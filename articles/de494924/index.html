<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛕 🚨 🐗 Die Implementierung des Aquarelleffekts in Spielen 👨🏽‍⚖️ 🤸 👞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung
 Als wir im Januar 2019 anfingen, über unser neues Farbspiel zu diskutieren . Wir haben sofort entschieden, dass der Aquarelleffekt das wic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Die Implementierung des Aquarelleffekts in Spielen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/494924/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9b/8bc/7c5/f9b8bc7c53c4d97ed983c428ce53926b.gif" alt="Bild"></div><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einführung</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als wir im Januar 2019 anfingen, über unser neues </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbspiel zu</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diskutieren </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;">.</font></em></a><font style="vertical-align: inherit;"> Wir haben sofort entschieden, dass der Aquarelleffekt das wichtigste Element ist. Inspiriert von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieser </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bulgari-</font></font></em></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"> Werbung</font></a><font style="vertical-align: inherit;"> stellten wir fest, dass die Umsetzung der Aquarellmalerei mit der hohen Qualität der verbleibenden Ressourcen, die wir erstellen wollten, vereinbar sein sollte. Wir haben einen interessanten Artikel von Forschern von Adobe gefunden </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die darin beschriebene Aquarelltechnik sah wunderbar aus und konnte aufgrund ihrer Vektor- (und nicht Pixel-) Natur auch auf schwachen Mobilgeräten funktionieren. Unsere Implementierung basiert auf dieser Studie. Wir haben Teile davon geändert und / oder vereinfacht, weil unsere Leistungsanforderungen unterschiedlich waren. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbton</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dies ist ein Spiel, daher mussten wir zusätzlich zur Zeichnung selbst die gesamte 3D-Umgebung rendern und die Spielelogik in einem Frame ausführen. </font><font style="vertical-align: inherit;">Wir wollten auch sicherstellen, dass die Simulation in Echtzeit durchgeführt wurde und der Spieler sofort sah, was gezeichnet wurde.</font></font><br>
<a name="habracut"></a><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e8/277/d95/2e8277d95ed5a29796176e375ecf59c5.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquarellsimulation in Farbton. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel werden wir die einzelnen Details der Implementierung dieser Technik in der Unity-Spiel-Engine teilen und darüber sprechen, wie wir sie so angepasst haben, dass sie nahtlos auf Low-End-Mobilgeräten funktioniert. </font><font style="vertical-align: inherit;">Wir werden mehr über die Hauptphasen dieses Algorithmus sprechen, ohne jedoch den Code zu demonstrieren. </font><font style="vertical-align: inherit;">Diese Implementierung wurde in Unity 2018.4.2 erstellt und später auf Version 2018.4.7 aktualisiert.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist Farbton?</font></font></h1><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbton</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dies ist ein Puzzlespiel, mit dem der Spieler die Level abschließen und die Farben der Aquarelle so mischen kann, dass sie den Farben des Origamis entsprechen. </font><font style="vertical-align: inherit;">Das Spiel wurde im Herbst 2019 bei Apple Arcade für iOS, macOS und tvOS veröffentlicht.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/630/d46/bb0630d469679d86535ec46fd97c8f0a.png" width="2224" height="1668"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Screenshot-Farbton.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bedarf</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die in meinem Artikel beschriebene Technik kann in drei Hauptstufen unterteilt werden, die in jedem Frame ausgeführt werden:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generiere neue Spots basierend auf Spielereingaben und füge sie der Spotliste hinzu</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malsimulation für alle Stellen auf der Liste</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spot-Rendering</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Folgenden werden wir detailliert darüber sprechen, wie wir die einzelnen Phasen implementiert haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wollten 60 FPS erreichen, dh diese Stufen und die gesamte unten beschriebene Logik werden 60 Mal pro Sekunde ausgeführt.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Input bekommen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In jedem Frame transformieren wir die Eingabe des Players (abhängig von der Plattform kann es sich um eine Berührung, die Position der Maus oder den virtuellen Cursor handeln) in eine </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatData-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur </font><font style="vertical-align: inherit;">, die Position, Bewegungsvektor, Farbe und Druck enthält (2). Zuerst überprüfen wir die Schlaglänge des Spielers auf dem Bildschirm und vergleichen sie mit einem bestimmten Schwellenwert. Mit kurzen Wischbewegungen erzeugen wir einen Punkt pro Frame an der Eingabeposition. Im umgekehrten Fall füllen wir den Abstand zwischen dem Start- und dem Endpunkt des Wischens des Spielers mit neuen Punkten, die mit einer vorgegebenen Dichte erstellt wurden (dies gewährleistet eine konstante Farbdichte unabhängig von der Wischgeschwindigkeit). Die Farbe gibt die aktuell verwendete Farbe an, und die Neigung der Bewegung gibt die Richtung des Wischens an. Erstellte neue Spots werden einer Sammlung namens </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatList hinzugefügt</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die auch alle zuvor erstellten Spots enthält. </font><font style="vertical-align: inherit;">Es wird verwendet, um Farbe in den folgenden Schritten zu simulieren und zu rendern. </font><font style="vertical-align: inherit;">Jeder einzelne Punkt kennzeichnet einen „Tropfen“ Farbe, der gerendert werden muss - den Hauptbaustein der Aquarellmalerei. </font><font style="vertical-align: inherit;">Die fertige Aquarellzeichnung ist das Ergebnis des Renderns von Dutzenden / Hunderten von sich überschneidenden Punkten. </font><font style="vertical-align: inherit;">Außerdem wird dem neu erstellten Spot der Wert der Lebensdauer (in Frames) zugewiesen, der bestimmt, wie lange der Spot simuliert werden kann.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ccb/e15/628/ccbe15628a553ba6ceb25af2fd2e2e36.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Beispiel für die Interpolation langer Wischpunkte. </font><font style="vertical-align: inherit;">Hohlkreise kennzeichnen Punkte, die in regelmäßigen Abständen erzeugt werden.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segeltuch</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie echte Farbe brauchen wir eine Leinwand. </font><font style="vertical-align: inherit;">Um dies zu implementieren, haben wir einen begrenzten Bereich im 3D-Raum erstellt, der wie ein Blatt Papier aussieht. </font><font style="vertical-align: inherit;">Die Eingabekoordinaten des Players und alle anderen Vorgänge, z. B. das Rendern eines Netzes, werden im Canvas-Bereich aufgezeichnet. </font><font style="vertical-align: inherit;">In ähnlicher Weise hängt die Größe eines Puffers, der zum Simulieren des Zeichnens verwendet wird, in Pixel von der Größe der Leinwand ab. </font><font style="vertical-align: inherit;">Der in diesem Artikel verwendete Begriff "Canvas" ist in keiner Weise mit der Canvas-Klasse von Unity UI verknüpft.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/648/367/1cc/6483671ccaa809a93bcf2a276cdd2471.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das grüne Rechteck zeigt den Leinwandbereich im Spiel</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stelle</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Optisch wird der Punkt durch ein rundes Netz dargestellt, dessen Rand aus 25 Eckpunkten besteht. Sie können es als „Tropfen“ wahrnehmen, den ein nasser Pinsel auf einem Stück Papier hinterlässt, wenn Sie es für einen sehr kurzen Moment berühren. Wir fügen der Position jedes Scheitelpunkts einen kleinen zufälligen Versatz hinzu, der die Ungleichmäßigkeit der Kanten der Farbflecken sicherstellt.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/baa/daa/9bbbaadaaf2b6d0fc1b295f5739ff083.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiele für Maschennetze.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Für jeden Scheitelpunkt speichern wir auch den Geschwindigkeitsvektor nach außen, der dann in der Simulationsphase verwendet wird. Wir generieren mehrere solcher Netze mit kleinen Abweichungen zwischen den Formularen und speichern ihre Daten in einem skriptuemy-Objekt ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einem skriptfähigen Objekt</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Jedes Mal, wenn ein Spieler in Echtzeit einen Punkt zeichnet, weisen wir ihm ein zufällig aus diesem Satz ausgewähltes Netz zu. Es ist erwähnenswert, dass die Leinwand bei unterschiedlichen Bildschirmauflösungen eine unterschiedliche Größe in Pixel hat. Damit auf allen Geräten der Koeffizient der Größe der Spots gleich ist, ändern wir zu Beginn des Spiels die Skalierung entsprechend der Größe der Leinwand.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1af/f92/8de/1aff928de51a35f64351fe72f5c10d80.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Beispiel für Punktvektoren, die mit neuen Punktdaten gespeichert wurden.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wenn ein Punktnetz erzeugt wird, speichern wir auch seinen „Benetzungsbereich“, der eine Reihe von Pixeln definiert, die sich innerhalb der ursprünglichen Punktgrenzen befinden. Der Benetzungsbereich wird verwendet, um die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advektion</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu simulieren </font><font style="vertical-align: inherit;">. Während der Ausführung der Anwendung zum Zeitpunkt der Erstellung jedes neuen Spots markieren wir die Leinwand darunter als nass. Wenn wir die Bewegung von Farbe simulieren, lassen wir sie sich über die Bereiche der Leinwand „ausbreiten“, die bereits nass geworden sind. Wir speichern den Feuchtigkeitsgehalt der Leinwand im globalen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wetmap-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puffer </font><font style="vertical-align: inherit;">, der aktualisiert wird, wenn jeder neue Punkt hinzugefügt wird. Neben der Teilnahme am Mischen zweier Farben spielt die Advektion eine wichtige Rolle für das endgültige Erscheinungsbild des Malstrichs.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/843/67e/31d84367e786d15bd7fe0f59cbe2e3a5.jpg"></div><br>
<i><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wetmap-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Füllung </font><font style="vertical-align: inherit;">, Pixel innerhalb der </font><em><font style="vertical-align: inherit;">Punktform</font></em><font style="vertical-align: inherit;"> (grüner Kreis) markieren den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wetmap-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puffer </font><font style="vertical-align: inherit;">(Raster) als nass (grün). </font><font style="vertical-align: inherit;">Der Wetmap-Puffer selbst hat eine viel höhere Auflösung. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich enthält jeder Punkt einen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opazitätswert</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der eine Funktion seiner Fläche ist. </font><font style="vertical-align: inherit;">es repräsentiert den Effekt der Speicherung von Pigment (eine konstante Menge an Pigment im Fleck). </font><font style="vertical-align: inherit;">Wenn die Größe eines Spots während der Simulation zunimmt, nimmt seine Deckkraft ab und umgekehrt.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a88/870/a5b/a88870a5b213286e20815f3b87ecca5d.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Beispiel für Farbe ohne Advektion (links) und damit (rechts).</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/341/069/348/341069348c265951c765843ca792b2c8.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiele für Farbvorschub.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simulationszyklus</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem die Eingabe des Players im aktuellen Frame empfangen und in neue Spots konvertiert wurde, besteht der nächste Schritt darin, die Spots zu simulieren, um die Verbreitung von Aquarellen zu simulieren. Zu Beginn dieser Simulation haben wir eine Liste der Punkte, die aktualisiert werden müssen, und eine aktualisierte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wetmap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In jedem Frame gehen wir die Liste der Punkte um und ändern die Positionen aller Eckpunkte der Punkte unter Verwendung der folgenden Gleichung:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6fe/91a/4b86fe91ae4f677697b43e99a3299ecc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dabei gilt: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der neue Bewegungsvektor, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der konstante Korrekturparameter (0,33), </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der Bewegungssteigungsvektor = normalisierte Richtung des </font><font style="vertical-align: inherit;">Schlagens </font><font style="vertical-align: inherit;">des Spielers multipliziert mit 0,3, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der Skalarwert der Leinwandrauheit = Random.Range (1,1 + r), </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der globale Rauheitsparameter, für Standardfarbe setzen wir ihn auf 0,4, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der Geschwindigkeitsvektor, der im Voraus mit dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Punktnetz erstellt wurde</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><b><font style="vertical-align: inherit;">vm</font></b><font style="vertical-align: inherit;"> ist der Geschwindigkeitsfaktor, der Skalarwert, den wir in einigen Situationen lokal verwenden, um die Advektion zu beschleunigen, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x (t +) 1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - mögliche neue Scheitelpunktposition, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x (t)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - aktuelle Scheitelpunktposition, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">br</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist der Verzweigungsrauheitsvektor = (Random.Range (-r, r), Random.Range (-r, r)), ist </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w (x)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Benetzungswert im Wetmap-Puffer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis solcher Gleichungen wird als </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voreingenommener Zufallslauf bezeichnet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es ahmt das Verhalten von Partikeln in echten Aquarellfarben nach. Wir versuchen, jeden Scheitelpunkt des Punkts von seiner Mitte ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">nach außen zu bewegen </font><font style="vertical-align: inherit;">, um Zufälligkeit hinzuzufügen. Dann ändert sich die Bewegungsrichtung geringfügig mit der Richtung des Strichs ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und wird erneut durch eine andere Rauheitskomponente ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">br</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">randomisiert </font><font style="vertical-align: inherit;">. Dann wird diese neue Scheitelpunktposition mit einer </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wetmap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verglichen </font><font style="vertical-align: inherit;">. Wenn die Leinwand an der neuen Position bereits nass war (Wert im </font><em><font style="vertical-align: inherit;">Wetmap-</font></em><font style="vertical-align: inherit;"> Puffer</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">größer als 0), dann geben wir dem Scheitelpunkt eine neue Position </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x (t + 1)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , andernfalls ändern wir seine Position nicht. </font><font style="vertical-align: inherit;">Infolgedessen verteilt sich die Farbe nur in den Bereichen der Leinwand, die bereits nass waren. </font><font style="vertical-align: inherit;">In der letzten Phase berechnen wir den Spotbereich neu, der im Renderzyklus verwendet wird, um seine Deckkraft zu ändern.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a69/742/ae4/a69742ae4ee6d91b27bac6397bd317ff.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mikroskaliges Beispiel einer Advektionssimulation zwischen zwei aktiven Farbflecken.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderzyklus - Nasspuffer</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem Sie die Spots nachgezählt haben, können Sie mit dem Rendern beginnen. Am Ausgang nach der Emulationsphase stellt sich heraus, dass das Netz der Punkte häufig deformiert ist (es treten beispielsweise Schnittpunkte auf). Daher verwenden wir für die korrekte Wiedergabe ohne zusätzliche Kosten für die wiederholte Triangulation eine Lösung mit Schablonenpuffer mit zwei Durchgängen. Die Unity </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphics-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeichenoberfläche wird zum Rendern von Spots verwendet </font><font style="vertical-align: inherit;">, und der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderzyklus</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird innerhalb der Unity </font><em><font style="vertical-align: inherit;">OnPostRender-</font></em><font style="vertical-align: inherit;"> Methode ausgeführt </font><font style="vertical-align: inherit;">. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Punktnetze</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden gerendert, um die Textur ( </font><em><font style="vertical-align: inherit;">WetBuffer</font></em><font style="vertical-align: inherit;"> ) mit einer separaten Kamera </font><font style="vertical-align: inherit;">zu rendern </font><font style="vertical-align: inherit;">. Zu Beginn des Zyklus wird </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gelöscht und mithilfe von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphics.SetRenderTarget (wetBuffer) als Renderziel festgelegt</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Weiter für jeden aktiven Spot aus </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatList</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir führen die im folgenden Diagramm gezeigte Sequenz aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e7/a09/328/1e7a0932807463744d7fd50a40fddedc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderzyklusdiagramm. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir beginnen mit der Reinigung des Schablonenpuffers vor jedem Punkt, damit der Zustand des Schablonenpuffers des vorherigen Punkts den neuen Punkt nicht beeinflusst. </font><font style="vertical-align: inherit;">Dann wählen wir das Material aus, mit dem der Punkt gezeichnet wird. </font><font style="vertical-align: inherit;">Dieses Material ist für die Farbe des Spots verantwortlich und wir wählen es basierend auf dem Farbindex aus, der in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gespeichert wurde, </font><font style="vertical-align: inherit;">als der Spieler </font><em><font style="vertical-align: inherit;">den</font></em><font style="vertical-align: inherit;"> Spot </font><em><font style="vertical-align: inherit;">gezeichnet hat</font></em><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dann ändern wir die Farbopazität (Alphakanal) basierend auf der im vorherigen Schritt berechneten Fläche des Punktnetzes. </font><font style="vertical-align: inherit;">Das Rendern selbst wird mit einem Schablonenpuffer-Shader mit zwei Durchgängen durchgeführt. </font><font style="vertical-align: inherit;">Im ersten Durchgang (Material.SetPass (0)) übergeben wir das ursprüngliche Punktnetz, um die Koordinaten aufzuzeichnen, in die das Netz gefüllt ist. </font><font style="vertical-align: inherit;">Mit diesem Pass </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ColorMask</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hat den Wert 0 zugewiesen, sodass das Netz selbst nicht gerendert wird. </font><font style="vertical-align: inherit;">Im zweiten Durchgang (Material.SetPass (1)) verwenden wir das um das Punktnetz beschriebene Viereck. </font><font style="vertical-align: inherit;">Wir überprüfen den Wert im Schablonenpuffer für jedes Pixel des Vierecks; </font><font style="vertical-align: inherit;">Wenn der Wert eins ist, wird das Pixel gerendert, andernfalls wird es übersprungen. </font><font style="vertical-align: inherit;">Als Ergebnis dieser Operation rendern wir dieselbe Form wie das Punktnetz, aber es enthält sicherlich keine unerwünschten Artefakte, z. B. Selbstüberschneidungen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a9/06b/beb/1a906bbeb3f003d057430f6fb28e9257.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Verfahren zur Durchführung der Doppelschablonenpuffertechnik (von links nach rechts). </font><font style="vertical-align: inherit;">Beachten Sie, dass dieser Schablonenpuffer eine viel höhere Auflösung als gezeigt hat, sodass er seine ursprüngliche Form mit großer Genauigkeit beibehalten kann.</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/15d/3ae/ed515d3aec23cd4eb9041761913afd2c.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Beispiel für drei sich überschneidende Punkte, die auf herkömmliche Weise gerendert wurden, was zum Auftreten von Artefakten führte (links) und die Verwendung der Zwei-Pass-Schablonenpuffertechnik unter Eliminierung aller Artefakte (rechts).</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nachdem alle Spots in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WetBuffer gerendert wurden, wird</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es in der Spielszene angezeigt. Unsere Leinwand verwendet einen provisorischen Shader, der einen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , eine diffuse Papierkarte und eine normale Papierkarte </font><font style="vertical-align: inherit;">kombiniert </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/968/db5/55a/968db555a2a477134013c355e3898e90.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canvas-Shader: nur WetBuffer (links), hinzugefügte Papierstruktur (Mitte), normale Karte hinzugefügt (rechts). </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Spiel unterstützt einen Modus für Menschen mit Farbenblindheit, in dem separate Muster über die Farbe gelegt werden. </font><font style="vertical-align: inherit;">Um dies zu erreichen, haben wir das Material der Flecken geändert, indem wir die Textur des Musters mit Kacheln hinzugefügt haben. </font><font style="vertical-align: inherit;">Muster folgen den Regeln zum Mischen der Farben des Spiels, z. B. Blau (Balken) + Gelb (Kreise) ergeben Grün (Kreise in den Balken) an der Kreuzung. </font><font style="vertical-align: inherit;">Um Muster nahtlos zu mischen, müssen sie im selben UV-Raum gerendert werden. </font><font style="vertical-align: inherit;">Wir passen die UV-Koordinaten des im zweiten Durchgang des Schablonenpuffers verwendeten Vierecks an und teilen die x- und y-Positionen (die im Canvas-Bereich angegeben sind) durch die Breite und Höhe der Canvas. </font><font style="vertical-align: inherit;">Als Ergebnis erhalten wir die korrekten Werte von u, v im Raum von 0 bis 1.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b5/057/211/7b50572119f116fae451dd321275a920.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Beispiel für Farbenblindheitsmuster.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimierung - Puffer für getrocknete Stellen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie oben erwähnt, bestand eine unserer Aufgaben darin, mobile Geräte mit geringem Stromverbrauch zu unterstützen. </font><font style="vertical-align: inherit;">Spot-Rendering stellte sich als Engpass unseres Spiels heraus. </font><font style="vertical-align: inherit;">Jeder Punkt erfordert drei Zeichenaufrufe (zwei Durchgänge aufrufen + Schablonenpuffer löschen). Da die Mallinie zehn oder Hunderte von Punkten enthält, steigt die Anzahl der Zeichenaufrufe schnell an und führt zu einem Rückgang der Bildrate. </font><font style="vertical-align: inherit;">Um dies zu bewältigen, haben wir zwei Optimierungstechniken angewendet: erstens das gleichzeitige Zeichnen aller „getrockneten“ Punkte in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und zweitens die lokale Beschleunigung des Trocknens der Punkte nach Erreichen einer bestimmten Anzahl aktiver Punkte. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wird dem Renderzyklus eine zusätzliche Rendertextur hinzugefügt. Wie bereits erwähnt, hat jeder Spot eine Lebensdauer (in Frames), die mit jedem Frame abnimmt. Nachdem die Lebensdauer 0 erreicht hat, gilt der Fleck als „ausgetrocknet“. Trockene Stellen werden nicht mehr simuliert, ihre Form ändert sich nicht und daher müssen sie nicht in jedem Frame erneut gerendert werden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/afe/714/b44afe714c3be2aed6d853d031e2379a.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DryBuffer in Aktion; Die grauen Flecken zeigen die in dryBuffer kopierten Flecken.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Jeder Punkt , </font><font style="vertical-align: inherit;">deren Lebensdauer erreicht 0 von dem entfernt </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatList</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und „kopiert“ zu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Während des Kopiervorgangs wird der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderzyklus</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wiederverwendet, und diesmal wird </font><em><font style="vertical-align: inherit;">dryBuffer</font></em><font style="vertical-align: inherit;"> als Ziel- </font><em><font style="vertical-align: inherit;">Rendertextur</font></em><font style="vertical-align: inherit;"> festgelegt </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das richtige Mischen zwischen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann nicht durch einfaches Überlappen der Puffer im Canvas-Shader erreicht werden, da die </font><em><font style="vertical-align: inherit;">Rendertextur</font></em><font style="vertical-align: inherit;"> des </font><em><font style="vertical-align: inherit;">WetBuffer-</font></em><font style="vertical-align: inherit;"> Puffers</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält Spots, die bereits mit dem Alpha-Wert gerendert wurden (was vormultipliziertem Alpha entspricht). </font><font style="vertical-align: inherit;">Wir haben dieses Problem umgangen, indem wir dem Start des Renderzyklus einen Schritt hinzugefügt haben, bevor wir die Spots iterativ durchlaufen haben. </font><font style="vertical-align: inherit;">Zu diesem Zeitpunkt rendern wir ein Viereck von der Größe einer Kamera- </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trimmpyramide</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die </font><em><font style="vertical-align: inherit;">dryBuffer</font></em><font style="vertical-align: inherit;"> anzeigt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dank dessen wird jeder Fleck, der in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gerendert </font><font style="vertical-align: inherit;">wird, bereits mit trockenen, zuvor gestrichenen Flecken gemischt.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24e/afe/417/24eafe41762bcd3e7b2363e78c8bb9c0.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Mischung aus nassen und getrockneten Stellen. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puffer </font><font style="vertical-align: inherit;">sammelt alle "getrockneten" Stellen und wird zwischen den Frames nicht gelöscht. </font><font style="vertical-align: inherit;">Daher kann der gesamte Speicher, der abgelaufenen Flecken zugeordnet ist, gelöscht werden, nachdem sie in den Puffer „kopiert“ wurden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/aa0/5bd/00eaa05bd29ca5c46eb8a845accc0b75.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dank der Optimierung mit </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind die </font><em><font style="vertical-align: inherit;">Farbmengen</font></em><font style="vertical-align: inherit;"> , die ein Spieler auf die Leinwand </font><em><font style="vertical-align: inherit;">auftragen kann</font></em><font style="vertical-align: inherit;"> , nicht mehr begrenzt.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wenn Sie die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Technik </font><font style="vertical-align: inherit;">separat verwenden, kann der Spieler mit nahezu unendlich viel Farbe zeichnen, garantiert jedoch keine gleichbleibende Leistung. Wie oben erwähnt, hat der Malstrich eine konstante </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dicke</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die durch Zeichnen unter Interpolation vieler Punkte zwischen dem Start- und dem Endpunkt des Wischens erreicht wird. Bei vielen schnellen und langen Wischen kann der Spieler eine große Anzahl von aktiven Punkten erzeugen. Diese Spots werden simuliert und über die durch ihre Lebensdauer festgelegte Anzahl von Frames gerendert, was letztendlich zu niedrigeren Frameraten führt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um eine stabile Bildrate zu gewährleisten, haben wir den Algorithmus so geändert, dass die Anzahl der aktiven Spots durch einen konstanten Wert von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxActiveSplats begrenzt wurde</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Alle Flecken, die diesen Wert überschreiten, „trocknen“ sofort aus. Dies wird erreicht, indem die Lebensdauer der ältesten aktiven Spots auf 0 reduziert wird, weshalb sie früher in den Puffer für getrocknete Spots kopiert werden. Da wir, wenn wir die Lebensdauer verkürzen, einen Punkt im unvollständigen Zustand der Simulation erhalten (was sehr interessant aussehen wird), erhöhen wir gleichzeitig die Ausbreitungsgeschwindigkeit der Farbe. Aufgrund der Geschwindigkeitssteigerung erreicht der Spot fast die gleiche Größe wie bei normaler Geschwindigkeit mit einer normalen Lebensdauer.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/907/c68/4c9/907c684c9c3642f6a109b4cadcf8718c.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d79/fe2/72b/d79fe272b648131541bfbf423384fc29.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demonstration von maximal 40 (oben) und 80 (unten) aktiven Spots. </font><font style="vertical-align: inherit;">In dryBuffer kopierte getrocknete Stellen werden grau angezeigt. </font><font style="vertical-align: inherit;">Der Wert gibt die „Menge“ an Farbe an, die gleichzeitig simuliert werden kann. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Wert von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxActiveSplats</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der wichtigste Leistungsparameter. Er ermöglicht es uns, die Anzahl </font><font style="vertical-align: inherit;">der </font><em><font style="vertical-align: inherit;">Zeichenaufrufe</font></em><font style="vertical-align: inherit;"> , die wir dem Aquarell-Rendering zuweisen können, genau zu steuern. </font><font style="vertical-align: inherit;">Wir legen es beim Start fest, basierend auf der Plattform- und Geräteleistung. </font><font style="vertical-align: inherit;">Sie können diesen Wert auch während der Anwendungsausführung ändern, wenn eine Verringerung der Bildrate festgestellt wird.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Implementierung dieses Algorithmus ist zu einer interessanten und herausfordernden Aufgabe geworden. </font><font style="vertical-align: inherit;">Wir hoffen, dass die Leser den Artikel genossen haben. </font><font style="vertical-align: inherit;">Sie können Fragen in den Kommentaren zum </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Original stellen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn Sie unser Aquarell in Aktion schätzen möchten, versuchen Sie, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tönung zu spielen. </font><font style="vertical-align: inherit;">auf der Apple Arcade</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/959/89e/fda/95989efda4d27809e1ce3923b341ac46.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Screenshot eines Spiels, das auf Apple TV läuft</font></font></i><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1) S. DiVerdi, A. Krishnaswamy, R. MÄch und D. Ito, "Malen mit Polygonen: Eine prozedurale Aquarellmaschine", in IEEE Transactions on Visualization and Computer Graphics, vol. </font><font style="vertical-align: inherit;">19, nein. </font><font style="vertical-align: inherit;">5, pp. </font><font style="vertical-align: inherit;">723–735, Mai 2013. doi: 10.1109 / TVCG.2012.295 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(2) Der Druck wird nur beim Zeichnen des Apple Pencil auf einem iPad berücksichtigt.</font></font></blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de494912/index.html">Mein Beitrag zum Schutz gegen Covid-19</a></li>
<li><a href="../de494916/index.html">Wie man Händlerkonten verkauft und eine Welle des Interesses am Online-Geschäft auslöst</a></li>
<li><a href="../de494918/index.html">Die dritte Woche des Fernfluges. Bewertungen von IT-QIWI-Mitarbeitern über Vollzeitarbeit von zu Hause aus</a></li>
<li><a href="../de494920/index.html">Schlechter Rat an den Entwickler: Was tun, um das Management zufrieden zu stellen?</a></li>
<li><a href="../de494922/index.html">Nischni Nowgorod für einen IT-Spezialisten: Perspektiven für die Arbeit und Chancen für das Leben</a></li>
<li><a href="../de494938/index.html">Glücklicher Backup-Tag! Vergiss ihn nicht</a></li>
<li><a href="../de494940/index.html">DevOps - was ist das, warum und wie stark ist es gefragt?</a></li>
<li><a href="../de494942/index.html">CGI zu Hause mit Unreal Engine und iPhone</a></li>
<li><a href="../de494950/index.html">Einige Speichertrends, auf die Sie achten sollten</a></li>
<li><a href="../de494956/index.html">Datenbyte-Lebensdauer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>