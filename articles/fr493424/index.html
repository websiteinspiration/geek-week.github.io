<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëèüèº üöÇ ‚úåüèæ Nous impl√©mentons des conversions de code Python ü§û üà≤ üßñüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr. 
 
 Aujourd'hui, nous vous proposons la traduction d'un article qui aborde un sujet qui n'est pas le plus discut√©: compilation de code ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Nous impl√©mentons des conversions de code Python</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/493424/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour, Habr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aujourd'hui, nous vous proposons la traduction d'un article qui aborde un sujet qui n'est pas le plus discut√©: compilation de code en Python, √† savoir: travail avec arbre de syntaxe abstraite (AST) et code d'octet. Alors que Python est un langage interpr√©t√©, de telles fonctionnalit√©s sont extr√™mement importantes d'un point de vue d'optimisation. Nous en parlerons aujourd'hui.</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous √™tes-vous d√©j√† demand√© comment le compilateur optimise exactement votre code pour qu'il fonctionne plus rapidement? </font><font style="vertical-align: inherit;">Vous voulez savoir ce qu'est un arbre de syntaxe abstraite (AST) et √† quoi il peut servir? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet article de revue d√©crit comment le code Python est converti en arborescence (AST). </font><font style="vertical-align: inherit;">Apr√®s avoir construit l'AST de votre programme, vous pouvez passer √† la recherche d'opportunit√©s pour optimiser et transformer votre code. </font><font style="vertical-align: inherit;">Cependant, gardez √† l'esprit qu'il est </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extr√™mement difficile d'</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> optimiser les programmes Python de mani√®re non triviale </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code de programme sous forme d'arbre</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment un ordinateur peut-il s'assurer qu'il √©value les expressions de votre code dans le bon ordre? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ce faire, il refait d'abord le code de votre programme dans une arborescence appel√©e AST. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque vous travaillez avec un langage de programmation interpr√©t√© (tel que Python), il est g√©n√©ralement admis que l'interpr√®te passe par votre code et fait tout ce qu'il rencontre, directement sur place, sans convertir le code Python en code machine de quelque fa√ßon que ce soit. Cependant, dans la pratique, ce sch√©ma d'ex√©cution provoque de nombreux probl√®mes, ce qui le rend tr√®s g√™nant. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenons, par exemple, un probl√®me aussi simple que la priorit√© des op√©rateurs. Dans une expression de vue </font></font><code>3 + 4 * x </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la pi√®ce est d'abord calcul√©e</font></font><code>4 * x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et alors seulement 3 peut √™tre ajout√© au r√©sultat de la multiplication. Peut-√™tre avez-vous appris la priorit√© des op√©rateurs dans les cours de math√©matiques en dessinant ces arbres sous l'expression: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xw/lr/sp/xwlrspwopyld8gohdzt4jxgwauu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python utilise les r√®gles standard de la notation math√©matique (d'abord, la multiplication, puis l'addition). Afin de ne pas confondre quoi que ce soit avec la priorit√© des op√©rateurs, en Python, au d√©but, il est construit un tel arbre que dans l'image pr√©c√©dente. L'op√©ration g√©n√©rale est l'addition (√† la racine de l'arbre), et tandis que le c√¥t√© gauche de cette somme est un nombre r√©gulier, √† droite, nous avons le produit. La structure de donn√©es r√©sultante ressemble √† ceci:</font></font><br>
<br>
<pre><code class="python hljs">BinOp(<font></font>
  left  = Num(<span class="hljs-number">3</span>),<font></font>
  op    = Add(),<font></font>
  right = BinOp(<font></font>
            left  = Num(<span class="hljs-number">4</span>),<font></font>
            op    = Mult(),<font></font>
            right = Name(<span class="hljs-string">'x'</span>)<font></font>
          )<font></font>
)<font></font>
</code></pre><br>
<code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">signifie op√©ration binaire (op√©ration binaire) et indique que dans les op√©rations telles que l'addition et la multiplication - deux op√©randes. Naturellement, vous n‚Äôobtiendrez aucun ajout si la bonne partie de l‚Äôexpression n‚Äôa pas la valeur correcte. Par cons√©quent, vous devez d‚Äôabord multiplier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la th√©orie des compilateurs et des langages de programmation, un tel arbre est appel√© </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstract Syntax Tree</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ou </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AST</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour faire court. L'AST dans l'exemple ci-dessus comprend deux n≈ìuds </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, deux n≈ìuds </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et un n≈ìud </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe une fonctionnalit√© int√©ressante dans Python - la possibilit√© de visualiser et d'afficher directement AST pour n'importe quel programme Python particulier. Il suffit d'importer un module standard</font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, analyser le programme, puis afficher le r√©sultat √† l'√©cran (soit dit en passant, l'analyse est le processus de conversion du code source du programme en arborescence AST).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
my_tree = ast.parse(<span class="hljs-string">"3 + 4*x"</span>)<font></font>
print(ast.dump(my_tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, vous remarquerez qu'il y aura des n≈ìuds et des champs suppl√©mentaires dans l'AST g√©n√©r√© par Python, et ils seront affich√©s sur une seule ligne, ce qui semble plus compliqu√© √† premi√®re vue qu'il ne l'est en r√©alit√©. </font></font><br>
<br>
<pre><code class="python hljs">Module(body=[Expr(value=BinOp(left=Num(n=<span class="hljs-number">3</span>), op=Add(), right=BinOp(left=Num(n=<span class="hljs-number">4</span>), op=Mult(), right=Name(id=<span class="hljs-string">'x'</span>, ctx=Load()))))])
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Divisons-le en n≈ìuds s√©par√©s, comme la derni√®re fois - et rouvrons l'AST, d√©j√† en haut, dans le cadre de l'arbre entier: </font></font><br>
<br>
<pre><code class="python hljs">Module(body = [<font></font>
    Expr(<font></font>
        value = BinOp(<font></font>
            left  = Num(n=<span class="hljs-number">3</span>),<font></font>
            op    = Add(),<font></font>
            right = BinOp(<font></font>
                left  = Num(n=<span class="hljs-number">4</span>),<font></font>
                op    = Mult(),<font></font>
                right = Name(id=<span class="hljs-string">'x'</span>, ctx=Load())<font></font>
            )<font></font>
        )<font></font>
    )<font></font>
])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De toute √©vidence, Python ¬´pense¬ª que la ligne que nous lui avons donn√©e pour l'analyse est un module entier. Le corps du module est une liste de toutes les instructions qu'il contient. La seule instruction dans notre exemple est une expression </font></font><code>Expr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dont le sens est exactement ce que nous avons discut√© ci-dessus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remarque: le n≈ìud </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a un champ suppl√©mentaire </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(abr√©g√© en ¬´contexte¬ª), qui a une valeur </font></font><code>Load()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Donc, Python dit que nous utilisons la valeur stock√©e dans la variable </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et non pas (re) d√©finir ou supprimer le nom </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. √Ä pr√©sent, essayez d'analyser quelque chose comme </font></font><code>del x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font><font style="vertical-align: inherit;">vous </font></font><code>x = 123</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">m√™me </font><font style="vertical-align: inherit;">, et vous verrez comment le champ </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">du n≈ìud se </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transforme en </font></font><code>Del()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>Store()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, respectivement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au fait: si vous installez le module</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">astunparse</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la sortie AST vers l'√©cran peut √™tre rendue beaucoup plus belle, et m√™me reconvertir l'AST en code Python en direct.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le processus de compilation: le reste</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s avoir collect√© les programmes AST, il est en principe possible de terminer l'ensemble du programme en passant par l'AST et en effectuant les op√©rations dans l'ordre dans lequel elles sont indiqu√©es. Cependant, cette approche pr√©sente au moins deux inconv√©nients. Premi√®rement, AST peut occuper une quantit√© de m√©moire relativement importante, surtout si elle contient des informations redondantes. Deuxi√®mement, la travers√©e AST peut prendre plus de temps que n√©cessaire. En bref: cela peut √™tre fait, mais c'est inefficace. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le compilateur ne traite pas directement l'AST, mais pr√©pare le bytecode, qui est ensuite ex√©cut√© sur la machine virtuelle Python. Bien que la discussion des d√©tails de ce processus d√©passe le cadre de cet article, le principe de base est que le compilateur traduit l'AST en notation polonaise invers√©e (RPN). Au lieu de mettre un op√©rateur</font></font><code>+</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entre les op√©randes gauche et droite, nous le mettons apr√®s les deux op√©randes. Dans l'exemple </font></font><code>3 + 4*x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ci-dessus, nous obtenons la s√©quence </font></font><code>3 4 x * +</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(et cette notation est particuli√®rement bonne car vous pouvez imm√©diatement voir √† partir de la s√©quence: vous devez d'abord effectuer la multiplication, puis seulement l'addition). √âtant donn√© que chacun des cinq √©l√©ments de cette s√©quence peut en principe √™tre repr√©sent√© comme un seul octet, un tel code est appel√© code d'octets. Python utilise ensuite la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">machine virtuelle empil√©e</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour ex√©cuter efficacement ce code.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En d'autres termes, le processus de compilation d'un programme √©crit en Python se d√©roule en deux √©tapes. </font><font style="vertical-align: inherit;">Tout d'abord, le programme re√ßu par l'entr√©e est analys√© et le r√©sultat est un arbre de syntaxe abstraite (AST). </font><font style="vertical-align: inherit;">Le compilateur passe ensuite par AST et g√©n√®re un bytecode. </font><font style="vertical-align: inherit;">Apr√®s cela, l'interpr√©teur Python ex√©cute ce bytecode. </font><font style="vertical-align: inherit;">Une fois optimis√©, il peut √™tre appliqu√© au niveau AST ou au niveau bytecode. </font><font style="vertical-align: inherit;">Ces deux options ont leurs propres avantages et inconv√©nients. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, gardez √† l'esprit que m√™me si AST est courant dans toute impl√©mentation Python, le processus de traduction d'AST en bytecode peut √™tre diff√©rent, et dans certaines impl√©mentations Python, disons, JavaScript, plut√¥t que bytecode, peut √™tre g√©n√©r√© √† l'√©tape interm√©diaire.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paradigmes d'autres langages de programmation</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tous les langages de programmation n'utilisent pas la notation infixe, comme en Python. </font><font style="vertical-align: inherit;">Deux exemples √† noter dans ce cas sont PostScript, o√π le programme est √©crit directement en notation polonaise inverse, et Lisp, bien s√ªr, o√π les programmes sont g√©n√©ralement √©crits en notation polonaise. </font><font style="vertical-align: inherit;">Ainsi, notre expression de l'exemple ci - </font><font style="vertical-align: inherit;">dessus, Lisp prendrait la forme suivante: </font></font><code>(+ 3 (* 4 x))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conversion de n≈ìuds dans AST</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ayant un programme AST, comment convertir des parties individuelles de cet arbre? Avec les fonctionnalit√©s int√©gr√©es pratiques de Python. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous regardons AST et, par exemple, constatons que les champs </font></font><code>left</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et les </font></font><code>right</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n≈ìuds </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont des nombres (n≈ìuds </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), nous pouvons effectuer les calculs correspondants √† l'avance, puis les remplacer par un </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n≈ìud normal </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien s√ªr, vous devez agir tr√®s soigneusement afin de ne pas changer le comportement du programme, en faisant de telles transformations. Par exemple, dans </font></font><code>len([a(), b(), c(), d()])</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il est clair que le r√©sultat est 4. Mais nous ne pouvons pas remplacer tout l'expression du nombre 4 parce que quatre fonctions </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ont toujours invoqu√© correctement.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encore une fois, commencez par une optimisation simple. Partout o√π un nom appara√Æt dans le code source d'un programme </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, remplacez-le par la valeur 3.14159265. Le module Python </font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fournit d√©j√† les structures de donn√©es n√©cessaires pour ce faire: une classe de convertisseur </font></font><code>NodeTransformer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui passe par tous les AST et v√©rifie pour chaque n≈ìud s'il peut √™tre remplac√©. Par d√©faut, la m√©thode de transformation renvoie simplement le n≈ìud source pour chaque n≈ìud, afin que nous obtenions le m√™me AST √† partir duquel nous avons commenc√©. Mais nous pouvons facilement remplacer la m√©thode pour les n≈ìuds </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, par exemple, afin qu'il v√©rifie </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si c'est le cas, puis renvoie le n≈ìud </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au lieu du n≈ìud avec le nom d'origine ...</font></font><br>
<br>
<pre><code class="python hljs">	<span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyOptimizer</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:
            <span class="hljs-keyword">return</span> ast.Num(n=<span class="hljs-number">3.14159265</span>)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"y = 2 * pi"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
print(ast.dump(tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour que le convertisseur / optimiseur passe par notre arbre, il est n√©cessaire d'appeler sa m√©thode </font></font><code>visit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui retournera alors un nouvel arbre modifi√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malheureusement, il est impossible de compiler et d'ex√©cuter l'AST r√©sultant, la raison en est un d√©tail technique. Ce n'est pas encore visible, mais (presque) tous les n≈ìuds de l'AST ont √©galement des champs </font></font><code>lineno</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>col_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ils indiquent la position exacte d'un n≈ìud particulier dans le code source. Si vous ne les installez pas correctement, le compilateur jurera et refusera de fonctionner. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Copions donc les champs appropri√©s du n≈ìud source </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vers le nouveau n≈ìud </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Vous pouvez ensuite compiler et ex√©cuter l'AST r√©sultant:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyOptimizer</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)<font></font>
            result.lineno = node.lineno<font></font>
            result.col_offset = node.col_offset<font></font>
            <span class="hljs-keyword">return</span> result
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"print(2 * pi)"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
code = compile(tree, <span class="hljs-string">"&lt;string&gt;"</span>, <span class="hljs-string">"exec"</span>)<font></font>
exec(code)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remarque: la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compilation de la </font><font style="vertical-align: inherit;">fonction</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√©cessite non seulement le code source (dans lequel peut √™tre un programme lui - </font><font style="vertical-align: inherit;">m√™me, ou la ligne AST), mais le nom du fichier (comme nous avons demand√© </font></font><code>"&lt;string&gt;"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), ainsi que l' </font><font style="vertical-align: inherit;">un des trois: </font></font><code>"exec"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>"eval"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>"single"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La n√©cessit√© de copier les champs d√©crivant la position du n≈ìud dans le code source se pose assez souvent. Par cons√©quent, le module </font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a une fonction d√©di√©e </font></font><code>copy_location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">juste √† cet effet, et nous pouvons √©crire:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)
            <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, vous pouvez √©tendre l'exemple pr√©c√©dent pour qu'il effectue r√©ellement l'optimisation, √† savoir sur le n≈ìud </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Selon la r√®gle de transformation, nous devons d'abord transformer / optimiser le n≈ìud gauche, puis le n≈ìud droit dans le cadre de BinOp. </font><font style="vertical-align: inherit;">Si, par cons√©quent, il s'av√®re que les n≈ìuds gauche et droit sont des nombres, les calculs peuvent √™tre effectu√©s directement sur place et remplacer l'original par le </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©sultat num√©rique de l'op√©ration.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVisitor</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_BinOp</span>(<span class="hljs-params">self, node: ast.BinOp</span>):</span><font></font>
        node.left = self.visit(node.left)<font></font>
        node.right = self.visit(node.right)<font></font>
        <span class="hljs-keyword">if</span> isinstance(node.left, ast.Num) <span class="hljs-keyword">and</span> isinstance(node.right, ast.Num):
            <span class="hljs-keyword">if</span> isinstance(node.op, ast.Add):<font></font>
                result = ast.Num(n = node.left.n + node.right.n)<font></font>
                <span class="hljs-keyword">return</span> ast.copy_location(result, node)
            <span class="hljs-keyword">elif</span> isinstance(node.op, ast.Mult):<font></font>
                result = ast.Num(n = node.left.n * node.right.n)<font></font>
                <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)
            <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"y = 2 * pi + 1"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
print(ast.dump(tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit dit en passant, le compilateur CPython optimise d√©j√† les n≈ìuds </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comme indiqu√© ici. </font><font style="vertical-align: inherit;">Le code correspondant est √©crit en C et est donn√© en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python / ast_opt.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Remarque: l'optimiseur CPython est plus universel et fonctionne non seulement avec des nombres, comme dans l'exemple que nous consid√©rons, mais avec diff√©rents types de valeurs constantes.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V√©rification des n≈ìuds dans AST</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment s'assurer que les transformations que nous avons effectu√©es √©taient correctes? Vous devez d'abord contourner compl√®tement AST et inspecter l'ensemble du programme. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'optimiseur pr√©sent√© ci-dessus reste un grave d√©faut. Que se passe-t-il si vous red√©finissez quelque part dans le programme </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Imaginez simplement quelque chose d'aussi simple et intelligible que </font></font><code>pi = 4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Notre optimiseur remplacera simplement pi sur le c√¥t√© gauche de l'expression par la valeur num√©rique 3.14159265, et Python refusera alors de compiler car il ne peut rien assigner √† une valeur litt√©rale. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est peut-√™tre pr√©cis√©ment le comportement que vous avez recherch√©, faisant de pi une vraie constante, qui est remplac√©e lors de la compilation et ne peut jamais √™tre r√©affect√©e, c'est-√†-dire qu'elle ne peut pas obtenir une valeur diff√©rente. Cependant, cela viole d√©finitivement la s√©mantique de Python.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors, que faire si nous voulons nous en tenir √† la s√©mantique de Python, mais remplacer pi quand m√™me dans la mesure du possible? Dans ce cas, vous devez d'abord parcourir l'ensemble du programme et v√©rifier si la valeur de est attribu√©e quelque part </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jusqu'√† ce que nous le compliquions: nous n'aurons pas recours au remplacement de pi si au moins un point du programme a une affectation de valeur √† </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous utilisons maintenant le n≈ìud visiteur, similaire au n≈ìud convertisseur d√©crit ci-dessus. Contrairement au convertisseur, le visiteur n'est pas destin√© √† changer les n≈ìuds, il passe simplement par l'AST et examine les n≈ìuds (les visite). Par cons√©quent, les m√©thodes de visite ne retournent rien. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre cas, nous v√©rifions si le n≈ìud se r√©f√®re </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et fait autre chose que le </font><font style="vertical-align: inherit;">chargement de </font><font style="vertical-align: inherit;">la valeur</font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(rappelez-vous le champ contextuel </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVisitor</span>(<span class="hljs-params">ast.NodeVisitor</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>
        self.modify_pi = <span class="hljs-literal">False</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_FunctionDef</span>(<span class="hljs-params">self, node: ast.FunctionDef</span>):</span>
        <span class="hljs-keyword">if</span> node.name == <span class="hljs-string">'pi'</span>:<font></font>
            self.modify_pi = <span class="hljs-literal">True</span><font></font>
        self.generic_visit(node)<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> isinstance(node.ctx, ast.Load):<font></font>
            self.modify_pi = <span class="hljs-literal">True</span><font></font>
 <font></font>
program = <span class="hljs-string">"""
def pi():
    return 3.1415
print(2 * pi())
"""</span><font></font>
tree = ast.parse(program)<font></font>
my_visitor = MyVisitor()<font></font>
my_visitor.visit(tree)<font></font>
print(<span class="hljs-string">"Pi modified:"</span>, my_visitor.modify_pi)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La m√©thode </font></font><code>generic_visit(node)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est appel√©e par le visiteur pour chaque n≈ìud pour lequel nous ne fournissons pas de m√©thode de visite sp√©cialis√©e. </font><font style="vertical-align: inherit;">En d'autres termes: il n'y a pas une telle m√©thode </font></font><code>visit_FunctionDef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la classe </font></font><code>NodeVisitor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que nous pourrions appeler using </font></font><code>super()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En ce qui concerne les d√©finitions de fonction, nous devons appeler un visiteur g√©n√©rique pour nous assurer que le corps entier de la fonction est √©galement trait√© correctement. </font><font style="vertical-align: inherit;">Sinon, nous pourrions masquer l'instruction dans la fonction </font></font><code>global pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et modifier globalement la valeur </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, afin que notre optimiseur ne remarque rien.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valeurs locales en Python</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre m√©thode, qui nous permet de d√©terminer si le programmeur a chang√© pi, s'est av√©r√©e plut√¥t grossi√®re. </font><font style="vertical-align: inherit;">Cependant, le compilateur Python agit de mani√®re tr√®s similaire lorsqu'il d√©termine quels noms dans la port√©e d'une fonction correspondent aux variables locales. </font><font style="vertical-align: inherit;">Si une variable change quelque part dans la port√©e de la fonction (et n'est pas explicitement rendue globale, par exemple, en utilisant l'instruction globale), alors cette variable est consid√©r√©e comme locale dans toute la port√©e de la fonction. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'exemple suivant s'ex√©cutera correctement sans la quatri√®me ligne. </font><font style="vertical-align: inherit;">Mais, bien que </font></font><code>x = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la quatri√®me ligne ne soit jamais ex√©cut√©e, elle est toujours consid√©r√©e comme une affectation √†</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et donc, x devient une variable locale √† l'√©chelle de la fonction enti√®re, et m√™me sur la ligne 3. C'est pourquoi Python jure que la variable x sur la troisi√®me ligne n'a pas encore d'importance.</font></font><br>
<br>
<pre><code class="python hljs">x = <span class="hljs-number">1</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_x</span>():</span><font></font>
    print(x)<font></font>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>: x = <span class="hljs-number">0</span>
print_x()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous √™tes int√©ress√© par les d√©tails du fonctionnement exact de Python ici, consultez </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python / symtable.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Python, comme dans la plupart des langages de programmation, un programme particulier n'est pas ex√©cut√© directement √† partir du code source. </font><font style="vertical-align: inherit;">En fait, la traduction du code source se d√©roule en deux √©tapes: d'abord, un arbre de syntaxe abstraite (AST) en est cr√©√©, puis du code d'octets pour la machine virtuelle empil√©e. </font><font style="vertical-align: inherit;">Python fournit √©galement un certain nombre de fonctionnalit√©s tr√®s int√©ressantes pour analyser et m√™me transformer l'AST d'un programme Python particulier, apr√®s quoi l'AST modifi√© peut √™tre compil√© et ex√©cut√©. </font><font style="vertical-align: inherit;">Ainsi, nous pouvons facilement impl√©menter nos propres optimisations.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien s√ªr, j'ai simplement omis de nombreux d√©tails ici. </font><font style="vertical-align: inherit;">S'assurer que votre optimisation fonctionnera correctement dans tous les cas et circonstances possibles est une question tr√®s simple. </font><font style="vertical-align: inherit;">Cependant, le but de cet article n'est pas de vous parler de l'optimisation pr√™te √† l'emploi en production, mais de donner une id√©e de base de la fa√ßon dont Python analyse votre code de programme afin que vous puissiez apprendre √† le convertir correctement, puis √† l'optimiser.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr493408/index.html">DJI Mavic mini copter est tomb√© comme un pied de biche</a></li>
<li><a href="../fr493412/index.html">Jeux avec Wifi sur ESP32</a></li>
<li><a href="../fr493416/index.html">IDA Pro et techniques d'ing√©nierie inverse</a></li>
<li><a href="../fr493418/index.html">Pourquoi l'apprentissage automatique utilise des donn√©es ¬´synth√©tiques¬ª</a></li>
<li><a href="../fr493420/index.html">Ma fa√ßon de pr√©senter Python √† des √©l√®ves du premier cycle du secondaire</a></li>
<li><a href="../fr493426/index.html">Organisation du code dans les microservices et mon approche de l'utilisation de l'architecture hexagonale et du DDD</a></li>
<li><a href="../fr493428/index.html">"Nous ne donnerons pas lieu √† des th√©ories du complot." Parlez de conf√©rences ML avec des gens des soci√©t√©s scientifiques et informatiques</a></li>
<li><a href="../fr493430/index.html">Architecture nette pour les applications Web</a></li>
<li><a href="../fr493432/index.html">Pourquoi ne pas commencer une carri√®re dans une petite entreprise non informatique</a></li>
<li><a href="../fr493436/index.html">Programme pour changer les droits d'acc√®s et enregistrer les noms de fichiers / r√©pertoires sur Bash</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>