<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐍 🤶 🧖🏿 コンテナー、マイクロサービス、サービスメッシュ ♑️ 💄 💇🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="インターネット上の束 記事 に関する サービスのメッシュ（サービスメッシュ）、そしてここで別の一つです。やったー！しかし、なぜ？それから、私の意見を述べたいのは、DockerやKubernetesなどのコンテナープラットフォームが登場する前の10年前にサービスメッシュが登場したほうがよいということで...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>コンテナー、マイクロサービス、サービスメッシュ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453204/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターネット上</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の束</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に関する</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスのメッシュ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（サービスメッシュ）、そしてここで別の一つです。</font><font style="vertical-align: inherit;">やったー！</font><font style="vertical-align: inherit;">しかし、なぜ？</font><font style="vertical-align: inherit;">それから、私の意見を述べたいのは、DockerやKubernetesなどのコンテナープラットフォームが登場する前の10年前にサービスメッシュが登場したほうがよいということです。</font><font style="vertical-align: inherit;">私の視点が他の視点よりも良いまたは悪いとは言いませんが、サービスメッシュは非常に複雑な動物であるため、視点の多様性は彼らの理解を深めるのに役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
100を超えるマイクロサービス上に構築され、コンテナで数千のアプリケーションをサポートするdotCloudプラットフォームについて説明します。</font><font style="vertical-align: inherit;">開発と立ち上げ時に発生した問題と、サービスメッシュがどのように役立つか（またはできないか）について説明します。</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dotCloudの歴史</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dotCloudの歴史とこのプラットフォームのアーキテクチャの選択についてはすでに書いていますが、ネットワークレベルについては少し話をしました。</font><font style="vertical-align: inherit;">dotCloudに関する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以前の記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を読みたくない場合は</font><font style="vertical-align: inherit;">、ここに簡単な要約を示します。これは、クライアントが幅広いデータサービス（MongoDB、 MySQL、Redis ...）とHerokuに似たワークフロー：コードをプラットフォームにアップロードし、コンテナーのイメージを構築してデプロイします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トラフィックがdotCloudプラットフォームにどのように転送されたかを説明します。</font><font style="vertical-align: inherit;">それは特にクールだったからではありません（システムは当時はうまく機能していましたが）。しかし、主に、モダンなツールの助けを借りて、マイクロサービスの束の間でトラフィックをルーティングする方法が必要な場合、適度なチームがそのような設計を短時間で簡単に実装できるためです。たくさんのアプリケーション。</font><font style="vertical-align: inherit;">したがって、オプションを比較できます。すべてを自分で開発した場合、または既存のサービスメッシュを使用した場合にどうなりますか。</font><font style="vertical-align: inherit;">標準的な選択：自分で行うか購入します。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ホストされたアプリケーションのトラフィックルーティング</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DotCloudアプリケーションは、HTTPおよびTCPエンドポイントを提供できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTPエンドポイントは</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hipache</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロードバランサクラスタ構成に動的に追加されます</font><font style="vertical-align: inherit;">。これは、</font><font style="vertical-align: inherit;">Kubernetes </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ingressの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リソース</font><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traefikの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ような</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ロードバランサーが今日行う</font></a><font style="vertical-align: inherit;">ことと似て</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">います</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドメイン名がdotCloudロードバランサーを指している場合、クライアントはそれぞれのドメインを介してHTTPエンドポイントに接続します。特にない。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCPエンドポイント</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はポート番号に関連付けられており、ポート番号は環境変数を通じてこのスタックのすべてのコンテナーに渡されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントは、適切なホスト名（gateway-X.dotcloud.comなど）とポート番号を使用してTCPエンドポイントに接続できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このホスト名は「nats」サーバークラスター（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NATSと</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は関係ありません</font><font style="vertical-align: inherit;">）に</font><font style="vertical-align: inherit;">解決されます。これにより</font><font style="vertical-align: inherit;">、着信TCP接続が正しいコンテナー（または、負荷分散されたサービスの場合は正しいコンテナー）にルーティングされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetesに精通している場合、これはおそらく</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NodePort</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスを思い出させます</font><font style="vertical-align: inherit;">。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">dotCloudプラットフォーム</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
には</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ClusterIP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスに相当するものはありません</font><font style="vertical-align: inherit;">でした。簡単にするために、サービスへのアクセスはプラットフォームの内外で同じでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが非常に単純に編成されました。HTTPおよびTCPルーティングネットワークの初期実装、おそらく数百行のPythonです。</font><font style="vertical-align: inherit;">プラットフォームの成長と追加の要件の出現で完成した単純な（私は、と言っても、素朴な）アルゴリズム。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
既存のコードの大規模なリファクタリングは必要ありませんでした。</font><font style="vertical-align: inherit;">特に、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12要素のアプリケーション</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、環境変数を通じて取得したアドレスを直接使用できます。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、最新のサービスメッシュとどのように異なりますか？</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
限られた</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可視性</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。通常、TCPルーティンググリッドのメトリックはありませんでした。 HTTPルーティングについては、後のバージョンでエラーコードと応答時間を含む詳細なHTTPメトリックが表示されましたが、最新のサービスメッシュはさらに進歩し、たとえばPrometheusなどのメトリック収集システムとの統合を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
運用の観点（問題のトラブルシューティングに役立つ）だけでなく、新機能がリリースされたときの可視性も重要です。安全な</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">青緑色のデプロイ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カナリアのデプロイについて</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルーティング効率</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">また限定されます。 dotCloudルーティンググリッドでは、すべてのトラフィックが専用ルーティングノードのクラスターを経由する必要がありました。これは、いくつかのAZの国境（アクセシビリティゾーン）を越える可能性と、遅延の大幅な増加を意味しました。ページごとに100を超えるSQLクエリを作成し、クエリごとにSQLサーバーへの新しい接続を開くコードの問題を修正した方法を覚えています。ローカルで起動すると、ページは瞬時に読み込まれますが、dotCloudでは、各TCP接続（およびその後のSQLクエリ）に数十ミリ秒かかるため、読み込みに数秒かかります。この特定のケースでは、永続的な接続が問題を解決しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最新のサービスメッシュは、このような問題に対して優れています。まず、接続が</font><i><font style="vertical-align: inherit;">ソースで</font></i><font style="vertical-align: inherit;">ルーティングさ</font><i><font style="vertical-align: inherit;">れて</font></i><font style="vertical-align: inherit;">いることを確認し</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。論理ストリームは同じです。</font></font><code> →  → </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ただし、メッシュはリモートノードではなくローカルで動作するため、接続</font></font><code> → </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はローカルで非常に高速です（ミリ秒ではなくマイクロ秒）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最新のサービスメッシュは、よりスマートな負荷分散アルゴリズムも実装しています。バックエンドのパフォーマンスを制御することで、より多くのトラフィックをより高速なバックエンドに送信できるため、全体的なパフォーマンスが向上します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セキュリティ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も優れています。 dotCloudルーティンググリッドはEC2 Classicで完全に機能し、トラフィックを暗号化しませんでした（誰かがEC2ネットワークトラフィックにスニファーを配置した場合、すでに大きな問題があると想定しています）。最新のサービスメッシュは、たとえば相互TLS認証とそれに続く暗号化など、すべてのトラフィックを透過的に保護します。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プラットフォームサービスのトラフィックルーティング</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、アプリケーション間のトラフィックについて説明しましたが、dotCloudプラットフォーム自体はどうですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラットフォーム自体は、さまざまな機能を担当する約100のマイクロサービスで構成されていました。</font><font style="vertical-align: inherit;">他の人からリクエストを受け取った人もいれば、他のサービスに接続したが接続を受け入れなかったバックグラウンドワーカーもいました。</font><font style="vertical-align: inherit;">いずれの場合も、各サービスは、接続する必要があるアドレスのエンドポイントを知っている必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの高レベルのサービスは、上記のルーティンググリッドを使用できます。実際、数百を超えるdotCloudマイクロサービスの多くは、dotCloudプラットフォーム自体に通常のアプリケーションとして展開されています。しかし、少数の低レベルサービス（特に、このルーティンググリッドを実装するもの）は、依存関係の少ない単純なものが必要でした（彼らは仕事のために自分自身に依存できなかったため、古き良き鶏と卵の問題です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの低レベルの重要なサービスは、いくつかの主要なノードでコンテナを直接実行することによって展開されました。同時に、標準のプラットフォームサービスは含まれていませんでした：リンカー、スケジューラー、ランナー。最新のコンテナープラットフォームと比較したい場合は、コントロールプレーンを</font></font><code>docker run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetesタスクを委任する代わりに、ノードで直接。これは、の概念にかなり似ている</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的モジュール（暖炉）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kubeadm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bootkube用途</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタンドアロンクラスタをロードします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのサービスはシンプルで大まかな方法​​で公開されました。それらの名前とアドレスはYAMLファイルにリストされていました。そして、各クライアントは、デプロイメントのためにこのYAMLファイルのコピーを取得する必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方では、Zookeeperなどの外部キー/値ストレージのサポートを必要としないため、非常に信頼性が高くなります（その時点では、etcdまたはConsulはまだ存在していません）。その一方で、サービスの移行が困難になりました。移動するたびに、すべてのクライアントは更新されたYAMLファイルを受信して​​いるはずです（そして場合によっては再起動する必要があります）。あまり快適ではありません！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、各クライアントがローカルプロキシサーバーに接続する新しいスキームの導入を開始しました。アドレスとポートの代わりに、サービスポート番号だけを知って接続するだけで十分です。</font></font><code>localhost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ローカルプロキシサーバーはこの接続を処理し、実際のサーバーにルーティングします。これで、バックエンドを別のマシンまたはスケーリングに移動するときに、すべてのクライアントを更新するのではなく、これらすべてのローカルプロキシのみを更新する必要があります。また、再起動は必要ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（また、TLS接続でトラフィックをカプセル化し、受信側に別のプロキシサーバーを配置し、受信サービスに参加せずにTLS証明書をチェックすることも計画されていました。これは接続のみを受け入れるように構成されています</font></font><code>localhost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">詳細は</font><font style="vertical-align: inherit;">後で説明します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは</font><font style="vertical-align: inherit;">Airbnbの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SmartStack</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とよく似て</font><font style="vertical-align: inherit;">いますが、dotCloudがDockerになったとき、内部のdotCloudルーティングシステムがボックスに入れられていたのに対して、SmartStackは本番環境に実装されてデプロイされるという大きな違いがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は個人的に、SmartStackはIstio、Linkerd、Consul Connectなどのシステムの前身の1つであると考えています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各ノードでプロキシを実行します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントはプロキシに接続します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">管理プレーンは、バックエンドを変更するときにプロキシ構成を更新します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...利益！</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスメッシュの最新の実装</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日同様のグリッドを実装する必要がある場合は、同様の原則を使用できます。</font><font style="vertical-align: inherit;">たとえば、サービス名を空間内のアドレスにマッピングして、内部DNSゾーンを構成します</font></font><code>127.0.0.0/8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次に、クラスターの各ノードでHAProxyを実行し、（このサブネット内の</font></font><code>127.0.0.0/8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">各サービスアドレスへの接続を受け入れ</font><font style="vertical-align: inherit;">、対応するバックエンドに負荷をリダイレクト/分散します。</font><font style="vertical-align: inherit;">HAProxy構成は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">confd</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって制御できます。これにより</font><font style="vertical-align: inherit;">、バックエンド情報をetcdまたはConsulに格納し、必要に応じて更新された構成をHAProxyに自動的にプッシュできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがIstioの仕組みです。</font><font style="vertical-align: inherit;">しかし、いくつかの違いがあります：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HAProxyの代わりに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Envoy Proxy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用し</font><font style="vertical-align: inherit;">ます。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etcdまたはConsulの代わりにKubernetes APIを介してバックエンド構成を保存します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスには、127.0.0.0 / 8ではなく、内部サブネット上のアドレス（Kubernetes ClusterIPアドレス）が割り当てられます。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これには、クライアントとサーバー間の相互TLS認証を追加するオプションのコンポーネント（Citadel）があります。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回路遮断、分散トレース、カナリアのデプロイなどの新機能をサポートします。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの違いを簡単に見てみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特使代理</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enftoy ProxyはLyftによって作成されました[タクシー市場でのUberの競合他社-約。トランス。それは多くの点で他のプロキシと非常に似ています（たとえば、HAProxy、Nginx、Traefik ...）。ただし、Lyftは他のプロキシにはない関数を必要とし、既存のものを拡張するよりも新しいものを作成するほうが合理的であると考えて独自に作成しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Envoyは単独で使用できます。他のサービスに接続する必要がある特定のサービスがある場合は、Envoyに接続するように構成してから、他のサービスの場所を使用してEnvoyを動的に構成および再構成すると同時に、可視性などの多くの優れた追加機能を利用できます。カスタムクライアントライブラリやコードにコールトラッキングを埋め込む代わりに、トラフィックをEnvoyに転送し、メトリックを収集します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、エンボイはまた、</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッシュのサービス用の</font><i><font style="vertical-align: inherit;">データプレーン</font></i><font style="vertical-align: inherit;">（データプレーン）。</font><font style="vertical-align: inherit;">つまり、このサービスメッシュでは、Envoyが</font><font style="vertical-align: inherit;">コントロールプレーン</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構成</font><i><font style="vertical-align: inherit;">されて</font></i><font style="vertical-align: inherit;">います</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コントロールプレーン</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
管理プレーンでは、IstioはKubernetes APIに依存しています。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、データウェアハウス内のキーのセットを表示するためにetcdまたはConsulに依存するconfdを</font><i><font style="vertical-align: inherit;">使用することと大差ありません</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Istioは、Kubernetes APIを通じて、Kubernetesリソースセットを表示します。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ケース間</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：私は個人的に、この</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes APIの説明が役立つ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">わかりました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes APIサーバーは、APIリソースのストレージ、バージョニング、検証、更新、およびセマンティクスを提供する「ダムサーバー」です。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IstioはKubernetesと連携するように設計されています。</font><font style="vertical-align: inherit;">Kubernetesの外部で使用する場合は、Kubernetes APIサーバーのインスタンス（および補助サービスなど）を実行する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスアドレス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IstioはKubernetesが割り当てるClusterIPアドレスに依存しているため、Istioサービスは内部アドレス（範囲外</font></font><code>127.0.0.0/8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">取得します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Istioを使用しないKubernetesクラスター内の特定のサービスのClusterIPアドレスへのトラフィックは、kube-proxyによってインターセプトされ、このプロキシのサーバー部分に送信されます。技術的な詳細に関心がある場合、kube-proxyはiptablesルール（または、構成方法によってはIPVSロードバランサー）を設定して、ClusterIPアドレスへの接続の宛先IPアドレスを書き換えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IstioをKubernetesクラスタにインストールした後、コンテナを導入して特定のコンシューマまたはネームスペース全体に対して明示的にオンにするまで、何も変更されません</font></font><code>sidecar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カスタム炉で。</font><font style="vertical-align: inherit;">このコンテナーはEnvoyのインスタンスを起動し、他のサービスへのトラフィックをインターセプトしてEnvoyにそのトラフィックをリダイレクトするための多数のiptablesルールを設定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Kubernetes DNSと統合すると、コードがサービスの名前で接続でき、すべてが「機能する」ことを意味します。</font><font style="vertical-align: inherit;">つまり、コードはタイプのリクエストを発行し</font></font><code>http://api/v1/users/4242</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、次に</font></font><code>api</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にリクエストを解決し</font></font><code>10.97.105.48</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、iptablesルールが10.97.105.48からの接続をインターセプトしてローカルのEnvoyプロキシにリダイレクトします。このローカルプロキシはリクエストを実際のAPIバックエンドに転送します。</font><font style="vertical-align: inherit;">ふ!！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">余分な小さなもの</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Istioは、mTLS（相互TLS）によるエンドツーエンドの暗号化と認証も提供します。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Citadel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれるコンポーネントがこれを担当します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ヘッダー、バックエンドの読み込みなどのさまざまな要因に応じてこのリクエストについて特別な決定を行うために</font><font style="vertical-align: inherit;">、Envoyが</font><i><font style="vertical-align: inherit;">各</font></i><font style="vertical-align: inherit;">リクエストに対して</font><font style="vertical-align: inherit;">リクエスト</font><font style="vertical-align: inherit;">できる</font><i><font style="vertical-align: inherit;">Mixer</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
コンポーネントもあり</font><font style="vertical-align: inherit;">ます...（心配しないでください。クラッシュした場合、Envoyは引き続きプロキシとして正常に動作します。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてもちろん、可視性についても言及しました。Envoyは分散トレースを提供しながら、膨大な数のメトリックを収集します。</font><font style="vertical-align: inherit;">マイクロサービスのアーキテクチャでは、1つのAPIリクエストがマイクロサービスA、B、C、Dを経由する必要がある場合、システムにログインすると、分散トレースによりリクエストに一意の識別子が追加され、これらのすべてのマイクロサービスへのサブクエリを通じてこの識別子が保存され、関連するすべての呼び出しを記録できます。遅延など</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発または購入</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Istioは複雑なシステムであるという評判があります。対照的に、この投稿の冒頭で説明したルーティンググリッドの構築は、既存のツールを使用すると比較的簡単です。では、代わりに独自のサービスメッシュを作成することには意味がありますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
適度なニーズがある場合（可視性、回路ブレーカー、およびその他の微妙さが必要ない場合）、独自のツールを開発することについて考えます。ただし、Kubernetesを使用する場合は、サービスの検出と負荷分散のための基本的なツールがKubernetesですでに提供されているため、必要ない場合もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、高度な要件がある場合は、サービスメッシュを「購入」する方がはるかに優れたオプションのようです。</font><font style="vertical-align: inherit;">（Istioにはオープンソースコードが付属しているため、これは必ずしも「購入」とは限りませんが、その作業を理解し、デプロイして管理するために、エンジニアリング時間を費やす必要があります）。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">選択するもの：Istio、Linkerd、またはConsul Connect？</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでのところ、Istioについてのみ説明しましたが、これが唯一のサービスメッシュではありません。人気のある代替手段は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linkerdで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consul Connect</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もあり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何を選ぶ？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正直、わかりません。現時点では、この質問に答えるのに十分な能力があるとは思いません。</font><font style="vertical-align: inherit;">これらのツールや</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ベンチマークを</font></a><font style="vertical-align: inherit;">比較する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">興味深い</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がいくつかあり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有望なアプローチの1つは、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">SuperGloo</font></a><font style="vertical-align: inherit;">などのツールを使用することです</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">抽象化レイヤーを実装して、サービスメッシュによって提供されるAPIを簡素化および統合します。</font><font style="vertical-align: inherit;">さまざまなサービスメッシュの特定の（そして私の考えでは比較的複雑な）APIを調べる代わりに、より単純なSuperGloo構成を使用して、HTTPインターフェースを記述する中間構成フォーマットがあるかのように、簡単に切り替えることができます。 Nginx、HAProxy、Traefik、Apacheの実際の構成を生成できるバックエンド... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はIstioとSuperGlooに少し甘やかされました。次の記事では、SuperGlooを使用して既存のクラスターにIstioまたはLinkerdを追加する方法と、後者がその作業にどの程度対処するかを示します。つまり、構成を上書きすることなく、1つのサービスメッシュから別のサービスメッシュに切り替えることができます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja453188/index.html">非IT管理者にフォールトトレラントITインフラストラクチャを構築する原則を説明する方法</a></li>
<li><a href="../ja453192/index.html">プロセスの同期と非同期</a></li>
<li><a href="../ja453194/index.html">PHDays 9でBest Reverser問題を解決します</a></li>
<li><a href="../ja453196/index.html">Forrester Research：トップ10のソフトウェア構成分析ベンダーの比較</a></li>
<li><a href="../ja453200/index.html">ディスカッション：OpenROADプロジェクトは、プロセッサの設計を自動化するタスクを解決することを目的としています</a></li>
<li><a href="../ja453206/index.html">Kelsey Moodyへのインタビュー：会社の構築方法と年齢関連の病状の終焉</a></li>
<li><a href="../ja453212/index.html">消費者レポート：テスラの最新のオートパイロットは完璧とはほど遠い</a></li>
<li><a href="../ja453214/index.html">リモートサイトのIT従業員が健康を維持する方法と理由</a></li>
<li><a href="../ja453216/index.html">VoIPネットワークのトラフィック監視システム。パート2-組織の原則</a></li>
<li><a href="../ja453218/index.html">YaC 2019の主なもの：道路上の100台のドローン、Yandex.Module、食品、スマートホーム</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>