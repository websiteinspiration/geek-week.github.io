<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚯 🚫 🥦 Rost. Checker über Iteratoren ausleihen 👰🏼 👨🏾‍🤝‍👨🏼 🌏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 
 
 Ich lerne seit ungefähr einem Jahr und schreibe in meiner Freizeit über das Rast. Mir gefällt, wie die Autoren das Problem der Speiche...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Rost. Checker über Iteratoren ausleihen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499108/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich lerne seit ungefähr einem Jahr und schreibe in meiner Freizeit über das Rast. </font><font style="vertical-align: inherit;">Mir gefällt, wie die Autoren das Problem der Speicherverwaltung gelöst und auf den Garbage Collector verzichtet haben - durch das Konzept der Ausleihe. </font><font style="vertical-align: inherit;">In diesem Artikel werde ich mich dieser Idee durch Iteratoren nähern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In letzter Zeit ist Scala meine Hauptsprache, daher wird es Vergleiche geben, aber es gibt nicht viele davon und alles ist intuitiv, ohne Magie :) Der </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ist für diejenigen gedacht, die etwas über Rost gehört haben, aber nicht auf Details eingegangen sind. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lu/ju/o1/lujuo1lkziqqcu6fpfxiuuuaquy.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fotos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von hier gemacht</font></font></a><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorwort</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In JVM-Sprachen ist es üblich, die Arbeit mit Links auszublenden. Das heißt, dort arbeiten wir fast immer mit Referenzdatentypen. Daher haben wir beschlossen, das kaufmännische Und (&amp;) auszublenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Rasta hat explizite Links, zum Beispiel zu Integer - `&amp; i32`, der Link kann über` *` dereferenziert werden, es kann auch einen Link zum Link geben und dann muss er zweimal dereferenziert werden **.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie Code schreiben, müssen Sie die Sammlung sehr oft nach einer Bedingung (Prädikat) filtern. </font><font style="vertical-align: inherit;">Im Fels würde es ungefähr so ​​aussehen, selbst Elemente aufzunehmen:</font></font><br>
<br>
<pre><code class="scala hljs">    <span class="hljs-keyword">val</span> vec = <span class="hljs-type">Vector</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
    <span class="hljs-keyword">val</span> result = vec.filter(e =&gt; e % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns die Sorten an:</font></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-keyword">private</span>[scala] <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filterImpl</span></span>(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>, isFlipped: <span class="hljs-type">Boolean</span>): <span class="hljs-type">Repr</span> = {
    <span class="hljs-keyword">val</span> b = newBuilder
    <span class="hljs-keyword">for</span> (x &lt;- <span class="hljs-keyword">this</span>)
      <span class="hljs-keyword">if</span> (p(x) != isFlipped) b += x<font></font>
<font></font>
    b.result<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ohne auf die Details von `newBuilder` einzugehen, ist klar, dass eine neue Sammlung erstellt wird. Wir iterieren über die alte und fügen ein Element hinzu, wenn das Prädikat true zurückgibt. </font><font style="vertical-align: inherit;">Trotz der Tatsache, dass die Sammlung neu ist, sind ihre Elemente tatsächlich Verknüpfungen zu Elementen aus der ersten Sammlung. Wenn diese Elemente plötzlich veränderbar sind, werden beide Sammlungen gemeinsam geändert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir nun, dasselbe im Rast zu tun. </font><font style="vertical-align: inherit;">Ich werde sofort ein funktionierendes Beispiel geben und dann die Unterschiede betrachten.</font></font><br>
<br>
<pre><code class="rust hljs">    <span class="hljs-keyword">let</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
    <span class="hljs-keyword">let</span> result: <span class="hljs-built_in">Vec</span>&lt;&amp;<span class="hljs-built_in">i32</span>&gt; = v.iter().filter(|e| **e % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).collect();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wow, wow was? </font><font style="vertical-align: inherit;">Doppelzeiger-Dereferenzierung? </font><font style="vertical-align: inherit;">Nur um den Vektor zu filtern? </font><font style="vertical-align: inherit;">Schwer :( Aber es gibt Gründe dafür. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns herausgreifen, wie sich dieser Code vom Fels unterscheidet:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Holen Sie sich explizit den Iterator auf den Vektor (`iter ()`) </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In der Prädikatfunktion dereferenzieren wir aus irgendeinem Grund den Zeiger zweimal </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rufen Sie `collect ()` auf </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es ergab sich auch ein Vektor der Referenztypen Vec &lt;&amp; i32&gt; und nicht gewöhnlicher Ints </font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Checker ausleihen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum explizit "iter ()" für die Sammlung aufrufen? </font><font style="vertical-align: inherit;">Jedem Rockman ist klar, dass Sie die Sammlung durchlaufen müssen, wenn Sie ".filter (...)" aufrufen. </font><font style="vertical-align: inherit;">Warum in einem Rast explizit schreiben, was implizit getan werden kann? </font><font style="vertical-align: inherit;">Weil es </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drei</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verschiedene Iteratoren gibt! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6t/vw/-m/6tvw-mzsdc6ce1caxkzl-custrw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um herauszufinden, warum drei? </font><font style="vertical-align: inherit;">Bedarf an berühren </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Borrow </font></font></b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(borrow, borrow) </font></font></i> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">checker</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚ein. </font><font style="vertical-align: inherit;">Genau das, aufgrund dessen der Rast ohne GC und ohne explizite Speicherzuweisung / Freigabe funktioniert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum wird es benötigt?</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um Situationen zu vermeiden, in denen mehrere Zeiger auf denselben Speicherbereich zeigen, können Sie ihn ändern. </font><font style="vertical-align: inherit;">Das ist eine Rennbedingung.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Speicher nicht mehrmals freizugeben.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie wird das erreicht? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund des Eigentumsbegriffs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen ist das Konzept des Eigentums einfach - nur einer kann etwas besitzen (sogar Intuition). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Besitzer kann wechseln, aber er ist immer allein. Wenn wir `let x: i32 = 25` schreiben, bedeutet dies, dass es eine Speicherzuordnung für 32bit int gab und ein bestimmtes` x` es besitzt. Die Idee des Eigentums existiert nur im Kopf des Compilers, im Leihprüfer. Wenn der Eigentümer in diesem Fall "x" den Bereich verlässt (verlässt den Bereich), wird der Speicher, dessen Eigentümer er ist, gelöscht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein Code, den der Leihprüfer nicht verpassen wird:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span></span>; <span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span> </span>() -&gt; X {
    <span class="hljs-keyword">let</span> first = X; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> second = first; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> third = first; <span class="hljs-comment">//   ,   first   </span>
<span class="hljs-comment">//    value used here after move</span><font></font>
<font></font>
    <span class="hljs-keyword">return</span> third;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
`struct X` ist so etwas wie` case class X ()` - eine randlose Struktur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich denke, dieses Verhalten ist für alle sehr intuitiv. </font><font style="vertical-align: inherit;">Ich kenne keine anderen Sprachen, in denen es unmöglich wäre, dieselbe "Variable" zweimal zu "verwenden". </font><font style="vertical-align: inherit;">Es ist wichtig, diesen Moment zu fühlen. </font><font style="vertical-align: inherit;">Erstens ist es überhaupt kein Verweis auf X, es ist sein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Besitzer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn wir den Besitzer wechseln, töten wir den vorherigen. Der Leihprüfer erlaubt seine Verwendung nicht.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum mussten Sie Ihre eigene Struktur erstellen, warum nicht eine reguläre Ganzzahl verwenden?</font></font></b>
                        <div class="spoiler_text">    —       (`struct X`),  , ,   integer.   ,     ,     :<br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span> </span>() -&gt; <span class="hljs-built_in">i32</span> {
    <span class="hljs-keyword">let</span> first = <span class="hljs-number">32</span>;
    <span class="hljs-keyword">let</span> second = first; 
    <span class="hljs-keyword">let</span> third = first; <font></font>
<font></font>
    <span class="hljs-keyword">return</span> third;<font></font>
}<font></font>
</code></pre><br>
  ,   borrow checker,            ,   .     Copy,      .      `i32` second     ,   (   ), -  third   .   X     Copy,      .<br>
<br>
     .   ,              ,      «»            .        Clone,    ,     .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">copy</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">clone</a>.<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zurück zu den Iteratoren. </font><font style="vertical-align: inherit;">Das Konzept der "Erfassung" unter ihnen ist </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntoIter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Er "schluckt" die Sammlung und gibt ihre Elemente in Besitz. </font><font style="vertical-align: inherit;">Im Code wird diese Idee folgendermaßen wiedergegeben:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-keyword">let</span> coll_1 = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">let</span> coll_2: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = coll_1.into_iter().collect();
<span class="hljs-comment">//coll_1 doesn't exists anymore</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch Aufrufen von "into_iter ()" bei coll_1 "verwandelten" wir es in einen Iterator, der alle seine Elemente absorbierte, wie im vorherigen Beispiel "second" absorbierte "first". </font><font style="vertical-align: inherit;">Danach werden alle Aufrufe von coll_1 während der Kompilierung vom Ausleihprüfer bestraft. </font><font style="vertical-align: inherit;">Dann haben wir diese Elemente mit der Funktion "sammeln" gesammelt und einen neuen Vektor erstellt. </font><font style="vertical-align: inherit;">Die Funktion `collect` wird benötigt, um eine Sammlung von einem Iterator zu sammeln. Dazu müssen Sie explizit den Typ angeben, den wir sammeln möchten. </font><font style="vertical-align: inherit;">Daher gibt coll_2 den Typ eindeutig an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Okay, im Allgemeinen reicht das oben Beschriebene für eine Programmiersprache aus, aber es ist nicht sehr effizient, Datenstrukturen jedes Mal zu kopieren / klonen, wenn wir sie übertragen möchten, und Sie müssen auch in der Lage sein, etwas zu ändern. </font><font style="vertical-align: inherit;">Also gehen wir zu den Zeigern.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeiger</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Besitzer kann, wie wir herausgefunden haben, nur einer sein. </font><font style="vertical-align: inherit;">Sie können jedoch beliebig viele Links haben.</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Y</span></span>; <span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span></span>() -&gt; Y {
    <span class="hljs-keyword">let</span> first = Y; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> second: &amp;Y = &amp;first; <span class="hljs-comment">//   ,     </span>
    <span class="hljs-keyword">let</span> third = &amp;first; <span class="hljs-comment">//    </span><font></font>
<font></font>
<span class="hljs-comment">// </span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, second);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, third);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> first;<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code ist bereits gültig, da der Eigentümer noch einer ist. Die gesamte Besitzlogik wird nur in der Kompilierungsphase überprüft, ohne die Speicherzuweisung / -verschiebung zu beeinflussen. Außerdem können Sie sehen, dass sich der Typ der Sekunde in "&amp; Y" geändert hat! Das heißt, die Semantik von Besitz und Links spiegelt sich in den Typen wider, sodass Sie während der Kompilierung beispielsweise das Fehlen einer Racebedingung überprüfen können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie kann ich mich beim Kompilieren vor Race-Bedingungen schützen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Indem Sie die Anzahl der veränderlichen Links begrenzen! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine veränderbare Verbindung zu einem bestimmten Zeitpunkt kann eine und nur eine sein (ohne unveränderliche). Das heißt, entweder eine / mehrere unveränderliche oder eine veränderliche. Der Code sieht folgendermaßen aus:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-comment">// </span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span></span> {<font></font>
    x: <span class="hljs-built_in">i32</span>,<font></font>
} <font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span></span>() -&gt; X {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> first = X { x: <span class="hljs-number">20</span> }; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> second: &amp;<span class="hljs-keyword">mut</span> X = &amp;<span class="hljs-keyword">mut</span> first; <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">let</span> third: &amp;<span class="hljs-keyword">mut</span> X = &amp;<span class="hljs-keyword">mut</span> first; <span class="hljs-comment">//    .        `second`        - .</span>
<span class="hljs-comment">//    second.x = 33;  //    ,             ,    </span>
    third.x = <span class="hljs-number">33</span>;<font></font>
<font></font>
    <span class="hljs-keyword">return</span> first;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns die Änderungen im vorherigen Beispiel durchgehen. Zuerst haben wir der Struktur ein Feld hinzugefügt, damit sich etwas ändern kann, da wir Veränderbarkeit benötigen. Zweitens erschien `mut` in der Deklaration der Variablen` let mut first = ...`, dies ist ein Marker für den Compiler über Mutabilität, wie` val` &amp; `var` im Gestein. Drittens haben alle Links ihren Typ von "&amp; X" in "&amp; mut X" geändert (es sieht natürlich monströs aus. Und dies ohne Lebenszeit ...). Jetzt können wir den vom Link gespeicherten Wert ändern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber ich sagte, dass wir nicht mehrere veränderbare Links erstellen können, sie sagen, dass der Leihprüfer dies nicht geben wird, aber ich habe selbst zwei erstellt! Ja, aber die Überprüfungen dort sind sehr schwierig, weshalb es manchmal nicht offensichtlich ist, warum der Compiler schwört. Er ist bemüht sicherzustellen, dass Ihr Programm kompiliert wird und wenn es absolut keine Optionen gibt, um die Regeln zu erfüllen, dann ein Fehler, und vielleicht nicht der, auf den Sie warten, sondern der, der seinen letzten Versuch verletzt, der verzweifeltste und für einen Anfänger nicht offensichtliche: ) Sie werden beispielsweise darüber informiert, dass die Struktur das Kopiermerkmal nicht implementiert, obwohl Sie nirgendwo Kopien aufgerufen haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall ist die Existenz von zwei veränderlichen Links gleichzeitig zulässig, da wir nur einen verwenden, dh der zweite kann weggeworfen werden und nichts wird sich ändern. Auch `second` kann bis zu verwendet </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstelle ein "drittes" und dann wird alles in Ordnung sein. </font><font style="vertical-align: inherit;">Wenn Sie jedoch "second.x = 33;" auskommentieren, stellt sich heraus, dass zwei veränderbare Links gleichzeitig vorhanden sind und Sie hier sowieso nicht raus können - Fehler beim Kompilieren.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iteratoren</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben also drei Arten der Übertragung:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Absorption, Ausleihe, Bewegung</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verknüpfung</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veränderliche Verbindung</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder Typ benötigt einen eigenen Iterator.</font></font><br>
<br>
<ol>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntoIter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> absorbiert Objekte aus der Originalsammlung</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> läuft auf Objektverknüpfungen</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IterMut wird</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf veränderlichen Objektreferenzen ausgeführt</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellt sich die Frage, wann welche zu verwenden sind. </font><font style="vertical-align: inherit;">Es gibt keine Silberkugel - Sie müssen üben, den Code eines anderen lesen, Artikel. </font><font style="vertical-align: inherit;">Ich werde ein Beispiel geben, das die Idee demonstriert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, es gibt eine Schule, eine Klasse und Schüler in der Klasse.</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-meta">#[derive(PartialEq, Eq)]</span>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Sex</span></span> {<font></font>
    Male,<font></font>
    Female<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Scholar</span></span> {<font></font>
    name: <span class="hljs-built_in">String</span>,<font></font>
    age: <span class="hljs-built_in">i32</span>,<font></font>
    sex: Sex<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">let</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = ...;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben den Vektor von Schulkindern genommen, indem wir zum Beispiel die Datenbank abgefragt haben. </font><font style="vertical-align: inherit;">Als nächstes musste ich die Anzahl der Mädchen in der Klasse zählen. </font><font style="vertical-align: inherit;">Wenn wir den Vektor durch "into_iter ()" "schlucken", können wir diese Sammlung nach dem Zählen nicht mehr zum Zählen der Jungen verwenden:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bad_idea</span></span>() {
    <span class="hljs-keyword">let</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();
    <span class="hljs-keyword">let</span> girls_c = scholars<font></font>
        .into_iter()<font></font>
        .filter(|s| (*s).sex == Sex::Female)<font></font>
        .count();<font></font>
<font></font>
    <span class="hljs-keyword">let</span> boys_c = scholars <font></font>
        .into_iter()<font></font>
        .filter(|s| (*s).sex == Sex::Male)<font></font>
        .count();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Zeile zum Zählen der Jungen wird der Fehler "Hier nach dem Verschieben verwendet" angezeigt. </font><font style="vertical-align: inherit;">Es ist auch offensichtlich, dass der veränderbare Iterator für uns keinen Nutzen hat. </font><font style="vertical-align: inherit;">Deshalb ist es nur "iter ()" und arbeitet mit einem doppelten Link:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">good_idea</span></span>() {
    <span class="hljs-keyword">let</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();
    <span class="hljs-keyword">let</span> girls_c = scholars.iter().filter(|s| (**s).sex == Sex::Female).count();
    <span class="hljs-keyword">let</span> boys_c = scholars.iter().filter(|s| (**s).sex == Sex::Male).count();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Anzahl potenzieller Rekruten im Land zu erhöhen, ist bereits ein veränderlicher Iterator erforderlich:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">very_good_idea</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();<font></font>
    scholars.iter_mut().for_each(|s| (*s).sex = Sex::Male);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir die Idee entwickeln, können wir aus den „Jungs“ Soldaten machen und den „absorbierenden“ Iterator demonstrieren:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-keyword">impl</span> Scholar {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">to_soldier</span></span>(<span class="hljs-keyword">self</span>) -&gt; Soldier {<font></font>
        Soldier { forgotten_name: <span class="hljs-keyword">self</span>.name, number: some_random_number_generator() }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Soldier</span></span> {<font></font>
    forgotten_name: <span class="hljs-built_in">String</span>,<font></font>
    number: <span class="hljs-built_in">i32</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">good_bright_future</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();<font></font>
    scholars.iter_mut().for_each(|s| (*s).sex = Sex::Male);<font></font>
    <span class="hljs-keyword">let</span> soldiers: <span class="hljs-built_in">Vec</span>&lt;Soldier&gt; = scholars.into_iter().map(|s| s.to_soldier()).collect();
    <span class="hljs-comment">//   scholars,    </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem wunderbaren Sinne ist das vielleicht alles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die letzte Frage bleibt - woher kommt die doppelte Dereferenzierung der Links in "Filter"? </font><font style="vertical-align: inherit;">Tatsache ist, dass ein Prädikat eine Funktion ist, die auf ein Argument verweist (um es nicht zu erfassen):</font></font><br>
<br>
<pre><code class="rust hljs">
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">filter</span></span>&lt;P&gt;(<span class="hljs-keyword">self</span>, predicate: P) -&gt; Filter&lt;<span class="hljs-keyword">Self</span>, P&gt; <span class="hljs-keyword">where</span>
        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span>, P: <span class="hljs-built_in">FnMut</span>(&amp;Self::Item) -&gt; <span class="hljs-built_in">bool</span>,
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Prädikat ist FnMut (grob gesagt eine Funktion), das auf sein (Selbst-) Element verweist und bool zurückgibt. </font><font style="vertical-align: inherit;">Da wir bereits einen Link vom Iterator ".iter ()" hatten, erschien der zweite im Filter. </font><font style="vertical-align: inherit;">Wenn es von einem Iterator (`into_iter`) absorbiert wird, wird die doppelte Dereferenzierung der Verbindung zu einer regulären.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortsetzung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe nicht viel Erfahrung im Schreiben von Artikeln, daher werde ich gerne kritisieren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Interesse kann ich weitermachen. </font><font style="vertical-align: inherit;">Optionen für Themen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wie und wann Speicherfreigabe erfolgt </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Link-Lebensdauer </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> asynchrone Programmierung </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie einen kleinen Webdienst schreiben, können Sie sogar API anbieten </font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links</font></font></h3><br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rostbuch</font></font></a> </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgrund des Eigentumskonzepts ist die Implementierung grundlegender Dinge wie beispielsweise einer verknüpften Liste nicht mehr trivial. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sind</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verschiedene Möglichkeiten, wie Sie sie implementieren können.</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de499092/index.html">Referenzmodell BIAN. Was Neues und Nützliches für die Unternehmensarchitektur der Bank bietet sie?</a></li>
<li><a href="../de499096/index.html">Fuzzy-Logik in schönen Bildern. Antwortflächen für verschiedene Zugehörigkeitsfunktionen</a></li>
<li><a href="../de499102/index.html">Kubernetes, Microservices, CI / CDs und Docker für Retrograde: Lerntipps</a></li>
<li><a href="../de499104/index.html">IoT für Ihre Wunden: Warum das Internet der Dinge im Zeitalter des Coronavirus am willkommensten ist</a></li>
<li><a href="../de499106/index.html">Erweitertes HTML</a></li>
<li><a href="../de499110/index.html">Der Große Bruder versucht, dem Guten zu dienen. Wie Datensammler und Programmunternehmen in den Kampf gegen Coronavirus involviert sind</a></li>
<li><a href="../de499112/index.html">Erweitertes Ressourcenautorisierungssystem in Laravel. Teil 3. Attribute lesen / schreiben, eigene Modelle</a></li>
<li><a href="../de499114/index.html">Export des Nummerierungsplans der Federal Communications Agency in eine relationale Datenbank</a></li>
<li><a href="../de499118/index.html">So erstellen Sie ein virales Video</a></li>
<li><a href="../de499120/index.html">[Lesezeichen] CSS: Verwenden von Einrückung und Einrückung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>