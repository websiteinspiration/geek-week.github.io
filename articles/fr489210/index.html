<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•´ üëáüèº ‚õîÔ∏è Test de performance du code Linux avec des exemples üôå ‚ÜóÔ∏è üëÜüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quand j'ai commenc√© √† apprendre Java, l'une des premi√®res t√¢ches que j'ai essay√© de r√©soudre √©tait de d√©terminer les nombres pairs / impairs. Je conna...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Test de performance du code Linux avec des exemples</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489210/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quand j'ai commenc√© √† apprendre Java, l'une des premi√®res t√¢ches que j'ai essay√© de r√©soudre √©tait de d√©terminer les nombres pairs / impairs. Je connaissais plusieurs fa√ßons de proc√©der, mais j'ai d√©cid√© de chercher la ¬´bonne¬ª mani√®re sur Internet. Les informations sur tous les liens trouv√©s m'ont indiqu√© la seule solution correcte du formulaire x% 2, afin d'obtenir le reste de la division. Si le reste est 0, le nombre est pair; si le reste est 1, il est impair. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depuis l'√©poque de ZX Spectrum, je me suis souvenu d'une autre mani√®re et elle est associ√©e √† la repr√©sentation des nombres dans le syst√®me binaire. Tout nombre dans le syst√®me d√©cimal peut √™tre √©crit comme la somme des puissances de deux. Par exemple, pour un octet, et cela fait 8 bits, tout nombre dans le syst√®me d√©cimal peut √™tre repr√©sent√© comme la somme des nombres 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce n'est qu'une s√©quence de pouvoirs de deux. Lors de la traduction d'un nombre dans le syst√®me binaire, si nous devons tenir compte du nombre, dans la repr√©sentation binaire, ce sera un, sinon n√©cessaire, ce sera 0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10 = 1010 (8 + 0 + 2 + 0) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
13 = 1101 (8 + 4 + 0 + 1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
200 = 11001000 (128 + 64 + 0 + 0 + 8 + 0 + 0 + 0)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez imm√©diatement faire attention au fait qu'un nombre impair ne peut donner qu'une puissance nulle de deux avec une valeur de 1, toutes les autres puissances de deux seront √©gales par d√©finition. </font><font style="vertical-align: inherit;">Cela signifie automatiquement que du point de vue du syst√®me de nombres binaires, si nous voulons v√©rifier la parit√© d'un nombre, nous n'avons pas besoin de v√©rifier le nombre entier, quelle que soit sa taille. </font><font style="vertical-align: inherit;">Nous devons v√©rifier uniquement le premier bit (le plus √† droite). </font><font style="vertical-align: inherit;">S'il est √©gal √† 0, alors le nombre est pair, puisque tous les autres bits donnent un nombre pair, et vice versa, s'il est un dans le bit le plus √† droite, alors le nombre est garanti d'√™tre impair, car tous les autres bits ne donnent qu'une valeur paire. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour v√©rifier uniquement le bon bit dans un nombre, vous pouvez utiliser plusieurs m√©thodes. </font><font style="vertical-align: inherit;">L'un d'eux est ET binaire.</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ET</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ET binaire (ET) fonctionne selon la r√®gle suivante. Si vous appliquez √† n'importe quel nombre, appelons-le original, ET logique avec le nombre 0, alors le r√©sultat d'une telle op√©ration est toujours 0. Ainsi, vous pouvez mettre √† z√©ro les bits dont vous n'avez pas besoin. Si vous postulez √† l'original 1, vous obtenez l'original. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans un syst√®me binaire, il est facile d'√©crire ceci: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 et 0 = 0 (z√©ro l'original) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 et 0 = 0 (z√©ro l'original) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 ET 1 = 0 (ne pas modifier l'original) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 ET 1 = 1 (ne change pas l'original) A </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
partir de </font><font style="vertical-align: inherit;">l√† quelques simples r√®gles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous appliquons l'op√©ration ET de toutes les unit√©s √† tous les nombres (tous les bits sont activ√©s), nous obtenons le m√™me nombre initial. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous appliquons ET de tous les z√©ros √† n'importe quel nombre (tous les bits sont d√©sactiv√©s), nous obtenons 0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous appliquons AND 0 √† l'octet 13, nous obtiendrons 0. En d√©cimal, cela ressemble √† 13 AND 0 = 0 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous appliquons AND 0 √† l'octet 200, nous obtiendrons 0, ou notons bri√®vement 200 AND 0 = 0. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il en va de m√™me pour le contraire, appliquer √† 13 tous les bits inclus, pour un octet ce sera huit unit√©s, et nous obtenons l'original. </font><font style="vertical-align: inherit;">Dans le syst√®me binaire 00001101 ET 11111111 = 00001101 ou dans le syst√®me d√©cimal 13 ET 255 = 13 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour 200, il y aura respectivement 11001000 ET 11111111 = 11001000, ou dans le syst√®me d√©cimal 200 ET 255 = 200</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V√©rification binaire</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour v√©rifier la parit√© du nombre, il suffit de v√©rifier le bit le plus √† droite. Si c'est 0, alors le nombre est pair; si 1, alors ce n'est pas pair. Sachant qu'avec AND, nous pouvons laisser certains bits d'origine et certains que nous pouvons r√©initialiser, nous pouvons simplement r√©initialiser tous les bits sauf le plus √† droite. Par exemple: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
13 dans le syst√®me binaire est 1101. Appliquons ET 0001 √† lui (nous remettons √† z√©ro tous les bits, le dernier reste l'original). Nous changeons le nombre 1101 tous les bits en 0 sauf le dernier et obtenons 0001. Nous n'avons obtenu que le dernier bit de notre nombre d'origine. Dans le syst√®me d√©cimal, il ressemblera √† 13 ET 1 = 1.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La m√™me chose avec le nombre 200, sous forme binaire 11001000. Nous lui appliquons ET 00000001, selon le m√™me sch√©ma, remettons √† z√©ro tous les bits, laissons le dernier tel quel, nous obtenons 00000000, et nous remettons √† z√©ro les 7 z√©ros de gauche avec AND, et nous avons obtenu le dernier 0 du num√©ro d'origine. Dans le syst√®me d√©cimal, cela ressemble √† 200 AND 1 = 0 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, en appliquant la commande AND 1 √† n'importe quel nombre, nous obtenons 0 ou 1. Et si le r√©sultat est 0, alors le nombre est pair. Lorsque 1, le nombre est impair. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Java, le binaire ET s'√©crit &amp;. En cons√©quence, 200 &amp; 1 = 0 (pair) et 13 &amp; 1 = 1 (impair). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela implique au moins deux m√©thodes pour d√©terminer les nombres pairs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X% 2 - par le reste de la division par deux </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X &amp; 1 - par ET binaire</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les op√©rations binaires telles que OR, AND, XOR sont trait√©es par le processeur en un minimum de temps. </font><font style="vertical-align: inherit;">Mais l'op√©ration de division est une t√¢che non triviale, et pour l'ex√©cuter, le processeur doit traiter un grand nombre d'instructions, essentiellement ex√©cuter le programme entier. </font><font style="vertical-align: inherit;">Cependant, il existe des op√©rations de d√©calage gauche et droite binaires qui permettent, par exemple, de diviser rapidement un nombre par 2. La question est de savoir si les compilateurs utilisent cette optimisation et s'il existe une diff√©rence entre ces deux comparaisons, qui en fait font de m√™me.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codage</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous √©crirons un programme qui traitera 9 000 000 000 de nombres dans un cycle dans l'ordre, et d√©terminerons leur appartenance √† pair / impair en d√©terminant le reste de la division.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OddEvenViaMod</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>{
                <span class="hljs-keyword">long</span> i=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> odds=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> evens=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>) {<font></font>
                        evens++;<font></font>
                        }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                        odds++;<font></font>
                        }<font></font>
                i++;<font></font>
                } <span class="hljs-keyword">while</span> (i&lt;<span class="hljs-number">9000000000L</span>);<font></font>
                System.out.println(<span class="hljs-string">"Odd "</span> + odds);<font></font>
                System.out.println(<span class="hljs-string">"Even "</span> + evens);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et nous √©crirons exactement la m√™me chose, mais changerons litt√©ralement deux caract√®res, en v√©rifiant la m√™me chose via ET binaire.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OddEvenViaAnd</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>{
                <span class="hljs-keyword">long</span> i=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> odds=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> evens=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">if</span> ((i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) {<font></font>
                        evens++;<font></font>
                        }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                        odds++;<font></font>
                        }<font></font>
                i++;<font></font>
                } <span class="hljs-keyword">while</span> (i&lt;<span class="hljs-number">9000000000L</span>);<font></font>
                System.out.println(<span class="hljs-string">"Odd "</span> + odds);<font></font>
                System.out.println(<span class="hljs-string">"Even "</span> + evens);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous devons en quelque sorte comparer ces deux programmes.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ressources sur Linux. </font><font style="vertical-align: inherit;">CPU</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Des heures consid√©rables ont √©t√© consacr√©es √† la cr√©ation de tout syst√®me d'exploitation, en particulier √† une r√©partition √©quitable des ressources entre les programmes. </font><font style="vertical-align: inherit;">D'une part, c'est bien, puisque l'ex√©cution de deux programmes, vous pouvez √™tre s√ªr qu'ils fonctionneront en parall√®le, mais d'autre part, lorsque vous devez v√©rifier les performances d'un programme, il est extr√™mement n√©cessaire de limiter ou au moins de r√©duire l'impact externe sur le programme des autres programmes et syst√®me d'exploitation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La premi√®re chose √† comprendre est le processeur. </font><font style="vertical-align: inherit;">Le syst√®me d'exploitation Linux pour chaque processus stocke un masque de bits, qui indique quels noyaux peuvent √™tre utilis√©s par l'application et lesquels ne le sont pas. </font><font style="vertical-align: inherit;">Vous pouvez afficher et modifier ce masque avec la commande tasket. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, voyons le nombre de c≈ìurs dans mon processeur:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# grep -c processor /proc/cpuinfo<font></font>
4<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mon ordinateur poss√®de un processeur avec 4 c≈ìurs. </font><font style="vertical-align: inherit;">C'est bien, car je vais en affecter un √† mes besoins. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons si tous sont actuellement utilis√©s avec la commande top:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# top
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Appuyez sur "1" pour afficher s√©par√©ment les informations sur chaque c≈ìur:</font></font><br>
<br>
<pre><code class="plaintext hljs">top - 13:44:11 up 1 day, 23:26,  7 users,  load average: 1.48, 2.21, 2.02<font></font>
Tasks: 321 total,   1 running, 320 sleeping,   0 stopped,   0 zombie<font></font>
%Cpu0  :  7.7 us,  6.8 sy,  0.0 ni, 85.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :  9.2 us,  4.2 sy,  0.0 ni, 86.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  7.6 us,  3.4 sy,  0.0 ni, 89.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  :  8.4 us,  4.2 sy,  0.0 ni, 87.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
KiB Mem : 16210820 total,   296972 free, 10072092 used,  5841756 buff/cache<font></font>
KiB Swap: 16777212 total, 16777212 free,        0 used.  5480568 avail Mem<font></font>
....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous voyons que tous les c≈ìurs sont utilis√©s √† peu pr√®s de la m√™me mani√®re. </font><font style="vertical-align: inherit;">(les indicateurs us et sy et id sont approximativement √©gaux pour chaque noyau). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayons maintenant de voir la m√™me chose avec la commande tasket.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -p 1<font></font>
pid 1's current affinity mask: f<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le masque binaire "F" dans le syst√®me hexad√©cimal signifie 15 en d√©cimal, ou 1111 en binaire (8 + 4 + 2 + 1). </font><font style="vertical-align: inherit;">Tous les bits sont activ√©s, ce qui signifie que tous les c≈ìurs sont utilis√©s par un processus avec PID 1. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sous Linux, lorsqu'un processus en g√©n√®re un autre avec un appel syst√®me clone, le masque binaire est copi√© √† partir du parent au moment du clonage. </font><font style="vertical-align: inherit;">Cela signifie que si nous changeons ce masque pour notre processus d'initialisation (dans mon cas, c'est systemd), alors lors du d√©marrage de tout nouveau processus via systemd, ce nouveau processus sera d√©j√† lanc√© avec un nouveau masque. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez modifier le masque du processus √† l'aide de la m√™me commande, en r√©pertoriant le nombre de c≈ìurs de processeur que nous voulons laisser utilis√©s pour le processus. </font><font style="vertical-align: inherit;">Supposons que nous voulons laisser le noyau 0.2.3 pour notre processus, et nous voulons d√©sactiver le noyau 1 pour notre processus systemd. </font><font style="vertical-align: inherit;">Pour ce faire, nous devons ex√©cuter la commande:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]#  taskset -pc 0,2,3 1<font></font>
pid 1's current affinity list: 0-3<font></font>
pid 1's new affinity list: 0,2,3<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous v√©rifions:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -p 1<font></font>
pid 1's current affinity mask: d<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le masque a chang√© en "D" dans la notation hexad√©cimale, qui est 13 en d√©cimal et 1101 en binaire (8 + 4 + 0 + 1). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D√©sormais, tout processus qui sera clon√© par le processus systemd aura automatiquement un masque 1101 d'utilisation CPU, ce qui signifie que le noyau num√©ro 1 ne sera pas utilis√©.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous interdisons l'utilisation du noyau √† tous les processus</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Emp√™cher le processus Linux principal d'utiliser un seul noyau n'affectera que les nouveaux processus cr√©√©s par ce processus. </font><font style="vertical-align: inherit;">Mais dans mon syst√®me, il n'y a d√©j√† pas un processus, mais toute une multitude, comme crond, sshd, bash et autres. </font><font style="vertical-align: inherit;">Si je dois interdire √† tous les processus d'utiliser un seul c≈ìur, je dois ex√©cuter la commande tasket pour chaque processus en cours d'ex√©cution. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour obtenir une liste de tous les processus, nous utiliserons l'API que le noyau nous donne, √† savoir le syst√®me de fichiers / proc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus loin dans la boucle, nous regardons le PID de chaque processus en cours d'ex√©cution et changeons le masque pour lui et tous les threads:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# cd /proc; for i in `ls -d [0-9]*`; do taskset -a -pc 0,2,3 $i; done<font></font>
pid 1's current affinity list: 0,2,3<font></font>
pid 1's new affinity list: 0,2,3<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√âtant donn√© que pendant l'ex√©cution du programme, certains processus peuvent avoir le temps de g√©n√©rer d'autres processus, il est pr√©f√©rable d'ex√©cuter cette commande plusieurs fois. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V√©rifiez le r√©sultat de notre travail avec la commande top:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# top<font></font>
top - 14:20:46 up 2 days, 3 min,  7 users,  load average: 0.19, 0.27, 0.57<font></font>
Tasks: 324 total,   4 running, 320 sleeping,   0 stopped,   0 zombie<font></font>
%Cpu0  :  8.9 us,  7.7 sy,  0.0 ni, 83.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  9.5 us,  6.0 sy,  0.0 ni, 84.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  :  8.4 us,  6.6 sy,  0.0 ni, 85.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
KiB Mem : 16210820 total,   285724 free, 10142548 used,  5782548 buff/cache<font></font>
KiB Swap: 16777212 total, 16777212 free,        0 used.  5399648 avail Mem<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, l'image a un peu chang√©, maintenant pour le noyau 0.2.3 les param√®tres moyens us, sy, id sont les m√™mes pour nous, et pour le noyau 1 notre consommation de base dans l'espace utilisateur et sys est de 0, et le noyau est inactif √† 100% (100 inactif) ) </font><font style="vertical-align: inherit;">Le noyau 1 n'est plus utilis√© par nos applications et un tr√®s faible pourcentage est actuellement utilis√© par le noyau. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D√©sormais, la t√¢che de tester les performances se r√©duit √† d√©marrer notre processus sur un c≈ìur libre.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©moire</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La m√©moire physique allou√©e √† un processus peut √™tre facilement extraite de n'importe quel processus. </font><font style="vertical-align: inherit;">Ce m√©canisme est appel√© swap. </font><font style="vertical-align: inherit;">Si Linux a une place pour l'√©change, il le fera de toute fa√ßon. </font><font style="vertical-align: inherit;">La seule fa√ßon d'emp√™cher le syst√®me d'exploitation de prendre de la m√©moire de notre processus, comme tout autre processus, est de d√©sactiver compl√®tement la section swap, ce que nous ferons:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo swapoff -a<font></font>
[user@localhost]$ free -m<font></font>
              total        used        free      shared  buff/cache   available<font></font>
Mem:          15830        7294        1894         360        6641        7746<font></font>
Swap:             0           0           0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons allou√© 1 c≈ìur de processeur, qui n'est pas utilis√©, et nous avons √©galement supprim√© la possibilit√© d'√©changer de la m√©moire du noyau Linux. </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disque</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afin de r√©duire l'impact du disque sur le lancement de notre processus, cr√©ez un disque en m√©moire et copiez tous les fichiers n√©cessaires sur ce disque. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cr√©ez un r√©pertoire et montez le syst√®me de fichiers:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo mkdir /mnt/ramdisk;<font></font>
[user@localhost]$ mount -t tmpfs -o size=512m tmpfs /mnt/ramdisk<font></font>
[user@localhost]$ chown user: /mnt/ramdisk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous devons maintenant d√©terminer quoi et comment nous pr√©voyons de le lancer. </font><font style="vertical-align: inherit;">Afin d'ex√©cuter notre programme, nous devons d'abord compiler notre code:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ javac OddEvenViaMod.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, vous devez l'ex√©cuter:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais dans notre cas, nous voulons ex√©cuter le processus sur le c≈ìur du processeur qui n'est utilis√© par aucun autre processus. </font><font style="vertical-align: inherit;">Par cons√©quent, ex√©cutez-le via l'ensemble de t√¢ches:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -c 1 time java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans nos tests, nous devons mesurer le temps, donc notre ligne de lancement se transforme en</font></font><br>
<br>
<pre><code class="plaintext hljs">taskset -c 1 time java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linux OS prend en charge plusieurs formats de fichiers ex√©cutables, et le plus courant d'entre eux est le format ELF. Ce format de fichier vous permet de dire au syst√®me d'exploitation de ne pas ex√©cuter votre fichier, mais d'ex√©cuter un autre fichier. √Ä premi√®re vue, cela ne semble pas tr√®s logique et compr√©hensible. Imaginez que je lance le jeu D√©mineur et que le jeu Mario d√©marre pour moi - il ressemble √† un virus. Mais c'est la logique. Si mon programme n√©cessite une biblioth√®que dynamique, par exemple libc, ou toute autre, cela signifie que le syst√®me d'exploitation doit d'abord charger cette biblioth√®que en m√©moire, puis charger et ex√©cuter mon programme. Et il semble logique de placer une telle fonctionnalit√© dans le syst√®me d'exploitation lui-m√™me, mais le syst√®me d'exploitation fonctionne dans une zone prot√©g√©e de m√©moire et devrait contenir le moins de fonctionnalit√©s possible et n√©cessaire.Par cons√©quent, le format ELF offre la possibilit√© de dire au syst√®me d'exploitation que nous voulons t√©l√©charger un autre programme, et cet "autre" programme t√©l√©chargera toutes les biblioth√®ques n√©cessaires et notre programme et d√©marrera le tout.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, nous devons ex√©cuter 3 fichiers, c'est le jeu de t√¢ches, le temps, java. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V√©rifiez le premier d'entre eux:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ whereis taskset<font></font>
taskset: /usr/bin/taskset /usr/share/man/man1/taskset.1.gz<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bash ex√©cutera le fichier / usr / bin / taskset, v√©rifiez ce qu'il contient:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ file /usr/bin/taskset<font></font>
/usr/bin/taskset: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=7a2fd0779f64aa9047faa00f498042f0f0c5dc60, stripped<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit du fichier ELF dont j'ai parl√© plus haut. </font><font style="vertical-align: inherit;">Dans le fichier ELF, en plus du programme lui-m√™me, il existe diff√©rents en-t√™tes. </font><font style="vertical-align: inherit;">En lan√ßant ce fichier, le syst√®me d'exploitation v√©rifie ses en-t√™tes et si l'en-t√™te ¬´Requesting program interpreter¬ª existe dans le fichier, le syst√®me d'exploitation lancera le fichier √† partir de cet en-t√™te et transmettra le fichier initialement lanc√© comme argument. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V√©rifiez si cet en-t√™te existe dans notre fichier ELF:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ readelf -a /usr/bin/taskset  | grep -i interpreter<font></font>
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'en-t√™te existe, ce qui signifie qu'en lan√ßant le fichier / usr / bin / tasket nous ex√©cutons r√©ellement /lib64/ld-linux-x86-64.so.2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V√©rifiez ce qu'est ce fichier:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ ls -lah /lib64/ld-linux-x86-64.so.2<font></font>
lrwxrwxrwx 1 root root 10 May 21  2019 /lib64/ld-linux-x86-64.so.2 -&gt; ld-2.17.so<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit d'un lien sim vers le fichier /lib64/ld-2.17.so. </font><font style="vertical-align: inherit;">V√©rifiez-le:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ file /lib64/ld-2.17.so<font></font>
/lib64/ld-2.17.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=a527fe72908703c5972ae384e78d1850d1881ee7, not stripped<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, il s'agit d'un autre fichier ELF que le syst√®me d'exploitation ex√©cutera. </font><font style="vertical-align: inherit;">Nous regardons les en-t√™tes:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ readelf -a /lib64/ld-2.17.so  | grep -i interpreter<font></font>
[user@localhost]$<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous voyons que ce fichier ELF n'a pas un tel en-t√™te, donc le syst√®me d'exploitation ex√©cutera ce fichier et lui transf√©rera le contr√¥le. </font><font style="vertical-align: inherit;">Et d√©j√† ce fichier ouvrira notre fichier / usr / bin / tasket, lisez √† partir de l√† des informations sur toutes les biblioth√®ques n√©cessaires. </font><font style="vertical-align: inherit;">La liste des biblioth√®ques requises se trouve √©galement dans les en-t√™tes du fichier ELF. </font><font style="vertical-align: inherit;">On peut regarder cette liste avec la commande ldd ou readelf, qui est la m√™me chose:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ ldd /usr/bin/taskset<font></font>
	linux-vdso.so.1 =&gt;  (0x00007ffc4c1df000)<font></font>
	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f4a24c4e000)<font></font>
	/lib64/ld-linux-x86-64.so.2 (0x00007f4a2501b000)<font></font>
<font></font>
[user@localhost]$ readelf -a /usr/bin/taskset  | grep NEEDED<font></font>
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VDSO est un morceau de m√©moire li√© qui n'est pas li√© aux biblioth√®ques, il est donc absent du fichier ELF en tant que biblioth√®que n√©cessaire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De cela, il est clair que le programme /lib64/ld-2.17.so est responsable de l'ex√©cution de tous les programmes qui en ont besoin, et ce sont tous des programmes avec des biblioth√®ques li√©es dynamiquement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous ex√©cutons / usr / bin / taskset, c'est exactement la m√™me chose que nous ex√©cutons /lib64/ld-2.17.so avec l'argument / usr / bin / taskset. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous revenons au probl√®me de l'influence du disque sur nos tests. </font><font style="vertical-align: inherit;">Maintenant, nous savons que si nous voulons charger notre programme de la m√©moire, nous devons copier non pas un fichier, mais plusieurs:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp /lib64/libc-2.17.so /mnt/ramdisk/<font></font>
[user@localhost]$ cp /lib64/ld-2.17.so /mnt/ramdisk/<font></font>
[user@localhost]$ cp /usr/bin/taskset /mnt/ramdisk/<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous faisons de m√™me pour le temps, les exigences de la biblioth√®que sont exactement les m√™mes (nous avons d√©j√† copi√© ld et libc).</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp /usr/bin/time /mnt/ramdisk/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour java, les choses sont un peu plus compliqu√©es, car java n√©cessite de nombreuses biblioth√®ques diff√©rentes qui peuvent √™tre copi√©es pendant longtemps. </font><font style="vertical-align: inherit;">Pour simplifier un peu ma vie, je vais copier tout le r√©pertoire de mon openjdk java sur un disque en m√©moire et cr√©er un lien sim. </font><font style="vertical-align: inherit;">Bien s√ªr, les acc√®s disque resteront dans ce cas, mais il y en aura moins.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp -R /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64 /mnt/ramdisk/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Renommez l'ancien r√©pertoire en y ajoutant le .default final</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo mv /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64{,.default}
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et cr√©ez un lien symbolique:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo ln -s /mnt/ramdisk/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64 /usr/lib/jvm/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous savons d√©j√† comment ex√©cuter un fichier binaire via l'argument du fichier /lib64/ld-2.17.so, qui d√©marre r√©ellement. </font><font style="vertical-align: inherit;">Mais comment faire pour que le programme /lib64/ld-2.17.so charge les biblioth√®ques charg√©es √† partir du r√©pertoire que nous avons sp√©cifi√©? </font><font style="vertical-align: inherit;">man ld pour nous aider, d'o√π nous apprenons que si vous d√©clarez la variable d'environnement LD_LIBRARY_PATH, le programme ld chargera les biblioth√®ques √† partir des r√©pertoires que nous sp√©cifions. </font><font style="vertical-align: inherit;">Nous avons maintenant toutes les donn√©es pour pr√©parer la ligne de lancement de l'application Java. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous commen√ßons plusieurs fois de suite et v√©rifions:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.66user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20344maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.65user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.66user 0.01system 0:10.68elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.65user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+96outputs (0major+5234minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendant l'ex√©cution du programme, nous pouvons ex√©cuter top et nous assurer que le programme s'ex√©cute sur le noyau CPU correct.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ top<font></font>
...<font></font>
%Cpu0  : 19.7 us, 11.7 sy,  0.0 ni, 68.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  9.8 us,  9.1 sy,  0.0 ni, 81.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  : 14.0 us,  9.0 sy,  0.0 ni, 77.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 s<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, les r√©sultats dans la plupart des cas sont similaires. </font><font style="vertical-align: inherit;">Malheureusement, nous ne pouvons pas supprimer compl√®tement l'influence du syst√®me d'exploitation sur le c≈ìur du processeur, donc le r√©sultat d√©pend toujours des t√¢ches sp√©cifiques √† l'int√©rieur du noyau Linux au moment du lancement. </font><font style="vertical-align: inherit;">Par cons√©quent, il est pr√©f√©rable d'utiliser la m√©diane des valeurs de plusieurs d√©marrages. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre cas, nous voyons que le programme java traite 9 000 000 000 avec parit√© √† travers le reste de la division en 10,65 secondes sur un c≈ìur du CPU. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faisons le m√™me test avec notre deuxi√®me programme, qui fait la m√™me chose via AND binaire.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.02user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5197minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.01user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20228maxresident)k<font></font>
0inputs+64outputs (0major+5199minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.01user 0.01system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5198minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.02user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5198minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous pouvons dire avec confiance que la comparaison de la parit√© via ET binaire prend 4,02 secondes, ce qui signifie que par rapport au contr√¥le dans le reste de la division, cela fonctionne 2,6 fois plus rapidement, au moins sur openjdk version 1.8.0.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oracle Java vs Openjdk</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai t√©l√©charg√© et d√©compress√© java jdk sur le site Web oracle dans le r√©pertoire /mnt/ramdisk/jdk-13.0.2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compile:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ /mnt/ramdisk/jdk-13.0.2/bin/javac OddEvenViaAnd.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous lan√ßons:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.39user 0.01system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 24260maxresident)k<font></font>
0inputs+64outputs (0major+6979minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.40user 0.01system 0:10.42elapsed 99%CPU (0avgtext+0avgdata 24268maxresident)k<font></font>
0inputs+64outputs (0major+6985minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous compilons le deuxi√®me programme:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ /mnt/ramdisk/jdk-13.0.2/bin/javac OddEvenViaMod.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous lan√ßons:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.39user 0.01system 0:10.40elapsed 99%CPU (0avgtext+0avgdata 24324maxresident)k<font></font>
0inputs+96outputs (0major+7003minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.40user 0.00system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 24316maxresident)k<font></font>
0inputs+64outputs (0major+6992minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le temps d'ex√©cution des m√™mes sources dans oracle jdk est le m√™me pour le reste de la division et AND binaire, ce qui semble normal, mais cette fois est √©galement mauvais, ce qui a √©t√© affich√© dans openjdk sur le reste de la division.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayons de comparer la m√™me chose en Python. </font><font style="vertical-align: inherit;">Tout d'abord, l'option avec le reste de la division par 2:</font></font><br>
<br>
<pre><code class="python hljs">odd=<span class="hljs-number">0</span>
even=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
	<span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<font></font>
		even += <span class="hljs-number">1</span>
	<span class="hljs-keyword">else</span>:<font></font>
		odd += <span class="hljs-number">1</span>
<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous lan√ßons:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.69user 0.00system 0:11.69elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.67user 0.00system 0:11.67elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.66user 0.00system 0:11.66elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, la m√™me chose avec ET binaire:</font></font><br>
<br>
<pre><code class="python hljs">odd=<span class="hljs-number">0</span>
even=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
	<span class="hljs-keyword">if</span> i &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span>:<font></font>
		even += <span class="hljs-number">1</span>
	<span class="hljs-keyword">else</span>:<font></font>
		odd += <span class="hljs-number">1</span>
<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous lan√ßons:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.41user 0.00system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 4588maxresident)k<font></font>
0inputs+0outputs (0major+1221minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.43user 0.00system 0:10.43elapsed 99%CPU (0avgtext+0avgdata 4588maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.43user 0.00system 0:10.43elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les r√©sultats montrent que ET est plus rapide. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur Internet, il a √©t√© √©crit √† plusieurs reprises que les variables globales en Python sont plus lentes. </font><font style="vertical-align: inherit;">J'ai d√©cid√© de comparer le temps d'ex√©cution du dernier programme avec ET et exactement le m√™me, mais envelopp√© dans une fonction:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
	odd=<span class="hljs-number">0</span>
	even=<span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
		<span class="hljs-keyword">if</span> i &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span>:<font></font>
			even += <span class="hljs-number">1</span>
		<span class="hljs-keyword">else</span>:<font></font>
			odd += <span class="hljs-number">1</span>
	<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
	<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd<font></font>
<font></font>
main()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ex√©cutez la fonction:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and_func.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
5.08user 0.00system 0:05.08elapsed 99%CPU (0avgtext+0avgdata 4592maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and_func.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
5.08user 0.00system 0:05.09elapsed 99%CPU (0avgtext+0avgdata 4592maxresident)k<font></font>
0inputs+0outputs (0major+1223minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, la m√™me comparaison de parit√© en Python via ET binaire dans une fonction traite 100000000 nombres sur un seul c≈ìur de processeur en ~ 5 secondes, la m√™me comparaison via AND sans fonction prend ~ 10 secondes et la comparaison sans fonction via le reste de la division prend ~ 11 secondes </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La raison pour laquelle un programme Python dans une fonction fonctionne plus rapidement que sans lui a d√©j√† √©t√© d√©crite plus d'une fois et est li√©e √† la port√©e des variables. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python a la capacit√© de d√©sassembler un programme en fonctions internes que Python utilise lors de l'interpr√©tation d'un programme. </font><font style="vertical-align: inherit;">Voyons quelles fonctions Python utilise pour la variante avec la fonction odd_and_func.py:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]# python<font></font>
Python 2.7.5 (default, Jun 20 2019, 20:27:34)<font></font>
[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linux2<font></font>
Type "help", "copyright", "credits" or "license" for more information.<font></font>
&gt;&gt;&gt; def main():<font></font>
...     odd=0<font></font>
...     even=0<font></font>
...     for i in xrange(100000000):<font></font>
...             if i &amp; 1 == 0:<font></font>
...                     even += 1<font></font>
...             else:<font></font>
...                     odd += 1<font></font>
...     print "even", even<font></font>
...     print "odd", odd<font></font>
...<font></font>
&gt;&gt;&gt; import dis<font></font>
&gt;&gt;&gt; dis.dis(main)<font></font>
  2           0 LOAD_CONST               1 (0)<font></font>
              3 STORE_FAST               0 (odd)<font></font>
<font></font>
  3           6 LOAD_CONST               1 (0)<font></font>
              9 STORE_FAST               1 (even)<font></font>
<font></font>
  4          12 SETUP_LOOP              59 (to 74)<font></font>
             15 LOAD_GLOBAL              0 (xrange)<font></font>
             18 LOAD_CONST               2 (100000000)<font></font>
             21 CALL_FUNCTION            1<font></font>
             24 GET_ITER<font></font>
        &gt;&gt;   25 FOR_ITER                45 (to 73)<font></font>
             28 STORE_FAST               2 (i)<font></font>
<font></font>
  5          31 LOAD_FAST                2 (i)<font></font>
             34 LOAD_CONST               3 (1)<font></font>
             37 BINARY_AND<font></font>
             38 LOAD_CONST               1 (0)<font></font>
             41 COMPARE_OP               2 (==)<font></font>
             44 POP_JUMP_IF_FALSE       60<font></font>
<font></font>
  6          47 LOAD_FAST                1 (even)<font></font>
             50 LOAD_CONST               3 (1)<font></font>
             53 INPLACE_ADD<font></font>
             54 STORE_FAST               1 (even)<font></font>
             57 JUMP_ABSOLUTE           25<font></font>
<font></font>
  8     &gt;&gt;   60 LOAD_FAST                0 (odd)<font></font>
             63 LOAD_CONST               3 (1)<font></font>
             66 INPLACE_ADD<font></font>
             67 STORE_FAST               0 (odd)<font></font>
             70 JUMP_ABSOLUTE           25<font></font>
        &gt;&gt;   73 POP_BLOCK<font></font>
<font></font>
  9     &gt;&gt;   74 LOAD_CONST               4 ('even')<font></font>
             77 PRINT_ITEM<font></font>
             78 LOAD_FAST                1 (even)<font></font>
             81 PRINT_ITEM<font></font>
             82 PRINT_NEWLINE<font></font>
<font></font>
 10          83 LOAD_CONST               5 ('odd')<font></font>
             86 PRINT_ITEM<font></font>
             87 LOAD_FAST                0 (odd)<font></font>
             90 PRINT_ITEM<font></font>
             91 PRINT_NEWLINE<font></font>
             92 LOAD_CONST               0 (None)<font></font>
             95 RETURN_VALUE<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et v√©rifiez la m√™me chose sans utiliser la fonction dans notre code:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt;&gt;&gt; f=open("odd_and.py","r")<font></font>
&gt;&gt;&gt; l=f.read()<font></font>
&gt;&gt;&gt;<font></font>
&gt;&gt;&gt; l<font></font>
'odd=0\neven=0\nfor i in xrange(100000000):\n\tif i &amp; 1 == 0:\n\t\teven += 1\n\telse:\n\t\todd += 1\nprint "even", even\nprint "odd", odd\n'<font></font>
&gt;&gt;&gt; k=compile(l,'l','exec')<font></font>
&gt;&gt;&gt; k<font></font>
&lt;code object &lt;module&gt; at 0x7f2bdf39ecb0, file "l", line 1&gt;<font></font>
&gt;&gt;&gt; dis.dis(k)<font></font>
  1           0 LOAD_CONST               0 (0)<font></font>
              3 STORE_NAME               0 (odd)<font></font>
<font></font>
  2           6 LOAD_CONST               0 (0)<font></font>
              9 STORE_NAME               1 (even)<font></font>
<font></font>
  3          12 SETUP_LOOP              59 (to 74)<font></font>
             15 LOAD_NAME                2 (xrange)<font></font>
             18 LOAD_CONST               1 (100000000)<font></font>
             21 CALL_FUNCTION            1<font></font>
             24 GET_ITER<font></font>
        &gt;&gt;   25 FOR_ITER                45 (to 73)<font></font>
             28 STORE_NAME               3 (i)<font></font>
<font></font>
  4          31 LOAD_NAME                3 (i)<font></font>
             34 LOAD_CONST               2 (1)<font></font>
             37 BINARY_AND<font></font>
             38 LOAD_CONST               0 (0)<font></font>
             41 COMPARE_OP               2 (==)<font></font>
             44 POP_JUMP_IF_FALSE       60<font></font>
<font></font>
  5          47 LOAD_NAME                1 (even)<font></font>
             50 LOAD_CONST               2 (1)<font></font>
             53 INPLACE_ADD<font></font>
             54 STORE_NAME               1 (even)<font></font>
             57 JUMP_ABSOLUTE           25<font></font>
<font></font>
  7     &gt;&gt;   60 LOAD_NAME                0 (odd)<font></font>
             63 LOAD_CONST               2 (1)<font></font>
             66 INPLACE_ADD<font></font>
             67 STORE_NAME               0 (odd)<font></font>
             70 JUMP_ABSOLUTE           25<font></font>
        &gt;&gt;   73 POP_BLOCK<font></font>
<font></font>
  8     &gt;&gt;   74 LOAD_CONST               3 ('even')<font></font>
             77 PRINT_ITEM<font></font>
             78 LOAD_NAME                1 (even)<font></font>
             81 PRINT_ITEM<font></font>
             82 PRINT_NEWLINE<font></font>
<font></font>
  9          83 LOAD_CONST               4 ('odd')<font></font>
             86 PRINT_ITEM<font></font>
             87 LOAD_NAME                0 (odd)<font></font>
             90 PRINT_ITEM<font></font>
             91 PRINT_NEWLINE<font></font>
             92 LOAD_CONST               5 (None)<font></font>
             95 RETURN_VALUE<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, dans la variante avec la fonction d√©clar√©e, Python utilise des fonctions internes avec le suffixe FAST, par exemple, STORE_FAST, LOAD_FAST, et dans la variante sans la d√©claration de la fonction, Python utilise les fonctions internes STORE_NAME et LOAD_NAME. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet article a peu de sens pratique et vise davantage √† comprendre certaines des fonctionnalit√©s de Linux et des compilateurs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bon √† tous!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr489194/index.html">Comment OpenShift modifie la structure organisationnelle d'une organisation informatique. L'√©volution des mod√®les organisationnels lors du passage au PaaS</a></li>
<li><a href="../fr489196/index.html">Magic Smoke: microcontr√¥leurs vs r√©gulateurs lin√©aires</a></li>
<li><a href="../fr489198/index.html">Comment ne pas se tirer une balle dans le pied avec Liquibase</a></li>
<li><a href="../fr489200/index.html">Ce que les startups recherchent Y Combinator en 2020</a></li>
<li><a href="../fr489204/index.html">Un aper√ßu de la fiabilit√© des services Facebook</a></li>
<li><a href="../fr489212/index.html">1C-Bitrix emp√™che la d√©sinscription √† la newsletter par l'obligation de soumettre leurs donn√©es personnelles</a></li>
<li><a href="../fr489214/index.html">Approche moderne pour tester la localisation sur iOS</a></li>
<li><a href="../fr489218/index.html">C'est na√Øf. Super: code et architecture d'un jeu simple</a></li>
<li><a href="../fr489226/index.html">M√©thodes d'optimisation des requ√™tes LINQ en C # .NET</a></li>
<li><a href="../fr489228/index.html">Bot de discours √† la banque - le pire UX de tous les temps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>