<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👍 💆🏻 ⛱️ Sécurité grâce à la restriction des utilisateurs ou comment créer une vulnérabilité 👨🏾‍🔬 🐳 👩🏾‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En 2019, la vulnérabilité CPDoS Cache Poisoned Denial of Service) a été découverte sur le réseau CDN, ce qui permet d'empoisonner le cache HTTP du fou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Sécurité grâce à la restriction des utilisateurs ou comment créer une vulnérabilité</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492718/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En 2019, la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vulnérabilité CPDoS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cache Poisoned Denial of Service) a </font><font style="vertical-align: inherit;">été </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">découverte</font></a><font style="vertical-align: inherit;"> sur le réseau CDN, ce qui permet d'empoisonner le cache HTTP du fournisseur CDN et de provoquer un déni de service. </font><font style="vertical-align: inherit;">La vulnérabilité n'a pas encore recueilli beaucoup de battage médiatique, car elle n'a pas été vue dans de vraies attaques. </font><font style="vertical-align: inherit;">Mais je veux parler séparément d'une des méthodes d'empoisonnement du cache. </font><font style="vertical-align: inherit;">Substitution de méthode HTTP.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rb/7j/wy/rb7jwy3an79ykaffwer39l297eu.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si d'autres variantes d'exploitation de la vulnérabilité d'une manière ou d'une autre s'appuient sur des bogues ou des fonctionnalités de modification de demande par un intermédiaire, alors la variante de substitution de méthode est basée sur la tactique du même nom, qui ne fait pas partie de la norme HTTP, entraîne des problèmes supplémentaires, et qui sont survenus et se sont propagés en raison d'une négligence relation avec la sécurité. </font><font style="vertical-align: inherit;">Ici, nous allons l'examiner.</font></font><br>
<a name="habracut"></a><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bref sur CPDoS si vous l'avez manqué</font></font></b><div class="spoiler_text"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"> </a> ,         URI  method   .<br>
<br>
      ,       ,       ,         ,      -   .       —            -  -   -,      ,    -     ,      .           ,         .<br>
<br>
            ,    . ,  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">   -</a>.      -   ,       ,      .<br>
<br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limitez le client, moins peut - moins se cassera</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le besoin même de remplacer la méthode dans la demande est dû au fait que certains pare-feu d'application Web et implémentations client HTTP étaient très limités et ne permettaient pas l'exécution de méthodes autres que GET et POST. Le problème n'est pas qu'il s'agissait d'une restriction d'implémentation, mais qu'il s'agissait d'une restriction intentionnelle des clients HTTP par une politique de sécurité. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est clair que tout a été réalisé avec la bonne intention de couper le trafic exigu, non standard pour les clients HTTP ordinaires. Mais dans un souci de sécurité, toutes les méthodes sauf GET et POST ont été supprimées. Peut-être parce que ce sont les seules méthodes qui </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">pas facultatives et requises</font></a><font style="vertical-align: inherit;"> pour les serveurs à usage général.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La raison pour laquelle il était nécessaire d'introduire une restriction aussi stricte n'est pas claire. Oui, les attaques avec l'introduction de différents caractères afin de confondre l'analyseur ne sont que le passe-temps des protocoles de texte. Mais vous pouvez autoriser un peu plus de méthodes, par exemple, prendre au moins celles qui sont </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">décrites dans la norme elle-même</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://www.iana.org/assignments/http-methods/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enregistrées auprès de l'IANA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cela ne valait pas la peine de supprimer complètement la vérification des méthodes, mais vous pouvez composer un certain nombre des méthodes les plus populaires et en exclure celles qui modifient le protocole d'interaction et interrompent le travail avec les connexions sur le serveur proxy (CONNECT). Mais non, il s'est avéré une politique de sécurité qui a introduit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> restrictions et des interdictions </font><i><font style="vertical-align: inherit;">inutiles</font></i><font style="vertical-align: inherit;"> pour les clients.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et les clients étaient limités aux mauvais. </font><font style="vertical-align: inherit;">Ils voulaient limiter la variabilité des messages des clients HTTP et limitaient les clients protégés par ces WAF, les serveurs d'applications finaux et leurs développeurs. </font><font style="vertical-align: inherit;">Désormais, les développeurs n'avaient plus que deux méthodes qui n'étaient pas toujours suffisantes pour décrire la logique du client HTTP.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des contraintes sont créées pour les surmonter.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il était à prévoir que cette restriction excessive commencerait tôt ou tard à interférer avec les développeurs Web. L'ironie est qu'il est si facile de ne pas se débarrasser de ces WAF. Surtout quand ils sont avec des clients ou des fournisseurs. Remettre en question les politiques de sécurité des autres est une affaire désastreuse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En raison de la flexibilité de HTTP, il n'est pas difficile de contourner cette limitation; ajoutez simplement quelque chose à la demande où vous pouvez remplacer la méthode. Strict WAF vérifiera uniquement la méthode dans la ligne de demande (la première ligne de la demande) et sera heureux de voir un GET ou POST approuvé là-bas. Et le backend pourra analyser l'élément ajouté et en extraire la vraie méthode. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://fandry.blogspot.com/2012/03/x-" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">google un </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tas d' </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://docs.inpaas.com/docs/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">articles, </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vraiment un </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://www.infoworld.com/article/3249687/how-to-implement-a-delegatinghandler-for-x-" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur la façon dont les proxys défectueux ont brisé les applications REST, et comment les auteurs ont dû passer la vraie méthode dans un en-tête séparé. </font><font style="vertical-align: inherit;">Dans chacun d'eux, ils suggèrent que vous saisissiez approximativement le même en-tête (méthode X-HTTP, méthode X-HTTP-Override ou méthode X-Override - l'orthographe varie quelque peu) pour indiquer une méthode remplacée. </font><font style="vertical-align: inherit;">Très, très rarement, on peut trouver des références qui peuvent être utilisées pour le même objet URI de composant de requête. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce qui manque dans ces articles, c'est la section Considérations sur la sécurité. </font><font style="vertical-align: inherit;">Et ils le sont.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La méthode est-elle sûre?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parfois, les développeurs d'applications Web oublient qu'entre le client et le serveur, il peut y avoir des participants intermédiaires qui interagissent via le protocole HTTP: mandataires, caches Web des fournisseurs, CDN et WAF. La prolifération de TLS réduit considérablement les chances d'un participant intermédiaire entre le client et le serveur. Le seul proxy entre le client et le backend sera probablement son propre serveur avec Nginx. Et une telle configuration est assez facile à tester sur des scénarios typiques avant sa sortie.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais nous entrons dans l'ère du CDN, et de plus en plus d'applications se cacheront derrière les CDN qui lisent et manipulent le trafic des utilisateurs. </font><font style="vertical-align: inherit;">Les backends ne servent presque jamais directement les utilisateurs et se cachent derrière des proxys inversés pour augmenter la réactivité et les performances. </font><font style="vertical-align: inherit;">Par conséquent, vous devrez vous rappeler comment le remplacement d'une méthode peut affecter le traitement d'une demande sur un serveur de médiation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les attaques dont je veux parler s'appliquent principalement à HTTP / 1.1. </font><font style="vertical-align: inherit;">HTTP / 2 hérite en quelque sorte du comportement de l'ancienne norme, à certains égards suit sa propre voie, donc l'applicabilité de chaque attaque à la nouvelle norme sera considérée séparément.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attaques de cache</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le plus souvent, les serveurs intermédiaires ne prennent pas en compte les remplacements de méthode, ne vérifient pas les en-têtes de la famille X-HTTP-Method-Override et travaillent avec la demande en utilisant sa méthode principale à partir de la ligne de demande. Et puisque la méthode remplacée n'est pas incluse dans la clé pour rechercher une demande dans le cache (méthode + URI), ces serveurs ne peuvent pas distinguer POST de POST + X-HTTP-Method-Override: DELETE. Cela signifie que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous ne pouvez pas autoriser la mise en cache des</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> requêtes vers un certain URI si le backend peut surveiller et exécuter des méthodes remplacées.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le document CPDoS a un bon exemple de ce qui se passe si vous mettez en cache une telle demande. Lorsqu'un attaquant déguise une demande POST en demande GET, le proxy ne reconnaît pas les substitutions et traite la demande comme une demande GET légitime. Le backend, cependant, reconnaît la méthode substituée et exécute le verbe décrit dans l'en-tête X-HTTP-Method-Override - POST. Étant donné que la méthode POST n'est pas définie pour l'URI de destination, le serveur génère une erreur. En outre, la réponse de backend est stockée dans le cache en tant que réponse à la méthode d'origine - GET. Maintenant, toute prochaine requête GET pour le même URI retournera une erreur mise en cache.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/0r/bv/_q/0rbv_qeocdxi9b4ctw2rschthgw.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, l'attaque est légèrement plus large que celle présentée dans le document. Les auteurs se sont concentrés sur le stockage de l'erreur dans le cache, qui n'est pas partout (déjà) reproductible. Mais si la méthode demandée pour l'URI sélectionné est définie et sera exécutée avec succès, le proxy recevra une réponse avec un état de 200 et la mettra en cache. Ensuite, les demandes suivantes du même URI pour recevoir des réponses à la méthode complètement erronée. Dans ce scénario, il n'y a plus d'exigence avec une erreur de cache de réponses 4XX, comme dans la description CPDoS d'origine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le problème inverse peut se produire. Si un client HTTP respectable envoie une demande GET + X-HTTP-Method-Override: PATCH (c'est mauvais, mais plus à ce sujet plus tard), et le cache a déjà une réponse GET, alors le client recevra cette réponse en cache. Dans ce cas, le backend ne recevra jamais de demande PATCH, ce qui peut violer la logique d'application sur le client et le serveur.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez réduire l'effet sur le cache en créant les stratégies de mise en cache correctes et en divisant les ressources en deux groupes: ceux pour lesquels l'opération de substitution de méthode est inacceptable ou non requis, les réponses à ceux-ci peuvent être mises en cache et celles pour lesquelles l'opération de remplacement de méthode est nécessaire, toute mise en cache de ces réponses est inacceptable . Mais moins les ressources sont mises en cache, moins le CDN est utile et plus le trafic atteint le backend, plus l'application est exposée au déluge HTTP. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, il est préférable d'utiliser le cache HTTP autant que possible, pour cela, il est nécessaire que le serveur de cache puisse distinguer les demandes avec différentes méthodes remplacées. La première façon consiste à transférer le remplacement de méthode du composant de requête vers l'URI:</font></font><br>
<br>
<pre><code class="plaintext hljs">POST /some-uri HTTP/1.1<font></font>
X-HTTP-Method-Override: DELETE<font></font>
   ↓  ↓   ↓<font></font>
POST /some-uri?method=DELETE HTTP/1.1<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Désormais, les requêtes avec différentes méthodes sont différentes pour le cache, car elles obtiennent des clés différentes. Certains mandataires préfèrent ne pas mettre en cache les réponses aux demandes contenant le composant de requête dans l'URI. Mais cela n'affectera que l'efficacité de la mise en cache. Cette méthode résout toujours les problèmes de mise en cache incorrecte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une autre façon consiste à laisser la méthode remplacer dans un en-tête séparé, mais entrez une clé secondaire pour trouver la réponse dans le cache. Cela est possible avec l'en-tête Vary. Lors du traitement de la demande, le serveur répétera l'en-tête avec la méthode override et reflétera le nom de cet en-tête dans l'en-tête Vary. Ensuite, aux demandes suivantes, le serveur de cache utilisera la valeur de la méthode remplacée comme clé secondaire lors de la recherche d'une demande dans le cache.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/oh/1n/rd/oh1nrdf3x18yktd6moekwlr01-w.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette méthode fonctionne si le serveur intermédiaire peut fonctionner avec des clés secondaires. </font><font style="vertical-align: inherit;">C'est généralement le cas, mais le niveau de confiance du proxy, qui coupe toutes les méthodes sauf GET et POST, est généralement plus bas et il est préférable de le vérifier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remplacer une méthode par le biais de n'importe quelle entité à l'intérieur du corps de la demande présente exactement les mêmes inconvénients que le remplacement par un en-tête supplémentaire - cela est hors de la visibilité du cache.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attaques Message Queuing</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Même si les attaques de cache sont fermées, ce n'est pas tout. </font><font style="vertical-align: inherit;">Un attaquant en redéfinissant une méthode peut essayer de modifier le cadrage de la réponse et ainsi violer la correspondance des paires requête-réponse pour les autres clients. </font><font style="vertical-align: inherit;">Ou forcez le côté serveur de l'application à traiter plusieurs fois la même demande.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La chose la plus importante qui est requise pour cela est un serveur intermédiaire fonctionnant en mode proxy inverse. Autrement dit, tout serveur de mise en cache ou CDN. Un tel proxy prend en charge un nombre relativement faible de connexions au backend et multiplie les demandes de nombreux clients dans chacun d'eux. Cela est nécessaire à la fois pour prendre la charge de la prise en charge d'un grand nombre de connexions clientes des backends vers le serveur proxy et pour équilibrer la charge entre les backends. La terminaison des connexions TLS se produit également sur le proxy, les connexions client ne sont jamais connectées directement au backend. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que maintenant les demandes de différents clients seront dans la même connexion entre le backend et le proxy, il est nécessaire de maintenir une correspondance claire entre les paires requête-réponse. La plupart des procurations </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ne</font></a><font style="vertical-align: inherit;"> prévoient </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(pipelines) envoie des requêtes au backend et fonctionne avec lui en mode de réponse aux requêtes. Le mode demande-réponse est plus simple et soumis à pratiquement une menace: le blocage de la connexion. Si vous établissez la connexion sur une seule paire demande-réponse, vous pouvez provoquer un retard, voire un refus, pour traiter les demandes suivantes (par exemple, si vous réussissez à déborder les files d'attente de demandes de procurations).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Des proxies plus productifs acheminent les requêtes vers le backend - cela vous permet d'envoyer immédiatement un paquet de requêtes au serveur et d'attendre leur exécution. Les performances sont supérieures, mais les menaces sont plus nombreuses. Premièrement, le problème du blocage en tête de ligne ne disparaît nulle part - même si le backend peut ratisser le pipeline de requêtes et les exécuter en parallèle, elles ne peuvent pas être envoyées si la première d'entre elles se bloque. Deuxièmement, si vous cassez le cadrage de la réponse, vous pouvez confondre le proxy et rompre la correspondance des paires demande-réponse, puis certains clients peuvent obtenir les réponses d'autres personnes, ou au moins parvenir à une fermeture de connexion instantanée avec le backend.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/td/wn/rj/tdwnrjiw4ekrsl7l1aqda-hhyzi.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La redéfinition la plus simple et la plus amusante d'une méthode consiste à remplacer GET par le verbe HEAD. Si la réponse à la première a un corps, la seconde non. De plus, tous les autres en-têtes sont identiques, y compris ceux qui fournissent le cadrage de la demande. Lorsque le proxy redirige une telle HEAD remplacée vers le serveur, il attend du serveur non seulement les en-têtes de réponse, mais aussi le corps de réponse, que le backend ne va pas envoyer. Si le proxy et le serveur interagissent dans le mode de demande-réponse, la connexion se "bloque" jusqu'à ce qu'elle soit interrompue par le délai d'expiration.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si le serveur envoie les réponses suivantes (mode pipeline), elles peuvent être analysées non pas comme des réponses indépendantes, mais dans le cadre de la réponse incomplète précédente à l'EEG. Le proxy les placera (ou une partie d'entre eux) dans le corps de la réponse "GET" et l'enverra à l'attaquant pour les lire. Vous pouvez créer un tel pseudo-GET pour recevoir un fichier volumineux et vider du trafic entre le proxy et le backend. Le succès dépend de la façon dont le backend place le Content-Length et le Transfer-Encoding: des en-têtes fragmentés pour encadrer les messages. Le premier vous permettra presque toujours d'obtenir un vidage, le second générera souvent des erreurs d'analyse et provoquera une déconnexion du backend. Si vous n'êtes pas du tout chanceux, le pseudo-GET peut couvrir plusieurs réponses dans son intégralité et se terminer juste avant la réponse suivante.Le proxy ne pourra pas du tout reconnaître ce problème et pour d'autres réponses à cet égard, la correspondance demande-réponse sera violée.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ee/ds/h9/eedsh90uounshmxglkz5aconiim.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Même si tout ce qui a été réalisé en remplaçant la méthode a été de fermer la connexion entre le proxy et le backend, cela peut suffire pour une attaque. </font><font style="vertical-align: inherit;">Vous pouvez lancer des demandes de service avec de telles demandes - les connexions avec les backends seront constamment interrompues. </font><font style="vertical-align: inherit;">Il n'y en a pas tellement, et la redécouverte prend du temps, par conséquent, vous pouvez réduire considérablement les performances de communication du serveur proxy et ainsi réduire le débit du service.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relecture automatique du spam</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai dit ci-dessus que les demandes de la forme GET + X-HTTP-Method-Override: PATCH de clients respectables sont mauvaises. Et c'est mauvais parce que les méthodes ont deux propriétés: la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sécurité</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idempotence</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La sécurité signifie que la méthode ne modifie pas l'état du serveur (lecture seule) et ne nous intéresse pas dans le cadre de cet article. L'idempotence de la méthode garantit que la demande répétée a le même effet qu'une demande unique. Vous pouvez faire une analogie: </font></font><code>(a = 5)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- requête idempotente, et </font></font><code>(a += 2) </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- non idempotente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette propriété est ce qui nous intéresse. Si la connexion entre le client et le serveur se brise soudainement, le client, sachant que la méthode est idempotente, peut renvoyer automatiquement la demande. Les mandataires se comportent de la même manière. Les requêtes non idempotentes ne sont pas répétées automatiquement car on ne sait pas comment elles affectent le serveur et ce que le client recevra à la fin. Je pense que tout le monde connaît les fenêtres contextuelles du navigateur: "Voulez-vous vraiment répéter la demande?" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous masquez une méthode non idempotente comme idempotente, en cas d'erreurs, elle ne sera pas supprimée, mais sera à nouveau redirigée vers le serveur. Même si le client considérera la méthode de demande réelle avant de soumettre à nouveau la demande, cela n'aidera pas beaucoup, car le serveur proxy ne connaît pas la substitution de méthode et répétera ces demandes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si un attaquant est en mesure de forcer les déconnexions entre le backend et les clients, il pourra amener le serveur à exécuter à plusieurs reprises des requêtes non idempotentes et à réduire la fiabilité et la prévisibilité de l'application. </font><font style="vertical-align: inherit;">Dans la section précédente, nous venons de trouver un moyen de provoquer des ruptures de connexion avec la même substitution de méthode. </font><font style="vertical-align: inherit;">Bien qu'il ne faut pas oublier qu'Internet est un réseau peu fiable, par définition, et que l'application elle-même est en danger. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour vous protéger contre cette attaque, vous ne devez utiliser que des méthodes qui n'ajoutent pas de nouvelles propriétés à la demande en tant que transport. </font><font style="vertical-align: inherit;">POST est un bon candidat, car par défaut il n'est ni sûr ni idempotent.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cet ancien HTTP / 1.1, comme avec HTTP / 2?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTTP / 2 a changé la façon dont les requêtes sont transportées entre les nœuds, mais il n'a pas changé leur signification lexicale. Par conséquent, dans les attaques liées à la valeur de la requête, HTTP / 2 se comporte de la même manière. Mais les attaques de «transport» ne sont pas reproduites, car elles sont déjà prises en compte dans la norme. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les attaques sur le cache sont</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reproduites de manière similaire à HTTP / 1, et la protection est similaire. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les attaques Message Queuing</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne s'appliquent pas à HTTP / 2. Les messages HTTP qu'il contient sont divisés en trames distinctes, avec des en-têtes de trame distincts qui déterminent explicitement la longueur et la fin du message. Comme si l'attaquant ne changerait pas la méthode et ne modifierait pas les en-têtes HTTP, cela n'affecterait pas le cadre du message. Voler la réponse échouera. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les attaques contre la répétition de messages non idempotents sont</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> applicables même en tenant compte du fait que dans HTTP / 2 il y a</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mécanisme de notification de la dernière demande traitée</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dans HTTP / 2, plusieurs requêtes sont multipliées dans le même TCP et créent ainsi des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flux</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Chaque fil a son propre numéro. </font><font style="vertical-align: inherit;">Si le serveur HTTP / 2 se déconnecte, il peut indiquer le numéro de la dernière demande traitée dans GOAWAY. </font><font style="vertical-align: inherit;">Les demandes avec un nombre plus élevé peuvent toujours être redirigées en toute sécurité; les demandes avec un nombre inférieur ne sont redirigées que si elles sont idempotentes. </font><font style="vertical-align: inherit;">Si une demande avec une méthode substituée semble idempotente pour un serveur proxy, le proxy la transmettra au serveur.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment remplacer en toute sécurité une méthode</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La réponse courte n'est pas possible. Il vaut mieux ne pas utiliser du tout les substitutions de méthode. Et désactivez complètement la prise en charge dans le backend, le cas échéant. Bloquer les méthodes de substitution des clients HTTP. Refuser le proxy / WAF, ce qui coupe les méthodes "supplémentaires". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous devez en quelque sorte vivre avec la redéfinition de la méthode, alors pour empêcher suffisamment de modifications sur le backend. Tout d'abord, il est conseillé de remplacer la méthode uniquement via le composant de requête de l'URI.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deuxièmement, il devrait y avoir une liste blanche de la transformation des méthodes: qui sont acceptables en tant que «transport» et qui en résultent. </font><font style="vertical-align: inherit;">Il ne devrait pas y avoir de fonctions de transformation généralisées lorsqu'une méthode peut être remplacée par n'importe laquelle. </font><font style="vertical-align: inherit;">La méthode de «transport» ne devrait pas avoir les propriétés de sécurité et d'idempotence si celle qui en résulte n'en a pas. </font><font style="vertical-align: inherit;">Les transformations dangereuses doivent être interdites, le même remplacement GET -&gt; HEAD.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dois-je corriger un proxy / WAF problématique?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si le proxy n'implémente que les méthodes GET et POST, et bloque les autres pour une raison ou une autre, certainement oui. </font><font style="vertical-align: inherit;">Vous pouvez l'optimiser principalement pour GET et POST, mais bloquer d'autres méthodes est une mauvaise idée. </font><font style="vertical-align: inherit;">Ce qui crée encore un gouffre de méfiance à l'égard du produit: si les choses de base sont bloquées, à quoi s'attendre de la mise en œuvre de problèmes plus complexes?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous vous inquiétez de la sécurité des applications Web protégées, il peut être utile de sécuriser les applications contre les stratégies de substitution de méthode non sécurisées. </font><font style="vertical-align: inherit;">Bien sûr, dans le cas général, sans connaître les détails de la mise en œuvre de l'application Web, il est impossible de protéger complètement l'application contre les remplacements incorrects, mais vous pouvez couvrir partiellement les utilisateurs qui ne connaissent tout simplement pas le problème. </font><font style="vertical-align: inherit;">Il est nécessaire non seulement de vous protéger contre l'empoisonnement de votre propre cache, mais également de permettre d'activer ou de désactiver la substitution pour chaque application protégée. </font><font style="vertical-align: inherit;">Pour ce faire, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gardez une trace des en- </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">têtes couramment utilisés.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X-HTTP-Method, X-HTTP-Method-Override et X-Method-Override. </font><font style="vertical-align: inherit;">Le suivi de la redéfinition dans le composant de requête de l'URI n'a pas beaucoup de sens: le cache n'empoisonne pas une telle demande, et la requête peut être très longue et avoir un format complètement arbitraire.</font></font><br>
<br>
<h2>      ?</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Développeurs de sécurité, ne limitez pas les développeurs d'applications aux politiques de sécurité. </font><font style="vertical-align: inherit;">Ils trouveront toujours comment les contourner, et plus le protocole est flexible, plus il est facile de le faire. </font><font style="vertical-align: inherit;">Il est très probable qu'ils ne vous frapperont pas et n'attendront pas que vous rendiez les restrictions plus raisonnables, mais les contournent simplement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous avez compris comment implémenter quelque chose dans le protocole, mais qu'il remplace ou va à l'encontre de l'un des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">concepts clés de la</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> norme, des problèmes de compatibilité et de sécurité se poseront sûrement. </font><font style="vertical-align: inherit;">Et ils doivent être couverts en même temps que la décision. </font><font style="vertical-align: inherit;">À chaque fois. </font><font style="vertical-align: inherit;">Si vous avez rencontré de tels conseils et n'avez pas vu d'avertissements de sécurité, ne dupliquez pas les conseils sur Internet. </font><font style="vertical-align: inherit;">Soyez toujours critique envers la décision et déterminez ce qui pourrait </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mal tourner</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au lieu d'une postface</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quels problèmes de serveur proxy avez-vous rencontrés? </font><font style="vertical-align: inherit;">Que fallait-il contourner et comment?</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr492706/index.html">Archives de la mémoire: comment le cerveau code et reproduit les souvenirs</a></li>
<li><a href="../fr492708/index.html">Internet satellite mondial - y a-t-il des nouvelles des champs?</a></li>
<li><a href="../fr492710/index.html">Chemin épineux du candidat à travers divers systèmes de GRH</a></li>
<li><a href="../fr492712/index.html">Maîtriser le développement grâce aux tests sur Android à l'aide de tests d'interface</a></li>
<li><a href="../fr492714/index.html">Travail efficace à domicile: général et personnel</a></li>
<li><a href="../fr492720/index.html">discussion: service de fichiers de projet</a></li>
<li><a href="../fr492724/index.html">Björn Straustrup répond aux 5 meilleures questions C ++ avec débordement de pile</a></li>
<li><a href="../fr492726/index.html">OS Sivelkiriya: processus de développement logiciel</a></li>
<li><a href="../fr492728/index.html">Astérisque et envoi manqués dans Telegram / Slack / E-mail</a></li>
<li><a href="../fr492730/index.html">Département américain de la Défense: éthique pour l'IA et les véhicules sans pilote</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>