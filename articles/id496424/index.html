<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸˆ‚ï¸ ğŸ‘µğŸ¼ ğŸ‘¨ğŸ¼â€ğŸš€ Tunjukkan saya solusi karena itu para pengembang tidak akan berdebat, dan saya akan memberi Anda bir ğŸ™ï¸ ğŸ¤½ğŸ¾ ğŸ‘”</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada dua kubu yang tidak bisa didamaikan. Beberapa mengatakan: Anda harus secara akurat dan kompeten menggambarkan komitmen Anda. Setiap komit adalah k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Tunjukkan saya solusi karena itu para pengembang tidak akan berdebat, dan saya akan memberi Anda bir</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496424/"><img src="https://habrastorage.org/webt/9m/cc/xu/9mccxujzxvko1w3tewtarvqazza.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada dua kubu yang tidak bisa didamaikan. Beberapa mengatakan: Anda harus secara akurat dan kompeten menggambarkan komitmen Anda. Setiap komit adalah karya yang lengkap dan bermakna. Jika Anda tidak dapat membuat deskripsi komit yang jelas dan sederhana, maka Anda memiliki komitmen yang salah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Orang lain menganggap bahwa Anda membuat komitmen sesuka Anda, ini adalah bagian dari alur kerja pribadi Anda. Tapi kumpulan permintaan dijelaskan secara rinci: apa yang dilakukan, bagaimana dilakukan, mengapa itu dilakukan. Saat diuji, masalah apa yang terpecahkan, apa yang harus Anda perhatikan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya seorang pendukung setia pendekatan kedua - tidak nyaman bagi saya untuk mengalahkan pekerjaan saya menjadi potongan-potongan mikro. Saya mengambil tugas kecil dan secara acak terburu-buru di sekitar basis kode, bereksperimen dan membuat perubahan dalam urutan yang ternyata. Jika saya dapat mengklik tombol, dan pekerjaan saya akan direstrukturisasi menjadi komitmen yang baik, saya akan mengkliknya. Tetapi tidak ada tombol, tetapi saya tidak ingin merusak diri saya sendiri. Pada saat yang sama, saya mencapai keterampilan tertentu dalam menggambarkan kumpulan permintaan. Saya kebetulan menemukan kode di Microsoft (melalui outstaff, itu tidak masuk hitungan), dan di sana saya mendapat standar teratas untuk memproses kumpulan permintaan. Selama bertahun-tahun, saya baru saja mengembangkan praktik ini. Biasanya saya berhasil meyakinkan tim untuk menggunakan pendekatan seperti itu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi pada pekerjaan terakhir, saya mendapatkan devlid - pendukung setia komitmen rinci. Oh, kami berdebat lama. Posisi bawahan saya berperan, kebiasaan Sovkovsky untuk setuju dengan hal utama tidak mudah untuk diam. Aku tidak begitu kategoris seperti biasa, dan diletakkan di kedua bilah. Ditumpuk, tetapi tidak yakin.</font></font><a name="habracut"></a><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika tiba-tiba para pengembang bersatu dalam satu pemerintahan, menetapkan peraturan dan mulai menyatakan pendekatan tertentu yang dilarang, perang saudara akan dimulai pada hari berikutnya. Semua karena di dunia pengembang ada kepercayaan akan tujuan dan terukur. Dalam kebenaran independen dari persepsi manusia. Dan jika semua ini ada, itu berarti bahwa salah satu pihak yang berselisih jelas secara objektif salah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perselisihan kerja serius pertama saya terjadi cukup awal. Saya masih seorang green juni, yang mengira dia tengah apper, dan memang pengembang yang sangat keren dan cerdas. Salah satu pengembang nyata dari tim saya melemparkan PR. Kami memiliki praktik bahwa semua anggota tim membuat kode ulasan. Saya membuka kode, dan segera melihat masalahnya. Seorang pria menulis tes untuk beberapa fungsi yang mengambil angka. Jadi dia memberinya 0, 1000, dan acak (0, 1000).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada saat itu, saya sangat merasa bahwa rekan satu tim lain melihat saya sebagai pendatang baru yang bodoh. Dan dia menunggu sebentar untuk mengolesi mereka dengan visinya. Saya beruntung - acak dalam tes! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak benar-benar memahami teori pengujian unit, tetapi saya membaca beberapa buku, dan ingat dengan kuat - unit test yang sama pada basis kode yang sama harus memberikan hasil yang sama. Saya menghabiskan sekitar satu jam untuk memikirkan komentar sehingga tidak terlihat beracun, tetapi saya menjelaskan bahwa hanya monyet, yang diajarkan untuk menghitung kemarin, bisa memikirkan keputusan seperti itu. Pada akhirnya, tentu saja, dia tampak sangat bodoh, seperti segala sesuatu yang magang kemarin yang membayangkan diri mereka sebagai pengembang yang diperas dari diri mereka sendiri.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keesokan harinya, saya menyadari bahwa saya telah membuka portal ke neraka. Ada seratus komentar lagi di bawah saya. Untuk sisa hari itu, alih-alih tim enam pengembang, kami adalah tim enam monyet. Kami berdebat dalam bahasa Inggris di PR sendiri, meskipun semua orang orang Rusia. Ketika stok kata-kata tidak cukup, mereka memanggil. Mereka saling menjatuhkan diri dengan tautan, kutipan dari buku, studi, beralih ke individu. Seorang kolega menjawab salah satu komentar saya dengan tangkapan layar dari kamus bahasa Inggris untuk mengejek bahasa Inggris saya. Tapi kami belum sampai pada kompromi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertanyaannya rumit. Di satu sisi, kita semua tidak tahu sama sekali apa yang bertanggung jawab atas parameter ini, fungsi kita meneruskannya ke yang lain, dari jaringan internal yang tidak memiliki dok. Oleh karena itu, secara teoritis, fungsi bisa jatuh pada nilai apa pun, yang berarti tes dapat menangkapnya, dan kemudian kita bisa mengantisipasi kesalahan pada prod. Di sisi lain, kami sudah memiliki masalah membangun berkubang secara acak. Karena itu, jika proyek tersebut sedang dibangun secara lokal dan mulai runtuh, kami dengan bodoh memesan bangunan baru dan tidak melihat log apa pun. Lagi pula, proses pembuatannya memakan waktu empat jam, dan tidak ada yang akan melihat permintaan tarik sampai lulus CI.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, mobil-mobil sering sibuk - itu jauh lebih pragmatis untuk memesan membangun sementara itu masih sedang dipesan daripada mencari "masalah" potensial (yang hampir selalu berubah menjadi waktu tunggu terbang dalam uji integrasi). Ini berarti bahwa bahkan jika tes acak gagal, kami tidak akan memperhatikan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya terselesaikan pada dealik berikutnya. Kami menelepon seluruh tim, dan selama setengah jam terus berdebat - dalam bahasa Rusia. Kami tidak memperhatikan bagaimana manajer pembangunan Amerika kami bergabung dengan panggilan itu, dan terus saling menghancurkan dengan argumen dengan nada tinggi. Sampai mereka mendengar, â€œHai teman-teman, sama sekali tidak penting. Gabungkan saja apa adanya. " Saya tidak tahu berapa lama dia mendengarkan kami sebelumnya, dan ketika dia mengerti apa yang sedang kita bicarakan, tapi kami berhenti dengan mendebat. Mereka membeku dan melupakannya. Berpisah dalam kedamaian, tetapi tidak yakin.</font></font><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejak itu, saya mendapatkan pengalaman untuk memahami - tetapi tidak peduli sama sekali, kasus acak, cacat, atau batas. Tes unit sialan ini akan mengganggu - kami akan menulis ulang. Semuanya lebih baik daripada berdebat sepanjang hari. Tetapi jika Anda membayangkan bahwa saya berada di dunia yang ideal, di mana selalu perlu untuk membuat keputusan yang lebih tepat, saya tidak tahu apa yang harus dilakukan. Kami membekukan uji dengan keacakan, dan sekarang saya memahami ini sebagai pilihan yang mendukung keandalan, tetapi merugikan kenyamanan pengembangan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suatu hari saya menghadapi dilema yang sama. Saya bermain dengan kode waktu baru dan menulis hal yang dapat digunakan seperti ini</font></font><br>
<br>
<pre><code class="actionscript hljs"><span class="hljs-comment">// LessThan&lt;T&gt;  MoreThan&lt;T&gt; -    ,   . </span>
<span class="hljs-comment">// ,        </span><font></font>
<font></font>
<span class="hljs-comment">//      , </span>
<span class="hljs-comment">//   ,   100</span>
<span class="hljs-keyword">const</span> consumeNumberLessThan100 = (v: LessThan&lt;<span class="hljs-number">100</span>&gt;) =&gt; <font></font>
    doWork(v);<font></font>
<font></font>
<span class="hljs-comment">//     ,   100</span>
<span class="hljs-keyword">const</span> consumeNumberMoreThan100 = (v: MoreThan&lt;<span class="hljs-number">100</span>&gt;) =&gt; doWork(v);<font></font>
<font></font>
<span class="hljs-keyword">const</span> sample = (x: number) =&gt; {<font></font>
<font></font>
    <span class="hljs-comment">//     check  , </span>
    <span class="hljs-comment">//   x  100</span>
    <span class="hljs-comment">//  "&lt;"  "&gt;"  , </span>
    <span class="hljs-comment">//     -   </span>
    <span class="hljs-keyword">const</span> lessThan100 = check(x,<span class="hljs-string">'&lt;'</span>, <span class="hljs-number">100</span>);<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (lessThan100) {
        <span class="hljs-comment">//     -  </span>
        <span class="hljs-comment">//       </span>
        <span class="hljs-comment">//    ,  lessThan100  - LessThan&lt;100&gt;</span>
        <span class="hljs-comment">//    </span><font></font>
        consumeNumberLessThan100(lessThan100); <font></font>
<font></font>
        <span class="hljs-comment">//   -  ,   , </span>
        <span class="hljs-comment">//  ,   &gt; 100.</span><font></font>
        consumeNumberMoreThan100(lessThan100);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">const</span> moreThan100 = check(x, <span class="hljs-string">'&gt;'</span>, <span class="hljs-number">100</span>);<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (moreThan100) {<font></font>
        consumeNumberMoreThan100(moreThan100); <span class="hljs-comment">// </span>
        consumeNumberLessThan100(moreThan100); <span class="hljs-comment">// </span><font></font>
    }<font></font>
<font></font>
    consumeNumberLessThan100(x); <span class="hljs-comment">// </span>
    consumeNumberMoreThan100(x); <span class="hljs-comment">// </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya pikir, sial, ini sangat keren - sehingga Anda dapat menangkap sejumlah besar kesalahan pada tahap sebelumnya. Desain alat pembatasan nilai saya sangat buruk, tetapi untuk sekarang ini hanya sebuah konsep. Di masa depan, Anda dapat dengan mudah mengembangkannya, membangun DSL yang kuat dan merumuskan kondisi yang sangat kompleks untuk pencocokan parameter yang dijamin pada tahap kompilasi. Saya menemukan cara untuk meningkatkan keandalan basis kode apa pun, bersemangat, dan mengirim cuplikan ke berbagai pengembang yang sudah dikenal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendapat dibagi lagi, dan tidak ke arah saya. Komplikasi ulang, rekayasa berlebihan, tidak didukung, semua orang akan macet penjaga Anda dengan bantuan pemain untuk eni. Tidak terbaca. Bagus sebagai eksperimen buruk dalam proyek ini. Contoh penggunaan diambil dari jari. Turun ke bisnis, Phil.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para pendukung pendekatan mengatakan, ya, sangat dapat diandalkan. Semakin cepat Anda menangkap kesalahan, semakin baik. Selain itu, jika Anda menulis fungsi yang bekerja dengan jumlah terbatas, Anda masih harus menulis cek, tetapi itu hanya akan bekerja di runtime, dan akan menambah jumlah kode di badan fungsi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang saya sedikit lebih pintar dari sebelumnya, dan belajar mendengarkan argumen. Saya membayangkan diri saya menulis fungsi yang dilindungi oleh tipe saya di proyek nyata. Seperti semua orang yang menggunakannya bertanya apa ini. Bagaimana, setelah meraba-raba chip, mereka mulai melapisi basis kode dengan DSL kustom yang tampak busuk. Ketika kami memeriksa tiga ratus kali nilai-nilai yang sebenarnya tidak akan pernah melebihi yang diizinkan. Pendekatannya benar-benar mengerikan untuk digunakan, beberapa masalah dapat diselesaikan atau dihaluskan, tetapi misalnya, kasus seperti itu</font></font><br>
<br>
<pre><code class="actionscript hljs">consumeNumberLessThan100(<span class="hljs-number">90</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jangan halus dengan cara apa pun. </font><font style="vertical-align: inherit;">Saya harus membuktikan kepada kompiler bahwa 90 kurang dari 100. Saya akan menyediakan aktivitas apa pun, dan hasilnya akan berubah</font></font><br>
<br>
<pre><code class="actionscript hljs">consumeNumberLessThan100(assert(<span class="hljs-number">90</span>, <span class="hljs-string">'&lt;'</span>, <span class="hljs-number">100</span>)); 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu tidak terlihat sangat keren. </font><font style="vertical-align: inherit;">Semua argumen melawan ada di tangan, tetapi mereka tidak bertentangan dengan argumen. </font><font style="vertical-align: inherit;">Ternyata dilema - kemudahan pengembangan, atau keandalan. </font><font style="vertical-align: inherit;">Di sini kita jatuh ke dalam perangkap, kita mulai berpikir bahwa kita perlu menghitung kenyamanan seperti apa yang ada dan reliabilitas seperti apa yang ada di sana. </font><font style="vertical-align: inherit;">Tetapi kemudahan dan keandalan dalam pengembangan adalah hal yang sangat, sangat kompleks. </font><font style="vertical-align: inherit;">Mereka terdiri dari ribuan parameter.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, kenyamanan adalah ketika IDE mengkompilasi kode untuk Anda pada sepasang karakter yang dimasukkan, ketika kode mudah dibaca, ketika Anda dapat mengubah fungsionalitas metode tanpa melihat dokumen. Ketika kompiler tidak dimuat dengan analisis statis, build cepat, editor teks langsung membuat karakter. Tetapi ketika kompiler mendeteksi dan menyoroti kesalahan untuk Anda, ini juga merupakan kenyamanan. Dan juga keandalan. Yang pada gilirannya dikumpulkan dari sejumlah besar hal yang sama sekali berbeda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda harus duduk dan menghitung berapa lama proyek akan berlangsung, ke arah mana ia akan pergi, berapa kali dalam sejarah umat manusia seseorang akan memanggil satu atau metode lain dari basis kode Anda, pengembang mana yang akan bekerja di sini. Ini adalah daftar pertanyaan tanpa akhir untuk sebagian yang baik di mana tidak mungkin untuk menghitung jawaban yang benar. Tebak saja.</font></font><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suatu hari, seorang teman meminta saya untuk menyiapkan pertanyaan teknis untuk wawancara dengan Andrei Breslav. Saya pergi ke dermaga Kotlin untuk menemukan poin kontroversial dalam desain. Mereka ada di sana, seperti di tempat lain, kegelapan. Tapi yang paling menarik minat saya adalah pendekatan untuk menangani pengecualian. Penangan pengecualian di Kotlin adalah ekspresi, pendekatan yang sepenuhnya fungsional dan andal. Itu hanya untuk menangani kesalahan tidak perlu. Yang menjatuhkan semua reliabilitas ke nol. Dan ini menarik karena tepat di dermaga, para pengembang tidak terlalu malas untuk menjelaskan pilihan mereka: "ada studi bahwa penanganan kesalahan wajib sangat mengurangi produktivitas pengembang dengan sedikit penurunan kesalahan."</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya gila, bagaimana Anda bisa menulis kode jika Anda tidak tahu apa yang harus dilakukan ketika itu tidak berfungsi dengan benar!? Jika Anda tidak tahu cara menangani pengecualian, maka jangan mengatasinya - bukan solusi untuk masalah, tetapi rak. Pada titik tertentu, kode akan jatuh, dan masalah yang selalu ada akan menyebabkan kerusakan yang bisa diantisipasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi argumen logis yang menentang tidak diperlukan, Anda hanya dapat melakukan statistik. Untuk pengembang kotlin, penelitian mematahkan logika karena mereka memiliki filosofi. Filsafat mereka adalah pragmatisme. Iron, pragmatisme yang tidak bisa dipecahkan, secara konsisten dibangun ke dalam semua fitur dari bahasa pemrograman ini. Kaum idealis yang melihat Haskels / Idris dan para govnokoder yang menulis golang melakukan hal yang persis sama. Filosofi kompromi yang masuk akal berkuasa dalam basis kode F #. Dan tidak ada perasaan bahwa salah satu dari mereka benar, dan sisanya bodoh. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua orang ini jauh lebih pintar dan lebih berpengalaman daripada orang-orang seperti saya, dan mereka tampaknya sudah lama mengerti bahwa Anda sedang mengembangkan filosofi untuk diri sendiri, dan kemudian Anda hanya mengikutinya. Karena fitur pembunuh dari setiap filosofi adalah untuk menyelesaikan dilema.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maka filsafat muncul dalam segala hal di TI, dan filsafat adalah kebalikan dari gagasan objektivitas tunggal dan sejati, karena filsafat menawarkan untuk memilih kebenaran subjektif untuk diri Anda sendiri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masing-masing dari kita memiliki filosofi kita sendiri - itu tidak dijelaskan dalam satu kata, itu adalah satu set pola kompleks untuk membuat keputusan. Dan kita sering mengubah atau mengembangkannya. Dalam praktiknya, ternyata Anda memiliki proyek dengan filosofi Anda sendiri, yang ditulis dalam bahasa pemrograman dengan filosofi Anda sendiri, menggunakan kerangka kerja dan alat, yang masing-masing memiliki filosofi sendiri. Dan pengembang menulis proyek ini, masing-masing dengan filosofi sendiri. Dan setiap kali Anda perlu membuat semacam keputusan, hanya kombinasi keadaan yang memengaruhi yang akan dibuat. Bukan manajemen kompleksitas, bukan pengalaman, bukan pendekatan, bukan pengetahuan, tetapi hanya kecelakaan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan semua proyek ini berhasil. Bagian terbesar dari semua tugas yang diselesaikan pengembang adalah penghapusan konsekuensi kesalahan pengembang lain, tetapi proyek berhasil dan menyelesaikan masalah orang. Orang pintar datang dengan praktik dan pola arsitektur. Memprogram bahasa dengan kontrol tipe yang kuat dan kontrak - semuanya, jika saja para pengembang tidak terlalu keliru. Dan setiap hari saya membuka Edge Board di tempat kerja, dan saya melihat ada lebih banyak bug daripada tugas. Di mana setiap bug, ini adalah yang lain, mengelola kompleksitas, pengembang omong kosong. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Filosofi pengembangan hanyalah pilihan cara Anda mencapai final. Tetapi jika tidak ada filsafat, tetapi hanya logika objektif murni, maka setiap argumen akan sampai pada masalah pencipta yang mahakuasa dan batu yang tak tertahankan.</font></font><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya sudah dalam pengembangan untuk waktu yang lama, dan saya telah belajar bagaimana melakukan apa yang mereka katakan, bahkan ketika saya pada dasarnya tidak setuju, dan mulai menulis komitmen yang sangat detail. Devlid saya adalah vampir yang nyata. Itu tidak hanya memerlukan deskripsi - dia ingin saya menulis apa yang dilakukan oleh setiap file, mengapa melakukannya, bagaimana melakukannya. Masalah apa yang dilakukan komit? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya menambahkan delapan komitmen ekstra-detail, deskripsi terperinci yang sama dari kumpulan permintaan - dan saya menyukainya kapet. Sejak itu, kami hampir tidak mengerjakan proyek khusus ini, tetapi dari waktu ke waktu saya pergi ke sana untuk mengagumi komitmen ini. Serius, sungguh, sangat keren. Dan di semua proyek lain, kecuali yang pribadi, saya sekarang menerapkan pendekatan ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sangat sulit bagi saya untuk membangun kembali alur kerja. Satu setengah bulan telah berlalu, dan masih sulit bagi saya untuk menulis kode seperti ini. Tapi sepertinya itu sepadan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atau tidak. </font><font style="vertical-align: inherit;">Sejujurnya saya tidak tahu. </font><font style="vertical-align: inherit;">Dan saya tidak tahu bahwa jika itu benar-benar layak, apakah itu membuat saya dua bulan benar-benar idiot. </font><font style="vertical-align: inherit;">Sekitar sepuluh orang berjalan di suatu tempat di dunia yang telah saya pelajari untuk tidak melakukan komitmen seperti itu. </font><font style="vertical-align: inherit;">Apakah mereka idiot? </font><font style="vertical-align: inherit;">Saya kira tidak.</font></font><br>
<br>
<br>
<hr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podcast saya</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id496406/index.html">Strategi Apple: mengapa iPad tidak memenuhi harapan</a></li>
<li><a href="../id496408/index.html">Prajurit universal atau spesialis sempit? Apa yang harus diketahui dan bisa dilakukan oleh insinyur DevOps</a></li>
<li><a href="../id496412/index.html">Konferensi DEFCON 26. Mengibas-ngibaskan ekor: pengawasan pasif terselubung. Bagian 2</a></li>
<li><a href="../id496418/index.html">Metodologi tangkas: perspektif bisnis (bagian 1)</a></li>
<li><a href="../id496422/index.html">Cara mulai bekerja di pengembang game internasional: tutorial dari 3D-modeler dari Ulyanovsk, yang menjadi co-owner studio</a></li>
<li><a href="../id496426/index.html">Implementasi CRM dalam krisis: membantu bisnis atau masalah mati?</a></li>
<li><a href="../id496428/index.html">Bagaimana cara menghemat pasar untuk kursus bahasa selama pandemi?</a></li>
<li><a href="../id496434/index.html">Antiquities: kehidupan kedua dari kaset portable</a></li>
<li><a href="../id496436/index.html">IPFS di server. Situs host dari laptop</a></li>
<li><a href="../id496438/index.html">Perbedaan yang jelas antara seorang pemimpin dan seorang manajer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>