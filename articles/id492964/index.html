<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”¡ ğŸ· ğŸ¤¹ğŸ¿ Memproses jutaan peristiwa per hari dengan antrian berjenjang ğŸ˜œ â¬†ï¸ âœ–ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ratusan, ribuan, dan dalam beberapa layanan, jutaan antrian, yang dilewati sejumlah besar data, berputar di bawah kap produk kami. Semua ini harus dip...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Memproses jutaan peristiwa per hari dengan antrian berjenjang</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/manychat/blog/492964/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ratusan, ribuan, dan dalam beberapa layanan, jutaan antrian, yang dilewati sejumlah besar data, berputar di bawah kap produk kami. </font><font style="vertical-align: inherit;">Semua ini harus diproses dengan cara magis dan tidak boleh ditembak. </font><font style="vertical-align: inherit;">Dalam posting ini saya akan memberi tahu Anda apa pendekatan arsitektur yang kami gunakan di rumah, memiliki tumpukan teknologi yang cukup sederhana dan tidak memiliki pusat data kecil di "dapur" kami.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/iq/-o/dc/iq-odcaikfzjfsiwqgpx2phk5us.png"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang kita miliki</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, di satu sisi, kami memiliki tumpukan teknologi yang terkenal: Nginx, PHP, PostgreSQL, Redis. </font><font style="vertical-align: inherit;">Di sisi lain, puluhan ribu peristiwa terjadi di sistem kami setiap menit, dan di puncaknya dapat mencapai ratusan ribu acara. </font><font style="vertical-align: inherit;">Untuk memperjelas apa acara-acara ini dan bagaimana kita harus menanggapinya, saya akan membuat penyimpangan produk kecil, setelah itu saya akan memberi tahu Anda bagaimana kami mengembangkan sistem otomatisasi berbasis acara.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ManyChat adalah platform untuk otomatisasi pemasaran. Pemilik halaman Facebook dapat menghubungkannya ke platform kami dan mengonfigurasi otomatisasi interaksi dengan pelanggannya (dengan kata lain, buat bot obrolan). Otomasi biasanya terdiri dari banyak rantai interaksi yang mungkin tidak saling berhubungan. Dalam rantai otomatisasi ini, tindakan tertentu dapat terjadi dengan pelanggan, misalnya, menetapkan tag tertentu dalam sistem, atau menetapkan / mengubah nilai suatu bidang dalam kartu pelanggan. Data ini selanjutnya memungkinkan Anda untuk mengelompokkan audiens dan membangun interaksi yang lebih relevan dengan pelanggan halaman.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pelanggan kami benar-benar menginginkan otomatisasi berbasis acara - kemampuan untuk menyesuaikan pelaksanaan suatu tindakan ketika suatu peristiwa tertentu dipicu dalam pelanggan (misalnya, penandaan). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena peristiwa pemicu dapat bekerja dari rantai otomatisasi yang berbeda, penting bahwa ada satu titik konfigurasi untuk semua tindakan berbasis Acara di sisi klien, dan di sisi pemrosesan kami harus ada satu bus yang memproses perubahan dalam konteks pelanggan dari titik otomatisasi yang berbeda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam sistem kami, ada bus umum di mana semua peristiwa yang terjadi dengan pelanggan lewat. Ini lebih dari 500 juta acara per hari. Pemrosesan mereka agak rumit - ini adalah catatan di gudang data, sehingga pemilik laman memiliki kesempatan untuk melihat secara historis segala sesuatu yang terjadi pada pelanggannya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tampaknya untuk menerapkan sistem berbasis Acara kami sudah memiliki segalanya, dan cukup bagi kami untuk mengintegrasikan logika bisnis kami ke dalam pemrosesan bus peristiwa umum. </font><font style="vertical-align: inherit;">Tetapi kami memiliki persyaratan tertentu untuk sistem baru kami:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami tidak ingin mendapatkan kinerja terdegradasi dalam memproses bus acara utama</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penting bagi kami untuk menjaga urutan pemrosesan pesan dalam sistem baru, karena hal ini dapat dikaitkan dengan logika bisnis klien yang mengatur otomatisasi</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hindari efek dari tetangga yang berisik ketika halaman aktif dengan sejumlah besar pelanggan menyumbat antrian dan memblokir pemrosesan acara halaman "kecil"</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita mengintegrasikan pemrosesan logika kita ke dalam pemrosesan bus peristiwa umum, maka kita akan mendapatkan penurunan kinerja yang serius, karena kita harus memeriksa setiap peristiwa untuk kepatuhan dengan otomatisasi yang dikonfigurasi. </font><font style="vertical-align: inherit;">Sebagai bagian dari pengaturan otomatisasi, filter tertentu dapat diterapkan (misalnya, mulai otomatisasi ketika suatu peristiwa dipicu hanya untuk klien wanita yang lebih tua dari 30 tahun). </font><font style="vertical-align: inherit;">Artinya, ketika memproses peristiwa di bus utama, sejumlah besar pertanyaan tambahan ke basis data akan diproses, dan juga logika yang agak berat akan mulai membandingkan konteks pelanggan saat ini dengan pengaturan otomatisasi. </font><font style="vertical-align: inherit;">Pilihan ini tidak cocok untuk kami, jadi kami berpikir lebih jauh.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xt/rq/in/xtrqingjirs1ne1ljopat1z-nti.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Organisasi riam antrian</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena logika bisnis kami yang terkait dengan sistem berbasis peristiwa dipisahkan dengan sangat baik dari logika untuk memproses peristiwa dari bus utama, kami memutuskan untuk meletakkan jenis peristiwa yang kami butuhkan dari bus bersama dalam antrian terpisah untuk diproses lebih lanjut dalam aliran data terpisah. Dengan demikian, kami menghilangkan masalah yang terkait dengan penurunan kinerja dalam memproses bus acara utama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada tahap yang sama, kami memutuskan apa yang akan keren untuk mentransfer acara ke antrian kaskade berikutnya untuk menempatkan acara ini dalam antrian terpisah untuk setiap bot. Dengan demikian, mengisolasi aktivitas masing-masing bot dengan kerangka gilirannya, yang memungkinkan kita untuk menyelesaikan masalah yang terkait dengan efek tetangga yang berisik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diagram alir data kami sekarang terlihat seperti ini:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/he/nz/2c/henz2cmwi9i5ii7pmzew-hokd3g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, agar skema ini berfungsi, kita perlu menyelesaikan masalah pemrosesan antrian baru.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada lebih dari 1 juta halaman yang terhubung (bot) di platform kami, yang berarti bahwa kita berpotensi mendapatkan ~ 1 juta antrian dalam skema kita, hanya pada tingkat lapisan berbasis peristiwa. </font><font style="vertical-align: inherit;">Dari sudut pandang teknis, ini tidak menakutkan bagi kami. </font><font style="vertical-align: inherit;">Sebagai server antrian, kami menggunakan Redis dengan tipe data standarnya, seperti LIST, SORTED SET, dan lainnya. </font><font style="vertical-align: inherit;">Ini berarti siapa setiap antrian adalah struktur data standar untuk Redis dalam RAM, yang dapat dibuat atau dihapus dengan cepat, yang memungkinkan kita untuk dengan mudah dan fleksibel mengoperasikan sejumlah besar antrian di sistem kami. </font><font style="vertical-align: inherit;">Saya akan berbicara lebih dalam tentang penggunaan Redis sebagai server antrian dengan detail teknis di pos terpisah, tetapi untuk sekarang mari kita kembali ke arsitektur kita.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jelas bahwa setiap bot memiliki aktivitas yang berbeda, dan bahwa kemungkinan mendapatkan 1 juta antrian dalam status "perlu diproses sekarang" sangat kecil. </font><font style="vertical-align: inherit;">Tetapi pada satu titik waktu, sangat mungkin bahwa kita akan memiliki beberapa puluhan ribu antrian aktif yang memerlukan pemrosesan. </font><font style="vertical-align: inherit;">Jumlah antrian ini terus berubah. </font><font style="vertical-align: inherit;">Antrian ini sendiri juga berubah, beberapa di antaranya dikurangi sepenuhnya dan dihapus, beberapa di antaranya dibuat secara dinamis dan diisi dengan acara untuk diproses. </font><font style="vertical-align: inherit;">Karena itu, kita perlu menemukan cara yang efektif untuk menanganinya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memproses kumpulan antrian yang sangat besar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi kami memiliki banyak antrian. Pada setiap titik waktu, mungkin ada jumlah acak. Kondisi penting untuk memproses setiap antrian, yang disebutkan di awal postingnya, adalah bahwa peristiwa dalam setiap halaman harus diproses secara ketat secara berurutan. Ini berarti bahwa pada satu titik waktu, setiap antrian tidak dapat diproses oleh lebih dari satu pekerja untuk menghindari masalah persaingan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi untuk membuat perbandingan antrian dengan penangan 1: 1 adalah tugas yang meragukan. Jumlah antrian terus berubah, baik naik maupun turun. Jumlah penangan yang berjalan juga tidak terbatas, setidaknya kami memiliki batasan pada bagian dari sistem operasi dan perangkat keras, dan kami tidak ingin pekerja berdiri diam di antrian kosong. Untuk mengatasi masalah interaksi antara penangan dan antrian, kami menerapkan sistem round robin untuk memproses kumpulan antrian kami. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan di sini garis kontrol datang membantu kami.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wg/rx/yp/wgrxypigmbunxgzyc_hkgqfodjq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika acara diteruskan dari bus bersama ke antrian berbasis acara bot tertentu, kami juga menempatkan pengidentifikasi antrian bot ini di antrian kontrol. Antrian kontrol menyimpan hanya pengidentifikasi antrian yang ada di kumpulan dan perlu diproses. Hanya nilai unik yang disimpan dalam antrian kontrol, yaitu, pengidentifikasi antrian bot yang sama akan disimpan dalam antrian kontrol hanya sekali, terlepas dari berapa kali itu ditulis di sana. Pada Redis, ini diimplementasikan menggunakan struktur data SET SORTED.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, kita dapat membedakan sejumlah pekerja tertentu, yang masing-masing akan menerima dari antrian kontrol pengenalnya dari antrian bot untuk diproses. Dengan demikian, setiap pekerja akan secara mandiri memproses chunk dari antrian yang ditugaskan kepadanya, setelah memproses chunk, mengembalikan pengidentifikasi dari antrian yang diproses ke kontrol, sehingga mengembalikannya ke round robin kami. Hal utama adalah jangan lupa untuk memberikan semuanya dengan kunci, sehingga dua pekerja tidak bisa memproses antrian bot yang sama secara paralel. Situasi ini dimungkinkan jika bot identifier memasuki antrian kontrol ketika sudah diproses oleh pekerja. Untuk kunci, kami juga menggunakan Redis sebagai kunci: menyimpan nilai dengan TTL.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika kami mengambil tugas dengan pengidentifikasi antrian bot dari antrian kontrol, kami menaruh kunci TTL pada antrian yang diambil dan mulai memprosesnya. </font><font style="vertical-align: inherit;">Jika konsumen lain mengambil tugas dengan antrian yang sudah diproses dari antrian kontrol, ia tidak akan dapat mengunci, mengembalikan tugas ke antrian kontrol dan menerima tugas berikutnya. </font><font style="vertical-align: inherit;">Setelah memproses antrian bot oleh konsumen, ia menghapus kunci dan pergi ke antrian kontrol untuk tugas berikutnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skema terakhir adalah sebagai berikut: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/it/jh/bl/itjhblg3hv1urwu_8gx3fhuj8wq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai hasilnya, dengan skema saat ini, kami memecahkan masalah utama yang diidentifikasi:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penurunan kinerja di bus acara utama</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelanggaran Penanganan Acara</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Efek tetangga berisik</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana cara menangani beban dinamis?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skema ini berfungsi, tetapi di dalamnya kami memiliki jumlah konsumen tetap untuk jumlah antrian yang dinamis. Tentunya, dengan pendekatan ini, kami akan melorot dalam memproses antrian setiap kali jumlah mereka meningkat tajam. Tampaknya akan baik bagi pekerja kita untuk memulai atau memadamkan secara dinamis saat dibutuhkan. Akan lebih baik jika ini tidak menyulitkan proses mengeluarkan kode baru. Pada saat-saat seperti itu, tangan sangat gatal untuk pergi dan menulis manajer proses Anda. Di masa depan, kami melakukan hal itu, tetapi cerita ini berbeda.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berpikir, kami memutuskan, mengapa tidak sekali lagi menggunakan semua alat yang akrab dan akrab. Jadi kami mendapatkan API internal kami, yang berfungsi pada bundel standar NGINX + PHP-FPM. Akibatnya, kami dapat mengganti kumpulan pekerja tetap kami dengan API, dan membiarkan NGINX + PHP-FPM menyelesaikan dan mengelola sendiri pekerja, dan cukup bagi kami untuk memiliki antara antrean kontrol dan API internal kami hanya satu konsumen kontrol yang akan mengirimkan pengidentifikasi antrian ke API kami untuk memproses, dan antrian itu sendiri akan diproses pada pekerja yang diangkat oleh PHP-FPM. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skema baru adalah sebagai berikut:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-l/a9/7p/-la97p-usddzj76y4c8grd8gbxa.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu terlihat indah, tetapi konsumen kontrol kami bekerja dalam satu utas, dan API kami bekerja secara serempak. </font><font style="vertical-align: inherit;">Ini berarti bahwa konsumen akan hang setiap saat sementara PHP-FPM sedang menggulung antrian. </font><font style="vertical-align: inherit;">Ini tidak cocok untuk kita.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Membuat API kami tidak sinkron</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi bagaimana jika kita bisa mengirim tugas ke API kita, dan membiarkannya mengirik logika bisnis di sana, dan konsumen kontrol kita akan mengikuti tugas berikutnya dalam antrian kontrol, setelah itu akan ditarik kembali ke API, dan seterusnya. </font><font style="vertical-align: inherit;">Tidak lebih cepat dikatakan daripada dilakukan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implementasinya membutuhkan beberapa baris kode, dan Bukti Konsep terlihat seperti ini:</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Api</span> </span>{
    	<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">actionDoSomething</span>(<span class="hljs-params"></span>)
    	</span>{<font></font>
    		$data = $_POST;<font></font>
    		<span class="hljs-keyword">$this</span>-&gt;dropFPMSession();
    		<span class="hljs-comment">// ,        , &nbsp;   </span>
    		<span class="hljs-comment">//     </span><font></font>
    	}<font></font>
    <font></font>
    <font></font>
    	<span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dropFPMSession</span>(<span class="hljs-params"></span>)
    	</span>{<font></font>
    		ignore_user_abort(<span class="hljs-literal">true</span>); 
    		<span class="hljs-comment">//          </span>
    		ob_end_flush(); <span class="hljs-comment">//  </span>
    		flush(); <span class="hljs-comment">//  </span>
    		@session_write_close(); <span class="hljs-comment">// </span><font></font>
    	<font></font>
    		fastcgi_finish_request(); <font></font>
    		<span class="hljs-comment">//          </span><font></font>
    	}<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam metode dropFPMSession (), kami memutuskan koneksi dengan klien, memberikan respons 200, setelah itu kami dapat menjalankan logika berat apa pun dalam postprocessing. </font><font style="vertical-align: inherit;">Klien dalam kasus kami adalah konsumen kontrol. </font><font style="vertical-align: inherit;">Penting baginya untuk menyebarkan tugas dengan cepat dari antrian kontrol ke pemrosesan pada API dan untuk mengetahui bahwa tugas tersebut telah mencapai API. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan menggunakan pendekatan ini, kami melepas banyak sakit kepala yang terkait dengan kontrol dinamis konsumen dan penskalaan otomatis mereka.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lebih scalable</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akibatnya, arsitektur subsistem kami mulai terdiri dari tiga lapisan: Lapisan Data, Proses dan API Internal. Pada saat yang sama, informasi melewati semua aliran data tentang bot mana dari acara / tugas yang diproses. Jelas, kita dapat menggunakan pengenal kunci / bot kami untuk sharding, sambil terus skala sistem kami secara horizontal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita membayangkan arsitektur kita sebagai unit yang solid, akan terlihat seperti ini: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bb/mw/en/bbmwendsu4hnp_xymwqnulblwvc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah menambah jumlah unit seperti itu, kita dapat menempatkan penyeimbang tipis di depannya, yang akan menyebarkan acara / tugas kita ke unit yang diperlukan, tergantung pada kunci sharding. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wf/1g/sk/wf1gsktxy1iqdp_jhqougdnfkuw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, kami mendapatkan margin besar untuk penskalaan horizontal sistem kami.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat menerapkan logika bisnis, Anda tidak boleh melupakan konsep keselamatan benang, jika tidak, Anda bisa mendapatkan hasil yang tidak terduga. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skema semacam itu dengan kaskade antrian dan penghapusan logika bisnis berat ke pemrosesan asinkron telah digunakan di beberapa bagian sistem selama lebih dari dua tahun. </font><font style="vertical-align: inherit;">Beban selama waktu ini untuk masing-masing subsistem telah tumbuh puluhan kali, dan implementasi yang diusulkan memungkinkan kita untuk dengan mudah dan cepat mengukur. </font><font style="vertical-align: inherit;">Pada saat yang sama, kami terus bekerja pada tumpukan utama kami, tanpa memperluasnya dengan alat / bahasa baru dan tanpa bertambah, sehingga menambah pengenalan dan dukungan alat baru.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id492948/index.html">Temui defer</a></li>
<li><a href="../id492952/index.html">Kembali ke Masa Depan dengan Kursus Pengembang Java</a></li>
<li><a href="../id492956/index.html">Gamer tidak pernah mantan. Kenangan indah dan kesenangan terlarang - dalam survei oleh DataArt</a></li>
<li><a href="../id492958/index.html">Komputasi rekursif otomatis</a></li>
<li><a href="../id492962/index.html">Kit survival karantina otonom saya</a></li>
<li><a href="../id492966/index.html">Untuk pertama kalinya foton dipindahkan dari satu keping ke keping lainnya</a></li>
<li><a href="../id492968/index.html">Dalam ingatan Freeman Dyson, si jenius matematika, berubah menjadi visioner teknologi</a></li>
<li><a href="../id492970/index.html">Bagaimana TeamViewer menyimpan kata sandi</a></li>
<li><a href="../id492972/index.html">Bagaimana kulit dilembabkan, dan apa yang terjadi ketika Anda secara manual mencuci tangan dengan alkohol dengan COVID-19</a></li>
<li><a href="../id492978/index.html">Cara memesan video produk IT outsourcing dan mendapatkan yang Anda butuhkan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>