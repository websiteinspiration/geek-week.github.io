<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëç üëêüèª üòÆ Soft particles in WebGL and OpenGL ES üå≠ üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® üë©üèø‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Particle systems are some of the easiest ways to make a 3D scene visually richer. In one of our Android applications, 3D Buddha Live Wallpaper is a fa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Soft particles in WebGL and OpenGL ES</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489644/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Particle systems are some of the easiest ways to make a 3D scene visually richer. In one of our Android applications, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3D Buddha Live Wallpaper is a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fairly simple scene, which would be nice to add a little more detail. And when we thought about how to add variety to the image, the most obvious decision to fill the empty space around the Buddha statue was to add puffs of smoke or fog. Thanks to the use of soft particles, we have achieved a pretty good result. In this article, we will describe in detail the implementation of soft particles on pure WebGL / OpenGL ES without using third-party libraries and ready-made 3D engines.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The difference between the old and the updated application even exceeded our expectations. </font><font style="vertical-align: inherit;">Simple smoke particles significantly improved the scene, made it richer and fuller. </font><font style="vertical-align: inherit;">Puffs of smoke are additional details that ‚Äúcatch the eye‚Äù, as well as a way to make the transition between the main objects and background smoother:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fy/8a/-e/fy8a-eyk-2aa2jstcglba6zc-du.jpeg"></div><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soft particles</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So what are these soft particles? </font><font style="vertical-align: inherit;">You may remember that in many old games (Quake 3 and CS 1.6) the effects of smoke and explosions had very clear flat boundaries at the intersection of particles with a different geometry. </font><font style="vertical-align: inherit;">All modern games no longer have such artifacts due to the use of soft particles - that is, particles with blurry, ‚Äúsoft‚Äù edges around adjacent objects.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is required to make the particles soft? </font><font style="vertical-align: inherit;">First, we need information about the depth of the scene in order to determine the intersection of particles with other objects and soften them. </font><font style="vertical-align: inherit;">Then we need to determine the intersection of the scene and particle geometries by comparing the scene and particle depths in the fragment shader - intersections where the depths are the same. </font><font style="vertical-align: inherit;">Next, we will look at the rendering process step by step. </font><font style="vertical-align: inherit;">Both scene implementations for Android OpenGL ES and WebGL are the same, the main difference is only in resource loading. </font><font style="vertical-align: inherit;">The implementation on WebGL is open source and you can get it here - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/keaukraine/webgl-buddha</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depth map rendering</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To render a scene depth map, first we need to create textures for the depth and color map and assign them to a specific FBO. This is done in the method </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initOffscreen ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the file </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuddhaRenderer.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Actual rendering of scene objects to a depth map itself is performed in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drawDepthObjects ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">, which </font><i><font style="vertical-align: inherit;">draws a</font></i><font style="vertical-align: inherit;"> Buddha statue and a floor plane. However, there is one trick to improving performance. Since at this stage of rendering we do not need color information, but only depth, rendering to the color buffer is disabled by calling </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gl.colorMask (false, false, false, false)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and then turned on again by calling </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gl.colorMask (true, true, true, true)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><i><font style="vertical-align: inherit;">GlcolorMask ()</font></i><font style="vertical-align: inherit;"> function</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can turn on and off the recording of the red, green blue and alpha components separately, so in order to completely turn off the recording in the color buffer, we set all components to false and then turn them on for rendering on the screen, exposing them all to true. </font><font style="vertical-align: inherit;">The result of rendering to the depth texture can be seen by uncommenting the call to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drawTestDepth ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drawScene ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Since the texture of the depth map has only one channel, it is perceived as soon as the red, blue, and green channels are zero. </font><font style="vertical-align: inherit;">A visualization of the depth map of our scene looks like this:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ht/63/nu/ht63nu3kmrnsmdjy9nke2wcmppw.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Particle rendering</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The shader code used to render the particles is located in the file </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SoftDiffuseColoredShader.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Let's see how it works. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main idea of ‚Äã‚Äãfinding the intersection of the particle and scene geometries is to compare the value of the current fragment depth with the stored value from the depth map. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first step in comparing depths is to linearize the depths, since the original values ‚Äã‚Äãare exponential. This is done using the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calc_depth ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">. This technique is well described here - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://community.khronos.org/t/soft-blending-do-it-yourself-solved/58190</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . For the linearization values, we need the Uniform variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vec2 uCameraRange</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">whose components x and y contain the values ‚Äã‚Äãof the near and far clipping planes of the camera. Then the shader calculates the linear difference between the depth of the particle and the scene - this value is stored in the variable a. However, if we apply this value to the color of the fragment, we get particles that are too transparent - the color will fade linearly from any geometry behind the particle, and fade pretty quickly. This is how the visualization of the linear difference in depth looks (you can uncomment the corresponding line of code in the shader and see it):</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/j9/yy/bv/j9yybvyxepfvjwyjs4jraymi72w.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To make the particles more transparent only near the intersection boundary (in the region of a = 0), we apply the GLSL </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">smoothstep ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">to the value of the variable a with the transition value from 0 to the coefficient specified in the uTransitionSize </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uniform</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which determines the width of the transparent transition. If you want to learn more about the operation of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">smoothstep ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">and see a couple of interesting examples of its use, we recommend reading this article - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://www.fundza.com/rman_shaders/smoothstep/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The final coefficient is stored in variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For the color mixing mode used in our scene, simply multiply the color of the particle taken from the texture by this coefficient; </font><font style="vertical-align: inherit;">in other particle implementations, you may need to change, for example, only the alpha channel. </font><font style="vertical-align: inherit;">If you uncomment the line of code in the shader to visualize this coefficient, the result will look like this:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/k9/ha/rd/k9hardw3rfmghkzjrdv9wsb0nqg.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comparison of various values ‚Äã‚Äãof the coefficient of "softness" of particles:</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hq/ix/6v/hqix6v7kcbvkkkhath792gl8t8k.gif"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprite rendering optimization</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this scene, small specks of dust are drawn as point sprites (primitives like </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GL_POINTS</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). This mode is convenient in that it automatically creates the finished square geometry of the particle with texture coordinates. However, they also have drawbacks that make their use inappropriate for large particles of fog clubs. First of all, they are cut off by the clipping planes of the camera matrix according to the coordinates of the center of the sprite. This leads to the fact that they abruptly disappear from view at the edges of the screen. Also, the square shape of the sprite is not very optimal for the fragment shader, since it is called in those places where the particle texture is empty, which causes a noticeable redrawing. We use an optimized particle shape - with cropped edges in those places where the texture is completely transparent:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/lr/vs/dp/lrvsdpj0icaww4fdnleho4kh9sg.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Such particle models are commonly called billboard. Of course, they cannot be rendered as primitives of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GL_POINTS</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , so each particle is drawn separately. This does not create a lot of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drawElements</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> calls </font><font style="vertical-align: inherit;">, in the whole scene there are only 18 particles of fog. They should be placed in arbitrary coordinates, scaled but rotated in such a way as to always be perpendicular to the camera regardless of its position. This is achieved by modifying the matrix described in this answer on </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StackOverflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . There </font><font style="vertical-align: inherit;">is a method </font><i><font style="vertical-align: inherit;">calculateMVPMatrixForSprite () in the </font></i></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuddhaRenderer.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file </font><font style="vertical-align: inherit;">that creates MVP matrices for billboard models. It performs all the usual transformations of displacement and scaling and then uses</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resetMatrixRotations ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to reset the rotation component of the model-view matrix before it is multiplied by the projection matrix. </font><font style="vertical-align: inherit;">The resulting matrix performs a transformation as a result of which the model is always directed exactly at the camera.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Result</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The final result can be seen live here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can learn and reuse source code from Github for your projects</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en489632/index.html">FOSS News No. 4 - review of free and open source news for February 17-23, 2020</a></li>
<li><a href="../en489636/index.html">Alexey Grachev: Go Frontend</a></li>
<li><a href="../en489638/index.html">Interplanetary File System - Simple IPFS Blog Using XSLT</a></li>
<li><a href="../en489640/index.html">Scientists from MIT managed to get electricity from the air using bacterial protein</a></li>
<li><a href="../en489642/index.html">Funny patents from the automotive industry</a></li>
<li><a href="../en489650/index.html">Automation of a journalist. Part 1: Tasks and Calendars</a></li>
<li><a href="../en489652/index.html">The digest of fresh materials from the world of the front-end for the last week No. 403 (February 17 - 23, 2020)</a></li>
<li><a href="../en489656/index.html">Bad experience creating and administering a scientific journal site</a></li>
<li><a href="../en489660/index.html">Why NoSQL Databases Are a Bad Solution for Modern Applications</a></li>
<li><a href="../en489662/index.html">PHP Digest No. 174 (February 10 - 24, 2020)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>