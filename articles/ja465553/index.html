<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏿 🦊 🚱 プログラミング言語Ü。導入、作成の動機、目標 👨‍👧‍👧 💆🏼 👖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前書き
 2016年以降（中断あり）、自分のプログラミング言語を開発しています。この言語の名前は「Ü」です。なぜÜ？1文字の名前が欲しかったので、AZセットのすべての文字は既に使用されています。
 
 この記事には、この言語を一般に知ってもらい、それについての一般的な考え方を伝えるという役割がありま...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>プログラミング言語Ü。導入、作成の動機、目標</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465553/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2016年以降（中断あり）、自分のプログラミング言語を開発しています。</font><font style="vertical-align: inherit;">この言語の名前は「Ü」です。</font><font style="vertical-align: inherit;">なぜÜ？</font><font style="vertical-align: inherit;">1文字の名前が欲しかったので、AZセットのすべての文字は既に使用されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事には、この言語を一般に知ってもらい、それについての一般的な考え方を伝えるという役割があります。</font><font style="vertical-align: inherit;">記事は言語を完全に説明することを意図しておらず、必要に応じて、言語のより完全な説明が後続の記事で提供されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜ別の言語が必要なのですか？</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は既存の静的型付けされたコンパイルされた多かれ少なかれよく知られた言語の数を調べて、それらのどれも完全に私に適していないという結論に達しました。</font><font style="vertical-align: inherit;">それらのすべてに致命的な欠陥があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
具体的なポイント：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-レベルが低すぎて安全ではない</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++-多くの低レベルの欠陥を継承し、足元で自分を撃つ新しい方法、反射の欠如</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D-ガベージコレクター、個別の参照型</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javaはガベージコレクターであり、すべての複合型が参照され、仮想マシンに強力にアタッチされます。</font><font style="vertical-align: inherit;">これの多くは、JVMベースの言語にも当てはまります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C＃-欠陥はJavaによく似ています</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">錆-明示的にリンクを取り、それらを明示的に逆参照する必要性、（主観的に）すべてが式で結果を返す場合のアプローチの危険性、プロトコルへのコンプライアンスの明示的な表示の存在、継承の欠如</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go-ガベージコレクター、テンプレートの欠如</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swift-参照型、プロトコルへの準拠を明示的に示す必要性</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のすべての言語の不完全性を発見したので、私は、私には思えるように、すべての欠陥を欠いた独自の言語を作成することにしました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般情報</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Üは、強力な型付けを備えたコンパイル済みの静的型付け言語です。</font><font style="vertical-align: inherit;">言語には、無料の関数、構造、クラス、構造とクラスのメソッドが含まれています。</font><font style="vertical-align: inherit;">既存のタイプのタイプ-基本、構造（構造、クラス）、一定サイズの配列、タプル、列挙、関数へのポインター。</font><font style="vertical-align: inherit;">クラスは継承に参加し、仮想関数を持つことができます。</font><font style="vertical-align: inherit;">言語はテンプレートをサポートし、クラスと構造のテンプレート、型のエイリアス、関数、メソッドがあります。</font><font style="vertical-align: inherit;">関数と演算子のオーバーロードがあります（いくつかの制限があります）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語は、クラスと構造のデストラクタをサポートします。</font><font style="vertical-align: inherit;">デストラクタは、メモリを含むリソースの管理に使用されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すでにそこにあるもの</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLVMベースのコンパイラを実装。</font><font style="vertical-align: inherit;">コンパイラーは、LLVMをサポートするすべてのプラットフォームをサポートします。</font><font style="vertical-align: inherit;">コンパイラはまだ純粋に実行可能なファイルを作成することはできませんが、オブジェクトファイル、アセンブラコード、バイナリまたはテキストllvmコードを生成することはできます。</font><font style="vertical-align: inherit;">Cコードとの通信の可能性があります。Cライブラリのheadヘッダーを簡単に作成できるユーティリティがあります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目標と目的</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語は、コンパイル段階で典型的なエラーの最大数をキャッチするように作成されています。</font><font style="vertical-align: inherit;">言語設計の決定は、主にこのタスクに基づいて行われます。</font><font style="vertical-align: inherit;">2番目の目標は、プログラムの（相対的な）書きやすさと読みやすさです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この言語には、誤ったコードの作成を引き起こす可能性のある構成要素は含まれていません。また、プログラムで何が起こっているかの理解を著しく複雑にする可能性のある機能も含まれていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の点にもかかわらず、パフォーマンスの問題は無視できません。</font><font style="vertical-align: inherit;">したがって、パフォーマンスを犠牲にして、言語設計の決定は行われません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、指定された目標に対応するinの瞬間を見てみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型システム</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++とは異なり、Üには型としてのポインタと参照はありません。</font><font style="vertical-align: inherit;">ポインタはまったくなく、リンクがありますが、スタックリンク、関数参照引数、参照フィールドとしてのみです。</font><font style="vertical-align: inherit;">また、mut / imut修飾子は型の一部ではなく、変数、参照、関数引数、フィールドの一部です。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この単純化のおかげで、特にボイラープレートコードで、どのタイプがどこにあるのかについての理解が深まります。</font><font style="vertical-align: inherit;">リンクまたは変数が宣言されるかどうか、typeof（C ++からのdecltypeのアナログ）の結果としての疑い、定数/非定数に関する疑いはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この単純化の裏側は、テンプレートの一貫性とリンクを個別に処理する必要があることです。</font><font style="vertical-align: inherit;">ただし、これにより、不変性パラメーターが明示的に別の引数としてテンプレートに渡されると、明確さが増します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化子</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数を宣言して初期化しないことはできません。</font><font style="vertical-align: inherit;">宣言された変数のバイトは初期化する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本（およびその他の）タイプでは、必須の初期化が必要です。</font></font><br>
<br>
<pre><code class="rust">var i32 x= 22, y(12345);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスと構造のフィールドを初期化します。</font></font><br>
<br>
<pre><code class="rust">struct Vec{ f32 x; f32 y; }<font></font>
...<font></font>
var Vec v{ .x= -56.1f, .y= 42.0f };<font></font>
var Vec v_uninit; //  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造体とクラスのデフォルトコンストラクターを作成でき、明示的な初期化は必要ありません。</font></font><br>
<br>
<pre><code class="rust">struct Vec<font></font>
{<font></font>
	f32 x; f32 y;<font></font>
	fn constructor()<font></font>
	( x= 0.0f, y= 0.0f )<font></font>
	{}<font></font>
}<font></font>
...<font></font>
var Vec v; //  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのフィールドをデフォルトで作成できる場合、またはフィールド初期化子がある場合は、デフォルトコンストラクターを自動的に生成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、フィールド初期化子：</font></font><br>
<br>
<pre><code class="rust">struct Vec<font></font>
{<font></font>
	f32 x= 0.0f;<font></font>
	f32 y= 0.0f;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のタイプのタイプには初期化子があり、配列およびタプルには、配列またはタプルの要素の数と等しい要素の数を持つ初期化子[]が必要です。</font></font><br>
<br>
<pre><code class="rust">var [ i32, 4 ] a[ 1, 1, 3, 4 ];<font></font>
var tup[ i32, f32 ] t[ 8, 0.5f ];<font></font>
var [ f32, 16 ] a_uninit; // ,     .<font></font>
var[ i32, 3 ] aa[ 0, 1 ]; // ,  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++とは異なり、構造要素は特定の順序でイニシャライザを渡すだけでは初期化できません。フィールド名を指定する必要があります。</font><font style="vertical-align: inherit;">これにより、構造が変更されたときの問題が回避されますが、初期化子はそうではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この言語は、コンストラクターとコンストラクターの初期化リストをサポートしています。</font><font style="vertical-align: inherit;">メンバーが初期化リストを介して初期化されると、どのフィールドが既に初期化され、どのフィールドがまだ初期化されていないかを追跡します。</font><font style="vertical-align: inherit;">これは初期化リストからも使用できません。つまり、初期化されていないデータを渡してメソッドや関数を呼び出すことはできません。</font></font><br>
<br>
<pre><code class="rust">struct Vec<font></font>
{<font></font>
	f32 x; f32 y;<font></font>
	fn constructor()<font></font>
	( x= y, y= 0.0f ) // ,  «y»   <font></font>
	{}<font></font>
<font></font>
	fn constructor( f32 val )<font></font>
	( x= val, y= x ) // . «x»         «y»<font></font>
	{}<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンク追跡</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語にはリンク追跡メカニズムがあります。</font><font style="vertical-align: inherit;">コンパイル段階では、同じスタック変数または関数引数への唯一の可変参照、またはゼロから無限の不変参照への参照が同時に存在するかどうかがチェックされます。</font><font style="vertical-align: inherit;">このルールの違反が検出された場合、コンパイラーはエラーを生成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も単純な例：</font></font><br>
<br>
<pre><code class="rust">var i32 mut x= 0;<font></font>
var i32 &amp;mut ref0= x;<font></font>
++x; // ,        <font></font>
var i32 &amp;imut ref1= x; // ,    , . .    </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一つの例：</font></font><br>
<br>
<pre><code class="rust">var i32 mut x= 0;<font></font>
var i32 &amp;imut ref0= x;<font></font>
var i32 &amp;mut ref1= x; // ,    ,     </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、これは可能です。</font></font><br>
<br>
<pre><code class="rust">var i32 mut x= 0;<font></font>
var i32 &amp;mut ref0= x;<font></font>
var i32 &amp;mut ref1= ref0; //  , . .       ,     </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数を呼び出すときにリンクが考慮されます。</font></font><br>
<br>
<pre><code class="rust">fn Mutate( i32 &amp;mut x, i32 &amp;mut y );<font></font>
...<font></font>
var i32 mut x= 0;<font></font>
Mutate( x, x ); // ,          </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメカニズムにより、一般的なメモリアクセスエラーをキャッチできます。</font><font style="vertical-align: inherit;">C ++の例</font></font><br>
<br>
<pre><code class="cpp">std::vector&lt;int&gt; vec;<font></font>
vec.push_back(1);<font></font>
int&amp; ref= vec.front();<font></font>
vec.push_back(2); // ,  ref        </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Üでは、この種の問題はコンパイル段階で検出されます。</font></font><br>
<br>
<pre><code class="rust">var ust::vector&lt;/i32/&gt; mut vec;<font></font>
vec.push_back(1);<font></font>
var i32 &amp;imut ref= vec.front();<font></font>
vec.push_back(2); // ,      vec,      </code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">継承</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
継承に参加できるのは（構造ではなく）クラスだけです。</font><font style="vertical-align: inherit;">ポリモーフィッククラスのみが継承に参加します-ポリモーフ、インターフェース、抽象、または祖先を持つというラベルが付けられます。</font><font style="vertical-align: inherit;">非ポリモーフィッククラスから継承することはできません。</font><font style="vertical-align: inherit;">ポリモーフィッククラスには仮想デストラクタがあり、明示的に宣言されていない仮想デストラクタは依然として仮想です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポリモーフィッククラスのタイプ：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェース </font><font style="vertical-align: inherit;">それらは、祖先インターフェースのみを持つことができ、フィールドを持つことはできず、仮想関数の実装を持つことはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例：</font></font><br>
<br>
<pre><code class="rust">class A interface<font></font>
{<font></font>
	fn virtual pure Foo(this);<font></font>
}</code></pre></li>
<li> .         .        .   ,       this,     ,  . . .     abstract call,  ,  ,  C++.<br>
<br>
:<br>
<br>
<pre><code class="rust">class A abstract<font></font>
{<font></font>
	fn virtual pure Foo(this);<font></font>
	fn virtual Bar(this){}<font></font>
	i32 x= 0;<font></font>
}</code></pre></li>
<li>  .         .     .  -    ,   .<br>
<br>
:<br>
<br>
<pre><code class="rust">class A interface<font></font>
{<font></font>
	fn virtual pure Foo(this);<font></font>
}<font></font>
class B : A<font></font>
{<font></font>
	fn virtual override Foo(this){}<font></font>
}</code></pre></li>
<li>  .  ,    ,     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポリモーフィッククラスだけが仮想関数を持つ権利を持っています。</font><font style="vertical-align: inherit;">仮想関数の場合、仮想のタイプを明示的に指定する必要があります。</font></font><br>
<br>
<pre><code class="rust">fn virtual pure Foo(this); //    .      ,        ,   .<font></font>
<font></font>
fn virtual Foo(this){} //     .   ,      .<font></font>
<font></font>
fn virtual override Foo(ths){} //   ,    .         ,   .<font></font>
<font></font>
fn virtual final Foo(this){} //   ,     .         ,   .  -    ,   .</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロー制御</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、2019年はすでにささいなことですが、それでもinでは、制御フローの忠実度が確認されています。</font><font style="vertical-align: inherit;">到達できないコードが検出されると、エラーが生成されます。</font><font style="vertical-align: inherit;">値を返す必要がある関数では、常に戻ることが証明されていない場合、エラーがスローされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例：</font></font><br>
<br>
<pre><code class="rust">fn Foo( i32 mut x ) : i32<font></font>
{<font></font>
	while(x  &lt; 100 )<font></font>
	{<font></font>
		x+= 10;<font></font>
		continue;<font></font>
		x+= 20; // ,  <font></font>
	}<font></font>
	return x;<font></font>
	++x; // ,  <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一つの例：</font></font><br>
<br>
<pre><code class="rust">fn Foo( i32 x ) : i32<font></font>
{<font></font>
	if( x &lt; 10 ) { return 0; }<font></font>
	else if( x &gt; 100 ) { return 1; }<font></font>
	// ,     <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例は、無条件のelseをreturnで追加するか、最後にreturnを追加することで修正できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
制御フローがどこにも行きたくない場合のために、停止演算子が用意されています（以下を参照）。</font><font style="vertical-align: inherit;">この演算子は終端と見なされます。つまり、その後はコードが無効になり、戻りを確認するときに制御フローの分岐が考慮されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチスレッド</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マルチスレッドエラーの問題は、異なるストリームからの同じデータへの同時書き込みアクセスの問題です。</font><font style="vertical-align: inherit;">ご覧のとおり、この問題は、同じストリームから同じデータへの複数のアクセスに多少似ています（リンクトラッキングを参照）。</font><font style="vertical-align: inherit;">したがって、この問題は同じメカニズムで（部分的に）解決されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例えば：</font></font><br>
<br>
<pre><code class="rust">struct CallableObject<font></font>
{<font></font>
	i32 &amp;mut x;<font></font>
	op()( mut this )<font></font>
	{<font></font>
		++x;<font></font>
	}<font></font>
}<font></font>
...<font></font>
var i32 mut x= 0;<font></font>
var CallableObject mut obj{ .x= x };<font></font>
auto thread= ust::thread_create( move(obj) );<font></font>
++x; // ,   «x»,        «thread»<font></font>
++ obj.x; //  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リンクトラッキングメカニズムにより、変更のために一部のデータへの別のストリームリンクに転送して、子ストリームが破棄される前に現在のストリームがこのデータにアクセスできないようにするか、リンクを転送して、機会を奪うことなく1つまたは複数のストリームにデータを読み取ることができます。親ストリームからこのデータを読み取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のフローへの不変リンクの無料転送の可能性は、競合が発生する可能性があるため、不変オブジェクトメソッド（C ++では可変）のオブジェクトの内部変更の禁止を意味します。内部の可変性が依然として必要な場合は、ミューテックスまたは競合の可能性を排除する類似のもので保護する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、異なるストリームから同じデータへの読み取りおよび書き込みアクセスを可能にする必要がある場合はどうなりますか？これを行うには、ロック付きの共有ポインタの特別なライブラリクラス-shared_ptr_mtなどがあります。書き込みが必要なスレッドは、ポインタークラスのlock_mut（）メソッドを呼び出して書き込みアクセスを取得するか、読み取りアクセスが必要な場合はlock_imut（）を呼び出します。これらのメソッドはブロックしており、「1つの可変リンクまたは複数の不変リンクの存在が許可されるのと同時に」というルールへの準拠を保証します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例：</font></font><br>
<br>
<pre><code class="rust">struct Incrementer<font></font>
{<font></font>
	ust::shared_ptr_mt_mut&lt;/ i32 /&gt; ptr;<font></font>
	op()( mut this )<font></font>
	{<font></font>
		auto mut lock= ptr.lock_mut(); //   «lock»  <font></font>
		++lock.get_ref();<font></font>
	}<font></font>
}<font></font>
...<font></font>
var ust::shared_ptr_mt_mut&lt;/ i32 /&gt; ptr(0);<font></font>
var size_type mut i(0);<font></font>
var ust::vector&lt;/ ust::thread&lt;/Incrementer/&gt; /&gt; mut threads;<font></font>
while( i &lt; size_type(64) )<font></font>
{<font></font>
	var Incrementer incrementer{ .ptr= ptr };<font></font>
	threads.push_back( ust::thread_create(incrementer) );<font></font>
	++i;<font></font>
}<font></font>
threads.clear(); //      .<font></font>
halt if( ptr.lock_imut().get_ref() != 64 ); // ,   ,  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
共有マルチスレッドポインターに加えて、標準ライブラリには、ロックを使用することが不採算である場合のために、通常の共有ポインターがあります。</font><font style="vertical-align: inherit;">このようなポインタは、一般に別のスレッドに渡すのは安全ではありません。</font><font style="vertical-align: inherit;">したがって、そのようなポインターのクラスは、特別なタグ「共有」でマークされます。</font><font style="vertical-align: inherit;">ストリームの作成時に、ストリームに転送されたデータに、タイプが「共有」としてマークされたデータが含まれていないことが確認されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グローバル変数</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変更可能な変数はありません。</font><font style="vertical-align: inherit;">グローバル定数のみが許可されますが、許可されるのはconstexprタイプのみです。</font><font style="vertical-align: inherit;">その結果、すべての定数の値はコンパイル段階で計算され、初期化の順序に問題はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グローバルな可変状態が必要な場合は、Üではなく、Cなどの他の何かに実装する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレーター</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++とは異なり、代入演算子（=、+ =、* =など）は値を返さず、さらに構文的にはステートメントであり、式ではありません。</font><font style="vertical-align: inherit;">同様に、++および-演算子を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の例は構文的にも正しくありません：</font></font><br>
<br>
<pre><code class="rust">if( x = 0 ) {}<font></font>
x++; //     ++<font></font>
x += x += x; // ,  +=  <font></font>
x+= x++ + ++x; //      </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オーバーロードされた演算子は、引数と戻り値が正しいかどうかがチェックされます。</font><font style="vertical-align: inherit;">代入演算子とデクリメント付きのインクリメントはvoidを返す必要があります。そうしないと、コンパイルエラーが生成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語には三項演算子がありますが、その構文は優先度のあいまいさを排除するために変更されました。</font><font style="vertical-align: inherit;">このステートメントは次のようになります。</font></font><br>
<br>
<pre><code class="rust">auto a = select( condition ? x : y );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
selectキーワードと括弧はステートメントの一部です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らはここにはいない。</font><font style="vertical-align: inherit;">どういたしまして。</font><font style="vertical-align: inherit;">そして、されません。</font><font style="vertical-align: inherit;">絶対そうしない。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何故ですか？</font><font style="vertical-align: inherit;">例外自体にはいくつかの問題があります。そのため、例外が存在すると、誤ったコードが記述される可能性が高くなります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムの各行で例外が発生する可能性があります。</font><font style="vertical-align: inherit;">このため、データの一貫性を維持するのはより難しく、一貫性の問題を解決するためにプログラマーが費やす時間と、その実装の生産性のコストの両方が必要です。</font></font></li>
<li>  .             . - NullPointerException  - ,       -  .              ,      , . .           .</li>
<li>   .  ,    ,    ,    . -           -        ,       .  ,   .</li>
<li>     .  ,    ,   .</li>
</ul><br>
<s><font style="vertical-align: inherit;"></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外で</font><s><font style="vertical-align: inherit;">はないにしても、だれでも、</font></s><font style="vertical-align: inherit;">何であるか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数がいわゆるを返すことができない場合。</font><font style="vertical-align: inherit;">「期待される」結果。C++のstd :: optional / std ::バリアントやRustのOption / Resultなど、結果または失敗の兆候を返す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムがそれ以上機能しないことが発生した場合のために、停止演算子が用意されています。</font><font style="vertical-align: inherit;">このオペレーターは、外部の（theプログラムに関して）ハンドラーに制御を移します。これにより、プログラムがクラッシュし、おそらくこれに関するレポートが開発者に送信されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュール性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、まだモジュールはありませんが、別のファイルからコンテンツをインポートしています。</font><font style="vertical-align: inherit;">インポートディレクティブの後に指定されたソースファイルが読み取られてコンパイルされ、その後、その宣言を使用できます。</font><font style="vertical-align: inherit;">C ++とは異なり、これは以前にインポートされたファイルの名前を考慮せずに、単一のファイルを完全にコンパイルしたものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでのところ、インポートされたファイルのコンテンツの可視性に制限はありません。</font><font style="vertical-align: inherit;">ただし、C ++の* .cppおよび* .hppと同様に、モジュールを見出し部分と内部部分に分割することができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の機能に加えて、選択された原則を反映する言語の他の多くの要素があり、それらすべてを1つの記事にリストすることはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語のいくつかの要素は構文的には不完全に思えるかもしれません。最初の優先事項は実用的なソリューションを作成することであり、長い間構文について考えていませんでした。</font><font style="vertical-align: inherit;">しかし、私はこれは修正可能だと思います、言語はまだ開発中です。</font><font style="vertical-align: inherit;">要素の構文が失敗した場合は、それを変更できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトを含むリポジトリ</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
→ </font><font style="vertical-align: inherit;">プロジェクトのアセンブル方法が明確になるように</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブリスクリプト</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">の例</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→コード例は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準ライブラリ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">確認</font></a><font style="vertical-align: inherit;">できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドキュメントを作成するには時期尚早であり、手が届いていないため、まだドキュメントはありません。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja465539/index.html">766 km-LoRaWANの新記録</a></li>
<li><a href="../ja465541/index.html">エンタープライズからSMBへ：SaaSモデルを使用した収益化により、中小企業向けの企業ソリューションの適応に関する経験を共有します</a></li>
<li><a href="../ja465545/index.html">州のさまざまな側面：Facebookが米国議会でどのように揚げられたのか、テレグラムはFSBと戦った</a></li>
<li><a href="../ja465547/index.html">SQLガイド：クエリをより適切に記述する方法（パート1）</a></li>
<li><a href="../ja465551/index.html">9月のITイベントダイジェスト（パート1）</a></li>
<li><a href="../ja465557/index.html">製品開発期限</a></li>
<li><a href="../ja465561/index.html">一流のプログラマーから学んだこと</a></li>
<li><a href="../ja465569/index.html">モバイル開発者開発マップ</a></li>
<li><a href="../ja465571/index.html">男性のたばこを女性に売って野蛮人に身を守らせる方法：できるコピーライター</a></li>
<li><a href="../ja465573/index.html">1つの言語の例におけるIntelliJ IDEAのすべての能力（写真）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>