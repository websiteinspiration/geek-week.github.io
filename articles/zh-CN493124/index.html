<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🚒 🦔 🍅 自己进行裸机配置或从头开始自动服务器准备 💇🏽 🤰 👒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="嗨，我是Denis，我的活动领域之一是在X5中开发基础结构解决方案。今天，我想与您分享如何部署基于公开可用工具的自动化服务器准备系统。我认为这是一个有趣，简单且灵活的解决方案。
 
 
 
 准备的意思是：从新服务器中直接制造一台具有OS的完全配置的服务器 Linux或ESXi虚拟机管理程序（本文不...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>自己进行裸机配置或从头开始自动服务器准备</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/X5RetailGroup/blog/493124/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">嗨，我是Denis，我的活动领域之一是在X5中开发基础结构解决方案。</font><font style="vertical-align: inherit;">今天，我想与您分享如何部署基于公开可用工具的自动化服务器准备系统。</font><font style="vertical-align: inherit;">我认为这是一个有趣，简单且灵活的解决方案。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cs/aj/wx/csajwx5dsd-sdlngyst-pfrollu.png"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
准备的意思是：从新服务器中直接制造一台具有OS的完全配置的服务器 </font><font style="vertical-align: inherit;">Linux或ESXi虚拟机管理程序（本文不讨论Windows Server Cast）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条款</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务器-需要配置的服务器。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安装服务器-通过网络提供整个准备过程的主服务器。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么需要自动化？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设有一个问题：从头开始大规模准备服务器-每天30个。</font><font style="vertical-align: inherit;">不同制造商和型号的服务器，可以安装不同的操作系统，可能存在或可能不存在管理程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
设置过程包括哪些操作（无自动化）：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将键盘，鼠标，显示器连接到服务器；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置BIOS，RAID，IPMI；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">升级组件固件；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部署文件系统映像（或安装管理程序并复制虚拟机）；</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意。</font><font style="vertical-align: inherit;">或者，可以通过安装自动应答文件来部署操作系统。</font><font style="vertical-align: inherit;">但这将不在本文中讨论。</font><font style="vertical-align: inherit;">尽管您会在下面看到添加此功能很容易。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置操作系统参数（主机名，IP等）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用这种方法，可以在每个服务器上顺序执行相同的设置。</font><font style="vertical-align: inherit;">这种工作的效率很低。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自动化的本质是在准备服务器的过程中避免人工参与。</font><font style="vertical-align: inherit;">越多越好。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于自动化，减少了操作之间的停机时间，并且可以同时准备多台服务器。</font><font style="vertical-align: inherit;">由于人为因素而导致错误的可能性也大大降低了。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/g7/ic/x1/g7icx1q3tb0yanpntf9jmw8n4p4.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何自动配置服务器？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将详细分析所有步骤。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您有一个用作PXE安装服务器的linux服务器。</font><font style="vertical-align: inherit;">服务已在其上安装和配置：DHCP，TFTP。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们通过PXE加载服务器（需要配置）。</font><font style="vertical-align: inherit;">回想一下它是如何工作的：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择通过网络引导的服务器。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务器将加载网卡的PXE-ROM，并通过DHCP与安装服务器联系以获得网络地址。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安装服务器的DHCP提供地址，以及通过PXE进一步下载的说明。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务器通过PXE从安装服务器下载网络引导程序，进一步下载根据PXE配置文件进行。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据接收到的参数（内核，initramfs，安装点，squashfs映像等）执行下载。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意。</font><font style="vertical-align: inherit;">本文介绍了通过BIOS模式启动PXE。</font><font style="vertical-align: inherit;">当前，制造商正在积极引入UEFI引导模式。</font><font style="vertical-align: inherit;">对于PXE，区别在于DHCP服务器的配置和附加引导加载程序的存在。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑一个PXE服务器配置示例（pxelinux菜单）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文件pxelinux.cfg /默认值：</font></font><br>
<br>
<pre><code class="plaintext hljs">default menu.c32<font></font>
prompt 0<font></font>
timeout 100<font></font>
menu title X5 PXE Boot Menu<font></font>
LABEL InstallServer Menu<font></font>
	MENU LABEL InstallServer<font></font>
	KERNEL menu.c32<font></font>
	APPEND pxelinux.cfg/installserver<font></font>
LABEL VMware Menu<font></font>
	MENU LABEL VMware ESXi Install<font></font>
	KERNEL menu.c32<font></font>
	APPEND pxelinux.cfg/vmware<font></font>
LABEL toolkit //   <font></font>
	MENU LABEL Linux Scripting Toolkits<font></font>
	MENU default<font></font>
	KERNEL menu.c32<font></font>
	APPEND pxelinux.cfg/toolkit //    </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文件pxelinux.cfg / toolkit：</font></font><br>
<br>
<pre><code class="plaintext hljs">prompt 0<font></font>
timeout 100<font></font>
menu title X5 PXE Boot Menu<font></font>
label mainmenu<font></font>
    menu label ^Return to Main Menu<font></font>
    kernel menu.c32<font></font>
    append pxelinux.cfg/default<font></font>
label x5toolkit-auto //   —  <font></font>
        menu label x5 toolkit autoinstall<font></font>
        menu default<font></font>
        kernel toolkit/tkcustom-kernel<font></font>
        append initrd=toolkit/tk-initramfs.gz quiet net.ifnames=0 biosdevname=0 nfs_toolkit_ip=192.168.200.1 nfs_toolkit_path=tftpboot/toolkit nfs_toolkit_script=scripts/mount.sh script_cmd=master-install.sh CMDIS2=”…”<font></font>
label x5toolkit-shell //   - <font></font>
        menu label x5 toolkit shell<font></font>
        kernel toolkit/tkcustom-kernel<font></font>
        append initrd=toolkit/tkcustom-initramfs.gz quiet net.ifnames=0 biosdevname=0 nfs_toolkit_ip=192.168.200.1 nfs_toolkit_path=tftpboot/toolkit nfs_toolkit_script=scripts/mount.sh script_cmd=/bin/bash CMDIS2=”…”</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此阶段的内核和initramfs是中间的linux映像，借助该映像，服务器的基本准备工作和配置将完成。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，引导程序将许多参数传递给内核。</font><font style="vertical-align: inherit;">其中一些参数由内核本身使用。</font><font style="vertical-align: inherit;">我们可以将一些用于我们自己的目的。</font><font style="vertical-align: inherit;">稍后将对此进行描述，但是现在您仅可以记住，通过/ proc / cmdline在中间的Linux映像中可以使用所有传递的参数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内核和initramfs从哪里获得？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为基础，您可以选择任何Linux发行版。</font><font style="vertical-align: inherit;">选择时我们要注意的是：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引导映像必须是通用的（可用驱动程序，能够安装其他实用程序）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最有可能需要定制initramfs。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们针对X5的解决方案中，这是如何完成的？我们选择CentOS 7作为基础，让我们做以下技巧：准备将来的映像结构，将其打包到归档文件中并创建initramfs，在其中将成为我们的文件系统归档文件。加载映像时，归档文件将部署到创建的tmpfs部分。因此，我们获得了一个最小的，功能齐全的实时Linux映像，其中包含所有必需的实用程序，该实用程序仅包含两个文件：vmkernel和initramfs。</font></font><br>
<br>
<pre><code class="plaintext hljs"># : <font></font>
<font></font>
mkdir -p /tftpboot/toolkit/CustomTK/rootfs /tftpboot/toolkit/CustomTK/initramfs/bin<font></font>
<font></font>
# :<font></font>
<font></font>
yum groups -y install "Minimal Install" --installroot=/tftpboot/toolkit/CustomTK/rootfs/<font></font>
yum -y install nfs-utils mariadb ntpdate mtools syslinux mdadm tbb libgomp efibootmgr dosfstools net-tools pciutils openssl make ipmitool OpenIPMI-modalias rng-tools --installroot=/tftpboot/toolkit/CustomTK/rootfs/<font></font>
yum -y remove biosdevname --installroot=/tftpboot/toolkit/CustomTK/rootfs/<font></font>
<font></font>
#  initramfs:<font></font>
<font></font>
wget https://busybox.net/downloads/binaries/1.31.0-defconfig-multiarch-musl/busybox-x86_64 -O /tftpboot/toolkit/CustomTK/initramfs/bin/busybox<font></font>
chmod a+x /tftpboot/toolkit/CustomTK/initramfs/bin/busybox<font></font>
cp /tftpboot/toolkit/CustomTK/rootfs/boot/vmlinuz-3.10.0-957.el7.x86_64 /tftpboot/toolkit/tkcustom-kernel<font></font>
<font></font>
#  /tftpboot/toolkit/CustomTK/initramfs/init (  ):<font></font>
<font></font>
#!/bin/busybox sh<font></font>
/bin/busybox --install /bin<font></font>
mkdir -p /dev /proc /sys /var/run /newroot<font></font>
mount -t proc proc /proc<font></font>
mount -o mode=0755 -t devtmpfs devtmpfs /dev<font></font>
mkdir -p /dev/pts /dev/shm /dev/mapper /dev/vc<font></font>
mount -t devpts -o gid=5,mode=620 devpts /dev/pts<font></font>
mount -t sysfs sysfs /sys<font></font>
mount -t tmpfs -o size=4000m tmpfs /newroot<font></font>
echo -n "Extracting rootfs... "<font></font>
xz -d -c -f rootfs.tar.xz | tar -x -f - -C /newroot<font></font>
echo "done"<font></font>
mkdir -p /newroot/dev /newroot/proc /newroot/sys<font></font>
mount --move /sys  /newroot/sys<font></font>
mount --move /proc /newroot/proc<font></font>
mount --move /dev  /newroot/dev<font></font>
exec switch_root /newroot /sbin/init<font></font>
<font></font>
#  rootfs  initramfs:<font></font>
<font></font>
cd /tftpboot/toolkit/CustomTK/rootfs<font></font>
tar cJf /tftpboot/toolkit/CustomTK/initramfs/rootfs.tar.xz --exclude ./proc --exclude ./sys --exclude ./dev .<font></font>
cd /tftpboot/toolkit/CustomTK/initramfs<font></font>
find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; /tftpboot/toolkit/tkcustom-initramfs-new.gz</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们指定了应该加载的内核和initramfs。</font><font style="vertical-align: inherit;">结果，在此阶段，通过PXE下载中间linux映像，我们得到了OS控制台。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
很好，但是现在我们需要将控制权转移到我们的“自动化”上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以这样做。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设在加载映像之后，我们计划将控制权转移到mount.sh脚本。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们在自动运行中包含mount.sh脚本。</font><font style="vertical-align: inherit;">为此，您需要修改initramfs：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解压缩initramfs（如果我们使用上述版本的initramfs，则不需要这样做）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在启动代码中包含将分析通过/ proc / cmdline传递的参数并进一步传输控制的代码；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">打包initramfs。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意。对于X5工具包，引导控制已转移到脚本中，</font></font><code>/opt/x5/toolkit/bin/hook.sh   override.conf  getty tty1 (ExecStart=…) </code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，将加载映像，其中mount.sh脚本将在启动时启动。接下来，在分析过程中，mount.sh脚本分析传递的参数（script_cmd =）并启动必要的程序/脚本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
标签工具包- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自动</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
内核... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
附加... nfs_toolkit_script =脚本/ mount.sh </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">script_cmd = master-install.sh</font></font><br>
</b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
标签工具包- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外壳</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
内核... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
append ... nfs_toolkit_script =脚本/ mount.sh </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">script_cmd = / bin / bash</font></font></b><br>
<br>
<img src="https://habrastorage.org/webt/w9/xc/8b/w9xc8b87fob_jooqjazqiyyiccm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
左侧是PXE菜单，右边是控制权转移方案。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
随着控制权的转移，我们得以解决。</font><font style="vertical-align: inherit;">根据PXE菜单的选择，将启动自动调整脚本或调试控制台。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在自动配置的情况下，将安装来自安装服务器的必要目录，其中包含：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">剧本;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存各种服务器的BIOS / UEFI模板；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">固件;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务器实用程序；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">日志。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，mount.sh脚本将控制权从脚本目录转移到master-install.sh脚本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
脚本树（启动顺序）如下所示：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主安装</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共享功能（通用功能）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信息（信息输出）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型号（根据服务器型号设置安装参数）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prepare_utils（安装必要的实用程序）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fwupdate（固件更新）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">诊断（基本诊断）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biosconf（BIOS / UEFI设置）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clockfix（在主板上设置时间）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srmconf（配置远程接口）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">raidconf（配置逻辑卷）</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
之一：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预安装（将控制权转移到操作系统或管理程序的安装程序，例如ESXi）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合并安装（直接开始解压缩映像）</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们知道：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何通过PXE引导服务器；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何将控制权转移到您自己的脚本。</font></font></li>
</ul></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们继续。</font><font style="vertical-align: inherit;">以下问题已变得相关：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何识别我们正在准备的服务器？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哪些实用程序以及如何配置服务器？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何获取特定服务器的设置？</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何识别我们正在准备的服务器？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
很简单-DMI：</font></font><br>
<br>
<pre><code class="plaintext hljs">dmidecode –s system-product-name<font></font>
dmidecode –s system-manufacturer<font></font>
dmidecode –s system-serial-number</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它具有您需要的一切：供应商，型号，序列号。</font><font style="vertical-align: inherit;">如果不确定此信息是否出现在所有服务器中，则可以通过MAC地址识别它们。</font><font style="vertical-align: inherit;">或者，如果服务器供应商不同，并且在某些型号上同时使用两种方式，则序列号信息根本不可用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据收到的信息，将安装来自安装服务器的网络文件夹，并加载所有必需的文件（实用程序，固件等）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哪些实用程序以及如何配置服务器？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将为一些制造商提供Linux实用程序。</font><font style="vertical-align: inherit;">所有实用程序都可以在供应商的官方网站上找到。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xx/xh/3f/xxxh3f0pg48elgtr8qn9r_wjp4q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有了固件，我认为一切都很清楚。</font><font style="vertical-align: inherit;">它们通常以打包的可执行文件形式出现。</font><font style="vertical-align: inherit;">可执行文件控制固件更新过程并报告返回码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BIOS和IPMI通常是通过模板配置的。</font><font style="vertical-align: inherit;">如有必要，可以在加载之前编辑模板。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一些供应商的RAID实用程序也可以根据模板进行配置。</font><font style="vertical-align: inherit;">如果不是这种情况，则必须编写配置脚本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配置RAID的过程通常如下：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们请求当前配置。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果已经存在逻辑数组，则将其删除。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们查看存在哪些物理磁盘，以及其中有多少物理磁盘。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建一个新的逻辑数组。</font><font style="vertical-align: inherit;">如果发生错误，我们将中断该过程。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何获取特定服务器的设置？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设所有服务器设置都存储在安装服务器上。</font><font style="vertical-align: inherit;">在这种情况下，为了回答我们的问题，您首先需要确定：如何将设置转移到安装服务器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，很可能要处理文本文件。</font><font style="vertical-align: inherit;">（将来，您可以使用文本文件作为传输设置的备份方式）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以在安装服务器上“共享”文本文件。</font><font style="vertical-align: inherit;">并将其添加到mount.sh脚本中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，这些行将如下所示：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&lt;序列号&gt; &lt;主机名&gt; &lt;子网&gt; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些行将由工程师从其工作计算机转移到文件中。</font><font style="vertical-align: inherit;">然后，在设置服务器时，将从文件中读取特定服务器的参数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，将来最好使用数据库来存储设置，状态和服务器安装日志。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，一个数据库无法做到，您将需要创建一个客户端部件，借助该客户端部件，设置将被传输到数据库中。这比文本文件更难实现，但实际上并不像听起来那样难。客户端的最低版本可以将数据简单地传输到数据库，这对于编写自己的版本是相当可行的。将来，也有可能以自由模式（报告，打印标签，发送通知等）进行改进，以备不时之需。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
向数据库发出特定请求并指示服务器的序列号后，我们获得了配置服务器所需的参数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，我们不需要发明用于同步访问的锁，就像文本文件一样。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以在数据库的所有阶段写入配置日志，并通过准备阶段的事件和标志来控制安装过程。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们知道了：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过PXE加载服务器；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将控制权转移到我们的脚本；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过序列号识别要准备的服务器；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用适当的实用程序配置服务器；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用客户端将设置转移到安装服务器数据库。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
了解如何：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安装的服务器从数据库接收必要的设置；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有准备进度都记录在数据库中（日志，事件，阶段标志）。</font></font></li>
</ul></b><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何安装不同类型的软件？</font><font style="vertical-align: inherit;">如何安装虚拟机管理程序，复制VM并配置所有这些？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在将文件系统映像（linux）部署到硬件的情况下，一切都非常简单：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置所有服务器组件之后，部署映像。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安装grub引导程序。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们制作chroot并配置所有必要的东西。</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何将控制权转移到OS安装程序（以ESXi为例）。</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用自动响应文件（kickstart）来组织从脚本到虚拟机监控程序安装程序的控制转移：</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除磁盘上的当前分区。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建一个500MB的分区。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将其标记为启动。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">格式为FAT32。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将ESXi安装文件复制到根目录。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安装syslinux。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将syslinux.cfg复制到/ syslinux /</font></font></li>
</ul><br>
<pre><code class="plaintext hljs">default esxi<font></font>
prompt 1<font></font>
timeout 50<font></font>
label esxi<font></font>
kernel mboot.c32<font></font>
append -c boot.cfg</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将mboot.c32复制到/ syslinux。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在boot.cfg中应该有kernelopt = ks = ftp：// &lt;安装服务器的IP&gt; /ks_esxi.cfg</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重新启动服务器。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
服务器重新引导后，ESXi安装程序将从其硬盘驱动器引导。</font><font style="vertical-align: inherit;">根据指定的自动应答文件，所有必需的安装程序文件将被加载到内存中，并且ESXi的安装将开始。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是ks_esxi.cfg自动应答文件中的几行：</font></font><br>
<br>
<pre><code class="plaintext hljs">%firstboot --interpreter=busybox<font></font>
…<font></font>
#   <font></font>
<font></font>
SYSSN=$(esxcli hardware platform get | grep Serial | awk -F " " '{print $3}')<font></font>
<font></font>
#  IP<font></font>
<font></font>
IPADDRT=$(esxcli network ip interface ipv4 get | grep vmk0 | awk -F " " '{print $2}')<font></font>
LAST_OCTET=$(echo $IPADDRT | awk -F'.' '{print $4}')<font></font>
<font></font>
#  NFS -<font></font>
<font></font>
esxcli storage nfs add -H is -s /srv/nfs_share -v nfsshare1<font></font>
<font></font>
#    ssh,   ssh-<font></font>
<font></font>
mv /etc/ssh /etc/ssh.tmp<font></font>
cp -R /vmfs/volumes/nfsshare1/ssh /etc/<font></font>
chmod go-r /etc/ssh/ssh_host_rsa_key<font></font>
<font></font>
#  ovftool,    ,    <font></font>
<font></font>
cp -R /vmfs/volumes/nfsshare1/ovftool /vmfs/volumes/datastore1/<font></font>
<font></font>
#  <font></font>
<font></font>
/vmfs/volumes/datastore1/ovftool/tools/ovftool --acceptAllEulas --noSSLVerify --datastore=datastore1 --name=VM1 /vmfs/volumes/nfsshare1/VM_T/VM1.ova vi://root:esxi_password@127.0.0.1<font></font>
/vmfs/volumes/datastore1/ovftool/tools/ovftool --acceptAllEulas --noSSLVerify --datastore=datastore1 --name=VM2 /vmfs/volumes/nfsshare1/VM_T/VM2.ova vi://root:esxi_password@127.0.0.1<font></font>
<font></font>
#      <font></font>
<font></font>
ssh root@is "mysql -h'192.168.0.1' -D'servers' -u'user' -p'secretpassword' -e \"SELECT ... WHERE servers.serial='$SYSSN'\"" | grep -v ^$ | sed 's/NULL//g' &gt; /tmp/servers<font></font>
...<font></font>
#    <font></font>
<font></font>
echo '#!/bin/sh' &gt; /vmfs/volumes/datastore1/netconf.sh<font></font>
echo "esxcli network ip interface ipv4 set -i=vmk0 -t=static --ipv4=$IPADDR --netmask=$S_SUB || exit 1" &gt;&gt; /vmfs/volumes/datastore1/netconf.sh<font></font>
echo "esxcli network ip route ipv4 add -g=$S_GW -n=default || exit 1" &gt;&gt; /vmfs/volumes/datastore1/netconf.sh<font></font>
chmod a+x /vmfs/volumes/datastore1/netconf.sh<font></font>
<font></font>
#   guestinfo.esxihost.id,     <font></font>
<font></font>
echo "guestinfo.esxihost.id = \"$SYSSN\"" &gt;&gt; /vmfs/volumes/datastore1/VM1/VM1.vmx<font></font>
echo "guestinfo.esxihost.id = \"$SYSSN\"" &gt;&gt; /vmfs/volumes/datastore1/VM2/VM2.vmx<font></font>
...<font></font>
#    <font></font>
<font></font>
SYSNAME=$(esxcli hardware platform get | grep Product | sed 's/Product Name://' | sed 's/^\ *//')<font></font>
UUID=$(vim-cmd hostsvc/hostsummary | grep uuid | sed 's/\ //g;s/,$//' | sed 's/^uuid="//;s/"$//')<font></font>
ssh root@is "mysql -D'servers' -u'user' -p'secretpassword' -e \"UPDATE servers ... SET ... WHERE servers.serial='$SYSSN'\""<font></font>
ssh root@is "mysql -D'servers' -u'user' -p'secretpassword' -e \"INSERT INTO events ...\""<font></font>
<font></font>
#   SSH<font></font>
<font></font>
rm -rf /etc/ssh<font></font>
mv /etc/ssh.tmp /etc/ssh<font></font>
<font></font>
#    <font></font>
<font></font>
esxcli system hostname set --fqdn=esx-${G_NICK}.x5.ru<font></font>
/vmfs/volumes/datastore1/netconf.sh<font></font>
reboot<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此阶段，将安装和配置虚拟机监控程序，并复制虚拟机。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在如何配置虚拟机？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们作弊：在安装过程中，我们在VM1.vmx文件中设置guestinfo.esxihost.id =“ $ SYSSN”参数，指示其中的物理服务器的序列号。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，启动后，虚拟机（安装了vmware-tools软件包）可以访问此参数：</font></font><br>
<br>
<pre><code class="plaintext hljs">ESXI_SN=$(vmtoolsd --cmd "info-get guestinfo.esxihost.id")</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也就是说，VM将能够标识自己（知道物理主机的序列号），向安装服务器数据库发出请求并获取需要配置的参数。</font><font style="vertical-align: inherit;">这全部在脚本中执行，该脚本应在guestos vm启动时自动启动（但一次：RunOnce）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们知道了：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过PXE加载服务器；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将控制权转移到我们的脚本；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过序列号识别要准备的服务器；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用适当的实用程序配置服务器；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用客户端将设置转移到安装服务器数据库；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置各种类型的PO，包括部署esxi管理程序和配置虚拟机（以及全部自动）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
了解如何：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安装的服务器从数据库接收必要的设置；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有准备进度都记录在数据库中（日志，事件，阶段标志）。</font></font></li>
</ul></b><br>
<u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">底线：</font></font></b></u><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
我认为该解决方案的独特之处在于其灵活性，简单性，功能和多功能性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请在评论中写下您的想法。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN493112/index.html">如何在6个月而不是3年内开始新业务</a></li>
<li><a href="../zh-CN493114/index.html">数据工程师如何观看数据</a></li>
<li><a href="../zh-CN493116/index.html">“更多的互动性！” 或TeamLead Conf 2020如何</a></li>
<li><a href="../zh-CN493118/index.html">内存标记扩展概述（Armv8.5-A）</a></li>
<li><a href="../zh-CN493122/index.html">万岁游戏办公室：日本在莫斯科市中心</a></li>
<li><a href="../zh-CN493126/index.html">面向事件的架构的反模式</a></li>
<li><a href="../zh-CN493130/index.html">Почему не стоит бояться коронавируса: мифы и почти правда о COVID-2019</a></li>
<li><a href="../zh-CN493132/index.html">围绕数据表</a></li>
<li><a href="../zh-CN493136/index.html">Unity Storage中的FAST VP：如何工作</a></li>
<li><a href="../zh-CN493138/index.html">跟我说话：语音机器人今天能做什么</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>