<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôãüèΩ üõê üòâ Sorting cheat sheet for Data Science üìÅ ü§æüèª üêÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sorting data is a primary concern for data scientists and engineers. Python users can choose the most convenient from a number of libraries with built...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Sorting cheat sheet for Data Science</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillfactory/blog/506888/"><img src="https://habrastorage.org/getpro/habr/post_images/4be/b00/dfb/4beb00dfb3cdb4f8665747189fa8910a.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sorting data is a primary concern for data scientists and engineers. Python users can choose the most convenient from a number of libraries with built-in, optimized sorting options. Some even work in parallel with the GPU. Surprisingly, some sorting methods do not use these types of algorithms, while others do not work as expected. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Choosing a library and the type of sorting algorithm is not always easy, and innovations are changing at a fast pace. At the moment, the Pandas documentation does not match the code (although personally my PR update of the sorting options was the latest). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this article I will explain to you what‚Äôs what, I‚Äôll give you a couple of tips to help you figure out the methods, and share the results of the speed test. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD July 17, 2019</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: The results of evaluating the speed test now include PyTorch and TensorFlow GPU implementations. </font><font style="vertical-align: inherit;">TensorFlow also includes CPU results for both when </font></font><code>tensorflow==2.0.0-beta1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and when </font></font><code>tensorflow-gpu==2.0.0-beta1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Interesting observations: the PyTorch GPU literally flies, and the TensorFlow GPU is slower than the TensorFlow CPU.</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Context</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are many basic sorting algorithms. </font><font style="vertical-align: inherit;">Some of them have high performance and take up less space, others work well with large amounts of data. </font><font style="vertical-align: inherit;">For some algorithms, the relative position of the data elements is important. </font><font style="vertical-align: inherit;">In the diagram at the beginning of the article, you can see the situation in time and volume for the most common algorithms.</font></font><br>
 <a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, you don‚Äôt need to be an expert in basic deployments to solve most sorting problems. </font><font style="vertical-align: inherit;">In fact, premature optimization is sometimes considered the root of evil. </font><font style="vertical-align: inherit;">However, if you need to sort a large number of data multiple times, it can be very useful to know in advance which library and which keywords are best used. </font><font style="vertical-align: inherit;">I present to you </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">my cheat sheet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
 <br>
<img src="https://habrastorage.org/getpro/habr/post_images/67a/568/caa/67a568caa0670b09aaccb1efb4653bb1.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Over the years, sorting algorithms have changed in most libraries. </font><font style="vertical-align: inherit;">For analysis in this article, I took the following software versions.</font></font><br>
 <br>
<pre><code class="plaintext hljs">python 3.6.8<font></font>
numpy 1.16.4<font></font>
pandas 0.24.2<font></font>
tensorflow==2.0.0-beta1  #tensorflow-gpu==2.0.0-beta1 slows sorting<font></font>
pytorch 1.1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start with the basics.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python (vanilla)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python has two built-in sorting methods.</font></font><br>
<br>
<ul>
<li><code>my_list.sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sorts the list in place, with the original list being replaced with the sorted one. </font></font><code>sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns None.</font></font></li>
<li>sorted(my_list)      . <code> sorted()</code>   . <code>sort()</code>   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In theory, it </font></font><code>sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should be faster, since the sorting takes place on the spot. Surprisingly, there is not much difference between them. In addition, </font></font><code>sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it is worth using carefully, since it changes the original data without saving. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All implementations for Vanilla Python, which we will cover in this article, have an ascending default sort order, from smallest to largest. However, most other sorting methods use a top-down method. Not very convenient for you and your head, but this option varies for each library. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For our case, to change the sort order to descending in Vanilla Python, you need to specify </font></font><code>reverse=True</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<code>key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">may be declared a keyword for your unique criteria. For instance,</font></font><code>sort(key=len)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sorts the list items by their length. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The only sorting algorithm used in Vanilla Python is Timsort. Using this algorithm, data is sorted according to their main criteria. For example, if you want to sort a short list, insertion sorting is used. For more information on Timsort, see Brandon Skerritt's great article. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Timsort and, accordingly, Vanilla Python, are constant. That is, if the initial values ‚Äã‚Äãare the same, then the processed values ‚Äã‚Äãwill be similar and arranged in the same order. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To remind the difference between sort () and sorted (), I just notice that sorted () is a more complex command than </font></font><code>sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and that</font></font><code> sorted()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It will take objectively more time, because at the same time both the initial data and the copy are saved. </font><font style="vertical-align: inherit;">And even if the test results are ambiguous, mnemonics is our everything. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now I propose to consider the use of Numpy.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numpy</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Numpy is the fundamental Python library for scientific computing. </font><font style="vertical-align: inherit;">Like Vanilla Python, it has two options for implementation: either copying or changing the array of source data:</font></font><br>
<br>
<ul>
<li><code>my_array.sort ()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> changes the array in place and returns a sorted array;</font></font></li>
<li><code>np.sort (my_array)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> returns a copy of the sorted array, without changing the original data.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arguments used optionally:</font></font><br>
<br>
<ul>
<li><code>axis</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int, optional</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - axis on which sorting is performed. </font><font style="vertical-align: inherit;">By default -1 - sorting by the last axis.</font></font></li>
<li><code>kind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{'quicksort', 'mergesort', 'heapsort', 'stable'}</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - sorting algorithm. </font><font style="vertical-align: inherit;">By default, 'quicksort' is used. </font><font style="vertical-align: inherit;">Next I will talk about this in more detail.</font></font></li>
<li><code>order</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">str or list of str</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - when a is an array with defined boundaries, this argument indicates in which order these boundaries are compared. </font><font style="vertical-align: inherit;">One field may be specified as a string; further fields may not be specified. </font><font style="vertical-align: inherit;">They will in any case be used in dtype for interruptions.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Frankly, at the moment, sorting algorithms actually match their names. </font><font style="vertical-align: inherit;">The command </font></font><code> kind=quicksort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">literally means that sorting begins with </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introspective sorting</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">More details </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<blockquote> ,    ,     heapsort.         O(n* log (n)).<br>
<br>
stable      .  ,    ,       timsort  radix,     .   API       ,        .<br>
<br>
Timsort          .    timsort   mergesort.        ,       -   ,     ‚Ä¶ ¬´mergesort¬ª  ¬´stable¬ª      .<br>
 ‚Äî  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="> Numpy</a> ‚Äî (   )</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of the most important conclusions: Numpy allows you to manage sorting options more freely than Vanilla Python. </font><font style="vertical-align: inherit;">The second conclusion, no less important: the kind keyword does not necessarily correspond to the sort type used. </font><font style="vertical-align: inherit;">And finally, the final result, if I may say so, is that </font></font><code>mergesort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>stable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are certain to Sort, and </font></font><code>quicksort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>heapsort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- no. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Numpy is the only method on our list that does not have a keyword for changing the sort order. </font><font style="vertical-align: inherit;">Luckily, it can be a kind of flip the array: </font></font><code>my_arr[::-1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All Numpy features are also available in much more user-friendly Pandas.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pandas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can sort in Pandas DataFrame c </font></font><code>df.sort_values (by=my_column)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For convenience, there are several keywords.</font></font><br>
<br>
<ul>
<li><code>by</code>: <i>str  list of str</i> ‚Äî       .   = 0   ,      / .    1  ,       /  .</li>
<li><code>axis</code>: <i>{0  , 1  }</i>,   0 ‚Äî   .</li>
<li><code>ascending</code>: <i>bool   bool</i>,    True ‚Äî      .      .    ,     by.</li>
<li><code>inplace</code>: <i>bool,   False</i> ‚Äî   True,    .</li>
<li><code>kind</code>: <i>{quicksort, mergesort, heapsort  stable}</i>,   quicksort ‚Äî   .       <code>ndarray.np.sort</code>.  DataFrames           .</li>
<li><code>na_position</code>: <i>{¬´first¬ª, ¬´last¬ª}</i>,   ¬´last¬ª ‚Äî first  NaNs  , last  NaNs  .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pandas Series is implemented with the same syntax. In Series, there is no need for a keyword </font></font><code>by</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, because there are no multiple columns with data. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since Pandas is ‚Äúunder the hood‚Äù - Numpy, you have the same optimized sorting options at your fingertips. However, using Pandas is a little more laborious. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When sorting by one column in Numpy, it is used by default </font></font><code>quicksort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. As you remember, </font></font><code>quicksort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">now it is actually introductory and goes into the pyramidal, if the sorting process is slow. Pandas claim that sorting across multiple columns uses </font></font><code>mergesort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numpy. </font></font><code>mergesort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numpy actually uses Timsort or Radix sorting algorithms. These are stable sorting algorithms, which is necessary when sorting across multiple columns.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are several key points for Pandas to remember:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Function name: </font></font><code>sort_values()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Must declare </font></font><code>by=column_name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or list column names.</font></font></li>
<li><code>ascending</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Is the keyword for reverse.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For stable sorting use </font></font><code>mergesort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When analytically processing data, I often encounter summing and sorting values ‚Äã‚Äãin Pandas DataFrame with </font></font><code>Series.value_counts()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Here is a code snippet to summarize and sort the most common values ‚Äã‚Äãfor each column.</font></font><br>
 <br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> df.columns:<font></font>
    print(<span class="hljs-string">f"---- <span class="hljs-subst">{c}</span> ---"</span>)<font></font>
    print(df[c].value_counts().head())</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dask</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which Pandas offer for working with big data, does not yet have a parallel sorting implementation, but this </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">issue is under discussion</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pandas sorting is a good choice for pre-sorting small amounts of data. </font><font style="vertical-align: inherit;">If you have a large amount of data and want to work in parallel with the GPU, you should pay attention to TensorFlow or PyTorch.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tensorflow</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TensorFlow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the most popular medium for deep learning. </font><font style="vertical-align: inherit;">You can learn more about deep learning in my article at the link </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The following information is relevant for the TensorFlow 2.0 GPU. </font></font><br>
<br>
<code>tf.sort(my_tensor)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns a sorted copy of the tensor. </font><font style="vertical-align: inherit;">Optional arguments:</font></font><br>
<br>
<ul>
<li><code>axis</code>: <i>{int}</i> ,    .    -1    .</li>
<li><code>direction</code>:<i> {ascending  descending}</i> ‚Äî   .</li>
<li><code>name</code>: <i>{str}</i> ‚Äî   .</li>
</ul><br>
<code>tf.sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">essentially uses </font></font><code> top_k()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. For </font></font><code>top_k()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the CUB library</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the CUDA GPU is used, which simplifies the parallel implementation. The documentation says that ‚ÄúCUB provides modern and repeatable software components for each level of the CUDA programming model.‚Äù TensorFlow uses basic GPU sorting through the CUB ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">discussion</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Information on the TensorFlow GPU can be found </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . To activate the GPU with TensorFlow 2.0, you need to register </font></font><code>!pip3 install tensorflow-gpu==2.0.0-beta1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It will be seen below that you can follow the path </font></font><code>tensorflow==2.0.0-beta1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if you are only sorting data (which is unlikely). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To check the code on the CPU and GPU, use the following line:</font></font><br>
<br>
<pre><code class="plaintext hljs">tf.debugging.set_log_device_placement(True)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To indicate that you want to use the GPU, you need to use this block:</font></font><br>
<br>
<pre><code class="plaintext hljs">with tf.device('/GPU:0'):<font></font>
 %time tf.sort(my_tf_tensor)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To use the CPU: </font></font><code>with tf.device('/CPU:0')</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<code>tf.sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is an intuitive method when working in TensorFlow. </font><font style="vertical-align: inherit;">Just remember what you </font></font><code>direction=descending</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">need to change the sort order.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pytorch</font></font></h3><br>
<code>torch.sort(my_tensor)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns a sorted copy of the tensor. </font><font style="vertical-align: inherit;">Optional arguments:</font></font><br>
<br>
<ul>
<li><code>dim</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{int}</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - sorting volume.</font></font></li>
<li><code>descending</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{bool}</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - controls the sort order (ascending or descending).</font></font></li>
<li><code>out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{tuple}</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - output tracking (Tensor, LongTensor), which can be used as output buffers.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you want to use the GPU for sorting, attach </font></font><code>.cuda ()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the end of your tensor.</font></font><br>
<br>
<pre><code class="plaintext hljs">gpu_tensor=my_pytorch_tensor.cuda()<font></font>
%time torch.sort(gpu_tensor)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Research has shown that PyTorch uses segmented parallel sorting through </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thrust</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if it is sorting a dataset larger than 1 million rows per 100,000 columns. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unfortunately, I did not have enough memory when I tried to create arbitrary data of 1.1 million per 100 thousand in size through Numpy in Google Colab. </font><font style="vertical-align: inherit;">After that, I tried GCP with 416 MB of RAM, and again I ran out of memory.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segmented sorting and sorting by location are high-performance merge sorting options that work with heterogeneous random data. </font><font style="vertical-align: inherit;">Segmented sorting allows you to sort multiple arrays of variable length in parallel. </font><font style="vertical-align: inherit;">- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://moderngpu.github.io/segsort.html</font></font></a></blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thrust</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a parallel algorithm library that provides compatibility between GPU performance and multi-core CPUs. It provides a sorting framework that automatically selects the most efficient implementation method. The CUB library used by TensorFlow lightens the load. PyTorch and TensorFlow use similar algorithms to sort GPUs - no matter which approach you use. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As TensorFlow, sorting method in PyTorch pretty easy to remember: </font></font><code>torch.sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The only thing to remember is the direction of the sorted values: TensorFlow uses </font></font><code>direction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and PyTorch uses </font></font><code>descending</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. And do not forget to use </font></font><code>.cuda()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it to maximize speed when working with large amounts of data.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
While GPU sorting may be a good option for very large datasets, it also makes sense to sort the data directly in SQL.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sorting in SQL is usually very fast, especially if the sorting takes place directly in memory. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SQL is a specification that does not oblige you to use a specific algorithm. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Postgres uses</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> disk merge sorting, pyramidal or fast sorting, depending on the circumstances. If you have enough memory, sorting can be done in it, and much faster. You can increase the available memory for sorting with </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><code> work_mem</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Other SQL options use different sorting algorithms. For example, Google BigQuery uses internal sorting with some tricks, such as those presented </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the answer to Stack Overflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sorting in SQL is done by the command</font></font><code>ORDER BY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This syntax is different from Python, where they prefer to use some form of the word sort. </font><font style="vertical-align: inherit;">Personally, I remember that ORDER BY is used in SQL syntax, as it is rather unusual. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To sort data in descending order, use the DESC keyword. </font><font style="vertical-align: inherit;">Thus, a request to return data in alphabetical order from last to first will look like this:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">Names</span> <span class="hljs-keyword">FROM</span> Customers
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">Names</span> <span class="hljs-keyword">DESC</span>;
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparison</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For each of the above Python libraries, I performed an analysis by sorting 1,000,000 data points in a single column, array, or list. </font><font style="vertical-align: inherit;">I used a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google Colab Jupyter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> laptop with a K80 GPU and a 2.30 GHz Intel Xeon CPU.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/64c/2ea/636/64c2ea636ec6e3148fda501eb431729e.gif" alt="image"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observations</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PyTorch with GPUs as fast as possible.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For both Numpy and Pandas, in-place sorting is generally faster than copying data.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pandas quicksort by default is pretty quick.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most Pandas features are relatively slower than their Numpy counterparts.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The TensorFlow processor is pretty fast. </font><font style="vertical-align: inherit;">Installing a GPU slows down TensorFlow even when using a CPU. </font><font style="vertical-align: inherit;">GPU sorting is pretty slow. </font><font style="vertical-align: inherit;">This option is not very effective.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Vanilla Python, in-place sorting is surprisingly slow ‚Äî almost 100 times slower than sorting with PyTorch GPU support. </font><font style="vertical-align: inherit;">I built the experiment several times (with different data) to double-check that this is not an anomaly.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Again, this is just one small test. </font><font style="vertical-align: inherit;">This is definitely not the end result.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To summarize</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a rule, you do not need your own development of sorting options. Ready-made options are quite satisfactory, and often use more than one sorting method. Instead, they first evaluate the data and then use the proven sorting algorithm. Some versions even modify the algorithms if sorting slows down. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this article, you figured out how to sort each piece of data in Python and SQL. I hope this helps you in the future. If you have the opportunity, please share the article on your favorite social networks to help other people find it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You just need to remember which option to choose and call it. Use my cheat sheet to save time. My general recommendations are as follows:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use Pandas </font></font><code>sort_values()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by default to explore relatively small datasets.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For large datasets, or when the speed is high enough, try the built-in Numpy sort in place, parallel implementation of the PyTorch or TensorFlow, or SQL GPU.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I haven‚Äôt written too much about GPU sorting. </font><font style="vertical-align: inherit;">This is an area that has matured for new research and study guides. </font><font style="vertical-align: inherit;">Here is a 2017 research article to give you an idea of ‚Äã‚Äãthe latest </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">research</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">More information on GPU sorting algorithms can be found </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rd/kl/lr/rdkllrbtrth_kdpceb-vxzrxl1o.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Learn the details of how to get a sought-after profession from scratch or Level Up in skills and salary by taking paid SkillFactory online courses:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Machine Learning Course (12 weeks)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data Scientist Profession Course (24 months) </font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">  ¬´ Data Analyst¬ª (18 )</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="> ¬´Python  -¬ª (9 )</a></li>
</ul> <br>
<br clear="left">
<h3> </h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">450     </a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">   Data Science  Harvard University</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">65    Machine Learning    </a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">30    -  </a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">     Data Science : Cambridge Analytica</a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en506870/index.html">How to disable the warning about the dangers of long listening to audio (Android)</a></li>
<li><a href="../en506872/index.html">Book Spring Boot 2: Best Practices for Professionals</a></li>
<li><a href="../en506874/index.html">From the life of a programmer: Business people</a></li>
<li><a href="../en506880/index.html">Joel Spolsky: how the Stack Overflow era began</a></li>
<li><a href="../en506886/index.html">Life hack for bits</a></li>
<li><a href="../en506890/index.html">Easter Egg in ionCube - an attempt by developers to sweep garbage under the carpet?</a></li>
<li><a href="../en506896/index.html">The most realistic interpretation of quantum mechanics</a></li>
<li><a href="../en506902/index.html">Smart home in a smart city</a></li>
<li><a href="../en506906/index.html">Black hole paradoxes reveal the fundamental connection between energy and order</a></li>
<li><a href="../en506908/index.html">Top science. May media ten: desperation of aquarium fish, voices of mental disorders and many times COVID</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>