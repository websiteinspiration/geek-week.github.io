<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏼 👊🏾 🌠 ZIO＆Cats Effect：成功した同盟 ➖ 🦑 🖕🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cats Effectは、機能的なScalaワールドの一種の「リアクティブストリーム」になり、ライブラリの多様なエコシステム全体を組み合わせることができます。
 
 多くの優れたライブラリ：http4s、fs2、doobie-Cats Effectの型クラスに基づいてのみ実装されています。ZIOやM...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ZIO＆Cats Effect：成功した同盟</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/472386/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cats Effectは、機能的なScalaワールドの一種の「リアクティブストリーム」になり、ライブラリの多様なエコシステム全体を組み合わせることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの優れたライブラリ：http4s、fs2、doobie-Cats Effectの型クラスに基づいてのみ実装されています。</font><font style="vertical-align: inherit;">ZIOやMonixなどのライブラリは、これらのタイプクラスのインスタンスをエフェクトタイプに提供します。</font><font style="vertical-align: inherit;">バージョン3.0で修正されるいくつかの問題にもかかわらず、Cats Effectは多くのオープンソースコントリビューターがScala言語の機能的エコシステム全体を有機的にサポートするのに役立ちます。</font><font style="vertical-align: inherit;">Cats Effectを使用する開発者は難しい選択に直面します：アプリケーションに使用する効果の実装。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日、3つの選択肢があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cats IO、リファレンス実装。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Monix、コード内のTaskデータ型とその反応性。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZIO、ZIOデータ型とそのクロススレッドスコープ。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この投稿では、Cats Effectを使用してアプリケーションを作成するために、ZIOがCats IOのリファレンス実装とはかなり異なる設計ソリューションと機能を備えた優れた選択肢であることを証明しようとします。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.より優れたMTL /タグなし最終アーキテクチャ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MTL（Monad Transformers Library）は、関数がその効果のタイプによって多態的であり、「タイプクラス制約」を通じて要件を表現するプログラミングスタイルです。 Scalaでは、これはタグなしファイナルスタイルと呼ばれます（同じではありませんが）。特に、型クラスに法則がない場合はそうです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cats IOなどのエフェクトタイプだけでなく、WriterやStateなどのクラシックMTLタイプクラスのグローバルインスタンスを定義できないことはよく知られています。問題は、これらのタイプのエフェクトのこれらのタイプクラスのインスタンスが、変更可能な状態へのアクセスを必要とすることです。これは、変更可能な状態の作成も影響であるため、グローバルに作成することはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、最高のパフォーマンスを得るには、「モナドトランスフォーマー」を回避し、主効果タイプの上に直接、書き込みと状態の実装を提供することが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを達成するために、Scalaプログラマーはトリックを使用します。プログラムのトップレベルでエフェクトを使用して（ただし、きれいに）インスタンスを作成し、ローカルインプリケーションとしてプログラムでさらに提供します。</font></font><br>
<br>
<pre><code class="scala hljs"><span class="hljs-type">Ref</span>.make[<span class="hljs-type">AppState</span>](initialAppState).flatMap(ref =&gt;
  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> monadState = <span class="hljs-keyword">new</span> <span class="hljs-type">MonadState</span>[<span class="hljs-type">Task</span>, <span class="hljs-type">AppState</span>] {
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span></span>: <span class="hljs-type">Task</span>[<span class="hljs-type">AppState</span>] = ref.get <font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span></span>(s: <span class="hljs-type">AppState</span>): <span class="hljs-type">Task</span>[<span class="hljs-type">Unit</span>] = ref.set(s).unit<font></font>
  }<font></font>
<font></font>
  myProgram<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのようなトリックが役立つという事実にもかかわらず、それはまだ「松葉杖」です。</font><font style="vertical-align: inherit;">理想的な世界では、型クラスのすべてのインスタンスは一貫性があり（型ごとに1つのインスタンス）、ローカルに作成されず、効果を生成するため、後続のメソッドで使用するために暗黙的な値に魔法のように自分自身をラップします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MTL / tagless-finalの優れた機能は、ZIO環境を使用して、ほとんどのインスタンスをZIOデータ型の上に直接定義できることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZIOデータ型のグローバルMonadState定義を作成する1つの方法を次に示します。</font></font><br>
<br>
<pre><code class="scala hljs">
<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">State</span>[<span class="hljs-type">S</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">state</span></span>: <span class="hljs-type">Ref</span>[<span class="hljs-type">S</span>]<font></font>
}<font></font>
<span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ZIOMonadState</span></span>[<span class="hljs-type">S</span>, <span class="hljs-type">R</span> &lt;: <span class="hljs-type">State</span>[<span class="hljs-type">S</span>], <span class="hljs-type">E</span>]: <span class="hljs-type">MonadState</span>[<span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, ?], <span class="hljs-type">S</span>] =
  <span class="hljs-keyword">new</span> <span class="hljs-type">MonadState</span>[<span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, ?], <span class="hljs-type">S</span>] {
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span></span>: <span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, <span class="hljs-type">S</span>] = <span class="hljs-type">ZIO</span>.accessM(_.state.get)<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span></span>(s: <span class="hljs-type">S</span>): <span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, <span class="hljs-type">Unit</span>] = <span class="hljs-type">ZIO</span>.accessM(_.state.set(s).unit)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インスタンスは、少なくともをサポートするすべての環境に対してグローバルに定義されるようになりました</font></font><code>State[S]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に</font></font><code>FunctorListen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、別名</font></font><code>MonadWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="scala hljs">
<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Writer</span>[<span class="hljs-type">W</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">writer</span></span>: <span class="hljs-type">Ref</span>[<span class="hljs-type">W</span>]<font></font>
}<font></font>
<span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ZIOFunctorListen</span></span>[<span class="hljs-type">W</span>: <span class="hljs-type">Semigroup</span>, <span class="hljs-type">R</span> &lt;: <span class="hljs-type">Writer</span>[<span class="hljs-type">W</span>], <span class="hljs-type">E</span>]: <span class="hljs-type">FunctorListen</span>[<span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, ?], <span class="hljs-type">W</span>] =
  <span class="hljs-keyword">new</span> <span class="hljs-type">FunctorListen</span>[<span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, ?], <span class="hljs-type">W</span>] {
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">listen</span></span>[<span class="hljs-type">A</span>](fa: <span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, <span class="hljs-type">A</span>]): <span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, (<span class="hljs-type">A</span>, <span class="hljs-type">W</span>)] = 
    <span class="hljs-type">ZIO</span>.accessM(_.state.get.flatMap(w =&gt; fa.map(a =&gt; a -&gt; w)))<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tell</span></span>(w: <span class="hljs-type">W</span>): <span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, <span class="hljs-type">W</span>] = 
    <span class="hljs-type">ZIO</span>.accessM(_.state.update(_ |+| w).unit)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてもちろん、同じことを次のように実行できます</font></font><code>MonadError</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="scala hljs">
<span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ZIOMonadError</span></span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>]: <span class="hljs-type">MonadError</span>[<span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, ?], <span class="hljs-type">E</span>] = 
  <span class="hljs-keyword">new</span> <span class="hljs-type">MonadError</span>[<span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, ?], <span class="hljs-type">E</span>]{
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handleErrorWith</span></span>[<span class="hljs-type">A</span>](fa: <span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, <span class="hljs-type">A</span>])(f: <span class="hljs-type">E</span> =&gt; <span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, <span class="hljs-type">A</span>]): <span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, <span class="hljs-type">A</span>] = <font></font>
      fa&nbsp;catchAll f<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">raiseError</span></span>[<span class="hljs-type">A</span>](e: <span class="hljs-type">E</span>): <span class="hljs-type">ZIO</span>[<span class="hljs-type">R</span>, <span class="hljs-type">E</span>, <span class="hljs-type">A</span>] = <span class="hljs-type">ZIO</span>.fail(e)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この手法は、タグなし最終型クラスを含む他の型クラスに簡単に適用できます。そのインスタンスは、効果の生成（変更、構成）、効果を生成するテスト関数（環境効果とタグなし最終の組み合わせ）、または環境から簡単にアクセスできるその他のものに必要です。 。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モナド変換が遅くなることはもうありません！</font><font style="vertical-align: inherit;">タイプクラスのインスタンスを初期化するときにエフェクトを作成し、ローカルの影響を「いいえ」としましょう。</font><font style="vertical-align: inherit;">これ以上松葉杖は必要ありません。</font><font style="vertical-align: inherit;">純粋な関数型プログラミングへの直接の没入。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.単なる人間のためのリソースの節約</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZIOの最初の機能の1つはインターラプションでした。ZIOランタイムが実行可能な効果を即座に中断し、すべてのリソースを解放することが保証されていることです。この機能の大まかな実装がCats IOに影響を与えました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haskellは、このような機能を非同期例外と呼びました。これにより、待ち時間、効率的な並列および競合操作、およびグローバルに最適な計算を作成して効率的に使用できます。このような中断は、大きなメリットをもたらすだけでなく、リソースへの安全なアクセスをサポートするという分野で複雑なタスクを引き起こします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラマーは、単純な分析を通じてプログラムのエラーを追跡するために使用されます。</font><font style="vertical-align: inherit;">これは、タイプシステムを使用してエラーの検出を支援するZIOでも実行できます。</font><font style="vertical-align: inherit;">しかし、中断は別のものです。</font><font style="vertical-align: inherit;">他の多くの効果から作成された効果は、任意の境界で中断できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の影響を考慮してください。</font></font><br>
<br>
<pre><code class="scala hljs">
<span class="hljs-keyword">for</span> {<font></font>
  handle &lt;- openFile(file)<font></font>
  data &lt;- readFile(handle)<font></font>
  _ &lt;- closeFile(handle)<font></font>
} <span class="hljs-keyword">yield</span> data</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの開発者は、このシナリオに驚かないでしょう</font><font style="vertical-align: inherit;">。落ちて</font></font><code>closeFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も実行されません</font></font><code>readFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">幸いなことに、エフェクトシステムを持っている</font></font><code>ensuring</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>guarantee</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたが最終的に似たファイナライザー効果に最終ハンドラを追加することができ、猫の影響で）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、上記のコードの主な問題は簡単に解決できます。</font></font><br>
<br>
<pre><code class="scala hljs">
<span class="hljs-keyword">for</span> {<font></font>
  handle &lt;- openFile(file)<font></font>
  data &lt;- readFile(handle).ensuring(closeFile(handle))<font></font>
} <span class="hljs-keyword">yield</span> ()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
効果が「転倒に強い」に</font></font><code>readFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なりました。壊れ</font><font style="vertical-align: inherit;">た場合</font><font style="vertical-align: inherit;">でもファイルは閉じられます。それがあれば</font></font><code>readFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成功し、ファイルも閉じられます。すべての場合において、ファイルは閉じられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、それでもまだすべてではありません。実行中の効果もの間、どこでも中断することができることを中断手段</font></font><code>openFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>readFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この場合、開いているファイルは閉じられず、リソースリークが発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リソースの取得と解放のパターンは非常に広まっているため、ZIOはブラケット演算子を導入しました。これはCats Effect 1.0にも登場しました。 Bracketステートメントは、中断から保護します。リソースが正常に受信された場合、リソースを使用する効果が中断されても解放が発生します。さらに、リソースの受信も解放も中断できないため、リソースのセキュリティが保証されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブラケットを使用すると、上記の例は次のようになります。</font></font><br>
<br>
<pre><code class="scala hljs">openFile(file).bracket(closeFile(_))(readFile(_))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、ブラケットは1つの（かなり一般的な）リソース消費パターンのみをカプセル化します。</font><font style="vertical-align: inherit;">他にも多くのものがあり、特に競合するデータ構造では、割り込みのためにアクセスできる必要があります。そうしないと、リークが発生する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、すべての割り込み作業は、主に次の2つに分類されます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中断される可能性のある一部の領域での中断を防ぐ。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">凍結する可能性のある領域での中断を許可します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZIOには、両方を実装する機能があります。</font><font style="vertical-align: inherit;">たとえば、低レベルのZIO抽象化を使用して、ブラケットのバージョンを開発できます。</font></font><br>
<br>
<pre><code class="scala hljs">
<span class="hljs-type">ZIO</span>.uninterruptible {
  <span class="hljs-keyword">for</span> {<font></font>
    a &lt;- acquire<font></font>
    exit &lt;- <span class="hljs-type">ZIO</span>.interruptible(use(a))<font></font>
    .run.flatMap(exit =&gt; release(a, exit)<font></font>
    .const(exit))<font></font>
    b &lt;- <span class="hljs-type">ZIO</span>.done(exit)<font></font>
  } <span class="hljs-keyword">yield</span> b<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードで</font></font><code>use(a)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、が中断できる唯一の部分です。周囲のコード</font></font><code>release</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、いかなる場合でも</font><font style="vertical-align: inherit;">実行</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">保証</font><font style="vertical-align: inherit;">します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いつでも、中断の可能性があるかどうかを確認できます。このため、2つの基本操作のみが必要です（残りはすべてそれらから派生します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この構成のフル機能の割り込みモデルにより、ブラケットの単純な実装だけでなく、割り込みの利点と欠点のバランスがとられているリソース管理の他のシナリオの実装も実装できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cats IOは、割り込みを制御するための1つの操作のみを提供します：キャンセルできないコンビネーター。コードのブロック全体が中断されません。この操作はめったに使用されませんが、リソースリークまたはロックが発生する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、Cats IO内でプリミティブを定義できることがわかりました。これにより、割り込みをより詳細に制御できます。</font><font style="vertical-align: inherit;">Fabio Labellaの非常に複雑な実装は、非常に遅いことが判明しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZIOを使用すると、割り込みのあるコードを記述したり、宣言的複合演算子を使用して高レベルで操作したりできます。また、深刻な複雑さと低パフォーマンスの組み合わせやリークのブロックを強制することはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、最近追加されたZIOのソフトウェアトランザクションメモリにより、ユーザーは、自動的に非同期で競合し、割り込みを許可するデータ構造とコードを宣言的に書き込むことができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.保証されたファイナライザ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くのプログラミング言語のtry / finallyブロックは、リソースをリークすることなく同期コードを記述するために必要な保証を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に、このブロックは次のことを保証します。tryブロックが実行を開始した場合、tryが停止したときにfinallyブロックが実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この保証は以下に適用されます：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネストされた「try / finally」ブロックがあります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「トライブロック」にエラーがあります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネストされたfinallyブロックにエラーがあります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZIOの「保証」操作は、try / finallyのように使用できます。</font></font><br>
<br>
<pre><code class="scala hljs"><span class="hljs-keyword">val</span> effect2 = effect.ensuring(cleanup)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZIOは、「effect.ensuring（finalizer）」に対して次の保証を提供します。「effect」が実行を開始した場合、「finalizer」は「effect」が停止したときに実行を開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
try / finallyのように、これらの保証は次の場合にも残ります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネストされた「保証」構成があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「効果」にエラーがあります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネストされた「ファイナライザ」にエラーがあります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、効果が中断されても保証は維持されます（「ブラケット」の保証も同様です。実際、「保証」には「ブラケット」が実装されています）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cats IOデータ型は、別の弱い保証を提供します。</font><font style="vertical-align: inherit;">「effect.guarantee（ファイナライザー）」は以下のように弱められています。「エフェクト」が実行され始めた場合、「エフェクト」に問題のエフェクトが挿入されていなければ、「エフェクト」が停止した時点で「ファイナライザー」が実行を開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cats IOの「ブラケット」の実装には、より弱い保証もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リソースリークを取得するには、「guarantee」または「bracket.use」エフェクト内で使用されるエフェクトを使用し、次のようなもので構成します。</font></font><br>
<br>
<pre><code class="scala hljs"><span class="hljs-comment">//   `interruptedFiber` -   </span>
<span class="hljs-keyword">val</span> bigTrouble = interruptedFiber.join</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようにbigTroubleが別のエフェクトに挿入されると、エフェクトは中断されなくなります。「保証」で設定された「ファイナライザ」や「ブラケット」によるリソースのクリーニングは実行されません。ブロックに「ファイナライザ」がある場合でも、これらすべてがリソースの浪費につながります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、次のコードの「ファイナライザ」は実行を開始しません。</font></font><br>
<br>
<pre><code class="scala hljs">(<span class="hljs-type">IO</span>.unit &gt;&gt; bigTrouble).guarantee(<span class="hljs-type">IO</span>(println(<span class="hljs-string">"Won’t be&nbsp;executed!!!«)))</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グローバルコンテキストを考慮せずにコードを評価する場合、「bigTrouble」などの効果が「ブラケット」操作の「使用」効果のどこに挿入されるか、ファイナライザブロック内に挿入されるかを判断することは不可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、Cats IOプログラムがプログラム全体を評価せずに、リソースリークや不足している「ファイナライザ」ブロックで機能するかどうかを確認することはできません。プログラム全体は手動でしか評価できず、このプロセスには常にコンパイラーで検証できないエラーが伴います。さらに、このプロセスは、コードに重要な変更が発生するたびに繰り返す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZIOには、Cats Effectの「guarantee」、「guaranteeCase」、および「bracket」のカスタム実装があります。</font><font style="vertical-align: inherit;">実装はネイティブのZIOセマンティクス（Cats IOセマンティクスではない）を使用します。これにより、リソースリークに関する起こりうる問題をここで評価できるようになり、すべての状況でファイナライザーが起動され、リソースが解放されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.安定したスイッチング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャッツエフェクトには、「ContextShift」の「evalOn」メソッドがあり、コードの実行を別の実行コンテキストに移動できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、いくつかの理由で役立ちます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くのクライアントライブラリでは、スレッドプールで何らかの作業を行う必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UIライブラリでは、UIスレッドでいくつかの更新を行う必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部の効果では、特定の機能に適合したスレッドプールを分離する必要があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「EvalOn」操作は、実行する必要がある場所で効果を実行してから、元の実行コンテキストに戻ります。例えば：</font></font><br>
<br>
<pre><code class="scala hljs">cs.evalOn(kafkaContext)(kafkaEffect)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注：Cats IOにも同様の「シフト」構成があり、戻ることなく別のコンテキストに切り替えることができますが、実際にはこの動作が必要になることはほとんどないため、「evalOn」が推奨されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「evalOn」（ZIOプリミティブ「ロック」で作成）のZIO実装は、エフェクトが機能する場所を一意に理解するために必要な保証を提供します。エフェクトは常に特定のコンテキストで実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cats IOには、別の弱い保証があります。効果は、最初の非同期操作または内部切り替えまで、特定のコンテキストで実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードの小さな部分を考えると、非同期は型に表示されないため、非同期効果（または入れ子の切り替え）が切り替えられる効果に組み込まれるかどうかを確実に知ることは不可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、リソースセキュリティの場合と同様に、Cats IO効果がどこで発生するかを理解するには、プログラム全体を調査する必要があります。</font><font style="vertical-align: inherit;">実際に、そして私の経験から、Cats IOユーザーは、ある状況で「evalOn」を使用しているときに、ほとんどの効果が別の状況で誤って実行されたことが後に判明したことに驚いています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZIOを使用すると、効果をトリガーする場所を決定できます。これにより、効果が他の効果にどのように組み込まれているかに関係なく、これがすべてのケースでどのように発生するかを信頼できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.エラーメッセージのセキュリティ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時実行性、同時実行性、またはリソースへの安全なアクセスをサポートする効果は、線形エラーモデルの問題に遭遇します。一般に、すべてのエラーを保存できるわけではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Cats IOに組み込まれた固定エラータイプである「Throwable」と、ZIOでサポートされている多態性エラータイプの両方に当てはまります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のワンタイムエラーがある状況の例：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイナライザは例外をスローします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つの（落下する）効果が並列実行で結合されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レース状態での2つの（落下）効果。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中断から保護されたセクションを離れる前に、中断された効果が低下します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのエラーが保存されるわけではないため、ZIOは無料の半リング（抽象代数からの抽象化、ここではその知識は想定されていません）に基づいて「原因[E]」データ構造を提供します。すべての操作（落下または中断された効果のクリーニングを含む）の間、ZIOはエラーを「原因[E]」データ構造に集約します。このデータ構造はいつでも利用できます。その結果、ZIOは常にすべてのエラーを保存します。それらは常に利用可能であり、ビジネス要件の要求に応じて、ログに記録し、調査し、変換することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cats IOは、エラー情報が失われたモデルを選択しました。 ZIOは原因[E]を介して2つのエラーを接続しますが、Cats IOは、たとえば、発生したエラーに対して「e.printStackTrace（）」を呼び出すことによって、エラーメッセージの1つを「失います」。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、このコードの「ファイナライザ」のエラーは失われます。</font></font><br>
<br>
<pre><code class="scala hljs"><span class="hljs-type">IO</span>.raiseError(<span class="hljs-keyword">new</span> <span class="hljs-type">Error</span>(<span class="hljs-string">"Error 1"</span>)).guarantee(<span class="hljs-type">IO</span>.raiseError(<span class="hljs-keyword">new</span> <span class="hljs-type">Error</span>(<span class="hljs-string">"Error 2«)))</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エラー追跡へのこのアプローチは、影響の組み合わせによって発生するエラーのスペクトル全体をローカルで見つけて処理することができないことを意味します。</font><font style="vertical-align: inherit;">ZIOを使用すると、「Throwable」（または「IOExceptio」などの特定のサブタイプや別のカスタム例外階層）などのあらゆるタイプのエラーを使用できるため、プログラムの実行中にエラーが失われることがなくなります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.デッドロックのない非同期</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZIOとCats IOはどちらも、コールバックを使用してコードを取得し、エフェクトにラップできるコンストラクターを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この機能は、Cats EffectのAsyncパイプクラスを通じて提供され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="scala hljs">
<span class="hljs-keyword">val</span> effect: <span class="hljs-type">Task</span>[<span class="hljs-type">Data</span>] = 
  <span class="hljs-type">Async</span>[<span class="hljs-type">Task</span>].async(k =&gt; <font></font>
    getDataWithCallbacks(<font></font>
      onSuccess = v =&gt; k(<span class="hljs-type">Right</span>(v)),<font></font>
      onFailure = e =&gt; k(<span class="hljs-type">Left</span>(e))<font></font>
))<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、非同期エフェクトが作成されます。これは、実行されると、値が表示されるまで待機してから続行します。これはすべて、エフェクトのユーザーには明らかです。したがって、関数型プログラミングは非同期コードの開発にとって非常に魅力的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コールバックコードがエフェクトになるとすぐに、コールバック関数（ここでは「k」と呼ばれます）が呼び出されることに注意してください。このコールバック関数は、成功/エラー値で終了します。このコールバック関数が呼び出されると、エフェクトの実行（以前に一時停止されていた）が再開されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZIOは、エフェクトが特定の特別なコンテキスト、またはエフェクトがアタッチされた別のコンテキストに割り当てられていない場合、ランタイムスレッドプールでエフェクトが実行を再開することを保証します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cats IOは、コールバックスレッドへの影響を再開します。これらのオプションの違いはかなり深いです。コールバックを引き起こしているスレッドは、コールバックコードが永久に実行されることを期待していませんが、コントロールが戻る前にわずかな遅延を許可します。一方、Cats IOはそのような保証をまったく提供しません。呼び出しのスレッドである開始コールバックは、実行の制御が戻るときに不定の時間待機してフリーズする可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cats Effect（「Deferred」、「Semaphore」）の競合するデータ構造の初期バージョンは、呼び出しスレッドに制御を返さなかった効果を再開しました。その結果、デッドロックと壊れた実行スケジューラに関連する問題が発見されました。これらの問題はすべて見つかりましたが、Cats Effectの競合するデータ構造に対してのみ修正されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cats IOと同様のアプローチを使用するユーザーコードは、このような問題に遭遇します。そのようなタスクは非決定的であるため、実行時にエラーが発生することは非常にまれであり、デバッグと問題の検出が困難なプロセスになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZIOは、デフォルトでデッドロック保護と通常のタスクスケジューラを提供し、ユーザーにCats IOの動作を明示的に選択させます（たとえば、「Promise」で「unsafeRun」を使用すると、非同期の効果が再開されます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのケースに適したソリューションはなく、ZIOとCats IOはすべての状況を（さまざまな方法で）解決するのに十分な柔軟性を提供しますが、ZIOを選択すると、心配せずに「非同期」を使用することを意味し、問題のコードを「unsafeRun」に配置することを強制します。デッドロックを引き起こすことが知られている</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.未来と互換性がある</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Scala標準ライブラリの「Future」を使用することは、多数のコードベースにとって現実です。</font><font style="vertical-align: inherit;">ZIOには「fromFuture」メソッドが付属しており、既成の実行コンテキストを提供します。</font></font><br>
<br>
<pre><code class="scala hljs"><span class="hljs-type">ZIO</span>.fromFuture(<span class="hljs-keyword">implicit</span> ec =&gt;
<span class="hljs-comment">// Create some Future using `ec`:</span><font></font>
???<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッドを使用してFutureをエフェクトにラップすると、ZIOはFutureが実行される場所を設定でき、evalOnなどの他のメソッドはFutureを目的の実行コンテキストに正しく転送します。</font><font style="vertical-align: inherit;">Cats IOは、外部の "ExecutionContext"で作成された "Future"を受け入れます。</font><font style="vertical-align: inherit;">これは、Cats IOがevalOnまたはshiftメソッドの要件に従ってFutureの実行を移動できないことを意味します。</font><font style="vertical-align: inherit;">さらに、これは、Futureの実行コンテキストを決定することでユーザーに負担をかけます。つまり、選択範囲が狭く、別の環境になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
提供されたExecutionContextは無視できるため、ZIOはCats IO機能の合計として表すことができ、Futureとのよりスムーズで正確な対話を一般的なケースで保証しますが、依然として例外があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.ブロッキングIO</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドプール</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」で示したように</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">。</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ZIOのベストプラクティス</font></a><font style="vertical-align: inherit;">」では、サーバーアプリケーションの場合、最大の効率を得るには少なくとも2つの個別のプールが必要です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU /非同期効果の固定プール。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的、ブロッキングスレッドの数を増やす可能性があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
固定スレッドプールですべての効果を実行するという決定は、ある日デッドロックにつながりますが、動的プールですべての効果をトリガーすると、パフォーマンスが低下する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JVMでは、ZIOはブロッキング効果をサポートする2つの操作を提供します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ブロッキング（エフェクト）オペレーター。これは、必要に応じて変更できる適切なプリセットを持つブロッキングストリームのプールで特定のエフェクトの実行を切り替えます。</font></font></li>
<li>«effectBlocking(effect)» ,     &nbsp;  &nbsp; ,        .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
効果があり、それがブロッキングスレッドのプールで実行されることを確認する必要がある場合は、「ブロッキング」でラップできます。一方、ある種のコードをブロックする副作用でラップした場合は、「effectBlocking」でラップして、結合された深くて安全なZIO割り込み（可能な場合）の利点を得ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cats IOはより小さな機能コアを提供するため、同様の機能の実装をユーザーコード側に委任します。 「ブロッキング」機能を提供できるライブラリは存在しますが、それらは「evalOn」に基づいているため、ブロッキングスレッドがプールで実行されることを実際に保証することはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
経験豊富なユーザーは、カスタムスレッドプールをスレッドで構成したり（ZIOで実行できます）、これらの2つ以上のスレッドプールを作成したりできます（たとえば、レイテンシの低いイベントをディスパッチするためのスレッドプール）。ただし、これらの操作は、大多数のイベントに望ましいセマンティクスを提供します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9.無料の効果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くのScala関数型アプリケーションは、最終的に次の1つまたは2つのモナディック変換を使用します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ReaderT」/「Kleisli」。環境へのアクセスの効果を追加します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプされたエラーの効果を追加する「EitherT」（または「OptionT」、つまり「タイプ」がエラーのタイプである「EitherT」）</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このパターンは非常に包括的であるため、ライブラリ全体がどちらか一方を中心に開発されています（たとえば、http4sは「Kleisli」と「OptionT」を大量に使用しています）。 「エフェクトトーテーション」と呼ばれる高度な手法を使用して、ZIOは「リーダー」機能と「型付きエラー」機能の両方をZIOデータ型に直接提供します。すべてのユーザーが「リーダー」および「型付きエラー」のパターンを必要とするわけではないため、ZIOは一般的な状況をカバーする他のタイプも提供します。たとえば、「タスク[A]」では、「リーダー」と「タイプエラー」はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、ZIOはオーバーヘッドなしで、機能アプリケーションで最も人気のある2つの（二次）効果を提供できます。さらに、これらの効果をZIOで直接サポートすると、効果を実行するオーバーヘッドが簡素化され、より単純なコードを作成できるようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cats IOは主要な効果のみを提供します。</font><font style="vertical-align: inherit;">これは、「リーダー」または「型付きエラー」、あるいは「状態」、「ライター」、およびその他のタイプのクラスの通常の実装を必要とするユーザーが、モナディック変換の使用を開始する可能性が高いことを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZIOは、同等のエフェクトスタックを備えたCats IOの8倍の速さです。</font><font style="vertical-align: inherit;">オーバーヘッドの影響がアプリケーションのパフォーマンスに与える影響は多数の要因に依存しますが、パフォーマンスが高いと、Scalaの機能アプリケーションの数が増え、開発者は明確に定義された影響からアプリケーションを構築できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.マイクロカーネルアーキテクチャ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZIOはマイクロカーネルアーキテクチャを使用して、ランタイムからできるだけ多くの機能を絞り出し、ユーザーが自由に使用できるようにします。確かに、マイクロカーネルの部分自体は純粋に機能的なScalaで記述されていますが、それでも小さいコンポーネントが使用されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
元のZIOコアには約2,000行のコードが含まれていましたが、「型付きエラー」と環境を追加して冗長性を解放し、直交性を改善した後、マイクロカーネル全体が1つのファイルで375行を表します。現代のScalaエフェクトシステムの複雑さが増すにつれて、エラーの可能性も高まっています。これらのシステムがどのように機能するかを理解している人は世界中にほとんどいないため、潜在的なエラーや境界状況の可能性は非常に高くなっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
個人的に、私は次の理由でマイクロカーネルエフェクトシステムのファンです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小さなコードは簡単に検証できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラーや隠れた境界線のケースの余地が少なくなります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーの要求に応えるために、より安く、より速く、より信頼性の高いことができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい寄稿者は、カーネルサポートに参加する方が簡単だと感じています。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理論的には、モノリシックカーネルは非常に最適化できます。</font><font style="vertical-align: inherit;">ただし、オープンソース開発の自発的な性質のため、最適化のためのリソースは限られています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの制限により、小核の一部または小核全体を個別に最適化できます。</font><font style="vertical-align: inherit;">最初のオプションは特定のケースで良好なパフォーマンスを提供し、2番目のオプションは多くの点で優れています。</font><font style="vertical-align: inherit;">利用可能なすべてのZIOエフェクトシステムの中で、ランタイムは最小です。</font><font style="vertical-align: inherit;">Cats IOは2位ですが、その未亡人のランタイムはZIOを上回ります（カウントによっては3倍）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11.初心者に適しています</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZIOには、上級ユーザー向けの損失や簡素化なしに、新規ユーザーが簡単に入力できるようにするものがたくさんあります。 </font></font><br>
<br>
<ul>
<li> ,  : «ZIO. succeed»  «Applicative[F].pure», «zip»  «Apply[F].product», «ZIO.foreach»  «Traverse[F].traverse».<br>
</li>
<li>        (Cats, Cats Effect, Scalaz   &nbsp; ).</li>
<li> ,       (&nbsp; «Runtime»,      Cats Effect  -   Cats Effect). &nbsp;—        Cats IO.</li>
<li>   .</li>
<li>      &nbsp; . : "zip"/"zipPar", "ZIO.foreach"/"ZIO.foreachPar", "ZIO.succeed"/"ZIO.succeedLazy«. <br>
</li>
<li>  &nbsp;  ,    &nbsp;&nbsp;  «».   ZIO  &nbsp; IDE.</li>
<li> &nbsp;   Scala &nbsp;ZIO  : «ZIO.fromFuture», «ZIO.fromOption», «ZIO.fromEither», «ZIO.fromTry».</li>
<li>        «».</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おもしろいですが、機能的なScalaの経験がなく、外部からの支援なしにZIOを使用してプロトタイプを正常に作成した人たちに会わなければなりませんでした。</font><font style="vertical-align: inherit;">Cats IOは、ほとんどの機能、名前、および型推論の決定をCatsに転送することを選択しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、リファレンス実装が小さく保たれますが、関数型プログラミングの学習を始めたばかりの開発者のエントリ時間が増加し、よく知られている便利な問題（検索、名前、意味、型推論の容易さ）で表されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12.便利</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZIOは、非同期で競争力のあるアプリケーションを構築するための優れたツールセットを提供する小さなクロスプラットフォームパッケージです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このキットに含まれるもの：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ref、Promise、Queue、Semaphore、ストリーミングファイル/ソケット/データ読み取り用の小さなStreamなど、最も重要な競合データ構造。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STM。これは、複合、非同期、競合、および割り込み可能なデータ構造を構築するために使用できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複合繰り返しを提供する「スケジュール」。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほとんどすべてのアプリケーションで使用される、テスト済みの「クロック」、「ランダム」、「コンソール」、および「システム」サービス。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最も一般的なケースをカバーするエフェクトタイプには、他にも多くの方法があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リファレンス実装のため、Cats IOにはそのようなボーナスはありません。</font><font style="vertical-align: inherit;">このソリューションにより、Cats IOはより軽量になりますが、サードパーティの依存関係（可能な場合）を追加したり、不足しているコードをユーザーが作成したりする代償が伴います。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cats EffectライブラリーはScalaエコシステムに多くの素晴らしいことをもたらし、現在一緒に機能する多くのライブラリーを生み出しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cats Effectを使用するアプリケーション開発者は、Cats Effectライブラリで使用する主な効果を選択することが困難になりました：Cats IO、Monix、Zio。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者は常に、特定の状況で最適なものを選択します。しかし、この投稿で説明されている設計上の決定の一部が気に入った場合は、ぜひご覧ください。ZIOとCats Effectは、キラーコンビネーションを形成します。</font></font><br>
<br>
<blockquote>   &nbsp; &nbsp;  &nbsp;Scala     &nbsp;—    . &nbsp;  &nbsp;   &nbsp; ,   Scala. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a> ScalaConf  , &nbsp; 18&nbsp;  &nbsp; , &nbsp;&nbsp;  John A&nbsp;De&nbsp;Goes  .</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja472372/index.html">Androidオートメーション 初めてのエスプレッソテストを作成するための超簡単ガイド</a></li>
<li><a href="../ja472374/index.html">サーバーをアイスランドに移動した理由</a></li>
<li><a href="../ja472378/index.html">フラッシュの信頼性：予想と予想外。パート2。USENIX協会のXIV会議。ファイルストレージテクノロジー</a></li>
<li><a href="../ja472380/index.html">MIRO-オープンな屋内ロボットプラットフォーム</a></li>
<li><a href="../ja472384/index.html">開発者の観点から見たAndroidのアップデート</a></li>
<li><a href="../ja472388/index.html">ウォルマートがアマゾンの価格戦争を宣言</a></li>
<li><a href="../ja472392/index.html">オーディオカセットの上昇、下降、および可能な復帰-神話に対処し、状況の概要を説明します</a></li>
<li><a href="../ja472394/index.html">オフショアの石油およびガスに対する人工知能の影響の評価</a></li>
<li><a href="../ja472396/index.html">Columnstoreで4秒で世界一周（パート1）</a></li>
<li><a href="../ja472402/index.html">RTMPビデオ通話ストリーミング</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>