<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö£üèø ü§õüèª üéç Flutter under the hood üë©üèæ‚Äçü§ù‚Äçüë®üèº üïäÔ∏è üè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello everyone! My name is Mikhail Zotiev, I work as a Flutter developer at Surf. I, like probably the majority of other developers who work with Flut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Flutter under the hood</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/501862/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello everyone! My name is Mikhail Zotiev, I work as a Flutter developer at Surf. I, like probably the majority of other developers who work with Flutter, most of all like how easy it is to create beautiful and convenient applications with its help. It takes very little time to get into Flutter development. I recently worked in game dev, and now I‚Äôve completely switched to cross-platform mobile development on Flutter.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is the simplicity? </font><font style="vertical-align: inherit;">With a dozen basic widgets, you can build pretty decent user interfaces. </font><font style="vertical-align: inherit;">And over time, when the baggage used is quite decent, it‚Äôs unlikely that some kind of task will put you at a standstill: be it an unusual design or sophisticated animation. </font><font style="vertical-align: inherit;">And the most interesting - most likely you can use it without even thinking about the question: ‚ÄúHow does it work at all?‚Äù </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since Flutter has open source, I decided to figure out what's under the hood (on the Dart side of the Force) and share it with you.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lg/ln/q6/lglnq6t8sbc8gq-emifhx1dxjwu.png"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We all have heard the phrase from the framework development team more than once: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Everything in Flutter is widgets</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><i><font style="vertical-align: inherit;">" </font></i><font style="vertical-align: inherit;">Let's see if this is really so. </font><font style="vertical-align: inherit;">To do this, we turn to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">(hereinafter - the widget) and begin to gradually familiarize ourselves with the contents. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first thing we will read in the documentation for the class:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Describes the configuration for an [Element].</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It turns out that the widget itself is just a description of some </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Element</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (hereinafter - the element).</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widgets are the central class hierarchy in the Flutter framework. </font><font style="vertical-align: inherit;">A widget is an immutable description of part of a user interface. </font><font style="vertical-align: inherit;">Widgets can be inflated into elements, which manage the underlying render tree.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To summarize, the phrase </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Everything in Flutter is a widget"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the minimum level of understanding how everything is arranged in order to use Flutter. </font><font style="vertical-align: inherit;">The widget is the center class in the Flutter hierarchy. </font><font style="vertical-align: inherit;">At the same time, there are many additional mechanisms around it that help the framework cope with its task. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we learned a few more facts:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">widget - an immutable description of a part of the user interface;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the widget is associated with some advanced view called an element; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an element controls some entity of the render tree.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You must have noticed a strange thing. </font><font style="vertical-align: inherit;">The user interface and immutability fit very poorly together, I would even say that these are completely incompatible concepts. </font><font style="vertical-align: inherit;">But we will return to this when a more complete picture of the Flutter world‚Äôs device will emerge, but for now, we‚Äôll continue to get acquainted with the widget‚Äôs documentation.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widgets themselves have no mutable state (all their fields must be final). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you wish to associate mutable state with a widget, consider using a [StatefulWidget], which creates a [State] object (via [StatefulWidget.createState]) whenever it is inflated into an element and incorporated into the tree.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This paragraph complements the first paragraph a bit: if we need a mutable configuration, we use the special </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">State</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entity </font><font style="vertical-align: inherit;">(hereinafter referred to as the state), which describes the current state of this widget. </font><font style="vertical-align: inherit;">However, the state is not associated with the widget, but with its elemental representation.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A given widget can be included in the tree zero or more times. </font><font style="vertical-align: inherit;">In particular a given widget can be placed in the tree multiple times. </font><font style="vertical-align: inherit;">Each time a widget is placed in the tree, it is inflated into an [Element], which means a widget that is incorporated into the tree multiple times will be inflated multiple times.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same widget can be included in the widget tree many times, or not be included at all. </font><font style="vertical-align: inherit;">But every time a widget is included in the widget tree, an element is mapped to it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, at this stage, the widgets are almost done, let's summarize:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">widget - the central class of the hierarchy;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">widget is some configuration; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">widget - an immutable description of a part of the user interface; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the widget is associated with an element that controls rendering in some way; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the widget‚Äôs changing state can be described by some entity, but it is connected not with the widget, but with the element that represents this widget.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Element</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From what we learned, the question begs, ‚ÄúWhat are these elements that govern everything?‚Äù </font><font style="vertical-align: inherit;">Do the same - open the documentation for the Element class.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An instantiation of a [Widget] at a particular location in the tree.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An element is some representation of a widget in a specific place in a tree.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widgets describe how to configure a subtree but the same widget can be used to configure multiple subtrees simultaneously because widgets are immutable. </font><font style="vertical-align: inherit;">An [Element] represents the use of a widget to configure a specific location in the tree. </font><font style="vertical-align: inherit;">Over time, the widget associated with a given element can change, for example, if the parent widget rebuilds and creates a new widget for this location.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The widget describes the configuration of some part of the user interface, but as we already know, the same widget can be used in different places of the tree. Each such place will be represented by a corresponding element. But over time, the widget that is associated with the item may change. This means that the elements are more tenacious and continue to be used, only updating their connections. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a fairly rational decision. As we have already defined above, widgets are an immutable configuration that simply describes a specific part of the interface, which means they must be very lightweight. And the elements in the area of ‚Äã‚Äãwhich control is much more heavy, but they are not recreated unnecessarily. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To understand how this is done, consider the life cycle of an element:</font></font><br>
<br>
<ul>
<li>     Widget.createElement    ,     .</li>
<li>   mount        .              .</li>
<li>       .</li>
<li>   ,    (,    ),     .       runtimeType  key,     .   ,     ,           .</li>
<li> ,       ,    ,             ,      (  deactivate).</li>
<li>   ,     .           ,       ,   (unmount),           .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you re-include elements in the tree, for example, if the element or its ancestors have a global key, it will be removed from the list of inactive elements, the activate method will be called, and the rendered object associated with this element will again be embedded in the render tree. </font><font style="vertical-align: inherit;">This means that the item should appear on the screen again.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the class declaration, we see that the element implements the BuildContext interface. </font><font style="vertical-align: inherit;">A BuildContext is something that controls the position of a widget in a widget tree, as follows from its documentation. </font><font style="vertical-align: inherit;">Almost exactly matches the item description. </font><font style="vertical-align: inherit;">This interface is used to avoid direct manipulation of the element, but at the same time give access to the necessary context methods. </font><font style="vertical-align: inherit;">For example, findRenderObject, which allows you to find the render tree object corresponding to this element.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderderbject</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It remains to deal with the last link of this triad - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RenderObject</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . As the name implies, this is an object of the visualization tree. It has a parent object, as well as a data field that the parent object uses to store specific information regarding this object itself, for example, its position. This object is responsible for the implementation of basic rendering and layout protocols.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RenderObject does not limit the model of using child objects: there may be none, one or many. </font><font style="vertical-align: inherit;">Also, the positioning system is not limited to: the Cartesian system, polar coordinates, all this and much more is available for use. </font><font style="vertical-align: inherit;">There are no restrictions on the use of location protocols: adjusting the width or height, limiting the size, specifying the size and location of the parent or, if necessary, using the data of the parent object.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flutter World Picture</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's try to build a big picture of how everything works together. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We already noted above, the widget is an immutable description, but the user interface is not at all static. </font><font style="vertical-align: inherit;">This discrepancy is removed by dividing into 3 levels of objects and the division of responsibility zones.</font></font><br>
<br>
<ul>
<li> ,          . </li>
<li> ,               . </li>
<li>  ,   ‚Äî ,     .</li>
</ul><br>
<img src="https://habrastorage.org/webt/j_/n_/og/j_n_ogui1a0iawbuoq5vxclsnne.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at how these trees look with a simple example: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/u7/0o/wk/u70owkgirs6krcos85rwn-acli8.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, we have some StatelessWidget wrapped in a Padding widget and containing text inside. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's put ourselves in place of Flutter - we were given this widget tree. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúHey, Padding, I need your element‚Äù</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Padding: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúOf course, hold SingleChildRenderObjectElement‚Äù</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/jj/u7/zn/jju7znfat7skocfex74adc4cu7o.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúElement, here is your place, settle down‚Äù</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
SingleChildRenderObjectElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúGuys, everything‚Äôs ok, but I need RenderObject‚Äù</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúPadding, like to draw you at all? ‚Äù</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Padding: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúHold it, RenderPadding‚Äù</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
SingleChildRenderObjectElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúGreat, get to work‚Äù</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/zk/ty/se/zktyse7pgo6jdd6x7impyivfhy0.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter:</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúSo who is next?‚Äù StatelessWidget, now you let the element ¬ª</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
StatelessWidget: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬´ Here StatelessElement ¬ª</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬´ StatelessElement, you will be in subjection to SingleChildRenderObjectElement, here's the place, embarking ¬ª</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
StatelessElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬´ OK ¬ª</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/7w/tb/ke/7wtbkebtfn_xeq1ieqxqbarpkro.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬´ the RichText, elementik Present, please ¬ª</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
the RichText gives MultiChildRenderObjectElement </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúMultiChildRenderObjectElement, here you go, get started‚Äù</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
MultiChildRenderObjectElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúI need a render for work‚Äù</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúRichText, we need a render object‚Äù</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
RichText: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúHere is a RenderParagraph‚Äù</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter:</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúRenderParagraph you will receive instructions RenderPadding, and you will control MultiChildRenderObjectElement‚Äù</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
MultiChildRenderObjectElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúNow everything is OK, I'm ready‚Äù</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/s4/24/fn/s424fnivo4j2tb4sv9pcirmxov0.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Surely you will ask a legitimate question: ‚ÄúWhere is the rendering object for StatelessWidget, why is it not there, we decided above that the elements bind configurations with display? " </font><font style="vertical-align: inherit;">Let's pay attention to the basic implementation of the mount method, which was discussed in this section of the life cycle description.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">void</span> mount(Element parent, dynamic newSlot) {<font></font>
    assert(_debugLifecycleState == _ElementLifecycle.initial);<font></font>
    assert(widget != <span class="hljs-literal">null</span>);<font></font>
    assert(_parent == <span class="hljs-literal">null</span>);<font></font>
    assert(parent == <span class="hljs-literal">null</span> || parent._debugLifecycleState == _ElementLifecycle.active);<font></font>
    assert(slot == <span class="hljs-literal">null</span>);<font></font>
    assert(depth == <span class="hljs-literal">null</span>);<font></font>
    assert(!_active);<font></font>
    _parent = parent;<font></font>
    _slot = newSlot;<font></font>
    _depth = _parent != <span class="hljs-literal">null</span> ? _parent.depth + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<font></font>
    _active = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>)<font></font>
        _owner = parent.owner;<font></font>
    <span class="hljs-keyword">if</span> (widget.key is GlobalKey) {<font></font>
        final GlobalKey key = widget.key;<font></font>
        key._register(<span class="hljs-keyword">this</span>);<font></font>
    }<font></font>
    _updateInheritance();<font></font>
    assert(() {<font></font>
        _debugLifecycleState = _ElementLifecycle.active;<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }());<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will not see in it the creation of a rendering object. </font><font style="vertical-align: inherit;">But the element implements a BuildContext, which has a findRenderObject visualization object search method, which will lead us to the following getter:</font></font><br>
<br>
<pre><code class="javascript hljs">RenderObject get renderObject {<font></font>
    RenderObject result;<font></font>
    <span class="hljs-keyword">void</span> visit(Element element) {<font></font>
        assert(result == <span class="hljs-literal">null</span>); 
        <span class="hljs-keyword">if</span> (element is RenderObjectElement)<font></font>
            result = element.renderObject;<font></font>
        <span class="hljs-keyword">else</span><font></font>
            element.visitChildren(visit);<font></font>
    }<font></font>
    visit(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> result;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the basic case, an element may not create a rendering object; only RenderObjectElement and its descendants are required to do this, however, in this case, an element at some nesting level must have a child element that has a rendering object. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It would seem why all these difficulties. As many as 3 trees, different areas of responsibility, etc. The answer is quite simple - this is where Flutter's performance is built. Widgets are immutable configurations, therefore, they are often recreated, but at the same time they are quite lightweight, which does not affect performance. But Flutter is trying to reuse heavy elements as much as possible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider an example. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Text in the middle of the screen. The code in this case will look something like this:</font></font></i><br>
<br>
<pre><code class="javascript hljs">body: Center(<font></font>
    child: Text(‚ÄúHello world!‚Äù)<font></font>
),</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, the widget tree will look like this: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lc/wt/fa/lcwtfazdhkpaprcu9tqvhssvck4.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After Flutter builds all 3 trees, we get the following picture: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uc/vx/ph/ucvxphu5r2ds-6_kmoizgyoczo8.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What happens if we change the text that we are going to display? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_u/8b/do/_u8bdowthfzx9jshpbprfnpj1ai.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We now have a new widget tree. Above we talked about the maximum possible reuse of elements. Take a look at the Widget class method, under the talking name </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">canUpdate</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">static</span> bool canUpdate(Widget oldWidget, Widget newWidget) {
    <span class="hljs-keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType &amp;&amp; oldWidget.key == newWidget.key;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We check the type of the previous widget and the new one, as well as their keys. If they are the same, then there is no need to change the item. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, before the upgrade, the first element is Center, after the upgrade, also Center. Both have no keys, a complete coincidence. We can update the item link to a new widget. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/he/tr/s4/hetrs4cgzrimhibqeilfoja5xzi.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But in addition to the type and key, the widget is a description and configuration, and the values ‚Äã‚Äãof the parameters that are necessary for the display could change. That is why the element, after updating the link to the widget, should initiate updates to the rendering object. In the case of Center, nothing has changed, and we continue to compare further. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Once again, the type and key tell us that it makes no sense to recreate the element. The text is a descendant of StatelessWidget; it does not have a direct display object.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dp/yy/6m/dpyy6mckv6cddryb0_yu5asy_uy.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go to RichText. The widget also has not changed its type; there are no discrepancies in the keys. The item updates its association with the new widget. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hw/vh/95/hwvh952jekjwhudyj6czju3hq6a.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The connection is updated, it remains only to update the properties. As a result, RenderParagraph will display the new text value. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lv/_p/g-/lv_pg-n6wlmcmlunokumb60nqw0.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And as soon as the time comes for the next drawing frame, we will see the result we expect. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thanks to this kind of work, Flutter achieves such high performance. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The example above describes the case when the widget structure itself has not changed. But what happens if the structure changes? Flutter, of course, will continue to try to maximize the use of existing objects, as we understood from the life cycle description, but new elements will be created for all new widgets, and old and more unnecessary ones will be deleted at the end of the frame.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at a couple of examples. </font><font style="vertical-align: inherit;">And in order to make sure of the above, we use the Android Studio tool - Flutter Inspector.</font></font><br>
<br>
<pre><code class="javascript hljs">@override<font></font>
Wid<span class="hljs-keyword">get</span> <span class="hljs-title">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> Scaffold(<font></font>
        body: Center(<font></font>
            child: _isFirst ? first() : second(),<font></font>
        ),<font></font>
        <span class="hljs-attr">floatingActionButton</span>: FloatingActionButton(<font></font>
            child: Text(<span class="hljs-string">"Switch"</span>),
            <span class="hljs-attr">onPressed</span>: () {<font></font>
                setState(() {<font></font>
                    _isFirst = !_isFirst;<font></font>
                });<font></font>
            },<font></font>
        ),<font></font>
    );<font></font>
}<font></font>
<font></font>
Wid<span class="hljs-keyword">get</span> <span class="hljs-title">first</span>() =&gt; <span class="hljs-title">Row</span>(<span class="hljs-params">
    mainAxisAlignment: MainAxisAlignment.center,
    children: &lt;Widget&gt;[
        Text(
            <span class="hljs-string">"test"</span>,
            style: TextStyle(fontSize: <span class="hljs-number">25</span></span>),<font></font>
        ),<font></font>
        <span class="hljs-title">SizedBox</span>(<span class="hljs-params">
            width: <span class="hljs-number">5</span>,
        </span>),
        <span class="hljs-title">Icon</span>(<span class="hljs-params">
            Icons.error,
        </span>),<font></font>
    ],<font></font>
);<font></font>
<font></font>
<span class="hljs-title">Widget</span> <span class="hljs-title">second</span>() =&gt; <span class="hljs-title">Row</span>(<span class="hljs-params">
    mainAxisAlignment: MainAxisAlignment.center,
    children: &lt;Widget&gt;[
        Text(
            <span class="hljs-string">"one more test"</span>,
            style: TextStyle(fontSize: <span class="hljs-number">25</span></span>),<font></font>
        ),<font></font>
        <span class="hljs-title">Padding</span>(<span class="hljs-params">
            padding: EdgeInsets.only(left: <span class="hljs-number">5</span></span>),<font></font>
        ),<font></font>
        <span class="hljs-title">Icon</span>(<span class="hljs-params">
            Icons.error,
        </span>),<font></font>
    ],<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, by clicking on the button, one of the widgets will change. </font><font style="vertical-align: inherit;">Let's see what the inspector shows us. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wi/vt/vt/wivtvtojhv4uq3l7ouoje3le-u0.png" alt="image"><br>
<br>
<img src="https://habrastorage.org/webt/f4/rb/0a/f4rb0avn7pombux2ct6pkap2edi.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As we can see, Flutter recreated the render only for Padding, the rest just reused. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider 1 more option in which the structure changes in a more global way - we change the levels of nesting.</font></font><br>
<br>
<pre><code class="javascript hljs">Wid<span class="hljs-keyword">get</span> <span class="hljs-title">second</span>() =&gt; <span class="hljs-title">Container</span>(<span class="hljs-params">child: first(</span>),);</code></pre><br>
<img src="https://habrastorage.org/webt/yt/8i/gs/yt8igsxt3r3b-ofhkrlcyjaqryc.png" alt="image"><br>
<br>
<img src="https://habrastorage.org/webt/j7/na/qw/j7naqwq6060sh-tw_atxna_umpa.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despite the fact that the tree did not visually change at all, the elements and objects of the rendering tree were recreated. </font><font style="vertical-align: inherit;">This happened because Flutter compares by level (in this case, it doesn‚Äôt matter that most of the tree has not changed), sifting of this part took place at the time of comparing Container and Row. </font><font style="vertical-align: inherit;">However, one can get out of this situation. </font><font style="vertical-align: inherit;">This will help us GlobalKey. </font><font style="vertical-align: inherit;">Add such a key for Row.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> _key = GlobalKey(debugLabel: <span class="hljs-string">"testLabel"</span>);<font></font>
<font></font>
Wid<span class="hljs-keyword">get</span> <span class="hljs-title">first</span>() =&gt; <span class="hljs-title">Row</span>(<span class="hljs-params">
    key: _key,
    ‚Ä¶
</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/gg/jp/zj/ggjpzjlpox-ijhgtwxy-i6rvcsk.png" alt="image"><br>
<br>
<img src="https://habrastorage.org/webt/zy/br/zy/zybrzywy-_ixs_apl7j1fiqsrco.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As soon as we told Flutter that the part could be reused, he took advantage of the opportunity.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We got a little closer acquainted with Flutter magic and now we know that it is not only in widgets. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutter is a well-thought out well-coordinated mechanism with its own hierarchy, areas of responsibility, with which you can create not only beautiful, but also productive applications. </font><font style="vertical-align: inherit;">Of course, we have examined only a small, albeit rather important part of its device, so we will continue to analyze various aspects of the framework‚Äôs internal work in future articles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I hope the information in this article is helpful in understanding how Flutter works internally and helps you find elegant and productive solutions during development. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thank you for the attention!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resources</font></font></h4><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flutter </font></font></i><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"How Flutter renders Widgets" by Andrew Fitz Gibbon, Matt Sullivan</font></font></i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en501850/index.html">We disassemble EM-algorithm into small bricks</a></li>
<li><a href="../en501854/index.html">How to quit programming and start performing</a></li>
<li><a href="../en501856/index.html">Tarantool: Analyst Look</a></li>
<li><a href="../en501858/index.html">Putting all the dots on the "psi"</a></li>
<li><a href="../en501860/index.html">May 15 RU-Center may add you a paid service without your participation</a></li>
<li><a href="../en501864/index.html">Assistant or inspector: for whom is the robot calling?</a></li>
<li><a href="../en501866/index.html">How many jobs robots will destroy</a></li>
<li><a href="../en501868/index.html">How not to let the accountant throw himself or We transfer 1C to the cloud. Step-by-step instruction</a></li>
<li><a href="../en501870/index.html">Maximum number of values ‚Äã‚Äãin enum Part II</a></li>
<li><a href="../en501872/index.html">Place of study in cybernetic systems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>