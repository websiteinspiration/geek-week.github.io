<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎤 🤭 ℹ️ メモリアロケータ 🌼 👌🏽 🏇🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="みなさん、こんにちは！少し前まで、アロケータとメモリ割り当てアルゴリズム、およびその後の実際のアプリケーションについて非常に綿密な調査を行った後、私はそれらをできるだけ詳細に説明する記事を書くというアイデアを思いつきました。現在このネットワークに関する情報源は非常に少なく、特にロシア語圏ではこの問題...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>メモリアロケータ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505632/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">みなさん、こんにちは！</font><font style="vertical-align: inherit;">少し前まで、アロケータとメモリ割り当てアルゴリズム、およびその後の実際のアプリケーションについて非常に綿密な調査を行った後、私はそれらをできるだけ詳細に説明する記事を書くというアイデアを思いつきました。</font><font style="vertical-align: inherit;">現在このネットワークに関する情報源は非常に少なく、特にロシア語圏ではこの問題に専念しているため、このトピックは非常に人気があると思います。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">序文</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、誰かが最初に「アロケータ」、「メモリ割り当てアルゴリズム」という用語を聞いて、なぜこれがすべて必要なのか理解していない場合は、この記事を読む前に、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースに</font><font style="vertical-align: inherit;">慣れることをお勧めします</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この記事では、標準のメモリアロケータに存在する問題、および標準のメモリアロケータに加えて、他のメモリアロケーションの方法を使用する価値がある目的について十分に説明しています。</font><font style="vertical-align: inherit;">ここでは、分散アルゴリズム自体についてのみ説明します。もちろん、最後に、標準C ++コンテナーで問題なく使用できるアロケーターの1つの実装を提供します。</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基礎</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アロケーターで実行できる5つの主な操作が概念的に強調表示されています（すべてのアロケーターがこのインターフェイスに明示的に対応できるわけではないことに注意したいと思います）。</font></font><br>
<br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">create-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アロケータを作成し、一定量のメモリを割り当てます。</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allocate-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アロケータが制御するメモリ領域から特定のサイズのブロックを選択します。</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deallocate-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のブロックを解放します。</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フリー</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -アロケータメモリから解放し、すべての割り当てられたブロックを（アロケータに割り当てられたメモリが解放されていません）。</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破壊</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -アロケータに割り当てられたメモリの後続のリリースでアロケータを破壊します。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形アロケーター</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
線形アロケータ。これも「線形」です。これはアロケータの最も単純なタイプです。アイデアは、割り当てられたアロケータのメモリブロックの先頭へのポインタを保存し、アロケータからの割り当てが完了するたびに移動する必要がある別のポインタまたは数値表現を使用することです。このアロケーターでは、すべての要素が順番に挿入されるため（空間的な局所性）、内部の断片化が最小限に抑えられ、それらの間の唯一の断片化は整列です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、このアロケータがどのように機能するかが詳細に明確に示されるいくつかの例を検討することを提案します。 14バイトに等しいメモリのブロックを取り、それをアロケータの制御に渡します。下の図からわかるように、メモリの先頭へのポインタ（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、2つのポインタ、または合計（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">end</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）と使用済み（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）のメモリサイズ</font><font style="vertical-align: inherit;">に関する情報を含む2つの数値表現も格納します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/aa/wg/vgaawgiqzerseegtgqvk0qbjhus.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アロケータが4バイトのメモリを割り当てる要求を受け取ったとします。</font><font style="vertical-align: inherit;">このリクエストの実行に対するアロケータのアクションは次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">割り当てるのに十分なメモリがあるかどうかを確認します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在使用されているポインタを保存します。これは、アロケータから割り当てられたメモリのブロックへのポインタとして後でユーザーに与えられます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用済みのポインタを、割り当てられたメモリブロックのサイズに等しい量だけシフトします。</font><font style="vertical-align: inherit;">4バイトずつ。</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/wp/3q/_r/wp3q_r2dp-ywsaou93vzk8zhqkk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、たとえば、要求は8バイトの割り当てを要求するため、割り当てられたメモリブロックのサイズに関係なく、アロケータのアクションはまったく同じになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/di/g4/ih/dig4ihecjl8qfasqqonhdqtt2lm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、ここではもう少し興味深いものになります。たとえば、要求が1バイトのみを割り当てるようになり、メモリ内のブロックを整列させたくない場合（たとえば、2、4の倍数であるアドレス）、アロケータのアクションはまったく同じままです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vz/x_/cc/vzx_cc45oildurtaxdyi7n9fi7i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、特定のアラインメント（たとえば、2の倍数のアドレスのアラインメント）を使用してメモリブロックを割り当てる必要がある場合、アロケータのアクションはわずかに変化します。これは実装の点では変更されませんが、データ自体が1バイトのボリュームに等しいことに加えて、アロケーターのメモリから1バイトを追加して整列のために取得しますが、これには意味がありません。これはまさに、線形アロケータ内のメモリの最小の断片化です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jx/xg/pz/jxxgpzvrvs9nhyodrphmi1xg1sy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
素晴らしい、今がメモリの解放について話す時です。前述のように、このタイプのアロケータは、特定のメモリブロックの選択的な解放をサポートしていません。つまり</font><font style="vertical-align: inherit;">、たとえば</font><b><font style="vertical-align: inherit;">0xFFAA00</font></b><font style="vertical-align: inherit;">へのポインターを持つ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc / free</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">との微妙な類似点を描く場合</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、このメモリブロックを解放できますが、線形アロケータではこれを行うことができません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mj/es/_0/mjes_04nsdmq3bfiolwehoxwdfk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちにできることは、アロケーター内で占有されているすべてのメモリを解放し、それが完全に空であるかのようにそれを使い続けることです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/aa/wg/vgaawgiqzerseegtgqvk0qbjhus.png"><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プールアロケータ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロックアロケーターのアイデアは、メモリの大きな部分を</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じサイズの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小さな部分に分割すること</font><font style="vertical-align: inherit;">です。中核としては、非常にシンプルなアロケーターでもあります。割り当てが要求されると、固定サイズの空きメモリの場所の1つを返すだけであり、解放が要求されると、将来使用するためにこのメモリ領域を保存するだけです。したがって、分散は非常に速く、断片化はまだ非常に小さいです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、線形アロケーターと同様に、それがどのように機能するかをより詳細に理解するために、例とともにすべてを検討することを提案します。そのため、12バイトに等しいメモリブロックを取得して、アロケーターの制御に割り当てます。下の写真からわかるように、先頭へのポインタ（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）および</font><font style="vertical-align: inherit;">アロケータによって制御されるメモリ</font><font style="vertical-align: inherit;">の終了（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">end</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、</font><font style="vertical-align: inherit;">および</font><font style="vertical-align: inherit;">アロケータ内の空きブロックのアドレスの</font><font style="vertical-align: inherit;">リスト（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freeblocks</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。ブロックがビジーまたはフリーのデータを格納する手段として、ブール値の配列など、多くのツールを使用できますが、この概念を最も簡単かつ明確に特徴づけているため、単純に接続されたリストを選択することにしました（ちなみに、リストのリンクはメモリの空きブロックに保存できるため、メモリの追加コストを削減できます）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/co/6s/5o/co6s5o7c7ufuvofrrb1oqwke8vy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リクエストがメモリの1ブロックを割り当てるようになった場合、アロケータのアクションは非常に原始的です。まず、空きブロックのリストにリンクがあるかどうかを確認します。リンクがない場合は、アロケータのメモリがすでに不足していると推測するのは難しくありません。そこに少なくとも1つのリンクがある場合、リストのルートまたはテール（この実装ではテールリンクが指定されています）リンクを取り出し、そのアドレスをユーザーに提供します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uc/j_/44/ucj_44gjfi99_jf4whquo4sra78.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のメモリブロックの割り当てが要求されると、アロケータは同じ方法で同じアクションを順番に実行します（前のステップで説明）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ri/qc/zy/riqczyaeceqtxdshywd0py4r0nw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロックの解放に関しては、解放の要求が到着した場合、アロケータはこのアドレスを単純に接続されたリストのいずれかの端に追加するだけです。たとえば、アロケータのメモリアドレスと一致しないアドレス（たとえば、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xEFAB12</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">が</font><b><font style="vertical-align: inherit;">解放さ</font></b><font style="vertical-align: inherit;">れるブロックのアドレスに</font><font style="vertical-align: inherit;">なる場合があることに注意してください。そうすると、私たちに属していないメモリをユーザーに与えることができます（もちろん、これは未定義の動作につながるか、非常に運が良ければプログラムをクラッシュさせるだけです）。この考えられる問題を回避するには、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開始</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">終了</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">だけ</font><font style="vertical-align: inherit;">を使用します。これにより、解放操作の要求中にユーザーがアドレスを間違えたかどうかを確認できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/0n/ed/gd0nedbx2nlhsrxggnymb42keey.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アロケータが制御しないメモリを超えるだけでなく、別の問題が発生する可能性があります。</font><font style="vertical-align: inherit;">ユーザーは、アロケーターのメモリ領域にあるすべてのアドレスを解放する要求を出すことができますが、どのブロックの開始アドレスとも等しくありません</font><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、アドレス</font><b><font style="vertical-align: inherit;">0xFFAA07の</font></b><font style="vertical-align: inherit;">ブロックがあるとします</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">もちろん、この操作は未定義の動作につながります。</font><font style="vertical-align: inherit;">ユーザーがすべてを正しく実行しているかどうかをさらに確認する必要がある場合は、これを追跡することができます。</font><font style="vertical-align: inherit;">これを追跡するには、たとえば、アドレスと占有ブロックも格納する、またはアロケーター内のブロックサイズの多様性についてアドレスをチェックするなど、多くの解決策があります（すべては、想像力と、アロケーターが使用される特定の状況に依存します）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3u/mn/hw/3umnhwagefbl_eysi3zl6yhu9be.png"><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタックアロケーター</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、これは、スタックのようにメモリを管理できる線形アロケータのスマートな進化です。すべてが以前と同じです。「ヘッダー」ブロック（以下、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘッダー</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として使用されます</font><font style="vertical-align: inherit;">）を含む</font><font style="vertical-align: inherit;">ポインターを</font><font style="vertical-align: inherit;">現在のメモリアドレス</font><font style="vertical-align: inherit;">に保存し、</font><font style="vertical-align: inherit;">割り当てごとに前方に移動します。線形アロケータとは異なり、それを戻すこともできます。つまり、線形アロケータではサポートされていない割り当て解除操作を実行します。以前と同様に、空間的な局所性の原則は保持され、断片化は依然として最小限です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
14バイトの同じメモリブロックを持つすべての例を検討することを提案します。線形アロケータと同様に、メモリの先頭（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）とend（</font><i><font style="vertical-align: inherit;">end</font></i><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">へのポインタも格納します</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、および使用済みメモリの末尾へのポインタ（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ba/sb/qv/basbqv8yj_v1sijo_td54pa472k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリ割り当ての要求が到着すると、ユーザーが要求した特定の量のメモリを割り当てることに加えて、さらにヘッダーを割り当てます（ユーザーはどのようにも操作しません）。割り当てられたバイト数に関する情報を保存します（この例では、ヘッダーサイズは2バイト）。たとえば、2バイトの割り当て要求を受け取った場合、アロケータの状態は下の図とまったく同じになります。ユーザーには見出しへのポインタは与えられないが、見出しの直後のブロックへのポインタが与えられることに注意することが重要です。つまり、この例では、これはアドレス</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFAA02の</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロック</font><b><font style="vertical-align: inherit;">です</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/qb/q2/bgqbq2fei1egpmowdnmz9vciplo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様の状況は、たとえば、6バイトの割り当ての場合です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/up/pf/x_/uppfx_dpultvroggfr2rvy7lxhc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、このリリースでは、すべてがもう少し興味深いものになっています（前述のように、メモリの割り当てと解放は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LIFO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズムを使用した場合にのみ可能です</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">最初に、ユーザーが解放するように要求するポインターから、ヘッダーのサイズを差し引き、次に値を逆参照する必要があります。その後、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用された</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポインター</font><font style="vertical-align: inherit;">をヘッダーのサイズとヘッダーから取得したブロックのサイズに移動します。</font><font style="vertical-align: inherit;">ここでは、ブロックアロケーターと同様に、「ランダムな」メモリブロックを解放する状況が発生する可能性があり、これも未定義の動作につながります。</font><font style="vertical-align: inherit;">アロケーターを追加のチェックで補足するかどうかは、すべての人の責任です。</font><font style="vertical-align: inherit;">最も重要なことは、この瞬間を忘れないことです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/as/fh/s4/asfhs4qflx43fwr9jizq-zmsatq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今、基本を理解したので、もっと深刻なことを学ぶ時が来ました。</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「プリミティブ標準アロケーター」</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、STLで問題なく使用できるアロケータの実装を示します。このアロケータのメモリ割り当てアルゴリズムは、標準アロケータが使用するアルゴリズムと同様です。私はmallocの完全な実装を装うのではなく、いくつかの場所にロジックを追加して、そこから基本的な概念のみを取り出したことにすぐに注意したいと思います。もちろん、この実装ではそのすべての機微とニュアンスは考慮されていません... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムは「チャンク」との相互作用に基づいています（以下、</font><b><font style="vertical-align: inherit;">セクション</font></b><font style="vertical-align: inherit;">として使用され</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、この実装では、サイズは静的であり、4の倍数である必要があります。アロケータメモリからのすべてのメモリ割り当ては、4の倍数で整列されます。これについては、後で説明します。例として、サイズが16バイトのセクションを取り上げます。その内部に</font><font style="vertical-align: inherit;">は、メモリ</font><font style="vertical-align: inherit;">の開始（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）および終了（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">end</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）へのポインタ、最大メモリブロック（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）および多くの（</font><i><font style="vertical-align: inherit;">freeblocks</font></i><font style="vertical-align: inherit;">へのポインタが含まれます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、空きブロックのヘッダーが格納されます。この実装のヘッダーサイズは4バイトですが、必要に応じてサイズを簡単に変更できます。たとえば、割り当てられたメモリブロックのサイズが1バイトまたは2バイトの変数で表すことができる最大数値以下になることが確実にわかっている場合は、1バイトまたは2バイトのヘッダーを使用できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nr/xq/3f/nrxq3fcbnoooxnu0hehls2dghim.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セクションからメモリを割り当てる操作では、まず、十分なメモリがあるかどうかを確認する必要があります（この実装では、これは定数操作です。これを</font><i><font style="vertical-align: inherit;">maxblock</font></i><font style="vertical-align: inherit;">と比較するだけです）</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘッダー、および割り当てられたメモリのサイズが最大ブロックより小さい場合、この割り当てに十分なメモリがあります）。十分なメモリがある場合は、スタックアロケーターのように、ヘッダーに続いてメモリアドレスを指定し、前のヘッダーを空きブロックのセットから削除し、その後、新しく割り当てられたメモリブロックに新しいヘッダーを追加します。最大ブロックからメモリを割り当てた場合、最大ブロックの値を更新する必要があることに注意することが重要です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5m/lm/yw/5mlmywi79wh3uutr-ug7ko7s9em.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後の選択では、すべてが前のステップとまったく同じように行われます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3m/2m/i9/3m2mi9xd9qmnf6ngnqjf8wfnzd0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、現在、セクション内のメモリがなくなるとすぐに、アロケータは同じまたはより大きなサイズの別のセクションを取得して単純に作成します（この実装では、すべてのセクションは同じサイズです）。また、割り当て可能なブロックのサイズが、プロットのサイズからヘッダーのサイズを引いた値を超えないようにすることも重要です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fy/fz/6g/fyfz6gthdrfysccjef_xcphihb0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、新しいセクションでは、必要なメモリブロックを簡単に割り当てることができます。メモリの割り当ては、前のセクションとまったく同じシナリオで行われます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/al/eu/gc/aleugc_fka3uvpmju9gw66dpn1w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、この実装でプロットのサイズが4の倍数になる理由について少し説明します。答えは非常に簡単です。これは、アルゴリズムの実装と認識を容易にするために行われます。セクションの最後に、ヘッダーに適合しないメモリ領域が残っている可能性があるため、次の図にその例を示します。この問題を解決するには、このメモリを追加の配置で満たすか、ヘッダーサイズを小さくするか、追加のツールを使用してこの考えられる問題を追跡することができます。それ以外の場合、このメモリは失われ、将来的には失われたメモリが蓄積する可能性があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rq/rp/mv/rqrpmvvpbx1thpxjfbqcictzq1o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリを解放する前に、ブロックが配置されているセクションを特定する必要があります（現在の実装では、この操作はセクションの総数に対して線形的に複雑です。セクションの数が多いことがわかっている場合は、ヘッダーにセクションインデックスを追加することで一定にすることができます。メモリが割り当てられた場所）。以下では、割り当て解除操作はスタックアロケーターと同じですが、解放されたブロックのヘッダーアドレスを空きブロックのセットに追加し</font><font style="vertical-align: inherit;">、新しく解放されたブロックのサイズが</font><i><font style="vertical-align: inherit;">maxblock</font></i><font style="vertical-align: inherit;">より大きい場合は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を更新する必要があります</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/webt/fw/sl/yl/fwslyluxwv00a8mwazxe2iakd00.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この実装では、後続の各メモリリリースで、メモリが解放された領域でデフラグが試行されることに注意することが重要です。空きブロックを大きなブロックに組み合わせるには、デフラグが必要です。たとえば、この状況では、下の図のように、空きメモリのサイズでこれを実行できる場合でも、6バイトを割り当てることはできませんが、断片化により、確実で決定的な「いいえ」がわかります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tm/ec/dp/tmecdpyhyynvn0ahzubdxltorvo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デフラグ操作は非常に原始的です。その本質は、メモリを解放する操作の後で、解放されたブロックの左側と右側にある2つの隣接ブロックが解放されているかどうかを確認することです。隣接する2つのブロックが空いている場合、それらは1つのユニットに結合されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jt/1u/hl/jt1uhl_a7d3xo2a3f9kedx_7waq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、この実装は、たとえば1バイトに等しい、メモリの小さなブロックの割り当てを処理するのに非常にひどいものになることにも注意してください。</font><font style="vertical-align: inherit;">この状況では、ヘッダーサイズが4バイトであり、さらに4バイトの倍数である必要があるアドレスを破棄するために3バイトが加えられているため、メモリを1バイトだけ割り当てるために+7バイトが追加されます。</font><font style="vertical-align: inherit;">これにより、待望の最適化の代わりに追加のコストしか得られない場合があるため、メモリ割り当てアルゴリズムを盲目的に使用しないでください。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/r2/ez/v3/r2ezv39toknyjxexeamoq05g3r8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理論で十分だと私は思うので、Linus Torvaldsが言ったように、「</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chatterは価値が</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ありません</font><i><font style="vertical-align: inherit;">。</font></i><i><font style="vertical-align: inherit;">コードを見せて</font></i><font style="vertical-align: inherit;">。 " </font><font style="vertical-align: inherit;">さて、始めましょう...</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アロケータの要件は、C ++標準の章「</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アロケータの要件[allocator.requirements]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」に記載されています。</font><font style="vertical-align: inherit;">これらの要件に基づいて、STLで使用できる最も基本的なアロケーターインターフェイスは次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">Allocator</span> 
{</span>
    <span class="hljs-keyword">typedef</span> T value_type;<font></font>
    Allocator( );<font></font>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; 
    <span class="hljs-title">Allocator</span>(<span class="hljs-title">const</span> &lt;T&gt;&amp; <span class="hljs-title">other</span>);</span>
    <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(T* ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">U</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>==(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T&gt;&amp;, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U&gt;&amp;);</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">U</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>!=(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T&gt;&amp;, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U&gt;&amp;);</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
STLコンテナーはアロケーターに直接アクセスしないが、次のような値を提供するstd :: allocator_traitsテンプレートを介してアクセスすることが想定されています。</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">typedef</span> T* pointer;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> T* const_pointer; <font></font>
… <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、私たちは要件を理解しましたが、最後にアロケーターを書き始めています。</font><font style="vertical-align: inherit;">まず、いくつかのインターフェースまたはアダプターを作成しますが、実際には両方を呼び出すのは難しいため、戦略を使用して、特定の目的でメモリ割り当てアルゴリズムを簡単に変更できる、一種の「レイヤー」にしましょう。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Common interface for interaction with STL</span>
<span class="hljs-comment">// containers and algorithms. You can manually change</span>
<span class="hljs-comment">// allocation algorithm with different 'AllocationStrategy'</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// In this implementation was not implented 'adress' and 'max_size'</span>
<span class="hljs-comment">// unnecessary functions for.</span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">Allocator</span>
{</span>
    <span class="hljs-keyword">static_assert</span>(!<span class="hljs-built_in">std</span>::is_same_v&lt;T, <span class="hljs-keyword">void</span>&gt;, <span class="hljs-string">"Type of the allocator can not be void"</span>);
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> value_type = T;<font></font>
<font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocStrategy</span>&gt;
    <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">Allocator</span>;</span><font></font>
    <font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rebind</span>
    {</span>
        <span class="hljs-keyword">using</span> other = Allocator&lt;U, AllocationStrategy&gt;;<font></font>
    };<font></font>
<span class="hljs-keyword">public</span>:<font></font>
    Allocator() = <span class="hljs-keyword">default</span>;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Allocator</span><span class="hljs-params">(AllocationStrategy&amp; strategy)</span> <span class="hljs-keyword">noexcept</span>
        : <span class="hljs-title">m_allocation_strategy</span><span class="hljs-params">(&amp;strategy)</span> </span>{}<font></font>
    <font></font>
    Allocator(<span class="hljs-keyword">const</span> Allocator&amp; other) <span class="hljs-keyword">noexcept</span><font></font>
        : m_allocation_strategy(other.m_allocation_strategy) {}<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-title">Allocator</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Allocator&lt;U, AllocationStrategy&gt;&amp; other)</span> <span class="hljs-keyword">noexcept</span>
        : <span class="hljs-title">m_allocation_strategy</span><span class="hljs-params">(other.m_allocation_strategy)</span> </span>{}<font></font>
    <font></font>
    <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span>
    </span>{<font></font>
        assert(m_allocation_strategy &amp;&amp; <span class="hljs-string">"Not initialized allocation strategy"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(m_allocation_strategy-&gt;allocate(count_objects * <span class="hljs-keyword">sizeof</span>(T)));<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* memory_ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span>
    </span>{<font></font>
        assert(m_allocation_strategy &amp;&amp; <span class="hljs-string">"Not initialized allocation strategy"</span>);<font></font>
        m_allocation_strategy-&gt;deallocate(memory_ptr, count_objects * <span class="hljs-keyword">sizeof</span>(T));<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-keyword">typename</span>... Args&gt;
    <span class="hljs-keyword">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(U* ptr, Args&amp;&amp;... args)</span>
    </span>{
        <span class="hljs-keyword">new</span> (<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(ptr)) U { <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)... };<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(U* ptr)</span>
    </span>{<font></font>
        ptr-&gt;~U();<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:<font></font>
    AllocationStrategy* m_allocation_strategy = <span class="hljs-literal">nullptr</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>==(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T, AllocationStrategy&gt;&amp; <span class="hljs-title">lhs</span>, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U, AllocationStrategy&gt;&amp; <span class="hljs-title">rhs</span>)
{</span>
    <span class="hljs-keyword">return</span> lhs.m_allocation_strategy == rhs.m_allocation_strategy;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>!=(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T, AllocationStrategy&gt;&amp; <span class="hljs-title">lhs</span>, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U, AllocationStrategy&gt;&amp; <span class="hljs-title">rhs</span>)
{</span>
    <span class="hljs-keyword">return</span> !(lhs == rhs);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリ割り当ての戦略のおかげで、次のようなことができます。</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> AllocatorForSmallObjects = Allocator&lt;T, StrategyForSmallObjects&gt;;
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> AllocatorForBigObjects = Allocator&lt;T, StrategyForBigObjects&gt;;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、特定の状況で必要な目的に応じて、配布アルゴリズムを柔軟に変更できます。</font><font style="vertical-align: inherit;">AllocationStrategyの唯一の要件は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">割り当て</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">割り当て解除の操作</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が必要であること</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-comment">// Strategy for manipulation memory chunks, like</span>
<span class="hljs-comment">// a primitive malloc allocator.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Warning: if you try to deallocate some random block</span>
<span class="hljs-comment">// of the memory, most of all it will be an undefined behavior,</span>
<span class="hljs-comment">// because current implementation doesn't check this possible situation.</span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE = <span class="hljs-number">16'384u</span>&gt;<font></font>
class CustomAllocationStrategy<font></font>
{<font></font>
    <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE != <span class="hljs-number">0u</span>, <span class="hljs-string">"Chunk size must be more, than zero"</span>);
    <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE &lt;= <span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;::max(),
        <span class="hljs-string">"Chunk size must be less or equal max value of the uint32_t"</span>);
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{<font></font>
        assert(size &lt; CHUNK_SIZE &amp;&amp; <span class="hljs-string">"Incorrect chunk size for future usage"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0u</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; chunk : m_chunks)<font></font>
        {<font></font>
            <span class="hljs-keyword">void</span>* allocated_block = chunk.tryReserveBlock(size);
            <span class="hljs-keyword">if</span> (allocated_block) <span class="hljs-comment">//if the block was not reserved, then memory in the chunk has run out</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> allocated_block;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        m_chunks.push_back(details::Chunk&lt;CHUNK_SIZE&gt;{});<font></font>
        <span class="hljs-keyword">auto</span>&amp; chunk = m_chunks.back();
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* allocated_block = chunk.tryReserveBlock(size);
        <span class="hljs-keyword">return</span> allocated_block;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* memory_ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-keyword">if</span> ( (!memory_ptr) || (size == <span class="hljs-number">0u</span>) )<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* deallocation_ptr = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(memory_ptr);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; chunk : m_chunks)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (chunk.isInside(deallocation_ptr))<font></font>
            {<font></font>
                chunk.releaseBlock(deallocation_ptr);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;details::Chunk&lt;CHUNK_SIZE&gt;&gt; m_chunks{ <span class="hljs-number">1u</span> };<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下では、標準的なコンテナが使用されます。</font><font style="vertical-align: inherit;">ヒープから多くの割り当てが行われることに同意します。</font><font style="vertical-align: inherit;">アロケータを書く人にとって、これは受け入れられないと思います。</font><font style="vertical-align: inherit;">もちろん、代わりに、独自のコンテナーを作成したり、特定のニーズに合わせて他の誰かのコンテナーを使用したりすることもできますが、この実装では、できるだけ簡単に資料を提示するようにしたので、私の選択は標準のコンテナーになりました。</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">namespace</span> details<font></font>
{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-title">getAlignmentPadding</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> not_aligned_address, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> alignment)</span>
    </span>{
        <span class="hljs-keyword">if</span> ( (alignment != <span class="hljs-number">0u</span>) &amp;&amp; (not_aligned_address % alignment != <span class="hljs-number">0u</span>) )<font></font>
        {<font></font>
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> multiplier = (not_aligned_address / alignment) + <span class="hljs-number">1u</span>;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> aligned_address = multiplier * alignment;
            <span class="hljs-keyword">return</span> aligned_address - not_aligned_address;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0u</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// Current chunk implementation works only with size</span>
    <span class="hljs-comment">// aligned by 4 bytes, because HEADER_SIZE now also 4 bytes.</span>
    <span class="hljs-comment">// You can modify it with HEADER_SIZE without problems for your purposes.</span><font></font>
<font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE&gt;
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chunk</span>
    {</span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> HEADER_SIZE = <span class="hljs-number">4u</span>;
        <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE % HEADER_SIZE == <span class="hljs-number">0</span>, <span class="hljs-string">"CHUNK_SIZE must be multiple of the four"</span>);
        <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE &gt; HEADER_SIZE, <span class="hljs-string">"CHUNK_SIZE must be more than HEADER_SIZE"</span>);
    <span class="hljs-keyword">public</span>:<font></font>
        Chunk()<font></font>
        {<font></font>
            m_blocks.resize(CHUNK_SIZE);<font></font>
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* init_header = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(m_blocks.data());<font></font>
            *init_header = CHUNK_SIZE - HEADER_SIZE;<font></font>
            m_max_block = init_header;<font></font>
            m_free_blocks.insert(init_header);<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isInside</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* address)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
        </span>{
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* start_chunk_address = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(m_blocks.data());
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* end_chunk_address = start_chunk_address + CHUNK_SIZE;
            <span class="hljs-keyword">return</span> (start_chunk_address &lt;= address) &amp;&amp; (address &lt;= end_chunk_address);<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* <span class="hljs-title">tryReserveBlock</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> allocation_size)</span>
        </span>{
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> not_aligned_address = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>&gt;(m_max_block) + allocation_size;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> alignment_padding = getAlignmentPadding(not_aligned_address, HEADER_SIZE);
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> allocation_size_with_alignment = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;(allocation_size + alignment_padding);
            <span class="hljs-keyword">if</span> ( (!m_max_block) || (allocation_size_with_alignment &gt; *m_max_block) ) <span class="hljs-comment">// Check on enaught memory for allocation</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-comment">// Find min available by size memory block</span>
            <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> min_it = <span class="hljs-built_in">std</span>::min_element(m_free_blocks.cbegin(), m_free_blocks.cend(), [allocation_size_with_alignment] (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* rhs)<font></font>
            {<font></font>
                <span class="hljs-keyword">if</span> (*rhs &lt; allocation_size_with_alignment)<font></font>
                {<font></font>
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
                }<font></font>
                <font></font>
                <span class="hljs-keyword">return</span> (*lhs &lt; *rhs) &amp;&amp; (*lhs &gt;= allocation_size_with_alignment);<font></font>
            });<font></font>
            <font></font>
            assert(min_it != m_free_blocks.cend() &amp;&amp; <span class="hljs-string">"Internal logic error with reserve block, something wrong in implementation..."</span>);<font></font>
            assert(**min_it &gt;= allocation_size_with_alignment &amp;&amp; <span class="hljs-string">"Internal logic error with reserve block, something wrong in implementation..."</span>);<font></font>
            <font></font>
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* header_address = *min_it;
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* new_header_address =
                <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(header_address) + HEADER_SIZE + allocation_size_with_alignment);
            <span class="hljs-keyword">if</span> (m_free_blocks.find(new_header_address) == m_free_blocks.cend()) <span class="hljs-comment">// check if there is free memory in the current block</span><font></font>
            {<font></font>
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> old_block_size = *header_address;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> difference = old_block_size - HEADER_SIZE;
                <span class="hljs-keyword">if</span> (difference &gt;= allocation_size_with_alignment) <span class="hljs-comment">// check if there is enough space for another block</span><font></font>
                {<font></font>
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> new_block_size = difference - allocation_size_with_alignment;<font></font>
                    *new_header_address = new_block_size;<font></font>
                    m_free_blocks.insert(new_header_address);<font></font>
                }<font></font>
            }<font></font>
            <font></font>
            m_free_blocks.erase(header_address);<font></font>
            *header_address = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;(allocation_size);
            <span class="hljs-keyword">if</span> (header_address == m_max_block) <span class="hljs-comment">// if the maximum block were changed, then need to find the maximum block again</span><font></font>
            {<font></font>
                <span class="hljs-comment">// Find max block by size</span>
                <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> max_it = <span class="hljs-built_in">std</span>::max_element(m_free_blocks.cbegin(), m_free_blocks.cend(), [] (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* rhs)<font></font>
                {<font></font>
                    <span class="hljs-keyword">return</span> (*lhs) &lt; (*rhs);<font></font>
                });<font></font>
                <font></font>
                <span class="hljs-comment">// If there are no free blocks, therefore the memory in this chunk is over</span>
                m_max_block = (max_it != m_free_blocks.cend()) ? (*max_it) : (<span class="hljs-literal">nullptr</span>);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(header_address) + HEADER_SIZE;<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">releaseBlock</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* block_ptr)</span>
        </span>{
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* header_address = block_ptr - HEADER_SIZE;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> size_relized_block = *header_address;
            <span class="hljs-keyword">if</span> ( (!m_max_block) || (size_relized_block &gt; *m_max_block) ) <span class="hljs-comment">// if the relized block is greater than the maximum, then need to replace it</span><font></font>
            {<font></font>
                m_max_block = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address);<font></font>
            }<font></font>
                <font></font>
            m_free_blocks.insert(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address));
            <span class="hljs-keyword">auto</span> forward_it = m_free_blocks.find(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address));
            <span class="hljs-keyword">auto</span> backward_it = tryDefragment(forward_it, m_free_blocks.end());<font></font>
            tryDefragment(<span class="hljs-built_in">std</span>::make_reverse_iterator(backward_it), m_free_blocks.rend());<font></font>
        }<font></font>
    <span class="hljs-keyword">private</span>:
        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> DstIterator, <span class="hljs-keyword">typename</span> SrcIterator&gt;
        <span class="hljs-keyword">constexpr</span> DstIterator <span class="hljs-title">getIterator</span><span class="hljs-params">(SrcIterator it)</span> <span class="hljs-keyword">const</span>
        </span>{
            <span class="hljs-keyword">using</span> iterator = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::iterator;
            <span class="hljs-keyword">using</span> reverse_iterator = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::reverse_iterator;
            <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">( (<span class="hljs-built_in">std</span>::is_same_v&lt;SrcIterator, iterator&gt;) &amp;&amp; (<span class="hljs-built_in">std</span>::is_same_v&lt;DstIterator, reverse_iterator&gt;) )</span>
            </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_reverse_iterator(it);<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">constexpr</span> ( (<span class="hljs-built_in">std</span>::is_same_v&lt;SrcIterator, reverse_iterator&gt;) &amp;&amp; (<span class="hljs-built_in">std</span>::is_same_v&lt;DstIterator, iterator&gt;) )<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> it.base();<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> it;<font></font>
            }<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;
        Iterator <span class="hljs-title">tryDefragment</span><span class="hljs-params">(Iterator start_it, Iterator end_it)</span>
        </span>{
            <span class="hljs-comment">// primitive defragmentation algorithm - connects two neighboring</span>
            <span class="hljs-comment">// free blocks into one with linear complexity</span><font></font>
   <font></font>
            <span class="hljs-keyword">auto</span> current_it = start_it++;
            <span class="hljs-keyword">auto</span> next_it = start_it;
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* current_header_address = *current_it;
            <span class="hljs-keyword">if</span> ( (current_it != end_it) &amp;&amp; (next_it != end_it) )<font></font>
            {<font></font>
                <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* next_header_address = *next_it;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> current_block_size = *current_header_address;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* available_current_block_address =
                    <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(current_header_address) + HEADER_SIZE + current_block_size);
                <span class="hljs-keyword">if</span> (available_current_block_address == next_header_address)<font></font>
                {<font></font>
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> next_block_size = *next_header_address;
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> new_current_block_size = current_block_size + HEADER_SIZE + next_block_size;<font></font>
                    *current_header_address = new_current_block_size;<font></font>
                    <span class="hljs-keyword">if</span> (new_current_block_size &gt; *m_max_block)<font></font>
                    {<font></font>
                        m_max_block = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(current_header_address);<font></font>
                    }<font></font>
                            <font></font>
                    <span class="hljs-keyword">auto</span> delete_it = getIterator&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::iterator&gt;(next_it);
                    <span class="hljs-keyword">return</span> getIterator&lt;Iterator&gt;(m_free_blocks.erase(delete_it));<font></font>
                }<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-keyword">return</span> current_it;<font></font>
        }<font></font>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt; m_blocks;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt; m_free_blocks;
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* m_max_block;<font></font>
    };<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、アロケーターの使用を標準のコンテナーと一緒に装飾する方法について少し説明します。 </font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE = <span class="hljs-number">16'384u</span>&gt;
<span class="hljs-keyword">using</span> CustomAllocator = Allocator&lt;T, CustomAllocationStrategy&lt;CHUNK_SIZE&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> CustomAllocatorWithStackChunks = Allocator&lt;T, CustomAllocationStrategy&lt;<span class="hljs-number">1'024u</span>&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> CustomAllocatorWithHeapChunks = Allocator&lt;T, CustomAllocationStrategy&lt;<span class="hljs-number">16'384u</span>&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_vector = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_list = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;T, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_set = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;T, <span class="hljs-built_in">std</span>::less&lt;T&gt;, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_unordered_set = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_set</span>&lt;T, <span class="hljs-built_in">std</span>::hash&lt;T&gt;, <span class="hljs-built_in">std</span>::equal_to&lt;T&gt;, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;
<span class="hljs-keyword">using</span> custom_map = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;K, V, <span class="hljs-built_in">std</span>::less&lt;K&gt;, CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">const</span> K, V&gt;&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;
<span class="hljs-keyword">using</span> custom_unordered_map = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;K, <span class="hljs-built_in">std</span>::hash&lt;K&gt;, <span class="hljs-built_in">std</span>::equal_to&lt;K&gt;, CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">const</span> K, V&gt;&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">using</span> custom_string = <span class="hljs-built_in">std</span>::basic_string&lt;<span class="hljs-keyword">char</span>, <span class="hljs-built_in">std</span>::char_traits&lt;<span class="hljs-keyword">char</span>&gt;, CustomAllocator&lt;<span class="hljs-keyword">char</span>&gt;&gt;;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スマートポインターでアロケーターを使用することもできますが、そのためには小さなレイヤーを記述する必要があります。 </font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_unique_ptr = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;T, <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(T*)&gt;&gt;;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Allocator, <span class="hljs-keyword">typename</span> T </span>= <span class="hljs-keyword">typename</span> Allocator::value_type, <span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-function">custom_unique_ptr&lt;T&gt; <span class="hljs-title">make_custom_unique</span><span class="hljs-params">(Allocator allocator, Args&amp;&amp;... args)</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> custom_deleter = [allocator](T* ptr) <span class="hljs-keyword">mutable</span><font></font>
    {<font></font>
        allocator.destroy(ptr);<font></font>
        allocator.deallocate(ptr, <span class="hljs-number">1u</span>);<font></font>
    };<font></font>
        <font></font>
    <span class="hljs-keyword">void</span>* memory_block = allocator.allocate(<span class="hljs-number">1u</span>);
    <span class="hljs-keyword">if</span> (memory_block)<font></font>
    {<font></font>
        T* object_block = <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(memory_block);<font></font>
        allocator.construct(object_block, <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...);
        <span class="hljs-keyword">return</span> custom_unique_ptr&lt;T&gt;{ object_block, custom_deleter };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、そして最後に、これすべてを使用する例：</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span>
</span>{<font></font>
    CustomAllocationStrategy allocation_area{};<font></font>
<font></font>
    CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt; custom_int_allocator{ allocation_area };<font></font>
    custom_vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">vector</span>{ custom_int_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0u</span>; i &lt; <span class="hljs-number">100</span>; ++i)<font></font>
    {<font></font>
        <span class="hljs-built_in">vector</span>.push_back(i);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">vector</span>.at(i) &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-built_in">vector</span>.resize(<span class="hljs-number">16u</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : <span class="hljs-built_in">vector</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
<font></font>
CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt; custom_int_allocator_copy = <span class="hljs-built_in">vector</span>.get_allocator();<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr1 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">100</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr2 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">500</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr3 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">1000</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr4 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">1500</span>);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *ptr1 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr2 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr3 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr4 &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-keyword">float</span>&gt; custom_float_allocator { custom_int_allocator };<font></font>
    custom_list&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-built_in">list</span>{ { <span class="hljs-number">10.0f</span>, <span class="hljs-number">11.0f</span>, <span class="hljs-number">12.0f</span>, <span class="hljs-number">13.0f</span>, <span class="hljs-number">14.0f</span>, <span class="hljs-number">15.0f</span> }, custom_float_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">float</span> val : <span class="hljs-built_in">list</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; custom_pair_allocator{ allocation_area };<font></font>
    custom_map&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt; <span class="hljs-built_in">map</span>{ { { <span class="hljs-number">1.0</span>, <span class="hljs-number">100.0</span> }, { <span class="hljs-number">2.0</span>, <span class="hljs-number">200.0</span> } }, custom_pair_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; it : <span class="hljs-built_in">map</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"{"</span> &lt;&lt; it.first &lt;&lt; <span class="hljs-string">" : "</span> &lt;&lt; it.second &lt;&lt; <span class="hljs-string">"} "</span>;<font></font>
    }<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-keyword">double</span>&gt; custom_double_allocator{ allocation_area };<font></font>
    custom_set&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-built_in">set</span>{ { <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>, <span class="hljs-number">3000.0</span> }, custom_double_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">double</span> val : <span class="hljs-built_in">set</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
<font></font>
    CustomAllocator&lt;<span class="hljs-keyword">char</span>&gt; custom_char_allocator{ allocation_area };<font></font>
    custom_string string1{ <span class="hljs-string">"First allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string string2{ <span class="hljs-string">"Second allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string string3{ <span class="hljs-string">"Third allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string result_string = string1 + string2 + string3;<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; result_string;<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> EXIT_SUCCESS;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この実装が最も原始的であるという事実に焦点を当てたいと思いますが、それは必要な方向に簡単に拡張できるので、すべてがあなたの手にあります！</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご清聴ありがとうございました。この記事がお役に立てば幸いです。</font><font style="vertical-align: inherit;">私はまた、メモリとの密接な相互作用の全員の成功を祈って、そして最も重要なのは、ドナルド・クヌースの非常に重要な単語を忘れないでください：「</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">早すぎる最適化は、すべての悪の根であるが</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。」</font><font style="vertical-align: inherit;">アロケータの完全な実装を使用</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
して</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リポジトリに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンクし</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用されるソース</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/en/post/274827</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/mtrebi/memory-allocators</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja505614/index.html">最大の銀行の預金金利は歴史的な最低に低下しました：これは経済にどのように影響し、どこで交換を行いますか</a></li>
<li><a href="../ja505616/index.html">ロシア語のアルファベットの認識：データセットの収集からGUIの作成まで</a></li>
<li><a href="../ja505618/index.html">GRASPテンプレート：作成者</a></li>
<li><a href="../ja505620/index.html">HackTheBox。ウォークスルーネスト。NTFSストリーム、逆C＃およびSMBウォーカー</a></li>
<li><a href="../ja505624/index.html">数十億レコードのデータフレームを数秒で処理する方法</a></li>
<li><a href="../ja505634/index.html">WSL（Ubuntu）のプロキシ設定</a></li>
<li><a href="../ja505640/index.html">出版物評価の客観性</a></li>
<li><a href="../ja505642/index.html">透明なコルーチン</a></li>
<li><a href="../ja505644/index.html">著作権者が試しました：他の人の曲を解析するYouTubeのミュージックビデオレッスンが消える可能性があります</a></li>
<li><a href="../ja505648/index.html">アインシュタインの2つの間違い</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>