<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤱 😷 🤟 Algoritma Pemrosesan Cepat String HTTP 📏 👏🏿 👏🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kompresi header standar muncul di HTTP / 2, tetapi tubuh nilai URI, Cookie, User-Agent masih bisa puluhan kilobyte dan memerlukan tokenization, pencar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Algoritma Pemrosesan Cepat String HTTP</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/493242/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompresi header standar muncul di HTTP / 2, tetapi tubuh nilai URI, Cookie, User-Agent masih bisa puluhan kilobyte dan memerlukan tokenization, pencarian, dan perbandingan substring. </font><font style="vertical-align: inherit;">Tugas menjadi kritis jika parser HTTP perlu menangani lalu lintas berbahaya yang berat. </font><font style="vertical-align: inherit;">Pustaka standar menyediakan alat pengolah string yang luas, tetapi string HTTP memiliki spesifikasi sendiri. </font><font style="vertical-align: inherit;">Untuk kekhususan inilah parser HTTP Tempesta FW dikembangkan. </font><font style="vertical-align: inherit;">Kinerjanya beberapa kali lebih tinggi dibandingkan dengan solusi Open Source modern dan melampaui yang tercepat di antara mereka.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GcAJF4648JI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander Krizhanovsky</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">krizhanovsky</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) pendiri dan arsitek sistem Tempesta Technologies, seorang ahli dalam komputasi kinerja tinggi di Linux / x86-64. Alexander akan berbicara tentang kekhasan struktur string HTTP, menjelaskan mengapa pustaka standar kurang cocok untuk memprosesnya, dan menyajikan solusi Tempesta FW. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di bawah potongan: bagaimana HTTP Flood mengubah parser HTTP Anda menjadi hambatan, masalah x86-64 dengan salah duga cabang, caching dan kehabisan memori pada tugas parser HTTP biasa, perbandingan FSM dengan lompatan langsung, optimisasi GCC, vektor otomatis, strspn () - dan algoritma seperti strcasecmp () - untuk string HTTP, SSE, AVX2 dan penyaringan serangan injeksi menggunakan AVX2.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di Tempesta Technologies kami mengembangkan perangkat lunak khusus: kami berspesialisasi dalam bidang kompleks yang terkait dengan kinerja tinggi. </font><font style="vertical-align: inherit;">Kami sangat bangga dengan pengembangan inti dari WAF versi pertama Positive Technologies. </font><font style="vertical-align: inherit;">Firewall Aplikasi Web (WAF) adalah proksi HTTP: ia berurusan dengan analisis lalu lintas HTTP yang sangat mendalam untuk serangan (Web dan DDoS). </font><font style="vertical-align: inherit;">Kami menulis inti pertama untuk itu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain konsultasi, kami sedang mengembangkan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta FW</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ini adalah Application Delivery Controller (ADC). </font><font style="vertical-align: inherit;">Kami akan membicarakannya.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengontrol Pengiriman Aplikasi</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengendali Pengiriman Aplikasi adalah proxy HTTP dengan fungsionalitas yang ditingkatkan. </font><font style="vertical-align: inherit;">Tetapi saya akan berbicara tentang fitur yang terkait dengan keamanan - tentang memfilter serangan DDoS dan Web. </font><font style="vertical-align: inherit;">Saya juga akan menyebutkan batasannya, dan saya akan menunjukkan pekerjaan dan fungsinya dengan contoh kode.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mg/gf/tw/mggftw9mux_ycaxzjbfqe6hpdc0.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performa</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tempesta FW dibangun ke dalam kernel Linux TCP / IP Stack. </font><font style="vertical-align: inherit;">Berkat ini dan sejumlah optimasi lainnya, sangat cepat - dapat memproses 1,8 juta permintaan per detik pada perangkat keras yang murah. </font><font style="vertical-align: inherit;">Ini 3 kali lebih cepat dari Nginx pada beban teratas dan juga cepat jika dibandingkan dengan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pendekatan bypass kernel. </font></font></strong><br>
<br>
<img src="https://habrastorage.org/webt/te/md/pe/temdpec1gcgnm98ktgwr4gewn-8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada sejumlah kecil core, ini menunjukkan kinerja yang mirip dengan proyek Seastar, yang digunakan dalam ScyllaDB (ditulis dalam DPDK).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Proyek ini lahir ketika kami mulai bekerja di PT AF - pada tahun 2013. </font><font style="vertical-align: inherit;">WAF ini didasarkan pada satu akselerator HTTP Open Source yang populer. </font><font style="vertical-align: inherit;">Nginx, HAProxy, Varnish atau Apache Traffic adalah akselerator HTTP yang baik: mereka memberikan konten yang baik, cache, modifikasi, tetapi tidak satupun dari mereka </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dirancang untuk pemrosesan dan penyaringan lalu lintas besar-besaran</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oleh karena itu, kami berpikir bahwa jika ada firewall tingkat jaringan, mengapa tidak melanjutkan ide ini dan mengintegrasikan ke dalam tumpukan TCP / IP sebagai firewall tingkat aplikasi? </font><font style="vertical-align: inherit;">Sebenarnya, ternyata Tempesta FW - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hibrida akselerator HTTP dan firewall</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catatan: Nginx akan digunakan sebagai contoh dalam laporan karena ini adalah server web yang sederhana dan populer. </font><font style="vertical-align: inherit;">Sebaliknya, mungkin ada server HTTP Open Source lainnya.</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permintaan HTTP</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami </font><font style="vertical-align: inherit;">(HTTP / (1, ~ 2)) </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_o/3z/tq/_o3ztqvtwrv-7epdryhdztg8wsq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita dapat memiliki URI yang sangat besar. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemisah</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang penting pada saat penguraian HTTP </font><font style="vertical-align: inherit;">disorot dalam huruf tebal merah </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Saya akan menyoroti fitur: string besar beberapa kilobyte, serta pembatas yang berbeda, misalnya, tambahan "titik koma" yang perlu kita uraikan, atau urutan "\ r \ n". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sedikit tentang HTTP / 2 juga perlu dikatakan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fitur HTTP / 2</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2 adalah campuran dari string dan data biner</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Campuran ini lebih tentang mengoptimalkan bandwidth koneksi daripada menghemat sumber daya server. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2 di HPACK menggunakan tabel dinamis</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Permintaan pertama dari klien tidak dioptimalkan, tidak ada dalam tabel. Anda harus menguraikannya sehingga ditambahkan ke tabel. Jika HTTP / 2 DDoS mendatangi Anda, ini masalahnya. Dalam kasus normal, HTTP / 2 adalah protokol biner, tetapi Anda masih perlu mem-parsing teks: nama header teks, data. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengodean Huffman</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini adalah pengkodean sederhana, tetapi Huffman sangat sulit diprogram dengan cepat untuk kompresi: pengkodean Huffman melintasi batas byte, Anda tidak dapat menggunakan ekstensi vektor dan Anda harus menggunakan byte. </font><font style="vertical-align: inherit;">Anda tidak akan dapat dengan cepat memproses data dalam 32 atau 16 byte. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cookie, User-Agent, Referer, URI bisa sangat besar</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pertama, hapus Huffman, lalu kirim ke parser HTTP biasa, sama seperti pada HTTP / 1. </font><font style="vertical-align: inherit;">Meskipun diizinkan oleh RFC, cookie tidak disarankan untuk dikompres, karena ini adalah data rahasia - Anda tidak boleh memberikan informasi kepada penyerang tentang ukurannya. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemrosesan HTTP lambat</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Semua server HTTP pertama mendekode HTTP / 2 dan kemudian mengirim baris-baris ini ke parser HTTP / 1 yang sudah menggunakan HTTP / 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa masalah dengan penguraian HTTP / 1?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda perlu memprogram mesin negara dengan cepat.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda perlu memproses garis berturut-turut dengan cepat.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lalu lintas berbahaya menargetkan bagian proses paling lambat (terlemah). </font><font style="vertical-align: inherit;">Karena itu, jika kita ingin membuat filter, kita harus memperhatikan bagian yang lambat sehingga mereka juga bekerja dengan cepat.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Profil nginx</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat profil nginx di bawah banjir HTTP. </font><font style="vertical-align: inherit;">Nonaktifkan log akses agar sistem file tidak melambat. </font><font style="vertical-align: inherit;">Ketika bahkan halaman indeks reguler diminta, parser naik di bagian atas.</font></font><br>
<div class="scrollable-table"><table>
<tbody>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">%</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nama simbol</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1,5719</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_http_parse_header_line</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1,0303</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_vslprintf</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,6401</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5807</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recv</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5156</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_linux_sendfile_chain</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,4990</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_http_limit_req_handler</font></font></td>
</tr>
</tbody>
</table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kiri - "Profil datar". </font><font style="vertical-align: inherit;">Menariknya, tempat terpanas di dalamnya tidak jauh lebih berat daripada yang berikutnya, dan setelah itu profil turun dengan lancar. </font><font style="vertical-align: inherit;">Ini berarti, misalnya, bahwa mengoptimalkan fungsi pertama dua kali tidak akan membantu meningkatkan kinerja secara signifikan. </font><font style="vertical-align: inherit;">Itu sebabnya kami tidak mengoptimalkan Nginx yang sama, tetapi membuat proyek baru yang akan meningkatkan kinerja seluruh ekor profil.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana parser HTTP reguler dikodekan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Biasanya kami memiliki loop ( </font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) yang berjalan di sepanjang baris, dan dua variabel: state ( </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) dan data saat ini ( </font></font><code>str_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memasuki siklus (1) dan melihat kondisi saat ini (kondisi cek). Kami meneruskan ke data yang diterima (simbol </font></font><code><em>'b'</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan menerapkan beberapa logika. Kami lolos ke kondisi kedua (2). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hi/z7/s2/hiz7s2e3yw5bpqqz-qbir5hbteq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pergi ke akhir </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3) - ini adalah transisi kedua relatif ke awal kode kita dan, mungkin, ketinggalan kedua dalam cache instruksi. Lalu kita pergi ke permulaan </font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4), makan karakter berikutnya ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gk/zs/17/gkzs17hdxtyfcaife8j1pms7wbi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... dan lagi mencari keadaan dalam instruksi di dalam </font></font><code>case 2:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika suatu variabel telah diberi </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai</font></font><code>2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kita bisa langsung ke instruksi selanjutnya. </font><font style="vertical-align: inherit;">Tetapi sebaliknya, mereka naik lagi dan turun lagi. </font><font style="vertical-align: inherit;">Kami "memotong lingkaran" dengan kode alih-alih hanya turun. </font><font style="vertical-align: inherit;">Parser normal tidak, misalnya, Ragel menghasilkan parser dengan transisi langsung.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mc/ba/3w/mcba3wgxqkflqjvq1mxytcy_kwo.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx HTTP Parser</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beberapa kata tentang parser nginx dan lingkungannya. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx berfungsi dengan API soket normal</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - data yang masuk ke adaptor disalin ke ruang pengguna. </font><font style="vertical-align: inherit;">Akibatnya, kami memiliki potongan data besar di mana kami mencari yang kami butuhkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginx menggunakan algoritma yang bekerja dalam dua lintasan: pertama mencari panjang, lalu memeriksa. </font><font style="vertical-align: inherit;">Pada langkah pertama, ia memindai string untuk token, mencari token pertama ("percobaan"). </font><font style="vertical-align: inherit;">Pada yang kedua, itu token, memeriksa akhir permintaan ( </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) dan mulai </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sesuai dengan ukuran token.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (p = b-&gt;pos; p &lt; b-&gt;last; p++) {<font></font>
    ...<font></font>
    <span class="hljs-keyword">switch</span> (state) {<font></font>
    ...<font></font>
    <span class="hljs-keyword">case</span> sw_method:
        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">' '</span>) {<font></font>
            m = r-&gt;request_start;<font></font>
            <span class="hljs-keyword">switch</span> (p - m) {         <span class="hljs-comment">// switch on token length!</span>
            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
                <span class="hljs-keyword">if</span> (ngx_str3_cmp(m, <span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>)) {<font></font>
                ...<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> ((ch &lt; <span class="hljs-string">'A'</span> || ch &gt; <span class="hljs-string">'Z'</span>) &amp;&amp; ch != <span class="hljs-string">'_'</span> &amp;&amp; ch != <span class="hljs-string">'-'</span>)
                <span class="hljs-keyword">return</span> NGX_HTTP_PARSE_INVALID_METHOD;
            <span class="hljs-keyword">break</span>;<font></font>
    ...</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Dapatkan" selalu dalam potongan data yang sama</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tempesta FW bekerja dengan zero-copy. </font><font style="vertical-align: inherit;">Ini berarti bahwa data dapat datang dengan ukuran yang sepenuhnya arbitrer: masing-masing 1 byte atau 1000 byte. </font><font style="vertical-align: inherit;">"Mekanisme" ini tidak cocok untuk kita. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat cara kerjanya </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di GCC.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gcc</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabel pencarian</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Di sebelah kiri adalah contoh khas enum: mulai dengan 0, lalu label berurutan, 26 konstanta, dan kemudian beberapa kode yang memproses semuanya. Di sebelah kanan adalah kode yang dihasilkan oleh kompiler. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ac/1n/hh/ac1nhhz9jqe87hdqb6bxfv541vu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, bandingkan variabel </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam register EAX dengan konstanta. Selanjutnya, kami menyajikan semua label dalam bentuk array berurutan dari pointer 8 byte (tabel pencarian). Pada instruksi ini kita meneruskan offset dalam array ini - itu adalah dereferencing ganda dari pointer. Kanan bawah adalah kode yang kita beralih dari tabel ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ternyata dereferencing ganda memori: jika kami menerima data rahasia, maka dengan byte kami menemukan alamat dalam array dan pergi ke pointer ini. Penting untuk diketahui bahwa dalam kehidupan ini masih lebih buruk daripada dalam contoh - untuk tabel pencarian yang </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">dihasilkan oleh</font></a><font style="vertical-align: inherit;"> kompiler</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kode lebih rumit dalam kasus </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">skrip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk serangan Spectre. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencarian biner</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kasus berikutnya </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bukan dengan konstanta berurutan, tetapi dengan yang sewenang-wenang. Kodenya sama, tetapi sekarang GCC tidak dapat mengkompilasi array yang begitu besar dan menggunakan konstanta sebagai indeks dari array. Dia beralih ke pencarian biner. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/as/mo/7p/asmo7pb4lxsv7pchnafv-qjz7u4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sebelah kanan kita melihat perbandingan berurutan, transisi ke alamat dan kelanjutan perbandingan - pencarian biner adalah dengan kode. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengurai HTTP nginx.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mari kita lihat apa itu mesin nginx. Ini memiliki 9 kilobyte kode - ini tiga kali lebih sedikit dari cache level pertama pada mesin tempat benchmark diluncurkan (seperti pada kebanyakan prosesor x86-64).</font></font><br>
<br>
<pre><code class="bash hljs">$ nm -S /opt/nginx-1.11.5/sbin/nginx<font></font>
| grep http_parse | cut -d<span class="hljs-string">' '</span> -f 2<font></font>
| perl -le <span class="hljs-string">'$a += hex($_) while (&lt;&gt;); print $a'</span><font></font>
9220<font></font>
<font></font>
$ getconf LEVEL1_ICACHE_SIZE<font></font>
32768<font></font>
<font></font>
$ grep -c <span class="hljs-string">'case sw_'</span> src/http/ngx_http_parse.c<font></font>
84</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengurai header nginx </font></font><code>ngx_http_parse_header_line ()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah tokenizer sederhana. </font><font style="vertical-align: inherit;">Itu tidak melakukan apa-apa dengan nilai header dan nama mereka, tetapi hanya menempatkan token dari header HTTP ke dalam hash. </font><font style="vertical-align: inherit;">Jika Anda membutuhkan nilai header apa pun, pindai tabel header dan ulangi analisisnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita harus </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benar</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><strong><font style="vertical-align: inherit;">benar memeriksa nama dan nilai header</font></strong><font style="vertical-align: inherit;"> untuk alasan keamanan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></strong><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta FW: validasi string dari string HTTP</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mesin negara kami adalah urutan besarnya lebih kuat: kami melakukan validasi header RFC dan segera, di parser, memproses hampir semuanya. </font><font style="vertical-align: inherit;">Jika nginx memiliki 80 negara, maka kami memiliki 520, dan ada lebih banyak dari mereka. </font><font style="vertical-align: inherit;">Jika kita melaju </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka itu akan menjadi 10 kali lebih besar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memiliki </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nol-salinan I / O</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - potongan ukuran yang berbeda dapat memotong data di tempat yang berbeda. </font><font style="vertical-align: inherit;">potongan yang berbeda dapat memotong data kami. </font><font style="vertical-align: inherit;">Dalam zero-copy I / O, misalnya, "GET" dapat (jarang) muncul sebagai "GET", "GE" dan "T" atau "G", "E" dan "T", sehingga Anda perlu menyimpan status di antara potongan data . </font><font style="vertical-align: inherit;">Kami praktis menghapus biaya I / O, tetapi dalam profil itu terbang - semuanya buruk. </font><font style="vertical-align: inherit;">Parser HTTP besar adalah salah satu tempat paling kritis dalam proyek.</font></font><br>
<br>
<pre><code class="bash hljs">$ grep -c <span class="hljs-string">'__FSM_STATE\|__FSM_TX\|__FSM_METH_MOVE\|__TFW_HTTP_PARSE_'</span> http_parser.c<font></font>
520<font></font>
    7.64% [tempesta_fw]     [k] tfw_http_parse_req<font></font>
    2.79% [e1000]           [k] e1000_xmit_frame<font></font>
    2.32% [tempesta_fw]     [k] __tfw_strspn_simd<font></font>
    2.31% [tempesta_fw]     [k] __tfw_http_msg_add_str_data<font></font>
    1.60% [tempesta_fw]     [k] __new_pgfrag<font></font>
    1.58% [kernel]          [k] skb_release_data<font></font>
    1.55% [tempesta_fw]     [k] __str_grow_tree<font></font>
    1.41% [kernel]          [k] __inet_lookup_established<font></font>
    1.35% [tempesta_fw]     [k] tfw_cache_do_action<font></font>
    1.35% [tempesta_fw]     [k] __tfw_strcmpspn</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang harus dilakukan untuk memperbaiki situasi ini?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referensi Langsung FSM</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal pertama yang kita lakukan adalah </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggunakan bukan loop, tetapi transisi langsung dengan label ( </font></font></strong><code>go to</code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Generator pengurai normal seperti Ragel melakukan ini. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bq/di/pr/bqdipr9bt6au4ifisfpvjli2p_e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menyandikan setiap negara bagian kami dengan label di </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan label di C dengan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nama yang sama</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Setiap kali kami ingin pergi, kami menemukan label di </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau mengakses negara yang sama langsung dari kode. Pertama kali kami melewati </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan kemudian di dalamnya kami langsung menuju label yang diinginkan. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kerugian</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : ketika kita ingin beralih ke keadaan berikutnya, kita harus segera mengevaluasi apakah kita masih memiliki data yang tersedia (karena zero-copy I / O). Kondisi tubuh</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini disalin ke masing-masing negara: alih-alih satu kondisi dalam FSM switch-driven biasa, kami memiliki 500 dari mereka sesuai dengan jumlah negara. Menghasilkan kode untuk setiap negara bagian tidak bagus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus mesin negara besar, karena </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan bagian </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam yang </font><font style="vertical-align: inherit;">besar </font><font style="vertical-align: inherit;">, GTC juga mengulangi kondisi </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beberapa kali di dalam kode. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ganti dengan </font></font></strong><code><strong>switch</strong></code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transisi langsung.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimasi berikutnya adalah bahwa kami tidak menggunakannya </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan beralih ke lompatan langsung ke alamat meta yang disimpan. Kami ingin segera pergi ke titik yang diinginkan segera setelah kami memasuki fungsi. GCC memungkinkan Anda melakukan ini. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/i3/x5/7m/i3x57mb0tahhz99szccnfdbxde0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GCC memiliki ekstensi standar yang dapat membantu. Kami mengambil nama label (ini dia </font></font><code>from</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) dan menetapkan alamatnya untuk beberapa variabel-C melalui double ampersand (&amp;&amp;). Sekarang kita bisa membuat instruksi lompat langsung</font></font><code>jmp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke alamat label ini dengan </font></font><code>goto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat apa yang terjadi.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kinerja Konversi Langsung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada sejumlah kecil negara, generator kode transisi langsung bahkan sedikit lebih lambat dari biasanya </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tetapi untuk mesin negara besar, produktivitas berlipat ganda. </font><font style="vertical-align: inherit;">Jika mesin negara kecil, lebih baik menggunakan yang biasa </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="bash hljs">$ grep -m 2 <span class="hljs-string">'model name\|bugs'</span> /proc/cpuinfo<font></font>
model name : Intel(R) Core(TM) i7-6500U CPU @ 2.50GHz<font></font>
bugs       : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf<font></font>
<font></font>
$ gcc --version|head -1<font></font>
gcc (GCC) 8.2.1 20181105 (Red Hat 8.2.1-5)<font></font>
<font></font>
States     Switch-driven automaton     Goto-driven automaton<font></font>
     7     header_line:      139ms     header_line:          156ms<font></font>
    27     request_line:     210ms     request_line:         186ms<font></font>
   406     big_header_line: 1406ms     goto_big_header_line: 727ms</code></pre><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catatan: Kode Tempesta lebih rumit dari contoh. </font><font style="vertical-align: inherit;">GitHub memiliki semua </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://github.com/tempesta-tech/blog/tree/master/"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tolok ukur</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sehingga Anda dapat melihat semuanya secara detail. </font><font style="vertical-align: inherit;">Kode parser asli tersedia </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di tautan</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (parser HTTP utama). </font><font style="vertical-align: inherit;">Selain itu, di Tempesta FW ada </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parser kecil</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang menggunakan FSM lebih mudah.</font></font></em><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa transisi langsung mungkin lebih lambat</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di mesin negara, kita melalui banyak kode, jadi (diharapkan) akan ada banyak salah duga cabang. </font><font style="vertical-align: inherit;">Mari kita melakukan "profiling" berdasarkan prediksi branch-misses:</font></font><br>
<br>
<pre><code class="bash hljs">perf record -e branch-misses -g ./http_benchmark<font></font>
406 states:    switch       - 38% on switch(),<font></font>
               direct jumps - 13% on header value parsing<font></font>
			   <font></font>
7,27 states:   switch       - &lt;18% switch(), up to 40% <span class="hljs-keyword">for</span>()<font></font>
               direct jumps – up to 46% on header &amp; URI parsing</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada mesin negara besar dengan 406 negara bagian, kami menghabiskan 38% dari waktu pemrosesan transisi di </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pada mesin keadaan dengan transisi langsung, hotspot adalah penguraian garis. </font><font style="vertical-align: inherit;">Parsing string di setiap negara termasuk memeriksa kondisi ujung string: kondisi </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mesin negara aktif </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="bash hljs">perf <span class="hljs-built_in">stat</span> -e L1-icache-load-misses ./http_benchmark<font></font>
<font></font>
                       Switch-driven automaton  Goto-driven automaton<font></font>
big FSM code size:                       29156                  49202<font></font>
L1-icache-load-misses:                      4M                     2M</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, kita melihat profil dari kedua jenis mesin negara oleh peristiwa L1 cache cache instruksi - hampir 30 kilobyte untuk </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan 50 kilobyte untuk lompatan langsung (lebih dari cache instruksi tingkat pertama). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tampaknya jika kita tidak cocok dengan cache, seharusnya ada banyak cache yang hilang untuk mesin keadaan seperti itu. </font><font style="vertical-align: inherit;">Tapi tidak, mereka 2 kali lebih sedikit. </font><font style="vertical-align: inherit;">Itu karena cache berfungsi lebih baik: kami bekerja dengan kode secara berurutan dan berhasil menarik data dari cache yang lebih lama.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompiler mengubah urutan kode</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat kami memprogram kode mesin keadaan </font></font><code>go to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pertama-tama kita memiliki status yang akan dipanggil pertama ketika data diterima: metode HTTP, URI, dan kemudian header HTTP. Tampaknya logis bahwa kode akan dimuat ke cache prosesor secara berurutan, dari atas ke bawah, sama seperti kita melalui data. Tapi ini sepenuhnya salah. Jika Anda melihat kode assembler, Anda akan melihat hal-hal luar biasa. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tg/uf/zr/tgufzrnfusabmvn1gg9ulzjgvgo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sebelah kiri adalah apa yang kami program: pertama kami parsing metode </font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kemudian di suatu tempat jauh di bawah metode yang tidak mungkin </font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Oleh karena itu, kami berharap dapat melihat parsing </font></font><code> GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font><font style="vertical-align: inherit;">pada awal assembler </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan kemudian </font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tapi semuanya justru sebaliknya: </font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di tengah, </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di akhir, dan di </font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini karena kompiler tidak mengerti bagaimana data datang kepada kita. </font><font style="vertical-align: inherit;">Dia mendistribusikan kode sesuai dengan gambar kode indahnya. </font><font style="vertical-align: inherit;">Agar dia mengatur kode dalam urutan yang benar, kita harus menggunakan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penghalang kompiler</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penghalang kompiler adalah boneka perakitan yang tidak akan disusun ulang oleh pengompil. </font><font style="vertical-align: inherit;">Dengan hanya menempatkan hambatan seperti itu, kami </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meningkatkan produktivitas sebesar 4%</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">STATE(sw_method) {<font></font>
    ... <span class="hljs-comment">// the most frequent states</span>
    MATCH(NGX_HTTP_GET, <span class="hljs-string">"GET "</span>);<font></font>
    MATCH(NGX_HTTP_POST, <span class="hljs-string">"POST"</span>);<font></font>
    <font></font>
    __asm__ __volatile__(<span class="hljs-string">""</span>: : :<span class="hljs-string">"memory"</span>);<font></font>
    ... <span class="hljs-comment">// many other states</span><font></font>
    <font></font>
    <span class="hljs-comment">// Improbable states</span>
    METH_MOVE(Req_MethU, <span class="hljs-string">'N'</span>, Req_MethUn);<font></font>
    METH_MOVE(Req_MethUn, <span class="hljs-string">'L'</span>, Req_MethUnl);<font></font>
    METH_MOVE(Req_MethUnl, <span class="hljs-string">'O'</span>, Req_MethUnlo);<font></font>
    METH_MOVE(Req_MethUnlo, <span class="hljs-string">'C'</span>, Req_MethUnloc);<font></font>
    METH_MOVE_finish(Req_MethUnloc, <span class="hljs-string">'K'</span>, NGX_HTTP_UNLOCK)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tulis kode dengan cara Anda sendiri</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena kompiler tidak mengatur data seperti yang kita inginkan, kami akan melakukan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">optimasi dipandu profiler</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (optimasi di bawah kendali profiler). </font><font style="vertical-align: inherit;">Profiler guided optimization (PGO) adalah jumlah total sampel, bukan urutan panggilan. </font><font style="vertical-align: inherit;">Misalnya, URI menerima lebih banyak sampel daripada analisis metode, sehingga URI akan memposisikan kode pemrosesan sebelum memproses metode.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana itu bekerja? </font><font style="vertical-align: inherit;">Kami akan menulis kode, menjalankan tolok ukur di atasnya, memberikan hasil profil ke kompiler, dan itu akan menghasilkan kode optimal untuk beban kami. </font><font style="vertical-align: inherit;">Tetapi masalahnya adalah ia hanya mengkompilasi bagian kode yang terpanas, tetapi tidak melacak ketergantungan waktu. </font><font style="vertical-align: inherit;">Jika URI terbesar di muat, maka ini akan menjadi tempat terpanas. </font><font style="vertical-align: inherit;">URI akan naik ke atas fungsi, dan PGO tidak akan menunjukkan bahwa nama metode selalu sebelum URI. </font><font style="vertical-align: inherit;">Dengan demikian, PGO tidak berfungsi.</font></font><br>
<br>
<pre><code class="cpp hljs">Req_Method: {
    <span class="hljs-keyword">if</span> (likely(PI(p) == CHAR4_INT(<span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>))) {<font></font>
        ...<font></font>
        <span class="hljs-keyword">goto</span> Req_Uri;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (likely(PI(p) == CHAR4_INT(<span class="hljs-string">'P'</span>, <span class="hljs-string">'O'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'T'</span>))) {<font></font>
        ...<font></font>
        <span class="hljs-keyword">goto</span> Req_UriSpace;<font></font>
    }<font></font>
    <span class="hljs-keyword">goto</span> Req_Meth_SlowPath;<font></font>
}<font></font>
... <span class="hljs-comment">// other methods: POST, PUT etc.</span><font></font>
Req_Uri:<font></font>
    ... <span class="hljs-comment">// URI processing</span><font></font>
Req_Meth_SlowPath:<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang berhasil? </font></font><br>
<br>
<code><strong>likely</strong></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code><strong>unlikely</strong></code> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">macro</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (untuk kode kernel Linux, GCC intrinsik tersedia di ruang pengguna </font></font><code>__builtin_expect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Mereka mengatakan kode mana yang harus ditempatkan lebih dekat. Misalnya, kemungkinan melaporkan bahwa badan permintaan harus segera ketinggalan </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kemudian mengambil kode terlebih dahulu (mengambil prosesor terlebih dahulu) akan memilih kode itu dan semuanya akan cepat. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7x/4u/05/7x4u057of2wmtq310wflcuyvlei.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gambar menunjukkan awal dari metode parsing, akhir dan penghalang. Kami tidak berharap melihat kode di balik penghalang. Tampaknya ini tidak seharusnya - kami telah memasang penghalang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi apa yang terjadi dalam kenyataan? Kompilator melihat </font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kondisi - kemungkinan besar kita akan memasuki tubuh kondisi dan di sana kita akan beralih ke lompatan tanpa syarat ke label</font></font><code>Req_Uri</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ternyata kode itu setelah kondisi kita tidak diproses di "hot path". </font><font style="vertical-align: inherit;">Kompiler memindahkan kode di bawah label di belakang </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, meskipun ada penghalang, karena kondisi kode panas terpenuhi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk ini tidak, GCC memiliki ekstensi: atribut </font></font><code>hot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>cold</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">label. </font><font style="vertical-align: inherit;">Mereka mengatakan label mana yang panas (kemungkinan besar) dan mana yang dingin (kecil kemungkinannya). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bw/ra/uh/bwrauhxesqvk_ke22cw67cqwuja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kita sepakat tentang apa yang </font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lebih mungkin </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan serahkan padanya </font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dalam kondisi tersebut, pemrosesan URI naik, dan </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masuk di bawah. </font><font style="vertical-align: inherit;">Semua kode lain untuk mesin keadaan paling tidak mungkin tetap di bawah karena labelnya dingin.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambigu -O3</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat optimasi kompiler. </font><font style="vertical-align: inherit;">Hal pertama yang terlintas dalam pikiran adalah untuk menggunakan bukan O2, tetapi O3 - itu harus lebih cepat. </font><font style="vertical-align: inherit;">Tapi ini tidak benar - O3 terkadang menghasilkan kode yang lebih buruk. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vc/-p/q8/vc-pq8a078kyofsx7cj1ukorbta.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O3 adalah kumpulan dari beberapa optimasi</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jika kami menambahkannya ke O2 secara terpisah, kami mendapatkan opsi yang berbeda: beberapa bantuan optimasi, beberapa mengganggu. </font><font style="vertical-align: inherit;">Untuk kode spesifik kami, kami memilih hanya optimasi yang menghasilkan kode lebih baik. </font><font style="vertical-align: inherit;">Kami memberikan hasil terbaik - ini adalah 1.820 detik relatif ke 1.838 dan 1.858. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beberapa opsi disorot dalam warna hijau - ini adalah auto-vektorisasi.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autovectorization</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh siklus dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">panduan GCC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> a[<span class="hljs-number">256</span>], b[<span class="hljs-number">256</span>], c[<span class="hljs-number">256</span>];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<font></font>
        a[i] = b[i] + c[i];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita memiliki beberapa variabel array yang berulang, kita dapat mengoptimalkan siklus - terurai menjadi vektor. </font><font style="vertical-align: inherit;">Secara default, auto- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vektorisasi</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diaktifkan pada tingkat ketiga optimasi -O3 </font><font style="vertical-align: inherit;">: GCC menghasilkan kode vektor di mana ia bisa. </font><font style="vertical-align: inherit;">Tetapi </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak semua kode</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dapat secara otomatis di-vectorized (walaupun pada prinsipnya vectorized). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami dapat mengaktifkan opsi GCC </font></font><code>-fopt-info-vec-all</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang menunjukkan apa yang telah menjadi vektor dan apa yang tidak. </font><font style="vertical-align: inherit;">Kami mendapatkan bahwa untuk tolok ukur kami tidak ada yang di vektorisasi, tetapi kode masih dihasilkan lebih buruk. </font><font style="vertical-align: inherit;">Oleh karena itu, vektorisasi tidak selalu berfungsi: kadang-kadang memperlambat kode. </font><font style="vertical-align: inherit;">Tetapi kita selalu dapat melihat apa yang telah di-vektor-kan dan mana yang tidak, dan mematikan vektorisasi, jika perlu.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alignment: bagaimana cara membandingkan string dengan GET?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami membuat retasan kecil, seperti pada nginx: kami tidak menguraikan baris demi byte, tetapi menghitung </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan membandingkan baris dengan mereka.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR4_INT(a, b, c, d)    ((d &lt;&lt; 24) | (c &lt;&lt; 16) | (b &lt;&lt; 8) | a)</span>
<span class="hljs-keyword">if</span> (p == CHAR4_INT(<span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>)))
    <span class="hljs-comment">// we have GET as method</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita tahu bahwa jika </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak selaras, maka akan melambat 2-3 kali. </font><font style="vertical-align: inherit;">Kami menulis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patokan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kecil </font><font style="vertical-align: inherit;">yang membuktikan ini.</font></font><br>
<br>
<pre><code class="cpp hljs">$ ./int_align<font></font>
Unaligned access = <span class="hljs-number">6.20482</span>
Aligned access = <span class="hljs-number">2.87012</span>
Read four bytes = <span class="hljs-number">2.45249</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian cobalah untuk menyelaraskan </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami akan melihat, jika alamat </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disejajarkan, kemudian membandingkan dengan </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jika tidak, byte.</font></font><br>
<br>
<pre><code class="cpp hljs"> (((<span class="hljs-keyword">long</span>)(p) &amp; <span class="hljs-number">3</span>)<font></font>
  ? ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">0</span>]) | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span>)<font></font>
  | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">16</span>) | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">3</span>]) &lt;&lt; <span class="hljs-number">24</span>))<font></font>
  : *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)(p));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi ternyata pendekatan ini bekerja lebih buruk:</font></font><br>
<br>
<pre><code class="bash hljs">full request line:     no difference<font></font>
method only:           unaligned      - 214ms<font></font>
                       aligned        - 231ms<font></font>
                       bytes          - 216ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Singkatnya: ada perbedaan antara kode benchmark yang terisolasi, tidak dapat dioptimalkan, dan kode parser sebaris, yang kehilangan optimasinya karena jumlah kode yang besar. </font><font style="vertical-align: inherit;">Tidak ada penalti dalam pembuatan profil. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catatan: diskusi terperinci tentang mengapa hal ini terjadi dalam tugas kita dapat </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dibaca di GitHub</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa string HTTP penting bagi kami?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, ini adalah URI normal: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pw/_d/tw/pw_dtwjndt-xro47gvj3qehvpm4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda cukup pilih-pilih tentang hotel, buka Pemesanan dan atur beberapa filter, dapatkan URI lebih dari satu kilobyte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginx memiliki mesin parsing yang cukup besar di </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Itu tidak bekerja dengan sangat cepat. </font><font style="vertical-align: inherit;">Selain itu, dalam kasus Tempesta FW, kita tidak hanya perlu menguraikan URI, tetapi juga memeriksanya untuk injeksi.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">case</span> sw_check_uri:
    <span class="hljs-keyword">if</span> (usual[ch &gt;&gt; <span class="hljs-number">5</span>] &amp; (<span class="hljs-number">1U</span> &lt;&lt; (ch &amp; <span class="hljs-number">0x1f</span>)))
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">switch</span> (ch) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:<font></font>
        r-&gt;uri_ext = <span class="hljs-literal">NULL</span>;<font></font>
        state = sw_after_slash_in_uri;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'.'</span>:<font></font>
        r-&gt;uri_ext = p + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">' '</span>:<font></font>
        r-&gt;uri_end = p;<font></font>
        state = sw_check_uri_http_09;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> CR:<font></font>
        r-&gt;uri_end = p;<font></font>
        r-&gt;http_minor = <span class="hljs-number">9</span>;<font></font>
        state = sw_almost_done;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LF:<font></font>
        r-&gt;uri_end = p;<font></font>
        r-&gt;http_minor = <span class="hljs-number">9</span>;
        <span class="hljs-keyword">goto</span> done;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'%'</span>:<font></font>
    r-&gt;quoted_uri = <span class="hljs-number">1</span>;<font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
URI lain: /redir_lang.jsp?lang=foobar%0d%0aContent-Length:%200%0d% </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0a% 0d% 0aHTTP / 1,1% 20200% 20OK% 0d% 0aContent-Type:% 20text / </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
html% 0d% 0aContent -Panjang:% 2019% 0d% 0a% 0d% 0aShazam &lt;/ </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
html&gt;. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sepertinya yang pertama, tetapi memiliki suntikan. Anda harus menggali cukup dalam untuk memahami hal ini. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita jalankan tes</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : ambil URI pertama, beri makan wrk, atur ke nginx dan lihat bahwa parsing nginx menjadi sangat panas. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m-/y1/id/m-y1idxtawyq5rjayodyb_r2tgq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika pada permintaan indeks reguler sebelumnya sudah jelas bahwa parser sudah ada di atas, ini semakin panas.</font></font><br>
<br>
<pre><code class="bash hljs">8.62%  nginx         [.] ngx_http_parse_request_line<font></font>
2.52%  nginx         [.] ngx_http_parse_header_line<font></font>
1.42%  nginx         [.] ngx_palloc<font></font>
0.90%  [kernel]      [k] copy_user_enhanced_fast_string<font></font>
0.85%  nginx         [.] ngx_strstrn<font></font>
0.78%  libc-2.24.so  [.] _int_malloc<font></font>
0.69%  nginx         [.] ngx_hash_find<font></font>
0.66%  [kernel]      [k] tcp_recvmsg</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang istimewa tentang string HTTP? </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada pemisah yang berbeda </font></font><code>' : '</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>' , '</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan bahkan akhir baris, yang dapat berupa byte ganda </font></font><code>\r\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau </font><font style="vertical-align: inherit;">byte </font><font style="vertical-align: inherit;">tunggal </font></font><code>\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang telah dibahas di awal. </font><font style="vertical-align: inherit;">Tidak ada terminasi 0-C-line - untuk alasan keamanan kami ingin lebih akurat memeriksa apa yang datang kepada kami. </font><font style="vertical-align: inherit;">Kami memiliki dua fungsi standar yang membantu dalam pengurai.</font></font><br>
<br>
<ul>
<li><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: memeriksa alfabet, karakter yang tersedia dalam string, secara dinamis mengkompilasi alfabet yang valid, meskipun diketahui pada tahap kompilasi program.</font></font></li>
<li><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tidak perlu untuk kasus mengkonversi untuk membandingkan </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan </font></font><code>Foo:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dalam kebanyakan kasus </font></font><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, hanya kepatuhan / ketidakpatuhan yang diperlukan </font><font style="vertical-align: inherit;">untuk </font><font style="vertical-align: inherit;">, dan Anda tidak perlu mengetahui posisi di baris tersebut.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mereka bekerja dengan lambat. </font><font style="vertical-align: inherit;">Mari kita lihat tolok ukur dan pahami apa yang salah dengan mereka.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parser cepat</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada beberapa pengurai. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginx adalah parser paling sederhana, parser, yang ketat memeriksa kepatuhan RFC. Ada juga picoHTTPParser (H2O) dan parser Cloudflare. Mereka memproses data lebih cepat, tetapi dapat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://blog.cloudflare.com/improving-pico"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melewati karakter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang tidak diizinkan oleh RFC. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCMESTRI.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parser menggunakan beberapa pendekatan berbeda. Yang pertama adalah instruksi PCMESTRI, yang digunakan dalam pengurai Pico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menetapkan rentang dalam instruksi. Sayangnya, kami dapat memuat 16 karakter atau 8 rentang. Jika rentang hanya terdiri dari satu karakter - ulangi saja. Karena keterbatasan ini, pengurai Pico tidak dapat sepenuhnya memverifikasi kepatuhan RFC, karena RFC memiliki lebih dari 8 rentang di lokasi ini.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ks/x8/m_/ksx8m_ixc0oy3kzucdwzumppaus.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memuat alfabet ke dalam register, memuat string, menjalankan instruksi. Di pintu keluar, kita cepat melihat apakah ada kebetulan atau tidak. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX2 - Pendekatan CloudFlare.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parser CloudFlare, menggunakan AVX2, memproses 32 byte string pada suatu waktu, bukan 16 byte dengan pengurai Pico. Parsing lebih baik di CloudFlare karena ditransfer ke AVX2. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/b8/3j/g1/b83jg1epzz6ec6dllxv1j4a-0lo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memeriksa semua karakter ke spasi di tabel ASCII, semua karakter lebih besar dari 128 dan mengambil rentang di antara mereka. Kode sederhana cepat. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bandingkan PCMESTRI dan AVX2.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagi kami, batas saat ini adalah 1500. Ini adalah ukuran paket maksimum yang datang kepada kami. Kita melihat bahwa kode AVX2 pada data besar jauh lebih cepat daripada pengurai Pico. Tetapi bekerja lebih lambat pada data kecil, karena instruksi lebih berat di AVX2. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/se/5t/c2/se5tc2npli1yed8ypqkdkk3z-pm.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebanding dengan</font></font><code><strong>strspn</strong></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jika kita memutuskan untuk menggunakan </font></font><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, segalanya menjadi lebih buruk, terutama pada data besar. </font><font style="vertical-align: inherit;">Dalam parser "tempur" tidak dapat digunakan </font></font><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bf/08/vq/bf08vqlzni3dcjzxgiuj73zgszo.png"><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencocokan Tempesta lebih cepat dan lebih akurat</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengurai kecepatan kami seperti keduanya. Pada data kecil, ini secepat Pico parser, pada CloudFlare besar. Namun, itu tidak melewati karakter yang tidak valid. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5t/ns/lw/5tnslwsd-ywmrv1d4xaj5_ypwbw.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana pengaturan parser?</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami, sebagai nginx, mendefinisikan array byte dan memeriksa data input olehnya - ini adalah prolog fungsi. Di sini kami bekerja hanya dengan jangka pendek, kami menggunakannya </font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">karena salah prediksi cabang lebih menyakitkan untuk garis pendek daripada panjang. Kami mengambil kode ini. Kami memiliki batas 4 karena baris terakhir - kami harus menulis kondisi yang cukup kuat. Jika kami memproses lebih dari 4 byte, kondisinya akan lebih sulit dan kodenya lebih lambat.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> uri_a[] __attribute__((aligned(<span class="hljs-number">64</span>))) = {
        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<font></font>
        ...<font></font>
        <span class="hljs-comment">// Branch misprediction is more crucial for short strings</span>
        <span class="hljs-keyword">if</span> (likely(len &lt;= <span class="hljs-number">4</span>)) {
                <span class="hljs-keyword">switch</span> (len) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<font></font>
                    c3 = uri_a[s[<span class="hljs-number">3</span>]];
                    <span class="hljs-comment">// fall through to process other chars</span>
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    c2 = uri_a[s[<span class="hljs-number">2</span>]];
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    c1 = uri_a[s[<span class="hljs-number">1</span>]];
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
                }<font></font>
                <span class="hljs-keyword">return</span> (c0 &amp; c1) == <span class="hljs-number">0</span> ? c0 : <span class="hljs-number">2</span> + (c2 ? c2 + c3 : <span class="hljs-number">0</span>);<font></font>
        }</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loop utama dan ekor besar. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam siklus pemrosesan utama, kami membagi data: jika cukup lama, kami memproses 128, 64, 32, atau 16 byte masing-masing. </font><font style="vertical-align: inherit;">Masuk akal untuk memproses masing-masing 128: secara paralel, kami menggunakan beberapa saluran prosesor (beberapa pipa) dan prosesor superscalar.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> ( ; unlikely(s + <span class="hljs-number">128</span> &lt;= end); s += <span class="hljs-number">128</span>) {<font></font>
        n = match_symbols_mask128_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">128</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">64</span> &lt;= end)) {<font></font>
        n = match_symbols_mask64_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">64</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">64</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">32</span> &lt;= end)) {<font></font>
        n = match_symbols_mask32_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">32</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">32</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">16</span> &lt;= end)) {<font></font>
        n = match_symbols_mask16_c(__C.URI_BM128, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">16</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">16</span>;<font></font>
}</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ekor. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhir fungsi mirip dengan awal. </font><font style="vertical-align: inherit;">Jika kita memiliki kurang dari 16 byte, maka kita memproses 4 byte dalam satu lingkaran, dan kemudian tidak lebih dari 3 byte pada akhirnya.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">while</span> (s + <span class="hljs-number">4</span> &lt;= end) {<font></font>
        c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
        c1 = uri_a[s[<span class="hljs-number">1</span>]];<font></font>
        c2 = uri_a[s[<span class="hljs-number">2</span>]];<font></font>
        c3 = uri_a[s[<span class="hljs-number">3</span>]];
        <span class="hljs-keyword">if</span> (!(c0 &amp; c1 &amp; c2 &amp; c3)) {<font></font>
                n = s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str;
                <span class="hljs-keyword">return</span> !(c0 &amp; c1) ? n + c0 : n + <span class="hljs-number">2</span> + (c2 ? c2 + c3 : <span class="hljs-number">0</span>);<font></font>
        }<font></font>
        s += <span class="hljs-number">4</span>;<font></font>
}<font></font>
<font></font>
c0 = c1 = c2 = <span class="hljs-number">0</span>;
<span class="hljs-keyword">switch</span> (end - s) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                c2 = uri_a[s[<span class="hljs-number">2</span>]];
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                c1 = uri_a[s[<span class="hljs-number">1</span>]];
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
}<font></font>
<font></font>
n = s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str;
<span class="hljs-keyword">return</span> !(c0 &amp; c1) ? n + c0 : n + <span class="hljs-number">2</span> + c2;</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memuat topeng bit dan data -</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ini adalah algoritma utama dari tubuh utama fungsi. Kami menyajikan tabel ASCII (seperti pada gambar) dengan 16 baris dan 8 kolom. Pertama, kami menyandikan baris tabel kami di register pertama BM URI: baris pertama dan kedua. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9l/cv/k2/9lcvk2_wg7qs6svdibpx9m1b09c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Simbol aktual yang kami izinkan adalah </font></font><code>0 @ P p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>2 B R q R</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mereka dikodekan sebagai berikut: </font></font><code>b8 = inv(1011 1000) = 0 @ P p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>f8 = inv(1111 1000) = 2 B R q R</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menyandikan dalam urutan terbalik: kita mulai dari 0, karakter layanan pertama tidak diperbolehkan, dan kemudian unit adalah apa yang diizinkan. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atur bit ASCII mask.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Misalnya, sebuah baris muncul </font></font><code>"pr"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: karakter pertama dari baris pertama adalah ASCII, yang kedua dari baris kedua. Kami menjalankan pernyataan acak, yang mengocok baris tabel kami yang disandikan sesuai dengan urutan karakter ini dalam input.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_i/zr/ol/_izrolii19qo5olblx0zzjgq_iu.jpeg"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ID kolom untuk input.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selanjutnya, kami menempatkan kolom tabel ASCII di register yang berbeda. Kemudian kita "melewati" register kolom dan baris, dan kita mendapatkan korespondensi: karakter kita atau tidak. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena kolom adalah 4 bit paling signifikan dari byte, kami bergeser ke kiri. AVX memiliki offset hanya 2 byte, jadi pertama-tama ubah byte, lalu n dengan mask kami untuk mendapatkan bit yang signifikan saja. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d9/xy/xr/d9xyxrmjyplbnhkpwrxbqblians.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengatur Kolom ASCII</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jalankan pengocokan kedua, pindahkan kolom ke posisi yang diinginkan. Dalam kedua kasus, input byte dari kolom terakhir, jadi di posisi pertama dan kedua kita mendapatkan kolom yang sama. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/g1/2s/hxg12sn4xw-qlt7miq97k0pnwgy.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Persimpangan kolom dan barisan topeng</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kami melakukan </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">("lintas" kolom dengan kolom) dan kami mendapatkan bahwa data input valid - hasilnya</font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari persimpangan kolom dan baris bukan nol. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cd/oa/kw/cdoakwgjf-oipltg_xeyyglobn8.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hitung jumlah nol di bagian akhir. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mengumpulkan semuanya dari vektor masuk </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan mengembalikannya ke output - cukup sederhana. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/f9/ci/tl/f9citlkgsjvtxifi9qe3pdxu7su.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sesuaikan huruf. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bekerja dengan tabel ASCII, kami mendapatkan fitur murah: kami menggunakan tabel statis, tetapi tidak ada yang menghalangi kami untuk menanyakan kepada pengguna alfabet apa yang tersedia untuk URI, nama dan nilai header yang berbeda. </font><font style="vertical-align: inherit;">Permintaan HTTP URI dan header menggunakan 8 huruf (plus atau minus) untuk menguraikan satu permintaan HTTP. </font><font style="vertical-align: inherit;">Tabel-tabel ini dapat dimuat ke dalam kode yang sama dan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dibandingkan dalam alfabet tunggal yang ditentukan oleh pengguna, sebuah</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> URI yang valid. </font><font style="vertical-align: inherit;">Jika tidak, ini berbeda.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serangan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beberapa kasus saat ini mungkin bermanfaat. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serangan SSRF dengan BlackHat'17</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ("Era Baru SSRF"): </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://foo@evil.com:80@google.com/</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- simbol ampersand yang tidak mungkin. </font><font style="vertical-align: inherit;">Dalam beberapa aplikasi digunakan, dalam beberapa tidak. </font><font style="vertical-align: inherit;">Tetapi jika Anda tidak menggunakannya, Anda dapat mengecualikannya dari alfabet yang valid dan serangan itu akan diblokir. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RCE-serangan:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> «efektif adalah melakukan serangan injeksi perintah seperti», BSides'16: </font></font><code>User-Agent: ...;echo NAELBD$((26+58))$echo(echo NAELBD)NAELBD...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">User-Agent adalah header statis, tetapi ada kasus serangan RCE ketika beberapa datang </font></font><code>shell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan karakter atipikal untuk User-Agent. </font><font style="vertical-align: inherit;">Kami melindungi diri sendiri kecuali tanda dolar. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Path Relative Timpa</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Kasus terakhir adalah apa yang dimiliki Google pada tahun 2016. </font><font style="vertical-align: inherit;">Kurung kurawal, titik dua, datang ke URI </font></font><code>.../gallery?q=%0a{}*{background:red}/..//apis/howto_guide.html</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini adalah karakter yang tidak mungkin yang dapat dikeluarkan dari alfabet.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strcasecmp ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah kode yang cukup sepele. </font><font style="vertical-align: inherit;">Kami juga membandingkan string 32 byte, masing-masing dua array.</font></font><br>
<br>
<pre><code class="cpp hljs">__m256i CASE = _mm256_set1_epi8(<span class="hljs-number">0x20</span>);<font></font>
<font></font>
<span class="hljs-comment">// Hacker’s Delight for signed comparison: -0x80 for both operands</span>
__m256i A = _mm256_set1_epi8(<span class="hljs-string">'A'</span> – <span class="hljs-number">0x80</span>);<font></font>
__m256i D = _mm256_set1_epi8(<span class="hljs-string">'Z'</span> - <span class="hljs-string">'A'</span> + <span class="hljs-number">1</span> – <span class="hljs-number">0x80</span>);<font></font>
<font></font>
<span class="hljs-comment">// Hacker’s Delight: 'a' &lt;= v &lt;= 'z' to</span>
<span class="hljs-comment">// v - ('a' – 0x80) &lt; 'z' - 'a' + 1 - 0x80</span><font></font>
__m256i sub = _mm256_sub_epi8(str1, A);<font></font>
__m256i cmp_r = _mm256_cmpgt_epi8(D, sub);<font></font>
__m256i lc = _mm256_and_si256(cmp_r, CASE);<font></font>
__m256i vl = _mm256_or_si256(str1, lc);<font></font>
__m256i eq = _mm256_cmpeq_epi8(vl, str2);<font></font>
<span class="hljs-keyword">return</span> ~_mm256_movemask_epi8(eq);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami hanya memberi register satu baris, karena pada baris kedua kami memprogram konstanta dalam parser dalam huruf kecil. </font><font style="vertical-align: inherit;">Karena kami memiliki perbandingan yang signifikan, kami mengurangi 128 dari setiap byte (sebuah trik dari Hacker's Delight). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami juga membandingkan rentang karakter yang valid: apakah kami dapat mendaftar untuk string ini atau tidak, apakah itu huruf atau tidak. </font><font style="vertical-align: inherit;">Pada saat memeriksa ini, alih-alih dua perbandingan dari a ke z, kita hanya dapat menggunakan satu perbandingan (trik dari Hacker's Delight) dan beralih ke konstanta.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kinerja strcasecmp ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tempesta jauh lebih cepat daripada GLIBC, bahkan versi baru (18 atau 19). </font><font style="vertical-align: inherit;">Kode ini </font></font><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">juga menggunakan AVX, tetapi bukan versi kedua. </font><font style="vertical-align: inherit;">AVX2 lebih cepat, jadi Tempesta memiliki kode lebih cepat.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/zi/pb/wxzipbzdsbvge8u_abhsnok-gfa.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPU kernel Linux</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menggunakan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ekstensi prosesor vektor</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - tersedia di kernel. Instruksi vektor diproses oleh modul prosesor FPU. Ini bukan modul prosesor utama, bukan register utama, tetapi cukup produktif. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena itu, ada optimasi di Linux. Jika kita beralih dari kernel ke ruang pengguna dan kembali, kami tidak menyimpan konteks register FPU (XMM, YMM, ZMM): kami mengubah konteks hanya register dari modul prosesor utama. Diasumsikan bahwa kernel OS tidak bekerja dengan ekstensi vektor prosesor. Tetapi jika Anda membutuhkannya, misalnya, kriptografi dapat melakukannya, tetapi perlu menggunakan </font></font><code>fpu_begin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>fpu_end</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyimpan serta memulihkan konteks register FPU:</font></font><br>
<br>
<pre><code class="cpp hljs">__kernel_fpu_begin_bh();<font></font>
memcpy_avx(dst, src, n);<font></font>
__kernel_fpu_end_bh();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah makro asli yang </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyimpan dan mengembalikan status modul prosesor</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang bertanggung jawab untuk register vektor. </font><font style="vertical-align: inherit;">Ini adalah sumber daya yang cukup lambat.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX dan SSE</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum tolok ukur menyimpan dan memulihkan konteks FPU, beberapa kata tentang operasi vektor. </font><font style="vertical-align: inherit;">Mengapa terkadang masuk akal untuk bekerja dengan assembler? </font><font style="vertical-align: inherit;">Terkadang GCC menghasilkan kode suboptimal. </font><font style="vertical-align: inherit;">Masalahnya adalah bahwa pada model prosesor yang lebih lama, ada penalti yang signifikan dari transisi dari SSE ke AVX. </font><font style="vertical-align: inherit;">GCC memiliki kunci baru </font></font><code>vzeroupper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- gunakanlah sehingga tidak menghasilkan instruksi ini </font></font><code>vzeroupper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang menghapus register dan menghapus hukuman ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda perlu menggunakan instruksi ini hanya jika Anda bekerja dengan kode lama yang dikompilasi untuk SSE oleh beberapa pihak ketiga. </font><font style="vertical-align: inherit;">Ini bukan kasus kami dan kami dapat dengan aman membuang instruksi ini.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPU</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memiliki </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vektorisasi otomatis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di prosesor. Ini berarti bahwa dalam kode ruang pengguna mana pun akan ada operasi vektor. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/n9/vy/0w/n9vy0wal4alh1eelo1rbdjabavc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dua proses dalam sistem menggunakan ekstensi prosesor vektor. Ketika proses Anda menuju ke kernel dan kembali, Anda tidak membuang waktu menghemat dan mengembalikan keadaan vektor prosesor. Tetapi jika Anda beralih dari satu ruang pengguna ke yang lain (saklar konteks), maka selain fakta bahwa cache tingkat pertama dinonaktifkan di sana, modul sakelar konteks pada FPU mulai / berakhir juga bekerja dengan buruk. Operasi ini cukup mahal - microbenchmark.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam microbenchmark, semuanya selalu dramatis, tetapi operasinya sangat mahal. </font><font style="vertical-align: inherit;">Oleh karena itu, di ruang pengguna, alihkan konteks untuk waktu yang lama. </font><font style="vertical-align: inherit;">Di kernel, kami tidak memiliki pengalihan konteks, jadi semuanya cepat. </font><font style="vertical-align: inherit;">Kami menyimpan dan mengembalikan prosesor vektor hanya sekali untuk paket yang cukup besar.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intelpocalypse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada awalnya, saya menunjukkan opsi tabel pencarian untuk mengoptimalkan kode switch: proses panjang, enum, kompilasi tabel switch ke dalam array dan ikuti dereferencing ganda dari pointer yang melompati array ini. Ini adalah skenario untuk serangan Spectre yang mengeksploitasi eksekusi spekulatif. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Google memiliki </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel yang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bagus </font><font style="vertical-align: inherit;">tentang bagaimana pointer dereferensi ganda dalam kompiler modern diatur sekarang (sejak awal 2018). Itu tidak bekerja dengan baik. Jika sebelumnya dalam register beberapa alamat disimpan dan kami pergi ke alamat ini, sekarang kami memiliki kode yang berbeda.</font></font><br>
<br>
<pre><code class="cpp hljs">jmp *%r11 <font></font>
    call l1<font></font>
l0: pause<font></font>
    lfence<font></font>
    jmp l0<font></font>
l1: mov %r11, (%rsp)<font></font>
    ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana cara kerjanya? Kami “memanggil” fungsi pada l1, prosesnya masuk ke label ini dan kami membuat peretasan: seolah-olah kita kembali dari fungsi (yang tidak), tetapi kami menulis ulang alamat pengirim. Ketika kita melakukan instruksi </font></font><code>call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">kita menempatkan </font><font style="vertical-align: inherit;">alamat pengirim, alamat saat ini di tumpukan, menulis ulang dengan isi register yang diperlukan dan pergi ke l1. Tetapi prosesor, ketika prefetcher-nya berjalan, melihat bahwa ada fungsi, dan kemudian penghalang. Karena itu, semuanya akan lambat - ia membuang prefetching dan kami menyingkirkan kerentanan Spectre. Kode ini lambat, kinerja turun 15%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Serangan relatif baru berikutnya adalah </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meltdown.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini khusus untuk proses ruang pengguna saja. </font><font style="vertical-align: inherit;">Sangat menyakitkan membaca memori kernel dari ruang pengguna. </font><font style="vertical-align: inherit;">Serangan dicegah oleh Isolasi Kernel Pate Table (KPTI), yang mengkompilasi kernel baru secara default. </font><font style="vertical-align: inherit;">Tetapi KPTI sangat mahal, hingga 30-40% penurunan kinerja ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seperti yang diukur oleh MariaDB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini disebabkan oleh kenyataan bahwa Anda tidak lagi memiliki malas optimasi TLB: ruang alamat kernel dan prosesor sepenuhnya dipisahkan dalam tabel halaman yang berbeda (sebelumnya, malas TLB terus memetakan ruang kernel ke tabel halaman setiap proses). </font><font style="vertical-align: inherit;">Ini menyakitkan untuk ruang pengguna, tetapi tidak untuk Tempesta FW, yang bekerja sepenuhnya di kernel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beberapa tautan bermanfaat:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://natsys-lab.blogspot.com/2014/11/the-fast-finite-state-machine-for-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesin Status Hingga Cepat untuk Parsing HTTP</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://natsys-lab.blogspot.com/2016/10/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemrosesan String HTTP Menggunakan C, SSE4.2 dan AVX2</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kegembiraan hacker</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meltdown dan Specter menyerang dokumen</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Intelpocalypse: goodbye fast system calls</a></li>
</ul><br>
<blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saint HighLoad++</a>        .       , 6   -- (  ,      Saint HighLoad++)  ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> web </a>. <br>
<br>
     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PHP Russia</a>: 13   ,  .       — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KnowledgeConf</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">++</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TechLead Conf</a> —     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  , ,    .<br>
</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id493226/index.html">Cara membaca dan memperbaiki 100.000 baris kode per minggu</a></li>
<li><a href="../id493230/index.html">Google PageSpeed ​​Insights baru yang diberdayakan oleh Lighthouse 6 (beta): periksa kinerja situs Anda</a></li>
<li><a href="../id493232/index.html">Sejarah pekerjaan saya di Open Product LLC</a></li>
<li><a href="../id493234/index.html">ING Meluncurkan Lion: Perpustakaan Komponen Web yang Produktif, Terjangkau, dan Fleksibel</a></li>
<li><a href="../id493236/index.html">Asterisk: batang eksternal dalam status Permintaan Terkirim</a></li>
<li><a href="../id493244/index.html">Apa yang bisa komputer kuantum</a></li>
<li><a href="../id493248/index.html">Webinar "Peluang Winnum untuk Analisis Industri"</a></li>
<li><a href="../id493250/index.html">Apa yang terjadi dengan perjalanan saat ini - dan bagaimana melindungi diri Anda dalam transportasi</a></li>
<li><a href="../id493252/index.html">Pengalaman mengajar di sekolah pengembangan, atau mengapa Anda harus pergi ke sekolah setelah universitas</a></li>
<li><a href="../id493254/index.html">Sistem penyadapan massal penduduk praktis tidak berguna bagi FBI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>