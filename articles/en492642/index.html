<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶Å üöú üßñ Create a scalable and resilient architecture with dynamic microservices üëß üê∑ üöµüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello again. As you know, in March, OTUS launches a completely new course on Architecture and Design Patterns . Ahead of the start of the course, a lo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Create a scalable and resilient architecture with dynamic microservices</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/492642/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello again. </font><font style="vertical-align: inherit;">As you know, in March, OTUS launches a completely new course </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on Architecture and Design Patterns</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ahead of the start of the course, a lot of material has been translated for you about Creating a scalable and resilient architecture using dynamic microservices. </font><font style="vertical-align: inherit;">Enjoy reading!</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/aw/ws/kg/awwskgrciq1fkykr-snivzihfds.png"><br>
<hr><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">annotation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the most important trends in industrial architecture is the use of microservices to the detriment of monolithic architectures that are losing popularity. </font><font style="vertical-align: inherit;">Thanks to the cloud architecture, the deployment of microservice systems is more productive, flexible and cost-effective. </font><font style="vertical-align: inherit;">Be that as it may, many companies have already begun to move from one type of architecture to another, but this is still only in its infancy. </font><font style="vertical-align: inherit;">In this article, we solve problems arising from the need to develop a scalable and fault-tolerant system based on microservices. </font><font style="vertical-align: inherit;">In our experiments, we consider two types of microservices, simple and advanced, and show that the proposed solution is innovative based on its dynamic behavior.</font></font><a name="habracut"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Introduction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In recent decades, the history of programming languages ‚Äã‚Äãand computer science paradigms has been characterized by increased attention to distribution and modularization to improve code reuse and reliability.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There was a need to increase the quantity and quality of software [1]. One of the key factors in clarifying the various disagreements associated with innovative design is the adequacy of using various tools for the design and development of more advanced software systems [2]. Great success in this process has recently been demonstrated by microservice-based systems [3], which are an architectural paradigm focused on various applications (for example, for people with disabilities) [3]. Under the auspices of microservices, interest in architecture and design is growing. Quality attributes (eg, scalability, performance, and error tolerance) or model selection, such as ‚Äúcontractual de service‚Äù [5] or API Gateway,no longer violate the YAGNI principle (‚ÄúYou aren't gonna need it‚Äù - ‚Äúsuffering from BDUF errors‚Äù (‚ÄúBig Design Up Front‚Äù - ‚ÄúLarge-scale design first‚Äù). The main research question that this article intends to answer is how can we develop a system based on microservices with the same simplicity as a monolithic system? And further, starting from the previous topic, how can we create an environment that provides dynamic distribution of computing power between clients? Our research hypothesis suggests using a client-server system architecture that combines distributed computing and microservices to solve these problems.The main research question that this article intends to answer is how can we develop a system based on microservices with the same simplicity as a monolithic system? And further, starting from the previous topic, how can we create an environment that provides dynamic distribution of computing power between clients? Our research hypothesis suggests using a client-server system architecture that combines distributed computing and microservices to solve these problems.The main research question that this article intends to answer is how can we develop a system based on microservices with the same simplicity as a monolithic system? And further, starting from the previous topic, how can we create an environment that provides dynamic distribution of computing power between clients? Our research hypothesis suggests using a client-server system architecture that combines distributed computing and microservices to solve these problems.which provides dynamic distribution of computing power between clients? Our research hypothesis suggests using a client-server system architecture that combines distributed computing and microservices to solve these problems.which provides dynamic distribution of computing power between clients? Our research hypothesis suggests using a client-server system architecture that combines distributed computing and microservices to solve these problems.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The structure of the document is as follows: section 2 provides a brief overview of the current literature explaining the importance of microservices, including two well-known services offered by Azure, and section 3 discusses the proposed architecture. </font><font style="vertical-align: inherit;">Section 4 discusses the evaluation of this system before drawing conclusions in the last section.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Literature review of microservices</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thanks to the cloud architecture, the deployment of microservice systems is more productive, flexible and cost-effective [6]. However, Zimmermann notes that microservices are a sensitive topic that is being studied mainly in academia [7] and industry. The term ‚Äúmicroservices‚Äù was first discussed at a seminar of software architects in Italy in May 2011 to describe what participants saw as a common architectural style recently explored by many of them. A year later, the same group confirmed that the term ‚Äúmicroservices‚Äù is the most appropriate name. In fact, microservices were developed as an answer to problems in monolithic applications or service-oriented architectures that complicate the scalability, complexity and dependencies of the application being developed,together with the use of lightweight communication mechanisms [8-9]. Since the monolith is a software application whose modules cannot be executed independently, we should consider a solution based on microservices, since it is the only one capable of executing instructions independent from each other [10-11]. Large monoliths become problematic to maintain over time and are difficult to evaluate because of their complexity, but the main disadvantage is that they limit the scalability of the product. Another problem is that they do not provide fault tolerance, and do not allow an individual component of the system to work when another component does not work, which is possible in microservice-oriented architectures.Since the monolith is a software application whose modules cannot be executed independently, we should consider a solution based on microservices, since it is the only one capable of executing instructions independent from each other [10-11]. Large monoliths become problematic to maintain over time and are difficult to evaluate because of their complexity, but the main disadvantage is that they limit the scalability of the product. Another problem is that they do not provide fault tolerance, and do not allow an individual component of the system to work when another component does not work, which is possible in microservice-oriented architectures.Since the monolith is a software application whose modules cannot be executed independently, we should consider a solution based on microservices, since it is the only one capable of executing instructions independent from each other [10-11]. Large monoliths become problematic to maintain over time and are difficult to evaluate because of their complexity, but the main disadvantage is that they limit the scalability of the product. Another problem is that they do not provide fault tolerance, and do not allow an individual component of the system to work when another component does not work, which is possible in microservice-oriented architectures.able to execute instructions independent from each other [10-11]. Large monoliths become problematic to maintain over time and are difficult to evaluate because of their complexity, but the main disadvantage is that they limit the scalability of the product. Another problem is that they do not provide fault tolerance, and do not allow an individual component of the system to work when another component does not work, which is possible in microservice-oriented architectures.able to execute instructions independent from each other [10-11]. Large monoliths become problematic to maintain over time and are difficult to evaluate because of their complexity, but the main disadvantage is that they limit the scalability of the product. Another problem is that they do not provide fault tolerance, and do not allow an individual component of the system to work when another component does not work, which is possible in microservice-oriented architectures.and they do not allow an individual component of the system to work when another component does not work, which is possible in microservice-oriented architectures.and they do not allow an individual component of the system to work when another component does not work, which is possible in microservice-oriented architectures.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In SOA (Service Oriented Architecture), the main services are coordinated using two methods: orchestration (where there is a central microservice that will send requests to other services and control the whole process by sending and receiving responses) and choreography (which does not involve any centralization, but each service knows in advance what it should do) [1]. As in the case of monolithic architectures and SOA architectures, the most difficult problem remains the partitioning of the system into services [12]. Also, in no case should one neglect the issue of providing confidential information through uncontrolled distribution of services [13].</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our architecture combines distributed computing with microservices to create an environment that enables dynamic distribution of computing between clients. By distributed computing, we mean the availability of processing and storing large amounts of data in the cloud, which is a key element in the modern industry both inside and outside the IT field. Distributed storage systems are designed to meet the requirements of distributed and computationally advanced applications with wide applicability, scalability and high performance. A well-known solution is MapReduce [14], which orchestrates calculations by sorting distributed servers, while simultaneously managing various tasks, all communications and data transfer between parts of the system,providing redundancy and fault tolerance.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Azure Batch is another programming model used to efficiently run computerized applications in parallel or large-scale mode, without manual configuration or infrastructure management, with more powerful clusters of high performance computing (HPC - high performance computing) [15]. To illustrate these ideas, let us remind you of SaaS (software as a service) or client applications that need wide execution [16]. In fact, various IT companies are showing increased interest in SaaS, being interested in lowering their operating expenses and, as a result, in increasing the flexibility of their business [17]. Another service offered by major cloud service providers is Azure Functions,which allows on-demand launch without the need for explicit provision or management of infrastructure [18].</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It also increases the interest of applications in easily launching small pieces of code or ‚Äúfunctions‚Äù in the cloud. </font><font style="vertical-align: inherit;">The growing interest in the Internet of Things (IoT) makes Azure Functions [19] an excellent solution for data processing, system integration and the creation of simple APIs and microservices.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Methodology</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The structurally proposed system can be divided into 3 different areas: (1) the client - that will perform the tasks assigned by the server; (2) server - an interface with a client, the brain of monolithic applications; (3) a client-server communication management area that encapsulates all the details associated with the transfer of execution from the server to the client. All information transmitted over the network between the client and server is encrypted using the DES (Data Encryption Standard) algorithm, and the key is changed using the Diffie-Hellman protocol [20], which, although it is vulnerable under certain conditions, yet implemented in a variety of Internet security solutions. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1. System architecture</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our system is heavily based on the architecture of dynamic microservice systems. The architecture takes as the basis the client-server, in which the server corresponds to a larger number of clients. Both the server and the client perform web microservices, the communication protocol is HTTP, the data format is JSON. This architecture is useful for distributing and dynamically redistributing resources between clients. Such an architectural model is used to build large, complex and horizontally scalable applications consisting of small, independent and separate processes that interact with each other using the API [21].</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fig. Figure 1 shows how a server distributes functionality packages for its clients. Depending on the number of clients, there may be instructions that will not be assigned to any client, or the same set of instructions assigned to several clients. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yd/-j/hk/yd-jhkvmw4m4mjb0lskder-k9bg.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 1. Distribution of services to customers.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
The application architecture was built using the ASP.NET MVC framework from Microsoft. In the central part, we see server microservices on the server itself, and on the left and right there are many clients waiting to start tasks from the server. The service component of orchestration provides, on the one hand, communication between the server and clients, sending tasks to clients, and on the other hand, it monitors the status of these requests.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This architecture allows one microservice to call another microservice (thus we get an extended (extended) microservice) or to call each other, which can lead to circular dependence, which should be prevented at the user level. </font><font style="vertical-align: inherit;">The client-server communication protocol is carried out in the following steps:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The client connects to the server and initiates a key exchange protocol. </font><font style="vertical-align: inherit;">He will also provide them to the server and port to which they will correspond.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The server notifies the client of the next task to be performed (the task is represented by a pair (microservice, input data)).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The client receives the job, and then notifies the server that the transfer and download have completed either successfully or unsuccessfully.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As soon as the connection between the two objects is established, the server sends the data in JSON format, encrypted using DES, to the client for processing.</font></font></li>
<li>      ( ,       )    JSON,    DES.</li>
<li>      ,         .</li>
<li>         ‚Äî            .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A special case of this interaction is a scenario when a client performs a task for the result of which the result of another client is required. </font><font style="vertical-align: inherit;">For this case, two existing possibilities were evaluated: orchestration and choreography. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the case of choreography, we identified several obstacles: (a) a list of clients available for performing an external task had to be sent by the server to the client, and maintaining this list of updated values ‚Äã‚Äãwould often result in increased load on the information exchange network; </font><font style="vertical-align: inherit;">(b) the communication between the two clients was vulnerable to attacks. </font><font style="vertical-align: inherit;">Two situations were resolved through orchestration. </font><font style="vertical-align: inherit;">In fact, all management care lies with the server, and clients are just simple objects that are easy to work with.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the extended microservices option, the phases of client-client interaction will be as follows:</font></font><br>
<br>
<ol>
<li>          .    ,     .      ,     DES.</li>
<li>  , ,   .   ,    ,  ,    ,         .     ,     (  . .).</li>
<li>      ,       (   ),   ,        .</li>
<li>        .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The client decrypts the result with a one-time password and continues execution.</font></font></li>
</ol><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2. </font><font style="vertical-align: inherit;">Application</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
To test and evaluate this architecture, we implemented several microservices that we called on for what we wanted to check at a time. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_l/ye/uc/_lyeucntwjhoj0xlbenxz4nygjs.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. </font><font style="vertical-align: inherit;">2. The interface. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the first experiment, we used 3 microservices as follows: (1) a microservice that performs a mathematical operation on two numbers (using LibraryMath), (2) a microservice that tells us whether the number is positive (MasterOfNumbers) and (3) an extended microservice, which will call the first microservice when it receives two numbers, and the result will be sent to the second microservice to extract information about this number (UniverseOfSuperMath).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 2 shows how we obtain mathematical calculations using the presented microservices. At the interface level, only the result of a mathematical operation is displayed, the rest of the information can be seen as a result of the server receiving an AJAX call by pressing the equal key (both results are positive). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, we will consider the main functionality of the application, which focuses on what happens when there are one, two or more connected clients. In Figure 3 we see how in our experiments we launched more clients on the local computer, using different ports for each of them. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/94/nq/a9/94nqa9rzhinodyiixedizjaul8m.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 3. The interface.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have 6 fields: ClientToken - a unique token associated with each client (when the call is local and has localhost value); Date - the moment when the request was made; IP &amp; Port = IP address of the client and the port through which communication is made; Function - name of the called function; Success - a boolean flag indicating the success of the call. For example, we notice that on the first call (h: 8:38:21 the client is not connected to the server, the process is performed by the server). At the second call, we observe the dynamic behavior of the system, one of the tasks of which is performed by one of the clients, and the other two are performed by the server. More specifically, UniverserOfSuperMath is called (locally - the client is not available for this task), which, in turn, calls two other microservices, one local and one through a client delegated to use a specific instruction, etc.d.</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fault tolerance</font></font></b></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Another functionality that I took into account when creating this architecture was related to the fault tolerance of the system. Based on the previous scenario, we can observe what happens if one or more clients choose to leave the system.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Figure 3 on the right, the call at 8:46 demonstrates this scenario. Clients on ports 8390 and 8827 have a local or network problem or simply close the connection to the server, and the server does not receive a notification in time to remove them from the list. The server will try to contact clients and run commands, but if they do not respond in a timely manner, the server takes on their tasks and returns the requested result. For confirmation, customers will be requested again after a while, and if they continue to not respond, they will be removed from the list of available customers. The next call (8:47) will no longer uselessly request clients that are no longer available, and tasks that are skipped by available clients will be performed by the server. </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advantages and disadvantages of the proposed solution</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The advantages of this architecture are obvious: low hosting costs, microservices offered in a distributed network are dynamic and automatically scalable (when customers also offer computing power as they increase, the computing power of the system increases).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The limitations should be emphasized equally: when the computing power curve does not match the customer power curve. We also have a restriction on the ability to run this application on any operating system. To do this, we decided to convert an affordable solution from .NET to Java. But this solution has some drawbacks with respect to the original solution (Java offers lower data processing speed and less dynamic packet transfer than we do in .NET). We are currently using this solution because the .Net Core offered by Microsoft for working on several platforms is not yet a mature solution and does not offer all the functions of the standard .NET platform). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3. Client-server components </font></font></b><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3.1. Customer</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this architecture, the client is a Windows Presentation Foundation (WPF) desktop application specifically designed to communicate with the server and perform various tasks received from it. Since the application is an executable file that does not require installation, the operating system must work with the .Net Framework. Essentially, a web microservice will interact with another web microservice. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, the client starts the task scheduler in a parallel thread, which every minute will try to notify the server of its presence. A task can take two states: (1) either there is a task to execute (initialization of the code package has already been completed) - in this case it only notifies the server of its presence; (2) or requires initialization with the server.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initialization with the server includes, first of all, an arbitrary choice of code and port that will start the server, which in turn are sent to it using the Diffie-Hellman key exchange protocol (IKE). As soon as the connection between the two objects is established, the server will notify the client with a package of instructions for installation. The main role of the client is to receive a package of instructions from the server, load it into memory, process the information received from the server, and then return the result obtained by executing this package of instructions. The first step performed by the client is to contact the server for a package of instructions. This package of instructions comes as a ZIP archive.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before extracting this package, delete the previous directory with instructions from the ‚Äúprocess‚Äù folder (if it exists), then extract the new content to this folder and load it into memory. Memory loading starts once, regardless of how many calls the client receives. This is possible because three properties remain unchanged in the session: assembly, methodInfo, and type. Assembly stores a link to the loaded DLL, the methodInfo property contains the method called from the DLL, and type describes the type of the DLL. The install.zip file is a package of instructions received from a server that contains DLLs, XML, images, configuration files, etc., and all compiled code that will be executed in a future process.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This step marks the beginning of communication between the client and server to perform a specific task. </font><font style="vertical-align: inherit;">As soon as the client is successfully initialized to perform a specific task, the server will send only the data packet in encrypted form, which must be processed, and will also wait for a response in encrypted form.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By executing the code received from the server, the system is ‚Äúlocked‚Äù, the client can connect to the databases, call other APIs, in particular, call other clients that execute the same or different instructions. </font><font style="vertical-align: inherit;">The connection is made in the orchestration system, where the server searches for the next available client, requests the result and its response is redirected by the server back to the client. </font><font style="vertical-align: inherit;">This microservice orchestration is called ‚ÄúExtendedService‚Äù, and the only difference at the client level is that the encryption is optimized.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The technical problem was to reinitialize the client with another package of instructions to execute. Since loading memory is static in a special context (web server), this was only possible by restarting the entire process to process DLLs loaded into memory. To do this, we created events in Windows that we run from a web application running in a desktop application. This is necessary because we are dealing with two different contexts in two different threads of execution. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3.2. Server</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The embedded microservice has an ILibraryMath interface, which provides the SimpleMath method, and the interface is implemented by the LibraryMath class. The LibraryMath class extends the universal abstract class MicroCore, which has two corresponding parameters for input and output. Extending this abstract class, the ProcessTask method should be implemented where all the code to be executed is written, and the Run function is called in the extended abstract class to execute this code in the SimpleMath method. Thus, it is possible to define interfaces and methods, not limited to any specific name, but, passing the code through an abstract class, we will get full control over the code, which we can distribute among different clients. Inside this class, we can easily have more functions and imported libraries,if they are grouped in one package.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The next step is to write this interface to SimpleInjector, a library that facilitates the deployment of a dependency injection pattern with loosely coupled components. In addition to recording interleaved classes in the Simple Injector container, in order to break the dependency between application levels (introducing template dependencies), we need to register the class in the microservice storage container, which will be scaled by the application. After this step, we will be able to use the function provided by the interface for the created purpose.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Service1 implements IService1 and extends the abstract MicroCore class, and then registers with MicroContainer.RegisterMicro in this container. It is worth mentioning the existence of APIs available in localohst / DynamicMicros / {Service} through which clients communicate with the server. Important actions available through these APIs: the client connects, the client notifies the server of its activity, the microservices expand, etc. Next, we introduce the MicroCore and MicroContainer classes, which together form the basis of our application.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The MicroCore class is an abstract, universal class and is responsible for calling code from the ProcessTask virtual method. </font><font style="vertical-align: inherit;">This is done by calling the Run method, which in turn calls the public TaskManager method. </font><font style="vertical-align: inherit;">Note that the microservice, in turn, will also call this method. </font><font style="vertical-align: inherit;">When a ZIP package is sent to the client for loading into memory and execution, it is sent with all its dependencies, including this class, which is used to manage the client‚Äôs microservice. </font><font style="vertical-align: inherit;">Execution control includes deserializing / serializing the data packet to send, calling the code itself, calling other APIs, and so on. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Returning to the server side, controlling the execution of the code consists of the following steps:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If it is an ExtendedService call, the server will be called to answer.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If a client is available for the request, it will be sent to him to process the result; </font><font style="vertical-align: inherit;">in the negative case, the server itself will process the data.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We request a client for data processing. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the client has problems, we again ask for confirmation of availability, but send a server response (to avoid downtime and long waiting times).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We register current activity.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The MicroContainer class is the management space for the entire embedded microsystem. </font><font style="vertical-align: inherit;">Here, the clients that connect the application (server) connect, and there are function calls that extend the MicroCore abstract class for ‚Äúadvanced services‚Äù. </font><font style="vertical-align: inherit;">This is a static class in which the list of tasks performed on microservices, the list of connected clients and the list of client tasks that perform these tasks are stored in the dictionary.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When launched, the class will be registered for integration into the microservice using RegisterMicro. This will happen only once during initialization. The AddNewClient method provides us with the registration of a new client, key exchange, registration of the IP address of the server and the port on which it will work. The token received by the new client will be checked before being inserted into the list of clients to confirm its uniqueness. Once the connection with the client is established, the server will call the InstallService method, which packs the data, sends it, and after the client responds, it will be added to the dictionary for this task. The service time that will be allocated to each customer depends on the strategy used. When you start the abstract MicroCore microservice, called both on the server and on the client (with ExtendedService),a request is made for available clients for the requested task using the GetNextClient function. This operation will be performed very often, and its complexity will directly affect the application response time. That is why our approach was to randomly select a client. This is done quickly and from our experiments ensures even distribution of calls.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another option was to implement a round-robin list ‚Äî a solution that has the drawback that in the event of a large client I / O stream, updating the round-robin list will require more time and complexity, which we tried to avoid. The RecordClientError method is called when the client does not respond to the received request. After answering this question, a decision is made to save or delete this client. Clients are uniquely identified by the token code sent by the client during initialization, and each microservice is identified by a namespace and class name. All resources (clients, code) are managed through this unitary unit, which provides support for necessary operations.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regarding system security, measures have been taken to prevent attacks, intercepts, and data protection. All messages sent between the server and clients are encrypted using the symmetric DES key algorithm and the Diffie-Hellman key exchange between the client and the server, which occurs during client initialization. Available clients and running programs are stored in server memory. We chose this solution because, in our opinion, it was the best option, because it provides high speed access to data, information can change very often, and the memory area is very difficult to attack. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4. Dynamic behavior of a microservice system</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First of all, all the computers on which the clients will work can be in the same or in different networks. Two elements are in priority: (a) time spent on data transfer; and (b) the overhead added by the system for data management (e.g., customer search, encryption, decryption, error handling, etc.). We were mainly interested in the behavior of our system in local (LAN) and global (WAN) networks (Fig. 4). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1p/lc/fe/1plcfehcmqd4zkcgmuuuvd07cgq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 4. Record of the system working in a local area network (the first column of logs) and global (the second column of logs).</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Task name column contains all the registrations made by the client call for each task, and the Logs columns are hours and duration in ms for each task processing (on the left in the local network and on the right in the global network). Note that tasks have the longest response time to the first call, after which it decreases. Naturally, because all memory downloads, saving addresses, etc. are usually done on the first call. The first three tasks are simple mathematical operations that are usually performed within milliseconds - the time that is also required for our system.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For a local network, we have an average of 20-30 milliseconds per task, which comes from encryption, logging and transmission over the network (even if it is local). This model of LAN communication is also used in the cloud, where computers are located in the same place (data center), and the communication between them is via fiber optic, the network delay is minimal. The results are shown in fig. 4 in the left column of logs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To test our WAN application, we configured the router to route a call from port 80 to:</font></font><code>http://192.168.1.160/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(network address), and IIS (Internet Information Services) launched the application, and it was accessible from anywhere outside the local network. </font><font style="vertical-align: inherit;">To run the application at the client level, the right to use ports 8000: 9000 (arbitrary ports) was required. </font><font style="vertical-align: inherit;">Clients are arranged at arbitrary points, connection to the public IP been ascertained via API: </font></font><code>https://api.ipify.org/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The results are shown in fig. </font><font style="vertical-align: inherit;">4 in the log column on the right. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the results presented in fig. </font><font style="vertical-align: inherit;">4, the values ‚Äã‚Äãin the right column of the journal are 16-17% higher than the values ‚Äã‚Äãin the left column of the journal for the first three tasks (without communication with other microservices) and ¬± 10% for microservices that downloaded documents from the Internet or interacted with the database on specific server.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Evaluation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this study, we monitored the behavior of the system both in the local network (connecting 5 computers via a wireless network) and in the global network (using the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mihaidm.ddns.net</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> namespace </font><font style="vertical-align: inherit;">), comparing our system with a monolithic system, these operations are performed on the same computer (see table 1). </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table 1. System rating for networks.</font></font></i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calculation (ms)</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">write to database (ms)</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pdf generation (ms)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">localhost</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.458</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15.449</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lan</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.408</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16.415</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wan</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">54</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.826</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">29.309</font></font></td>
</tr>
</tbody></table></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Testing was carried out sequentially on one device with 5 connected clients for network testing. </font><font style="vertical-align: inherit;">Each task was completed 100 times, evaluating the total number of milliseconds in all calls.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It was a product of two numbers as a numerical calculation. A microservice does not interact with other microservices, the amount of information transmitted over the network is small, and the complexity is minimized to strictly study the time spent on server, client, and network management tasks. If the calculation is performed by the server (localhost), it is first checked if there is an available client, and since the client is not connected, the server processes the result. In the following case, the presence of clients in the local network shows the completion of the task in conditions of very fast network operation, and from the processing side, encryption / decryption, finding the client‚Äôs response. For 100 executions, the average time required to complete the operation was 25 ms, which is a promising value considering the flexibility / speed ratio. In case of WAN, the time is twice as longthan in the local network (54 ms), this is due to the encryption process, transport costs, but for the actual execution requires half a millisecond.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another task that we investigated is writing to the database. In particular, the word that will be written to the database is taken as a parameter. We are interested in how quickly the client will contact a database located outside the local area (for this study, the database was located at </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.my.gearhost.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Note that the runtime values ‚Äã‚Äãon LAN and localhost are close. In the global network, the difference is noticeable, because processing, managing data and clients does not take as much time as the range of clients that connects to the database to insert the value.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The last task performed in this study was the creation of a PDF file, our focus was on estimating the transmission time of the data in the system. </font><font style="vertical-align: inherit;">To do this, we download the PDF file from </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.pdf-archive.com/2018/05/14/diploma/diploma.pdf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is loaded into memory. </font><font style="vertical-align: inherit;">The system will write the name to a specific position and return the result (in the form of byte vectors) back to the server. </font><font style="vertical-align: inherit;">For a local host and a local network, a difference of about 1000 ms represents the time required to encrypt and transfer PDF files locally. </font><font style="vertical-align: inherit;">For the WAN, the resulting value is higher because the transmission cost of the byte vector is very high.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Conclusions and future work</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The general and abstract nature of the system architecture, presented in this work on the server side, made design difficult, since the same code is executed by both the server and the client. We can argue that the current architecture is compact, simple, easy to understand and expand; the client can perform the tasks assigned by the server, the server is a monolith and the client interface.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The proposed architecture makes it very easy to create new microservices, which are then automatically integrated into the embedded system. Innovative elements of this architecture: it can be scaled very easily, each new client receives a task from the server in accordance with the strategy pursued (the most expensive tasks, the most common, a combination of the two previously listed or purely just an arbitrary strategy). In fact, we have a monolith with the flexibility of a microservice system. The server processes the dynamic distribution of tasks between clients, providing dynamic scaling based on a number of parameters (the number of calls to the task, its execution time, or a combination thereof).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the future directions takes into account that this system can be successfully integrated into a website or API system with a pronounced applicative character. </font><font style="vertical-align: inherit;">The proposed architecture can be improved and expanded at any time due to availability for several platforms (for example, for mobile phones). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another direction in the future that we are considering is considered extremely attractive today - is that the user provides computing power in exchange for a fee (for example, the BITCOIN system), our application is developed to run microservices on certain computers.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source Link</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This study was published with the support of the POC-A1-A1.2.3-G-2015 program, as part of the PrivateSky project (P_40_371 / 13/01/01/2016) and the README project ‚ÄúInteractive and innovative application for assessing the readability of Romanian texts and improving user writing styles ‚Äù, contract No. </font><font style="vertical-align: inherit;">114/15.09.2017, MySMIS 2014 code 119286.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">References</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[1] Dragoni, N., Giallorenzo, S., Lluch-Lafuente, AL, Mazzara, M., Montesi, F., Mustafin, R. (2017a) "Microservices: Yesterday, Today, and Tomorrow." Mazzara M., Meyer B. (eds.), Present and Ulterior Software Engineering. Springer </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[2] Mazzara, M., Khanda, K., Mustafin, R., Rivera, V., Safina, L. and Silitti, A. (2018) ‚ÄúMicroservices Science and Engineering‚Äù. In: P. Ciancarini, S. Litvinov, A. Messina, A., Sillitti, G. Succi (eds.) Proceedings of the 5th International Conference in Software Engineering for Defense Applications, SEDA 2016, Springer, 10-20.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[3] Dragoni, N., Lanese, I., Larsen, ST, Mazzara, M., Mustafin, R., and Safina, L. (2017b) ‚ÄúMicroservices: How To Make Your Application Scale‚Äù. In: Petrenko A., Voronkov A. (eds.) Perspectives of System Informatics. PSI 2017. Lecture Notes in Computer Science, 10742. Springer, Cham. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[4] Melis, A., Mirri, S., Prandi, C., Prandini, M., Salomoni, P., and Callegati, F. (2016) ‚ÄúA Microservice Architecture Use Case for Persons with Disabilities‚Äù. At the 2nd EAI International Conference on Smart Objects and Technologies for Social Good, DOI: 10.1007 / 978-3-319-61949-1_5. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[5] Zimmermann, O. (2017) ‚ÄúMicroservices Tenets: Agile Approach to Service Development and Deployment, Computer Science - Research and Development‚Äù, 32 (3-4): 301-310.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[6] Xia, C., Zhang, Y., Wang, L, Coleman, S., and Liu, Y. (2018) ‚ÄúMicroservice-based cloud robotics system for intelligent space‚Äù. In: Robotics and Autonomous Systems 110, DOI: 10.1016 / j.robot.2018.10.001. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[7] Bogner, J., Fritzsch, J., Wagner, S., and Zimmermann, A. (2019) ‚ÄúMicroservices in Industry: Insights into Technologies, Characteristics, and Software Quality‚Äù. At the 2019 IEEE International Conference on Software Architecture Workshops (ICSAW) At: Hamburg, Germany. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[8] Akentev, E., Tchitchigin, A., Safina, L., and Mzzara, M. (2017) ‚ÄúVerified type checker for Jolie programming language‚Äù, https: // arXiv.org/pdf/1703.05186.pdf.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[9] ƒåern√Ω, T., Donahoo, MJ, and Trnka, M. (2018) ‚ÄúContextual understanding of microservice architecture: current and future directions‚Äù. ACM SIGAPP Applied Computing Review 17 (4): 29-45, DOI: 10.1145 / 3183628.3183631. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[10] Larucces, X., Santamaria, I., Colomo-Palacios, R., and Ebert, C. (2018) ‚ÄúMicroservices‚Äù. In: IEEE Software, 35/3: 96-100. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[11] Kalske, M. (2017) ‚ÄúTransforming monolithic architecture towards microservice architecture‚Äù. M.Sc. Thesis, Univ. of Helsinki. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[12] Lenarduzzi, V., and Taibi, D. (2016) ‚ÄúMVP Explained: A Systematic Mapping Study on the Definitions of Minimal Viable Product‚Äù. At the 42th Euromicro Conference on Software Engineering and Advanced Applications (SEAA), 112-119.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[13] Taibi, D., Lenarduzzi, V., Janes, A., Liukkunen, K., and Ahmad, MO (2017) ‚ÄúComparing Requirements Decomposition within the Scrum, Scrum with Kanban, XP, and Banana Development Processes‚Äù. In: Baumeister H., Lichter H., Riebisch M. (eds.) Agile Processes in Software Engineering and Extreme Programming. Lecture Notes in Business Information Processing, 283. Springer, Cham. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[14] G√≥mez, A., Benelallam, A., and Tisi, M. (2015) ‚ÄúDecentralized Model Persistence for Distributed Computing‚Äù. At the 3rd BigMDE Workshop, L'Aquila, Italy. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[15] Kandave, KR (2018) ‚ÄúHigh performance computing on Azure‚Äù. Nanette Ray (ed.), AzureCAT, Microsoft Corporation.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[16] Sreenivas, V., SriHarsha, S., and Narasimham, C. (2012) ‚ÄúA Cloud Model to Implement SaaS‚Äù. In: Advanced Materials Research 341-342, Trans Tech Publications, Switzerland, 499-503. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[17] Badidi, E. (2013) ‚ÄúA Framework for Software-As-A-Service Selection and Provisioning‚Äù. In: International Journal of Computer Networks &amp; Communications (IJCNC), 5 (3): 189-200. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[18] Lynn, T., Rosati, P., Lejeune, A., and Emeakaroha, V. (2017) ‚ÄúA Preliminary Review of Enterprise Serverless Cloud Computing (Functionas-a-Service) Platforms‚Äù. At the 2017 IEEE 9th International Conference on Cloud Computing Technology and Science, 162-169. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[19] Adzic, G. and Chatley, R. (2017) ‚ÄúServerless Computing: Economic and Architectural Impact.‚Äù At: ESEC / FSE'17, September 4-8, 2017, Paderborn, Germany, ACM.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[20] Diffie, W. and Hellman, M. (1976) ‚ÄúNew directions in cryptography‚Äù. </font><font style="vertical-align: inherit;">In: IEEE Transactions on, Information Theory, 22 (6): 644‚Äì654. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[21] Kratzke, N. (2015) ‚ÄúAbout Microservices, Containers and their Underestimated Impact on Network Performance‚Äù. </font><font style="vertical-align: inherit;">At the CLOUD Comput. </font><font style="vertical-align: inherit;">2015, 180 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arxiv.org/abs/1710.04049</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Learn more about the course</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en492622/index.html">‚ÄúHey bully, bring whiskey!‚Äù, Or About English words with Irish roots</a></li>
<li><a href="../en492628/index.html">Confidence interval for the number of patients with coronavirus (mortality calculation)</a></li>
<li><a href="../en492632/index.html">Quarantined small business: panic is the enemy of reason</a></li>
<li><a href="../en492636/index.html">What does it mean to be effective?</a></li>
<li><a href="../en492638/index.html">Scaling a Redux app with ducks</a></li>
<li><a href="../en492652/index.html">Card game "Fool" on two M5Stack</a></li>
<li><a href="../en492658/index.html">I went to a remote control - launched a podcast: what to read for beginners - 5 proven books</a></li>
<li><a href="../en492660/index.html">The whole world against coronavirus. Intel Stories</a></li>
<li><a href="../en492662/index.html">How I first streamed a university lecture</a></li>
<li><a href="../en492666/index.html">Maltego Part 4. VK, Instagram, LinkedIN and other fantastic critters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>