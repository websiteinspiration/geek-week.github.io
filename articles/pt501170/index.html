<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚵 ⛩️ 🤜🏿 A melhor maneira de trabalhar com o DOM 👇🏽 👨🏼‍💼 🍖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Enquanto escrevia no Solid , tive a oportunidade de estimar o número de tentativas para otimizar o desempenho em gráficos (benchmarks). 
 
 O DOM é um...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>A melhor maneira de trabalhar com o DOM</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501170/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enquanto escrevia no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solid</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tive a oportunidade de estimar o número de tentativas para otimizar o desempenho em gráficos (benchmarks). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O DOM é um desenvolvimento de gargalo front-end. </font><font style="vertical-align: inherit;">Soluções diferentes podem levar a resultados semelhantes. </font><font style="vertical-align: inherit;">Novas bibliotecas aparecem todas as semanas, incorporando o melhor das anteriores, para fazer a combinação perfeita. </font><font style="vertical-align: inherit;">Depois de algum tempo, meus olhos começam a fugir de uma variedade de soluções. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não me entenda mal. </font><font style="vertical-align: inherit;">Adoro ver novas idéias surgirem, mas todas elas apresentam falhas e, às vezes, acarretam uma perda de conveniência ou produtividade. </font><font style="vertical-align: inherit;">Entendo as consequências dessa decisão, mas quero compartilhar minhas observações. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qual é a maneira mais rápida de trabalhar com o DOM:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dom virtual</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Literais de modelo com a tag </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observáveis ​​refinados</font></font></li>
</ul><a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparação</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O JS Frameworks Benchmark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é o melhor projeto de código aberto para comparar o desempenho das estruturas de UI do JavaScript. </font><font style="vertical-align: inherit;">É melhor executar testes localmente, em vez de usar resultados oficiais. </font><font style="vertical-align: inherit;">Os resultados podem variar de acordo com a máquina. </font><font style="vertical-align: inherit;">Como estou testando em uma máquina fraca, o desempenho diminuirá notavelmente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adotarei as melhores abordagens na renderização de uma árvore DOM para ilustrar a redundância de certas soluções. </font><font style="vertical-align: inherit;">Farei isso usando a capacidade do Solid de suportar diferentes opções de renderização para impor custos à medida que as variáveis ​​mudam e compará-las com resultados semelhantes de outras estruturas. </font><font style="vertical-align: inherit;">Vamos dar uma olhada neles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Variedades de Sólido:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solid</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - versão da estrutura com o configurador de proxy ES2015 sobre as funções de controle de alterações integradas nos modelos de nós DOM clonados. </font><font style="vertical-align: inherit;">Isso é obtido pré-compilando modelos JSX </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(código)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sinais sólidos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - esta versão é igual à anterior, mas sinais brutos são usados ​​em vez de proxies. </font><font style="vertical-align: inherit;">Isso complica o uso da biblioteca, mas no final obtemos um pacote menor e melhor desempenho </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(código)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aceso</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - esta versão não usa a pré-compilação JSX em tempo de execução </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(código)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solid-h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Esta versão usa o HyperScript para criar `document.createElement` em tempo real. </font><font style="vertical-align: inherit;">O restante usa a mesma implementação que Solid </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Code)</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outras bibliotecas:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">domc</a> — -,       DOM     DSL (domain specific language)   HTML,    index.html<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"> (Code)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">surplus</a> —       JSX     `document.createElement`. Solid     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"> (Code)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">ivi </a> —     Inferno,      DOM.   HyperScript Helpers-esque  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"> (Code)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">lit-html</a> —      ,  c  .     Tagged Template Literals   DOM-<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"> (Code)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inferno</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é o mais rápido dos clones React e uma das bibliotecas virtuais mais rápidas do DOM. </font><font style="vertical-align: inherit;">Usa diretivas JSX especiais para obter melhor desempenho </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(código)</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algumas de suas estruturas favoritas podem não estar aqui, mas esta lista exibe versões otimizadas de todas as técnicas que você verá nas estruturas mais populares. </font><font style="vertical-align: inherit;">Você pode vê-lo como um indicador para avaliar os recursos máximos da sua biblioteca. </font><font style="vertical-align: inherit;">Se você estiver interessado em comparar o desempenho de estruturas populares, recomendo este gráfico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comparação, gostaria de adicionar o Web Assembly. </font><font style="vertical-align: inherit;">Infelizmente, no momento da redação deste artigo, os registros WASM eram uma implementação de baunilha sem abstrações de alto nível. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Mais tarde, eles adicionaram wasm-bindgen à estrutura - aprox. Tradutor)</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resultados</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HyperScript (inferno, ivi, sólido-h)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O HyperScript exibe a marcação como uma composição de funções (como h ou React.createElement). </font><font style="vertical-align: inherit;">Por exemplo:</font></font><br>
<br>
<pre><code class="javascript hljs">h(<span class="hljs-string">'div'</span>, {<span class="hljs-attr">id</span>: <span class="hljs-string">'my-element'</span>}, [<font></font>
  h(<span class="hljs-string">'span'</span>, <span class="hljs-string">'Hello'</span>),<font></font>
  h(<span class="hljs-string">'span'</span>, <span class="hljs-string">'John'</span>)<font></font>
])<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As estruturas virtuais do DOM possuem essa propriedade. Mesmo se eles usarem JSX ou outros mecanismos de modelo DSL - ainda serão convertidos para métodos de renderização elemento a elemento. Isso é usado para construir uma árvore DOM virtual para cada ciclo de renderização. Mas, como mostrado aqui, as funções renderizadas podem ser usadas para criar um gráfico de dependência reativa, como no caso de Solid. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1t/lp/av/1tlpavyaaxibat0dsnz84dlgcv4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como você pode ver, as bibliotecas com um DOM virtual são muito mais rápidas. Sólido perde desempenho devido à criação excessiva de um gráfico reativo. Observe a diferença nos pontos de referência # 1, # 2, # 7, # 8, # 9. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uf/jo/ne/ufjonerq7jqkd4r31x3sfwtcy7o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A memória é menos convincente. O Inferno e esta versão do Solid mostram aproximadamente o mesmo resultado. Enquanto o ivi usa mais memória.</font></font><br>
<blockquote>   ,  Solid,  ,    VDOM. Solid            ,     DOM,     DOM. Solid  JSX    DOM .               ,  . Solid  fine grained evaluation    .  -  .<br>
 — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"></a><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As estruturas de rastreamento de atualização reativa mostram melhores resultados ao atualizar linhas. </font><font style="vertical-align: inherit;">Este gráfico explicaria a popularidade do VDOM nos últimos anos. </font><font style="vertical-align: inherit;">Basta dizer que, se você usar o HyperScript com esta atualização, é melhor alternar para o Virtual DOM.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modelos de string (domc, lit-html, solid-lit)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada biblioteca aqui tem algo em comum. Eles são renderizados com base em modelos de elemento de clonagem, executados em tempo de execução e não usam VDOM. Mas eles ainda têm diferenças. O DomC e o lit-html usam diferenças de cima para baixo semelhantes ao Virtual DOM, enquanto o Solid usa um gráfico reativo. O Lit-html divide os modelos em partes. DomC e Solid compilam o modelo em caminhos separados em tempo de execução e os atualizam. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/h3/iu/lv/h3iulvmkhg6y1og6dslnc3pt8i8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta categoria tem a maior variedade de desempenho. O DomC é o mais rápido e o lit-html é o mais lento. Solid Lit está no meio. O DomC demonstra que a simplicidade do código leva ao melhor desempenho. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O DomC afunda apenas na seção 4 porque calcula a diferença de nós, que se torna mais complicada à medida que a profundidade aumenta. É bem rápido, mas você precisa validar os resultados no big data.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solid Lit é mais produtivo que Solid HyperScript. A compilação instantânea em tempo de execução remove as desvantagens de criar um gráfico reativo, permitindo que a estrutura acompanhe o ivi, a biblioteca VDOM mais rápida (consulte a tabela completa no final do artigo). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/0m/h1/vo/0mh1vo1qzvthbjsvsol1mpopdgg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DomC mostrou bons resultados no consumo de memória. Isso aconteceu devido à clonagem dos elementos do modelo. Vale ressaltar que a geração de código em tempo de execução pode ter uma sobrecarga de desempenho mínima em comparação com a compilação no estágio de compilação. Talvez esta seja uma comparação injusta para o lit-html porque a estrutura não usa essa técnica. Mas é justo dizer que bibliotecas lit-html ou similares, como hyperHTML ou lighterHTML, não são a melhor maneira de implementar literais de modelo com tags. E você pode obter bons resultados, mesmo em tempo de execução, sem o VDOM.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSX pré-compilado (sólido, sinais sólidos, excedente)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essas bibliotecas usam JSX, que é compilado em um DOM ou gráfico reativo no estágio de construção. </font><font style="vertical-align: inherit;">Os modelos podem ser qualquer coisa, mas o JSX fornece uma árvore de sintaxe limpa que aprimora a experiência do desenvolvedor. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q5/ik/c7/q5ikc7iohyy8m5lyydzhijzylaq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este grupo tem resultados semelhantes, mas a diferença é muito importante. </font><font style="vertical-align: inherit;">Todos os três utilizam a mesma biblioteca para gerenciar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> estado </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Usando o exemplo de Sinais Sólidos, você pode ver que as funções de rastreamento com clonagem de elementos do modelo oferecem melhor desempenho. </font><font style="vertical-align: inherit;">A implementação padrão do Solid está sobrecarregada usando os Proxies ES2015, o que piora o resultado em todos os gráficos. </font><font style="vertical-align: inherit;">O excedente usa `document.createElement`, que diminui o desempenho em testes nos quais as linhas 1, 2, 7 e 8 são criadas.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fv/7_/by/fv7_bynjjqiyp8u_ss3l0cqsmtc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O consumo de memória tem resultados semelhantes. </font><font style="vertical-align: inherit;">Nesse caso, os proxies adicionam mais complexidade do que os elementos do modelo de clonagem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A conclusão aqui é que os proxies degradam o desempenho e mais bibliotecas devem clonar modelos. </font><font style="vertical-align: inherit;">Por outro lado, você pode considerar uma pequena perda de desempenho devido a proxies como investimento. </font><font style="vertical-align: inherit;">O exemplo Solid possui a menor quantidade de código dentre outros exemplos - apenas 66 linhas, 13% menos espaço em branco que o Svelte - uma biblioteca que se orgulha de seu minimalismo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melhor da classe (domc, ivi, solid-signs, vanillajs)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos pegar os vencedores de cada categoria e compará-los com o exemplo brutal, eficaz e escrito à mão em JavaScript vanilla. Cada implementação representa uma das populares soluções de rastreamento de estado. Você pode até fazer uma analogia entre essas bibliotecas e os Três Grandes: Sólido → Vue, DomC → Angular, ivi → Reagir. Você obterá esse resultado se remover tudo supérfluo, exceto a renderização, e se livrar do código de 60-200kb. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sy/lj/9c/sylj9c8bd1xzzwehg0o-z7mvyei.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O DomC e o Solid estão próximos em termos de desempenho, o ivi está significativamente atrasado, mas o DomC, no geral, é mais rápido. Sua complexidade em comparação com o vanillaJS é notavelmente menor, mas é menos eficaz com atualizações parciais. Somente este critério não é indicativo. Qualquer pessoa que pense que o VDOM é lento ou tem complicações desnecessárias deve verificar isso por conta própria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A maioria das bibliotecas nunca terá esse tipo de desempenho. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mz/zp/bx/mzzpbxqifmdadvbjm3ydk3pxy2a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O DomC também está liderando o gráfico com memória. </font><font style="vertical-align: inherit;">Sólido refinado supera o VDOM ivi em termos de consumo de memória. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Curiosamente, essas bibliotecas não são muito piores que o vanillaJS, independentemente do método. </font><font style="vertical-align: inherit;">Eles são todos muito rápidos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamanho do pacote</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por fim, gostaria de abordar o tamanho do pacote. </font><font style="vertical-align: inherit;">Muitos testes reais se concentram apenas nessas métricas. </font><font style="vertical-align: inherit;">Sim, o tamanho do pacote é importante e tem uma correlação direta com o desempenho, mas qual é a diferença? </font><font style="vertical-align: inherit;">Suspeito que a complexidade do código seja mais importante que o tamanho.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-t/m7/yb/-tm7ybrxshulxxcbcufybomwzjq.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusão</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como sempre, os resultados nesses gráficos nunca são completamente convincentes. O processo em si e as conclusões que tiramos são importantes. Nesse caso, vemos que o próprio DOM é um grande gargalo no que diz respeito ao desempenho. Tanto é assim que não existe uma técnica inequívoca para contorná-lo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ll/7v/qa/ll7vqadwntgwoae6oepqwwbsalc.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Christoper Lambert como o Highlander</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Não, não é assim tão simples. Nem o DOM nem o VDOM são lentos. Mas acredito que eles valem um ao outro. Admito que a retórica do VDOM Performance React me levou a esses pensamentos. A ignorância de opiniões sobre esse tópico é enfurecedora.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A alegação de que o VDOM é lento deve-se à falta de conhecimento. Renderizar VDOM e calcular a diferença de estado é uma complicação comparada a não fazê-lo. Mas sua ausência é escalável? E como fazer alterações nos dados?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vejo que há uma exceção em todas as regras. Em geral, a pré-compilação combinada com granulação fina em estruturas reativas é a solução mais rápida. Mas o DomC mostra alto desempenho sem ele. Métodos JS nativos, como clonagem de elementos de modelo com literais de modelo marcado, podem ser a melhor solução para implementar lit-html de grandes empresas (Google). Mas essa é uma das estruturas mais lentas desta tabela e nem mesmo a melhor implementação dessas tecnologias. Svelte é considerada a biblioteca mais rápida da comunidade, mas não conseguiu nem competir de perto com as soluções apresentadas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se a programação reativa vencer, isso não significa que todas as bibliotecas reativas são rápidas ou que métricas significam tudo. </font><font style="vertical-align: inherit;">Apesar da comparação profunda neste artigo, acho que, na realidade, existem bibliotecas rápidas e lentas. </font><font style="vertical-align: inherit;">Mesmo se encontrarmos super tecnologia, ainda enfrentaremos suas limitações. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultados de teste de todas as bibliotecas em uma tabela:</font></font></b><br>
<br>
<img src="https://habrastorage.org/webt/gg/3u/oq/gg3uoqckygryprsownwet3r12jq.png"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt501158/index.html">Tornando o Android View Binding conveniente com o Kotlin</a></li>
<li><a href="../pt501162/index.html">Comparação de cenas de rap russas usando técnicas de mineração de texto e texto. Noize Mc e Kasta vs Pharaoh and Morgenshtern</a></li>
<li><a href="../pt501164/index.html">Visualização de topologias de rede ou por que outro engenheiro de rede Python # 2</a></li>
<li><a href="../pt501166/index.html">oVirt em 2 horas. Parte 1. Abra a Plataforma de Virtualização de Failover</a></li>
<li><a href="../pt501168/index.html">Os auxiliares se salvam - eles salvam, salvam, queimam?</a></li>
<li><a href="../pt501172/index.html">Meu computador Mikrosh: continue a semana de nostalgia</a></li>
<li><a href="../pt501178/index.html">Como assistir pornô afeta a produtividade do trabalho e estudo</a></li>
<li><a href="../pt501180/index.html">[Pós-pergunta] Você precisa de um movimento de TI para FACTS sobre coronavírus e "efeitos colaterais"</a></li>
<li><a href="../pt501182/index.html">oVirt em 2 horas. Parte 2. Instalando o Gerenciador e os Hosts</a></li>
<li><a href="../pt501184/index.html">Como configurar o Apollo para funcionar com o GraphQL no Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>