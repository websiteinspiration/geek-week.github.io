<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💍 🦍 👕 Continuamos corriendo en plantillas C ++ de varios pisos en RESTinio: una alternativa de tipo seguro al enrutador express-js 👩🏾‍💼 👌 🏡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="RESTinio , nuestro pequeño servidor HTTP incorporado, continúa evolucionando . Una de las características distintivas de RESTinio es que en su impleme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Continuamos corriendo en plantillas C ++ de varios pisos en RESTinio: una alternativa de tipo seguro al enrutador express-js</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/497508/"><p><img src="https://habrastorage.org/webt/bh/ei/td/bheitd3ichxc6a_l2tu_npnbvag.png"></p><br>
<p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RESTinio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nuestro pequeño servidor HTTP incorporado, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continúa evolucionando</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Una de las características distintivas de RESTinio es que en su implementación, las plantillas C ++ de varios pisos se usan activamente (como se mencionó anteriormente: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></p><br>
<p>C++   RESTinio      ,  ,         ,    RESTinio:        ,        .</p><br>
<p>        (   )   ,       run-time.       RESTinio,           ,      .          , <s>    </s>    .</p><br>
<h1 id="easy_parser_router-kak-alternativa-express-router-u">easy_parser_router   express-router-</h1><br>
<h2 id="express-router-i-chto-s-nim-ne-tak">express-router      ?</h2><br>
<p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">ExpressJS</a>    RESTinio  ,   .   ,    ,       . ,  ,    - . , ,      .</p><a name="habracut"></a><br>
<h3 id="podverzhennost-oshibkam-i-opechatkam">   </h3><br>
<p>   express-         . , ,   :</p><br>
<pre><code class="cpp hljs">router-&gt;http_get(<span class="hljs-string">"/api/v1/books/:id"</span>,<font></font>
   [](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; req, <span class="hljs-keyword">auto</span> params) {
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> book_id = restinio::cast_to&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint64_t</span>&gt;(params[<span class="hljs-string">"Id"</span>]);<font></font>
      ...<font></font>
   });</code></pre><br>
<p> ,     ,      "id".       "id" (  ),        "Id" (  ).</p><br>
<p>  —       id.     <code>/api/v1/books/:id</code>   "id"     ,  ,  ,    .</p><br>
<p>,         :</p><br>
<pre><code class="cpp hljs">router-&gt;http_get(<span class="hljs-string">R"(/api/v1/books/:id(\d+))"</span>,<font></font>
   [](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; req, <span class="hljs-keyword">auto</span> params) {
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> book_id = restinio::cast_to&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint64_t</span>&gt;(params[<span class="hljs-string">"id"</span>]);<font></font>
      ...<font></font>
   });</code></pre><br>
<p>     ,  .</p><br>
<p>  ,    "id"       ,         64-  .</p><br>
<p>,       , , :</p><br>
<pre><code class="cpp hljs">router-&gt;http_get(<span class="hljs-string">R"(/api/v1/books/:id(\d{1,10}))"</span>,<font></font>
   [](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; req, <span class="hljs-keyword">auto</span> params) {
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> book_id = restinio::cast_to&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint64_t</span>&gt;(params[<span class="hljs-string">"id"</span>]);<font></font>
      ...<font></font>
   });</code></pre><br>
<p>    ,        run-time. ..,       ,              .</p><br>
<h3 id="otsutstvie-prozrachnosti-i-bezopasnosti-po-tipam">     </h3><br>
<p>  ,            :</p><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">api_v1_handler</span> {</span><font></font>
   ...<font></font>
<span class="hljs-keyword">public</span>:
   <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">on_get_book</span><span class="hljs-params">(
         <span class="hljs-keyword">const</span> restinio::<span class="hljs-keyword">request_handle_t</span> &amp; req,
         restinio::router::<span class="hljs-keyword">route_params_t</span> params)</span>
   </span>{
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> book_id = restinio::cast_to&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint64_t</span>&gt;(params[<span class="hljs-string">"id"</span>]);<font></font>
      ...<font></font>
   }<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">on_get_book_version</span><span class="hljs-params">(
         <span class="hljs-keyword">const</span> restinio::<span class="hljs-keyword">request_handle_t</span> &amp; req,
         restinio::router::<span class="hljs-keyword">route_params_t</span> params)</span>
   </span>{
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> book_id = restinio::cast_to&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint64_t</span>&gt;(params[<span class="hljs-string">"id"</span>]);
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> ver_id = restinio::cast_to&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;(params[<span class="hljs-string">"version"</span>]);<font></font>
      ...<font></font>
   }<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">on_get_author_books</span><span class="hljs-params">(
         <span class="hljs-keyword">const</span> restinio::<span class="hljs-keyword">request_handle_t</span> &amp; req,
         restinio::router::<span class="hljs-keyword">route_params_t</span> params)</span>
   </span>{
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> author = restinio::cast_to&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;(params[<span class="hljs-string">"author"</span>]);<font></font>
      ...<font></font>
   }<font></font>
   ...<font></font>
};</code></pre><br>
<p>  -          -  ,        .</p><br>
<p>       :</p><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> handler = <span class="hljs-built_in">std</span>::make_shared&lt;api_v1_handler&gt;(...);<font></font>
router-&gt;http_get(<span class="hljs-string">R"(/api/v1/books/:id(\d{1,10}))"</span>,<font></font>
   [handler](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; req, <span class="hljs-keyword">auto</span> params) {
      <span class="hljs-keyword">return</span> handler-&gt;on_get_book_version(req, params);<font></font>
   });<font></font>
router-&gt;http_get(<span class="hljs-string">R"(/api/v1/books/:id(\d{1,10})/versions/:version)"</span>,<font></font>
   [handler](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; req, <span class="hljs-keyword">auto</span> params) {
      <span class="hljs-keyword">return</span> handler-&gt;on_get_author_books(req, params);<font></font>
   });<font></font>
router-&gt;http_get(<span class="hljs-string">R"(/api/v1/:author)"</span>,<font></font>
   [handler](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; req, <span class="hljs-keyword">auto</span> params) {
      <span class="hljs-keyword">return</span> handler-&gt;on_get_book(req, params);<font></font>
   });</code></pre><br>
<p>         . ,  ,      .      ,            .</p><br>
<p>,           <code>api_v1_handler</code>.     express-  , ,  :</p><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">api_v1_handler</span> {</span><font></font>
   ...<font></font>
   <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">on_get_book_version</span><span class="hljs-params">(
         <span class="hljs-keyword">const</span> restinio::<span class="hljs-keyword">request_handle_t</span> &amp; req,
         <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint64_t</span> book_id,
         <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp; ver_id)</span> </span>{ ... }<font></font>
   ...<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">auto</span> handler = <span class="hljs-built_in">std</span>::make_shared&lt;api_v1_handler&gt;(...);<font></font>
router-&gt;http_get(<span class="hljs-string">R"(/api/v1/books/:id(\d{1,10})/versions/:version)"</span>,<font></font>
   [handler](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; req, <span class="hljs-keyword">auto</span> params) {
      <span class="hljs-keyword">return</span> handler-&gt;on_get_book_version(req,<font></font>
            restinio::cast_to&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint64_t</span>&gt;(params[<span class="hljs-string">"id"</span>]),<font></font>
            restinio::cast_to&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;(params[<span class="hljs-string">"version"</span>]));<font></font>
   });</code></pre><br>
<p>      .    ,   <em></em>  .     . ,  ,   . </p><br>
<h2 id="easy_parser_router-v-kachestve-alternativy">easy_parser_router   </h2><br>
<p>   0.6.6  RESTinio   express-   <em>easy_parser_router</em>    ,  easy_parser_router      .</p><br>
<p>       "id":</p><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> epr = restinio::router::easy_parser_router;<font></font>
router-&gt;http_get(<font></font>
   epr::path_to_params(<font></font>
      <span class="hljs-string">"/api/v1/books/"</span>,<font></font>
      epr::non_negative_decimal_number_p&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint64_t</span>&gt;()),<font></font>
   [](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; req, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint64_t</span> book_id) {<font></font>
      ...<font></font>
   });</code></pre><br>
<p> ,  ,     HTTP GET ,    <code>api/v1/books/</code>   64-  ,       .       :</p><br>
<ul>
<li> —    <code>restinio::request_handle_t</code>,       ;</li>
<li> —    64-   ,    .</li>
</ul><br>
<p>       ,    URL   book_id      ,      <code>uint64_t</code>,    " "     .</p><br>
<p>   <code>api_v1_handler</code>    .       <code>api_v1_handler</code>:</p><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">api_v1_handler</span> {</span><font></font>
   ...<font></font>
<span class="hljs-keyword">public</span>:
   <span class="hljs-keyword">using</span> book_id_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint64_t</span>;<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">on_get_book</span><span class="hljs-params">(
         <span class="hljs-keyword">const</span> restinio::<span class="hljs-keyword">request_handle_t</span> &amp; req,
         book_id_type book_id)</span> </span>{ ... }<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">on_get_book_version</span><span class="hljs-params">(
         <span class="hljs-keyword">const</span> restinio::<span class="hljs-keyword">request_handle_t</span> &amp; req,
         book_id_type book_id,
         <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp; ver_id)</span> </span>{ ... }<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">on_get_author_books</span><span class="hljs-params">(
         <span class="hljs-keyword">const</span> restinio::<span class="hljs-keyword">request_handle_t</span> &amp; req,
         <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp; author)</span> </span>{ ... }<font></font>
   ...<font></font>
};</code></pre><br>
<p>     -        .         -.</p><br>
<p>         :</p><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> epr = restinio::router::easy_parser_router;<font></font>
<font></font>
<span class="hljs-keyword">auto</span> book_id_p = epr::non_negative_decimal_number_p&lt;api_v1_handler::book_id_type&gt;();
<span class="hljs-keyword">auto</span> ver_id_p = epr::path_fragment_p();
<span class="hljs-keyword">auto</span> author_p = epr::path_fragment_p();<font></font>
<font></font>
<span class="hljs-keyword">auto</span> handler = <span class="hljs-built_in">std</span>::make_shared&lt;api_v1_handler&gt;(...);<font></font>
router-&gt;http_get(<font></font>
   epr::path_to_params(<span class="hljs-string">"/api/v1/books/"</span>, book_id_p),<font></font>
   [handler](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; req, <span class="hljs-keyword">auto</span> book_id) {
      <span class="hljs-keyword">return</span> handler-&gt;on_get_book(req, book_id);<font></font>
   });<font></font>
router-&gt;http_get(<font></font>
   epr::path_to_params(<span class="hljs-string">"/api/v1/books/"</span>, book_id_p, <span class="hljs-string">"/versions/"</span>, ver_id_p),<font></font>
   [handler](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; req, <span class="hljs-keyword">auto</span> book_id, <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; ver_id) {
      <span class="hljs-keyword">return</span> handler-&gt;on_get_book_version(req, book_id, ver_id);<font></font>
   });<font></font>
router-&gt;http_get(<font></font>
   epr::path_to_params(<span class="hljs-string">"/api/v1/"</span>, author_p),<font></font>
   [handler](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; req, <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; author) {
      <span class="hljs-keyword">return</span> handler-&gt;on_get_author_books(req, author);<font></font>
   });</code></pre><br>
<p>       <code>on_get_book</code> ,   <code>on_get_author_books</code>.</p><br>
<h3 id="ves-fokus-v-path_to_params-ili-v-path_to_tuple">   path_to_params.   path_to_tuple</h3><br>
<p> ,   easy_parser_router-,     <code>path_to_params</code>,      .  variadic template ,       ,  .. <em>producer</em>-.</p><br>
<p>   <code>path_to_params</code>   -.   ,    path  URL,     HTTP-.</p><br>
<p>   URL      path . ,    <code>path_to_params</code> -producer    . ,   <code>path_to_params</code>   producer,          .    producer-,  .  ,  .  ..    <code>path_to_params</code>     producer-,   , ,    :</p><br>
<pre><code class="cpp hljs">router-&gt;http_get(epr::path_to_params(<span class="hljs-string">"/"</span>), [](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; req) {...});</code></pre><br>
<p>          .</p><br>
<p> ,  ,    <code>path_to_params</code>  —     URL  HTTP-      .</p><br>
<p>    <code>path_to_params</code>  —             . ..,   <code>path_to_params</code>    producer-,   :</p><br>
<pre><code class="cpp hljs">router-&gt;http_get(<font></font>
   epr::path_to_params(<span class="hljs-string">"/api/v1/books/"</span>, book_id_p, <span class="hljs-string">"/versions/"</span>, ver_id_p),<font></font>
   [handler](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; req, <span class="hljs-keyword">auto</span> book_id, <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; ver_id) {
      <span class="hljs-keyword">return</span> handler-&gt;on_get_book_version(req, book_id, ver_id);<font></font>
   });</code></pre><br>
<p> ,   producer-,       .     -   :    —     <code>restinio::request_handle_t</code>,    —    producer-.</p><br>
<p> ,           -  ,   <code>path_to_params</code>   <code>path_to_tuple</code>.  <code>path_to_tuple</code>  <code>path_to_params</code>   ,  <code>path_to_tuple</code>    producer-        . :</p><br>
<pre><code class="cpp hljs">router-&gt;http_get(<font></font>
   epr::path_to_tuple(<span class="hljs-string">"/api/v1/books/"</span>, book_id_p, <span class="hljs-string">"/versions/"</span>, ver_id_p),<font></font>
   [handler](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; req, <span class="hljs-built_in">std</span>::tuple&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint64_t</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; params) {
      <span class="hljs-keyword">return</span> handler-&gt;on_get_book_version(req, <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">0</span>&gt;(params), <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">1</span>&gt;(params));<font></font>
   });</code></pre><br>
<h2 id="chto-oznachaet-easy_parser-v-nazvanii-easy_parser_router">  easy_parser   easy_parser_router?</h2><br>
<p>  ,    RESTinio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://stiffstream.com/en/docs/restinio/0.6/workingwithheader.html&amp;usg=ALkJrhiT2V5GSS-Dl-p9Dxgdj1kymNZG3A#helpers-for-parsing-values-of-" rel="nofollow">   HTTP-</a>,  RESTinio       easy_parser.         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Parsing Expression Grammar (PEG)</a>,    PEG-   C++ DSL. , ,   :</p><br>
<pre><code class="plaintext hljs">limit = "limit" [SPACE] ":" [SPACE] NUMBER SPACE "bytes"</code></pre><br>
<p>    "limit:4096 bytes"  "limit: 4096 bytes",  easy_parser-     :</p><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> restinio::easy_parser;
<span class="hljs-keyword">auto</span> parser = produce&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt;(<font></font>
   exact(<span class="hljs-string">"limit"</span>),<font></font>
   maybe(space()),<font></font>
   symbol(<span class="hljs-string">':'</span>),<font></font>
   maybe(space()),<font></font>
   non_negative_decimal_number_p&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt;(),<font></font>
   space(),<font></font>
   exact(<span class="hljs-string">"bytes"</span>));</code></pre><br>
<p>    , ,    ,    <code>unsigned int</code>.</p><br>
<p> easy_parser_router  RESTinio-0.6.6    easy_parser-.   easy_parser_router     easy_parser-      -    URL,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">  easy_parser-</a>.</p><br>
<p> ,           easy_parser,  ,    easy_parser_router-     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">- long_output</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>.</p><br>
<p>   :   GET-  URL  <code>/</code>, <code>/&lt;size&gt;</code>  <code>/&lt;size&gt;/&lt;count&gt;</code>,  <code>&lt;size&gt;</code>  <code>&lt;count&gt;</code>         . , URL <code>/512k/1024</code> ,       1024   512KiB .  URL <code>/1200/500</code> ,       500   1200 .</p><br>
<p>  express-      URL    :</p><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-title">extract_chunk_size</span><span class="hljs-params">(<span class="hljs-keyword">const</span> restinio::router::<span class="hljs-keyword">route_params_t</span> &amp; params)</span> </span>{
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> multiplier = [](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> sv) <span class="hljs-keyword">noexcept</span> -&gt; <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> {
      <span class="hljs-keyword">if</span>(sv.empty() || <span class="hljs-string">"B"</span> == sv || <span class="hljs-string">"b"</span> == sv) <span class="hljs-keyword">return</span> <span class="hljs-number">1u</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">"K"</span> == sv || <span class="hljs-string">"k"</span> == sv) <span class="hljs-keyword">return</span> <span class="hljs-number">1024u</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1024u</span>*<span class="hljs-number">1024u</span>;<font></font>
   };<font></font>
<font></font>
   <span class="hljs-keyword">return</span> restinio::cast_to&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>&gt;(params[<span class="hljs-string">"value"</span>]) *<font></font>
         multiplier(params[<span class="hljs-string">"multiplier"</span>]);<font></font>
}<font></font>
...<font></font>
<span class="hljs-keyword">auto</span> router = <span class="hljs-built_in">std</span>::make_unique&lt;<span class="hljs-keyword">router_t</span>&gt;();<font></font>
<font></font>
router-&gt;http_get(<span class="hljs-string">"/"</span>, [&amp;ctx](<span class="hljs-keyword">auto</span> req, <span class="hljs-keyword">auto</span>) {...});<font></font>
<font></font>
router-&gt;http_get(<font></font>
         <span class="hljs-string">R"(/:value(\d+):multiplier([MmKkBb]?))"</span>,<font></font>
         [&amp;ctx](<span class="hljs-keyword">auto</span> req, <span class="hljs-keyword">auto</span> params) {<font></font>
<font></font>
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> chunk_size = extract_chunk_size(params);<font></font>
      ...<font></font>
   });<font></font>
<font></font>
router-&gt;http_get(<font></font>
         <span class="hljs-string">R"(/:value(\d+):multiplier([MmKkBb]?)/:count(\d+))"</span>,<font></font>
         [&amp;ctx](<span class="hljs-keyword">auto</span> req, <span class="hljs-keyword">auto</span> params) {<font></font>
<font></font>
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> chunk_size = extract_chunk_size(params);
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> count = restinio::cast_to&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>&gt;(params[<span class="hljs-string">"count"</span>]);<font></font>
      ...<font></font>
   });</code></pre><br>
<p>   easy_parser_router-      :</p><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> restinio::router::easy_parser_router;<font></font>
<font></font>
<span class="hljs-keyword">auto</span> router = <span class="hljs-built_in">std</span>::make_unique&lt;<span class="hljs-keyword">router_t</span>&gt;();<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">distribution_params</span>
{</span>
   <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> chunk_size_{<span class="hljs-number">100u</span>*<span class="hljs-number">1024u</span>};
   <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_{<span class="hljs-number">10000u</span>};<font></font>
};<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">chunk_size</span> {</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> c_{<span class="hljs-number">1u</span>}, m_{<span class="hljs-number">1u</span>}; };<font></font>
<font></font>
router-&gt;http_get(<font></font>
   path_to_params(<font></font>
      produce&lt;distribution_params&gt;(<font></font>
         exact(<span class="hljs-string">"/"</span>),<font></font>
         maybe(<font></font>
            produce&lt;chunk_size&gt;(<font></font>
               non_negative_decimal_number_p&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;()<font></font>
                  &gt;&gt; &amp;chunk_size::c_,<font></font>
               maybe(<font></font>
                  produce&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;(<font></font>
                     alternatives(<font></font>
                        caseless_symbol_p(<span class="hljs-string">'b'</span>) &gt;&gt; just_result(<span class="hljs-number">1u</span>),<font></font>
                        caseless_symbol_p(<span class="hljs-string">'k'</span>) &gt;&gt; just_result(<span class="hljs-number">1024u</span>),<font></font>
                        caseless_symbol_p(<span class="hljs-string">'m'</span>) &gt;&gt; just_result(<span class="hljs-number">1024u</span> * <span class="hljs-number">1024u</span>)<font></font>
                     )<font></font>
                  ) &gt;&gt; &amp;chunk_size::m_<font></font>
               )<font></font>
            ) &gt;&gt; convert(<font></font>
                  [](<span class="hljs-keyword">auto</span> cs) { <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>{cs.c_} * cs.m_; })<font></font>
               &gt;&gt; &amp;distribution_params::chunk_size_,<font></font>
            maybe(<font></font>
               exact(<span class="hljs-string">"/"</span>),<font></font>
               non_negative_decimal_number_p&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>&gt;()<font></font>
                  &gt;&gt; &amp;distribution_params::count_<font></font>
            )<font></font>
         )<font></font>
      )<font></font>
   ),<font></font>
   [&amp;ctx](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; req, <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; params ) { ... });</code></pre><br>
<p>..      URL     URL.   URL   PEG-:</p><br>
<pre><code class="plaintext hljs">path = "/" [NUMBER [((B|b) | (K|k) | (M|m))] ["/" NUMBER]]</code></pre><br>
<p> C++    ,      PEG-    <code>distribution_params</code>,     :         .     C++    ,          <code>b</code>, <code>k</code>  <code>m</code>.</p><br>
<p>    easy_parser  , ,  ,   . ...</p><br>
<p>-,   .  ,      ( ,  ).  ,        PEG-         "        ,       ".</p><br>
<p>-,    easy_parser,       easy_parser_router-      .    —    ,   .  ,   , don't shoot the pianist…    ,   -  ,        DSL   C++14,  , .</p><br>
<p>  ,      <code>produce</code>, <code>maybe</code>, <code>alternatives</code>, <code>just_result</code>, <code>convert</code>  .  .      .    - ,    .      easy_parser-  ,     .        ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">  </a>.</p><br>
<h1 id="neskolko-detaley-realizacii-iz-pod-kapota-easy_parser-a-i-easy_parser_router-a">      easy_parser-  easy_parser_router-</h1><br>
<p>             easy_parser  easy_parser_router,         "       C++  ".  ,    -    C++, , ,         ,     .</p><br>
<h2 id="shablony-result_value_wrapper-i-result_wrapper_for"> result_value_wrapper  result_wrapper_for</h2><br>
<p>  easy_parser-   ,     PEG-  - .    DSL easy_parser- —    <code>produce</code>:</p><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Target_Type, <span class="hljs-keyword">typename</span>... Clauses&gt;
<span class="hljs-keyword">auto</span> <span class="hljs-title">produce</span><span class="hljs-params">(Clauses &amp;&amp;... clauses)</span></span>;</code></pre><br>
<p>  <code>Target_Type</code>       ,       .    <code>Clauses</code>  .</p><br>
<p>     ,       - :</p><br>
<pre><code class="cpp hljs"><span class="hljs-comment">// :</span>
<span class="hljs-comment">// kv = key "-&gt;" value</span>
<span class="hljs-comment">// key = NUMBER</span>
<span class="hljs-comment">// value = NUMBER</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KV</span>{</span> <span class="hljs-keyword">int</span> key; <span class="hljs-keyword">int</span> value; };<font></font>
produce&lt;KV&gt;(<font></font>
   decimal_number_p&lt;<span class="hljs-keyword">int</span>&gt;() &gt;&gt; &amp;KV::key,<font></font>
   exact(<span class="hljs-string">"-&gt;"</span>),<font></font>
   decimal_number_p&lt;<span class="hljs-keyword">int</span>&gt;() &gt;&gt; &amp;KV::value);</code></pre><br>
<p>      :</p><br>
<pre><code class="cpp hljs"><span class="hljs-function">expected&lt;KV, <span class="hljs-keyword">parsing_error_t</span>&gt;
<span class="hljs-title">try_produce_KV_</span><span class="hljs-params">(impl::<span class="hljs-keyword">input_t</span> &amp; from)</span> </span>{<font></font>
   KV result_value;<font></font>
   {<font></font>
      impl::<span class="hljs-keyword">decimal_number_producer_t</span>&lt;<span class="hljs-keyword">int</span>&gt; p;
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> r = p.try_produce(from);
      <span class="hljs-keyword">if</span>(!r) <span class="hljs-keyword">return</span> make_unexpected(r.error());<font></font>
      impl::<span class="hljs-keyword">field_setter_consumer_t</span>&lt;&amp;KV::key&gt; consumer;<font></font>
      consumer.consume(result_value, *r); <span class="hljs-comment">// result_value.key = *r;</span><font></font>
   }<font></font>
   {<font></font>
      impl::<span class="hljs-keyword">exact_clause_t</span> c{<span class="hljs-string">"-&gt;"</span>};
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> r = c.try_process(from, result_value);
      <span class="hljs-keyword">if</span>(r) <span class="hljs-keyword">return</span> make_unexpected(*r);<font></font>
   }<font></font>
   {<font></font>
      impl::<span class="hljs-keyword">decimal_number_producer_t</span>&lt;<span class="hljs-keyword">int</span>&gt; p;
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> r = p.try_produce(from);
      <span class="hljs-keyword">if</span>(!r) <span class="hljs-keyword">return</span> make_unexpected(r.error());<font></font>
      impl::<span class="hljs-keyword">field_setter_consumer_t</span>&lt;&amp;KV::value&gt; consumer;<font></font>
      consumer.consume(result_value, *r); <span class="hljs-comment">// result_value.value = *r;</span><font></font>
   }<font></font>
   <span class="hljs-keyword">return</span> result_value;<font></font>
}</code></pre><br>
<p>.. ,   <code>produce&lt;KV&gt;(clauses...)</code>,      <code>KV</code>,     <code>clauses</code>.    <code>clauses</code>   ,         <code>produce&lt;KV&gt;</code>.</p><br>
<p>      ,    <code>produce&lt;T&gt;</code>  <code>T</code> —  -  <code>int</code>  <code>long</code>,  - .    <code>T</code>     . ,   - :</p><br>
<pre><code class="cpp hljs"><span class="hljs-comment">// :</span>
<span class="hljs-comment">// keys_values = (kv [","])+</span>
<span class="hljs-comment">// kv = key "-&gt;" value</span>
<span class="hljs-comment">// key = NUMBER</span>
<span class="hljs-comment">// value = NUMBER</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KV</span>{</span> <span class="hljs-keyword">int</span> key; <span class="hljs-keyword">int</span> value; };<font></font>
produce&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;KV&gt;&gt;(<font></font>
   repeat(<span class="hljs-number">1</span>, N,<font></font>
      produce&lt;KV&gt;(<font></font>
         decimal_number_p&lt;<span class="hljs-keyword">int</span>&gt;() &gt;&gt; &amp;KV::key,<font></font>
         exact(<span class="hljs-string">"-&gt;"</span>),<font></font>
         decimal_number_p&lt;<span class="hljs-keyword">int</span>&gt;() &gt;&gt; &amp;KV::value<font></font>
      ) &gt;&gt; to_container(),<font></font>
      maybe(exact(<span class="hljs-string">","</span>))<font></font>
   ));</code></pre><br>
<p>..         <code>KV</code>,        <code>std::vector&lt;KV&gt;</code>.</p><br>
<p>           DSL-  easy_parser_router-  .</p><br>
<p> () ,   , ,  , "   ",     "      "  . , ,  ,  <code>std::vector</code>  <code>std::string</code>.</p><br>
<p>   <code>std::array</code>,     ,     .       - :</p><br>
<pre><code class="cpp hljs">produce&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">char</span>, 8&gt;&gt;(<font></font>
   repeat(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, hexdigit_p() &gt;&gt; to_container()));</code></pre><br>
<p>   :   ,          <code>std::array&lt;char, 8&gt;</code>?</p><br>
<p>  <code>produce&lt;std::array&lt;char, 8&gt;&gt;</code>    <code>std::array&lt;char, 8&gt;</code>,    .</p><br>
<p>   ,  <code>std::array</code>      ,   -  .    <code>std::vector</code>  <code>std::string</code>      .</p><br>
<p> <code>result_value_wrapper</code>    easy_parser    ,  <code>produce&lt;T&gt;(clauses...)</code> ,      <code>produce</code>     <code>clauses</code>. ..  <code>produce&lt;T&gt;(...)</code>      - :</p><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">expected_t</span>&lt;T, <span class="hljs-keyword">parsing_error_t</span>&gt;
<span class="hljs-title">try_produce_T_</span><span class="hljs-params">(impl::<span class="hljs-keyword">input_t</span> &amp; from)</span> </span>{
   <span class="hljs-keyword">typename</span> result_value_wrapper&lt;T&gt;::wrapped_type result_value;<font></font>
   ...<font></font>
   <span class="hljs-keyword">return</span> result_value_wrapper&lt;T&gt;::unwrap_value(result_value);<font></font>
}</code></pre><br>
<p> easy_parser-  <code>result_value_wrapper</code>   . ,   <code>std::vector</code>:</p><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args &gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">result_value_wrapper</span>&lt; std::vector&lt; T, Args... &gt; &gt;
{</span>
   <span class="hljs-keyword">using</span> result_type = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt; T, Args... &gt;;
   <span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> result_type::value_type;
   <span class="hljs-keyword">using</span> wrapped_type = result_type;<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>
   <span class="hljs-title">as_result</span><span class="hljs-params">( wrapped_type &amp; to, result_type &amp;&amp; what )</span>
   </span>{<font></font>
      to = <span class="hljs-built_in">std</span>::move(what);<font></font>
   }<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>
   <span class="hljs-title">to_container</span><span class="hljs-params">( wrapped_type &amp; to, value_type &amp;&amp; what )</span>
   </span>{<font></font>
      to.push_back( <span class="hljs-built_in">std</span>::move(what) );<font></font>
   }<font></font>
<font></font>
   <span class="hljs-function">RESTINIO_NODISCARD
   <span class="hljs-keyword">static</span> result_type &amp;&amp;
   <span class="hljs-title">unwrap_value</span><span class="hljs-params">( wrapped_type &amp; v )</span>
   </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::move(v);<font></font>
   }<font></font>
};</code></pre><br>
<p>, ,   <code>std::array</code>:</p><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> impl<font></font>
{<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> S &gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">std_array_wrapper</span>
{</span>
   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt; T, S &gt; m_array;
   <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> m_index{ <span class="hljs-number">0u</span> };<font></font>
};<font></font>
<font></font>
} <span class="hljs-comment">/* namespace impl */</span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> S &gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">result_value_wrapper</span>&lt; std::array&lt; T, S &gt; &gt;
{</span>
   <span class="hljs-keyword">using</span> result_type = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt; T, S &gt;;
   <span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> result_type::value_type;
   <span class="hljs-keyword">using</span> wrapped_type = impl::std_array_wrapper&lt; T, S &gt;;<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>
   <span class="hljs-title">as_result</span><span class="hljs-params">( wrapped_type &amp; to, result_type &amp;&amp; what )</span>
   </span>{<font></font>
      to.m_array = <span class="hljs-built_in">std</span>::move(what);<font></font>
      to.m_index = <span class="hljs-number">0u</span>;<font></font>
   }<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>
   <span class="hljs-title">to_container</span><span class="hljs-params">( wrapped_type &amp; to, value_type &amp;&amp; what )</span>
   </span>{
      <span class="hljs-keyword">if</span>( to.m_index &gt;= S ) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">exception_t</span>(...);<font></font>
<font></font>
      to.m_array[ to.m_index ] = <span class="hljs-built_in">std</span>::move(what);<font></font>
      ++to.m_index;<font></font>
   }<font></font>
<font></font>
   <span class="hljs-function">RESTINIO_NODISCARD
   <span class="hljs-keyword">static</span> result_type &amp;&amp;
   <span class="hljs-title">unwrap_value</span><span class="hljs-params">( wrapped_type &amp; v )</span>
   </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::move(v.m_array);<font></font>
   }<font></font>
};</code></pre><br>
<p>    <code>produce&lt;std::vector&lt;T&gt;&gt;(...)</code>    <code>std::vector&lt;T&gt;</code>,    <code>produce&lt;std::array&lt;T, 10&gt;&gt;(...)</code>   <code>impl::std_array_wrapper&lt;T, 10&gt;</code>.</p><br>
<p>,   <code>result_value_wrapper</code>        .          <code>produce</code>:</p><br>
<pre><code class="cpp hljs"><span class="hljs-function">expected&lt;KV, <span class="hljs-keyword">parsing_error_t</span>&gt;
<span class="hljs-title">try_produce_KV_</span><span class="hljs-params">(impl::<span class="hljs-keyword">input_t</span> &amp; from)</span> </span>{
   <span class="hljs-keyword">typename</span> result_value_wrapper&lt;KV&gt;::wrapped_type result_value;<font></font>
   {<font></font>
      impl::<span class="hljs-keyword">decimal_number_producer_t</span>&lt;<span class="hljs-keyword">int</span>&gt; p;
      <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> r = p.try_produce(from);
      <span class="hljs-keyword">if</span>(!r) <span class="hljs-keyword">return</span> make_unexpected(r.error());<font></font>
      impl::<span class="hljs-keyword">field_setter_consumer_t</span>&lt;&amp;KV::key&gt; consumer;<font></font>
      consumer.consume(result_value, *r); <span class="hljs-comment">// (1)</span><font></font>
   }<font></font>
   ...<font></font>
}</code></pre><br>
<p>  (1)   <code>consume</code>    <code>result_value_wrapper&lt;KV&gt;::wrapped_type</code>.     <code>consume</code>   ,   .      <code>KV</code>,       -   <code>KV</code>.   <code>consume</code>      .</p><br>
<p>    ""    <code>result_wrapper_for</code>,    <code>wrapped_type</code>    <code>result_value_wrapper</code>.     <code>consume</code>   :</p><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">typename</span> Target_Type, <span class="hljs-keyword">typename</span> Value &gt;
<span class="hljs-keyword">void</span>
<span class="hljs-title">consume</span><span class="hljs-params">( Target_Type &amp; dest, Value &amp;&amp; src )</span> <span class="hljs-keyword">const</span>
</span>{
   <span class="hljs-keyword">using</span> W = <span class="hljs-keyword">typename</span> result_wrapper_for&lt;Target_Type&gt;::type;<font></font>
   W::as_result( dest, <span class="hljs-built_in">std</span>::forward&lt;Value&gt;(src) );<font></font>
}</code></pre><br>
<p>,  -  <code>result_value_wrapper</code>     <code>wrapped_type</code>,   <code>result_type</code>,      <code>result_wrapper_for</code>:</p><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> S &gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">result_wrapper_for</span>&lt; impl::std_array_wrapper&lt;T, S&gt; &gt;
{</span>
   <span class="hljs-keyword">using</span> type = result_value_wrapper&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt; T, S &gt; &gt;;<font></font>
};</code></pre><br>
<p>,    <code>consume&lt;Target_Type, Value&gt;()</code>   <code>Target_Type</code>  <code>impl::std_array_wrapper&lt;T, S&gt;</code> (    <code>wrapped_type</code>  <code>std::array</code>),  <code>consume</code> ,     <code>result_value_wrapper&lt;std::array&lt;T, S&gt;&gt;</code>     <code>Target_Type</code>.</p><br>
<h2 id="transformer_proxy">transformer_proxy</h2><br>
<p> easy_parser   ,     :</p><br>
<ul>
<li><strong>producer</strong>  - ;</li>
<li><strong>transformer</strong>   producer- .   transformer-     , , <code>producer() &gt;&gt; transformer_one() &gt;&gt; transformer_two() &gt;&gt; transformer_three()</code>. .. transformer     <code>&gt;&gt;</code>,       producer,  transformer.       transformer,  consumer;</li>
<li><strong>consumer</strong> ""  producer- . ,   -.   consumer     <code>&gt;&gt;</code>     producer,  transformer,       . .. consumer    <code>&gt;&gt;</code>;</li>
<li><strong>clause</strong>.     <code>producer() &gt;&gt; ... &gt;&gt; consumer()</code>,     clause,     ,  .</li>
</ul><br>
<p>       . ,  ,     producer-  transformer-,      <code>result_type</code>.</p><br>
<p>  easy_parser-       ( <code>to_lower</code>  )   <code>result_type</code>  ,   ,   .</p><br>
<p>       <code>convert</code> (       <code>map</code>):     (),      .   <code>convert</code>     :</p><br>
<pre><code class="cpp hljs">produce&lt;chunk_size&gt;(<font></font>
   non_negative_decimal_number_p&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;()<font></font>
      &gt;&gt; &amp;chunk_size::c_,<font></font>
   maybe(<font></font>
      produce&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;(<font></font>
         alternatives(<font></font>
            caseless_symbol_p(<span class="hljs-string">'b'</span>) &gt;&gt; just_result(<span class="hljs-number">1u</span>),<font></font>
            caseless_symbol_p(<span class="hljs-string">'k'</span>) &gt;&gt; just_result(<span class="hljs-number">1024u</span>),<font></font>
            caseless_symbol_p(<span class="hljs-string">'m'</span>) &gt;&gt; just_result(<span class="hljs-number">1024u</span> * <span class="hljs-number">1024u</span>)<font></font>
         )<font></font>
      ) &gt;&gt; &amp;chunk_size::m_<font></font>
   )<font></font>
) &gt;&gt; convert( <span class="hljs-comment">// (1)</span>
      [](<span class="hljs-keyword">auto</span> cs) { <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>{cs.c_} * cs.m_; })<font></font>
   &gt;&gt; &amp;distribution_params::chunk_size_,</code></pre><br>
<p>   (1)  <code>convert</code>   ,     <code>chunk_size</code>,   <code>std::size_t</code>.</p><br>
<p>   ,    . ..                     .</p><br>
<p>..    <code>convert</code> :</p><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Callable&gt;
SomeTransformerType <span class="hljs-title">convert</span><span class="hljs-params">(Callable &amp;&amp; f)</span> </span>{...}</code></pre><br>
<p>     transformer-.</p><br>
<p> ,      SomeTransformerType     result_type.           <code>convert</code>,  .    <code>convert</code>     producer-.</p><br>
<p>     easy_parser      : <strong>transformer_proxy</strong>.</p><br>
<p>Transformer_proxy   transfomer-,   ,    transformer-  ,  transformer_proxy    producer-.</p><br>
<p>   transformer_proxy   <code>operator&gt;&gt;</code>    :</p><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;
   <span class="hljs-keyword">typename</span> P,
   <span class="hljs-keyword">typename</span> T,
   <span class="hljs-keyword">typename</span> S = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<font></font>
         is_producer_v&lt;P&gt; &amp; is_transformer_proxy_v&lt;T&gt;,<font></font>
         <span class="hljs-keyword">void</span> &gt; &gt;<font></font>
RESTINIO_NODISCARD<font></font>
<span class="hljs-keyword">auto</span>
<span class="hljs-keyword">operator</span>&gt;&gt;(P producer, T transformer_proxy )<font></font>
{<font></font>
   <span class="hljs-keyword">auto</span> real_transformer = transformer_proxy.<span class="hljs-keyword">template</span> make_transformer&lt; 
         <span class="hljs-keyword">typename</span> P::result_type &gt;();<font></font>
<font></font>
   <span class="hljs-keyword">using</span> transformator_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">decay_t</span>&lt; <span class="hljs-keyword">decltype</span>(real_transformer) &gt;;<font></font>
<font></font>
   <span class="hljs-keyword">using</span> producer_type = <span class="hljs-keyword">transformed_value_producer_t</span>&lt; P, transformator_type &gt;;<font></font>
<font></font>
   <span class="hljs-keyword">return</span> producer_type{ <span class="hljs-built_in">std</span>::move(producer), <span class="hljs-built_in">std</span>::move(real_transformer) };<font></font>
};</code></pre><br>
<p>      <code>convert</code>, ..    transformer_proxy,  -  .    transformer_proxy     <code>operator&gt;&gt;</code>,  -    <code>make_transformer</code>        transformer-   <code>result_type</code> :</p><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">typename</span> Converter &gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">convert_transformer_proxy_t</span> :</span> <span class="hljs-keyword">public</span> transformer_proxy_tag<font></font>
{<font></font>
   Converter m_converter;<font></font>
<font></font>
<span class="hljs-keyword">public</span> :<font></font>
   ...<font></font>
   <span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">typename</span> Input_Type &gt;
   RESTINIO_NODISCARD
   <span class="hljs-keyword">auto</span>
   <span class="hljs-title">make_transformer</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> &amp;
   </span>{
      <span class="hljs-keyword">using</span> output_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">decay_t</span>&lt;
            <span class="hljs-keyword">decltype</span>(m_converter(<span class="hljs-built_in">std</span>::declval&lt;Input_Type&amp;&amp;&gt;())) &gt;;<font></font>
<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">convert_transformer_t</span>&lt; output_type, Converter &gt;{ m_converter };<font></font>
   }<font></font>
   ...<font></font>
};</code></pre><br>
<p> <code>output_type</code>  <code>make_transformer</code> —       <code>result_type</code>   <code>convert_transformer_t</code>.</p><br>
<h2 id="odin-iz-tryukov-pri-obrabotke-parametrov-path_to_paramspath_to_tuple">      path_to_params/path_to_tuple</h2><br>
<p> easy_parser_router    easy_parser,         easy_parser_router  DSL    <code>path_to_params</code>  <code>path_to_tuple</code>. ,       :</p><br>
<pre><code class="cpp hljs">router-&gt;http_get(<font></font>
   path_to_params(<span class="hljs-string">"/"</span>),<font></font>
   [](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; req) {...});<font></font>
<font></font>
router-&gt;http_get(<font></font>
   path_to_params(<span class="hljs-string">"/api/v1/books/"</span>, non_negative_decimal_number_p&lt;<span class="hljs-keyword">int</span>&gt;()),<font></font>
   [](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; req, <span class="hljs-keyword">int</span> book_id) {...});</code></pre><br>
<p> ,  - :</p><br>
<pre><code class="cpp hljs">router-&gt;http_get(<font></font>
   route_to_params(produce&lt;<span class="hljs-built_in">std</span>::tuple&lt;&gt;&gt;(<font></font>
      exact_p(<span class="hljs-string">"/"</span>) &gt;&gt; just_result(<span class="hljs-built_in">std</span>::tuple&lt;&gt;{}))),<font></font>
   [](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; req) {});<font></font>
<font></font>
router-&gt;http_get(<font></font>
   route_to_params(produce&lt;<span class="hljs-built_in">std</span>::tuple&lt;<span class="hljs-keyword">int</span>&gt;&gt;(<font></font>
      exact(<span class="hljs-string">"/api/v1/books/"</span>),<font></font>
      non_negative_decimal_number_p&lt;<span class="hljs-keyword">int</span>&gt;() &gt;&gt; to_tuple&lt;<span class="hljs-number">0</span>&gt;())),<font></font>
  [](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; req, <span class="hljs-keyword">int</span> book_id) {...});</code></pre><br>
<p>,   -  DSL       <code>path_to_params</code> (<code>path_to_tuple</code>) :</p><br>
<ul>
<li>   <code>std::tuple</code>,          URL  .     <code>result_type</code>   producer-,     <code>path_to_params</code> (<code>path_to_tuple</code>);</li>
<li>    clauses        URL.</li>
</ul><br>
<p>,   :</p><br>
<pre><code class="cpp hljs">path_to_params(<span class="hljs-string">"/"</span>)</code></pre><br>
<p>          <code>std::tuple&lt;&gt;</code>.       clauses -  <code>type_list&lt;exact_fragment_clause_t&gt;</code>.</p><br>
<p>   :</p><br>
<pre><code class="cpp hljs">path_to_params(
   <span class="hljs-string">"/api/v1/books/"</span>,<font></font>
   non_negative_decimal_number_p&lt;<span class="hljs-keyword">int</span>&gt;(),
   <span class="hljs-string">"/versions/"</span>,<font></font>
   path_fragment_p())</code></pre><br>
<p>     <code>std::tuple&lt;int, std::string&gt;</code>,     clauses  - : <code>type_list&lt;exact_fragment_clause_t, tuple_item_consumer_t&lt;0, non_negative_decimal_number_producer_t&lt;int&gt;&gt;, exact_fragment_clause_t, tuple_item_consumer_t&lt;1, path_fragment_producer_t&gt;&gt;</code>.</p><br>
<p>       easy_parser_router     (    ):</p><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">typename</span>... Args &gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dsl_processor</span>
{</span>
   <span class="hljs-keyword">static_assert</span>( <span class="hljs-number">0u</span> != <span class="hljs-keyword">sizeof</span>...(Args), <span class="hljs-string">"Args can't be an empty list"</span> );<font></font>
<font></font>
   <span class="hljs-keyword">using</span> arg_types = meta::<span class="hljs-keyword">transform_t</span>&lt;<font></font>
         dsl_details::special_decay, meta::type_list&lt;Args...&gt; &gt;;<font></font>
<font></font>
   <span class="hljs-keyword">using</span> result_tuple = dsl_details::<span class="hljs-keyword">detect_result_tuple_t</span>&lt; arg_types &gt;;<font></font>
<font></font>
   <span class="hljs-keyword">using</span> clauses_tuple = dsl_details::<span class="hljs-keyword">make_clauses_types_t</span>&lt; arg_types &gt;;<font></font>
};</code></pre><br>
<p>       ,      :   <code>arg_types</code>  <code>result_tuple</code>.</p><br>
<p> <code>arg_types</code> —    ,  ,      const/volatile  .  ,   Args  <code>dsl_processor</code>  <code>const T&amp;</code>,   <code>arg_types</code>       <code>T</code>.</p><br>
<p> <code>arg_types</code>   - transform,    .       (    <code>dsl_details::special_decay</code>)      .    ,  .</p><br>
<p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><code>  meta::transform_t</code></a>   ,   C++14              ( Boost-).</p><br>
<p>     <code>result_tuple</code>   .</p><br>
<p>,   <code>result_tuple</code>        <code>path_to_params</code> (<code>path_to_tuple</code>)    ,   producer-,      <code>result_type</code>.   :</p><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">typename</span> Args_Type_List &gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">detect_result_tuple</span>
{</span>
   <span class="hljs-keyword">using</span> type = meta::<span class="hljs-keyword">rename_t</span>&lt;
         <span class="hljs-keyword">typename</span> result_tuple_detector&lt;<font></font>
               Args_Type_List,<font></font>
               meta::type_list&lt;&gt; &gt;::type,<font></font>
         <span class="hljs-built_in">std</span>::tuple &gt;;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">typename</span> Args_Type_List &gt;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">detect_result_tuple_t</span> = <span class="hljs-keyword">typename</span> detect_result_tuple&lt;Args_Type_List&gt;::type;</code></pre><br>
<p> <code>detect_result_tuple</code>      <code>result_tuple_detector</code>,        .  <code>result_tuple_detector</code>  <code>type_list&lt;T...&gt;</code>,     <code>std::tuple&lt;T...&gt;</code>.  <code>detect_result_tuple</code>   <code>type_list&lt;T...&gt;</code>     <code>std::tuple&lt;T...&gt;</code>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">  rename</a>.</p><br>
<p>,      <code>result_tuple_detector</code>.    :</p><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">typename</span> From, <span class="hljs-keyword">typename</span> To &gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">result_tuple_detector</span>;</span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;
   <span class="hljs-keyword">template</span>&lt;class...&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">From</span>,
   <span class="hljs-title">typename</span>... <span class="hljs-title">Sources</span>,
   <span class="hljs-title">template</span>&lt;class...&gt; <span class="hljs-title">class</span> <span class="hljs-title">To</span>,
   <span class="hljs-title">typename</span>... <span class="hljs-title">Results</span> &gt;
<span class="hljs-title">struct</span> <span class="hljs-title">result_tuple_detector</span>&lt; From&lt;Sources...&gt;, To&lt;Results...&gt; &gt;
{</span>
   <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> result_tuple_detector&lt;<font></font>
         meta::<span class="hljs-keyword">tail_of_t</span>&lt; Sources... &gt;,
         <span class="hljs-keyword">typename</span> add_type_if_necessary&lt;<font></font>
               meta::<span class="hljs-keyword">head_of_t</span>&lt; Sources... &gt;,<font></font>
               To&lt; Results... &gt; &gt;::type<font></font>
      &gt;::type;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;
   <span class="hljs-keyword">template</span>&lt;class...&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">From</span>,
   <span class="hljs-title">template</span>&lt;class...&gt; <span class="hljs-title">class</span> <span class="hljs-title">To</span>,
   <span class="hljs-title">typename</span>... <span class="hljs-title">Results</span> &gt;
<span class="hljs-title">struct</span> <span class="hljs-title">result_tuple_detector</span>&lt; From&lt;&gt;, To&lt;Results...&gt; &gt;
{</span>
   <span class="hljs-keyword">using</span> type = To&lt;Results...&gt;;<font></font>
};</code></pre><br>
<p> ,         C++  ", ..." ,        result_tuple_detector. ,  , :</p><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;
   <span class="hljs-keyword">template</span>&lt;class...&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">From</span>,
   <span class="hljs-title">template</span>&lt;class...&gt; <span class="hljs-title">class</span> <span class="hljs-title">To</span>,
   <span class="hljs-title">typename</span>... <span class="hljs-title">Results</span> &gt;
<span class="hljs-title">struct</span> <span class="hljs-title">result_tuple_detector</span>&lt; From&lt;&gt;, To&lt;Results...&gt; &gt;
{</span>
   <span class="hljs-keyword">using</span> type = To&lt;Results...&gt;;<font></font>
};</code></pre><br>
<p>   .    ,         .  ,    —          <code>result_tuple_detector</code>.</p><br>
<p>  ,   ,      :</p><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;
   <span class="hljs-keyword">template</span>&lt;class...&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">From</span>,
   <span class="hljs-title">typename</span>... <span class="hljs-title">Sources</span>,
   <span class="hljs-title">template</span>&lt;class...&gt; <span class="hljs-title">class</span> <span class="hljs-title">To</span>,
   <span class="hljs-title">typename</span>... <span class="hljs-title">Results</span> &gt;
<span class="hljs-title">struct</span> <span class="hljs-title">result_tuple_detector</span>&lt; From&lt;Sources...&gt;, To&lt;Results...&gt; &gt;
{</span>
   <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">typename</span> result_tuple_detector&lt;<font></font>
         meta::<span class="hljs-keyword">tail_of_t</span>&lt; Sources... &gt;,
         <span class="hljs-keyword">typename</span> add_type_if_necessary&lt;<font></font>
               meta::<span class="hljs-keyword">head_of_t</span>&lt; Sources... &gt;,<font></font>
               To&lt; Results... &gt; &gt;::type<font></font>
      &gt;::type;<font></font>
};</code></pre><br>
<p>    :       ,    ""  ,              ,            <code>add_type_if_necessary&lt;H, R_List&gt;</code>.                 .  <code>add_type_if_necessary&lt;H, R_List&gt;</code>       (<code>R_List</code>),  <code>H</code>    producer-.     ,    <code>R_List</code>  <code>H::result_type</code>,  <code>H</code>   producer-.</p><br>
<p>   <code>add_type_if_necessary</code>  :</p><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">typename</span> H, <span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">bool</span> Is_Producer &gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">add_type_if_necessary_impl</span>;</span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;
   <span class="hljs-keyword">typename</span> H,
   <span class="hljs-keyword">template</span>&lt;class...&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">To</span>,
   <span class="hljs-title">typename</span>... <span class="hljs-title">Results</span> &gt;
<span class="hljs-title">struct</span> <span class="hljs-title">add_type_if_necessary_impl</span>&lt; H, To&lt;Results...&gt;, false &gt;
{</span>
   <span class="hljs-keyword">using</span> type = To&lt;Results...&gt;;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;
   <span class="hljs-keyword">typename</span> H,
   <span class="hljs-keyword">template</span>&lt;class...&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">To</span>,
   <span class="hljs-title">typename</span>... <span class="hljs-title">Results</span> &gt;
<span class="hljs-title">struct</span> <span class="hljs-title">add_type_if_necessary_impl</span>&lt; H, To&lt;Results...&gt;, true &gt;
{</span>
   <span class="hljs-keyword">using</span> type = To&lt;Results..., <span class="hljs-keyword">typename</span> H::result_type&gt;;<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// Adds type H to type list R if H is a producer.</span>
<span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">typename</span> H, <span class="hljs-keyword">typename</span> R &gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">add_type_if_necessary</span>
   :</span> add_type_if_necessary_impl&lt; H, R, ep::impl::is_producer_v&lt;H&gt; &gt;<font></font>
{};</code></pre><br>
<p> <code>is_producer_v</code> —  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">-  easy_parser</a>,  ,     producer-  .</p><br>
<h1 id="zaklyuchenie"></h1><br>
<h2 id="easy_parser_router----eto-eksperiment">easy_parser_router —  ...</h2><br>
<p>…        .   ,    ,    C++        compile-time,       .</p><br>
<p>  ,      HTTP-  C++ —  - ,   .         -     RESTinio.</p><br>
<p>     , ..      -.   easy_parser —     .            ,     .</p><br>
<p>    ,   .</p><br>
<p>,    ,  .   ,   .   .</p><br>
<h2 id="ya-ne-nastoyaschiy-svarschik">   </h2><br>
<p> ,    easy_parser  easy_parser_router    RESTinio .        ,       ,    .</p><br>
<p>    ,    ,           C++.   ,    .</p><br>
<p>   ,   .     .     .</p><br>
<p>   ,        ,    -        .     C++  -   ,      .</p><br>
<p>   -     RESTinio  easy_parser_router  ,       .</p><br>
<h2 id="eto-vse"> </h2><br>
<p> ,          .</p><br>
<p>  -  ,   RESTinio, easy_parser / easy_parser_router,        .</p><br>
<p>        ,         RESTinio.</p></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es497488/index.html">Automatice los procesos de recursos humanos con Microsoft Teams, PowerApps y Power Automate. Solicitudes de retiro de empleados</a></li>
<li><a href="../es497490/index.html">Dificultades en la paternidad de los caballitos de mar: metamorfosis genéticas del sistema inmune.</a></li>
<li><a href="../es497492/index.html">Aplicación en TSD y comunicación con 1C: Enterprise 8.3 a través del servicio HTTP. Parte 1.1 (Descripción detallada de la API)</a></li>
<li><a href="../es497504/index.html">Cómo Quarkus integra MicroProfile y Spring</a></li>
<li><a href="../es497506/index.html">Crear un todo para un comando remoto en Laravel</a></li>
<li><a href="../es497510/index.html">Síntesis de audio de videojuegos - Número 2. Presa</a></li>
<li><a href="../es497512/index.html">¿Los glaciares derretidos proporcionarán energía hidroeléctrica en el futuro?</a></li>
<li><a href="../es497516/index.html">Cómo crear una caja blindada anecoica usted mismo</a></li>
<li><a href="../es497520/index.html">Comparación de rendimiento HTTP / 3 y HTTP / 2</a></li>
<li><a href="../es497522/index.html">Juegos por dinero: experiencia en una red de juegos distribuidos del propietario de varios servidores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>