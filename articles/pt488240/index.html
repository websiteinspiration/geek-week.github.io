<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏽 🧠 👩🏼 Um ciclo interminável que não era: a história do inseto do Santo Graal 👩‍👧 🍳 👨🏽‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Era uma vez um jogo para GBA chamado Hello Kitty Collection: Miracle Fashion Maker. Foi um jogo fofo baseado na famosa franquia Sanrio Hello Kitty e d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Um ciclo interminável que não era: a história do inseto do Santo Graal</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488240/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Era uma vez um jogo para GBA chamado Hello Kitty Collection: Miracle Fashion Maker. Foi um jogo fofo baseado na famosa franquia Sanrio Hello Kitty e desenvolvido pela Imagineer. Mas, sob o pretexto de um nome aparentemente inocente, havia um problema insidioso. Por alguma razão, este jogo simples não foi executado em nenhum emulador de GBA. Mas isso por si só não seria suficiente para chamar o problema de inseto do Santo Graal. Como todos os insetos do Santo Graal, esse inseto em si era completamente confuso. A explicação era simples: em algum momento da sequência de lançamento do jogo, ele entrou em um ciclo do qual nunca </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saiu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , esperando que um determinado valor fosse lido da memória que </font><em><font style="vertical-align: inherit;">ele não existe</font></em><font style="vertical-align: inherit;"> . Embora existam erros semelhantes em muitos jogos, por exemplo, na introdução popular</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Legend of Zelda: The Minish Cap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , eles contam com um comportamento especial causado pela leitura de endereços de memória inválidos. </font><font style="vertical-align: inherit;">Mas esse ciclo parecia violar esse comportamento. </font><font style="vertical-align: inherit;">No entanto, o jogo funcionou em equipamentos reais. </font><font style="vertical-align: inherit;">Além disso, ocorreu exatamente o mesmo bug ao carregar um save no Sonic Pinball Party após uma reinicialização a frio. </font><font style="vertical-align: inherit;">Poderia a expectativa desses endereços de memória inválidos de alguma forma errônea? </font><font style="vertical-align: inherit;">Mas se sim, como?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b0/c85/547/1b0c8554787a8e54e1ac5c21c78d639c.png"></div><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas isso é ilegal, certo?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espere um minuto - se você está tentando acessar a memória inválida, o jogo precisa travar, certo? Uma operação não resolvida, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segfault</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou algum outro erro </font><font style="vertical-align: inherit;">deve ocorrer </font><font style="vertical-align: inherit;">. Direita? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, é mais como sim. Mas não realmente. Pelo menos não no GBA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na arquitetura dos processadores ARM usados ​​no GBA, esse estado incorreto é chamado de cancelamento de dados e ocorre apenas quando você tenta acessar a memória à qual o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gerenciador de memória</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> não atribuiu a permissão de leitura </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Quando ocorre a interrupção dos dados, o processador conclui o que estava fazendo e vai para </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o vetor de exceção</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atribuído a exceções de cancelamento de dados. Em seguida, o sistema operacional pode escolher uma das soluções: interromper o processo atual, atribuir memória de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falha de página</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , deixar o processo lidar com a situação, como alguns emuladores JIT fazem com “fastmem” ou executar outras ações. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como o GBA lida com a interrupção de dados? A entrada do vetor de exceção para o cancelamento de dados está localizada na ROM de inicialização do console GBA (ou, como também é chamado, no BIOS). Se o GBA encontrar um cancelamento de dados, ele tentará ir para o manipulador DACS </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se existir, ocorrerá o bloqueio. </font><font style="vertical-align: inherit;">Nenhum jogo comercial possui manipuladores DACS. </font><font style="vertical-align: inherit;">Então, por que esse jogo não está congelando? </font><font style="vertical-align: inherit;">Tudo é muito simples - o GBA nunca gera abortamento de dados. </font><font style="vertical-align: inherit;">Ele não possui um gerenciador de memória (MMU) (ou mesmo uma unidade de proteção de memória, como no DS), portanto, continua a trabalhar e lê a memória inválida.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O barramento de memória entra em cena.</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f75/dd9/55f/f75dd955f33d3a974b417f401fe054a6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que é memória inválida em geral? Como é a aparência dela? Este é o principal obstáculo. Essa é uma situação difícil: o que o código lê depende muito do que a CPU fez recentemente ou, mais precisamente, do que o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">barramento de memória</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fez recentemente </font><font style="vertical-align: inherit;">. Em resumo, ao acessar uma memória inválida, a CPU lê qual foi a última no barramento de memória. Para entender o que se segue, é necessário aprender um pouco sobre o barramento de memória e como ele funciona.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um barramento de memória faz parte de um circuito eletrônico que conecta a CPU a todos os componentes de memória da plataforma. No GBA, vários dispositivos estão conectados ao barramento de memória: RAM de trabalho, memória de vídeo e barramento de cartucho. Quando a CPU tenta acessar a memória, informa ao barramento de memória a qual endereço ele precisa acessar e, em seguida, o componente correspondente a esse endereço é ativado. Em seguida, o componente coloca o valor nesse endereço no barramento, o que pode levar vários </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ciclos </font><font style="vertical-align: inherit;">e, em seguida, a CPU pode finalmente ler o valor do barramento. No caso do GBA, se nenhum equipamento estiver associado ao endereço, nenhum valor será gravado no barramento e a CPU lerá qualquer valor colocado por </font><em><font style="vertical-align: inherit;">último</font></em><font style="vertical-align: inherit;"> no barramento.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A situação pode variar de maneiras diferentes, por exemplo, se a leitura for de 16 bits e a CPU tentar executar a leitura de 32 bits, mas, em geral, sempre será um valor do barramento. </font><font style="vertical-align: inherit;">Os desenvolvedores chamam esse recurso de "barramento aberto". </font><font style="vertical-align: inherit;">Anteriormente, escrevi como isso afeta </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">outros jogos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bem, parece que tudo não parece tão ruim ... Certo?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então você pode apenas armazenar em cache o último acesso à memória? E depois trazê-lo de volta? No caso geral, essa abordagem funcionará, mas há certas dificuldades. Primeiro, você precisa garantir que todas as operações de acesso à memória estejam na ordem correta. Isso é mais complicado do que parece, porque a CPU acessa a memória com cada instrução para obter a próxima instrução no pipeline. E, de fato, no caso geral *, a memória presa no barramento é a última instrução recebida. Isso simplifica o processo, porque você precisa obter apenas esse último valor pré-selecionado. Mas como o último valor pré-selecionado depende apenas de onde estamos executando atualmente a partir da memória, ele deve sempre ser o mesmo. Mesmo que o endereço recebido mude enquanto é inválido,você sempre terá a mesma memória.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pare. </font><font style="vertical-align: inherit;">Mas esse ciclo existe e não pode ser encerrado se esse valor estiver pré-selecionado. </font><font style="vertical-align: inherit;">Então, o que está acontecendo? </font><font style="vertical-align: inherit;">Se ele recebe constantemente as seguintes instruções, o que acontece entre essas operações? </font><font style="vertical-align: inherit;">Tentei executar loops intermináveis ​​em ROMs de teste para verificar se, por exemplo, o valor poderia dar errado. </font><font style="vertical-align: inherit;">Definitivamente, isso pode acontecer se o valor não tiver sido atualizado recentemente, mas o valor for atualizado em cada instrução, portanto, não há tempo para ser corrompido. </font><font style="vertical-align: inherit;">Meus testes nunca saíram do circuito. </font><font style="vertical-align: inherit;">Eu fiz algo diferente do que nesses jogos, embora tenha recriado exatamente o ciclo. </font><font style="vertical-align: inherit;">O que eu fiz errado?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pokémon Emerald e ACE, ocorrendo apenas em ferro</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avanço rápido no tempo, em janeiro de 2020. O relatório de bugs na Sonic Pinball Party naquela época tinha cerca de três anos e meio de idade. Em outros emuladores, ele era conhecido por muitos anos. Eu fiquei sem teorias de trabalho. No final deste mês, um usuário com o apelido </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merrp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ingressou na comunidade Discord do emulador de mGBA e disse que o Pokémon Emerald tem uma nova falha arbitrária de execução de código (ACE) que funciona apenas em hardware. Além disso, essa falha provavelmente será usada pelos speedrunners, que podem querer praticar o emulador. Obviamente, esse bug se tornou um alvo atraente para corrigir o erro, embora seja melhor que eu descubra isso antes da versão 0.8.0. Comecei a pesquisar a falha e confirmei a observação do merrp de que ele só funciona em hardware. Em todos os emuladores que tentei, o jogo ficou com uma tela preta. Mas o merrp me informou que fica travando a leitura da memória inválida em um loop e percebi que provavelmente não conseguiria corrigir o erro no futuro próximo. Este é novamente </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o mesmo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bug.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dessa vez, aprender sobre as funções de loop me deu uma vantagem. Graças ao </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projeto de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> descompilação do </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">pokeemerald,</font></a><font style="vertical-align: inherit;"> eu poderia facilmente fazer alterações direcionadas na função para tentar descobrir como ela conseguiu sair do circuito. Uma versão simplificada desse loop é mais ou menos assim:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint16_t</span> type = <span class="hljs-comment">/* ... */</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int32_t</span> i = <span class="hljs-number">0</span>; table[type][i] != <span class="hljs-number">0xFFFF</span>; ++i) {
	<span class="hljs-keyword">uint16_t</span> value = table[type][i] &amp; <span class="hljs-number">0xFE00</span>;
	<span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">0x7E00</span>) {
		<span class="hljs-keyword">break</span>;<font></font>
	}<font></font>
	<span class="hljs-comment">/* ... */</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O loop executa uma tarefa bastante simples. Existe uma tabela bidimensional de valores. Em cada linha desta tabela de colunas, o </font></font><code>type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loop primeiro tenta determinar se o valor é um determinado valor sentinela. Nesse caso, o loop termina. Caso contrário, aplica uma máscara ao valor e verifica se é maior que o valor que está sendo verificado. Caso contrário, diminui o ciclo. Em um caso específico de falha, o valor </font></font><code>type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vai além dos limites da tabela, o que leva à aparência de um ponteiro inválido. Isso significa que quando você tenta acessar</font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para este elemento desta coluna inexistente, sempre acessaremos a memória inválida. Embora o deslocamento da tabela aumente a cada iteração do loop antes de retornar à memória real, ele pode precisar de centenas de milhões de repetições. Portanto, é óbvio que ele não faz. Então, como um programa sai de um loop?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para investigar isso, mudei o ciclo e observei o que aconteceria se eu apenas interrompesse instantaneamente o ciclo. </font><font style="vertical-align: inherit;">Tudo acabou sendo muito simples: nesse momento, o ACE trabalhava tanto no hardware quanto no emulador, e nada pendia. </font><font style="vertical-align: inherit;">Então, em vez disso, tentei definir a cor da tela para o valor que o programa lê quando sai do loop e congela para que a cor não mude. </font><font style="vertical-align: inherit;">Eu recompilei o código e o executei em um GBA real. </font><font style="vertical-align: inherit;">Após alguns segundos de congelamento em uma tela preta, tornou-se um lindo tom azul.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/eq/e_/md/eqe_md60cly8igmztq2_kd2yigc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MUITO AZUL</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Mas o emulador ainda estava pendurado em uma tela preta. </font><font style="vertical-align: inherit;">Que valor ele lerá se ler o valor recebido anteriormente? </font><font style="vertical-align: inherit;">Em vez disso, tornou-se um turquesa escuro.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/sh/hf/6j/shhf6jyqkem0ulhbpzjuhc9hmi4.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fu.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ou seja, o programa, antes de conseguir sair do ciclo, certamente o passou pelo menos uma vez. </font><font style="vertical-align: inherit;">Descobriu-se também que o tempo necessário para escapar do ciclo com ferro varia. </font><font style="vertical-align: inherit;">Isso geralmente levava 2 a 30 segundos. </font><font style="vertical-align: inherit;">O que está acontecendo?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nova teoria de trabalho</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então notei a diferença entre a ROM de teste e o Pokémon Emerald quando ele travou. Pokémon tocou música. O Sonic Pinball Party também tocou música. Hello Kitty não tocou música, mas me deu uma ideia. O que acontece se ocorrer uma interrupção entre a pré-busca e o carregamento de dados? O programa inicia a pré-busca do vetor de interrupção antes de acessar a memória inválida? Criei rapidamente um layout para essa situação no mGBA, liguei as interrupções na ROM de teste e, é claro, saiu do circuito. Depois, tentei o mesmo ROM de teste no hardware e ... ele não saiu do circuito. E assim surgiu a teoria. No final, eu percebi uma coisa. Tenho certeza de que você notou um asterisco acima. Portanto, pode haver um evento entre pré-buscar e acessar a memória,mas somente se, entre a pré-busca e o acesso à memória inválida, o barramento de memória enviar uma solicitação não à CPU, mas a outra coisa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu disse que o barramento de memória é controlado pela CPU. Na maioria das vezes, isso é verdade, mas há outros equipamentos importantes que também têm acesso ao barramento de memória ignorando o processador. Esse processo é chamado de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acesso direto à memória</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Eu falei sobre DMA em um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo anterior</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , agora não vou entrar nos princípios de seu trabalho. Se você reler o artigo, poderá notar que eu disse que a CPU principal faz uma pausa enquanto o DMA está em execução. Isso significa que enquanto o DMA estiver em execução, o valor no barramento será agora o último acesso à memória do DMA. Isso é importante principalmente se o DMA for além da memória real para uma região inválida; no entanto, duplica o último bom valor.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há muito se sabe que, se você carregar memória inválida no DMA, obterá o último valor do DMA, mas eu o implementei no mGBA por um longo tempo e já o esqueci. Quando vi isso no código de acesso à memória inválida ao estudar o bug, algo clicou na minha cabeça. E se o valor de DMA permanecer no barramento por uma instrução? Se a primeira instrução após o DMA terminar de carregar a memória inválida antes de obter o próximo valor, em teoria, isso deve levar ao recarregamento do valor do DMA. Além disso, a reprodução de música no GBA normalmente usa DMA para transmitir a saída de áudio. Para a implementação correta disso, é necessário um emulador preciso de tato que possa bloquear a CPU no meio da execução da instrução, entre o início da instrução e o acesso à memória, e a emulação de console GBA no emulador mGBA não é precisa.E isso é algo para mim.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recorda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Felizmente, consegui contornar esse problema. </font><font style="vertical-align: inherit;">A solução é imperfeita, mas agora posso comparar o endereço de CPU esperado para a instrução após o DMA com o endereço de CPU atual para uma carga inválida e usar um único endereço em vez do valor pré-selecionado para esse valor de DMA.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A tão esperada decisão</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Liguei as operações de DMA para o H-blank na ROM de teste e as sincronizei com o V-blank para que os tempos fossem estáveis, executei no hardware e ... desta vez funcionou! A ROM de teste constantemente saía do loop após o mesmo número de iterações quando o valor de DMA era lido no barramento. Eu tinha razão! Para a implementação correta disso no mGBA, foram necessárias várias tentativas, mas agora o programa sai do ciclo com os mesmos resultados que no hardware. Finalmente consegui um tom de azul no mGBA. Olá Kitty foi inicializado. A economia no Sonic Pinball Party ganhou. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu fiz isso.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este foi provavelmente o tempo mais longo que passei em um único bug. Durante três anos, investi tanto tempo na depuração que perdi a conta e tenho certeza de que outros desenvolvedores também enfrentaram situações semelhantes em seus emuladores. Sem essa percepção, poderia ter me levado mais um ano, ou até mais, mas a tela preta, na qual nada aconteceu exceto a reprodução de música, tornou-se o dominó que levou ao colapso de todo o problema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora que a solução foi encontrada, ela pode ser implementada em outros emuladores de GBA, encerrando esse bug. O bug será corrigido no mGBA 0.9.0, que, espero, será lançado este ano e já foi corrigido nas versões de teste. Você pode finalmente jogar a coleção Hello Kitty: Miracle Fashion Maker. A menos que, claro, você deseje, não cabe a mim julgá-lo.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34c/74c/fce/34c74cfce5ebbb092c5a55c9293ec0cb.png" alt="imagem"></div><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você tentar executar a memória que não possui permissões de execução, isso é chamado de cancelamento de pré-busca.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DACS (abreviação de Debugging and Communication System) faz parte do kit de desenvolvimento GBA.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esses ciclos inativos durante a leitura do barramento às vezes são chamados de estados de espera.</font></font></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt488222/index.html">Como fiz um jogo para o Bloco de Notas</a></li>
<li><a href="../pt488228/index.html">TOP 10 lugares e idéias para um encontro de geeks em 14 de fevereiro</a></li>
<li><a href="../pt488230/index.html">Introdução ao SSD. Parte 3. Fator de forma</a></li>
<li><a href="../pt488232/index.html">tecnologia aproximada: QATOK # 2</a></li>
<li><a href="../pt488234/index.html">Usando o QubesOS para Windows 7</a></li>
<li><a href="../pt488242/index.html">Integração do projeto VueJS + TS com o SonarQube</a></li>
<li><a href="../pt488244/index.html">Como reduzir a sobrecarga ao lidar com exceções em C ++</a></li>
<li><a href="../pt488246/index.html">VoiceOver no iOS: cada controle se comporta de maneira diferente</a></li>
<li><a href="../pt488250/index.html">Para a questão do Linux (L)</a></li>
<li><a href="../pt488252/index.html">Como reduzir o custo de desenvolvimento de novos produtos usando o SLS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>