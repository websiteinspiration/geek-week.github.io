<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õπüèæ üåÑ üõåüèæ C√≥mo resolvemos el problema de la memoria de pila no inicializada en Windows üê¢ ‚ô†Ô∏è üîà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En esta nota, describir√© c√≥mo Microsoft elimina las vulnerabilidades asociadas con la memoria de pila no inicializada y por qu√© hacemos esto.
 
 Para ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C√≥mo resolvemos el problema de la memoria de pila no inicializada en Windows</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505498/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta nota, describir√© c√≥mo Microsoft elimina las vulnerabilidades asociadas con la memoria de pila no inicializada y por qu√© hacemos esto.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para facilitar la navegaci√≥n, la nota se divide en secciones:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabajar con memoria no inicializada: historial de problemas</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remedio para vulnerabilidades de memoria no inicializadas</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll - inicializaci√≥n autom√°tica</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observaciones interesantes relacionadas con el uso de InitAll</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimizaciones de rendimiento</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valor del usuario</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Planes futuros</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este trabajo no hubiera sido posible sin una estrecha colaboraci√≥n entre Visual Studio, Windows y MSRC.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabajar con memoria no inicializada: historial de problemas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al crear los lenguajes de programaci√≥n C y C ++, se hizo hincapi√© en la alta velocidad y el control flexible por parte del desarrollador. </font><font style="vertical-align: inherit;">Por esta raz√≥n, estos lenguajes no fuerzan la inicializaci√≥n de variables. </font><font style="vertical-align: inherit;">Trabajar con variables no inicializadas conduce a un comportamiento indefinido, por lo que deben inicializarse antes de su uso, y la responsabilidad de observar esta regla recae completamente en el desarrollador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las vulnerabilidades asociadas con la memoria no inicializada se reducen a dos tipos:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Divulgaci√≥n de contenido: los datos almacenados en secciones de memoria no inicializadas se copian fuera del √°rea de confianza y se dan a conocer a personas que no tienen la autoridad adecuada.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uso directo de la memoria no inicializada. </font><font style="vertical-align: inherit;">Ejemplo: escribir por puntero no inicializado.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es importante comprender que los problemas pueden ocurrir independientemente de si la memoria est√° asignada en la pila o en el mont√≥n. </font><font style="vertical-align: inherit;">Esta publicaci√≥n trata sobre la memoria de la pila, y luego hablaremos sobre el mont√≥n.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo de uso de memoria no inicializada</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> size;  <font></font>
GetSize(&amp;size); <span class="hljs-comment">//       ?</span>
<span class="hljs-built_in">memcpy</span>(dest, src, size); <span class="hljs-comment">//  memcpy </span>
                         <span class="hljs-comment">//  </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema aqu√≠ es que si la funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetSize</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no asigna un valor a la variable 'tama√±o' en todas las ramas del programa, entonces se </font><font style="vertical-align: inherit;">pasar√° </font><font style="vertical-align: inherit;">un </font><font style="vertical-align: inherit;">tama√±o no inicializado a la </font><font style="vertical-align: inherit;">llamada de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Debido a esto, puede producirse un error de lectura o escritura fuera del b√∫fer si el valor de 'tama√±o' es mayor que el tama√±o del b√∫fer 'src' o 'dest'.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo de expansi√≥n de memoria no inicializada</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mystruct</span> {</span>
      <span class="hljs-keyword">uint8_t</span> field1;
      <span class="hljs-keyword">uint64_t</span> field2;<font></font>
};<font></font>
mystruct s {<span class="hljs-number">1</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">memcpy</span>(dest, &amp;s, <span class="hljs-keyword">sizeof</span>(s));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponga que la funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> copia una estructura fuera de un √°rea confiable (es decir, del modo kernel al modo usuario). A primera vista, la estructura parece estar completamente inicializada, pero entre el 'campo1' y el 'campo2' el compilador insert√≥ bytes de marcador de posici√≥n que no se inicializaron expl√≠citamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado de llamar a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">los bytes de marcador de posici√≥n se copiar√°n fuera del √°rea de confianza junto con su contenido no inicializado escrito anteriormente en estas direcciones virtuales. </font><font style="vertical-align: inherit;">Puede ser, por ejemplo, una pieza de una clave de cifrado secreta (que se har√° visible en el modo de usuario), un puntero (que romper√° el ASLR) u otra cosa. </font><font style="vertical-align: inherit;">En algunos casos, se puede demostrar f√°cilmente que no se transmiten datos particularmente cr√≠ticos, en otros ser√° muy dif√≠cil. </font><font style="vertical-align: inherit;">Pero, en cualquier caso, descubrir cu√°n serio es el problema de la memoria no inicializada es un trabajo desagradecido, y estar√≠amos dispuestos a hacer otra cosa.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estad√≠sticas de error de memoria sin inicializar</font></font></h3><br>
<p><img src="https://habrastorage.org/webt/hb/la/gn/hblagnxiqxpsgewdennaq6tx8o8.png" alt="Cuadro 8"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nota: en esta figura, el uso de memoria no inicializada se refiere a ambos tipos de problemas: uso directo y divulgaci√≥n de contenido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En los √∫ltimos a√±os, el n√∫mero de tales errores ha ido en aumento. </font><font style="vertical-align: inherit;">Esto probablemente se deba en parte al creciente inter√©s de los investigadores en ellos y, como resultado, al surgimiento de herramientas efectivas para su b√∫squeda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una clasificaci√≥n m√°s detallada de estos errores revela algunas tendencias m√°s interesantes.</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/od/bg/sq/odbgsqun-kof4vx6j8ws_v9d9f8.png" alt="Cuadro 6"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nota: en este diagrama, el uso de memoria no inicializada NO incluye la divulgaci√≥n de su contenido.</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/rl/ql/ee/rlqleezbmgk3oeo-bxztqaaphry.png" alt="Cuadro 5"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mirando estos diagramas, podemos sacar las siguientes conclusiones:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entre 2017 y 2018, las vulnerabilidades de memoria no inicializadas representaron aproximadamente el 5-10% de todas las vulnerabilidades en los informes de Microsoft.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las vulnerabilidades asociadas con la asignaci√≥n de memoria en la pila y las vulnerabilidades asociadas con la asignaci√≥n de memoria en el mont√≥n / grupo resultaron ser casi iguales.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay m√°s casos de revelar el contenido de la memoria no inicializada que casos de usar memoria no inicializada.</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">literatura adicional</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para obtener una introducci√≥n m√°s completa al tema, consulte los siguientes recursos:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/microsoft/MSRC-Security-Research/blob/master/presentations/2019_09_CppCon/CppCon2019%20-%20Killing%20Uninitialized%20Memory.pdf</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://j00ru.vexillium.org/papers/2018/bochspwn_reloaded.pdf</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.blackhat.com/presentations/bh-europe-06/bh-eu-06-Flake.pdf</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remedio para vulnerabilidades de memoria no inicializadas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Intentaron resolver los problemas descritos de varias maneras.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An√°lisis est√°tico (tanto durante la compilaci√≥n como despu√©s)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuzzing</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revisi√≥n de c√≥digo</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializaci√≥n autom√°tica</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An√°lisis est√°tico</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Microsoft utiliza numerosas advertencias del analizador est√°tico para detectar variables no inicializadas (incluidas C4700, C4701, C4703, C6001, C26494 y C26495). </font><font style="vertical-align: inherit;">Estos diagn√≥sticos son conservadores, es decir. </font><font style="vertical-align: inherit;">Para reducir el ruido, ignoran algunos patrones que pueden conducir a la memoria no inicializada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n se han escrito una serie de reglas estrictas para el analizador est√°tico </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semmle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que se ejecutan en algunas bases de c√≥digo de Windows. </font><font style="vertical-align: inherit;">Pero estos diagn√≥sticos generan mucho ruido y es dif√≠cil verificar grandes cantidades de c√≥digo. </font><font style="vertical-align: inherit;">Adem√°s, el cumplimiento de estas reglas y la correcci√≥n de errores lleva mucho tiempo. </font><font style="vertical-align: inherit;">Como resultado, result√≥ que es dif√≠cil y costoso usarlos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuzzing</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fuzzing, como sabes, es dif√≠cil de escalar. </font><font style="vertical-align: inherit;">Los buenos fuzzers son costosos de mantener y requieren personalizaci√≥n para tareas espec√≠ficas. </font><font style="vertical-align: inherit;">Con una base de c√≥digo de tama√±os tales como Microsoft, es muy dif√≠cil asegurar su cobertura completa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Incluso si fuera posible cubrir perfectamente todo el c√≥digo con ellos, los fuzzers no pueden detectar la divulgaci√≥n del contenido de la memoria no inicializada, ya que no conduce a un bloqueo del programa. </font><font style="vertical-align: inherit;">Para detectar tales defectos usando fuzzing, se requiere una de dos soluciones:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazzer, que comprende el protocolo y es capaz de detectar el retorno de la memoria no inicializada (o m√°s bien, datos inesperados).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un analizador din√°mico capaz de detectar el acceso a la memoria no inicializada.</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revisi√≥n de c√≥digo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La descripci√≥n general del c√≥digo no es escalable y es extremadamente propensa a errores. </font><font style="vertical-align: inherit;">Se revisa el c√≥digo con vulnerabilidades, pero est√°n tan bien disfrazados que los programadores no los notan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La parte del c√≥digo en la que encontramos la divulgaci√≥n del contenido de la memoria no inicializada se reescribi√≥ en los d√≠as de Windows de 32 bits, y entonces no hubo tales errores. </font><font style="vertical-align: inherit;">Cuando se produjo la transici√≥n a arquitecturas de 64 bits, el tama√±o de los punteros aument√≥ de 32 a 64 bits, por lo que algunas estructuras tienen campos de marcador de posici√≥n no inicializados.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll - Inicializaci√≥n autom√°tica</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s de los enfoques mencionados, Microsoft ha estado utilizando durante alg√∫n tiempo un mecanismo llamado </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : inicializa autom√°ticamente las variables de la pila en la etapa de compilaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En esta secci√≥n, describir√© c√≥mo se usa esta tecnolog√≠a en Windows y por qu√© de esta manera.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuraci√≥n actual de Windows:</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los siguientes tipos se inicializan autom√°ticamente:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escalar (matrices, punteros, n√∫meros de coma flotante)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matrices de puntero</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estructuras (estructuras de datos simples - POD)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los siguientes tipos no se inicializan autom√°ticamente:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables vol√°tiles</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matrices de tipos distintos de punteros (es decir, matrices de enteros, matrices de estructuras, etc.)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clases que no son POD</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En ensamblajes minoristas optimizados, las variables se inicializan con un valor de 0. Para los n√∫meros de coma flotante, se usa un valor de 0.0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los conjuntos de depuraci√≥n (CHK) o los conjuntos para desarrolladores (es decir, minoristas no optimizados) usan el valor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xE2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">los n√∫meros de punto flotante se inicializan a 1.0. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aplica a los siguientes componentes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo el c√≥digo del repositorio de Windows que se ejecuta en modo kernel (es decir, todo el c√≥digo que se compila con el modificador / KERNEL) </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo el c√≥digo relacionado con Hyper-V (hipervisor, componentes en modo kernel, componentes en modo usuario)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Varios otros proyectos, como servicios de red en modo de usuario</font></font></li>
</ol><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementa en el front-end del compilador. </font><font style="vertical-align: inherit;">El frontend inicializar√° todas las variables que cumplan los criterios enumerados anteriormente y que el programador no haya inicializado. </font><font style="vertical-align: inherit;">Una de las ventajas de este enfoque es que, desde el punto de vista del optimizador, la inicializaci√≥n autom√°tica no es diferente de la inicializaci√≥n por parte del desarrollador. </font><font style="vertical-align: inherit;">De esto se deduce que las optimizaciones que agregamos para acelerar el trabajo con </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no est√°n vinculadas solo a esta funci√≥n y funcionar√°n en los casos en que inicialice las variables usted mismo al declarar (o antes de usar).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo evitamos el problema de la bifurcaci√≥n del idioma?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay un problema con la inicializaci√≥n autom√°tica de cero: cero es un significado especial en un lenguaje de programaci√≥n, especialmente para punteros. Y este es quiz√°s el valor m√°s com√∫n que inicializa las variables individuales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando se inicializa a cero, un puntero que el programador no inicializ√≥ correctamente puede caer en la rama de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puntero NULL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Como resultado, puede obtener un programa que no se bloquea, pero no produce los resultados deseados. Si inicializa el puntero con un valor basura, no caer√° en la rama del </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puntero NULL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y, si intenta usarlo, har√° que el programa se bloquee.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resolvemos este problema utilizando un valor de inicializaci√≥n distinto de cero (0xE2) en las compilaciones CHK y las denominadas compilaciones para desarrolladores, que a menudo son compilaciones de lanzamiento no optimizadas. Debido a esto, por un lado, es posible mantener un alto rendimiento del c√≥digo entregado a los clientes y, por otro lado, obtener un comportamiento en los ensambles que se est√°n probando que hace que sea m√°s f√°cil notar las inicializaciones perdidas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observo que C ++ ya requiere la inicializaci√≥n cero autom√°tica de todos los miembros est√°ticos. </font><font style="vertical-align: inherit;">Esta sem√°ntica ayuda a los desarrolladores. </font><font style="vertical-align: inherit;">Por ejemplo, cuando vea una variable est√°tica con un valor cero, sabr√° que necesita inicializarla, ya que este es su primer uso. </font><font style="vertical-align: inherit;">InitAll presenta una sem√°ntica similar para las variables autom√°ticas (pila) con una advertencia importante: tratamos de no vincular a los desarrolladores con valores iniciales espec√≠ficos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥mo elegimos para qu√© componentes usar InitAll</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicialmente, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> planeaba usar en dos componentes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥digo de modo de n√∫cleo: principalmente debido a la gran cantidad de vulnerabilidades observadas asociadas con la memoria de n√∫cleo no inicializada.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El c√≥digo Hyper-V se debe principalmente a su importancia para Azure y a las estad√≠sticas recientes decepcionantes sobre casos de divulgaci√≥n del contenido de la memoria de pila no inicializada.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algunos en Microsoft se enteraron de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y comenzaron a usarlo activamente en sus componentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La raz√≥n por la que no implementamos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inmediato en todo el c√≥digo es porque queremos hacer al menos algo bien primero y no fallar, tratando de hacerlo todo de una vez. </font><font style="vertical-align: inherit;">Cuanto m√°s c√≥digo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">procesemos InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a la vez, m√°s dif√≠cil ser√° depurar las ca√≠das de rendimiento, resolver problemas de compatibilidad, etc. </font><font style="vertical-align: inherit;">Ahora que hemos implementado con √©xito la tecnolog√≠a en los componentes m√°s importantes, puede hacer el resto del c√≥digo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øInitAll interrumpe el an√°lisis est√°tico?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El an√°lisis est√°tico es extremadamente √∫til porque les recuerda a los desarrolladores las variables que olvidaron inicializar antes de usar. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> notifica al analizador </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PREfast</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y al backend del compilador (ambos dan advertencias sobre variables no inicializadas) sobre las inicializaciones que ha agregado. </font><font style="vertical-align: inherit;">Gracias a esto, los analizadores est√°ticos pueden ignorar dichos lugares y a√∫n as√≠ dar sus advertencias. </font><font style="vertical-align: inherit;">Cuando </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll est√° habilitado,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seguir√° recibiendo mensajes del analizador est√°tico sobre variables no inicializadas, incluso si </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll las</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inicializa por usted.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© no inicializamos todos los tipos?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durante las pruebas preliminares, inicializamos a la fuerza todos los tipos de datos asignados en la pila y observamos ca√≠das de rendimiento de m√°s del 10% en varios escenarios importantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si solo se inicializaron las estructuras POD, el rendimiento no se redujo tanto, y las optimizaciones del compilador destinadas a reducir el n√∫mero de operaciones de escritura innecesarias (tanto dentro de las unidades base como entre ellas) nos permitieron reducir a√∫n m√°s la desaceleraci√≥n de cualquier nivel notable al nivel de error en La mayor√≠a de las pruebas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Planeamos volver a la idea de inicializar todos los tipos (especialmente ahora que tenemos optimizaciones m√°s potentes), simplemente no hemos llegado a este punto.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© inicializamos variables con cero?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La inicializaci√≥n a cero proporciona los mejores resultados en t√©rminos de rendimiento (tanto en t√©rminos de velocidad como de tama√±o binario), as√≠ como en t√©rminos de seguridad.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desde una perspectiva de seguridad</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La inicializaci√≥n cero tiene las siguientes ventajas:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un puntero nulo arrojar√° una excepci√≥n SEH al desreferenciar en Windows (es decir, en el peor de los casos, esto causar√° un error de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">denegaci√≥n de servicio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero ser√° imposible la ejecuci√≥n remota de c√≥digo), que generalmente termina con un bloqueo del programa.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una variable que especifica un tama√±o o √≠ndice recibir√° un valor nulo. </font><font style="vertical-align: inherit;">Esto deber√≠a minimizar el riesgo de pasar el tama√±o no inicializado a funciones como </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy que</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trabajan con un b√∫fer cuyo tama√±o viene dado por el valor de la variable pasada.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de verificar el puntero nulo, el programa ejecutar√° la rama correspondiente y no intentar√° usarlo. </font><font style="vertical-align: inherit;">Por lo tanto, al menos, ser√° posible procesar correctamente los punteros que el desarrollador olvid√≥ inicializar (ya que un intento de acceder a la memoria utilizando un puntero inicializado autom√°ticamente siempre provocar√° un bloqueo).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las variables de tipo booleano con un valor de 0 significan "falso", que en las pruebas puede indicar un estado de error.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La inicializaci√≥n con cero tambi√©n tiene un par de desventajas:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La variable NTSTATUS tendr√° el valor STATUS_SUCCESS </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HRESULT ser√° S_OK </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero los valores devueltos pueden ser muy diferentes, y no existe un √∫nico valor universal con el que inicializarlos todos, especialmente teniendo en cuenta que tambi√©n debe usarse para tama√±os, √≠ndices, punteros, etc.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desde una perspectiva de rendimiento</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La velocidad del programa y el tama√±o del c√≥digo tambi√©n dependen del valor de inicializaci√≥n seleccionado. </font><font style="vertical-align: inherit;">No medimos qu√© tan peores fueron los resultados al usar un valor distinto de cero, ya que est√°bamos interesados ‚Äã‚Äãprincipalmente en los beneficios de seguridad que la inicializaci√≥n da a cero, y sab√≠amos que al mismo tiempo tendr√≠a un efecto positivo en el rendimiento (tanto la velocidad como el tama√±o del c√≥digo). </font><font style="vertical-align: inherit;">Nuestros colegas de Google tomaron medidas y mostraron que en Clang, la inicializaci√≥n con cero en este momento es notablemente m√°s rentable que la inicializaci√≥n con un valor distinto de cero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci√≥n, mostrar√© con ejemplos por qu√© al inicializar con cero, se obtiene menos c√≥digo.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo 1: Inicializaci√≥n utilizando registros de prop√≥sito general</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializaci√≥n por cero:</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">31</span> c0                            <span class="hljs-keyword">xor</span>    eax,eax
<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">01</span>                         mov    QWORD PTR [rcx],rax</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializaci√≥n con un valor distinto de cero:</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">48</span> b8 e2 e2 e2 e2 e2 e2 e2 e2    movabs rax,<span class="hljs-number">0xe2e2e2e2e2e2e2e2</span>
<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">01</span>                         mov    QWORD PTR [rcx],rax</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este ejemplo, estamos interesados ‚Äã‚Äãen dos puntos: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, establecer el registro RAX en cero requiere 2 bytes de c√≥digo versus 10 bytes cuando se establece en un valor distinto de cero. Resulta una ganancia tanto en tama√±o de c√≥digo como en velocidad. Muchos procesadores leen las instrucciones de 16 bytes a la vez, por lo que escribir una constante fija en el registro utilizando una instrucci√≥n de 10 bytes evita que se emitan las siguientes instrucciones que podr√≠an ejecutarse en paralelo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En segundo lugar, antes de que sea posible escribir el valor en el registro RCX, debe esperar hasta que se complete la escritura en RAX, lo que puede conducir al procesador inactivo. </font><font style="vertical-align: inherit;">Se reconocen secuencias como "xor eax, eax" en las primeras partes de la tuber√≠a, y no se requiere la ejecuci√≥n real del comando XOR: los procesadores simplemente restablecen el registro RAX. </font><font style="vertical-align: inherit;">Como resultado, la tuber√≠a est√° inactiva menos tiempo y el programa se ejecuta m√°s r√°pido.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo 2: Inicializaci√≥n utilizando registros XMM</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para escribir valores m√°s grandes, el compilador generalmente usa registros XMM (as√≠ como YMM o ZMM, dependiendo de si est√° habilitado el soporte para los conjuntos de instrucciones AVX o AVX512). </font><font style="vertical-align: inherit;">Como regla general, los procesadores no pueden completar m√°s de un comando de escritura en un ciclo de reloj, por lo que ser√≠a aconsejable utilizar comandos que establezcan tantos bytes como sea posible. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializaci√≥n por cero:</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">0f</span> <span class="hljs-number">57</span> c0                         xorps  xmm0,xmm0<font></font>
f3 <span class="hljs-number">0f</span> <span class="hljs-number">7f</span> <span class="hljs-number">01</span>                      movdqu XMMWORD PTR [rcx],xmm0</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializaci√≥n con un valor distinto de cero (cargado desde una variable global, que los compiladores suelen hacer):</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">66</span> <span class="hljs-number">0f</span> <span class="hljs-number">6f</span> <span class="hljs-number">04</span> <span class="hljs-number">25</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       movdqa xmm0,XMMWORD PTR ds:<span class="hljs-number">0x0</span>
f3 <span class="hljs-number">0f</span> <span class="hljs-number">7f</span> <span class="hljs-number">01</span>                      movdqu XMMWORD PTR [rcx],xmm0</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializaci√≥n con un valor distinto de cero (cargado desde una constante fija en el c√≥digo, que los compiladores no hacen):</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-number">48</span> ba e2 e2 e2 e2 e2 e2 e2 e2    movabs rdx,<span class="hljs-number">0xe2e2e2e2e2e2e2e2</span>
<span class="hljs-number">66</span> <span class="hljs-number">48</span> <span class="hljs-number">0f</span> <span class="hljs-number">6</span>e c2                   movq   xmm0,rdx
<span class="hljs-number">0f</span> <span class="hljs-number">16</span> c0                         movlhps xmm0,xmm0<font></font>
f3 <span class="hljs-number">0f</span> <span class="hljs-number">7f</span> <span class="hljs-number">01</span>                      movdqu XMMWORD PTR [rcx],xmm0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, en el caso de los registros XMM se observa la misma imagen. Cuando se inicializa a cero, el c√≥digo es muy peque√±o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No es posible escribir una constante fija directamente en el registro XMM. Primero debe guardarlo en el registro general, desde all√≠ moverlo al registro XMM y luego copiar los 64 bits bajos del registro XMM a sus 64 bits altos. Como resultado, obtenemos un c√≥digo largo y tres comandos, cada uno de los cuales debe esperar a que se complete el anterior.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para evitar esto, los compiladores, como regla, guardan una constante fija en forma de una variable global, desde la cual pueden leer el valor, lo que resulta en mucho menos c√≥digo. Desafortunadamente, debe esperar hasta el final de la escritura en el registro XMM antes de que est√© disponible para su uso. Si una variable global se descarga de la memoria, la operaci√≥n puede tomar varios miles de ciclos de reloj. Una operaci√≥n de lectura toma varios ciclos de reloj, incluso en el mejor de los casos, cuando los datos se almacenan en la memoria cach√© L1. E incluso en este caso, el c√≥digo es mucho m√°s largo que si solo reinicia el registro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto revela otra ventaja de la inicializaci√≥n cero: resultados m√°s deterministas. El tiempo de inicializaci√≥n no depende de si la variable global est√° en el cach√© L1, L2 o L3, si est√° descargada de la memoria, etc.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observaciones interesantes relacionadas con el uso de InitAll</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actuaci√≥n</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows 10 1903 (lanzado en la primavera de 2019) fue la primera versi√≥n en la que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> estaba habilitado de forma predeterminada. </font><font style="vertical-align: inherit;">Hasta ahora, no hemos recibido ninguna queja sobre la degradaci√≥n del rendimiento debido a ello.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compatibilidad</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anti fraude</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Poco despu√©s de activar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en Windows, comenzamos a recibir quejas sobre fallas del kernel causadas por algunos programas anti-trampas. </font><font style="vertical-align: inherit;">Despu√©s de examinar el problema, descubrimos que estos programas conten√≠an controladores en modo kernel que escaneaban la imagen del kernel NT en la memoria y buscaban secuencias de bytes espec√≠ficas que indicaran el comienzo de funciones no documentadas. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> agreg√≥ inicializaciones adicionales (cuya redundancia no se pudo probar) al comienzo de estas funciones, por lo que sus firmas han cambiado. </font><font style="vertical-align: inherit;">Contactamos a los desarrolladores de estos anti-trampas y, a pedido nuestro, actualizaron sus controladores para que ya no causen fallas en el kernel.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando memoria liberada en FAT32</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Poco despu√©s de habilitar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para los tipos de datos escalares (es decir, enteros, n√∫meros de coma flotante, etc.), encontramos un problema interesante en el controlador del sistema de archivos FAT, que no permit√≠a actualizar los ensamblados internos de Windows desde unidades flash USB de arranque. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El c√≥digo en el que ocurri√≥ el problema se parec√≠a a esto:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<font></font>
{<font></font>
      <span class="hljs-keyword">int</span> tmp;<font></font>
      DoStuff(&amp;tmp, i);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay un ciclo dentro del cual se declara una variable. En la primera iteraci√≥n del bucle, la funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DoStuff</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inicializa la variable 'tmp', cuya direcci√≥n se le pasa como argumento. En cada iteraci√≥n posterior, la variable 'tmp' se usa como par√°metro de entrada / salida. En otras palabras, su valor se lee primero y luego se actualiza. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema es que la variable en cuesti√≥n al comienzo de cada iteraci√≥n del bucle entra en su alcance y la deja al final de la iteraci√≥n. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inicializa esta variable a cero antes de cada iteraci√≥n. De hecho, tenemos una vulnerabilidad </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libre de uso despu√©s</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Para el funcionamiento normal del c√≥digo, se requiere que la variable 'tmp' conserve su valor en cada iteraci√≥n, incluso si al final de la iteraci√≥n queda fuera de alcance. </font><font style="vertical-align: inherit;">Desafortunadamente, este problema no condujo a un bloqueo del controlador, sino a una l√≥gica incorrecta de su funcionamiento y, como resultado, un comportamiento impredecible del sistema de archivos. </font><font style="vertical-align: inherit;">Durante la depuraci√≥n, el equipo del kernel determin√≥ la causa del problema y lo arregl√≥ eliminando la variable del bucle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este caso es un buen ejemplo de c√≥mo las mejoras de seguridad pueden romper el c√≥digo que no se ha analizado durante a√±os.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimizaciones de rendimiento</font></font></h2><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
optimizaciones de rendimiento </font><i><font style="vertical-align: inherit;">de InitAll</font></i><font style="vertical-align: inherit;"> tienen </font><font style="vertical-align: inherit;">tres objetivos:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proporcione a los desarrolladores la capacidad de deshabilitar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para c√≥digo cr√≠tico</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si es posible, elimine las operaciones de escritura innecesarias</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acelere las operaciones de escritura restantes tanto como sea posible</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desactivar InitAll para c√≥digo cr√≠tico</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las optimizaciones m√°s obvias son dejar que el c√≥digo:</font></font><ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desactivar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll completamente</font></font></i></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deshabilite </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para un tipo espec√≠fico (es decir, estructura typedef)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deshabilite </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para todas las operaciones de asignaci√≥n de memoria en la funci√≥n</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desactivar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para una declaraci√≥n de variable espec√≠fica en una funci√≥n</font></font></li>
</ol><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll est√°</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
actualmente </font><font style="vertical-align: inherit;">deshabilitado (por </font><i><font style="vertical-align: inherit;">razones de</font></i><font style="vertical-align: inherit;"> rendimiento) para un solo tipo: la estructura _CONTEXT, que almacena los valores de todos los registros. La inicializaci√≥n forzada condujo a una disminuci√≥n en el rendimiento en las pruebas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La estructura </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_CONTEXT</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tiene un tama√±o de m√°s de 1000 bytes, y esto es suficiente para almacenar los valores de todos los registros. Con el registro ETW activado para rastrear los cambios de contexto, cada vez que se cambia el contexto, se registran los valores de todos los registros. La estructura </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_CONTEXT</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en este caso se asignar√° en la pila, se completar√° con una funci√≥n de ensamblador y luego se pasar√° a ETW. Debido al hecho de que la estructura es inicializada por una funci√≥n ensambladora, el compilador no puede eliminar la inicializaci√≥n realizada</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dado que esta estructura ya contiene datos cr√≠ticos (estado de cada registro), es grande y se usa en ramas extremadamente exigentes en rendimiento, decidimos no aplicar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a ella </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para todos los dem√°s tipos, variables y funciones, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no </font><i><font style="vertical-align: inherit;">estaba deshabilitado</font></i><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminar operaciones de escritura innecesarias</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La eliminaci√≥n de operaciones de escritura innecesarias es una optimizaci√≥n realizada por el compilador de Visual Studio, que elimina las operaciones de escritura que pueden probarse como redundantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los siguientes son ejemplos de diferentes tipos de optimizaci√≥n utilizados por Visual Studio.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminando m√∫ltiples memset</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enlace a Godbolt: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://msvc.godbolt.org/z/Ldu7AP</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
El siguiente patr√≥n de c√≥digo (con diferentes variaciones) es extremadamente com√∫n. Las reglas iniciales de programaci√≥n de NT requieren que todas las variables se declaren al comienzo de la funci√≥n y se inicialicen lo m√°s tarde posible. Como resultado, tenemos casos en los que una variable se declara al comienzo de una funci√≥n, y se inicializa solo en cualquier rama inmediatamente antes de su uso. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> agrega su inicializaci√≥n variable al comienzo de la funci√≥n. El compilador puede eliminar el duplicado, pero esto no siempre es f√°cil de hacer.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">160</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dummy</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dummy"</span>);
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> b = <span class="hljs-literal">true</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-comment">//   memset,  ,   memset,  InitAll</span>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
  <font></font>
    <span class="hljs-keyword">if</span> (b) <span class="hljs-comment">//  volatile-,</span>
           <span class="hljs-comment">//        </span>
           <span class="hljs-comment">// (   ,      )</span><font></font>
    {<font></font>
        Dummy();<font></font>
        <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x1</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
        DoStuff(&amp;s);<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/hq/dl/ee/hqdleeuo4icifkr9_ijrp0rt_ps.png" alt="Cuadro 4"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece que este sencillo ejemplo deber√≠a optimizarse f√°cilmente, sin embargo, GCC 9.3 y Clang 10.0.0 (las √∫ltimas versiones disponibles en Godbolt) no pueden eliminar la llamada de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memoria</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adicional </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No estoy hablando de esto para criticar a estos compiladores: ambos optimizan muy bien el c√≥digo. </font><font style="vertical-align: inherit;">Solo quiero mostrar que algunos patrones pueden causar dificultades incluso para los compiladores m√°s potentes. </font><font style="vertical-align: inherit;">Antes de la llegada de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y las optimizaciones relacionadas, Visual Studio no pod√≠a eliminar la llamada adicional. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un ejemplo a√∫n m√°s simple:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
entre dos llamadas de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> solo hay una llamada de funci√≥n sin argumentos. </font><font style="vertical-align: inherit;">Este patr√≥n, como el anterior, es muy com√∫n en el c√≥digo de Microsoft. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enlace a Godbolt:</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://msvc.godbolt.org/z/HqFMx_</font></font></a><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">160</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dummy</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dummy"</span>);
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-comment">//   memset,  ,   memset,  InitAll</span>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
<font></font>
    Dummy();<font></font>
<font></font>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x1</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
<font></font>
    DoStuff(&amp;s);<font></font>
<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/fe/qo/7e/feqo7evdydknbjjwx9wwlvxt61a.png" alt="Cuadro 3"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVC elimina el exceso de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en este ejemplo. Clang 10.0.0 - tambi√©n, pero GCC 9.3 todav√≠a falla. Parece que este c√≥digo puede optimizarse f√°cilmente, pero para esto el compilador debe realizar un an√°lisis no trivial. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema aqu√≠ (en MSVC) es que el compilador usa an√°lisis de accesibilidad de objetos, independiente de la ramificaci√≥n o ejecuci√≥n de subprocesos. Desde el punto de vista del compilador, la variable 's' "escapa" de la funci√≥n actual (en otras palabras, su direcci√≥n se pasa a alg√∫n lugar fuera de esta funci√≥n), ya que su direcci√≥n se pasa a la funci√≥n 'DoStuff'. El compilador tambi√©n ve una llamada a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 's', luego una llamada a 'Dummy', seguida de otra llamada a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 's'.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desde el punto de vista del compilador, dado que la variable 's' "escap√≥" de la funci√≥n, la funci√≥n 'Dummy' te√≥ricamente podr√≠a leer el contenido de 's' o modificarlo antes de llamar a la funci√≥n 'DoStuff'. </font><font style="vertical-align: inherit;">Esto significa que una llamada a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no se puede eliminar ni antes ni despu√©s de 'Dummy'. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos ver que aunque la variable 's' y "escapa" de la funci√≥n actual, esto no sucede antes de que se llame a la funci√≥n 'DoStuff'. </font><font style="vertical-align: inherit;">El compilador MSVC ahora tambi√©n comprende esto (en un grado u otro) y puede eliminar la primera llamada de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reducci√≥n de tama√±o de memoria</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enlace a Godbolt: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://msvc.godbolt.org/z/fyLVUF</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
El siguiente patr√≥n tampoco es infrecuente. </font><font style="vertical-align: inherit;">La estructura se inicializa parcialmente y luego se transfiere a otra funci√≥n. </font><font style="vertical-align: inherit;">Es probable que esta segunda funci√≥n inicialice el resto de los datos de la estructura (o al menos no los lea), pero el compilador no puede probar esto.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">320</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dummy</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"dummy"</span>);
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> b = <span class="hljs-literal">true</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-comment">//   memset,  ,   memset,  InitAll</span>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (b) <span class="hljs-comment">//  volatile-,</span>
           <span class="hljs-comment">//        </span>
           <span class="hljs-comment">// (   ,      )</span><font></font>
    {<font></font>
        Dummy();<font></font>
        <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s)<span class="hljs-number">-0x160</span>);<font></font>
        DoStuff(&amp;s);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/qv/zv/ix/qvzvix4pxzqvazgvfzafdg_zraa.png" alt="Imagen 2"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVC ahora puede recortar el tama√±o del primer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que inicialice solo aquellos elementos en la estructura que el segundo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no inicializa </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nuevamente, GCC 9.3 y Clang 10.0.0 a√∫n no saben c√≥mo hacer esta optimizaci√≥n en este ejemplo.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barrido de memset m√°s eficiente</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enlace a Godbolt:</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
en el siguiente ejemplo, la llamada de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no se puede eliminar. </font><font style="vertical-align: inherit;">Por lo tanto, debe realizarse de la manera m√°s eficiente posible.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStruct</span>
{</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">12</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span><span class="hljs-params">(MyStruct* s)</span>
</span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hi"</span>, (<span class="hljs-keyword">int</span>*)&amp;s); <span class="hljs-comment">//   "s"</span>
                            <span class="hljs-comment">//   , </span>
                            <span class="hljs-comment">//    c  </span>
                            <span class="hljs-comment">//      "s"</span>
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{<font></font>
    MyStruct s;<font></font>
    <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0x0</span>, <span class="hljs-keyword">sizeof</span>(s));<font></font>
    DoStuff(&amp;s);<font></font>
    <span class="hljs-keyword">return</span>;<font></font>
}</code></pre><br>
<p><img src="https://habrastorage.org/webt/fm/yf/7v/fmyf7vxnqesyecgskxvarcbgyc4.png" alt="Foto 1"></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVC (como la mayor√≠a de los compiladores) puede "desplegar" peque√±as llamadas de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con un tama√±o y un valor de relleno est√°ticamente definidos. Es decir, la llamada de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se reemplaza por una secuencia de comandos de escritura directamente en la memoria. Gracias a esta optimizaci√≥n, el tiempo de ejecuci√≥n de las llamadas de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memoria</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peque√±a </font><font style="vertical-align: inherit;">(hasta 128 bytes) se reduce a una cuarta parte de lo habitual con una cantidad menor de c√≥digo (no es necesario guardar los valores de los registros en la pila, llamar a la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memoria</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y luego restaurar el estado de los registros). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSVC sol√≠a desplegar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en AMD64 utilizando registros de uso general. </font><font style="vertical-align: inherit;">Ahora usa registros de vectores, lo que le permite desplegar llamadas dos veces m√°s grandes. </font><font style="vertical-align: inherit;">Como resultado, obtenemos un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> m√°s </font><i><font style="vertical-align: inherit;">r√°pido</font></i><font style="vertical-align: inherit;"> y no dejamos que el c√≥digo crezca. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementaciones de memset m√°s productivas</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
. </font><b><font style="vertical-align: inherit;">Analizaremos</font></b><font style="vertical-align: inherit;"> este art√≠culo en detalle en otra ocasi√≥n.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valor del usuario</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desde que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lanzamos InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , muchas de las vulnerabilidades que los usuarios informaron a MSRC han dejado de reproducirse en versiones recientes de Windows. Gracias a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> estas vulnerabilidades han </font><i><font style="vertical-align: inherit;">evolucionado</font></i><font style="vertical-align: inherit;"> de "problemas de seguridad" a "defectos de c√≥digo que actualmente no tienen consecuencias negativas". Esto significa que ya no necesitamos entregar actualizaciones de seguridad para los sistemas operativos ya lanzados con </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> instalado </font><font style="vertical-align: inherit;">, lo que salva a los usuarios del dolor de cabeza que acompa√±a a la instalaci√≥n de parches, y a Microsoft del dolor de cabeza que acompa√±a su desarrollo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestras ramas activas del repositorio, todav√≠a mejoramos el c√≥digo y corregimos errores, as√≠ como tambi√©n hacemos cambios a los sistemas operativos ya lanzados en los que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaparecidos y que, por tanto, siguen siendo vulnerables. </font><font style="vertical-align: inherit;">Con el tiempo, las versiones sin </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ya no ser√°n compatibles. </font><font style="vertical-align: inherit;">Cuando esto sucede, los errores neutralizados con </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se corregir√°n solo en las ramas de desarrollo activo, y en los sistemas actuales ya no ser√° necesario </font><i><font style="vertical-align: inherit;">reparar</font></i><font style="vertical-align: inherit;"> este tipo de defectos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Planes futuros</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este momento, planeamos ocuparnos de dos tareas principales en el contexto de problemas con variables de pila no inicializadas:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para estudiar y utilizar la posibilidad de aplicar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a todos los tipos de datos asignados (es decir, matrices de todos los tipos y todas las clases, no solo POD)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implemente </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InitAll</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en todo el c√≥digo de Windows.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el futuro, planeamos averiguar si es posible estandarizar el proceso de eliminaci√≥n de los tipos de problemas descritos en C y C ++. No es necesario dejar variables sin inicializar por defecto en aras del rendimiento (especialmente si el compilador puede optimizar las operaciones de escritura redundantes). En cambio, ser√≠a mejor exigir al desarrollador que inicialice las variables antes de usarlas, "si se ha demostrado tal necesidad", y permitir que esta regla se viole solo si se usa una palabra clave especial para variables no inicializadas. Tal soluci√≥n preservar√≠a el alto rendimiento y al mismo tiempo salvar√≠a a los programadores de errores innecesarios.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Planeamos publicar otra nota sobre el trabajo en curso para neutralizar las vulnerabilidades de memoria no inicializadas en el mecanismo para asignar un grupo de memoria en el n√∫cleo de Windows.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comentario del traductor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El art√≠culo casi no est√° relacionado con mi tema nativo de an√°lisis de c√≥digo est√°tico, pero me pareci√≥ interesante y quer√≠a compartir la traducci√≥n con una audiencia de habla rusa. </font><font style="vertical-align: inherit;">Por mi cuenta, quiero agregar que los problemas de seguridad asociados con la "fuga" de datos privados generalmente consisten en dos componentes. </font><font style="vertical-align: inherit;">Primero: hay un lugar donde se deben borrar los datos privados, pero esto no sucede ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V597</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Segundo: los datos privados sin limpiar como parte de la memoria no inicializada pueden transferirse a alg√∫n lugar ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ejemplo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es505476/index.html">CRUD API en Deno y PostegreSQL: trabajando con un dinosaurio</a></li>
<li><a href="../es505478/index.html">Sustituci√≥n de un sistema CRM con un sistema CRM</a></li>
<li><a href="../es505488/index.html">12 consejos para implementar TypeScript en aplicaciones React</a></li>
<li><a href="../es505494/index.html">Enmarcado del desarrollador</a></li>
<li><a href="../es505496/index.html">Flutter Dev Podcast con CTO Meduza Boris Goryachev: lo principal sobre la aplicaci√≥n Meduz y el desarrollo de medios</a></li>
<li><a href="../es505502/index.html">Omnichannel en servicio al cliente: ¬øqu√© buscar y c√≥mo hacer todo bien?</a></li>
<li><a href="../es505506/index.html">√âl no muerde: c√≥mo hacer que los robots industriales sean seguros para los trabajadores</a></li>
<li><a href="../es505508/index.html">No solo tecnolog√≠a no tripulada: el futuro de la industria automotriz</a></li>
<li><a href="../es505510/index.html">Racionalizaci√≥n de la API de Check Point con Python SDK</a></li>
<li><a href="../es505516/index.html">Aprendizaje autom√°tico: d√≥nde comenzar o c√≥mo construir el primer modelo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>