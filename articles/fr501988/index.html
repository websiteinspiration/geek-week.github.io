<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚞 🚮 👩🏽‍✈️ Comment s'affiche l'écran de message VK? 😠 🏖️ 🤸🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Que fait VK pour réduire les retards de rendu? Comment afficher un très gros message et ne pas tuer UiThread? Comment réduire les délais de défilement...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Comment s'affiche l'écran de message VK?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/501988/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que fait VK pour réduire les retards de rendu? </font><font style="vertical-align: inherit;">Comment afficher un très gros message et ne pas tuer UiThread? </font><font style="vertical-align: inherit;">Comment réduire les délais de défilement dans RecyclerView? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vs/2s/jg/vs2sjg1iyfq7cdkohrmgpuy5mla.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mon expérience est basée sur le travail de dessin d'un écran de message dans l'application VK Android, dans lequel il est nécessaire d'afficher une énorme quantité d'informations avec un minimum de freins sur l'interface utilisateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je programme pour Android depuis près de dix ans, j'étais auparavant freelance pour PHP / Node.js. </font><font style="vertical-align: inherit;">Maintenant - un développeur Android senior VKontakte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sous la coupe - vidéo et transcription de mon rapport de la conférence Mobius 2019 à Moscou.</font></font><a name="habracut"></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GZkTwgetUWI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le rapport révèle trois sujets</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les solutions standard sont les principes de base du fonctionnement de l'écran de message VK. </font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les solutions non standard sont des solutions peu connues ou originales qui permettent de minimiser les retards d'interface utilisateur.</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les alternatives concernent différentes bibliothèques et implémentations, ainsi que les raisons pour lesquelles les développeurs VK ne les ont pas utilisées.</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regarde l'écran:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/he/h2/xj/heh2xjq-ij5pnzsu49cf11uuabu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce message est quelque part sur cinq écrans. </font><font style="vertical-align: inherit;">Et ils pourraient bien être avec nous (dans le cas du transfert de messages). </font><font style="vertical-align: inherit;">Les outils standard ne fonctionneront plus. </font><font style="vertical-align: inherit;">Même sur un appareil haut de gamme, tout peut prendre du retard. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, en plus de cela, l'interface utilisateur elle-même est assez diversifiée:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dates et indicateurs de chargement,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">messages de service</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">texte (emoji, lien, email, hashtags),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clavier bot</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">~ 40 façons d'afficher les pièces jointes,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arborescence des messages transférés.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La question se pose: comment réduire au maximum le nombre de décalages? </font><font style="vertical-align: inherit;">À la fois dans le cas de messages simples et dans le cas de messages en masse (cas de bord de la vidéo ci-dessus).</font></font><br>
<a name="ordinary"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solutions standard</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecyclerView et ses modules complémentaires</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe différents modules complémentaires pour RecyclerView.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setHasFixedSize ( </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beaucoup de gens pensent que ce drapeau est nécessaire lorsque les éléments de la liste sont de la même taille. </font><font style="vertical-align: inherit;">Mais en fait, à en juger par la documentation, le contraire est vrai. </font><font style="vertical-align: inherit;">C'est lorsque la taille de RecyclerView est constante et indépendante des éléments (à peu près, pas wrap_content). </font><font style="vertical-align: inherit;">La définition de l'indicateur permet d'augmenter légèrement la vitesse du RecyclerView afin d'éviter des calculs inutiles.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setNestedScrollingEnabled ( </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Optimisation mineure qui désactive la prise en charge de NestedScroll. </font><font style="vertical-align: inherit;">Nous n'avons pas CollapsingToolbar ou d'autres fonctionnalités en fonction de NestedScroll sur cet écran, nous pouvons donc définir ce drapeau sur false en toute sécurité.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setItemViewCacheSize ( </font></font><code>cache_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Configuration du cache RecyclerView interne. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beaucoup de gens pensent que les mécanismes de RecyclerView sont:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il y a un ViewHolder affiché sur l'écran;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il y a un RecycledViewPool stockant ViewHolder;</font></font></li>
<li> ViewHolder    —    RecycledViewPool.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En pratique, tout est un peu plus compliqué, car il y a un cache intermédiaire entre ces deux choses. </font><font style="vertical-align: inherit;">Il s'appelle ItemViewCache. </font><font style="vertical-align: inherit;">Quelle est son essence? </font><font style="vertical-align: inherit;">Lorsque le ViewHolder quitte l'écran, il n'est pas placé dans le RecycledViewPool, mais dans le cache intermédiaire (ItemViewCache). </font><font style="vertical-align: inherit;">Toutes les modifications apportées à l'adaptateur s'appliquent à la fois au ViewHolder visible et au ViewHolder à l'intérieur de ItemViewCache. </font><font style="vertical-align: inherit;">Et pour le ViewHolder à l'intérieur de RecycledViewPool, les modifications ne sont pas appliquées. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grâce à setItemViewCacheSize, nous pouvons définir la taille de ce cache intermédiaire. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus il est grand, plus le défilement sera rapide sur de courtes distances, mais les opérations de mise à jour prendront plus de temps (en raison de ViewHolder.onBind, etc.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment RecyclerView est implémenté et comment son cache est structuré est un sujet assez vaste et complexe. </font><font style="vertical-align: inherit;">Vous pouvez lire un excellent </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, où ils parlent en détail de tout.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimisation OnCreate / OnBind</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une autre solution classique consiste à optimiser onCreateViewHolder / onBindViewHolder:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mise en page facile (nous essayons d'utiliser autant que possible FrameLayout ou Custom ViewGroup),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les opérations lourdes (parsing links / emoji) se font de manière asynchrone au stade du chargement des messages,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StringBuilder pour la mise en forme du nom, de la date, etc.,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et d'autres solutions qui réduisent le temps de travail de ces méthodes.</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tracking Adapter.onFailedToRecyclerView ()</font></font></h3><br>
<img src="https://habrastorage.org/webt/8l/eo/1n/8leo1nki7gxrit4wg8mhhv0q3ua.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous disposez d'une liste dans laquelle certains éléments (ou une partie d'entre eux) sont animés en alpha. </font><font style="vertical-align: inherit;">Au moment où View, en cours d'animation, quitte l'écran, il ne passe pas à RecycledViewPool. </font><font style="vertical-align: inherit;">Pourquoi? </font><font style="vertical-align: inherit;">RecycledViewPool voit que la vue est maintenant animée par l'indicateur View.hasTransientState et l'ignore simplement. </font><font style="vertical-align: inherit;">Par conséquent, la prochaine fois que vous faites défiler vers le haut ou vers le bas, la photo ne sera pas prise à partir de RecycledViewPool, mais sera recréée à nouveau. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La décision la plus correcte est lorsque ViewHolder quitte l'écran, vous devez annuler toutes les animations. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-7/1r/rh/-71rrhbw5idwburnf60gtfllcau.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous avez besoin d'un correctif dès que possible ou si vous êtes un développeur paresseux, alors dans la méthode onFailedToRecycle, vous pouvez simplement toujours retourner true et tout fonctionnera, mais je ne le conseillerais pas.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/iu/se/ha/iusehamefbgzcvc6miixbtfmfoy.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suivi du découvert et du profileur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La manière classique de détecter les problèmes est le sur-retrait et le suivi du profileur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Overdraw - le nombre de redessins du pixel: moins il y a de couches et moins le pixel est redessiné, plus vite. Mais selon mes observations, dans les réalités modernes, cela n'affecte pas tellement les performances. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/0h/-d/fh/0h-dfhogberhs_hsy1eseaexkwa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Profiler - alias Android Monitor, qui est dans Android Studio. Dans celui-ci, vous pouvez analyser toutes les méthodes appelées. Par exemple, ouvrez des messages, faites défiler vers le haut et vers le bas et voyez quelles méthodes ont été appelées et combien de temps elles ont pris. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dz/la/wy/dzlawyqmpqtzxbnpcbezvfoq_ww.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout ce qui se trouve dans la moitié gauche est les appels système Android nécessaires pour créer / rendre un View / ViewHolder. Soit nous ne pouvons pas les influencer, soit nous devrons consacrer beaucoup d'efforts. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La moitié droite est notre code qui s'exécute dans ViewHolder.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le bloc d'appel au numéro 1 est un appel à des expressions régulières: quelque part, ils ont oublié et oublié de mettre l'opération sur le thread d'arrière-plan, ralentissant ainsi le défilement de ~ 20%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bloc d'appel au numéro 2 - Fresco, une bibliothèque pour afficher des images. </font><font style="vertical-align: inherit;">Il n'est pas optimal à certains endroits. On ne sait pas encore quoi faire avec ce décalage, mais si nous pouvons le résoudre, nous économiserons encore ~ ​​15%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autrement dit, en résolvant ces problèmes, nous pouvons obtenir une augmentation de ~ 35%, ce qui est plutôt cool.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Difficile</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beaucoup d'entre vous utilisent DiffUtil sous sa forme standard: il existe deux listes - appelées, comparées et poussées. Faire tout cela sur le thread principal est un peu cher car la liste peut être très longue. Ainsi, le calcul DiffUtil s'exécute généralement sur un thread d'arrière-plan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ListAdapter et AsyncListDiffer le font pour vous. Le ListAdapter étend l'adaptateur normal et démarre tout de manière asynchrone - il suffit de créer une liste de soumission et le calcul complet des modifications s'envole vers le thread d'arrière-plan interne. Le ListAdapter peut prendre en compte le cas de mises à jour fréquentes: si vous l'appelez trois fois de suite, il ne prendra que le dernier résultat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DiffUtil lui-même, nous utilisons uniquement pour certains changements structurels - l'apparence du message, son changement et sa suppression. </font><font style="vertical-align: inherit;">Pour certaines données à changement rapide, elles ne conviennent pas. </font><font style="vertical-align: inherit;">Par exemple, lorsque nous téléchargeons une photo ou lisons de l'audio. </font><font style="vertical-align: inherit;">De tels événements se produisent souvent - plusieurs fois par seconde, et si vous exécutez DiffUtil à chaque fois, vous aurez beaucoup de travail supplémentaire.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des animations</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il était une fois un cadre d'animation - plutôt maigre, mais toujours quelque chose. </font><font style="vertical-align: inherit;">Nous avons travaillé avec lui comme ceci:</font></font><br>
<br>
<pre><code class="java hljs">view.startAnimation(TranslateAnimation(fromX = <span class="hljs-number">0</span>, toX = <span class="hljs-number">300</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le problème est que le paramètre getTranslationX () renverra la même valeur avant et après l'animation. </font><font style="vertical-align: inherit;">C'est parce que l'animation a changé la représentation visuelle, mais n'a pas changé les propriétés physiques. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/f0/uu/tw/f0uutwhihhopkcfvps8itszyt_a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans Android 3.0, le framework Animator est apparu, ce qui est plus correct car il a modifié la propriété physique spécifique de l'objet. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q2/ib/qy/q2ibqywrlcla5cxqpslznxbxxm0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus tard, ViewPropertyAnimator est apparu et tout le monde ne comprend toujours pas vraiment sa différence avec Animator. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je vais expliquer. </font><font style="vertical-align: inherit;">Disons que vous devez effectuer la traduction en diagonale - déplacez la vue le long des axes x, y. </font><font style="vertical-align: inherit;">Très probablement, vous écririez du code typique:</font></font><br>
<br>
<pre><code class="java hljs">val animX = ObjectAnimator.ofFloat(view, “translationX”, <span class="hljs-number">100f</span>)<font></font>
val animY = ObjectAnimator.ofFloat(view, “translationY”, <span class="hljs-number">200f</span>)<font></font>
AnimatorSet().apply {<font></font>
    playTogether(animX, animY)<font></font>
    start()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et vous pouvez le raccourcir:</font></font><br>
<br>
<pre><code class="java hljs">view.animate().translationX(<span class="hljs-number">100f</span>).translationY(<span class="hljs-number">200f</span>) </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque vous exécutez view.animate (), vous lancez implicitement ViewPropertyAnimator. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi est-il nécessaire?</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lecture et maintenance du code plus faciles.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animation d'opérations par lots.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre dernier cas, nous avons modifié deux propriétés. Lorsque nous le faisons via des animateurs, les ticks d'animation seront appelés séparément pour chaque animateur. Autrement dit, setTranslationX et setTranslationY seront appelés séparément et View effectuera les opérations de mise à jour séparément. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cas de ViewPropertyAnimator, le changement se produit en même temps, il y a donc une économie due à moins d'opérations et le changement des propriétés lui-même est mieux optimisé.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez y parvenir avec Animator, mais vous devrez écrire plus de code. </font><font style="vertical-align: inherit;">De plus, en utilisant ViewPropertyAnimator, vous pouvez être sûr que les animations seront optimisées autant que possible. </font><font style="vertical-align: inherit;">Pourquoi? </font><font style="vertical-align: inherit;">Android a un RenderNode (DisplayList). </font><font style="vertical-align: inherit;">Très grossièrement, ils mettent en cache le résultat de onDraw et l'utilisent lors du redessin. </font><font style="vertical-align: inherit;">ViewPropertyAnimator fonctionne directement avec RenderNode et lui applique des animations, en évitant les appels onDraw. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De nombreuses propriétés d'affichage peuvent également affecter directement le RenderNode, mais pas toutes. </font><font style="vertical-align: inherit;">Autrement dit, lorsque vous utilisez ViewPropertyAnimator, vous êtes assuré d'utiliser la manière la plus efficace. </font><font style="vertical-align: inherit;">Si vous avez soudainement une sorte d'animation qui ne peut pas être faite avec ViewPropertyAnimator, alors vous devriez peut-être y penser et la changer.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animations: TransitionManager</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Habituellement, les gens associent que ce cadre est utilisé pour passer d'une activité à une autre. En fait, il peut être utilisé différemment et simplifier considérablement la mise en œuvre de l'animation des changements structurels. Supposons que nous ayons un écran sur lequel un message vocal est lu. Nous le fermons avec une croix, et le dé monte. Comment faire? L'animation est assez compliquée: le joueur se ferme avec alpha, tout en ne se déplaçant pas par translation, mais change de hauteur. Dans le même temps, notre liste monte et change également la hauteur. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mv/ff/kh/mvffkhe5udzkypeumimmusvhiig.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si le joueur faisait partie de la liste, l'animation serait assez simple. Mais pour nous, le joueur n'est pas un élément de la liste, mais une vision complètement indépendante.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peut-être que nous commencerions à écrire une sorte d'animateur, puis nous rencontrerions des problèmes, des plantages, commencerions à scier des béquilles et doubler le code. </font><font style="vertical-align: inherit;">Et obtiendrait quelque chose comme l'écran ci-dessous. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wd/0d/k-/wd0dk-urz2lfr6xugvvpmp16rdk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec TransitionManager, vous pouvez tout simplifier:</font></font><br>
<br>
<pre><code class="java hljs">TransitionManager.beginDelayedTransition(<font></font>
        viewGroup = &lt;LinearLayoutManager&gt;,<font></font>
        transition = AutoTransition())<font></font>
playerView.visibility = View.GONE</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toute animation se déroule automatiquement sous le capot. </font><font style="vertical-align: inherit;">Cela ressemble à de la magie, mais si vous allez profondément à l'intérieur et voyez comment cela fonctionne, il s'avère que le TransitionManager s'abonne simplement à toutes les vues, capture les modifications de leurs propriétés, calcule les différences, crée les animateurs nécessaires ou ViewPropertyAnimator si nécessaire, et fait tout aussi efficacement que possible. </font><font style="vertical-align: inherit;">TransitionManager nous permet de créer des animations dans la section des messages rapidement et facilement.</font></font><a name="extrodinary"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solutions personnalisées</font></font></h2><br>
<img src="https://habrastorage.org/webt/u2/rx/ji/u2rxjicmid-zkuhvqsxc4kxbeem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est la chose la plus fondamentale sur laquelle reposent les performances et les problèmes qui en découlent. Que faire lorsque votre message est sur 10 écrans? Si vous faites attention, tous nos éléments sont situés exactement les uns sous les autres. Si nous acceptons que ViewHolder n'est pas un seul message, mais des dizaines de ViewHolders différents, alors tout devient beaucoup plus simple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce n'est pas un problème pour nous que le message soit devenu 10 écrans, car maintenant nous affichons seulement six ViewHolders dans un exemple concret. Nous avons obtenu une mise en page facile, le code est plus facile à maintenir et il n'y a pas de problèmes particuliers, sauf un - comment faire?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ho/gh/ui/hoghuifbuntyzu3uszyjr6vij_0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe des ViewHolders simples - ce sont des séparateurs de date classiques, Charger plus, etc. </font><font style="vertical-align: inherit;">Et BaseViewHolder - ViewHolder de base conditionnelle pour le message. </font><font style="vertical-align: inherit;">Il a une implémentation de base et plusieurs spécifiques - TextViewHolder, PhotoViewHolder, AudioViewHolder, ReplyViewHolder et ainsi de suite. </font><font style="vertical-align: inherit;">Il y en a environ 70.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De quoi est responsable BaseViewHolder?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BaseViewHolder est uniquement responsable du dessin de l'avatar et du morceau de bulle souhaité, ainsi que de la ligne des messages transférés - bleu à gauche. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6o/yh/ia/6oyhiaag8f94wm6s69vskpv6r4u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'implémentation concrète du contenu est déjà effectuée par d'autres héritiers de BaseViewHolder: TextViewHolder affiche uniquement le texte, FwdSenderViewHolder - l'auteur du message transféré, AudioMsgViewHolder - le message vocal, etc. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/th/wi/sdthwihnbm9jm4xehrbh4mmrv20.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a un problème: que faire de la largeur? Imaginez un message sur au moins deux écrans. La largeur à définir n'est pas très claire, car la moitié est visible, la moitié n'est pas visible (et n'a même pas encore été créée). Absolument tout ne peut pas être mesuré, car il repose. Je dois béquiller un peu, hélas. Il y a des cas simples où le message est très simple: purement texte ou voix - en général, se compose d'un élément.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_q/i0/ov/_qi0ovd7qibtvqzcya0tzv_o4vq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, utilisez le wrap_content classique. </font><font style="vertical-align: inherit;">Pour un cas complexe, lorsqu'un message est composé de plusieurs éléments, nous prenons et forceons chaque ViewHolder sur une largeur fixe. </font><font style="vertical-align: inherit;">Plus précisément ici - 220 dp. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yi/fa/5t/yifa5tx6chfyxf2c26zeak-kaeu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si le texte est très court et que le message est transmis, il y a un espace vide à droite. </font><font style="vertical-align: inherit;">Il n'y a pas d'échappatoire à cela, car les performances sont plus importantes. </font><font style="vertical-align: inherit;">Pendant plusieurs années, il n'y a eu aucune plainte - peut-être que quelqu'un l'a remarqué, mais en général, tout le monde s'y est habitué. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/mz/0l/qbmz0lzz-o_lvhongodanb3fh1m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a des cas marginaux. </font><font style="vertical-align: inherit;">Si nous répondons à un message avec un autocollant, nous pouvons spécifier la largeur spécifiquement pour un tel cas, afin qu'il soit plus joli. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous nous divisons en ViewHolders au stade du chargement des messages: nous démarrons le chargement en arrière-plan du message, le convertissons en élément, ils sont directement affichés dans ViewHolders.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/12/w_/x7/12w_x7wp4a4a4s5f_dqeqrevlbc.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Global RecycledViewPool</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les mécanismes d'utilisation de notre messager sont tels que les gens ne s'assoient pas dans le même chat, mais passent constamment entre eux. </font><font style="vertical-align: inherit;">Dans l'approche standard, lorsque nous sommes entrés dans le chat et l'avons laissé, le RecycledViewPool (et le ViewHolder qu'il contient) sont simplement détruits, et chaque fois que nous dépensons des ressources pour créer le ViewHolder. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela peut être résolu par Global RecycledViewPool:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le cadre d'Application, RecycledViewPool vit comme un singleton;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">réutilisé sur l'écran de message lorsque l'utilisateur passe d'un écran à l'autre;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">défini comme RecyclerView.setRecycledViewPool (pool).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a des pièges, il est important de se rappeler deux choses:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous allez à l'écran, cliquez sur retour, quittez. </font><font style="vertical-align: inherit;">Le problème est que les ViewHolders qui étaient à l'écran sont jetés et ne sont pas retournés à la piscine. </font><font style="vertical-align: inherit;">Ceci est résolu comme suit:</font></font><br>
<pre><code class="java hljs">LinearLayoutManager.recycleChildrenOnDetach = <span class="hljs-keyword">true</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecycledViewPool a des limites: pas plus de cinq ViewHolders peuvent être stockés pour chaque ViewType.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si 9 TextViews s'affichent à l'écran, seuls cinq éléments seront renvoyés au RecycledViewPool et les autres seront jetés. </font><font style="vertical-align: inherit;">Vous pouvez changer la taille du RecycledViewPool: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RecycledViewPool.setMaxRecycledViews (viewType, size) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais il est en quelque sorte triste de prescrire pour chaque ViewType avec vos mains, car vous pouvez écrire votre RecycledViewPool, en étendant le standard et en faire NoLimit. </font><font style="vertical-align: inherit;">Par le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous pouvez télécharger l'implémentation terminée.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DiffUtil n'est pas toujours utile</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un cas classique - téléchargement, lecture d'une piste audio et d'un message vocal. </font><font style="vertical-align: inherit;">Dans ce cas, DiffUtil appelle le spam. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ho/3o/lt/ho3oltgo6763hgc65xxel-ccopa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre BaseViewHolder a une méthode abstraite updateUploadProgress.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseViewHolder</span> : <span class="hljs-title">ViewHolder</span> </span>{<font></font>
    …<font></font>
    <span class="hljs-function">fun <span class="hljs-title">updateUploadProgress</span><span class="hljs-params">(attachId: Int, progress: Float)</span>
    …        
}
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour lancer un événement, nous devons contourner tous les ViewHolder visibles:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">fun <span class="hljs-title">onUploadProgress</span><span class="hljs-params">(attachId: Int, progress: Float)</span> </span>{<font></font>
    forEachActiveViewHolder {<font></font>
        it.updateUploadProgress(attachId, progress)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit d'une opération simple, il est peu probable que nous ayons plus de dix ViewHolder à l'écran. </font><font style="vertical-align: inherit;">Une telle approche ne peut pas être en retard sur le principe. </font><font style="vertical-align: inherit;">Comment trouver ViewHolder visible? </font><font style="vertical-align: inherit;">Une implémentation naïve serait quelque chose comme ceci:</font></font><br>
<br>
<pre><code class="java hljs">val firstVisiblePosition = &lt;...&gt;<font></font>
val lastVisiblePosition = &lt;...&gt;<font></font>
<span class="hljs-keyword">for</span> (i in firstVisiblePosition.. lastVisiblePosition) {<font></font>
    val viewHolder = recycler.View.findViewHolderForAdapterPosition(i)<font></font>
    viewHolder.updateUploadProgress(..)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais il y a un problème. </font><font style="vertical-align: inherit;">Le cache intermédiaire que j'ai mentionné plus tôt, ItemViewCache, contient des ViewHolders actifs qui n'apparaissent tout simplement pas à l'écran. </font><font style="vertical-align: inherit;">Le code ci-dessus ne les affectera pas. </font><font style="vertical-align: inherit;">Directement, nous ne pouvons pas non plus y répondre. </font><font style="vertical-align: inherit;">Et puis des béquilles viennent à notre aide. </font><font style="vertical-align: inherit;">Créez un WeakSet qui stocke les liens vers ViewHolder. </font><font style="vertical-align: inherit;">De plus, il nous suffit de contourner simplement ce WeakSet.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> : <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">Adapter</span> </span>{<font></font>
    val activeViewHolders = WeakSet&lt;ViewHolder&gt;()<font></font>
        <font></font>
    <span class="hljs-function">fun <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: ViewHolder, position: Int)</span> </span>{<font></font>
        activeViewHolders.add(holder)<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">fun <span class="hljs-title">onViewRecycled</span><span class="hljs-params">(holder: ViewHolder)</span> </span>{<font></font>
        activeViewHolders.remove(holder)<font></font>
    }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Superposition de ViewHolder</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenons l'exemple des histoires. Auparavant, si une personne réagissait à une histoire avec un autocollant, nous la présentions comme ceci: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rc/kd/z1/rckdz16ebmfwftxzfpql2lwmsko.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
elle a l'air assez moche. Je voulais faire mieux, car les histoires ont un contenu lumineux et nous avons un petit carré là-bas. Mais nous voulions obtenir quelque chose comme ceci: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vj/ma/51/vjma51z9m4eqwlhiagc7xvu2kg0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a un problème: notre message est divisé en ViewHolder, ils sont situés strictement les uns sous les autres, mais ici ils se chevauchent. Immédiatement, on ne sait pas comment résoudre ce problème. Vous pouvez créer un autre ViewType «historique + autocollant» ou «historique + message vocal». Donc, au lieu de 70 ViewType, nous en aurions 140 ... Non, nous devons trouver quelque chose de plus pratique.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/01/mr/5j/01mr5jqsfdpq_zcq4s3b-vf9pyq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une de vos béquilles préférées dans Android me vient à l'esprit. </font><font style="vertical-align: inherit;">Par exemple, nous faisions quelque chose, mais Pixel Perfect ne converge pas. </font><font style="vertical-align: inherit;">Pour résoudre ce problème, vous devez tout supprimer et écrire à partir de zéro, mais la paresse. </font><font style="vertical-align: inherit;">En conséquence, nous pouvons faire une marge = -2dp (négative), et maintenant tout se met en place. </font><font style="vertical-align: inherit;">Mais une telle approche ne peut pas être utilisée ici. </font><font style="vertical-align: inherit;">Si vous définissez une marge négative, l'autocollant se déplacera, mais la place qu'il occupait restera vide. </font><font style="vertical-align: inherit;">Mais nous avons ItemDecoration, où itemOffset nous pouvons faire un nombre négatif. </font><font style="vertical-align: inherit;">Et il fonctionne! </font><font style="vertical-align: inherit;">En conséquence, nous obtenons la superposition attendue et en même temps il reste un paradigme où chaque ViewHolder est ami. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une belle solution en une seule ligne.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OffsetItemDecoration</span> : <span class="hljs-title">RecyclerViewItemDecoration</span>() </span>{
    <span class="hljs-function">overrride fun <span class="hljs-title">getItemOffsets</span><span class="hljs-params">(offset: Rect, …)</span> </span>{<font></font>
        offset.top = -<span class="hljs-number">100</span>dp<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idlehandler</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est un cas avec un astérisque, c'est complexe et pas si souvent nécessaire en pratique, mais il est important de connaître l'existence d'une telle méthode. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, je vais vous expliquer le fonctionnement du thread principal UiThread. Le schéma général: il existe une file d'attente d'événements de tâches dans laquelle les tâches sont définies via handler.post, et une boucle infinie qui traverse cette file d'attente. Autrement dit, UiThread est juste pendant (vrai). S'il y a des tâches, on les exécute, sinon, on attend qu'elles apparaissent.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y3/ee/nn/y3eennjezxs29i4lkbvggnqkgjw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans nos réalités habituelles, Handler est responsable de la mise des tâches dans la file d'attente, et Looper contourne sans cesse la file d'attente. </font><font style="vertical-align: inherit;">Il y a des tâches qui ne sont pas très importantes pour l'interface utilisateur. </font><font style="vertical-align: inherit;">Par exemple, un utilisateur lit un message - ce n'est pas si important pour nous lorsque nous l'afficherons sur l'interface utilisateur, maintenant ou après 20 ms. </font><font style="vertical-align: inherit;">L'utilisateur ne remarquera pas la différence. </font><font style="vertical-align: inherit;">Alors, cela vaut peut-être la peine d'exécuter cette tâche sur le thread principal uniquement lorsqu'elle est gratuite? </font><font style="vertical-align: inherit;">Autrement dit, il serait bon pour nous de savoir quand la ligne waitNewTask est appelée. </font><font style="vertical-align: inherit;">Dans ce cas, Looper a un addIdleHandler qui se déclenche lorsque le code tasks.isEmpty se déclenche. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Looper.myQueue (). AddIdleHandler ()</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Et puis l'implémentation la plus simple de IdleHandler ressemblera à ceci:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@AnyThread</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdleHandler</span> </span>{
    <span class="hljs-keyword">private</span> val handler = Handler(Looper.getMainLooper())<font></font>
<font></font>
    <span class="hljs-function">fun <span class="hljs-title">post</span><span class="hljs-params">(task: Runnable)</span> </span>{<font></font>
        handler.post {<font></font>
            Looper.myQueue().addIdleHandler {<font></font>
                task.run()<font></font>
                <span class="hljs-keyword">return</span><span class="hljs-meta">@addIdleHandler</span> <span class="hljs-keyword">false</span><font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De la même manière, vous pouvez mesurer un démarrage à froid honnête de l'application.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Emoji</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous utilisons nos emoji personnalisés au lieu de ceux du système. Voici un exemple de l'apparence des emojis sur différentes plateformes au cours des différentes années. Les emoji gauche et droit sont plutôt sympas, mais au milieu ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bv/71/m3/bv71m3d7rginefvtev6ogcgwess.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a un deuxième problème: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dw/-1/nx/dw-1nxxjfpggaxcjo_-idb0ofce.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
chaque ligne est le même emoji, mais les émotions qu'ils reproduisent sont différentes. J'aime le bas à droite le plus, je ne comprends toujours pas ce que cela signifie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a un vélo de VKontakte. En ~ 2014, nous avons légèrement changé un emoji. Peut-être que quelqu'un se souvient - "Marshmallow" l'était. Après son changement, une mini-émeute a commencé. Bien sûr, il n'a pas atteint le niveau «retour du mur», mais la réaction a été assez intéressante. Et cela nous indique l'importance d'interpréter les emoji.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment les émojis sont faits: nous avons un grand bitmap, où ils sont tous assemblés dans un grand «atlas». </font><font style="vertical-align: inherit;">Il y en a plusieurs - sous différents DPI. </font><font style="vertical-align: inherit;">Et il y a un EmojiSpan qui contient des informations: je dessine "tel ou tel" emoji, il est dans tel ou tel bitmap à tel ou tel endroit (x, y). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et il y a un ReplacementSpan qui vous permet d'afficher quelque chose au lieu de texte sous Span. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autrement dit, vous trouvez des emoji dans le texte, enveloppez-les avec EmojiSpan, et le système dessine les emoji souhaités au lieu du système.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/y5/tq/agy5tq5wl0ys8vbwuqgwhpfeoli.png"><a name="alt"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternatives</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gonfler</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelqu'un peut dire que comme le gonflage est lent, pourquoi ne pas simplement créer une disposition avec vos mains, en évitant de gonfler. </font><font style="vertical-align: inherit;">Et accélérez ainsi tout en évitant le 100500 ViewHolder. </font><font style="vertical-align: inherit;">C'est une illusion. </font><font style="vertical-align: inherit;">Avant de faire quelque chose, il vaut la peine de le mesurer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android a une classe Debug, il a startMethodTracing et stopMethodTracing.</font></font><br>
<br>
<pre><code class="java hljs">Debug.startMethodTracing(“trace»)<font></font>
inflate(...)<font></font>
Debug.stopMethodTracing()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela nous permettra de collecter des informations sur le temps d'exécution d'un morceau de code particulier. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ea/hz/wa/eahzwatykq-cflwr2ul3qnwbvq4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et on voit qu'ici gonfler en tant que tel est même invisible. </font><font style="vertical-align: inherit;">Un quart du temps a été consacré au chargement de dessins, un quart au chargement de couleurs. </font><font style="vertical-align: inherit;">Et ce n'est que quelque part dans la partie etc. que notre gonflement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai essayé de traduire la disposition XML en code et j'ai enregistré environ 0,5 ms. </font><font style="vertical-align: inherit;">L'augmentation, en fait, n'est pas la plus impressionnante. </font><font style="vertical-align: inherit;">Et le code est devenu beaucoup plus compliqué. </font><font style="vertical-align: inherit;">Autrement dit, la réécriture n'a pas beaucoup de sens.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, en pratique, beaucoup ne rencontreront pas du tout ce problème, car un long gonflement ne se produit généralement que lorsque l'application devient très volumineuse. </font><font style="vertical-align: inherit;">Dans notre application VKontakte, par exemple, il y a environ 200 à 300 écrans différents, et le chargement de toutes les ressources plante. </font><font style="vertical-align: inherit;">Que faire de cela n'est pas encore clair. </font><font style="vertical-align: inherit;">Très probablement, vous devrez écrire votre propre gestionnaire de ressources.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anko</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anko est récemment devenu obsolète. </font><font style="vertical-align: inherit;">Quoi qu'il en soit, Anko n'est pas magique, mais un sucre syntaxique simple. </font><font style="vertical-align: inherit;">Il traduit tout dans la nouvelle vue conditionnelle () de la même manière. </font><font style="vertical-align: inherit;">Par conséquent, il n'y a aucun avantage d'Anko.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Litho / Flutter</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi ai-je combiné deux choses complètement indépendantes? </font><font style="vertical-align: inherit;">Parce qu'il ne s'agit pas de technologie, mais de la complexité de la migration vers celle-ci. </font><font style="vertical-align: inherit;">Vous ne pouvez pas simplement emprunter et passer à une nouvelle bibliothèque. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On ne sait pas si cela nous donnera un coup de fouet sur les performances. </font><font style="vertical-align: inherit;">Et nous n'obtiendrons pas de nouveaux problèmes, car des millions de personnes avec des appareils complètement différents utilisent notre application chaque minute (vous n'en avez probablement même pas entendu parler environ un quart). </font><font style="vertical-align: inherit;">De plus, les messages sont une très grande base de code. </font><font style="vertical-align: inherit;">Il est impossible de tout réécrire instantanément. </font><font style="vertical-align: inherit;">Et le faire à cause du battage médiatique de la technologie est stupide. </font><font style="vertical-align: inherit;">Surtout quand le Jetpack Compose se profile quelque part très loin.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetpack compose</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Google nous promet tous de la manne céleste sous la forme de cette bibliothèque, mais elle est toujours en alpha. </font><font style="vertical-align: inherit;">Et quand ce sera dans la version - ce n'est pas clair. </font><font style="vertical-align: inherit;">Nous ne savons pas non plus si nous pouvons l'obtenir sous sa forme actuelle. </font><font style="vertical-align: inherit;">Il est trop tôt pour expérimenter. </font><font style="vertical-align: inherit;">Laissez-le sortir en stable, laissez les principaux bugs se fermer. </font><font style="vertical-align: inherit;">Et c'est seulement alors que nous regarderons dans sa direction.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une grande vue personnalisée</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe une autre approche dont parlent ceux qui utilisent divers messageries instantanées: «prenez et écrivez une grande vue personnalisée, pas de hiérarchie compliquée». </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quels sont les inconvénients?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est difficile à maintenir.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela n'a pas de sens dans les réalités actuelles.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec Android 4.3, le système de mise en cache interne dans View a été pompé. </font><font style="vertical-align: inherit;">Par exemple, onMeasure n'est pas appelé si la vue n'a pas changé. </font><font style="vertical-align: inherit;">Et les résultats de la mesure précédente sont utilisés. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec Android 4.3-4.4, un RenderNode (DisplayList) est apparu, mettant en cache le rendu. </font><font style="vertical-align: inherit;">Regardons un exemple. </font><font style="vertical-align: inherit;">Supposons qu'il y ait une cellule dans la liste des dialogues: avatar, titre, sous-titre, état de lecture, heure, un autre avatar. </font><font style="vertical-align: inherit;">Conditionnellement - 10 éléments. </font><font style="vertical-align: inherit;">Et nous avons écrit Custom View. </font><font style="vertical-align: inherit;">Dans ce cas, lorsque vous modifiez une propriété, nous mesurerons à nouveau tous les éléments. </font><font style="vertical-align: inherit;">Autrement dit, il suffit de dépenser les ressources supplémentaires. </font><font style="vertical-align: inherit;">Dans le cas du ViewGroup, où chaque élément est une vue distincte, lorsque vous changez une vue, nous invaliderons une seule vue (sauf lorsque cette vue affecte la taille des autres).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sommaire</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous avez donc appris que nous utilisons le RecyclerView classique avec des optimisations standard. Il y en a une partie non standard, où le plus important et le plus fondamental est de diviser le message en ViewHolder. Bien sûr, vous pouvez dire que cela est étroitement applicable, mais cette approche peut également être projetée sur d'autres choses, par exemple, sur un grand texte de 10 000 caractères. Il peut être divisé en paragraphes, où chaque paragraphe est un ViewHolder distinct. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il vaut également la peine de tout maximiser sur @WorkerThread: analyse des liens, DiffUtils - déchargeant ainsi @UiThead autant que possible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le Global RecycledViewPool vous permet de parcourir les écrans de messages et de ne pas créer un ViewHolder à chaque fois. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais il y a d'autres choses importantes que nous n'avons pas encore décidées, par exemple, un long gonflement, ou plutôt, le chargement des données à partir des ressources.</font></font><br>
<br>
<blockquote>    ,   Mobius 2019 Piter  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>,     .     ,     ,  SQLite,     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mobius 2020 Piter</a>     .</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr501978/index.html">Comment fonctionne l'histogramme Prometheus?</a></li>
<li><a href="../fr501980/index.html">L'histoire d'un projet ou comment j'ai créé un PBX de 7 ans basé sur Asterisk et Php</a></li>
<li><a href="../fr501982/index.html">Comment transférer un shader d'un moteur de jeu vers Substance Painter</a></li>
<li><a href="../fr501984/index.html">Que voir en quarantaine? Une sélection de matériaux de Technostream (partie 4)</a></li>
<li><a href="../fr501986/index.html">Les secrets de l'incroyable succès des Apple AirPods</a></li>
<li><a href="../fr501990/index.html">Poste utile: 4 événements pour résoudre les problèmes de la deuxième journée dans OpenShift et créer des opérateurs</a></li>
<li><a href="../fr501992/index.html">Comment organiser les tests afin d'accélérer et de stabiliser les versions des produits. Partie 1</a></li>
<li><a href="../fr501994/index.html">Orchestrator pour MySQL: pourquoi un projet à sécurité intégrée ne peut pas être construit sans lui</a></li>
<li><a href="../fr501996/index.html">Zen Go (Pocket Version)</a></li>
<li><a href="../fr501998/index.html">Prix ​​cher des styles. Rapport Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>