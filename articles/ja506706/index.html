<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏾 🎰 🛤️ 大量のデータを処理するときの最新のJavaのパフォーマンス、パート1 ♈️ 💻 👩🏾‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Javaランタイムは、近年、以前よりも速く進化しています。15年後、ようやくデフォルトのガベージコレクターG1を手に入れました。さらに2つが開発中で、実験的な機能として利用可能です-Oracle ZGCとOpenJDK Shenandoah。私たちはこれらすべての新しいツールをテストし、Hazelc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>大量のデータを処理するときの最新のJavaのパフォーマンス、パート1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/506706/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/gy/8p/zf/gy8pzf7gjtwr9pvv1zb7rgmmjiy.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaランタイムは、近年、以前よりも速く進化しています。</font><font style="vertical-align: inherit;">15年後、ようやくデフォルトのガベージコレクターG1を手に入れました。</font><font style="vertical-align: inherit;">さらに2つが開発中で、実験的な機能として利用可能です-Oracle ZGCとOpenJDK Shenandoah。</font><font style="vertical-align: inherit;">私たちはこれらすべての新しいツールをテストし、Hazelcast Jet分散型オープンソースストリーミングエンジンの典型的なワークロードに最適なものを見つけることにしました。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetは、さまざまな遅延と帯域幅の要件を持つあらゆる種類のタスクを解決するために使用されます。</font><font style="vertical-align: inherit;">タスクは3つの重要なカテゴリに分類されます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無制限の低遅延ストリーミング。</font><font style="vertical-align: inherit;">例：100 Hzの周波数で情報を取得する10,000台のデバイスのセンサーからのデータの傾向を識別し、10〜20ミリ秒以内に修正を送信します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高帯域幅の無制限のストリーミング処理。</font><font style="vertical-align: inherit;">例：数百万のユーザーのGPS座標を追跡し、速度ベクトルを計算します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビッグデータの古典的なバッチ処理。</font><font style="vertical-align: inherit;">基準は、処理に費やされる時間です。つまり、高いスループットが必要になります。</font><font style="vertical-align: inherit;">例：特定の資産ポートフォリオのリスクレベルを更新するために1日に収集される株式取引データの分析。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、次のことを確認できます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のシナリオでは、遅延要件は、ガベージコレクタの一時停止の危険ゾーンに該当します。100ミリ秒。</font><font style="vertical-align: inherit;">これは、最も困難な場合のガベージコレクションの優れた結果であると考えられており、多くの状況でそれは障害となります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目と3番目のシナリオは、ガベージコレクションの要件が同じです。</font><font style="vertical-align: inherit;">遅延の要件はそれほど厳しくありませんが、保有世代に大きな負荷がかかります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目のシナリオは、最初のシナリオほど厳しくなくても、遅延要件があるためより困難です。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の組み合わせを試しました。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトのParallelアセンブラーとオプションのConcurrentMarkSweepおよびG1を備えたJDK 8。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトのコレクターG1およびオプションのParallelを備えたJDK 11。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトのコレクターG1と実験的なZGCおよびシェナンドアを備えたJDK 14。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の結論に達しました。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JDKの最新バージョンでは、G1ビルダーは優れた働きをします。</font><font style="vertical-align: inherit;">数十ギガバイトのヒープ（60 GBを試した）を簡単に処理でき、最大200ミリ秒の一時停止があります。</font><font style="vertical-align: inherit;">極端な負荷がかかると、G1は悪夢のようなクリティカルモードに入りません。</font><font style="vertical-align: inherit;">代わりに、完全なガベージコレクションの一時停止期間は数秒に増加します。</font><font style="vertical-align: inherit;">コレクターの弱点は、低負荷の好ましい条件での一時停止の上限です。</font><font style="vertical-align: inherit;">なんとか20-25ミリ秒に下げました。</font></font></li>
<li>JDK 8 —   .    Parallel       .  G1    ,    ,       ,     .       12    20   Parallel     G1. ConcurrentMarkSweep       G1,           .</li>
<li>  ZGC    ,   G1,        ,  G1       10 . </li>
<li>Shenandoah        220    .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZGCもシェナンドアも、G1ほど着実にクリティカルモードで動作しませんでした。</font><font style="vertical-align: inherit;">彼らの仕事は信頼性が低く、低遅延モードでは、非常に長い休止が予期せず発生し、OOMEでさえありました。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、2つのストリーミング処理シナリオでのテストの結果について説明します。</font><font style="vertical-align: inherit;">後半では、バッチ処理の結果について説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリーム処理ベンチマーク</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリーミングベンチマークでは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを使用して、テスト間で少し変更しました。</font><font style="vertical-align: inherit;">これが主要部分であるJetパイプラインです。</font></font><br>
<br>
<pre><code class="java hljs">StreamStage&lt;Long&gt; source = p.readFrom(longSource(ITEMS_PER_SECOND))<font></font>
                            .withNativeTimestamps(<span class="hljs-number">0</span>)<font></font>
                            .rebalance(); <span class="hljs-comment">// Introduced in Jet 4.2</span><font></font>
source.groupingKey(n -&gt; n % NUM_KEYS)<font></font>
      .window(sliding(SECONDS.toMillis(WIN_SIZE_SECONDS), SLIDING_STEP_MILLIS))<font></font>
      .aggregate(counting())<font></font>
      .filter(kwr -&gt; kwr.getKey() % DIAGNOSTIC_KEYSET_DOWNSAMPLING_FACTOR == <span class="hljs-number">0</span>)<font></font>
      .window(tumbling(SLIDING_STEP_MILLIS))<font></font>
      .aggregate(counting())<font></font>
      .writeTo(Sinks.logger(wr -&gt; String.format(<span class="hljs-string">"time %,d: latency %,d ms, cca. %,d keys"</span>,<font></font>
              simpleTime(wr.end()),<font></font>
              NANOSECONDS.toMillis(System.nanoTime()) - wr.end(),<font></font>
              wr.result() * DIAGNOSTIC_KEYSET_DOWNSAMPLING_FACTOR)));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このパイプラインは、イベントのフローが無制限の使用シナリオを反映しています。エンジンは、「スライディングウィンドウ」メソッドを使用してデータを集計する必要があります。このような集計は、たとえば、変化する値の時間微分を取得したり、高周波ノイズからデータを消去したり（平滑化）、またはイベントの発生頻度（1秒あたりのイベント数）を測定したりするために必要です。エンジンは最初にストリームをカテゴリ（たとえば、すべての個別のIoTデバイスまたはスマートフォン）にサブストリームに分割できます。そして、各サブフローの集計値を個別に追跡します。 Hazelcast Jetでは、スライディングウィンドウは、指定したサイズで個別のステップで移動します。たとえば、1秒のステップで、毎秒完全な結果セットが得られます。そして、1分のステップで、最後の1分間に起こったすべてが結果に含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかのメモ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードは完全に自己完結型です。外部データソースは使用されません。スタブソースを使用して、適切な頻度でイベントのストリームをエミュレートします。イベントは定期的に発生します。ソースは、タイムスタンプが未来に関連するイベントを生成しませんが、可能な限り迅速にそれらを生成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パイプラインが遅れると、イベントは保存されずに「バッファリング」されます。この場合、パイプラインは、データをできるだけ早く受信する必要があります。ソースが並列化されていないため、その帯域幅制限は1秒あたり約220万イベントに達しました。 100万イベント/秒をエミュレートし、最大120万イベント/秒をキャッチするためのマージンを残しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンベヤは、スライディングウィンドウの結果のタイムスタンプを現在の時刻と比較することにより、遅延を測定します。中間濾過を伴う2段階の凝集が使用された。 1つのスライディングウィンドウの結果には、各サブストリームに1つずつ、多くの要素が含まれます。最後の要素の遅延に関心があります。したがって、最初に結果の大部分を除外し、1万番目ごとの要素を残します。次に、減少したフローを第2ステージに向け、キーのない「フリッピング」ウィンドウを使用します。この段階で、結果のサイズを記録し、遅延を測定します。キーを使用しない集計は並列化されないため、測定ポイントは1つです。ろ過ステージは並列化され、データローカルであるため、追加の集計ステージの影響は非常に小さい（1 msよりはるかに小さい）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純な集計関数であるカウントを使用しました。実際、ストリーム内のイベントの頻度のメトリックが取得されました。最小限の構造（1つの型番号</font></font><code>long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）で、ガベージは生成されません。ヒープ使用量（ギガバイト単位）の場合、このような小さなキー構造は、ガベージコレクタの最悪のシナリオ、つまり非常に多数のオブジェクトを意味します。コレクターの負荷は、ヒープのサイズでは増加しませんが、オブジェクトの数では増加します。また、同じ集計関数を計算するオプションをテストしましたが、ガベージを生成する実装が異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パイプラインのパフォーマンスに対するメモリ管理の影響に関心があったため、1つのノードでほとんどのストリームベンチマークを実行しました。</font><font style="vertical-align: inherit;">また、ネットワーク遅延はデータにノイズを追加するだけです。</font><font style="vertical-align: inherit;">クラスターのパフォーマンスが調査結果に影響しないという仮説をテストするために、3ノードのAmazon EC2クラスターでいくつかの主要なテストを繰り返しました。</font><font style="vertical-align: inherit;">これについては、2番目の記事の終わり近くで詳しく説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parallelコレクターが作成する遅延ピークはほとんどの実際のシナリオでは許容できないため、ストリーミングコレクターの結果からParallelコレクターを削除しました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シナリオ1：低遅延、中規模の構造</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スクリプトオプション：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenJDK 14</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVMヒープサイズは4 GBです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G1の場合、 </font></font><code>-XX:MaxGCPauseMillis=5</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100万イベント/秒。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">50,000個の個別のキー。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.1秒後に30秒のスライディングウィンドウ。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシナリオでは、1 GB未満のヒープが使用されます。</font><font style="vertical-align: inherit;">コレクターの負荷は小さく、バックグラウンドで競合するガベージコレクションを実行するのに十分な時間があります。</font><font style="vertical-align: inherit;">以下は、3つのアセンブラがテストされたパイプラインの動作における最大遅延です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/053/d40/26c/053d4026c6d3eb747e3e78bbdcd46ecd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの値には、ウィンドウ結果の送信のための約3 msの固定間隔が含まれます。</font><font style="vertical-align: inherit;">グラフはそれ自体を物語っています。デフォルトのコレクターG1は素晴らしい仕事をしますが、さらに低い遅延が必要な場合は、実験的なZGCを使用できます。</font><font style="vertical-align: inherit;">遅延のピークを10ミリ秒未満に下げることはできませんでした。</font><font style="vertical-align: inherit;">しかし、ZGCとShenandoahの場合は、ガベージコレクションの一時停止のためではなく、コレクターのバックグラウンド作業の短期間の増加量のために発生します。</font><font style="vertical-align: inherit;">ときどき、Shenandoahサービスプロセスで遅延が200ミリ秒を超えました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シナリオ2：構造が大きく、レイテンシ要件が厳しくない</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
制御不能な理由（セルラーネットワークなど）により、遅延が数秒に増加する可能性があると想定しています。</font><font style="vertical-align: inherit;">これにより、ストリーム処理パイプラインの要件が緩和されます。</font><font style="vertical-align: inherit;">一方、非常に大きなデータ、つまり数百万から数千万のキーに遭遇する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシナリオでは、ガベージコレクターがクラスターの複数のノードにデータを分散するのではなく、大きなヒープで動作するという事実を考慮して、機器を頻繁に使用するように準備できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さまざまな組み合わせで多くのテストを実行し、要因の組み合わせがランタイムのパフォーマンスにどのように影響するかを調べました。</font><font style="vertical-align: inherit;">これは2つのパラメーターに依存することがわかりました。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集計に格納されているレコードの数。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メイクアップの帯域幅要件。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のパラメーターは、古い世代のオブジェクトの数を示します。スライディングウィンドウメソッドを使用して集計する場合、オブジェクトを（ウィンドウ全体で）長時間保持してから解放します。これは、オブジェクトが若くして死ぬか、永遠に生きるかのいずれかであると主張する世代別ごみ仮説（Generational Garbage仮説）に直接矛盾します。このモードでは、ガベージコレクターに最大負荷が作成されます。そして、その作業の強度は生きているオブジェクトの数とともに増加するため、生産性はこのパラメータに大きく依存します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のパラメーターは、アプリケーションがガベージコレクターに割り当てることができるリソースの量に関連します。より明確にするために、いくつかの図を作成してみましょう。スライディングウィンドウ方式を使用して集約する場合、コンベヤは3つの段階を経ます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発生時のリアルタイムのイベント処理。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スライディングウィンドウの結果を渡します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第2段階で受け取ったイベントをキャッチアップします。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つのステージはすべて、次のように視覚化できます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99c/d77/894/99cd778940f1596c2dd5e1dbf0933fd4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィンドウ結果の転送に時間がかかる場合、次のような状況になります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b22/694/760/b226947608cfb3373742d02e6dc7774f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、コンベヤにはほとんど時間がありません。ガベージコレクションの一時停止などのすべての時間遅延は遅延を増加させ、非常にゆっくりと回復します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グラフを変更して、ウィンドウの結果を渡した後のイベントの平均吸収率のみを表示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d78/cd9/ccb/d78cd9ccbf09b96c23705ae8bb0d6e38.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
黄色の長方形の高さを「面付け要件」と呼びます。これはソース容量の要件です。コンベヤの実際のスループットを超えると、負荷に対応できなくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィンドウ結果の転送に時間がかかりすぎる場合は、次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b9/0ea/594/5b90ea59490f05c628401475c9849e21.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
赤と黄色の長方形の領域は固定されており、パイプラインを通過する必要のあるデータの量に対応しています。実際、赤は黄色を「圧迫」します。しかし、黄色の長方形の高さは制限されています。この場合、天井は220万イベント/秒です。そして、高さが制限を超えると、負荷と無限に増大する遅延に対応できないコンベヤができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベント頻度、ウィンドウサイズ、スリップステップ、およびキーセットサイズの特定の組み合わせについて、四角形のサイズを予測するための数式を導出しました。したがって、どのような場合でも、面付けの要件を決定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、個々の組み合わせを説明する他の多くのパラメーターから派生した2つ程度の独立したパラメーターができました。</font><font style="vertical-align: inherit;">円が消えたベンチマークを示す2次元グラフを作成できます。</font><font style="vertical-align: inherit;">組み合わせの成功または失敗に応じて円に色を付けます。</font><font style="vertical-align: inherit;">たとえば、ラップトップでG1が実行されている一連のJDK 14の場合、次のグラフが表示されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab2/9e6/416/ab29e641669a2666c59d506e59fce458.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つのカテゴリを識別しました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「はい」-コンベヤーは対処しています、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「いいえ」-帯域幅が不足しているため、パイプラインは対応できません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ガベージコレクター」-アセンブリーの頻繁な長い休止のため、コンベヤーは対応しません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
競合するガベージコレクションと頻繁な短いアセンブリポーズにより、帯域幅の不足も発生する可能性があることに注意してください。一般に、最後の2つのカテゴリの違いはわずかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グラフの左下を区切る境界線を確認できます。成功したベンチマークのポイントが含まれています。 JDKとガベージコレクターの他の組み合わせについて同じグラフをプロットし、ゾーンの境界を特定して、次の結果を得ました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/251/d12/394/251d123945208cbed4806928946c4241.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MacBook Pro 2018には、6コアのIntel Core i7と16GB DDR4 RAMが搭載されていました。 JVMが構成されています</font></font><code>-Xmx10g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ただし、他の多くの構成でも同様の状況が見られると考えています。グラフは、他のコレクターに対するG1の優位性、JDK 8で使用した場合のG1の弱点、およびこの種の負荷での待ち時間が短い実験用コレクターの弱点を示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本的な遅延-ウィンドウ結果の送信期間-は約500ミリ秒変動しました。</font><font style="vertical-align: inherit;">ただし、バーストはガベージコレクションのメインポーズ（G1の場合は不当に長い）が原因で発生することが多く、ボーダーラインの状況で最大10秒（コンベヤーがほとんど作業に対応していない場合）、1〜2秒に減少しました。</font><font style="vertical-align: inherit;">また、ボーダーラインの状況でのJITコンパイルの影響にも気づきました。パイプラインはますます遅延して動作し始め、約2分後にパフォーマンスが向上し、遅延は通常の値に戻ります。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja506696/index.html">Gitlab.comでのPostgreSQLの管理。ホセ・コアス・フィノット</a></li>
<li><a href="../ja506698/index.html">『海上ローンチ』のレクイエム</a></li>
<li><a href="../ja506700/index.html">PlayMarketでのその後の展開でAndroidのGitHubアクションを構成します</a></li>
<li><a href="../ja506702/index.html">Backblaze Q1 2020による最も信頼性の高いHDD</a></li>
<li><a href="../ja506704/index.html">2020年にPHPで記述する理由 Holivarimは今週木曜日にYouTubeでインタラクティブなポッドキャストです</a></li>
<li><a href="../ja506708/index.html">VPN / Mikrotik 2要素認証-シンプルでスケーラブル</a></li>
<li><a href="../ja506710/index.html">Zimbra Collaboration Suite Open-Source Editionで複数のアドレス帳を管理する</a></li>
<li><a href="../ja506716/index.html">マルチスレッド線形リスト：要素の存在問題、生産性の向上、およびSTL関係</a></li>
<li><a href="../ja506726/index.html">システムでのユーザーの登録と承認にRutokenテクノロジーを使用した経験（パート2）</a></li>
<li><a href="../ja506730/index.html">SnortまたはSuricata。パート1：企業ネットワークを保護するための無料のIDS / IPSを選択する</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>