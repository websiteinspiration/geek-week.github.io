<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüç≥ ‚ôÇÔ∏è üëêüèæ Prueba de rendimiento del c√≥digo de Linux con ejemplos #‚É£ ‚õΩÔ∏è ü•í</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cuando comenc√© a aprender Java, una de las primeras tareas que intent√© resolver fue determinar los n√∫meros pares / impares. Conoc√≠a varias formas de h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Prueba de rendimiento del c√≥digo de Linux con ejemplos</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489210/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando comenc√© a aprender Java, una de las primeras tareas que intent√© resolver fue determinar los n√∫meros pares / impares. Conoc√≠a varias formas de hacer esto, pero decid√≠ buscar la forma "correcta" en Internet. La informaci√≥n en todos los enlaces encontrados me habl√≥ de la √∫nica soluci√≥n correcta de la forma x% 2, para obtener el resto de la divisi√≥n. Si el resto es 0, el n√∫mero es par; si el resto es 1, es impar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desde la √©poca de ZX Spectrum, record√© otra forma y est√° asociada con la representaci√≥n de n√∫meros en el sistema binario. Cualquier n√∫mero en el sistema decimal se puede escribir como la suma de las potencias de dos. Por ejemplo, para un byte, y esto es 8 bits, cualquier n√∫mero en el sistema decimal se puede representar como la suma de los n√∫meros 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto es solo una secuencia de poderes de dos. Al traducir un n√∫mero al sistema binario, si tenemos que tener en cuenta el n√∫mero, en la representaci√≥n binaria ser√° uno, si no es necesario, ser√° 0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10 = 1010 (8 + 0 + 2 + 0) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
13 = 1101 (8 + 4 + 0 + 1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
200 = 11001000 (128 + 64 + 0 + 0 + 8 + 0 + 0 + 0)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede prestar atenci√≥n de inmediato al hecho de que un n√∫mero impar solo puede dar una potencia cero de dos con un valor de 1, todas las dem√°s potencias de dos ser√°n pares por definici√≥n. </font><font style="vertical-align: inherit;">Esto significa autom√°ticamente que, desde el punto de vista del sistema de n√∫meros binarios, si queremos verificar la paridad de cualquier n√∫mero, no necesitamos verificar el n√∫mero entero, sin importar cu√°n grande sea. </font><font style="vertical-align: inherit;">Necesitamos verificar solo el primer bit (el m√°s a la derecha). </font><font style="vertical-align: inherit;">Si es 0, entonces el n√∫mero es par, ya que todos los dem√°s bits dan un n√∫mero par, y viceversa, si el bit m√°s a la derecha es uno, entonces se garantiza que el n√∫mero es impar, porque todos los dem√°s bits solo dan un valor par. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para verificar solo el bit correcto en un n√∫mero, puede usar varios m√©todos. </font><font style="vertical-align: inherit;">Uno de ellos es binario AND.</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Binario AND (AND) funciona seg√∫n la siguiente regla. Si aplica a cualquier n√∫mero, llam√©moslo original, l√≥gico Y con el n√∫mero 0, entonces el resultado de tal operaci√≥n es siempre 0. De esta manera puede poner a cero los bits que no necesita. Si solicita el original 1, obtendr√° el original. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En un sistema binario, es f√°cil escribir esto: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 Y 0 = 0 (cero el original) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 Y 0 = 0 (cero el original) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 Y 1 = 0 (no cambie el original) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 Y 1 = 1 (no cambie el original) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De aqu√≠ algunos simples reglas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si aplicamos la operaci√≥n AND de todas las unidades a todos los n√∫meros (todos los bits est√°n activados), obtenemos el mismo n√∫mero inicial. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si aplicamos AND de todos los ceros a cualquier n√∫mero (todos los bits est√°n apagados), obtenemos 0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si aplicamos AND 0 al byte 13, entonces obtenemos 0. En decimal parece 13 AND 0 = 0 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si aplicamos AND 0 al byte 200, obtenemos 0, o escribimos 200 AND 0 = 0 brevemente. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo mismo es lo contrario, aplicamos a 13 todos los bits incluidos, para un byte ser√°n ocho unidades, y obtenemos el original. </font><font style="vertical-align: inherit;">En el sistema binario 00001101 Y 11111111 = 00001101 o en el sistema decimal 13 Y 255 = 13 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para 200 habr√° 11001000 Y 11111111 = 11001000, respectivamente, o en el sistema decimal 200 Y 255 = 200</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verificaci√≥n binaria</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para verificar el n√∫mero de paridad, solo necesitamos verificar el bit m√°s a la derecha. Si es 0, entonces el n√∫mero es par; si es 1, entonces no es par. Sabiendo que con AND podemos dejar algunos bits originales, y algunos podemos restablecer, simplemente podemos restablecer todos los bits, excepto el m√°s a la derecha. Por ejemplo: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
13 en el sistema binario es 1101. Apliquemos AND 0001 (restablecemos todos los bits, el √∫ltimo sigue siendo el original). En 1101, cambiamos todos los bits a 0 excepto el √∫ltimo y obtenemos 0001. Obtuvimos solo el √∫ltimo bit de nuestro n√∫mero original. En el sistema decimal, se ver√° como 13 Y 1 = 1.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo mismo con el n√∫mero 200, en binario 11001000. Le aplicamos AND 00000001, de acuerdo con el mismo esquema, ponemos a cero todos los bits, dejamos el √∫ltimo como est√°, obtenemos 00000000, mientras que los 7 ceros izquierdos se restablecieron con el comando AND, y el √∫ltimo 0 lo obtuvimos del n√∫mero original En el sistema decimal, parece 200 AND 1 = 0 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, aplicando el comando AND 1 a cualquier n√∫mero, obtenemos 0 o 1. Y si el resultado es 0, entonces el n√∫mero es par. Cuando 1, el n√∫mero es impar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Java, el AND binario se escribe como &amp;. En consecuencia, 200 y 1 = 0 (par) y 13 y 1 = 1 (impar). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto implica al menos dos m√©todos para determinar n√∫meros pares. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X% 2 - a trav√©s del resto de la divisi√≥n por dos </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X y 1 - a trav√©s de binario AND</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El procesador procesa operaciones binarias como OR, AND, XOR en un tiempo m√≠nimo. </font><font style="vertical-align: inherit;">Pero la operaci√≥n de divisi√≥n no es una tarea trivial, y para ejecutarla, el procesador necesita procesar muchas instrucciones, esencialmente ejecutar todo el programa. </font><font style="vertical-align: inherit;">Sin embargo, hay operaciones binarias de desplazamiento hacia la izquierda y hacia la derecha que permiten, por ejemplo, dividir r√°pidamente un n√∫mero entre 2. La pregunta es si los compiladores usan esta optimizaci√≥n y si hay una diferencia entre estas dos comparaciones, que de hecho hacen lo mismo.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codificaci√≥n</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Escribiremos un programa que procesar√° 9,000,000,000 n√∫meros en un ciclo en orden, y determinaremos su pertenencia a par / impar determinando el resto de la divisi√≥n.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OddEvenViaMod</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>{
                <span class="hljs-keyword">long</span> i=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> odds=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> evens=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>) {<font></font>
                        evens++;<font></font>
                        }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                        odds++;<font></font>
                        }<font></font>
                i++;<font></font>
                } <span class="hljs-keyword">while</span> (i&lt;<span class="hljs-number">9000000000L</span>);<font></font>
                System.out.println(<span class="hljs-string">"Odd "</span> + odds);<font></font>
                System.out.println(<span class="hljs-string">"Even "</span> + evens);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y escribiremos exactamente lo mismo, pero literalmente cambiaremos dos caracteres, verificando lo mismo a trav√©s del binario AND.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OddEvenViaAnd</span> </span>{
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>{
                <span class="hljs-keyword">long</span> i=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> odds=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">long</span> evens=<span class="hljs-number">0</span>;
                <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">if</span> ((i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) {<font></font>
                        evens++;<font></font>
                        }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                        odds++;<font></font>
                        }<font></font>
                i++;<font></font>
                } <span class="hljs-keyword">while</span> (i&lt;<span class="hljs-number">9000000000L</span>);<font></font>
                System.out.println(<span class="hljs-string">"Odd "</span> + odds);<font></font>
                System.out.println(<span class="hljs-string">"Even "</span> + evens);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora tenemos que comparar de alguna manera estos dos programas.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recursos en Linux. </font><font style="vertical-align: inherit;">UPC</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se ha invertido una gran cantidad de horas en la creaci√≥n de cualquier sistema operativo, en particular en la distribuci√≥n justa de recursos entre programas. </font><font style="vertical-align: inherit;">Por un lado, esto es bueno, ya que al ejecutar dos programas, puede estar seguro de que funcionar√°n en paralelo, pero por otro lado, cuando necesita verificar el rendimiento de un programa, es extremadamente necesario limitar o al menos reducir la influencia externa en el programa de otros. programas y sistema operativo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo primero que debes descubrir es el procesador. </font><font style="vertical-align: inherit;">El sistema operativo Linux para cada proceso almacena una m√°scara de bits, que indica qu√© n√∫cleos puede utilizar la aplicaci√≥n y cu√°les no. </font><font style="vertical-align: inherit;">Puede ver y cambiar esta m√°scara con el comando del conjunto de tareas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, veamos la cantidad de n√∫cleos en mi procesador:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# grep -c processor /proc/cpuinfo<font></font>
4<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mi computadora tiene un procesador con 4 n√∫cleos. </font><font style="vertical-align: inherit;">Esto es bueno, porque voy a asignar uno de ellos a mis necesidades. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos si todos est√°n actualmente en uso con el comando superior:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# top
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Presione "1" para ver la informaci√≥n de cada n√∫cleo por separado:</font></font><br>
<br>
<pre><code class="plaintext hljs">top - 13:44:11 up 1 day, 23:26,  7 users,  load average: 1.48, 2.21, 2.02<font></font>
Tasks: 321 total,   1 running, 320 sleeping,   0 stopped,   0 zombie<font></font>
%Cpu0  :  7.7 us,  6.8 sy,  0.0 ni, 85.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :  9.2 us,  4.2 sy,  0.0 ni, 86.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  7.6 us,  3.4 sy,  0.0 ni, 89.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  :  8.4 us,  4.2 sy,  0.0 ni, 87.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
KiB Mem : 16210820 total,   296972 free, 10072092 used,  5841756 buff/cache<font></font>
KiB Swap: 16777212 total, 16777212 free,        0 used.  5480568 avail Mem<font></font>
....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ vemos que todos los n√∫cleos se usan aproximadamente de la misma manera. </font><font style="vertical-align: inherit;">(los indicadores us y sy e id son aproximadamente iguales para cada n√∫cleo). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora intentemos ver lo mismo con el comando del conjunto de tareas.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -p 1<font></font>
pid 1's current affinity mask: f<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La m√°scara de bits "F" en el sistema hexadecimal significa 15 en decimal, o 1111 en binario (8 + 4 + 2 + 1). </font><font style="vertical-align: inherit;">Todos los bits est√°n habilitados, lo que significa que todos los n√∫cleos son utilizados por un proceso con PID 1. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Linux, cuando un proceso genera otro con una llamada al sistema de clonaci√≥n, la m√°scara de bits se copia del padre en el momento de la clonaci√≥n. </font><font style="vertical-align: inherit;">Esto significa que si cambiamos esta m√°scara para nuestro proceso de inicio (en mi caso es systemd), al comenzar cualquier proceso nuevo a trav√©s de systemd, este nuevo proceso ya se iniciar√° con una nueva m√°scara. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede cambiar la m√°scara para el proceso utilizando el mismo comando, enumerando los n√∫meros de n√∫cleos de CPU que queremos dejar utilizados para el proceso. </font><font style="vertical-align: inherit;">Supongamos que queremos dejar el kernel 0.2.3 para nuestro proceso, y queremos deshabilitar el kernel 1 para nuestro proceso systemd. </font><font style="vertical-align: inherit;">Para hacer esto, necesitamos ejecutar el comando:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]#  taskset -pc 0,2,3 1<font></font>
pid 1's current affinity list: 0-3<font></font>
pid 1's new affinity list: 0,2,3<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verificamos:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -p 1<font></font>
pid 1's current affinity mask: d<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La m√°scara cambi√≥ a "D" en la notaci√≥n hexadecimal, que es 13 en decimal y 1101 en binario (8 + 4 + 0 + 1). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De ahora en adelante, cualquier proceso que ser√° clonado por el proceso systemd tendr√° autom√°ticamente una m√°scara 1101 de uso de CPU, lo que significa que no se utilizar√° el n√∫cleo n√∫mero 1.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prohibimos el uso del n√∫cleo a todos los procesos.</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Evitar que el proceso principal de Linux use un solo n√∫cleo solo afectar√° los nuevos procesos creados por este proceso. </font><font style="vertical-align: inherit;">Pero en mi sistema ya no hay un solo proceso, sino una multitud completa, como crond, sshd, bash y otros. </font><font style="vertical-align: inherit;">Si necesito prohibir que todos los procesos usen un n√∫cleo, entonces debo ejecutar el comando del conjunto de tareas para cada proceso en ejecuci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para obtener una lista de todos los procesos, utilizaremos la API que nos proporciona el n√∫cleo, es decir, el sistema de archivos / proc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
M√°s adelante en el bucle, observamos el PID de cada proceso en ejecuci√≥n y cambiamos la m√°scara y todos los hilos:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# cd /proc; for i in `ls -d [0-9]*`; do taskset -a -pc 0,2,3 $i; done<font></font>
pid 1's current affinity list: 0,2,3<font></font>
pid 1's new affinity list: 0,2,3<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que durante la ejecuci√≥n del programa, algunos procesos podr√≠an tener tiempo para generar otros procesos, es mejor ejecutar este comando varias veces. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verifique el resultado de nuestro trabajo con el comando superior:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# top<font></font>
top - 14:20:46 up 2 days, 3 min,  7 users,  load average: 0.19, 0.27, 0.57<font></font>
Tasks: 324 total,   4 running, 320 sleeping,   0 stopped,   0 zombie<font></font>
%Cpu0  :  8.9 us,  7.7 sy,  0.0 ni, 83.4 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  9.5 us,  6.0 sy,  0.0 ni, 84.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  :  8.4 us,  6.6 sy,  0.0 ni, 85.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
KiB Mem : 16210820 total,   285724 free, 10142548 used,  5782548 buff/cache<font></font>
KiB Swap: 16777212 total, 16777212 free,        0 used.  5399648 avail Mem<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, la imagen ha cambiado un poco, ahora para el kernel 0.2.3 los par√°metros promedio us, sy, id son los mismos para nosotros, y para el kernel 1 nuestro consumo central en el espacio de usuario y sys es 0, y el kernel est√° inactivo al 100% (inactivo 100 ) </font><font style="vertical-align: inherit;">El n√∫cleo 1 ya no es utilizado por nuestras aplicaciones y el n√∫cleo utiliza actualmente un porcentaje muy peque√±o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora la tarea de probar el rendimiento se reduce a comenzar nuestro proceso en un n√∫cleo libre.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memoria</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La memoria f√≠sica asignada a un proceso puede extraerse f√°cilmente de cualquier proceso. </font><font style="vertical-align: inherit;">Este mecanismo se llama intercambio. </font><font style="vertical-align: inherit;">Si Linux tiene un lugar para el intercambio, lo har√° de todos modos. </font><font style="vertical-align: inherit;">La √∫nica forma de evitar que el sistema operativo tome memoria de nuestro proceso, como cualquier otro proceso, es deshabilitar completamente la secci√≥n de intercambio, lo que haremos:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo swapoff -a<font></font>
[user@localhost]$ free -m<font></font>
              total        used        free      shared  buff/cache   available<font></font>
Mem:          15830        7294        1894         360        6641        7746<font></font>
Swap:             0           0           0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Asignamos 1 n√∫cleo de procesador, que no se usa, y tambi√©n eliminamos la capacidad de intercambiar memoria del kernel de Linux. </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disco</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para reducir el impacto del disco en el inicio de nuestro proceso, cree un disco en la memoria y copie todos los archivos necesarios en este disco. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cree un directorio y monte el sistema de archivos:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo mkdir /mnt/ramdisk;<font></font>
[user@localhost]$ mount -t tmpfs -o size=512m tmpfs /mnt/ramdisk<font></font>
[user@localhost]$ chown user: /mnt/ramdisk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora tenemos que descubrir qu√© y c√≥mo planeamos lanzarlo. </font><font style="vertical-align: inherit;">Para ejecutar nuestro programa, primero necesitamos compilar nuestro c√≥digo:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ javac OddEvenViaMod.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces necesitas ejecutarlo:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero en nuestro caso, queremos ejecutar el proceso en el n√∫cleo del procesador que no es utilizado por ning√∫n otro proceso. </font><font style="vertical-align: inherit;">Por lo tanto, ejec√∫telo a trav√©s del conjunto de tareas:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]# taskset -c 1 time java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestras pruebas, necesitamos medir el tiempo, por lo que nuestra l√≠nea de lanzamiento se convierte en</font></font><br>
<br>
<pre><code class="plaintext hljs">taskset -c 1 time java OddEvenViaMod
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El sistema operativo Linux admite varios formatos de archivos ejecutables, y el m√°s com√∫n de ellos es el formato ELF. Este formato de archivo le permite decirle al sistema operativo que no ejecute su archivo, sino que ejecute otro archivo. A primera vista, no suena muy l√≥gico y comprensible. Imagina que lanzo el juego Buscaminas, y el juego Mario comienza para m√≠, parece un virus. Pero esta es la l√≥gica. Si mi programa requiere alguna biblioteca din√°mica, por ejemplo, libc, o cualquier otra, esto significa que el sistema operativo primero debe cargar esta biblioteca en la memoria, y luego cargar y ejecutar mi programa. Y parece l√≥gico colocar dicha funcionalidad en el sistema operativo en s√≠, pero el sistema operativo funciona en un √°rea protegida de memoria y debe contener la menor funcionalidad posible y necesaria.Por lo tanto, el formato ELF brinda la oportunidad de decirle al sistema operativo que queremos descargar alg√∫n otro programa, y ‚Äã‚Äãeste "otro" programa descargar√° todas las bibliotecas necesarias y nuestro programa y comenzar√° todo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, necesitamos ejecutar 3 archivos, este es un conjunto de tareas, tiempo, java. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comprueba el primero de ellos:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ whereis taskset<font></font>
taskset: /usr/bin/taskset /usr/share/man/man1/taskset.1.gz<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bash ejecutar√° el archivo / usr / bin / taskset, verifique lo que hay dentro:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ file /usr/bin/taskset<font></font>
/usr/bin/taskset: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=7a2fd0779f64aa9047faa00f498042f0f0c5dc60, stripped<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es el archivo ELF sobre el que escrib√≠ anteriormente. </font><font style="vertical-align: inherit;">En el archivo ELF, adem√°s del programa en s√≠, hay varios encabezados. </font><font style="vertical-align: inherit;">Al iniciar este archivo, el sistema operativo verifica sus encabezados, y si el encabezado "Solicitar int√©rprete de programa" existe en el archivo, el sistema operativo iniciar√° el archivo desde este encabezado, y pasar√° el archivo lanzado inicialmente como argumento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compruebe si este encabezado existe en nuestro archivo ELF:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ readelf -a /usr/bin/taskset  | grep -i interpreter<font></font>
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El encabezado existe, lo que significa que al iniciar el archivo / usr / bin / taskset en realidad ejecutamos /lib64/ld-linux-x86-64.so.2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comprueba qu√© es este archivo:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ ls -lah /lib64/ld-linux-x86-64.so.2<font></font>
lrwxrwxrwx 1 root root 10 May 21  2019 /lib64/ld-linux-x86-64.so.2 -&gt; ld-2.17.so<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es un enlace sim al archivo /lib64/ld-2.17.so. </font><font style="vertical-align: inherit;">Echale un vistazo:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ file /lib64/ld-2.17.so<font></font>
/lib64/ld-2.17.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=a527fe72908703c5972ae384e78d1850d1881ee7, not stripped<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, este es otro archivo ELF que ejecutar√° el sistema operativo. </font><font style="vertical-align: inherit;">Nos fijamos en los encabezados:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ readelf -a /lib64/ld-2.17.so  | grep -i interpreter<font></font>
[user@localhost]$<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vemos que este archivo ELF no tiene ese encabezado, por lo que el sistema operativo ejecutar√° este archivo y le transferir√° el control. </font><font style="vertical-align: inherit;">Y ya este archivo abrir√° nuestro archivo / usr / bin / taskset, lea desde all√≠ la informaci√≥n sobre todas las bibliotecas necesarias. </font><font style="vertical-align: inherit;">La lista de bibliotecas necesarias tambi√©n se encuentra en los encabezados del archivo ELF. </font><font style="vertical-align: inherit;">Podemos mirar esta lista con el comando ldd o readelf, que es lo mismo:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ ldd /usr/bin/taskset<font></font>
	linux-vdso.so.1 =&gt;  (0x00007ffc4c1df000)<font></font>
	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f4a24c4e000)<font></font>
	/lib64/ld-linux-x86-64.so.2 (0x00007f4a2501b000)<font></font>
<font></font>
[user@localhost]$ readelf -a /usr/bin/taskset  | grep NEEDED<font></font>
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VDSO es una pieza de memoria vinculada que no est√° relacionada con las bibliotecas, por lo tanto, falta en el archivo ELF como una biblioteca necesaria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto deja en claro que el programa /lib64/ld-2.17.so es responsable de ejecutar todos los programas que lo requieren, y todos estos son programas con bibliotecas vinculadas din√°micamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si ejecutamos / usr / bin / taskset, esto es exactamente lo mismo que ejecutamos /lib64/ld-2.17.so con el argumento / usr / bin / taskset. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Volvemos al problema de la influencia del disco en nuestras pruebas. </font><font style="vertical-align: inherit;">Ahora sabemos que si queremos cargar nuestro programa desde la memoria, entonces necesitamos copiar no un archivo, sino varios:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp /lib64/libc-2.17.so /mnt/ramdisk/<font></font>
[user@localhost]$ cp /lib64/ld-2.17.so /mnt/ramdisk/<font></font>
[user@localhost]$ cp /usr/bin/taskset /mnt/ramdisk/<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hacemos lo mismo por el tiempo, los requisitos de la biblioteca para los cuales son exactamente los mismos (ya copiamos ld y libc).</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp /usr/bin/time /mnt/ramdisk/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para Java, las cosas son un poco m√°s complicadas, ya que Java requiere muchas bibliotecas diferentes que se pueden copiar durante mucho tiempo. </font><font style="vertical-align: inherit;">Para simplificar un poco mi vida, copiar√© todo el directorio de mi java openjdk a un disco en la memoria y crear√© un enlace sim. </font><font style="vertical-align: inherit;">Por supuesto, los accesos al disco permanecer√°n en este caso, pero habr√° menos.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ cp -R /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64 /mnt/ramdisk/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cambie el nombre del directorio anterior y agregue el final predeterminado.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo mv /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64{,.default}
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y crea un enlace simb√≥lico:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost]$ sudo ln -s /mnt/ramdisk/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64 /usr/lib/jvm/
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya sabemos c√≥mo ejecutar un archivo binario a trav√©s del argumento del archivo /lib64/ld-2.17.so, que en realidad comienza. </font><font style="vertical-align: inherit;">Pero, ¬øc√≥mo hacer que el programa /lib64/ld-2.17.so cargue bibliotecas cargadas desde el directorio que especificamos? </font><font style="vertical-align: inherit;">man ld para ayudarnos, de lo cual aprendemos que si declara la variable de entorno LD_LIBRARY_PATH, el programa ld cargar√° las bibliotecas de los directorios que especifiquemos. </font><font style="vertical-align: inherit;">Ahora tenemos todos los datos para preparar la l√≠nea de lanzamiento de la aplicaci√≥n Java. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comenzamos varias veces seguidas y verificamos:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.66user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20344maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.65user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.66user 0.01system 0:10.68elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+64outputs (0major+5229minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.65user 0.01system 0:10.67elapsed 99%CPU (0avgtext+0avgdata 20348maxresident)k<font></font>
0inputs+96outputs (0major+5234minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durante la ejecuci√≥n del programa, podemos ejecutar top y asegurarnos de que el programa se ejecute en el n√∫cleo de CPU correcto.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ top<font></font>
...<font></font>
%Cpu0  : 19.7 us, 11.7 sy,  0.0 ni, 68.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu1  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu2  :  9.8 us,  9.1 sy,  0.0 ni, 81.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st<font></font>
%Cpu3  : 14.0 us,  9.0 sy,  0.0 ni, 77.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 s<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, los resultados en la mayor√≠a de los casos son similares. </font><font style="vertical-align: inherit;">Desafortunadamente, no podemos eliminar por completo la influencia del sistema operativo en el n√∫cleo de la CPU, por lo que el resultado a√∫n depende de las tareas espec√≠ficas dentro del n√∫cleo de Linux en el momento del lanzamiento. </font><font style="vertical-align: inherit;">Por lo tanto, es mejor usar la mediana de los valores de varios inicios. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestro caso, vemos que el programa Java procesa 9,000,000,000 con paridad a trav√©s del resto de la divisi√≥n en 10.65 segundos en un n√∫cleo de CPU. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hagamos la misma prueba con nuestro segundo programa, que hace lo mismo a trav√©s del binario AND.</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.02user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5197minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.01user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20228maxresident)k<font></font>
0inputs+64outputs (0major+5199minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.01user 0.01system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5198minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
4.02user 0.00system 0:04.03elapsed 99%CPU (0avgtext+0avgdata 20224maxresident)k<font></font>
0inputs+64outputs (0major+5198minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora podemos decir con confianza que la comparaci√≥n de la paridad a trav√©s del binario Y toma 4.02 segundos, lo que significa que en comparaci√≥n con el resto de la divisi√≥n, funciona 2.6 veces m√°s r√°pido, al menos en la versi√≥n 1.8.0 de openjdk.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oracle Java vs Openjdk</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
He descargado y descomprimido JDK de Java desde el sitio web de Oracle en el directorio /mnt/ramdisk/jdk-13.0.2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compilar:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ /mnt/ramdisk/jdk-13.0.2/bin/javac OddEvenViaAnd.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lanzamos:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.39user 0.01system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 24260maxresident)k<font></font>
0inputs+64outputs (0major+6979minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaAnd<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.40user 0.01system 0:10.42elapsed 99%CPU (0avgtext+0avgdata 24268maxresident)k<font></font>
0inputs+64outputs (0major+6985minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compilamos el segundo programa:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ /mnt/ramdisk/jdk-13.0.2/bin/javac OddEvenViaMod.java
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lanzamos:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.39user 0.01system 0:10.40elapsed 99%CPU (0avgtext+0avgdata 24324maxresident)k<font></font>
0inputs+96outputs (0major+7003minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/jdk-13.0.2/bin/java OddEvenViaMod<font></font>
Odd 4500000000<font></font>
Even 4500000000<font></font>
10.40user 0.00system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 24316maxresident)k<font></font>
0inputs+64outputs (0major+6992minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El tiempo de ejecuci√≥n de las mismas fuentes en Oracle jdk es el mismo para el resto de la divisi√≥n y el binario AND, que parece normal, pero esta vez es igualmente malo, lo que se mostr√≥ en openjdk en el resto de la divisi√≥n.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pit√≥n</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Intentemos comparar lo mismo en Python. </font><font style="vertical-align: inherit;">Primero, la opci√≥n con el resto de dividir por 2:</font></font><br>
<br>
<pre><code class="python hljs">odd=<span class="hljs-number">0</span>
even=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
	<span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<font></font>
		even += <span class="hljs-number">1</span>
	<span class="hljs-keyword">else</span>:<font></font>
		odd += <span class="hljs-number">1</span>
<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lanzamos:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.69user 0.00system 0:11.69elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.67user 0.00system 0:11.67elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_mod.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
11.66user 0.00system 0:11.66elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1220minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora lo mismo con binario AND:</font></font><br>
<br>
<pre><code class="python hljs">odd=<span class="hljs-number">0</span>
even=<span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
	<span class="hljs-keyword">if</span> i &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span>:<font></font>
		even += <span class="hljs-number">1</span>
	<span class="hljs-keyword">else</span>:<font></font>
		odd += <span class="hljs-number">1</span>
<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lanzamos:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.41user 0.00system 0:10.41elapsed 99%CPU (0avgtext+0avgdata 4588maxresident)k<font></font>
0inputs+0outputs (0major+1221minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.43user 0.00system 0:10.43elapsed 99%CPU (0avgtext+0avgdata 4588maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
10.43user 0.00system 0:10.43elapsed 99%CPU (0avgtext+0avgdata 4584maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los resultados muestran que Y es m√°s r√°pido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Internet, se ha escrito muchas veces que las variables globales en Python son m√°s lentas. </font><font style="vertical-align: inherit;">Decid√≠ comparar el tiempo de ejecuci√≥n del √∫ltimo programa con AND y exactamente el mismo, pero envuelto en una funci√≥n:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
	odd=<span class="hljs-number">0</span>
	even=<span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">100000000</span>):
		<span class="hljs-keyword">if</span> i &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span>:<font></font>
			even += <span class="hljs-number">1</span>
		<span class="hljs-keyword">else</span>:<font></font>
			odd += <span class="hljs-number">1</span>
	<span class="hljs-keyword">print</span> <span class="hljs-string">"even"</span>, even
	<span class="hljs-keyword">print</span> <span class="hljs-string">"odd"</span>, odd<font></font>
<font></font>
main()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ejecutar en la funci√≥n:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and_func.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
5.08user 0.00system 0:05.08elapsed 99%CPU (0avgtext+0avgdata 4592maxresident)k<font></font>
0inputs+0outputs (0major+1222minor)pagefaults 0swaps<font></font>
[user@localhost ramdisk]$<font></font>
[user@localhost ramdisk]$ export LD_LIBRARY_PATH=/mnt/ramdisk ; /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/taskset -c 1 /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/time /mnt/ramdisk/ld-2.17.so /mnt/ramdisk/python2.7 odd_and_func.py<font></font>
even 50000000<font></font>
odd 50000000<font></font>
5.08user 0.00system 0:05.09elapsed 99%CPU (0avgtext+0avgdata 4592maxresident)k<font></font>
0inputs+0outputs (0major+1223minor)pagefaults 0swaps<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, la misma comparaci√≥n de paridad en Python a trav√©s de AND binario en una funci√≥n procesa 100000000 n√∫meros en un solo n√∫cleo de CPU en ~ 5 segundos, la misma comparaci√≥n a trav√©s de AND sin una funci√≥n toma ~ 10 segundos, y la comparaci√≥n sin una funci√≥n en el resto de la divisi√≥n toma ~ 11 segundos </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por qu√© un programa Python en una funci√≥n funciona m√°s r√°pido que sin √©l ya se ha descrito m√°s de una vez y est√° relacionado con el alcance de las variables. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python tiene la capacidad de desarmar un programa en funciones internas que Python utiliza al interpretar un programa. </font><font style="vertical-align: inherit;">Veamos qu√© funciones usa Python para la variante con la funci√≥n odd_and_func.py:</font></font><br>
<br>
<pre><code class="plaintext hljs">[user@localhost ramdisk]# python<font></font>
Python 2.7.5 (default, Jun 20 2019, 20:27:34)<font></font>
[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linux2<font></font>
Type "help", "copyright", "credits" or "license" for more information.<font></font>
&gt;&gt;&gt; def main():<font></font>
...     odd=0<font></font>
...     even=0<font></font>
...     for i in xrange(100000000):<font></font>
...             if i &amp; 1 == 0:<font></font>
...                     even += 1<font></font>
...             else:<font></font>
...                     odd += 1<font></font>
...     print "even", even<font></font>
...     print "odd", odd<font></font>
...<font></font>
&gt;&gt;&gt; import dis<font></font>
&gt;&gt;&gt; dis.dis(main)<font></font>
  2           0 LOAD_CONST               1 (0)<font></font>
              3 STORE_FAST               0 (odd)<font></font>
<font></font>
  3           6 LOAD_CONST               1 (0)<font></font>
              9 STORE_FAST               1 (even)<font></font>
<font></font>
  4          12 SETUP_LOOP              59 (to 74)<font></font>
             15 LOAD_GLOBAL              0 (xrange)<font></font>
             18 LOAD_CONST               2 (100000000)<font></font>
             21 CALL_FUNCTION            1<font></font>
             24 GET_ITER<font></font>
        &gt;&gt;   25 FOR_ITER                45 (to 73)<font></font>
             28 STORE_FAST               2 (i)<font></font>
<font></font>
  5          31 LOAD_FAST                2 (i)<font></font>
             34 LOAD_CONST               3 (1)<font></font>
             37 BINARY_AND<font></font>
             38 LOAD_CONST               1 (0)<font></font>
             41 COMPARE_OP               2 (==)<font></font>
             44 POP_JUMP_IF_FALSE       60<font></font>
<font></font>
  6          47 LOAD_FAST                1 (even)<font></font>
             50 LOAD_CONST               3 (1)<font></font>
             53 INPLACE_ADD<font></font>
             54 STORE_FAST               1 (even)<font></font>
             57 JUMP_ABSOLUTE           25<font></font>
<font></font>
  8     &gt;&gt;   60 LOAD_FAST                0 (odd)<font></font>
             63 LOAD_CONST               3 (1)<font></font>
             66 INPLACE_ADD<font></font>
             67 STORE_FAST               0 (odd)<font></font>
             70 JUMP_ABSOLUTE           25<font></font>
        &gt;&gt;   73 POP_BLOCK<font></font>
<font></font>
  9     &gt;&gt;   74 LOAD_CONST               4 ('even')<font></font>
             77 PRINT_ITEM<font></font>
             78 LOAD_FAST                1 (even)<font></font>
             81 PRINT_ITEM<font></font>
             82 PRINT_NEWLINE<font></font>
<font></font>
 10          83 LOAD_CONST               5 ('odd')<font></font>
             86 PRINT_ITEM<font></font>
             87 LOAD_FAST                0 (odd)<font></font>
             90 PRINT_ITEM<font></font>
             91 PRINT_NEWLINE<font></font>
             92 LOAD_CONST               0 (None)<font></font>
             95 RETURN_VALUE<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y verifique lo mismo sin usar la funci√≥n en nuestro c√≥digo:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt;&gt;&gt; f=open("odd_and.py","r")<font></font>
&gt;&gt;&gt; l=f.read()<font></font>
&gt;&gt;&gt;<font></font>
&gt;&gt;&gt; l<font></font>
'odd=0\neven=0\nfor i in xrange(100000000):\n\tif i &amp; 1 == 0:\n\t\teven += 1\n\telse:\n\t\todd += 1\nprint "even", even\nprint "odd", odd\n'<font></font>
&gt;&gt;&gt; k=compile(l,'l','exec')<font></font>
&gt;&gt;&gt; k<font></font>
&lt;code object &lt;module&gt; at 0x7f2bdf39ecb0, file "l", line 1&gt;<font></font>
&gt;&gt;&gt; dis.dis(k)<font></font>
  1           0 LOAD_CONST               0 (0)<font></font>
              3 STORE_NAME               0 (odd)<font></font>
<font></font>
  2           6 LOAD_CONST               0 (0)<font></font>
              9 STORE_NAME               1 (even)<font></font>
<font></font>
  3          12 SETUP_LOOP              59 (to 74)<font></font>
             15 LOAD_NAME                2 (xrange)<font></font>
             18 LOAD_CONST               1 (100000000)<font></font>
             21 CALL_FUNCTION            1<font></font>
             24 GET_ITER<font></font>
        &gt;&gt;   25 FOR_ITER                45 (to 73)<font></font>
             28 STORE_NAME               3 (i)<font></font>
<font></font>
  4          31 LOAD_NAME                3 (i)<font></font>
             34 LOAD_CONST               2 (1)<font></font>
             37 BINARY_AND<font></font>
             38 LOAD_CONST               0 (0)<font></font>
             41 COMPARE_OP               2 (==)<font></font>
             44 POP_JUMP_IF_FALSE       60<font></font>
<font></font>
  5          47 LOAD_NAME                1 (even)<font></font>
             50 LOAD_CONST               2 (1)<font></font>
             53 INPLACE_ADD<font></font>
             54 STORE_NAME               1 (even)<font></font>
             57 JUMP_ABSOLUTE           25<font></font>
<font></font>
  7     &gt;&gt;   60 LOAD_NAME                0 (odd)<font></font>
             63 LOAD_CONST               2 (1)<font></font>
             66 INPLACE_ADD<font></font>
             67 STORE_NAME               0 (odd)<font></font>
             70 JUMP_ABSOLUTE           25<font></font>
        &gt;&gt;   73 POP_BLOCK<font></font>
<font></font>
  8     &gt;&gt;   74 LOAD_CONST               3 ('even')<font></font>
             77 PRINT_ITEM<font></font>
             78 LOAD_NAME                1 (even)<font></font>
             81 PRINT_ITEM<font></font>
             82 PRINT_NEWLINE<font></font>
<font></font>
  9          83 LOAD_CONST               4 ('odd')<font></font>
             86 PRINT_ITEM<font></font>
             87 LOAD_NAME                0 (odd)<font></font>
             90 PRINT_ITEM<font></font>
             91 PRINT_NEWLINE<font></font>
             92 LOAD_CONST               5 (None)<font></font>
             95 RETURN_VALUE<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, en la variante con la funci√≥n declarada, Python usa funciones internas con el postfix FAST, por ejemplo, STORE_FAST, LOAD_FAST, y en la variante sin la declaraci√≥n de la funci√≥n, Python usa las funciones internas STORE_NAME y LOAD_NAME. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este art√≠culo tiene poco significado pr√°ctico y est√° dirigido m√°s a comprender algunas de las caracter√≠sticas de Linux y los compiladores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno para todos!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es489196/index.html">Humo M√°gico: Microcontroladores vs. Reguladores Lineales</a></li>
<li><a href="../es489198/index.html">C√≥mo no dispararte en el pie con Liquibase</a></li>
<li><a href="../es489200/index.html">Qu√© startups est√° buscando Y Combinator en 2020</a></li>
<li><a href="../es489204/index.html">Una mirada al interior de la fiabilidad de los servicios de Facebook</a></li>
<li><a href="../es489206/index.html">Historias de bloqueo con Patroni, o C√≥mo soltar un cl√∫ster PostgreSQL</a></li>
<li><a href="../es489212/index.html">1C-Bitrix evita la cancelaci√≥n de la suscripci√≥n al bolet√≠n por el requisito de enviar sus datos personales</a></li>
<li><a href="../es489214/index.html">Enfoque moderno para probar la localizaci√≥n en iOS</a></li>
<li><a href="../es489218/index.html">Es ingenuo. Super: c√≥digo y arquitectura de un juego simple</a></li>
<li><a href="../es489226/index.html">M√©todos para optimizar consultas LINQ en C # .NET</a></li>
<li><a href="../es489228/index.html">Speech bot en el banco: la peor experiencia de usuario jam√°s vista</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>