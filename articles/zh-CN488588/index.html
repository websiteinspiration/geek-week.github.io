<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖇️ 🕓 🛠️ C ++ 20批准！对C ++ 23开发人员的期望和准备 🔐 👈🏼 🎗️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前几天在布拉格，国际标准化委员会C ++举行了会议。又又又又…… 
 
 
 
 C ++ 20已经准备好了！仍然需要在ISO上盖章，但这是一个纯粹的正式步骤，应该没有问题。
 
 恭喜大家，这次精彩的活动！概念，协程，模块，范围，std ::格式，constexpr新算法和constexpr算法+...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C ++ 20批准！对C ++ 23开发人员的期望和准备</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/488588/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前几天在布拉格，国际标准化委员会C ++举行了会议。</font><font style="vertical-align: inherit;">又又又又…… </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xn/2z/jn/xn2zjnez64pzklp69iaix77njn0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 20已经准备好了！</font><font style="vertical-align: inherit;">仍然需要在ISO上盖章，但这是一个纯粹的正式步骤，应该没有问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
恭喜大家，这次精彩的活动！</font><font style="vertical-align: inherit;">概念，协程，模块，范围，std ::格式，constexpr新算法和constexpr算法+向量+字符串，日期时间，jthread，span，bit_cast和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">许多</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他大小创新。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他们在最后一刻设法添加和修复的内容，他们提出的要打破的内容以及每个人都希望在C ++ 23中看到的内容-有关所有这些内容的详细说明。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从C到C ++的技巧20</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近，有一种传统，是用C ++的新手开发人员以未定义的行为（UB）吓跑。</font><font style="vertical-align: inherit;">现在该改变它了！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，在这里，这样的代码对C绝对有效：</font></font><br>
<br>
<pre><code class="cpp">struct X { int a, b; };<font></font>
<font></font>
X *make_x() {<font></font>
  X *p = (X*)malloc(sizeof(struct X));<font></font>
  p-&gt;a = 1;<font></font>
  p-&gt;b = 2;<font></font>
  return p;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是在C ++中，存在很大的问题。</font><font style="vertical-align: inherit;">C使用字节操作，而C ++使用对象。</font><font style="vertical-align: inherit;">但是对象具有生命期，并且在C ++ 20之前，从调用new开始考虑了该对象生命期的开始。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
委员会对字节和简单结构的底层工作感到严重关注。</font><font style="vertical-align: inherit;">他们采用了改进措施，说某些功能集（memcpy，memmove，malloc，aligned_alloc，calloc，realloc，bit_cast）开始了对象的生命周期。</font><font style="vertical-align: inherit;">现在，大多数低级C-技巧都可以在C ++中使用。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool在C ++ 20中变得更加可靠</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
猜测错误是什么：</font></font><br>
<br>
<pre><code class="cpp">template &lt;typename T, size_t N&gt;<font></font>
auto count_unique(const std::array&lt;T, N&gt;&amp; v) {<font></font>
    return std::unordered_set&lt;T&gt;{v.begin(), v.end()}.size();<font></font>
}<font></font>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回答</font></font></b><div class="spoiler_text"> T  bool       v.begin()  v.end()   (,   libc++  libstdc++) —   count_unique   1.<br>
<br>
 - ,   std::unordered_set&lt;bool&gt;{v.begin(), v.end()}      bool     std::unordered_set&lt;bool&gt;{true, true}.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
布尔中的变换现在被认为是缩小变换。</font><font style="vertical-align: inherit;">这使我们能够在许多代码库中发现问题（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1957</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">句子</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">本身</font></a><font style="vertical-align: inherit;">中的更多示例</font><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 20概念变得更快</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
直到最近，您都可以编写这样的概念：</font></font><br>
<br>
<pre><code class="cpp">template &lt;class T&gt;<font></font>
concept Reservable = requires(T v) {<font></font>
    v.reserve(int{});<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并惊讶地返回不同的结果：</font></font><br>
<br>
<pre><code class="cpp">struct Test;<font></font>
<font></font>
static_assert(!Reservable&lt;Test&gt;);<font></font>
<font></font>
struct Test {<font></font>
    void reserve(int);<font></font>
};<font></font>
<font></font>
static_assert(Reservable&lt;Test&gt;);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上次，我们从该国家/地区发出了一条评论：“不可能在概念中使用不完整的类型，因为否则您会遇到多次违反ODR的情况”。</font><font style="vertical-align: inherit;">我们的评论被拒绝，但现在有了提案P2104，部分获得了预期的结果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，由于编译器现在有权缓存将概念应用于类型的结果，因此编译速度更快。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 20中的次要编辑</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">范围得到了ssize方法。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实例化模块链接实体时，实体内部链接不再可见（编译器会在编译阶段告诉您什么地方不对）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们扭曲了模块的规则，以便任何工具都可以更轻松地使用它们。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们打破C ++ 23或C ++ 26的一切吗？</font></font></h2><br>
<img align="right" src="https://habrastorage.org/webt/fb/_x/jm/fb_xjmkw7emgmk6gg9oozovv50w.jpeg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">长时间的辩论引发了关于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用程序二进制接口</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ABI，不要与API混淆）</font><font style="vertical-align: inherit;">的提议</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">提出了有趣的问题：</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.我们可以完全更改C ++ 23中的ABI，并获得5-10％的性能提升。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而且，所有旧的C ++库都必须重建；它们将无法使用新的ABI链接到库。</font><font style="vertical-align: inherit;">您不能在C ++ 23项目中使用由C ++早期版本构建的库。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，当然，总会有一些老旧的商业软件，没人会重新组装，但这会拖累其标准库（是的，视频游戏，我在说你！）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
稍作表决，ABI决定不中断C ++ 23。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.让我们向用户保证，我们将尝试不破坏/更改ABI。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后他们决定不提供保证。</font><font style="vertical-align: inherit;">不同的供应商对其平台有不同的计划，有时他们有能力承受破坏ABI的风险，而通常不会损害用户。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们在所有地方都添加noexcept吗？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从历史上看，在带有前提条件的标准函数中，即使它们从不抛出异常，也不会标记为noexcept。</font><font style="vertical-align: inherit;">例如，在这里，运算符-&gt;具有std ::可选：</font></font><br>
<br>
<pre><code class="cpp">constexpr const T* operator-&gt;() const;<font></font>
constexpr T* operator-&gt;();<font></font>
    Requires: *this contains a value.<font></font>
    Returns: val.<font></font>
    Throws: Nothing.<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他没有抛出任何东西，但是没有什么例外，而是说“ Throws：Nothing”，因为有一个前提条件“ *其中包含一个值”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用noexcept的用户将更加清晰。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1656中的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个好主意</font><font style="vertical-align: inherit;">！</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ch/yj/ph/chyjphhdpk8q4uv8eqbsdt_kdkq.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有！</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
有一个完整的子组SG21：合同，它带有检查合同（前提条件和后置条件）的通用机制。合同处理程序可以引发异常，如果从noexcept函数引发异常，它将被std :: terminate终止，并且应用程序将崩溃。如果您插入一个特殊的拐杖，用于合同的异常可能会从noexcept函数中飞出...那么无论如何一切都会崩溃，类型特征会受到noexcept的引导，然后它们开始对您说谎，标有noexcept并带有前提条件的函数将引发异常。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但这不是最大的问题。标准库有很多分支，现在在某些情况下已经明确插入了前提条件检查。例如，您是否有一个关键项目，应使其可用性最大化。您使用类似的派生，并且如果有人突然将std :: vector :: back（）用作空向量，则会引发异常，该异常将在代码中进行更高级别的处理，并开始使用fallback。通过</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1656的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编辑</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">，</font></a><font style="vertical-align: inherit;">这样的库将不再被视为标准库。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这不是所有的问题！..除了标准库以外，其他nono不仅会以减小二进制文件大小或提高性能的形式带来任何积极影响，而且这种更改不仅会破坏至少两家公司的代码，而且还会破坏其中一种方法合同的使用...因此该提案也被两个小组批准。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RG21的优点</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与往常一样，我们在各个小组中工作，分享了实施经验，提出了提案，而这些提案的作者却没有。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们很幸运地提出的杰出思想之一是安东之林</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2025保证命名返回对象的保证复制省略</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的思想</font><font style="vertical-align: inherit;">。它的实现将允许为对象创建工厂函数，而无需复制和移动构造函数。实际上，这是一种破坏性的举动，自90年代中期以来就已在标准中秘密存在，并且受到个别语言规则的特别禁止。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
得益于作者本人的出色阐述，我们成功地将该想法拖入了EWG-1和EWG实例。 CWG阶段仍然存在，经过几次会议后，有机会让您看到标准中必要的文字以及编译器中的第一个实现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除此想法外，我们还拖动了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1990R0</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的想法</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">：</font></a><font style="vertical-align: inherit;">通过LEWG-I </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">将运算符[]添加到std :: initializer_list中</font></a><font style="vertical-align: inherit;">，获得了有关</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1944R0</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的有用反馈</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">：constexpr &lt;cstring&gt;和&lt;cwchar&gt;</font></a><font style="vertical-align: inherit;">。 Daniil Goncharov的两个想法都有使用C ++ 23的机会。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在std :: hash字段中，意外的失败正在等待着我们。关于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1406r1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的讨论</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">：添加更多std :: hash专门性</font></a><font style="vertical-align: inherit;">突然变成了关于退化边界情况和遥远C ++ 2 *可能性的讨论。结果，委员会决定不做任何改动。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
随着SG6和Numbers一起成长。 SG6的主要讨论与ABI的讨论相交，这就是SG6的法定人数没有累积的原因。由于存在此</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1889：C ++ </font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数值</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">进行中</font></a><font style="vertical-align: inherit;">，</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">P2010：从P1889</font></a><font style="vertical-align: inherit;">和</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">删除iostream运算符</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1890：C ++数值正在进行中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未讨论问题。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 23计划</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自从C ++ 20的开发开始以来，该委员会就开始按计划行事。</font><font style="vertical-align: inherit;">即，为下一个标准确定几个有趣的主意，此后在以后的所有会议上都不要考虑其他主题的提案，即使不是所有主题都已经讨论过。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于C ++ 23，这样的计划刚刚在布拉格获得批准。</font><font style="vertical-align: inherit;">C ++ 23的主要优先事项：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标准库中的Corutin支持</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将标准库转换为模块</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行者</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">联网</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第一段中，每个人都将受到</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CppCoro</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库的指导</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，如果您已经想使用C ++ 20协程，则应该从使用此库开始。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二点就是模块，您只需要坐下来做就可以了，不会有什么特别的困难。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是执行者是个问题。</font><font style="vertical-align: inherit;">他们的设计不是很明显，不是所有用户案例都涵盖在内，目前的形式还没有被任何人使用过，并且该设计仍然未被批准。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
委员会还同意在以下领域优先考虑提案：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反射</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式匹配</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合约</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代替总数</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 20已准备就绪，是时候使用C ++ 23了！</font><font style="vertical-align: inherit;">下一次委员会会议将在夏季举行，因此，如果您对新标准有不错的想法，请在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stdcpp.ru</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和Telegram-chatting </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProCxx</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上共享它们</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，每个想与委员会代表进行实时聊天的人-看看会议和C ++会议*：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++西伯利亚2020</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明斯克的Corehard</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">莫斯科的C ++用户组</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++俄罗斯2020</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 *生活技巧：如果您是演讲者，则无需支付会议门票。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN488576/index.html">亚美尼亚生态运动：简单的挂历如何发展成大型的反塑料运动</a></li>
<li><a href="../zh-CN488578/index.html">JavaScript中的红黑树</a></li>
<li><a href="../zh-CN488582/index.html">使用OpenVINO工具包的Intel发行版创建智能库演示</a></li>
<li><a href="../zh-CN488584/index.html">在为Apple Watch编写应用程序之前，您需要了解的内容：我们的经验</a></li>
<li><a href="../zh-CN488586/index.html">灰烬时代-第135期</a></li>
<li><a href="../zh-CN488590/index.html">FOSS新闻3-2020年2月10日至16日免费和开源新闻回顾</a></li>
<li><a href="../zh-CN488592/index.html">Mail.ru关于游戏“ Allods II：灵魂之王”的一封公开信。</a></li>
<li><a href="../zh-CN488594/index.html">熊猫和其他人获取大量数据</a></li>
<li><a href="../zh-CN488596/index.html">Google开发了一种算法，可以自动在帧中的重要对象上裁剪视频</a></li>
<li><a href="../zh-CN488598/index.html">世界准备好大流行了吗？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>