<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙅🏽 👩🏽‍🚒 👨🏿‍💼 Stas Afanasyev. Juno Tuberías basadas en io.Reader / io.Writer. Parte 1 💤 🧖🏾 ⛏️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la charla, hablaremos sobre el concepto de io.Reader / io.Writer, por qué son necesarios, cómo implementarlos correctamente y qué inconvenientes ex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Stas Afanasyev. Juno Tuberías basadas en io.Reader / io.Writer. Parte 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/491484/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la charla, hablaremos sobre el concepto de io.Reader / io.Writer, por qué son necesarios, cómo implementarlos correctamente y qué inconvenientes existen a este respecto, así como sobre la construcción de tuberías basadas en implementaciones estándar y personalizadas de io.Reader / io.Writer .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rd/nv/uj/rdnvujcjwsukejxq_6a9syayawu.jpeg"><a name="habracut"></a><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stanislav Afanasyev (en adelante - SA):</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ¡Buenas tardes! Me llamo Stas Vengo de Minsk, de la compañía Juno. Gracias por venir en este día lluvioso, después de haber encontrado la fuerza para salir de la casa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hoy quiero hablar con ustedes sobre un tema como la construcción de tuberías Go basadas en las interfaces io.Reader / io.Writer. De lo que voy a hablar hoy es, en general, del concepto de interfaces io.Reader / io.Writer, por qué son necesarias, cómo usarlas correctamente y, lo más importante, cómo implementarlas correctamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También hablaremos sobre la construcción de tuberías basadas en diversas implementaciones de estas interfaces. Hablaremos sobre los métodos existentes, discutiremos sus ventajas y desventajas. Mencionaré varias trampas (esto será en abundancia).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de comenzar, debemos responder la pregunta, ¿por qué se necesitan estas interfaces? </font><font style="vertical-align: inherit;">Levanta las manos, que trabaja con Go con fuerza (todos los días, cada dos días) ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d2/pd/f4/d2pdf4kdwdjk_vxkqz6fwckqrgk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Genial! </font><font style="vertical-align: inherit;">Todavía tenemos una comunidad de Go. </font><font style="vertical-align: inherit;">Creo que muchos de ustedes han trabajado con estas interfaces, al menos han oído hablar de ellas. </font><font style="vertical-align: inherit;">Puede que ni siquiera sepas sobre ellos, pero ciertamente deberías haber escuchado algo sobre ellos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En primer lugar, estas interfaces son una abstracción de la operación de entrada-salida en todas sus manifestaciones. </font><font style="vertical-align: inherit;">En segundo lugar, es una API muy conveniente que le permite construir tuberías, como un constructor a partir de cubos, sin pensar realmente en los detalles internos de la implementación. </font><font style="vertical-align: inherit;">Al menos eso fue originalmente pensado.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es una interfaz muy simple. Consiste en un solo método: el método de lectura. Conceptualmente, la implementación de la interfaz io.Reader puede ser una conexión de red, por ejemplo, donde todavía no hay datos, pero pueden aparecer allí: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/n-/4n/dc/n-4ndcbxpoxkul6h227ue7hruli.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
puede ser un búfer en la memoria donde los datos ya existen y se pueden leer por completo. También puede ser un descriptor de archivo: podemos leer este archivo en pedazos si es muy grande. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La implementación conceptual de la interfaz io.Reader es el acceso a algunos datos. Todos los casos que escribí son compatibles con el método Read. Solo tiene un argumento: este es el byte de corte.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un punto para hacer aquí. Aquellos que vinieron a Go recientemente o vinieron de otra tecnología, donde no había una API similar (yo soy uno de esos), esta firma es un poco confusa. El método de lectura parece leer de alguna manera este segmento. De hecho, lo contrario es cierto: la implementación de la interfaz Reader lee los datos que contiene y llena este segmento con los datos que tiene esta implementación.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La cantidad máxima de datos que el método de lectura puede leer a pedido es igual a la longitud de este segmento. </font><font style="vertical-align: inherit;">Una implementación regular devuelve tantos datos como puede devolver en el momento de la solicitud, o la cantidad máxima que cabe en este segmento. </font><font style="vertical-align: inherit;">Esto sugiere que Reader puede leerse en partes: al menos por byte, al menos diez, como lo desee. </font><font style="vertical-align: inherit;">Y el cliente que llama a Reader, de acuerdo con los valores de retorno del método Read, piensa cómo vivir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método Read devuelve dos valores:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">número de bytes restados;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un error si ocurrió</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estos valores influyen en el comportamiento posterior del cliente. </font><font style="vertical-align: inherit;">Hay un gif en la diapositiva que muestra, muestra este proceso, que acabo de describir:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/si/ww/sf/siwwsf6u8mb1nkztg0ltnumkckw.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/p1/hk/mb/p1hkmbpfp8-twtnznjj2ihireaa.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Io.Reader - ¿Cómo hacerlo?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay exactamente dos formas para que sus datos satisfagan la interfaz del lector. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/l0/fm/e7/l0fme7quz_tqzilkfiuiddpgjk4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El primero es el más simple. Si tiene algún tipo de byte de corte y desea que satisfaga la interfaz del lector, puede implementar una biblioteca estándar que ya satisfaga esta interfaz. Por ejemplo, Reader del paquete de bytes. En la diapositiva anterior, puede ver la firma de cómo se crea este Reader. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay una forma más complicada: implementar la interfaz del lector usted mismo. Hay aproximadamente 30 líneas en la documentación con reglas difíciles, restricciones que deben seguirse. Antes de hablar sobre todos ellos, me resultó interesante: “¿Y en qué casos no hay suficientes implementaciones estándar (biblioteca estándar)? ¿Cuándo es el momento en que necesitamos implementar la interfaz del lector nosotros mismos?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para responder a esta pregunta, tomé los miles de repositorios más populares en Github (por el número de estrellas), los agregué y encontré todas las implementaciones de la interfaz Reader allí. </font><font style="vertical-align: inherit;">En la diapositiva, tengo algunas estadísticas (categorizadas) de cuándo las personas implementan esta interfaz.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La categoría más popular son las conexiones. </font><font style="vertical-align: inherit;">Esta es una implementación de protocolos y envoltorios patentados para los tipos existentes. </font><font style="vertical-align: inherit;">Entonces, Brad Fitzpatrick tiene un proyecto Camlistore: hay un ejemplo en forma de statTrackingConn, que, en general, es un Wrapper ordinario sobre el tipo de estafa del paquete neto (agrega métricas a este tipo).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La segunda categoría más popular son los buffers personalizados. </font><font style="vertical-align: inherit;">Aquí me gustó el único ejemplo: dataBuffer del paquete x / net. </font><font style="vertical-align: inherit;">Su peculiaridad es que almacena datos cortados en fragmentos, y al restarlos pasa a través de estos fragmentos. </font><font style="vertical-align: inherit;">Si los datos en el fragmento han terminado, pasarán al siguiente fragmento. </font><font style="vertical-align: inherit;">Al mismo tiempo, tiene en cuenta la longitud, el lugar en el que puede llenar el segmento transmitido.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otra categoría es todo tipo de barras de progreso, contando el número de bytes restados con el envío de métricas ...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En base a estos datos, podemos decir que la necesidad de implementar la interfaz io.Reader ocurre con bastante frecuencia. </font><font style="vertical-align: inherit;">Entonces comencemos a hablar sobre las reglas que están en la documentación.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reglas de documentación</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como dije, la lista de reglas, y en general la documentación es bastante grande, masiva. 30 líneas son suficientes para una interfaz que consta de solo tres líneas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La primera regla, la más importante, se refiere al número de bytes devueltos. Debe ser estrictamente mayor o igual que cero y menor o igual que la longitud del segmento enviado. ¿Por qué es importante? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1k/kp/xh/1kkpxhahoiicme8z8vbdbq5ajbm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que este es un contrato bastante estricto, el cliente puede confiar en la cantidad que proviene de la implementación. Hay Wrappers en la biblioteca estándar (por ejemplo, bytes.Buffer y bufio). Hay un momento así en la biblioteca estándar: algunas implementaciones confían en los lectores envueltos, otros no confían (hablaremos de esto más adelante).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bufio no confía en nada, verifica absolutamente todo. </font><font style="vertical-align: inherit;">Bytes.Buffer confía absolutamente en todo lo que le llega. </font><font style="vertical-align: inherit;">Ahora demostraré lo que está sucediendo en relación con esto ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora consideraremos tres casos posibles: estos son tres lectores implementados. </font><font style="vertical-align: inherit;">Son bastante sintéticos, útiles para la comprensión. </font><font style="vertical-align: inherit;">Leeremos todos estos lectores usando el ayudante ReadAll. </font><font style="vertical-align: inherit;">Su firma se presenta en la parte superior de la diapositiva:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ib/c1/7b/ibc17bdqyrimk3xce2khqwera4w.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader # 1. </font><font style="vertical-align: inherit;">Ejemplo 1</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ReadAll es un ayudante que toma algún tipo de implementación de la interfaz de Reader, la lee y devuelve los datos que leyó, así como un error. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestro primer ejemplo es Reader, que siempre devolverá -1 y cero como un error, es decir, un NegativeReader. Ejecútelo y veamos qué sucede: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7n/3h/l-/7n3hl-2vdvmgvmw80eljlorapiw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
como sabe, el pánico sin ninguna razón es una señal de tontería. Pero quién en este caso es tonto, yo o byte. Amortiguador, depende del punto de vista. Quienes escriben este paquete y lo siguen tienen diferentes puntos de vista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Que pasó aquí? Bytes.Buffer aceptó un número negativo de bytes, no verificó que fuera negativo e intentó cortar el búfer interno a lo largo del límite superior, que recibió, y salimos de los límites del segmento.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay dos problemas en este ejemplo. La primera es que la firma no tiene prohibido devolver números negativos, y la documentación está prohibida. Si la firma tuviera Uint, obtendríamos un desbordamiento clásico (cuando un número con signo se interpreta como sin signo). Y este es un error muy complicado, que seguramente ocurrirá el viernes por la noche, cuando ya estés en casa. Por lo tanto, el pánico en este caso es la opción preferida.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo "punto" es que el seguimiento de la pila no comprende lo que sucedió en absoluto. Está claro que hemos ido más allá de los límites del sector, ¿y qué? Cuando tiene una tubería multicapa y se produce un error de este tipo, no está claro de inmediato qué sucedió. Por lo tanto, el bufio de la biblioteca estándar también "entra en pánico" en esta situación, pero lo hace más bellamente. Inmediatamente escribe: “Resté un número negativo de bytes. No haré nada más, no sé qué hacer con él ".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y bytes. Buffer está entrando en pánico lo mejor que puede. </font><font style="vertical-align: inherit;">Publiqué un problema en Golang pidiéndome que agregue un error humano. </font><font style="vertical-align: inherit;">El tercer día, discutimos las perspectivas de esta decisión. </font><font style="vertical-align: inherit;">La razón es esta: históricamente sucedió que diferentes personas en diferentes momentos tomaron diferentes decisiones descoordinadas. </font><font style="vertical-align: inherit;">Y ahora tenemos lo siguiente: en un caso no confiamos en absoluto en la implementación (verificamos todo), y en el otro confiamos completamente, no obtenemos lo que proviene de allí. </font><font style="vertical-align: inherit;">Este es un problema no resuelto, y hablaremos más sobre esto.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader # 1. </font><font style="vertical-align: inherit;">Ejemplo 2</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La siguiente situación: nuestro lector siempre devolverá 0 y cero como resultado. </font><font style="vertical-align: inherit;">Desde el punto de vista de los contratos, todo es legal aquí, no hay problemas. </font><font style="vertical-align: inherit;">La única advertencia: la documentación dice que no se recomienda que las implementaciones devuelvan los valores 0 y nulo, además del caso, cuando la longitud del segmento enviado es cero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la vida real, tal lector puede causar muchos problemas. </font><font style="vertical-align: inherit;">Entonces, volvemos a la pregunta, ¿debemos confiar en Reader? </font><font style="vertical-align: inherit;">Por ejemplo, una verificación está integrada en el bufio: lee secuencialmente Reader exactamente 100 veces; si dicho par de valores se devuelve 100 veces, simplemente devuelve NoProgress. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No hay nada como esto en bytes. </font><font style="vertical-align: inherit;">Si ejecutamos este ejemplo, obtenemos solo un bucle sin fin (ReadAll usa bytes.Buffer debajo del capó, no Reader en sí):</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xh/br/zu/xhbrzuvnof4dxubt2d26i6q4l_q.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader # 1. </font><font style="vertical-align: inherit;">Ejemplo 2</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un ejemplo mas. </font><font style="vertical-align: inherit;">También es bastante sintético, pero útil para comprender: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ga/pe/xp/gapexpzfyhd6za09ss_uuwbrmlk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aquí siempre devolvemos 1 y cero. </font><font style="vertical-align: inherit;">Parece que tampoco hay problemas aquí: todo es legal desde el punto de vista del contrato. </font><font style="vertical-align: inherit;">Hay un matiz: si ejecuto este ejemplo en mi computadora, se congelará después de 30 segundos ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto se debe al hecho de que el cliente que lee este Reader (es decir, bytes.Buffer) nunca recibe una señal del final de los datos: se lee, resta ... Además, obtiene un byte restado cada vez. </font><font style="vertical-align: inherit;">Para él, esto significa que en algún momento, el búfer reposicionado finaliza, todavía se ejecuta: la situación se repite y se ejecuta hasta el infinito hasta que explota.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader # 2. </font><font style="vertical-align: inherit;">Error de retorno</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Llegamos a la segunda regla importante para implementar la interfaz de Reader: este es un retorno de error. </font><font style="vertical-align: inherit;">La documentación establece tres errores que la implementación debería devolver. </font><font style="vertical-align: inherit;">El más importante de ellos es EOF. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EOF es el signo mismo del fin de los datos, que la implementación debería devolver siempre que se quede sin datos. </font><font style="vertical-align: inherit;">Conceptualmente, esto no es, en general, un error, sino un error. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay otro error llamado UnexpectedEOF. </font><font style="vertical-align: inherit;">Si de repente mientras lee Reader ya no puede leer los datos, se pensó que devolvería UnexpectedEOF. </font><font style="vertical-align: inherit;">Pero, de hecho, este error se usa solo en un lugar de la biblioteca estándar: en la función ReadAtLeast.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-c/og/la/-coglawtrylyakbq0kxlc0ob9rs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro error es NoProgress, del que ya hablamos. </font><font style="vertical-align: inherit;">La documentación lo dice: esta es una señal de que la interfaz está implementada es una mierda.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Io.Reader # 3</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La documentación estipula un conjunto de casos sobre cómo devolver correctamente el error. </font><font style="vertical-align: inherit;">A continuación puede ver tres casos posibles: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m1/ef/si/m1efsipabh8oypgch-7_ni2syc8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
podemos devolver un error tanto con el número de bytes restados como por separado. </font><font style="vertical-align: inherit;">Pero si de repente sus datos se agotan en su Reader, y no puede devolver el EOF [signo final] en este momento (muchas implementaciones de biblioteca estándar funcionan de esa manera), entonces se supone que devolverá EOF a la próxima llamada consecutiva (es decir, debe dejar ir cliente). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para el cliente, esto significa que no hay más datos, ya no acudes a mí. </font><font style="vertical-align: inherit;">Si devuelve nulo y el cliente necesita datos, entonces debe volver a usted.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader. </font><font style="vertical-align: inherit;">Errores</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, según Reader, estas fueron las principales reglas importantes. </font><font style="vertical-align: inherit;">Todavía hay un conjunto de pequeños, pero no son tan importantes y no conducen a tal situación: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xv/iu/az/xviuazv5segzzd5ganrbinp8xli.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
antes de pasar por todo lo relacionado con Reader, debemos responder a la pregunta: ¿es importante, ocurren errores a menudo en implementaciones personalizadas? </font><font style="vertical-align: inherit;">Para responder a esta pregunta, recurrí a mi spool para obtener 1000 repositorios (y allí obtuvimos alrededor de 550 implementaciones personalizadas). </font><font style="vertical-align: inherit;">Miré a través de los primeros cien con los ojos. </font><font style="vertical-align: inherit;">Por supuesto, esto no es un superanálisis, sino lo que es ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Identifiqué los dos errores más populares:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nunca devuelve EOF;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demasiada confianza en el lector envuelto.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuevamente, este es un problema desde mi punto de vista. </font><font style="vertical-align: inherit;">Y de aquellos que están viendo el paquete io, esto no es un problema. </font><font style="vertical-align: inherit;">Hablaremos de esto nuevamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Me gustaría volver a un matiz. </font><font style="vertical-align: inherit;">Ver: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/te/3h/9q/te3h9q46okeg22rijrfyxrmi4da.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El cliente nunca debe interpretar el par 0 y cero como EOF. </font><font style="vertical-align: inherit;">Esto es un error! </font><font style="vertical-align: inherit;">Para Reader, este valor es solo una oportunidad para dejar ir al cliente. </font><font style="vertical-align: inherit;">Por lo tanto, los dos errores que mencioné parecen insignificantes, pero es suficiente imaginar que tiene una tubería de varias capas en el producto y un pequeño y astuto "bagul" en el medio, ¡entonces el "golpe subterráneo" no tardará mucho, garantizado! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Según Reader, básicamente todo. </font><font style="vertical-align: inherit;">Estas fueron las reglas básicas de implementación.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Writer</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el otro extremo de las tuberías, tenemos io.Writer, que es donde usualmente escribimos datos. </font><font style="vertical-align: inherit;">Una interfaz muy similar: también consta de un método (escritura), su firma es similar. </font><font style="vertical-align: inherit;">Desde el punto de vista de la semántica, la interfaz de Writer es más comprensible: diría que tal como se escucha, se escribe. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fq/ya/ls/fqyalshoz2lwp48cs5u8oa9ymdk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método Write toma un byte de segmento y lo escribe en su totalidad. </font><font style="vertical-align: inherit;">También tiene un conjunto de reglas que deben seguirse.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El primero de estos se refiere al número devuelto de bytes escritos. </font><font style="vertical-align: inherit;">Yo diría que no es tan estricto, porque no encontré un solo ejemplo cuando esto llevaría a algunas consecuencias críticas, por ejemplo, entrar en pánico. </font><font style="vertical-align: inherit;">Esto no es muy estricto porque existe la siguiente regla ...</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La implementación de Writer es necesaria para devolver un error siempre que la cantidad de datos escritos sea inferior a la que se envió. </font><font style="vertical-align: inherit;">Es decir, la grabación parcial no es compatible. </font><font style="vertical-align: inherit;">Esto significa que no es muy importante cuántos bytes se escribieron.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una regla más: el escritor no debe modificar el segmento enviado, porque el cliente seguirá trabajando con este segmento.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El escritor no debe contener esta porción (el lector tiene la misma regla). </font><font style="vertical-align: inherit;">Si necesita datos en su implementación para algunas operaciones, solo necesita copiar esta diapositiva, y eso es todo.</font></font></li>
</ol><br>
<img src="https://habrastorage.org/webt/iy/tx/qe/iytxqemg1nabcwxyfzxtgszmjxy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lector y escritor, eso es todo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dendrograma</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Especialmente para este informe, generé un gráfico de implementación y lo diseñé en forma de dendrograma. </font><font style="vertical-align: inherit;">Aquellos que quieran ahora pueden seguir este código QR: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/r2/zp/pq/r2zppqu-0snqu80oqyxxpxakkpc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
este dendrograma tiene todas las implementaciones de todas las interfaces del paquete io. </font><font style="vertical-align: inherit;">Este dendrograma es necesario para comprender simplemente: qué y con qué se puede unir en las tuberías, dónde y qué puede leer, dónde puede escribir. </font><font style="vertical-align: inherit;">Todavía lo consultaré en el curso de mi informe, así que por favor consulte el código QR.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tuberías</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hablamos sobre qué es Reader, io.Writer. Ahora hablemos de la API que existe en la biblioteca estándar para construir tuberías. Empecemos con lo básico. Tal vez ni siquiera sea interesante para nadie. Sin embargo, esto es muy importante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leeremos los datos del flujo de entrada estándar (de Stdin): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zq/tq/4m/zqtq4mfocqntafmpk5m_scirhcm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stdin está representado en Go por una variable global de tipo archivo del paquete os. Si observa el dendrograma, notará que el tipo de archivo también implementa las interfaces Reader y Writer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este momento estamos interesados ​​en Reader. Leeremos Stdin usando el mismo ayudante ReadAll que ya usamos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vale la pena señalar un matiz con respecto a este ayudante: ReadAll lee Reader hasta el final, pero determina el final por EOF, de acuerdo con el signo del final del que hablamos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora limitaremos la cantidad de datos que leemos de Stdin. Para hacer esto, hay una implementación de LimitedReader en la biblioteca estándar: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qq/dm/hn/qqdmhnj73dfyxpdlrpoffwzimgq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
me gustaría que preste atención a cómo LimitedReader limita el número de bytes a leer. Uno podría pensar que esta implementación, este Wrapper, resta todo lo que está en el Reader, que envuelve, y luego da todo lo que queremos. Pero todo funciona un poco diferente ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LimitedReader recorta el segmento dado como argumento a lo largo del límite superior. </font><font style="vertical-align: inherit;">Y le pasa esta rebanada recortada a Reader, que la envuelve. </font><font style="vertical-align: inherit;">Esta es una demostración clara de cómo se regula la longitud de los datos leídos en las implementaciones de la interfaz io.Reader.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Error al devolver el final del archivo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro punto interesante: ¡observe cómo esta implementación devuelve un error EOF! </font><font style="vertical-align: inherit;">Los valores nombrados devueltos se usan aquí, y se asignan por los valores que obtenemos del Reader envuelto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y si sucede que hay más datos en el Reader envuelto de los que necesitamos, asignamos los valores del Reader envuelto, por ejemplo, 10 bytes y cero, porque todavía hay datos en el Reader envuelto. </font><font style="vertical-align: inherit;">Pero la variable n, que disminuye (en la penúltima línea), dice que hemos llegado al "fondo", el final de lo que necesitamos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la próxima iteración, el cliente debe volver de nuevo; en la primera condición, recibirá EOF. </font><font style="vertical-align: inherit;">Este es el caso que mencioné. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Continuará muy pronto ...</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/kuyjuGk1USY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un poco de publicidad :)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gracias por estar con nosotros. ¿Te gustan nuestros artículos? ¿Quieres ver más materiales interesantes? Apóyenos haciendo un pedido o recomendando a sus amigos, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VPS en la nube para desarrolladores desde $ 4.99</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">análogo único de servidores de nivel básico que inventamos para usted: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toda la verdad sobre VPS (KVM) E5-2697 v3 (6 núcleos) 10GB DDR4 480GB SSD 1Gbps desde $ 19 o cómo dividir el servidor?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (las opciones están disponibles con RAID1 y RAID10, hasta 24 núcleos y hasta 40GB DDR4). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xd 2 veces más barato en el centro de datos Equinix Tier IV en Amsterdam?</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solo tenemos </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV desde $ 199</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en los Países Bajos.</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - ¡desde $ 99! </font></font></b></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lea sobre</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cómo construir un edificio de infraestructura. </font><font style="vertical-align: inherit;">clase c con servidores Dell R730xd E5-2650 v4 que cuestan 9,000 euros por un centavo?</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es491462/index.html">Lectura de fin de semana: 12 podcasts, puesta de sol de la era FM y aplicaciones de meditación</a></li>
<li><a href="../es491476/index.html">MEMS acelerómetros, magnetómetros y ángulos de orientación</a></li>
<li><a href="../es491478/index.html">Un nuevo implante para ciegos se conecta directamente al cerebro</a></li>
<li><a href="../es491480/index.html">Proyecto CoVirus MVP: un mapa en línea de la infección por coronavirus o un "botón rojo" en la mano</a></li>
<li><a href="../es491482/index.html">Presentamos PowerShell 7.0</a></li>
<li><a href="../es491486/index.html">Script personalizado al cerrar la tapa de la computadora portátil y bloquear la pantalla sin dormir</a></li>
<li><a href="../es491488/index.html">¿Qué significa ser ágil?</a></li>
<li><a href="../es491490/index.html">¿Cómo hereda Gitlab-CI las variables de entorno?</a></li>
<li><a href="../es491494/index.html">La grandiosa estafa de la ciencia soviética: por qué una nave orbital reutilizable resultó ser única</a></li>
<li><a href="../es491496/index.html">Consejos y trucos de IntelliJ IDEA: 1. Comparación de archivos y carpetas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>