<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§úüèº üíü üö£ Hunderttausende von Routen pro Sekunde und Kern. Yandex.Routing Erfahrung üôèüèª üèÜ ü§ê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor ein paar Wochen erz√§hlte Danya Tararukhin auf Habr√©, wie unser Service Yandex.Routing aussah und wie er Unternehmen bei der Logistik hilft. Mit de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Hunderttausende von Routen pro Sekunde und Kern. Yandex.Routing Erfahrung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/496818/"><img src="https://habrastorage.org/webt/it/we/vn/itwevn4ivk3h4pncvonx-mh4w70.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor ein paar Wochen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erz√§hlte</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Danya Tararukhin </font><font style="vertical-align: inherit;">auf Habr√©, wie unser Service Yandex.Routing aussah und wie er Unternehmen bei der Logistik hilft. </font><font style="vertical-align: inherit;">Mit der Erstellung der Plattform haben wir einige interessante Probleme gel√∂st, von denen eines dem heutigen Beitrag gewidmet ist. </font><font style="vertical-align: inherit;">Ich m√∂chte √ºber die Routenplanung selbst und die daf√ºr ben√∂tigten Ressourcen sprechen.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Finden der besten Route zwischen mehreren Punkten ist ein klassisches diskretes Optimierungsproblem. </font><font style="vertical-align: inherit;">Um dies zu l√∂sen, m√ºssen Sie die Entfernungen und Fahrzeiten zwischen allen Punkten kennen. </font><font style="vertical-align: inherit;">Das hei√üt, die Matrix der Entfernungen und Zeiten zu kennen. </font><font style="vertical-align: inherit;">Vor zwei Jahren war eine lange Matrixberechnung f√ºr uns ein sehr kritisches Problem und blockierte die Entwicklung. </font><font style="vertical-align: inherit;">Die Suche nach der optimalen L√∂sung mit der bekannten Matrix dauerte 10 Minuten, aber die Berechnung aller Zellen der Matrix f√ºr gro√üe Aufgaben (f√ºr mehrere tausend Bestellungen) dauerte Stunden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das Problem mit f√ºnftausend Bestellungen zu l√∂sen, m√ºssen Sie die Entfernungen und Fahrzeiten zwischen allen Punkten kennen. Dies sind zwei Zahlenmatrizen mit einer Abmessung von 5000 x 5000. Wir planen Kurierrouten f√ºr den ganzen Tag, und am Morgen wird der Kurier einmal und abends von Punkt zu Punkt kommen - zum anderen. Sie m√ºssen also die Zeit- und Entfernungsmatrix f√ºr jede Stunde des Tages berechnen. Nicht alle Stunden des Tages sind einzigartig, aber die Korkzeit (morgens und abends) muss gut abgedeckt werden. Daher kamen wir zu einer Konfiguration mit dreizehn Stundenschnitten. Insgesamt ben√∂tigen wir zwei W√ºrfel (Zeiten und Entfernungen) von jeweils 13x5000x5000. Dies sind 325 Millionen Routen, berechnet nach dem realen Stra√üendiagramm, in dem 165 Millionen Kanten liegen. Die Berechnung einer Route in einem gut optimierten Algorithmus des Yandex.Maps-Teams dauert etwa 10 ms, was insgesamt 900 Stunden Berechnungen entspricht.Selbst wenn Sie auf 900 CPUs parallelisiert sind, m√ºssen Sie 1 Stunde warten. Wir konnten einen solchen Dienst nicht starten, wir brauchten einen geeigneteren Algorithmus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum weiteren Lesen ist es hilfreich, den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dijkstra-Algorithmus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu kennen, um den k√ºrzesten Weg in einem Diagramm zu finden. Es kann sich als eine ‚ÄûWelle‚Äú vorstellen, die vom Startpunkt der Route ausgeht und den gesamten Graphen umrundet, bis der Endpunkt erreicht ist. In diesem Fall ist die Laufzeit des Algorithmus proportional zu den Kanten des Diagramms, dh dem von der Welle abgedeckten Bereich: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cz/7s/em/cz7seml-ef9d058gdfhgkoe50_k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fast jeder Kandidat f√ºr ein Interview bei einem Interview kennt den ersten Schritt zur Optimierung einer solchen Aufgabe: Sie k√∂nnen die Welle von zwei Seiten starten und die Suche beenden, wenn sich die Wellen treffen. Die Gesamtfl√§che von zwei Wellen mit halbem Radius ist kleiner als eine gro√üe.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2g/ch/2c/2gch2cvzqgbjwduk9_agsqhvrma.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das reale Stra√üendiagramm ist ziemlich strukturiert und kann verwendet werden. Wenn Sie nach der k√ºrzesten Entfernung zwischen Moskau und St. Petersburg suchen, werden Sie in der klassischen Dijkstra gezwungen sein, die Welle im Kreis zu verbreiten und alle Stra√üen und Gassen Moskaus, die St√§dte und D√∂rfer der Region Moskau, die Stra√üen Twer und Nowgorod zu sortieren. Dies ist eine enorme Menge an Berechnungen, aber Sie k√∂nnen sich im Voraus vorbereiten und die optimalen Routen zwischen St√§dten (auch als Verkn√ºpfungen bezeichnet) merken und diese nicht zur Laufzeit wiederholen. Um dann die Route zwischen zwei Punkten in der hierarchischen Dijkstra zu finden, m√ºssen Sie die k√ºrzesten Entfernungen zur gew√ºnschten Verkn√ºpfung berechnen. Da die Hierarchieebenen m√∂glicherweise nicht zwei, sondern 5 bis 6 sind, verk√ºrzen sie die Suchzeit erheblich.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Card-Router-Team hat solche Optimierungen seit geraumer Zeit implementiert. Sie haben es m√∂glich gemacht, 10 ms zu erreichen, um eine Route zwischen zwei Punkten zu finden. :) Im Moment sind wir also nicht nahe daran, unser Problem zu l√∂sen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da der Punkt-zu-Punkt-Suchmodus bereits extrem optimiert ist, k√∂nnen wir die Berechnung der Reihen in der Matrix optimieren. Eine Zeile ist der Abstand von einem Punkt zu allen anderen. W√§hrend wir nach der Entfernung zum entferntesten Punkt suchen, berechnen wir gleichzeitig die Entfernung zu n√§heren. Daher entspricht die Berechnung der Reihe der Berechnung des Abstands zum am weitesten entfernten Punkt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jp/6i/qa/jp6iqadxummylqmj1suh0h2ppe8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir betrachten den Zeitpunkt der Berechnung der Reihen mit diesem Algorithmus und erinnern uns, dass die sequentielle Berechnung von 5000 Routen etwa 5000 * 10 ms = 50 s dauern w√ºrde:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jv/c_/v9/jvc_v98yos03l5xd5w57394s4dk.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Grafik zeigt die Berechnungszeit einer Zeile in einer Abstandsmatrix der Gr√∂√üe 1 * N f√ºr verschiedene N (nach realen Daten). Es ist ersichtlich, dass die Berechnung der f√ºr uns interessanten Zeile der Gr√∂√üe 1 * 5000 in 1,3 Sekunden passt. Dem Diagramm wurde eine Trendlinie hinzugef√ºgt, die zeigt, dass die Berechnungszeit in N, der Gr√∂√üenordnung von N ** 0,74, etwas langsamer als linear w√§chst.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Schon nicht schlecht! Mit diesem Algorithmus k√∂nnen wir unseren W√ºrfel in 13 * 5000 * 1,3 s = 84 500 s = fast 24 Stunden berechnen. Es gibt leicht Parallelen in Reihen, und bei Verwendung von 50 CPUs werden die Entfernungen in einer halben Stunde berechnet. Die Komplexit√§tsreihenfolge des W√ºrfelberechnungsalgorithmus ist O (N ** 1,74):</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9c/cr/xd/9ccrxdjoher2ks-ijoa7ur3rd2m.png"><br>
<i>    13   N*N    50 CPU (    13*N/50).      ,        5000 ,           .      10 000,   :      .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dieser Form haben wir vor zweieinhalb Jahren die erste Version unserer API ver√∂ffentlicht, die das Logistikproblem l√∂st. Kunden haben sich oft √ºber eine lange Entscheidungszeit beschwert und sind leicht zu verstehen: Sie haben eine zu l√∂sende Aufgabe gestartet, 1 Stunde gewartet, eine L√∂sung gefunden und verstanden, dass Sie vergessen haben, die Schichtzeit mit dem Fahrer festzulegen, Sie korrigieren sie und alles beginnt von vorne. Die Fahrer werden langsam nerv√∂s, weil sie Gefahr laufen, in die morgendliche Hauptverkehrszeit zu geraten, oder sogar keine Zeit haben, die Bestellung p√ºnktlich zu liefern. Es war notwendig, etwas zu tun. Wir wollten das Problem mit Eisen nicht ‚Äûwerfen‚Äú: Wir haben uns auf schwere Lasten vorbereitet, es h√§tte viel Eisen ben√∂tigt, und der Kauf von Servern findet nicht sofort statt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Studie mit wissenschaftlichen Artikeln hat gezeigt, dass es f√ºr diese Aufgabe Algorithmen mit linearer Komplexit√§t gibt </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! (In dem Artikel, auf den Bezug genommen wird, gibt es einen gro√üen √úberblick √ºber alle Arten moderner Methoden der Dijkstra-Beschleunigung, einschlie√ülich f√ºr den Matrixfall.) Die Berechnung der Matrix in linearer Zeit passte nicht in meinen Kopf. Einer unserer Entwickler hat sich freiwillig gemeldet, um einen Prototyp zu schreiben, und genau das ist passiert: Die </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/3o/lq/ag3olqspwhrjrvtodp699z6bl64.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit, um eine Matrix der Gr√∂√üe N * N auf einer CPU mit dem "Fast Matrix" -Algorithmus zu berechnen. Die Komplexit√§t wird in der Gr√∂√üenordnung von O (N ** 1,1) erhalten. Hohe Ns werden aus der Trendlinie geworfen, da die Generierung der Antwort und das Herunterladen √ºber das Netzwerk die Zeit bereits st√§rker beeinflussen.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
115 Sekunden pro 5000x5000 Matrix mit einem einzigen Kern und einer fast linearen Abh√§ngigkeit von N. Fiktion ist Realit√§t geworden! Die Idee des Algorithmus kombiniert die beiden oben beschriebenen Ideen: Dijkstra f√ºr die serielle und hierarchische Suche. Wenn wir mit der Berechnung der zweiten Zeile beginnen, werden wir nat√ºrlich irgendwann wieder denselben Bereich des Diagramms durchlaufen, den wir gerade durchlaufen haben, und die vorherige Zeile berechnen. Lassen Sie uns daher die k√ºrzesten Entfernungen zu allen Zielen an den Knoten des hierarchischen Diagramms speichern. Wenn wir mit der Berechnung der n√§chsten Reihe beginnen, erhalten wir nach Erreichen eines solchen Knotens sofort fast alle Entfernungen zu anderen Punkten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ch/3y/os/ch3yosqi1h0od0dtee_tn_dsqem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor anderthalb Jahren konnten wir mit </font><b><font style="vertical-align: inherit;">e</font></b><font style="vertical-align: inherit;"> eine halbe Stunde Zeit sparen</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logistik und reduzieren deutlich die Eisenaufnahme. </font><font style="vertical-align: inherit;">Fr√ºher brauchten wir f√ºr eine gro√üe Anfrage 50 Kerne f√ºr eine halbe Stunde, jetzt - 13 Kerne f√ºr 2 Minuten. </font><font style="vertical-align: inherit;">Dies sind ungef√§hr 200.000 Routen pro Sekunde pro Kern. </font><font style="vertical-align: inherit;">Dieser seltene Fall, in dem der neue Algorithmus nicht nur die Klasse der Probleme schlie√üt, sondern unsere Vorstellungen √ºber das M√∂gliche erweitert.</font></font><br>
 <br>
<hr><sub><sup><a name="arxiv"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Artikel ‚ÄûRoutenplanung in Verkehrsnetzen‚Äú, siehe Abschnitt </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.7.2 ‚ÄûBatched Shortest Paths‚Äú.</font></font></a></sup></sub></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de496802/index.html">Einfach gemacht leicht - Rich Hickey (mit russischer √úbersetzung)</a></li>
<li><a href="../de496804/index.html">Installieren und Konfigurieren von Docker unter Windows Subsystem Linux (WSL)</a></li>
<li><a href="../de496810/index.html">Allgemeine Finanzanalyse in Python (Teil 3)</a></li>
<li><a href="../de496812/index.html">Zoom - banale Nachl√§ssigkeit oder gezielte Spionage?</a></li>
<li><a href="../de496816/index.html">Kannst du den Kandidaten f√ºhlen, lebt er?</a></li>
<li><a href="../de496820/index.html">Fallstricke von Terraform</a></li>
<li><a href="../de496822/index.html">Wie Startups in den USA an Coronavirus sterben</a></li>
<li><a href="../de496824/index.html">Ihr nordisches Arbeitsumfeld</a></li>
<li><a href="../de496826/index.html">Millionen Sprites mit mehr als 120 fps</a></li>
<li><a href="../de496828/index.html">Wo finde ich freiberufliche Mitarbeiter, die Spa√ü machen werden? (Spoiler: nicht Upwork)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>