<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤜🏼 💟 🚣 Hunderttausende von Routen pro Sekunde und Kern. Yandex.Routing Erfahrung 🙏🏻 🏆 🤐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor ein paar Wochen erzählte Danya Tararukhin auf Habré, wie unser Service Yandex.Routing aussah und wie er Unternehmen bei der Logistik hilft. Mit de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Hunderttausende von Routen pro Sekunde und Kern. Yandex.Routing Erfahrung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/496818/"><img src="https://habrastorage.org/webt/it/we/vn/itwevn4ivk3h4pncvonx-mh4w70.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor ein paar Wochen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erzählte</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Danya Tararukhin </font><font style="vertical-align: inherit;">auf Habré, wie unser Service Yandex.Routing aussah und wie er Unternehmen bei der Logistik hilft. </font><font style="vertical-align: inherit;">Mit der Erstellung der Plattform haben wir einige interessante Probleme gelöst, von denen eines dem heutigen Beitrag gewidmet ist. </font><font style="vertical-align: inherit;">Ich möchte über die Routenplanung selbst und die dafür benötigten Ressourcen sprechen.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Finden der besten Route zwischen mehreren Punkten ist ein klassisches diskretes Optimierungsproblem. </font><font style="vertical-align: inherit;">Um dies zu lösen, müssen Sie die Entfernungen und Fahrzeiten zwischen allen Punkten kennen. </font><font style="vertical-align: inherit;">Das heißt, die Matrix der Entfernungen und Zeiten zu kennen. </font><font style="vertical-align: inherit;">Vor zwei Jahren war eine lange Matrixberechnung für uns ein sehr kritisches Problem und blockierte die Entwicklung. </font><font style="vertical-align: inherit;">Die Suche nach der optimalen Lösung mit der bekannten Matrix dauerte 10 Minuten, aber die Berechnung aller Zellen der Matrix für große Aufgaben (für mehrere tausend Bestellungen) dauerte Stunden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das Problem mit fünftausend Bestellungen zu lösen, müssen Sie die Entfernungen und Fahrzeiten zwischen allen Punkten kennen. Dies sind zwei Zahlenmatrizen mit einer Abmessung von 5000 x 5000. Wir planen Kurierrouten für den ganzen Tag, und am Morgen wird der Kurier einmal und abends von Punkt zu Punkt kommen - zum anderen. Sie müssen also die Zeit- und Entfernungsmatrix für jede Stunde des Tages berechnen. Nicht alle Stunden des Tages sind einzigartig, aber die Korkzeit (morgens und abends) muss gut abgedeckt werden. Daher kamen wir zu einer Konfiguration mit dreizehn Stundenschnitten. Insgesamt benötigen wir zwei Würfel (Zeiten und Entfernungen) von jeweils 13x5000x5000. Dies sind 325 Millionen Routen, berechnet nach dem realen Straßendiagramm, in dem 165 Millionen Kanten liegen. Die Berechnung einer Route in einem gut optimierten Algorithmus des Yandex.Maps-Teams dauert etwa 10 ms, was insgesamt 900 Stunden Berechnungen entspricht.Selbst wenn Sie auf 900 CPUs parallelisiert sind, müssen Sie 1 Stunde warten. Wir konnten einen solchen Dienst nicht starten, wir brauchten einen geeigneteren Algorithmus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum weiteren Lesen ist es hilfreich, den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dijkstra-Algorithmus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu kennen, um den kürzesten Weg in einem Diagramm zu finden. Es kann sich als eine „Welle“ vorstellen, die vom Startpunkt der Route ausgeht und den gesamten Graphen umrundet, bis der Endpunkt erreicht ist. In diesem Fall ist die Laufzeit des Algorithmus proportional zu den Kanten des Diagramms, dh dem von der Welle abgedeckten Bereich: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cz/7s/em/cz7seml-ef9d058gdfhgkoe50_k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fast jeder Kandidat für ein Interview bei einem Interview kennt den ersten Schritt zur Optimierung einer solchen Aufgabe: Sie können die Welle von zwei Seiten starten und die Suche beenden, wenn sich die Wellen treffen. Die Gesamtfläche von zwei Wellen mit halbem Radius ist kleiner als eine große.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2g/ch/2c/2gch2cvzqgbjwduk9_agsqhvrma.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das reale Straßendiagramm ist ziemlich strukturiert und kann verwendet werden. Wenn Sie nach der kürzesten Entfernung zwischen Moskau und St. Petersburg suchen, werden Sie in der klassischen Dijkstra gezwungen sein, die Welle im Kreis zu verbreiten und alle Straßen und Gassen Moskaus, die Städte und Dörfer der Region Moskau, die Straßen Twer und Nowgorod zu sortieren. Dies ist eine enorme Menge an Berechnungen, aber Sie können sich im Voraus vorbereiten und die optimalen Routen zwischen Städten (auch als Verknüpfungen bezeichnet) merken und diese nicht zur Laufzeit wiederholen. Um dann die Route zwischen zwei Punkten in der hierarchischen Dijkstra zu finden, müssen Sie die kürzesten Entfernungen zur gewünschten Verknüpfung berechnen. Da die Hierarchieebenen möglicherweise nicht zwei, sondern 5 bis 6 sind, verkürzen sie die Suchzeit erheblich.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Card-Router-Team hat solche Optimierungen seit geraumer Zeit implementiert. Sie haben es möglich gemacht, 10 ms zu erreichen, um eine Route zwischen zwei Punkten zu finden. :) Im Moment sind wir also nicht nahe daran, unser Problem zu lösen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da der Punkt-zu-Punkt-Suchmodus bereits extrem optimiert ist, können wir die Berechnung der Reihen in der Matrix optimieren. Eine Zeile ist der Abstand von einem Punkt zu allen anderen. Während wir nach der Entfernung zum entferntesten Punkt suchen, berechnen wir gleichzeitig die Entfernung zu näheren. Daher entspricht die Berechnung der Reihe der Berechnung des Abstands zum am weitesten entfernten Punkt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jp/6i/qa/jp6iqadxummylqmj1suh0h2ppe8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir betrachten den Zeitpunkt der Berechnung der Reihen mit diesem Algorithmus und erinnern uns, dass die sequentielle Berechnung von 5000 Routen etwa 5000 * 10 ms = 50 s dauern würde:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jv/c_/v9/jvc_v98yos03l5xd5w57394s4dk.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Grafik zeigt die Berechnungszeit einer Zeile in einer Abstandsmatrix der Größe 1 * N für verschiedene N (nach realen Daten). Es ist ersichtlich, dass die Berechnung der für uns interessanten Zeile der Größe 1 * 5000 in 1,3 Sekunden passt. Dem Diagramm wurde eine Trendlinie hinzugefügt, die zeigt, dass die Berechnungszeit in N, der Größenordnung von N ** 0,74, etwas langsamer als linear wächst.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Schon nicht schlecht! Mit diesem Algorithmus können wir unseren Würfel in 13 * 5000 * 1,3 s = 84 500 s = fast 24 Stunden berechnen. Es gibt leicht Parallelen in Reihen, und bei Verwendung von 50 CPUs werden die Entfernungen in einer halben Stunde berechnet. Die Komplexitätsreihenfolge des Würfelberechnungsalgorithmus ist O (N ** 1,74):</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9c/cr/xd/9ccrxdjoher2ks-ijoa7ur3rd2m.png"><br>
<i>    13   N*N    50 CPU (    13*N/50).      ,        5000 ,           .      10 000,   :      .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dieser Form haben wir vor zweieinhalb Jahren die erste Version unserer API veröffentlicht, die das Logistikproblem löst. Kunden haben sich oft über eine lange Entscheidungszeit beschwert und sind leicht zu verstehen: Sie haben eine zu lösende Aufgabe gestartet, 1 Stunde gewartet, eine Lösung gefunden und verstanden, dass Sie vergessen haben, die Schichtzeit mit dem Fahrer festzulegen, Sie korrigieren sie und alles beginnt von vorne. Die Fahrer werden langsam nervös, weil sie Gefahr laufen, in die morgendliche Hauptverkehrszeit zu geraten, oder sogar keine Zeit haben, die Bestellung pünktlich zu liefern. Es war notwendig, etwas zu tun. Wir wollten das Problem mit Eisen nicht „werfen“: Wir haben uns auf schwere Lasten vorbereitet, es hätte viel Eisen benötigt, und der Kauf von Servern findet nicht sofort statt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Studie mit wissenschaftlichen Artikeln hat gezeigt, dass es für diese Aufgabe Algorithmen mit linearer Komplexität gibt </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! (In dem Artikel, auf den Bezug genommen wird, gibt es einen großen Überblick über alle Arten moderner Methoden der Dijkstra-Beschleunigung, einschließlich für den Matrixfall.) Die Berechnung der Matrix in linearer Zeit passte nicht in meinen Kopf. Einer unserer Entwickler hat sich freiwillig gemeldet, um einen Prototyp zu schreiben, und genau das ist passiert: Die </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/3o/lq/ag3olqspwhrjrvtodp699z6bl64.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit, um eine Matrix der Größe N * N auf einer CPU mit dem "Fast Matrix" -Algorithmus zu berechnen. Die Komplexität wird in der Größenordnung von O (N ** 1,1) erhalten. Hohe Ns werden aus der Trendlinie geworfen, da die Generierung der Antwort und das Herunterladen über das Netzwerk die Zeit bereits stärker beeinflussen.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
115 Sekunden pro 5000x5000 Matrix mit einem einzigen Kern und einer fast linearen Abhängigkeit von N. Fiktion ist Realität geworden! Die Idee des Algorithmus kombiniert die beiden oben beschriebenen Ideen: Dijkstra für die serielle und hierarchische Suche. Wenn wir mit der Berechnung der zweiten Zeile beginnen, werden wir natürlich irgendwann wieder denselben Bereich des Diagramms durchlaufen, den wir gerade durchlaufen haben, und die vorherige Zeile berechnen. Lassen Sie uns daher die kürzesten Entfernungen zu allen Zielen an den Knoten des hierarchischen Diagramms speichern. Wenn wir mit der Berechnung der nächsten Reihe beginnen, erhalten wir nach Erreichen eines solchen Knotens sofort fast alle Entfernungen zu anderen Punkten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ch/3y/os/ch3yosqi1h0od0dtee_tn_dsqem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor anderthalb Jahren konnten wir mit </font><b><font style="vertical-align: inherit;">e</font></b><font style="vertical-align: inherit;"> eine halbe Stunde Zeit sparen</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logistik und reduzieren deutlich die Eisenaufnahme. </font><font style="vertical-align: inherit;">Früher brauchten wir für eine große Anfrage 50 Kerne für eine halbe Stunde, jetzt - 13 Kerne für 2 Minuten. </font><font style="vertical-align: inherit;">Dies sind ungefähr 200.000 Routen pro Sekunde pro Kern. </font><font style="vertical-align: inherit;">Dieser seltene Fall, in dem der neue Algorithmus nicht nur die Klasse der Probleme schließt, sondern unsere Vorstellungen über das Mögliche erweitert.</font></font><br>
 <br>
<hr><sub><sup><a name="arxiv"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Artikel „Routenplanung in Verkehrsnetzen“, siehe Abschnitt </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.7.2 „Batched Shortest Paths“.</font></font></a></sup></sub></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de496802/index.html">Einfach gemacht leicht - Rich Hickey (mit russischer Übersetzung)</a></li>
<li><a href="../de496804/index.html">Installieren und Konfigurieren von Docker unter Windows Subsystem Linux (WSL)</a></li>
<li><a href="../de496810/index.html">Allgemeine Finanzanalyse in Python (Teil 3)</a></li>
<li><a href="../de496812/index.html">Zoom - banale Nachlässigkeit oder gezielte Spionage?</a></li>
<li><a href="../de496816/index.html">Kannst du den Kandidaten fühlen, lebt er?</a></li>
<li><a href="../de496820/index.html">Fallstricke von Terraform</a></li>
<li><a href="../de496822/index.html">Wie Startups in den USA an Coronavirus sterben</a></li>
<li><a href="../de496824/index.html">Ihr nordisches Arbeitsumfeld</a></li>
<li><a href="../de496826/index.html">Millionen Sprites mit mehr als 120 fps</a></li>
<li><a href="../de496828/index.html">Wo finde ich freiberufliche Mitarbeiter, die Spaß machen werden? (Spoiler: nicht Upwork)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>