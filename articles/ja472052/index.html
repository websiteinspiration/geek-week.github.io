<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌇 🔞 🚣🏿 データ指向の設計（または、なぜOOPを使用すると、おそらく自分の足で撃たれるのか） 🤱🏻 ☝🏿 📫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この画像を想像してみてください。開発サイクルの終わりが近づいていて、ゲームはほとんど忍び寄っていませんが、プロファイラーでは明らかな問題領域を見つけることができません。誰が悪いのか？ランダムアクセスメモリパターンと永続的なキャッシュミス。パフォーマンスを改善しようとすると、コードの一部を並列化しよう...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>データ指向の設計（または、なぜOOPを使用すると、おそらく自分の足で撃たれるのか）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472052/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f8/5ea/960/4f85ea960a2c233300fd62f394a5b213.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この画像を想像してみてください。開発サイクルの終わりが近づいていて、ゲームはほとんど忍び寄っていませんが、プロファイラーでは明らかな問題領域を見つけることができません。誰が悪いのか？ランダムアクセスメモリパターンと永続的なキャッシュミス。パフォーマンスを改善しようとすると、コードの一部を並列化しようとしますが、それは英雄的な努力の価値があります。結局、追加する必要のあるすべての同期のため、加速はほとんど目立ちません。さらに、コードは非常に複雑なので、バグを修正するとさらに多くの問題が発生し、新しい機能を追加するという考えはすぐに破棄されます。聞き覚えがある？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このイベントの展開は、過去10年間に参加した開発のほぼすべてのゲームをかなり正確に説明しています。</font><font style="vertical-align: inherit;">その理由は、プログラミング言語や開発ツールではなく、規律の欠如でさえありません。</font><font style="vertical-align: inherit;">私の経験では、大部分はオブジェクト指向プログラミング（OOP）とその周囲の文化に責任があります。</font><font style="vertical-align: inherit;">OOPは役に立たないかもしれませんが、プロジェクトに干渉します！</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データがすべて</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOPは、ビデオゲーム開発の既存の文化に深く浸透しているため、ゲームについて考えるとき、オブジェクト以外のものを想像するのは困難です。</font><font style="vertical-align: inherit;">何年もの間、私たちは車、プレーヤー、および状態機械のクラスを作成してきました。</font><font style="vertical-align: inherit;">代替案は何ですか？</font><font style="vertical-align: inherit;">手続き型プログラミング？</font><font style="vertical-align: inherit;">関数型言語？</font><font style="vertical-align: inherit;">エキゾチックなプログラミング言語？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ指向設計は、これらすべての問題を解決するように設計されたソフトウェアを設計するもう1つの方法です。手続き型プログラミングの主な要素は手続き呼び出しであり、OOPは主にオブジェクトを扱います。どちらの場合も、コードは中央に置かれていることに注意してください。一方は通常のプロシージャ（または関数）であり、もう一方は特定の内部状態に関連付けられたグループ化されたコードです。データ指向の設計により、注目の対象がオブジェクトからデータ自体に移ります。データのタイプ、メモリ内の場所、ゲームでのデータの読み取りと処理の方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定義によるプログラミングは、データを変換する方法です。つまり、入力データを処理して出力データを作成するプロセスを記述する一連の機械命令を作成する行為です。</font><font style="vertical-align: inherit;">ゲームは対話型プログラムにすぎないので、データを処理するコードではなく、主にデータに集中する方が論理的ではないでしょうか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
混乱しないように、すぐに説明します。データ指向の設計は、プログラムがデータ駆動型であるという意味ではありません。</font><font style="vertical-align: inherit;">データ駆動型ゲームは通常、機能の大部分がコードの外にあるゲームです。</font><font style="vertical-align: inherit;">データがゲームの動作を決定できるようにします。</font><font style="vertical-align: inherit;">この概念は、データ指向の設計とは無関係であり、任意のプログラミング方法で使用できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完璧なデータ</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/100/4e9/bb7/1004e9bb72c374929c1b914a344c43b9.png" alt="オブジェクト指向のアプローチによる呼び出しシーケンス" width="229" height="247"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図1a。オブジェクト指向の方法でシーケンスを呼び出す</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
プログラムをデータの観点から見ると、理想的なデータはどのようになるでしょうか。データ自体とその使用方法によって異なります。一般的に、理想的なデータは、最小限の労力で使用できる形式です。最良の場合、フォーマットは予想される出力結果と完全に一致します。つまり、処理はデータのコピーのみで構成されます。多くの場合、理想的なデータスキームは、連続して処理できる隣接する同種データの大きなブロックのように見えます。いずれにせよ、目標はコンバージョン数を最小限に抑えることです。可能であれば、ゲームリソースを作成する段階で、この理想的な形式でデータを事前に「ベイク」します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ指向の設計ではデータを最優先するため、理想的なデータ形式を中心としたプログラム全体のアーキテクチャを作成できます。私たちは常にそれを完全に完璧にすることに成功するわけではありません（コードが教科書のOOPにほとんど似ていないように）が、これは私たちの主な目標であり、常に覚えています。これを実現すると、記事の冒頭で述べた問題のほとんどが解決します（この次のセクションで詳しく説明します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトについて考えると、ツリー（継承ツリー、ネストツリー、メッセージツリー）をすぐに思い出し、データはこのように自然に順序付けられます。</font><font style="vertical-align: inherit;">したがって、オブジェクトに対して操作を実行すると、通常、オブジェクトがツリーの下にある他のオブジェクトにアクセスするという事実につながります。</font><font style="vertical-align: inherit;">複数のオブジェクトを反復処理する場合、同じ操作を実行すると、各オブジェクトに対して下流の完全に異なる操作が生成されます（図1aを参照）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f8/5ea/960/4f85ea960a2c233300fd62f394a5b213.png" alt="データ指向のアプローチによるシーケンスの呼び出し" width="233" height="297"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図1b。</font><font style="vertical-align: inherit;">データ指向の手法での呼び出しシーケンス</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最適なデータストレージスキームを取得するには、取得したオブジェクトに関係なく、各オブジェクトを異なるコンポーネントに分割し、同じタイプのコンポーネントをメモリ内でグループ化すると便利です。このような順序付けにより、同種のデータの大きなブロックが作成され、データを順次処理できるようになります（図1bを参照）。データ指向のデザインコンセプトの威力の主な理由は、オブジェクトの大きなグループで非常にうまく機能することです。 OOPは、定義上、単一のオブジェクトで機能します。最後に取り組んだゲームを思い出してください。コード内で、1つの要素のみで作業しなければならない場所をどれくらいの頻度で見つけましたか？敵は一人？車一台？ノードを見つける1つの方法？一発？ワンピース？絶対に！ 1つある場合は、さらにいくつかあります。OOPはこれを無視し、各オブジェクトを個別に処理します。したがって、同じタイプの多くの要素を処理する必要があるようにデータを整理することにより、私たち自身と機器の作業を簡略化できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは奇妙に思えますか？</font><font style="vertical-align: inherit;">しかし、あなたは何を知っていますか？</font><font style="vertical-align: inherit;">ほとんどの場合、コードの一部ですでに使用しています。つまり、パーティクルシステムです。</font><font style="vertical-align: inherit;">データ指向の設計により、コードベース全体が巨大なパーティクルシステムに変わります。</font><font style="vertical-align: inherit;">おそらく、この方法をゲーム開発者にとってより身近なものにするには、パーティクル駆動プログラミングと呼ばれる必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ指向設計の利点</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まずデータについて考え、これに基づいてプログラムのアーキテクチャを作成すると、多くの利点が得られます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並列処理</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、複数のコアで作業する必要があるという事実を取り除くことは不可能です。 OOPコードを並列化しようとした人は、タスクがいかに複雑でエラーが発生しやすく、おそらく特に効率的ではないことを確認できます。多くの同期プリミティブを追加して、複数のスレッドから同時にデータにアクセスすることを避けなければならないことがよくあります。通常、多くのスレッドが長時間アイドル状態で、他のスレッドが動作するのを待機しています。その結果、生産性の向上はかなり平凡です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ指向の設計を適用すると、並列化がはるかに簡単になります。入力データ、それを処理してデータを出力する小さな関数があります。</font><font style="vertical-align: inherit;">類似したものを簡単にいくつかのストリームに分割して、それらの間の同期を最小限に抑えることができます。</font><font style="vertical-align: inherit;">操作を変更することなく、次のステップに進んで、ローカルメモリを備えたプロセッサ（たとえば、CellプロセッサのSPU）でこのコードを実行することもできます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュの使用</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マルチコアを使用することに加えて、深い命令パイプラインと複数のキャッシュレベルを持つ低速メモリシステムを備えた最新の機器で高性能を達成するための主要な方法の1つは、キャッシュに便利なデータアクセスの実装です。</font><font style="vertical-align: inherit;">データ指向の設計では、同じコードが常に実行されるため、コマンドキャッシュを非常に効率的に使用できます。</font><font style="vertical-align: inherit;">さらに、隣接する大きなブロックにデータを配置すると、データを順次処理できるため、データキャッシュをほぼ完全に使用でき、優れたパフォーマンスを実現できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適化オプション</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトまたは関数について考えるときは、通常、関数またはアルゴリズムのレベルでの最適化に焦点を合わせます。関数呼び出しの順序を変更したり、並べ替え方法を変更したり、アセンブリ言語でCコードの一部を書き直したりします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような最適化は確かに役立ちますが、データについて最初に考える場合は、前に戻って、より野心的で重要な最適化を作成できます。</font><font style="vertical-align: inherit;">ゲームは特定のデータ（リソース、ユーザー入力、ステータス）を他のデータ（グラフィックコマンド、新しいゲームの状態）に変換することだけを扱うことを忘れないでください。</font><font style="vertical-align: inherit;">このデータストリームを念頭に置いて、データの変換方法と適用方法に基づいて、より詳細で情報に基づいた意思決定を行うことができます。</font><font style="vertical-align: inherit;">従来のOOP手法でのこのような最適化は、非常に複雑で時間がかかる可能性があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュール性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のデータ指向設計の利点はすべて、キャッシュの使用、最適化、および並列化というパフォーマンスに関連しています。私たちのゲームプログラマにとって、パフォーマンスは非常に重要であることは間違いありません。多くの場合、生産性を向上させる手法と、コードの可読性と開発の容易さを促進する手法の間には矛盾があります。たとえば、コードの一部をアセンブリ言語で書き換えると、パフォーマンスが向上しますが、これにより通常、読みやすさが低下し、コードサポートがより複雑になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸い、データ指向の設計は、生産性と開発の容易さの両方にメリットをもたらします。</font><font style="vertical-align: inherit;">データ変換専用のコードを作成すると、コードの他の部分との依存関係が非常に少ない小さな関数が得られます。</font><font style="vertical-align: inherit;">コードベースは非常に「フラット」なままで、大きな依存関係を持たない多くの「リーフ」関数があります。</font><font style="vertical-align: inherit;">このレベルのモジュール性と依存関係がないことにより、コードの理解、置き換え、更新が大幅に簡素化されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト中</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ指向設計の最後の主な利点は、テストが容易なことです。</font><font style="vertical-align: inherit;">多くの人は、オブジェクトの相互作用をテストするための単体テストを書くことは簡単なことではないことを知っています。</font><font style="vertical-align: inherit;">レイアウトを作成し、要素を間接的にテストする必要があります。</font><font style="vertical-align: inherit;">正直なところ、これはかなり苦痛です。</font><font style="vertical-align: inherit;">一方、データを直接操作する場合、単体テストの作成は非常に簡単です。受信データを作成し、それらを変換する関数を呼び出して、出力が期待されるデータと一致するかどうかを確認します。</font><font style="vertical-align: inherit;">これですべてです。</font><font style="vertical-align: inherit;">実際、これは大きな利点であり、テスト駆動開発であろうと、コードの後に​​単体テストを作成しようと、コードのテストを大幅に簡素化します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ指向設計の短所</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ指向の設計は、ゲーム開発におけるすべての問題を解決する「特効薬」ではありません。これは、高性能のコードを記述し、より読みやすく保守しやすいプログラムを作成するのに役立ちますが、それ自体にいくつかの欠点があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ指向設計の主な問題：それは、ほとんどのプログラマーが学んで使用してきたものとは異なります。それには、プログラムのメンタルモデルを90度回転させ、その視点をシフトする必要があります。このアプローチが第二の性質になるためには、実践が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、アプローチの違いにより、手続き型またはOOPスタイルで記述された既存のコードとのやり取りが困難になる可能性があります。</font><font style="vertical-align: inherit;">1つの関数を個別に作成することは困難ですが、データ指向の設計をサブシステム全体に適用できるようになるとすぐに、多くの利点を得ることができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ指向設計の使用</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
十分な理論とレビュー。</font><font style="vertical-align: inherit;">データ指向の設計方法の実装を開始するにはどうすればよいですか？</font><font style="vertical-align: inherit;">開始するには、コードの特定の領域（ナビゲーション、アニメーション、衝突など）を選択します。</font><font style="vertical-align: inherit;">その後、ゲームエンジンの主要部分がデータに焦点を当てるようになると、フレームの最初から最後まで、パス全体に沿ってデータフローを調整できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、システムが必要とする入力データと、生成する必要のあるデータのタイプを明確に識別する必要があります。データを特定するためだけに、今のところOOP用語で考えているかもしれません。たとえば、アニメーションシステムの場合、スケルトン、基本ポーズ、アニメーションデータ、および現在の状態が入力データの一部になります。結果は「アニメーションアニメーションコード」ではなく、現在再生中のアニメーションによって生成されたデータです。この場合、出力は新しいポーズのセットと更新された状態になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
受信データをその使用方法に基づいて一歩下がって分類することが重要です。それらは読み取り専用、読み取り/書き込み、または書き込み専用ですか？このような分類は、プログラムの他の部分に依存しているため、データを格納する場所とデータをいつ処理するかを決定するのに役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階で、1つの操作に必要なデータについて考えるのをやめ、それらを数十または数百の要素に適用することについて考え始める必要があります。 1つのスケルトン、1つの基本的なポーズ、および現在の状態はなくなりました。これらの各タイプのブロックがあり、各ブロックに多数のインスタンスがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入力から出力への変換プロセスでデータがどのように使用されるかを慎重に検討してください。データを送信するには、構造内の特定のフィールドをスキャンする必要があり、その結果を使用して別のパスを実行する必要があることに気付く場合があります。この場合、このソースフィールドを個別に処理できる個別のメモリブロックに分割する方が論理的かもしれません。これにより、キャッシュを最適に使用し、コードを並列化できるように準備できます。または、1つのベクトルレジスタに配置するために異なる場所からデータを受信する必要がある場合は、コードの一部をベクトル化する必要がある場合があります。この場合、データは隣接して保存されるため、不必要な変換を行わずにベクトル演算を直接適用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、データを非常によく理解できました。</font><font style="vertical-align: inherit;">それらを変換するコードを書くことはずっと簡単になります。</font><font style="vertical-align: inherit;">スペースを埋めてコードを作成するようなものです。</font><font style="vertical-align: inherit;">同じOOPコードと比較して、コードが当初考えていたよりもはるかに単純でコンパクトであることがわかり、驚くでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のブログのほとんどの投稿では、このタイプのデザインに備えることができました。</font><font style="vertical-align: inherit;">次に、データの配置方法に注意し、データを効率的に使用できるように入力形式でベイク処理し、データブロック間のポインターなしでリンクを使用して簡単に移動できるようにする必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOPを使用する余地はありますか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、OOPは役に立たないので、プログラムの作成時に使用すべきではないという意味ですか？それは言えない。各オブジェクトの1つのインスタンス（たとえば、グラフィックデバイス、ログマネージャーなど）についてのみ話している場合、オブジェクトのコンテキストで考えることは害がありませんが、この場合、コードはより簡単なCスタイルの関数と静的に基づいて実装できますファイルレベルのデータ。そして、この状況でも、オブジェクトがデータ変換に重点を置いて設計されていることが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私がまだOOPを使用しているもう1つの状況は、GUIシステムです。おそらくこれは、すでにオブジェクト指向の方法で設計されたシステムで作業しているためか、あるいはGUIコードの場合、パフォーマンスと複雑さは重要な要素ではないためです。とにかく、私は継承をほとんど使用せず、ネストを最大化するGUI APIを好みます（良い例はCocoaとCocoaTouchです）。ゲームの場合、データ指向で見栄えの良いGUIシステムを作成できる可能性がありますが、これまでのところ、そのような例はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結局のところ、ゲームをこのように考えたい場合は、オブジェクトに基づいてメンタルピクチャを作成することを妨げるものは何もありません。</font><font style="vertical-align: inherit;">敵のエッセンスがメモリ内の1つの物理的な場所を占有するのではなく、同様のコンポーネントの大きなデータテーブルの一部を形成する、より小さなサブコンポーネントに分割されるだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ指向の設計は、従来のプログラミング方法とは少し異なりますが、常にデータとそれを変換するために必要な方法を考えると、生産性と開発の容易さの点で大きな利点が得られます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja472036/index.html">素数を計算し、除数の列挙を最適化するための式</a></li>
<li><a href="../ja472040/index.html">赤黒の木のバランス調整-3つのケース</a></li>
<li><a href="../ja472042/index.html">Zextras Adminを使用したZimbra OSEでの完全なマルチテナンシー</a></li>
<li><a href="../ja472044/index.html">ISPmanagerの概要-ホスティングおよびサイトコントロールパネル</a></li>
<li><a href="../ja472046/index.html">カンファレンス：道のりの始まり</a></li>
<li><a href="../ja472054/index.html">CS Centerオンラインプログラムに関する主催者と教員</a></li>
<li><a href="../ja472060/index.html">ドイツの警察は独立したデータセンターを収容する軍事バンカーを襲撃しました</a></li>
<li><a href="../ja472062/index.html">監視+ストレステスト=予測と失敗なし</a></li>
<li><a href="../ja472064/index.html">クラウド内の仮想マシンクラスターでのAnsible +自動gitプル</a></li>
<li><a href="../ja472068/index.html">古いBIOSとLinux OSを搭載したコンピューターでシステムドライブとしてNVME SSDを使用する</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>