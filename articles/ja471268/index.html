<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤯 👩🏾‍💼 🎖️ メッセージブローカーについて理解する。ActiveMQとKafkaを介してメッセージングのメカニズムを学ぶ。第2章ActiveMQ 🧘🏽 🧑🏾‍🤝‍🧑🏽 👃🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="小さな本の翻訳の続き：
 「Understanding Message Brokers」、
 著者：Jakub Korab、出版社：O'Reilly Media、Inc.、発行日：2017年6月、ISBN：9781492049296 
 
 。翻訳は完了しました。
 
 前の部分：メッセージブローカ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>メッセージブローカーについて理解する。ActiveMQとKafkaを介してメッセージングのメカニズムを学ぶ。第2章ActiveMQ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471268/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小さな本の翻訳の続き：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「Understanding Message Brokers」、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
著者：Jakub Korab、出版社：O'Reilly Media、Inc.、発行日：2017年6月、ISBN：9781492049296 </font></font><br>
<br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。翻訳は完了しました。</font></font></a></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
前の部分：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージブローカーの理解。</font><font style="vertical-align: inherit;">ActiveMQとKafkaを介してメッセージングのメカニズムを学ぶ。</font><font style="vertical-align: inherit;">第1章;序章</font></font></a><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第2章</font></font></h2><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Activemq</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ActiveMQは、古典的なメッセージングシステムとして最もよく説明されています。これは2004年に作成され、オープンソースのメッセージブローカーの必要性を補っています。当時、アプリケーションでメッセージングを使用したい場合、唯一の選択肢は高価な商用製品でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ActiveMQは、Java Message Service（JMS）仕様の実装として開発されました。この決定は、オープンソースのJ2EEアプリケーションサーバーであるApache GeronimoプロジェクトにJMS準拠のメッセージングを実装するための要件を満たすために行われました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
：実装JMS仕様は、次のコンポーネントで構成されていること（それは時々呼ばれるように、またはメッセージ指向ミドルウェア）メッセージングシステム</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブローカ</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージを配信するミドルウェアの中心部分。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアント</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ブローカーを介してメッセージを送信するソフトウェア。</font><font style="vertical-align: inherit;">また、次のアーティファクトで構成されています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JMS APIを使用してコーディングします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JMS APIは、JMS仕様に規定されている保証に従ってブローカーと対話するための一連のインターフェースです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APIの実装を提供し、ブローカーと対話するシステムのクライアントライブラリ。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントとブローカ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、対話プロトコル</font></font></i> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とも呼ばれるアプリケーション層プロトコルを介して相互に通信し</font><i><font style="vertical-align: inherit;">ます</font></i></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（図2-1）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 JMS仕様では、このプロトコルの詳細は特定の実装に任されていました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/u1/wi/za/u1wiza7rupveiqnyqktuqsa-mvs.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2-1。 JMSの概要JMS</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
では、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロバイダー</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">という用語を使用して</font><font style="vertical-align: inherit;">、JMS APIの基礎となるメッセージングシステムのベンダーの実装を説明します。これには、ブローカーとそのクライアントライブラリが含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JMSの実装を支持する選択は、ActiveMQの作成者が行った実装の決定に広範な影響を及ぼしました。仕様自体は、メッセージングシステムのクライアントと彼が通信するブローカーの責任に関する明確なガイダンスを提供し、ブローカーのメッセージの配信と配信の義務を優先します。クライアントの主な責任は、クライアントが送信したメッセージの宛先（キューまたはトピック）と対話することです。仕様自体は、ブローカーとのAPIの相互作用を比較的単純にすることを目的としています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この領域は、後で説明するように、ActiveMQのパフォーマンスに大きな影響を与えました。</font><font style="vertical-align: inherit;">ブローカーの複雑さに加えて、Sun Microsystemsが提供する仕様の互換性パッケージには多くのニュアンスがあり、それ自体がパフォーマンスに影響を与えました。</font><font style="vertical-align: inherit;">ActiveMQをJMS互換と見なすためには、これらのニュアンスをすべて考慮に入れておく必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コミュニケーション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
APIと予想される動作はJMS仕様で明確に定義されていますが、既存のブローカーをJMS準拠にすることができるように、実際のクライアントブローカー通信プロトコルは意図的に仕様から除外されました。したがって、ActiveMQは独自の対話プロトコルであるOpenWireを自由に定義できました。 OpenWireは、ActiveMQ JMSクライアントライブラリの実装だけでなく、.NetおよびC ++の対応するもの（NMSおよびCMS）でも使用されます。これらは、Apache Software FoundationがホストするActiveMQサブプロジェクトです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間の経過とともに、他の対話プロトコルのサポートがActiveMQに追加され、他の言語や環境との対話機能が向上しました：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMQP 1.0</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Advanced Message Queuing Protocol（ISO / IEC 19464：2014）は、その前身である0.Xと混同しないでください。これは、他のメッセージングシステム、特に0.9.1を使用するRabbitMQに実装されています。 AMQP 1.0は、2つのノード間でメッセージを交換するための汎用バイナリプロトコルです。クライアントやブローカーの概念はなく、フロー制御、トランザクション、およびさまざまなQoS（1回以下、少なくとも1回、正確に1回）などの機能が含まれています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STOMP</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
シンプル/ストリーミングテキスト指向メッセージングプロトコル。さまざまな言語で数十のクライアントを実装する、実装が簡単なプロトコルです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xmpp</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
拡張可能なメッセージングとプレゼンスプロトコル。 （拡張メッセージングおよびプレゼンスプロトコル）。以前はJabberと呼ばれていたこのXMLベースのプロトコルは、もともとチャットシステム用に開発されましたが、元の使用例を超えて拡張され、パブリッシュサブスクライブメッセージングが含まれています。</font><font style="vertical-align: inherit;">
マシンマシン（M2M）およびモノのインターネット（IoT）アプリケーションに使用される</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MQTT</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">軽量パブリッシュサブスクライブプロトコル（ISO / IEC 20922：2016）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ActiveMQは、WebSocketへの上記プロトコルのインポジションもサポートします。これにより、Webブラウザーのアプリケーションとブローカーの宛先の間で全二重データ交換が提供されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを念頭に置いて、今はActiveMQについて話しているので、JMS / NMS / CMSライブラリとOpenWireプロトコルに基づく相互作用スタックだけを参照することはありません。このアプリケーションに最適な言語、プラットフォーム、および外部ライブラリの組み合わせと選択は、ますます人気が高まっています。たとえば、JavaScriptアプリケーションが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eclipse Paho</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MQTTライブラリ</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用してブラウザーで実行され、</font><font style="vertical-align: inherit;">Webソケット経由でメッセージをActiveMQに送信する</font><font style="vertical-align: inherit;">ことが可能</font><font style="vertical-align: inherit;">であり、これらのメッセージは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apache Qpidプロトン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリを通じてAMQPを使用するC ++サーバープロセスによって読み取られます</font><font style="vertical-align: inherit;">。この観点から、メッセージングの状況はより多様化しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に、AMQPは、クライアントでもブローカーでもないコンポーネントがメッセージングランドスケープのより身近な部分になっているので、現在よりもはるかに多くの機会があります。たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apache Qpidディスパッチルーター</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はメッセージルーターとして機能し、クライアントが直接接続することで、さまざまな宛先がさまざまなアドレスを処理できるようにするとともに、シャーディング（分離）の可能性を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サードパーティのライブラリと外部コンポーネントを使用する場合は、品質にばらつきがあり、ActiveMQで提供される機能と互換性がない可能性があることに注意してください。</font><font style="vertical-align: inherit;">非常に単純な例として、MQTTを介してキューにメッセージを送信することはできません（ブローカーでルーティングを設定しないと）。</font><font style="vertical-align: inherit;">したがって、アプリケーションの要件に最も適したメッセージングシステムのスタックを決定するために、オプションを使用して時間を費やす必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンスと信頼性のトレードオフ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ActiveMQでポイントツーポイントメッセージングがどのように機能するかについて詳しく説明する前に、データ処理を集中的に行うすべてのシステムが直面すること、つまりパフォーマンスと信頼性のトレードオフについて少し説明する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージブローカーであろうとデータベースであろうと、データを受け入れるすべてのシステムは、障害が発生した場合にこのデータを処理する方法について指示を受ける必要があります。障害にはさまざまな形がありますが、簡単にするために、システムが電力を失い、すぐにシャットダウンする状況に絞り込みます。この状況では、システム内にあったデータがどうなるかを推測する必要があります。データ（この場合はメッセージ）がメモリ内または鉄などの揮発性の部分（キャッシュなど）にあった場合、このデータは失われます。ただし、データがディスクなどの不揮発性ストレージに送信された場合、システムが再び機能するようになると、そのデータは再び使用可能になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この観点から見ると、ブローカーに障害が発生した場合にメッセージを失わないようにするには、永続的なストレージにメッセージを書き込む必要があります。残念ながら、この特定のソリューションのコストは非常に高くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メガバイトのデータをディスクに書き込む場合の違いは、メモリへの書き込みよりも100〜1000倍遅いことに注意してください。したがって、アプリケーション開発者は、メッセージの信頼性がパフォーマンスの損失に値するかどうかを判断する必要があります。このような決定は、使用シナリオに基づいて行う必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パフォーマンスと信頼性の間のトレードオフは、さまざまなオプションに基づいています。信頼性が高いほど、パフォーマンスは低下します。たとえば、メッセージをメモリにのみ保存するなど、システムの信頼性を低下させる場合は、生産性が大幅に向上します。デフォルトでは、信頼性を確保するために、JMSはActiveMQをそのまま使用するように構成されています。ブローカーを構成し、メッセージングシステムを使用する特定のシナリオに最も適したこの範囲内の位置にブローカーと対話できるようにする多くのメカニズムがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この妥協は、個々のブローカーのレベルで適用されます。</font><font style="vertical-align: inherit;">ただし、個々のブローカーの設定が完了すると、メッセージフローを注意深く調べ、複数のブローカー間でトラフィックを共有することにより、この時点を超えてメッセージングシステムを拡張できます。</font><font style="vertical-align: inherit;">これは、特定の受信者に独自のブローカーを提供するか、メッセージレベル全体をアプリケーションレベルで分割するか、中間コンポーネントを使用することによって実現できます。</font><font style="vertical-align: inherit;">後で、ブローカーのトポロジーをどのように考慮するかをさらに詳しく検討します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージを保存する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ActiveMQには、プラグイン可能なメッセージ保持戦略が多数付属しています。それらは、メッセージストレージエンジンと見なすことができる永続性（永続性）アダプターの形で提供されます。これらには、KahaDBやLevelDBなどのディスクベースのソリューション、およびJDBCを介してデータベースを使用する機能が含まれます。前者が最も一般的に使用されるため、それらに焦点を当てて説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブローカーが持続メッセージを受信すると、それらはまずジャーナルのディスクに書き込まれます。ジャーナルは、データの追加のみが可能なディスク上のデータ構造であり、複数のファイルで構成されます。着信メッセージは、ブローカーによってプロトコルに依存しないオブジェクトの表現にシリアル化され、バイナリ形式でマーシャリングされてから、ログの最後に書き込まれます。ログには、すべての着信メッセージのログと、クライアントによって読み取られたことが確認されたメッセージに関する情報が含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
永続ディスクアダプタは、次の転送メッセージがログのどこにあるかを追跡するインデックスファイルをサポートしています。</font><font style="vertical-align: inherit;">ログファイルからすべてのメッセージが読み取られると、それらはActiveMQバックグラウンドワークフローによって削除またはアーカイブされます。</font><font style="vertical-align: inherit;">ブローカーの障害時にこのログが破損した場合、ActiveMQはログファイルの情報に基づいてログを再構築します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのキューからのメッセージは同じログファイルに書き込まれます。つまり、1つのメッセージが読み取られなかった場合、ファイル全体（通常、永続性アダプターに応じてデフォルトは32 MBまたは100 MBです）は消去できません。</font><font style="vertical-align: inherit;">これは、時間の経過とともにディスク容量の低下という問題を引き起こす可能性があります。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラシックメッセージブローカーは長期保存用に設計されていません-メッセージを読んでください！</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ログは、両方の操作でディスクアクセスがシーケンシャルであるため、メッセージを格納して後で取得するための非常に効率的なメカニズムです。</font><font style="vertical-align: inherit;">従来のハードドライブでは、ディスク上のヘッドが単にディスクの回転する基板上のセクターの読み取りまたは書き込みを続けるため、これによりシリンダーによるディスク検索の数が最小限に抑えられます。</font><font style="vertical-align: inherit;">同様に、SSDでは、ランダムアクセスよりもシーケンシャルアクセスの方がはるかに高速です。前者はドライブのメモリページをよりよく使用するためです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディスクのパフォーマンス要因</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスクが動作する速度を決定する要因はいくつかあります。これを理解するために、パイプの簡略化されたメンタルモデルを使用してディスクに書き込む方法を考え</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">図2-2</font></a><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kv/wx/j_/kvwxj_wqzdn772kf0lb5yttf4i8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2-2。ディスクパフォ​​ーマンスパイプモデル</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
パイプには次の3つの次元があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
さ</font><i><font style="vertical-align: inherit;">待ち時間に</font></i><font style="vertical-align: inherit;">対応</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つの操作を完了することが期待されています。ほとんどのローカルドライブの場合、これはかなり良いですが、ローカルドライブが実際にオンラインであるクラウド環境では、大きな制限要因になる可能性があります。たとえば、執筆時点（2017年4月）では、AmazonはEBSストレージへの書き込みが「2ミリ秒未満」になることを保証しています。連続して記録する場合、これにより1秒あたり500レコードの最大スループットが得られます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幅</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単一操作</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">搬送容量または帯域</font></font></i><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">幅</font></b><font style="vertical-align: inherit;">を定義し</font><font style="vertical-align: inherit;">ます。ファイルシステムキャッシュはこのプロパティを使用して、多数の小さな書き込みをディスク上で実行される大きな書き込み操作の小さなセットに組み合わせます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間の経過に伴う帯域幅</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アイデアは、同時にパイプ内に存在する可能性のある一連のイベントの形で提示され、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOPS（1秒あたりのI / O操作の数）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれるメトリックによって表され</font><font style="vertical-align: inherit;">ます。 IOPSは、パフォーマンスを測定するためにストレージメーカーやクラウドプロバイダーによって一般的に使用されます。ハードドライブは、異なるコンテキストで異なるIOPS値を持ちます：ワークロードが主に読み取り、書き込み、またはそれらの組み合わせで構成されるかどうか、およびこれらの操作が順次、任意、または混合であるかどうか。ブローカーの観点から最も興味深いIOPS測定は、ログのログの読み取りと書き込みに対応するため、順次読み取りと書き込み操作です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージブローカーの最大スループットは</font><i><font style="vertical-align: inherit;">、これらの最初の制限の達成</font></i><font style="vertical-align: inherit;">によって決まり</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブローカーのセットアップは、ディスクの操作方法に大きく依存します。</font><font style="vertical-align: inherit;">これは、たとえばブローカーの構成方法の要素だけでなく、プロデューサーがブローカーと対話する方法にも依存します。</font><font style="vertical-align: inherit;">パフォーマンスに関連するすべてのものと同様に、ブローカーを代表的なワークロード（つまり、実際のメッセージに可能な限り近い）およびPROMで使用される実際のストレージ構成でテストする必要があります。</font><font style="vertical-align: inherit;">これは、システムが実際にどのように動作するかを理解するために行われます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JMS API</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ActiveMQがクライアントと通信する方法の詳細に入る前に、まずJMS APIを学ぶ必要があります。 APIは、クライアントコードにより使用されるプログラミングインターフェイスのセットを定義：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のConnectionFactory</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これは、ブローカとの接続を確立するために使用されるトップレベルのインタフェースです。一般的なメッセージングアプリケーションでは、このインターフェイスのインスタンスは1つだけです。 ActiveMQでは、これはActiveMQConnectionFactoryです。最上位では、この設計はメッセージブローカーの場所を、メッセージブローカーとの対話方法の低レベルの詳細とともに通知します。名前が示すように、ConnectionFactoryは、Connectionオブジェクトが作成されるメカニズムです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接続</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、TCP接続にほぼ似た長命のオブジェクトです。作成後、通常は、閉じられるまで、アプリケーションのライフサイクル全体を通じて存在します。接続はスレッドセーフで、複数のスレッドを同時に処理できます。接続オブジェクトを使用すると、Sessionオブジェクトを作成できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セッション</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ブローカーと対話するときのストリームハンドルです。セッションオブジェクトはスレッドセーフではありません。つまり、複数のスレッドが同時にアクセスすることはできません。セッションは、トランザクションモードの場合にプログラマがメッセージをコミットおよびロールバックできる主要なトランザクション記述子です。このオブジェクトを使用して、Message、MessageConsumer、およびMessageProducerオブジェクトを作成し、TopicおよびQueueオブジェクトへのポインタ（記述子）も取得します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MessageProducer</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このインターフェイスを使用すると、受信者にメッセージを送信できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MessageConsumer</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このインターフェースを使用すると、開発者はメッセージを受信できます。 2つのメッセージ取得メカニズムがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MessageListenerを登録します。</font><font style="vertical-align: inherit;">これは、実装したメッセージハンドラーインターフェースであり、1つのストリームを使用してブローカーによって発行されたメッセージを順次処理します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">receive（）メソッドを使用したメッセージのポーリング。</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージ</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
データを転送するため、これはおそらく最も重要な構造です。</font><font style="vertical-align: inherit;">JMSのメッセージは、次の2つの側面で構成されています。</font></font><br>
<br>
<ul>
<li> .     .  ,    ,   .  —    ,   JMS     API,   JMSDestination  JMSTimestamp.  —      ,              .  , ,   AccountID  OrderType.</li>
<li> .  Session            ,     ,      TextMessage    BytesMessage   .</li>
</ul><br>
<h3>  :    </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不正確ではあるものの、有用な作業のActiveMQモデルは、脳の2つの半分のモデルです。</font><font style="vertical-align: inherit;">1つはプロデューサーからのメッセージの受信を担当し、もう1つはこれらのメッセージをコンシューマーに送信します。</font><font style="vertical-align: inherit;">関係は実際にはパフォーマンスの最適化のためにより複雑ですが、モデルは基本的な理解には十分です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キューへのメッセージの送信</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージを送信するときに発生する相互作用を見てみましょう。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2-3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ブローカーがメッセージを受信するプロセスの簡略化されたモデルを示しています。それぞれの場合の動作には完全には対応していませんが、基本的な理解には非常に適しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/u9/tc/_p/u9tc_p1dznwdwdajfxt19fsoxva.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2-3。 JMSへのメッセージの送信</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
クライアントアプリケーションでは、スレッドがMessageProducerへのポインタを受け取ります。推定メッセージペイロードを使用してメッセージを作成し、キューをメッセージの最終的な宛先としてMessageProducer.send（ "orders"、メッセージ）を呼び出します。ブローカーが壊れた場合、プログラマーはメッセージを失いたくないので、メッセージヘッダーJMSDeliveryModeはPERSISTENT（デフォルトの動作）に設定されていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階（1）で、送信ストリームはクライアントライブラリを呼び出し、OpenWire形式でメッセージをマーシャリングします。次に、メッセージはブローカーに送信されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブローカーでは、受信ストリームがメッセージを行から削除し、内部オブジェクトに非整列化します。次に、メッセージオブジェクトが永続化アダプターに送信されます。永続化アダプターは、Googleプロトコルバッファー形式を使用してメッセージをマーシャリングし、ストレージに書き込みます（2）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストレージにメッセージを記録した後、持続性アダプターはメッセージが実際に記録されたことの確認を受信する必要があります（3）。これは通常、相互作用全体の中で最も遅い部分です。これについては後で詳しく説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブローカーは、メッセージが保存されたことを確認するとすぐに、確認応答（4）をクライアントに送信します。その後、最初にsend（）操作を呼び出したクライアントスレッドは、その作業を続行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この永続メッセージの保留中の確認は、JMS APIによって提供される保証の基礎です。メッセージを保存する場合は、そもそもメッセージがブローカーによって受け入れられたかどうかも重要になる可能性があります。これが不可能な理由はいくつかあります。たとえば、メモリまたはディスクの制限に達したなどです。ブローカーは失敗の代わりに送信操作を一時停止し、メッセージを処理するのに十分なシステムリソースが利用できるようになるまでプロデューサーに待機させる（プロデューサーフロー制御と呼ばれるプロセス）か、否定的な確認をプロデューサーに送信して例外をスローします。正確な動作は、ブローカーごとにカスタマイズ可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この単純な操作では、かなりの数のI / O対話が行われます。プロデューサーとブローカー間の2つのネットワーク操作、1つの保存操作と確認ステップです。保存操作は、ディスクへの単純な書き込みでも、ストレージサーバーへの別のネットワーク移行でもかまいません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはメッセージブローカーに関する重要な質問を提起します。それらの作業はI / O操作の非常に集中的なストリームに関連付けられており、使用されるインフラストラクチャ、特にディスクに非常に敏感です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の相互作用の確認ステップ（3）を詳しく見てみましょう。</font><font style="vertical-align: inherit;">永続性アダプタがファイルベースの場合、メッセージの保存にはファイルシステムへの書き込みが含まれます。</font><font style="vertical-align: inherit;">もしそうなら、なぜ書き込み操作が完了したことを確認する必要があるのですか？</font><font style="vertical-align: inherit;">録音を完了するという行為は、本当に録音が行われたことを意味しますか？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あんまり。</font><font style="vertical-align: inherit;">よくあることですが、何かを深く研究すればするほど、複雑になります。</font><font style="vertical-align: inherit;">この特定のケースでは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシング</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が原因</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュ、どこにでもキャッシュ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブローカーなどのオペレーティングシステムプロセスがデータをディスクに書き込むと、ファイルシステムと対話します。ファイルシステムは、使用されるストレージメディアとの相互作用の詳細を抽象化するプロセスであり、OPEN、CLOSE、READ、WRITEなどのファイル操作用のAPIを提供します。これらの機能の1つは</font><font style="vertical-align: inherit;">、オペレーティングシステムによって書き込まれたデータを1つのアプローチでディスクに保存できるブロックにバッファリングすることにより</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、書き込み操作の数</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><i><font style="vertical-align: inherit;">最小限に抑える</font></i><font style="vertical-align: inherit;">ことです。ディスクと相互作用するように見えるファイルシステム書き込み操作は、実際にはこの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッファキャッシュ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に書き込まれます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、USBドライブを安全にイジェクトすると、コンピューターが不平を言うのはそのためです。コピーしたファイルは実際には書き込まれていない可能性があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データがバッファキャッシュを超えるとすぐに、次のレベルのキャッシングに移ります。今回はハードウェアレベルで</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あるディスクコントローラーキャッシュ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。これらはRAIDベースのシステムにとって特に重要であり、オペレーティングシステムレベルでのキャッシングと同じ機能を実行します。ドライブ自体に必要な対話の数を最小限に抑えます。これらのキャッシュは2つのカテゴリに分類されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライトスルー書き込み</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
は、受信するとすぐにディスクに転送されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返事を書く</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスクへの記録は、バッファがいっぱいになって特定のしきい値に達したときにのみ実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのキャッシュに格納されているデータは、通常、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">揮発性（揮発性）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であるため、停電時に簡単に失われる可能</font><i><font style="vertical-align: inherit;">性があり</font></i><font style="vertical-align: inherit;">ます。より高価なカードには、システム全体が電力を回復できるまでキャッシュ電力をサポートする冗長バッテリーパック（BBU）があり、その後データがディスクに書き込まれます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後のキャッシュレベルはディスク自体にあります。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディスクキャッシュ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハードドライブ（標準のハードドライブとソリッドステートドライブの両方）にあり、ライトスルーまたはライトバックのいずれかです。ほとんどの商用ドライブはライトバックキャッシュを使用しており、揮発性であるため、停電が発生するとデータが失われる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージブローカーに戻り、確認手順を実行して、データが実際にディスクに到達したことを確認する必要があります。残念ながら、これらのハードウェアバッファーとのやり取りはファイルシステムに依存しているため、ActiveMQのようなプロセスで実行できることは、すべてのシステムバッファーを使用中のデバイスと同期させたいという信号をファイルシステムに送信することだけです。これを行うために、ブローカーはjava.io.FileDescriptor.sync（）メソッドを呼び出します。これにより、POSIX fsync（）操作が開始されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この同期動作は、永続的としてマークされたすべてのメッセージが実際にディスクに保存され、トランザクション内の各メッセージまたは関連メッセージのセットが受信された後に実行されるようにするJMSの要件です。</font><font style="vertical-align: inherit;">したがって、ディスクがsync（）を実行できる速度は、ブローカーのパフォーマンスにとって重要です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部紛争</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのキューに1つのログを使用すると、さらに複雑になります。常に、複数のプロデューサーが同時にメッセージを送信する場合があります。ブローカーには、着信ソケットからこれらのメッセージを受信するいくつかのストリームがあります。各スレッドはメッセージをログに保存する必要があります。複数のスレッドが同時に同じファイルに書き込むことができないため、レコードは互いに競合するため、相互排除メカニズムを使用してレコードをキューに入れる必要があります。これを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドの競合</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼び</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のメッセージを処理する前に、各メッセージを完全に記録して同期する必要があります。この制限は、ブローカー内のすべてのキューに同時に影響します。したがって、メッセージの受信速度は、ディスクへの書き込みにかかる時間と、他のストリームが記録を完了するまでの待機時間です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ActiveMQには書き込みバッファーが含まれています。書き込みバッファーでは、受信ストリームがメッセージを書き込み、前の記録の完了を待ちます。メッセージが使用可能になると、バッファは1つのアクションで書き込まれます。完了すると、スレッドに通知されます。したがって、ブローカーはストレージ帯域幅の使用を最大化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッドの競合の影響を最小限に抑えるために、mKahaDBアダプターを使用してキューセットに独自のログを割り当てることができます。</font><font style="vertical-align: inherit;">スレッドはいつでも別のジャーナルに書き込む可能性が高く、1つのログファイルへの排他的アクセスのためにスレッドが互いに競合する必要がないため、このアプローチは書き込み待ち時間を削減します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取引</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのキューに単一のジャーナルを使用する利点は、ブローカーの作成者の観点から見ると、トランザクションを実装する方がはるかに簡単なことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のメッセージがプロデューサーから複数のキューに送信される例を見てみましょう。トランザクションを使用することは、送信されるメッセージのセット全体を1つのアトミック操作と見なす必要があることを意味します。この対話では、ActiveMQクライアントライブラリは、送信速度を大幅に向上させるいくつかの最適化を行うことができます。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">図2-4に</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
示す操作で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、プロデューサーは3つのメッセージを送信し、すべて異なるキューに入れます。</font><font style="vertical-align: inherit;">ブローカーとの通常の対話の代わりに、各メッセージが確認されると、クライアントは3つのメッセージすべてを非同期に、つまり応答を待たずに送信します。</font><font style="vertical-align: inherit;">これらのメッセージは、ブローカーのメモリーに保管されます。</font><font style="vertical-align: inherit;">操作が完了するとすぐに、プロデューサーはセッションにコミットを行う必要があることを通知します。これにより、ブローカーは1つの同期操作で1つの大きなレコードを実行します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/i0/gl/tu/i0gltuz_gqybny3uyjrtpiot5bg.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2-4。</font><font style="vertical-align: inherit;">トランザクションでのメッセージの送信</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このタイプの操作では、ActiveMQは2つの最適化を使用して速度を向上させます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロデューサーによる次のディスパッチが可能になるまでの待ち時間をなくす</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの小さなディスク操作を1つの大きなディスク操作に組み合わせる-これにより、ディスクバスの帯域幅全体を使用できるようになります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを各キューが独自のログに格納されている状況と比較すると、ブローカーはすべてのレコード間のトランザクションの調整などを提供する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キューからメッセージを差し引く</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージの読み取りプロセスは、コンシューマーがメッセージを受信するメッセージを処理するようにMessageListenerを設定するか、MessageConsumer.receive（）メソッドを呼び出すことによってメッセージを受け入れる意思を表明したときに始まります（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2-5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/eh/p7/-2/ehp7-2hesg0xjd1h4ynnqr46gqo.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2-5。 JMSを介したメッセージの読み取り</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ActiveMQがコンシューマーを認識すると、ActiveMQはストレージからディストリビューションメモリ（1）にページごとにメッセージを読み取ります（ページ）。次に、これらのメッセージは会計士（2）にリダイレクト（ディスパッチ）されます。多くの場合、ネットワークの相互作用の量を減らすためにいくつかの部分に分けられます。ブローカーは、どのメッセージがどのコンシューマーにリダイレクトされたかを追跡します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンシューマによって受信されたメッセージは、アプリケーションによってすぐには処理されませんが、次のようなメモリ領域に配置されます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プリフェッチバッファ（プリフェッチバッファ）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このバッファーの目的は、メッセージフローを合理化して、ブローカーがメッセージを送信できるようになったらスーパーバイザーに発行し、コンシューマーは一度に1つずつ順番に受信できるようにすることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プリフェッチバッファーに入った後のある時点で、メッセージはアプリケーションロジック（X）によって読み取られ、校正の確認がブローカーに送信されます（3）。メッセージ処理と確認の間の時間のタイミングは、確認</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モード</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれるJMSセッションパラメータを使用して設定され</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。これについては、後で説明します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブローカーがメッセージの配信確認を受け入れるとすぐに、メモリとメッセージストアから削除されます（4）。実際には確認レコードがログに書き込まれ、インデックスのインデックスが増加するため、「削除」という用語は誤解を招く可能性があります。メッセージを含むログファイルの実際の削除は、この情報に基づいてバックグラウンドスレッドのガベージコレクターによって実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の動作は、理解を容易にするための簡略化です。</font><font style="vertical-align: inherit;">実際、ActiveMQはディスクからページデータを読み取るだけでなく、ブローカーの受信部分とリダイレクト部分の間でカーソルメカニズムを使用して、ブローカーのリポジトリとのやり取りを可能な限り最小限に抑えます。</font><font style="vertical-align: inherit;">上記のように、ページネーションはこのメカニズムで使用されるモードの1つです。</font><font style="vertical-align: inherit;">カーソルは、ブローカーのリポジトリとの同期を維持する必要があるアプリケーションレベルのキャッシュと見なすことができます。</font><font style="vertical-align: inherit;">使用されるコヒーレンシプロトコルは、ActiveMQディスパッチメカニズムを次の章で説明するKafkaメカニズムよりもはるかに複雑にする重要な部分です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">確認モードとトランザクションモード</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
校正と確認の間の順序を決定するさまざまな確認モードは、クライアントに実装する必要のあるロジックに大きな影響を与えます。それらは次のとおりです</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。AUTO_ACKNOWLEDGE</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これは、AUTOという単語が含まれている可能性があるため、最も一般的に使用されるモードです。このモードでは、クライアントライブラリが強制的にメッセージを確認すると同時に、メッセージがreceive（）呼び出しによって読み取られます。つまり、メッセージによって開始されたビジネスロジックが例外をスローした場合、ブローカーでメッセージがすでに削除されているため、メッセージは失われます。メッセージがリスナーを介して読み取られる場合、メッセージは、リスナーが作業を正常に完了した後にのみ確認されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CLIENT_ACKNOWLEDGE</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確認は、コンシューマコードが明示的にMessage.acknowledge（）メソッドを呼び出した場合にのみ送信されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DUPS_OK_ACKNOWLEDGE</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ネットワークトラフィックの量を減らすために、確認を同時に送信する前に、コンシューマで確認がバッファリングされます。ただし、クライアントシステムがシャットダウンした場合、確認は失われ、メッセージは再送信され、2回目に処理されます。したがって、コードではメッセージが重複する可能性を考慮する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確認モードは、トランザクション読み取りツールによって補完されます。</font><font style="vertical-align: inherit;">セッションを作成すると、トランザクションとしてマークできます。</font><font style="vertical-align: inherit;">つまり、プログラマーは明示的にSession.commit（）またはSession.rollback（）を呼び出す必要があります。</font><font style="vertical-align: inherit;">コンシューマー側では、トランザクションにより、コードが単一のアトミック操作として実行できる対話の範囲が拡大します。</font><font style="vertical-align: inherit;">たとえば、複数のメッセージをまとめて読み取って処理したり、1つのキューからメッセージを読み取って、同じSessionオブジェクトを使用して別のキューに送信したりできます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発送といくつかの消費者</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまで、単一のコンシューマーとメッセージを読み取る動作について説明してきました。次に、このモデルが複数の消費者にどのように適用されるかを見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のコンシューマーがキューをサブスクライブする場合、ブローカーのデフォルトの動作は、プリフェッチバッファーに空きがある消費者にラウンドロビンメッセージを送信することです。メッセージは、キューに到着した順序で送信されます-これは、提供される唯一のFIFO保証です（先入れ先出し、先入れ先出し）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
消費者が突然切断すると、彼に送信されたがまだ確認されていないすべてのメッセージが、別の利用可能な顧客に再送信されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは重要な問題を提起します。コンシューマートランザクションが使用されている場合でも、メッセージが数回処理されないという保証はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンシューマ内の次の処理ロジックを検討してください。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージはキューから差し引かれます。</font><font style="vertical-align: inherit;">トランザクションが開始されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージの内容でWebサービスが呼び出されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トランザクションがコミットされます。</font><font style="vertical-align: inherit;">確認がブローカーに送信されます。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントがステップ2と3の間に完了した場合、メッセージの校正は、Webサービスを呼び出すことによって他のシステムにすでに影響を与えています。 Webサービスの呼び出しはHTTPリクエストであるため、トランザクションではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この動作はすべてのキューシステムに当てはまります。トランザクションシステムであっても、メッセージを処理するときに副作用がないことを保証することはできません。メッセージ処理を詳細に検討した結果、自信を持って次のように言うことができ</font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a></i><i><font style="vertical-align: inherit;">。</font></i><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">メッセージの配信は1回だけ</font></a></i></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">というようなものはありません</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
キューは、</font><i><font style="vertical-align: inherit;">少なくとも1回</font></i><font style="vertical-align: inherit;">の配信</font><i><font style="vertical-align: inherit;">を</font></i><font style="vertical-align: inherit;">保証します</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードの機密部分は、繰り返しメッセージを受信する可能性を常に考慮する必要があります。</font><font style="vertical-align: inherit;">メッセージングクライアントがべき等読み取りを使用して、既に表示されているメッセージを追跡し、重複を回避する方法については、後で説明します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージの並べ替え</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[A、B、C、D]の順序で到着するメッセージのセット、および2つのコンシューマーC1とC2の場合、メッセージの正規分布は次のようになります</font><font style="vertical-align: inherit;">
。 C1がC2より遅い場合、メッセージの初期セットは[B、D、A、C]として処理できます。</font><font style="vertical-align: inherit;">
この動作は、メッセージが順番に処理されることを期待し、これに基づいて独自のメッセージングアプリケーションを開発する初心者を驚かせる可能性があります。同じ送信者から送信されたメッセージを相互に順番に処理する必要があるという要件は、</font><i><font style="vertical-align: inherit;">因果的順序</font></i><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">も呼ばれ</font><font style="vertical-align: inherit;">、非常に一般的です。</font></font><br>
<br>
<code>C1: [A, C]<br>
C2: [B, D]</code><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例として、オンラインベッティングから取得した次のユースケースを取り上げます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーアカウントが構成されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お金は口座に入金されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アカウントからお金を引き出す賭けが行われます。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、メッセージが送信された順序で処理されるため、アカウントの一般的なステータスが考慮されることは理にかなっています。</font><font style="vertical-align: inherit;">システムが資金を持たない口座からお金を取り除こうとすると、奇妙なことが起こる可能性があります。</font><font style="vertical-align: inherit;">もちろん、これを回避する方法はあります。</font><i><font style="vertical-align: inherit;">排他的顧客</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
モデルに</font><font style="vertical-align: inherit;">は、すべてのメッセージをキューから1人の顧客に送信することが含まれます。</font><font style="vertical-align: inherit;">このアプローチを使用すると、アプリケーションまたはスレッドの複数のインスタンスをキューに接続するときに、特別な受信者パラメーターを使用して署名されます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><code>my.queue?consumer.exclusive=true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。独占消費者を接続すると、彼はすべてのメッセージを受信します。 2番目のコンシューマが接続されると、最初のコンシューマが切断されるまでメッセージを受信しません。この2番目のコンシューマーは実際にはホットリザーブですが、最初のコンシューマーは、メッセージがジャーナルに記録された順序で（因果的な順序で）正確に受信するようになります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチの欠点は、メッセージ処理は一貫していますが、すべてのメッセージを単一のコンパレータで処理する必要があるため、パフォーマンスのボトルネックになることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この使用例をよりインテリジェントに理解するには、問題を再考する必要があります。すべてのメッセージを順番に処理する必要がありますか？上記の入札を処理する場合、１つの口座に関連するメッセージのみを順番に処理する必要がある。 ActiveMQは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JMSメッセージグループ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれるこの状況に対処するメカニズムを提供し</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージグループは、プロデューサーがビジネスキーに従って順次処理されるグループにメッセージを配布できるようにする一種のパーティション分割メカニズムです。このビジネスキーは、というメッセージプロパティに設定されます</font></font><code>JMSXGroupID</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ベットを処理する場合の自然なキーはアカウント識別子です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
送信のしくみを説明するために、次の順序で到着する一連のメッセージについて考えてみます。</font></font><br>
<br>
<pre><code class="plaintext hljs">[(A, Group1), (B, Group1), (C, Group2), (D, Group3), (E, Group2)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージがActiveMQのディスパッチメカニズムによって処理され、</font></font><code>JMSXGroupID</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それが以前には存在しなかった</font><font style="vertical-align: inherit;">ことが</font><font style="vertical-align: inherit;">わかった場合、このキーは循環的に会計士に割り当てられます。</font><font style="vertical-align: inherit;">今後、このキーを持つすべてのメッセージがこの会計士に送信されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、グループは2つのコンシューマーC1とC2の間で次のように割り当てられます。</font></font><br>
<br>
<pre><code class="plaintext hljs">C1: [Group1, Group3] <font></font>
C2: [Group2]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージは次のようにリダイレクトされて処理されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">C2: [B, D]<font></font>
C2: [(C, Group2), (E, Group2)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンシューマーが故障した場合、彼に割り当てられたすべてのグループが残りのコンシューマー間で再配布され、未確認のメッセージは再びリダイレクトされます。</font><font style="vertical-align: inherit;">したがって、関連するすべてのメッセージが順番に処理されることを保証できますが、同じコンシューマーによって処理されるとは主張できません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高可用性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ActiveMQは、共有ストレージに基づくマスタースレーブにより高可用性を提供します。このスキームでは、2つ以上のブローカー（通常は2つ）が別々のサーバーに構成され、それらのメッセージは外部の場所にあるメッセージストアに格納されます。メッセージストアは、ブローカの複数のインスタンスで同時に使用することはできません。そのため、その（ストアハウス）二次機能は、どのブローカが排他的アクセスを取得するかを決定するブロッキングメカニズムとして機能します（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2-6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bn/yn/d5/bnynd5kctkhlomy5nb7-gmckrws.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2-6。ブローカーAがリード、ブローカーBがスレーブとしてスタンバイ</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リポジトリに接続するには、最初のブローカー（ブローカーA）がリーダーの役割を引き受け、メッセージトラフィック用にポートを開きます。 2番目のブローカー（ブローカーB）がリポジトリーに接続すると、ロックを取得しようとしますが、成功しないため、ロックを再度取得する前に、しばらく停止します。これはドリブンコントロールと呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、クライアントは2つのブローカーのアドレスを交互に使用して、トランスポートコネクタと呼ばれる受信ポートに接続しようとします。メインブローカーが利用可能になるとすぐに、クライアントはそのポートに接続し、メッセージを送信および読み取ることができます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リーダーとして機能しているブローカーAがプロセス障害のために失敗すると（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2-7</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、次のイベントが発生します。</font></font><br>
<br>
<ol>
<li>      ,    .</li>
<li>   .      .</li>
<li> B,    ,    , ,        ,   .</li>
<li>    B    .</li>
</ol><br>
<img src="https://habrastorage.org/webt/ks/wi/yd/kswiydyc5bffutft06ck-1sm4zq.png"><br>
<i>Figure 2-7.  A  ,    .  B     </i><br>
<blockquote>           ,      JMS/NMS/CMS.        ,         ,      (highly available).</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このアプローチの主な欠点は、1つの論理ブローカーの作業を簡略化するために、複数の物理サーバーが必要になることです。この場合、ブローカーの2つのサーバーの1つはアイドル状態であり、動作を開始する前にパートナーの切断を待機しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチには、共有ネットワークファイルシステムであろうとデータベースであろうと、ブローカーのリポジトリが使用する必要があるという複雑さが加わります。これにより、機器やブローカー設定の管理に追加のコストがかかります。このシナリオでは、データベースなど、インフラストラクチャの他の部分で使用されている既存の高可用性リポジトリを再利用したくなりますが、これは誤りです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスクはブローカーの全体的なパフォーマンスの主要な制限事項であることを覚えておくことは重要です。</font><font style="vertical-align: inherit;">ディスク自体がメッセージブローカー以外のプロセスで同時に使用されている場合、このプロセスとディスクの相互作用により、ブローカーからの記録が遅くなるため、メッセージがシステムを通過する速度が遅くなります。</font><font style="vertical-align: inherit;">このような速度低下は診断が困難であり、それらを回避する唯一の方法は、2つのプロセスを異なるストレージボリュームに分離することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブローカーの安定した運用を確保するには、専用の専用ストレージが必要です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">垂直および水平スケーリング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトのある時点で、メッセージブローカーのパフォーマンスの制限が発生する場合があります。</font><font style="vertical-align: inherit;">これらの制限は通常、リソース、特に使用されているストレージとのActiveMQの相互作用に関連しています。</font><font style="vertical-align: inherit;">これらの問題は通常、たとえばピーク時に1つのキューがブローカーをオーバーフローした場合など、メッセージの量や受信者間の帯域幅の競合が原因で発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブローカーのインフラストラクチャからより多くのパフォーマンスを得る方法はいくつかあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要がない場合は、永続性を使用しないでください。</font><font style="vertical-align: inherit;">一部の使用シナリオでは、特に1つのシステムが定期的またはオンデマンドでキューを介して別の完全なスナップショット状態を別のシステムに送信するときに、クラッシュ中にメッセージが失われる可能性があります。</font></font></li>
<li>     .              HDD  memory-based .</li>
<li>    .       ,  ,      ,      ,  ,        .</li>
<li>  .             :</li>
</ul><br>
<ol>
<li>     ,      mKahaDB   ,       .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかのブローカー、およびトラフィックの分割は、クライアントアプリケーションによって手動で実行されます。</font><font style="vertical-align: inherit;">ActiveMQはこの目的のためのネイティブ機能を提供していません。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブローカーのパフォーマンスの問題の最も一般的な原因の1つは、単に1つのインスタンスを使いすぎようとすることです。</font><font style="vertical-align: inherit;">原則として、これは、ブローカーの既存の負荷を考慮したり、ボリュームを理解したりせずに、ブローカーが単純に複数のアプリケーションに分割されている状況で発生します。</font><font style="vertical-align: inherit;">時間の経過とともに、1つのブローカーは、適切な動作を停止するまで、ますますロードされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題は、システム設計者が</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2-8の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ようなスキームを提案できるシステム設計フェーズでよく発生し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/86/2g/9m/862g9malnlxd6k8ryettpya_dwu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2-8。</font><font style="vertical-align: inherit;">メッセージングインフラストラクチャの概念図</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
目標は、複数のアプリケーションがActiveMQを介して非同期で相互に通信することです。目標は指定されなくなり、スキームは実際のブローカー構成の基礎を決定します。このアプローチは、ユニバーサルデータパイプラインと呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の概念設計と物理的実装との間の分析の基本的なステップは考慮されていません。特定の構成の構築に進む前に、物理プロジェクトを正当化するために使用される分析を実行する必要があります。このプロセスの最初のステップは、どのシステムが相互に作用するかを決定することです-長方形と矢印の付いたかなり単純な図（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2-9</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v_/wz/cz/v_wzczik2oi-menqrxjenakhs1e.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2-9。システム間のメッセージフローのスケッチ</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
承認後、詳細に移動して次の質問に答えることができます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キューとトピックはいくつ使用されますか？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それぞれに期待されるメッセージ量はどれくらいですか？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各受信者のメッセージの大きさはどれくらいですか？</font><font style="vertical-align: inherit;">大きなメッセージはページングプロセスで問題を引き起こし、過剰なメモリ制限につながり、ブローカーをブロックする可能性があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージフローは1日を通して均一ですか、それともバッチジョブによるスパイクがありますか？</font><font style="vertical-align: inherit;">使用率の低い1つのキューで大きなバーストが発生すると、高性能の宛先のディスクへのタイムリーな記録が妨げられる可能性があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムは同じデータセンターにありますか、それとも異なりますか？</font><font style="vertical-align: inherit;">リモート通信には、ある種のネットワークブローカーが関与します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アイデアは、個別のブローカーによって結合または分割できる個別のメッセージングシナリオを定義することです（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2-10</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような内訳の後、ActiveMQパフォーマンスモジュールを使用して相互に組み合わせて問題を特定することにより、使用シナリオをモデル化できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nj/im/ry/njimryyhatcjfwhprygsdrrzqwc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2-10。</font><font style="vertical-align: inherit;">個々のブローカーの識別</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
適切な数の論理ブローカーを決定したら、ブローカーのアクセス性の高い構成とネットワークを使用して、それらを物理レベルで実装する方法を決定できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この章では、ActiveMQがメッセージを受信して​​配信するメカニズムについて説明しました。関連するメッセージとトランザクションのスティッキロードバランシングなど、このアーキテクチャでサポートされる機能について説明しました。同時に、通信プロトコルや雑誌など、すべてのメッセージングシステムに共通する一連の概念を導入しました。また、ディスクへの書き込みに伴う問題と、ブローカーがパケット書き込みなどの手法を使用してパフォーマンスを向上させる方法についても詳しく調べました。最後に、ActiveMQを高可用性にする方法と、個々のブローカーの機能を超えてActiveMQを拡張する方法を検討しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の章では、Apache Kafkaと、そのアーキテクチャーがクライアントとブローカー間の関係を再定義して、通常のメッセージブローカーよりも何倍も大きい帯域幅を備えた信じられないほど堅牢なメッセージパイプラインを提供する方法について説明します。</font><font style="vertical-align: inherit;">この目標を達成するために使用する機能について説明し、この機能を提供するアプリケーションのアーキテクチャについて簡単に検討します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のパート：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージブローカーについて </font><font style="vertical-align: inherit;">ActiveMQとKafkaを介してメッセージングのメカニズムを学ぶ。</font><font style="vertical-align: inherit;">第3章カフカ</font></font></a><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳者：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tele.gg/middle_java</font></font></a></b></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja471258/index.html">データストレージ/ローディングシステム</a></li>
<li><a href="../ja471260/index.html">Android上のKali Linux NetHunterパート2：ワイヤレスネットワークへの攻撃</a></li>
<li><a href="../ja471262/index.html">ホリバー。ルネットの歴史。パート5.トロール：学ぶ、必死のプリンター、Copper</a></li>
<li><a href="../ja471264/index.html">Mailchimpの代替を選択する：切り替える理由と選択する製品</a></li>
<li><a href="../ja471266/index.html">未来はここにあるか、ブラウザにエンコードされています</a></li>
<li><a href="../ja471270/index.html">Google PageSpeed Insightsからのサイトの読み込み速度に関するデータの受信を自動化する[テンプレート]</a></li>
<li><a href="../ja471272/index.html">C ++での強い型付けの利点：実地経験</a></li>
<li><a href="../ja471278/index.html">テンプレートによるロシア語のテキスト生成</a></li>
<li><a href="../ja471282/index.html">Fast.aiを使用してX線で肺炎を探す</a></li>
<li><a href="../ja471288/index.html">OnAirゲームのキャラクターの顔を作成する</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>