<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèø ü§üüèΩ „äôÔ∏è Wir implementieren Python-Code-Konvertierungen üîÉ üë®‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® üßëüèø‚Äçü§ù‚Äçüßëüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr. 
 
 Heute bieten wir Ihnen eine √úbersetzung eines Artikels an, der ein Thema behandelt, das nicht am meisten diskutiert wird: Kompilierung...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Wir implementieren Python-Code-Konvertierungen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/493424/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heute bieten wir Ihnen eine √úbersetzung eines Artikels an, der ein Thema behandelt, das nicht am meisten diskutiert wird: Kompilierung von Code in Python, n√§mlich: Arbeiten mit abstraktem Syntaxbaum (AST) und Bytecode. W√§hrend Python eine interpretierte Sprache ist, sind solche Funktionen aus Optimierungssicht √§u√üerst wichtig. Wir werden heute dar√ºber sprechen.</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haben Sie sich jemals gefragt, wie genau der Compiler Ihren Code so optimiert, dass er schneller funktioniert? </font><font style="vertical-align: inherit;">M√∂chten Sie wissen, was ein abstrakter Syntaxbaum (AST) ist und wof√ºr er verwendet werden kann? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem √úbersichtsartikel wird beschrieben, wie Python-Code in die Baumform (AST) konvertiert wird. </font><font style="vertical-align: inherit;">Nachdem Sie den AST Ihres Programms erstellt haben, k√∂nnen Sie nach M√∂glichkeiten suchen, Ihren Code zu optimieren und zu transformieren. </font><font style="vertical-align: inherit;">Beachten Sie jedoch, dass die Optimierung von Python-Programmen auf nicht triviale Weise </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√§u√üerst schwierig ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmcode als Baum</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie kann ein Computer sicherstellen, dass Ausdr√ºcke aus Ihrem Code in der richtigen Reihenfolge ausgewertet werden? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dazu erstellt er zun√§chst Ihren Programmcode in eine Baumstruktur namens AST. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie mit einer interpretierten Programmiersprache (wie Python) arbeiten, wird allgemein angenommen, dass der Interpreter Ihren Code durchl√§uft und alles, was ihm begegnet, direkt vor Ort ausf√ºhrt, ohne Python-Code in irgendeiner Weise in Maschinencode umzuwandeln. In der Praxis verursacht dieses Ausf√ºhrungsschema jedoch viele Probleme, die es sehr unpraktisch machen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen Sie zum Beispiel ein so einfaches Problem wie die Priorit√§t der Bediener. In einem Ansichtsausdruck </font></font><code>3 + 4 * x </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird das Teil zuerst berechnet</font></font><code>4 * x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und nur dann kann 3 zum Ergebnis der Multiplikation addiert werden. Vielleicht haben Sie die Priorit√§t von Operatoren in Mathematikklassen gelernt, indem Sie diese B√§ume unter dem Ausdruck gezeichnet haben: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xw/lr/sp/xwlrspwopyld8gohdzt4jxgwauu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python verwendet die Standardregeln der mathematischen Notation (zuerst Multiplikation, dann Addition). Um nichts mit der Priorit√§t der Operatoren zu verwechseln, wird in Python zun√§chst ein solcher Baum wie im vorherigen Bild erstellt. Die allgemeine Operation ist Addition (an der Wurzel des Baums), und w√§hrend die linke Seite dieser Summe eine regul√§re Zahl ist, haben wir rechts das Produkt. Die resultierende Datenstruktur sieht folgenderma√üen aus:</font></font><br>
<br>
<pre><code class="python hljs">BinOp(<font></font>
  left  = Num(<span class="hljs-number">3</span>),<font></font>
  op    = Add(),<font></font>
  right = BinOp(<font></font>
            left  = Num(<span class="hljs-number">4</span>),<font></font>
            op    = Mult(),<font></font>
            right = Name(<span class="hljs-string">'x'</span>)<font></font>
          )<font></font>
)<font></font>
</code></pre><br>
<code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bedeutet Bin√§roperation (Bin√§roperation) und gibt an, dass bei Operationen wie Addition und Multiplikation zwei Operanden vorhanden sind. Nat√ºrlich erhalten Sie keine Addition, wenn der richtige Teil des Ausdrucks nicht den richtigen Wert hat. Daher m√ºssen Sie zuerst multiplizieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Theorie der Compiler und Programmiersprachen wird ein solcher Baum als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstract Syntax Tree</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder kurz </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AST bezeichnet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Der AST im obigen Beispiel enth√§lt zwei Knoten </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, zwei Knoten </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und einen Knoten </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Python gibt es eine nette Funktion - die M√∂glichkeit, AST f√ºr ein bestimmtes Python-Programm direkt anzuzeigen und anzuzeigen. Sie m√ºssen lediglich ein Standardmodul importieren</font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parsen des Programms und anschlie√üendes Anzeigen des Ergebnisses auf dem Bildschirm (Parsen ist √ºbrigens das Konvertieren des Programmquellcodes in den AST-Baum).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
my_tree = ast.parse(<span class="hljs-string">"3 + 4*x"</span>)<font></font>
print(ast.dump(my_tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie werden jedoch feststellen, dass der von Python generierte AST zus√§tzliche Knoten und Felder enth√§lt und in einer Zeile angezeigt wird, was ihn auf den ersten Blick komplizierter erscheinen l√§sst als er tats√§chlich ist. </font></font><br>
<br>
<pre><code class="python hljs">Module(body=[Expr(value=BinOp(left=Num(n=<span class="hljs-number">3</span>), op=Add(), right=BinOp(left=Num(n=<span class="hljs-number">4</span>), op=Mult(), right=Name(id=<span class="hljs-string">'x'</span>, ctx=Load()))))])
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teilen wir es wie beim letzten Mal in separate Knoten auf - und √∂ffnen Sie den bereits oben befindlichen AST als Teil des gesamten Baums erneut: </font></font><br>
<br>
<pre><code class="python hljs">Module(body = [<font></font>
    Expr(<font></font>
        value = BinOp(<font></font>
            left  = Num(n=<span class="hljs-number">3</span>),<font></font>
            op    = Add(),<font></font>
            right = BinOp(<font></font>
                left  = Num(n=<span class="hljs-number">4</span>),<font></font>
                op    = Mult(),<font></font>
                right = Name(id=<span class="hljs-string">'x'</span>, ctx=Load())<font></font>
            )<font></font>
        )<font></font>
    )<font></font>
])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Offensichtlich "denkt" Python, dass die Zeile, die wir zum Parsen angegeben haben, ein ganzes Modul ist. Der Hauptteil des Moduls ist eine Liste aller darin enthaltenen Anweisungen. Die einzige Anweisung in unserem Beispiel ist ein Ausdruck, </font></font><code>Expr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dessen Bedeutung genau der oben diskutierten entspricht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinweis: Der Knoten </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verf√ºgt √ºber ein zus√§tzliches Feld </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(abgek√ºrzt als ‚ÄûKontext‚Äú), das einen Wert hat </font></font><code>Load()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Python sagt also, dass wir den in der Variablen gespeicherten Wert verwenden </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und den Namen nicht (neu) definieren oder l√∂schen </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Versuchen Sie nun, etwas wie </font></font><code>del x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder sich </font><font style="vertical-align: inherit;">selbst zu analysieren </font></font><code>x = 123</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und Sie werden sehen, wie sich das Feld </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Knoten </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>Del()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bzw. </font><font style="vertical-align: inherit;">√§ndert </font></font><code>Store()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úbrigens: wenn Sie das Modul installieren</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">astunparse</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann kann die AST-Ausgabe auf dem Bildschirm viel sch√∂ner gestaltet und der AST sogar wieder in Live-Python-Code konvertiert werden.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Kompilierungsprozess: der Rest</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Sammeln von AST-Programmen ist es grunds√§tzlich m√∂glich, das gesamte Programm zu vervollst√§ndigen, indem das AST durchlaufen und die Vorg√§nge in der angegebenen Reihenfolge ausgef√ºhrt werden. Dieser Ansatz weist jedoch mindestens zwei Nachteile auf. Erstens kann AST eine relativ gro√üe Menge an Speicher belegen, insbesondere wenn es redundante Informationen enth√§lt. Zweitens kann die AST-Durchquerung l√§nger als n√∂tig dauern. Kurz gesagt: Es kann getan werden, aber es ist ineffizient. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Compiler verarbeitet den AST nicht direkt, sondern bereitet den Bytecode vor, der dann auf der virtuellen Python-Maschine ausgef√ºhrt wird. Obwohl die Er√∂rterung der Details dieses Prozesses den Rahmen dieses Artikels sprengt, besteht das Grundprinzip darin, dass der Compiler den AST in die umgekehrte polnische Notation (RPN) √ºbersetzt. Anstatt einen Operator zu setzen</font></font><code>+</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwischen dem linken und rechten Operanden setzen wir es nach beiden Operanden. Im </font></font><code>3 + 4*x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obigen </font><font style="vertical-align: inherit;">Beispiel erhalten </font><font style="vertical-align: inherit;">wir die Sequenz </font></font><code>3 4 x * +</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(und diese Notation ist besonders gut, da Sie sofort anhand der Sequenz sehen k√∂nnen: Zuerst m√ºssen Sie die Multiplikation und erst dann die Addition durchf√ºhren). Da jedes der f√ºnf Elemente in dieser Sequenz im Prinzip als einzelnes Byte dargestellt werden kann, wird ein solcher Code als Bytecode bezeichnet. Python verwendet dann die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gestapelte virtuelle Maschine</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um diesen Code effizient auszuf√ºhren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit anderen Worten, das Kompilieren eines in Python geschriebenen Programms erfolgt in zwei Schritten. </font><font style="vertical-align: inherit;">Zun√§chst wird das von der Eingabe empfangene Programm analysiert, und das Ergebnis ist ein abstrakter Syntaxbaum (AST). </font><font style="vertical-align: inherit;">Der Compiler durchl√§uft dann AST und generiert Bytecode. </font><font style="vertical-align: inherit;">Danach f√ºhrt der Python-Interpreter diesen Bytecode aus. </font><font style="vertical-align: inherit;">Nachdem die Optimierung aufgenommen wurde, kann sie entweder auf AST-Ebene oder auf Bytecode-Ebene angewendet werden. </font><font style="vertical-align: inherit;">Beide Optionen haben ihre eigenen Vor- und Nachteile. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie schlie√ülich, dass, obwohl AST in jeder Python-Implementierung √ºblich ist, der Prozess der √úbersetzung von AST in Bytecode unterschiedlich sein kann und in einigen Python-Implementierungen beispielsweise JavaScript anstelle von Bytecode in der Zwischenphase generiert werden kann.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paradigmen aus anderen Programmiersprachen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nicht alle Programmiersprachen verwenden die Infix-Notation wie in Python. </font><font style="vertical-align: inherit;">Zwei bemerkenswerte Beispiele in diesem Fall sind PostScript, bei dem das Programm direkt in umgekehrter polnischer Notation geschrieben ist, und Lisp, bei dem Programme normalerweise in polnischer Notation geschrieben sind. </font><font style="vertical-align: inherit;">Unser Ausdruck des obigen Beispiels in Lisp w√ºrde also die folgende Form annehmen : </font></font><code>(+ 3 (* 4 x))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knotenkonvertierung innerhalb von AST</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie konvertiere ich mit einem AST-Programm einzelne Teile dieses Baums? Mit den praktischen integrierten Funktionen von Python. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir uns AST ansehen und beispielsweise feststellen, dass sowohl Felder </font></font><code>left</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als auch </font></font><code>right</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knoten </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zahlen (Knoten </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) sind, k√∂nnen wir die entsprechenden Berechnungen im Voraus durchf√ºhren und sie dann durch einen </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normalen Knoten </font><font style="vertical-align: inherit;">ersetzen </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nat√ºrlich m√ºssen Sie sehr vorsichtig handeln, um das Verhalten des Programms bei solchen Transformationen nicht zu √§ndern. Zum Beispiel in </font></font><code>len([a(), b(), c(), d()])</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ist es klar , </font><font style="vertical-align: inherit;">dass das Ergebnis 4., aber wir k√∂nnen alle den Ausdruck der Nummer 4 , </font><font style="vertical-align: inherit;">weil vier Funktionen nicht ersetzen </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">noch richtig aufgerufen haben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen Sie erneut mit einer einfachen Optimierung. Wenn im Quellcode eines Programms ein Name vorkommt </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ersetzen Sie ihn durch den Wert 3.14159265. Das Python-Modul </font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stellt bereits die daf√ºr erforderlichen Datenstrukturen bereit: Eine Konverterklasse </font></font><code>NodeTransformer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die alle ASTs durchl√§uft und f√ºr jeden Knoten pr√ºft, ob er ersetzt werden kann. Standardm√§√üig gibt die Transformationsmethode einfach den Quellknoten f√ºr jeden Knoten zur√ºck, sodass wir denselben AST erhalten, von dem aus wir gestartet sind. Aber wir k√∂nnen die Methode f√ºr Knoten leicht √ºberschreiben, zum Beispiel, um zu pr√ºfen </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ob dies der Fall ist, und dann den Knoten </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anstelle des Knotens mit dem urspr√ºnglichen Namen zur√ºckgeben ...</font></font><br>
<br>
<pre><code class="python hljs">	<span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyOptimizer</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:
            <span class="hljs-keyword">return</span> ast.Num(n=<span class="hljs-number">3.14159265</span>)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"y = 2 * pi"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
print(ast.dump(tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit der Konverter / Optimierer unseren Baum durchl√§uft, muss seine Methode aufgerufen werden </font></font><code>visit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die dann einen neuen, ge√§nderten Baum zur√ºckgibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider ist es nicht m√∂glich, den resultierenden AST zu kompilieren und auszuf√ºhren. Der Grund daf√ºr ist ein technisches Detail. Dies ist noch nicht sichtbar, aber (fast) alle Knoten im AST haben auch Felder </font></font><code>lineno</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>col_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie geben die genaue Position eines bestimmten Knotens im Quellcode an. Wenn Sie sie nicht ordnungsgem√§√ü installieren, schw√∂rt der Compiler und weigert sich zu arbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kopieren wir also die entsprechenden Felder vom Quellknoten </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf den neuen Knoten </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie k√∂nnen dann den resultierenden AST kompilieren und ausf√ºhren:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyOptimizer</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)<font></font>
            result.lineno = node.lineno<font></font>
            result.col_offset = node.col_offset<font></font>
            <span class="hljs-keyword">return</span> result
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"print(2 * pi)"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
code = compile(tree, <span class="hljs-string">"&lt;string&gt;"</span>, <span class="hljs-string">"exec"</span>)<font></font>
exec(code)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinweis: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktion der </font><font style="vertical-align: inherit;">Kompilierung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erfordert den Quellcode nicht nur (in dem ein Programm selbst sein kann, oder die AST - </font><font style="vertical-align: inherit;">Linie), aber der Dateiname (wie wir gefragt </font></font><code>"&lt;string&gt;"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), sowie ein von drei: </font></font><code>"exec"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>"eval"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>"single"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Notwendigkeit, die Felder zu kopieren, die die Position des Knotens im Quellcode beschreiben, tritt ziemlich h√§ufig auf. Daher hat das Modul </font><font style="vertical-align: inherit;">nur f√ºr diesen Zweck </font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine spezielle Funktion </font></font><code>copy_location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und wir k√∂nnen schreiben:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)
            <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schlie√ülich k√∂nnen Sie das vorherige Beispiel so erweitern, dass es tats√§chlich eine Optimierung durchf√ºhrt, und zwar auf dem Knoten </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Gem√§√ü der Transformationsregel m√ºssen wir zuerst den linken und dann den rechten Knoten als Teil von BinOp transformieren / optimieren. </font><font style="vertical-align: inherit;">Wenn sich als Ergebnis herausstellt, dass sowohl der linke als auch der rechte Knoten Zahlen sind, k√∂nnen die Berechnungen direkt vor Ort durchgef√ºhrt werden und das Original durch das </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">numerische Ergebnis der Operation </font><font style="vertical-align: inherit;">ersetzen </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVisitor</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_BinOp</span>(<span class="hljs-params">self, node: ast.BinOp</span>):</span><font></font>
        node.left = self.visit(node.left)<font></font>
        node.right = self.visit(node.right)<font></font>
        <span class="hljs-keyword">if</span> isinstance(node.left, ast.Num) <span class="hljs-keyword">and</span> isinstance(node.right, ast.Num):
            <span class="hljs-keyword">if</span> isinstance(node.op, ast.Add):<font></font>
                result = ast.Num(n = node.left.n + node.right.n)<font></font>
                <span class="hljs-keyword">return</span> ast.copy_location(result, node)
            <span class="hljs-keyword">elif</span> isinstance(node.op, ast.Mult):<font></font>
                result = ast.Num(n = node.left.n * node.right.n)<font></font>
                <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)
            <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"y = 2 * pi + 1"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
print(ast.dump(tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úbrigens optimiert der CPython-Compiler bereits Knoten </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie hier gezeigt. </font><font style="vertical-align: inherit;">Der entsprechende Code ist in C geschrieben und in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python / ast_opt.c angegeben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Bitte beachten Sie: Das CPython-Optimierungsprogramm ist universeller und funktioniert nicht nur mit Zahlen, wie im Beispiel, sondern auch mit verschiedenen Arten von konstanten Werten.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberpr√ºfen von Knoten in AST</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie kann sichergestellt werden, dass die von uns vorgenommenen Transformationen korrekt waren? Zuerst m√ºssen Sie AST vollst√§ndig umgehen und das gesamte Programm √ºberpr√ºfen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der oben vorgestellte Optimierer bleibt ein schwerwiegender Fehler. Was passiert, wenn Sie irgendwo im Programm neu definieren </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Stellen Sie sich etwas so Einfaches und Verst√§ndliches vor wie </font></font><code>pi = 4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Unser Optimierer ersetzt einfach pi auf der linken Seite des Ausdrucks durch den numerischen Wert 3.14159265, und Python weigert sich dann zu kompilieren, da es einem Literalwert nichts zuweisen kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielleicht ist dies genau das Verhalten, das Sie gesucht haben, wodurch pi zu einer echten Konstante wird, die w√§hrend der Kompilierung ersetzt wird und niemals neu zugewiesen werden kann, dh keinen anderen Wert erhalten kann. Dies verst√∂√üt jedoch definitiv gegen die Semantik von Python.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was tun, wenn wir uns an die Semantik von Python halten, aber pi wo immer m√∂glich ersetzen m√∂chten? In diesem Fall m√ºssen Sie zuerst das gesamte Programm durchgehen und pr√ºfen, ob der Wert f√ºr irgendwo zugewiesen ist </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Bis wir es komplizieren: Wir werden nicht auf das Ersetzen von pi zur√ºckgreifen, wenn mindestens einem Punkt im Programm ein Wert zugewiesen ist </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt verwenden wir den Besucherknoten, √§hnlich dem oben beschriebenen Konverterknoten. Im Gegensatz zum Konverter soll der Besucher keine Knoten √§ndern, er geht einfach durch den AST und untersucht die Knoten (besucht sie). Dementsprechend geben Besuchsmethoden nichts zur√ºck. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Fall √ºberpr√ºfen wir , </font><font style="vertical-align: inherit;">ob der Knoten bezieht sich </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und tut etwas anderes als den Wert geladen</font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Denken Sie an das Kontextfeld </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVisitor</span>(<span class="hljs-params">ast.NodeVisitor</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>
        self.modify_pi = <span class="hljs-literal">False</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_FunctionDef</span>(<span class="hljs-params">self, node: ast.FunctionDef</span>):</span>
        <span class="hljs-keyword">if</span> node.name == <span class="hljs-string">'pi'</span>:<font></font>
            self.modify_pi = <span class="hljs-literal">True</span><font></font>
        self.generic_visit(node)<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> isinstance(node.ctx, ast.Load):<font></font>
            self.modify_pi = <span class="hljs-literal">True</span><font></font>
 <font></font>
program = <span class="hljs-string">"""
def pi():
    return 3.1415
print(2 * pi())
"""</span><font></font>
tree = ast.parse(program)<font></font>
my_visitor = MyVisitor()<font></font>
my_visitor.visit(tree)<font></font>
print(<span class="hljs-string">"Pi modified:"</span>, my_visitor.modify_pi)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Methode </font></font><code>generic_visit(node)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird vom Besucher f√ºr jeden Knoten aufgerufen, f√ºr den wir keine spezielle Besuchsmethode bereitstellen. </font><font style="vertical-align: inherit;">Mit anderen Worten: Es gibt keine solche Methode </font></font><code>visit_FunctionDef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Klasse </font></font><code>NodeVisitor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die wir mit aufrufen k√∂nnten </font></font><code>super()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In Bezug auf Funktionsdefinitionen m√ºssen wir einen generischen Besucher anrufen, um sicherzustellen, dass auch der gesamte Funktionsk√∂rper korrekt verarbeitet wird. </font><font style="vertical-align: inherit;">Andernfalls k√∂nnten wir die Anweisung in der Funktion ausblenden </font></font><code>global pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und den Wert global √§ndern </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sodass unser Optimierer nichts bemerkt.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lokale Werte in Python</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere Methode, mit der wir feststellen k√∂nnen, ob der Programmierer pi ge√§ndert hat, erwies sich als ziemlich unh√∂flich. </font><font style="vertical-align: inherit;">Der Python-Compiler verh√§lt sich jedoch sehr √§hnlich, wenn er bestimmt, welche Namen im Bereich einer Funktion lokalen Variablen entsprechen. </font><font style="vertical-align: inherit;">Wenn sich eine Variable irgendwo im Funktionsumfang √§ndert (und beispielsweise mit der globalen Anweisung nicht explizit globalisiert wird), wird diese Variable im gesamten Funktionsumfang als lokal betrachtet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das folgende Beispiel wird ohne die vierte Zeile einwandfrei ausgef√ºhrt. </font><font style="vertical-align: inherit;">Obwohl </font></font><code>x = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die vierte Zeile nie ausgef√ºhrt wird, wird sie dennoch als Zuweisung an betrachtet</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und deshalb wird x eine lokale Variable auf der Skala der gesamten Funktion und sogar in Zeile 3. Deshalb wird Python schw√∂ren, dass die Variable x in der dritten Zeile noch keine Rolle spielt.</font></font><br>
<br>
<pre><code class="python hljs">x = <span class="hljs-number">1</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_x</span>():</span><font></font>
    print(x)<font></font>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>: x = <span class="hljs-number">0</span>
print_x()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie genau </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wissen m√∂chten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wie Python hier funktioniert, </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">lesen Sie Python / symtable.c</font></a><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Python wird wie in den meisten Programmiersprachen ein bestimmtes Programm nicht direkt aus dem Quellcode ausgef√ºhrt. </font><font style="vertical-align: inherit;">Tats√§chlich erfolgt die √úbersetzung des Quellcodes in zwei Schritten: Zuerst wird ein abstrakter Syntaxbaum (AST) daraus erstellt und dann Bytecode f√ºr die gestapelte virtuelle Maschine. </font><font style="vertical-align: inherit;">Python bietet auch eine Reihe sehr n√ºtzlicher Funktionen zum Analysieren und sogar Transformieren des AST eines bestimmten Python-Programms, wonach der modifizierte AST kompiliert und ausgef√ºhrt werden kann. </font><font style="vertical-align: inherit;">So k√∂nnen wir problemlos unsere eigenen Optimierungen implementieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nat√ºrlich habe ich hier einfach viele Details weggelassen. </font><font style="vertical-align: inherit;">Es ist nicht trivial, sicherzustellen, dass Ihre Optimierung in allen m√∂glichen F√§llen und Umst√§nden korrekt funktioniert. </font><font style="vertical-align: inherit;">Der Zweck dieses Artikels besteht jedoch nicht darin, Sie √ºber die Optimierung zu informieren, die f√ºr die Produktion bereit ist, sondern eine grundlegende Vorstellung davon zu geben, wie Python Ihren Programmcode analysiert, damit Sie lernen, wie Sie ihn richtig konvertieren und dann optimieren.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de493408/index.html">DJI Mavic Mini Copter fiel wie eine Brechstange</a></li>
<li><a href="../de493412/index.html">Spiele mit Wifi auf ESP32</a></li>
<li><a href="../de493416/index.html">IDA Pro und Reverse Engineering-Techniken</a></li>
<li><a href="../de493418/index.html">Warum maschinelles Lernen ‚Äûsynthetische‚Äú Daten verwendet</a></li>
<li><a href="../de493420/index.html">Mein Weg, Sch√ºler der Mittelstufe in Python einzuf√ºhren</a></li>
<li><a href="../de493426/index.html">Organisation von Code in Microservices und mein Ansatz zur Verwendung von hexagonaler Architektur und DDD</a></li>
<li><a href="../de493428/index.html">"Wir werden keine Verschw√∂rungstheorien hervorbringen." Sprechen Sie √ºber ML-Konferenzen mit Menschen aus Wissenschafts- und IT-Unternehmen</a></li>
<li><a href="../de493430/index.html">Netzarchitektur f√ºr Webanwendungen</a></li>
<li><a href="../de493432/index.html">Warum nicht eine Karriere in einem kleinen Nicht-IT-Unternehmen beginnen?</a></li>
<li><a href="../de493436/index.html">Programm zum √Ñndern von Zugriffsrechten und zum Registrieren von Datei- / Verzeichnisnamen auf Bash</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>