<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏿 🤟🏽 ㊙️ Wir implementieren Python-Code-Konvertierungen 🔃 👨‍❤️‍💋‍👨 🧑🏿‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr. 
 
 Heute bieten wir Ihnen eine Übersetzung eines Artikels an, der ein Thema behandelt, das nicht am meisten diskutiert wird: Kompilierung...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Wir implementieren Python-Code-Konvertierungen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/493424/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heute bieten wir Ihnen eine Übersetzung eines Artikels an, der ein Thema behandelt, das nicht am meisten diskutiert wird: Kompilierung von Code in Python, nämlich: Arbeiten mit abstraktem Syntaxbaum (AST) und Bytecode. Während Python eine interpretierte Sprache ist, sind solche Funktionen aus Optimierungssicht äußerst wichtig. Wir werden heute darüber sprechen.</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haben Sie sich jemals gefragt, wie genau der Compiler Ihren Code so optimiert, dass er schneller funktioniert? </font><font style="vertical-align: inherit;">Möchten Sie wissen, was ein abstrakter Syntaxbaum (AST) ist und wofür er verwendet werden kann? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Übersichtsartikel wird beschrieben, wie Python-Code in die Baumform (AST) konvertiert wird. </font><font style="vertical-align: inherit;">Nachdem Sie den AST Ihres Programms erstellt haben, können Sie nach Möglichkeiten suchen, Ihren Code zu optimieren und zu transformieren. </font><font style="vertical-align: inherit;">Beachten Sie jedoch, dass die Optimierung von Python-Programmen auf nicht triviale Weise </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">äußerst schwierig ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmcode als Baum</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie kann ein Computer sicherstellen, dass Ausdrücke aus Ihrem Code in der richtigen Reihenfolge ausgewertet werden? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dazu erstellt er zunächst Ihren Programmcode in eine Baumstruktur namens AST. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie mit einer interpretierten Programmiersprache (wie Python) arbeiten, wird allgemein angenommen, dass der Interpreter Ihren Code durchläuft und alles, was ihm begegnet, direkt vor Ort ausführt, ohne Python-Code in irgendeiner Weise in Maschinencode umzuwandeln. In der Praxis verursacht dieses Ausführungsschema jedoch viele Probleme, die es sehr unpraktisch machen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen Sie zum Beispiel ein so einfaches Problem wie die Priorität der Bediener. In einem Ansichtsausdruck </font></font><code>3 + 4 * x </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird das Teil zuerst berechnet</font></font><code>4 * x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und nur dann kann 3 zum Ergebnis der Multiplikation addiert werden. Vielleicht haben Sie die Priorität von Operatoren in Mathematikklassen gelernt, indem Sie diese Bäume unter dem Ausdruck gezeichnet haben: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xw/lr/sp/xwlrspwopyld8gohdzt4jxgwauu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python verwendet die Standardregeln der mathematischen Notation (zuerst Multiplikation, dann Addition). Um nichts mit der Priorität der Operatoren zu verwechseln, wird in Python zunächst ein solcher Baum wie im vorherigen Bild erstellt. Die allgemeine Operation ist Addition (an der Wurzel des Baums), und während die linke Seite dieser Summe eine reguläre Zahl ist, haben wir rechts das Produkt. Die resultierende Datenstruktur sieht folgendermaßen aus:</font></font><br>
<br>
<pre><code class="python hljs">BinOp(<font></font>
  left  = Num(<span class="hljs-number">3</span>),<font></font>
  op    = Add(),<font></font>
  right = BinOp(<font></font>
            left  = Num(<span class="hljs-number">4</span>),<font></font>
            op    = Mult(),<font></font>
            right = Name(<span class="hljs-string">'x'</span>)<font></font>
          )<font></font>
)<font></font>
</code></pre><br>
<code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bedeutet Binäroperation (Binäroperation) und gibt an, dass bei Operationen wie Addition und Multiplikation zwei Operanden vorhanden sind. Natürlich erhalten Sie keine Addition, wenn der richtige Teil des Ausdrucks nicht den richtigen Wert hat. Daher müssen Sie zuerst multiplizieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Theorie der Compiler und Programmiersprachen wird ein solcher Baum als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstract Syntax Tree</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder kurz </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AST bezeichnet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Der AST im obigen Beispiel enthält zwei Knoten </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, zwei Knoten </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und einen Knoten </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Python gibt es eine nette Funktion - die Möglichkeit, AST für ein bestimmtes Python-Programm direkt anzuzeigen und anzuzeigen. Sie müssen lediglich ein Standardmodul importieren</font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parsen des Programms und anschließendes Anzeigen des Ergebnisses auf dem Bildschirm (Parsen ist übrigens das Konvertieren des Programmquellcodes in den AST-Baum).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
my_tree = ast.parse(<span class="hljs-string">"3 + 4*x"</span>)<font></font>
print(ast.dump(my_tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie werden jedoch feststellen, dass der von Python generierte AST zusätzliche Knoten und Felder enthält und in einer Zeile angezeigt wird, was ihn auf den ersten Blick komplizierter erscheinen lässt als er tatsächlich ist. </font></font><br>
<br>
<pre><code class="python hljs">Module(body=[Expr(value=BinOp(left=Num(n=<span class="hljs-number">3</span>), op=Add(), right=BinOp(left=Num(n=<span class="hljs-number">4</span>), op=Mult(), right=Name(id=<span class="hljs-string">'x'</span>, ctx=Load()))))])
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teilen wir es wie beim letzten Mal in separate Knoten auf - und öffnen Sie den bereits oben befindlichen AST als Teil des gesamten Baums erneut: </font></font><br>
<br>
<pre><code class="python hljs">Module(body = [<font></font>
    Expr(<font></font>
        value = BinOp(<font></font>
            left  = Num(n=<span class="hljs-number">3</span>),<font></font>
            op    = Add(),<font></font>
            right = BinOp(<font></font>
                left  = Num(n=<span class="hljs-number">4</span>),<font></font>
                op    = Mult(),<font></font>
                right = Name(id=<span class="hljs-string">'x'</span>, ctx=Load())<font></font>
            )<font></font>
        )<font></font>
    )<font></font>
])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Offensichtlich "denkt" Python, dass die Zeile, die wir zum Parsen angegeben haben, ein ganzes Modul ist. Der Hauptteil des Moduls ist eine Liste aller darin enthaltenen Anweisungen. Die einzige Anweisung in unserem Beispiel ist ein Ausdruck, </font></font><code>Expr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dessen Bedeutung genau der oben diskutierten entspricht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinweis: Der Knoten </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verfügt über ein zusätzliches Feld </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(abgekürzt als „Kontext“), das einen Wert hat </font></font><code>Load()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Python sagt also, dass wir den in der Variablen gespeicherten Wert verwenden </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und den Namen nicht (neu) definieren oder löschen </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Versuchen Sie nun, etwas wie </font></font><code>del x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder sich </font><font style="vertical-align: inherit;">selbst zu analysieren </font></font><code>x = 123</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und Sie werden sehen, wie sich das Feld </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Knoten </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>Del()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bzw. </font><font style="vertical-align: inherit;">ändert </font></font><code>Store()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Übrigens: wenn Sie das Modul installieren</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">astunparse</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann kann die AST-Ausgabe auf dem Bildschirm viel schöner gestaltet und der AST sogar wieder in Live-Python-Code konvertiert werden.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Kompilierungsprozess: der Rest</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Sammeln von AST-Programmen ist es grundsätzlich möglich, das gesamte Programm zu vervollständigen, indem das AST durchlaufen und die Vorgänge in der angegebenen Reihenfolge ausgeführt werden. Dieser Ansatz weist jedoch mindestens zwei Nachteile auf. Erstens kann AST eine relativ große Menge an Speicher belegen, insbesondere wenn es redundante Informationen enthält. Zweitens kann die AST-Durchquerung länger als nötig dauern. Kurz gesagt: Es kann getan werden, aber es ist ineffizient. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Compiler verarbeitet den AST nicht direkt, sondern bereitet den Bytecode vor, der dann auf der virtuellen Python-Maschine ausgeführt wird. Obwohl die Erörterung der Details dieses Prozesses den Rahmen dieses Artikels sprengt, besteht das Grundprinzip darin, dass der Compiler den AST in die umgekehrte polnische Notation (RPN) übersetzt. Anstatt einen Operator zu setzen</font></font><code>+</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwischen dem linken und rechten Operanden setzen wir es nach beiden Operanden. Im </font></font><code>3 + 4*x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obigen </font><font style="vertical-align: inherit;">Beispiel erhalten </font><font style="vertical-align: inherit;">wir die Sequenz </font></font><code>3 4 x * +</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(und diese Notation ist besonders gut, da Sie sofort anhand der Sequenz sehen können: Zuerst müssen Sie die Multiplikation und erst dann die Addition durchführen). Da jedes der fünf Elemente in dieser Sequenz im Prinzip als einzelnes Byte dargestellt werden kann, wird ein solcher Code als Bytecode bezeichnet. Python verwendet dann die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gestapelte virtuelle Maschine</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um diesen Code effizient auszuführen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit anderen Worten, das Kompilieren eines in Python geschriebenen Programms erfolgt in zwei Schritten. </font><font style="vertical-align: inherit;">Zunächst wird das von der Eingabe empfangene Programm analysiert, und das Ergebnis ist ein abstrakter Syntaxbaum (AST). </font><font style="vertical-align: inherit;">Der Compiler durchläuft dann AST und generiert Bytecode. </font><font style="vertical-align: inherit;">Danach führt der Python-Interpreter diesen Bytecode aus. </font><font style="vertical-align: inherit;">Nachdem die Optimierung aufgenommen wurde, kann sie entweder auf AST-Ebene oder auf Bytecode-Ebene angewendet werden. </font><font style="vertical-align: inherit;">Beide Optionen haben ihre eigenen Vor- und Nachteile. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie schließlich, dass, obwohl AST in jeder Python-Implementierung üblich ist, der Prozess der Übersetzung von AST in Bytecode unterschiedlich sein kann und in einigen Python-Implementierungen beispielsweise JavaScript anstelle von Bytecode in der Zwischenphase generiert werden kann.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paradigmen aus anderen Programmiersprachen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nicht alle Programmiersprachen verwenden die Infix-Notation wie in Python. </font><font style="vertical-align: inherit;">Zwei bemerkenswerte Beispiele in diesem Fall sind PostScript, bei dem das Programm direkt in umgekehrter polnischer Notation geschrieben ist, und Lisp, bei dem Programme normalerweise in polnischer Notation geschrieben sind. </font><font style="vertical-align: inherit;">Unser Ausdruck des obigen Beispiels in Lisp würde also die folgende Form annehmen : </font></font><code>(+ 3 (* 4 x))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knotenkonvertierung innerhalb von AST</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie konvertiere ich mit einem AST-Programm einzelne Teile dieses Baums? Mit den praktischen integrierten Funktionen von Python. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir uns AST ansehen und beispielsweise feststellen, dass sowohl Felder </font></font><code>left</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als auch </font></font><code>right</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knoten </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zahlen (Knoten </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) sind, können wir die entsprechenden Berechnungen im Voraus durchführen und sie dann durch einen </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normalen Knoten </font><font style="vertical-align: inherit;">ersetzen </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich müssen Sie sehr vorsichtig handeln, um das Verhalten des Programms bei solchen Transformationen nicht zu ändern. Zum Beispiel in </font></font><code>len([a(), b(), c(), d()])</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ist es klar , </font><font style="vertical-align: inherit;">dass das Ergebnis 4., aber wir können alle den Ausdruck der Nummer 4 , </font><font style="vertical-align: inherit;">weil vier Funktionen nicht ersetzen </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">noch richtig aufgerufen haben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen Sie erneut mit einer einfachen Optimierung. Wenn im Quellcode eines Programms ein Name vorkommt </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ersetzen Sie ihn durch den Wert 3.14159265. Das Python-Modul </font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stellt bereits die dafür erforderlichen Datenstrukturen bereit: Eine Konverterklasse </font></font><code>NodeTransformer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die alle ASTs durchläuft und für jeden Knoten prüft, ob er ersetzt werden kann. Standardmäßig gibt die Transformationsmethode einfach den Quellknoten für jeden Knoten zurück, sodass wir denselben AST erhalten, von dem aus wir gestartet sind. Aber wir können die Methode für Knoten leicht überschreiben, zum Beispiel, um zu prüfen </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ob dies der Fall ist, und dann den Knoten </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anstelle des Knotens mit dem ursprünglichen Namen zurückgeben ...</font></font><br>
<br>
<pre><code class="python hljs">	<span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyOptimizer</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:
            <span class="hljs-keyword">return</span> ast.Num(n=<span class="hljs-number">3.14159265</span>)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"y = 2 * pi"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
print(ast.dump(tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit der Konverter / Optimierer unseren Baum durchläuft, muss seine Methode aufgerufen werden </font></font><code>visit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die dann einen neuen, geänderten Baum zurückgibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider ist es nicht möglich, den resultierenden AST zu kompilieren und auszuführen. Der Grund dafür ist ein technisches Detail. Dies ist noch nicht sichtbar, aber (fast) alle Knoten im AST haben auch Felder </font></font><code>lineno</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>col_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie geben die genaue Position eines bestimmten Knotens im Quellcode an. Wenn Sie sie nicht ordnungsgemäß installieren, schwört der Compiler und weigert sich zu arbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kopieren wir also die entsprechenden Felder vom Quellknoten </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf den neuen Knoten </font></font><code>Num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie können dann den resultierenden AST kompilieren und ausführen:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyOptimizer</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)<font></font>
            result.lineno = node.lineno<font></font>
            result.col_offset = node.col_offset<font></font>
            <span class="hljs-keyword">return</span> result
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"print(2 * pi)"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
code = compile(tree, <span class="hljs-string">"&lt;string&gt;"</span>, <span class="hljs-string">"exec"</span>)<font></font>
exec(code)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinweis: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktion der </font><font style="vertical-align: inherit;">Kompilierung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erfordert den Quellcode nicht nur (in dem ein Programm selbst sein kann, oder die AST - </font><font style="vertical-align: inherit;">Linie), aber der Dateiname (wie wir gefragt </font></font><code>"&lt;string&gt;"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), sowie ein von drei: </font></font><code>"exec"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>"eval"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>"single"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Notwendigkeit, die Felder zu kopieren, die die Position des Knotens im Quellcode beschreiben, tritt ziemlich häufig auf. Daher hat das Modul </font><font style="vertical-align: inherit;">nur für diesen Zweck </font></font><code>ast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine spezielle Funktion </font></font><code>copy_location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und wir können schreiben:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)
            <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließlich können Sie das vorherige Beispiel so erweitern, dass es tatsächlich eine Optimierung durchführt, und zwar auf dem Knoten </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Gemäß der Transformationsregel müssen wir zuerst den linken und dann den rechten Knoten als Teil von BinOp transformieren / optimieren. </font><font style="vertical-align: inherit;">Wenn sich als Ergebnis herausstellt, dass sowohl der linke als auch der rechte Knoten Zahlen sind, können die Berechnungen direkt vor Ort durchgeführt werden und das Original durch das </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">numerische Ergebnis der Operation </font><font style="vertical-align: inherit;">ersetzen </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVisitor</span>(<span class="hljs-params">ast.NodeTransformer</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_BinOp</span>(<span class="hljs-params">self, node: ast.BinOp</span>):</span><font></font>
        node.left = self.visit(node.left)<font></font>
        node.right = self.visit(node.right)<font></font>
        <span class="hljs-keyword">if</span> isinstance(node.left, ast.Num) <span class="hljs-keyword">and</span> isinstance(node.right, ast.Num):
            <span class="hljs-keyword">if</span> isinstance(node.op, ast.Add):<font></font>
                result = ast.Num(n = node.left.n + node.right.n)<font></font>
                <span class="hljs-keyword">return</span> ast.copy_location(result, node)
            <span class="hljs-keyword">elif</span> isinstance(node.op, ast.Mult):<font></font>
                result = ast.Num(n = node.left.n * node.right.n)<font></font>
                <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span>:<font></font>
            result = ast.Num(n=<span class="hljs-number">3.14159265</span>)
            <span class="hljs-keyword">return</span> ast.copy_location(result, node)
        <span class="hljs-keyword">return</span> node<font></font>
 <font></font>
tree = ast.parse(<span class="hljs-string">"y = 2 * pi + 1"</span>)<font></font>
optimizer = MyOptimizer()<font></font>
tree = optimizer.visit(tree)<font></font>
print(ast.dump(tree))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Übrigens optimiert der CPython-Compiler bereits Knoten </font></font><code>BinOp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie hier gezeigt. </font><font style="vertical-align: inherit;">Der entsprechende Code ist in C geschrieben und in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python / ast_opt.c angegeben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Bitte beachten Sie: Das CPython-Optimierungsprogramm ist universeller und funktioniert nicht nur mit Zahlen, wie im Beispiel, sondern auch mit verschiedenen Arten von konstanten Werten.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überprüfen von Knoten in AST</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie kann sichergestellt werden, dass die von uns vorgenommenen Transformationen korrekt waren? Zuerst müssen Sie AST vollständig umgehen und das gesamte Programm überprüfen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der oben vorgestellte Optimierer bleibt ein schwerwiegender Fehler. Was passiert, wenn Sie irgendwo im Programm neu definieren </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Stellen Sie sich etwas so Einfaches und Verständliches vor wie </font></font><code>pi = 4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Unser Optimierer ersetzt einfach pi auf der linken Seite des Ausdrucks durch den numerischen Wert 3.14159265, und Python weigert sich dann zu kompilieren, da es einem Literalwert nichts zuweisen kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielleicht ist dies genau das Verhalten, das Sie gesucht haben, wodurch pi zu einer echten Konstante wird, die während der Kompilierung ersetzt wird und niemals neu zugewiesen werden kann, dh keinen anderen Wert erhalten kann. Dies verstößt jedoch definitiv gegen die Semantik von Python.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was tun, wenn wir uns an die Semantik von Python halten, aber pi wo immer möglich ersetzen möchten? In diesem Fall müssen Sie zuerst das gesamte Programm durchgehen und prüfen, ob der Wert für irgendwo zugewiesen ist </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Bis wir es komplizieren: Wir werden nicht auf das Ersetzen von pi zurückgreifen, wenn mindestens einem Punkt im Programm ein Wert zugewiesen ist </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt verwenden wir den Besucherknoten, ähnlich dem oben beschriebenen Konverterknoten. Im Gegensatz zum Konverter soll der Besucher keine Knoten ändern, er geht einfach durch den AST und untersucht die Knoten (besucht sie). Dementsprechend geben Besuchsmethoden nichts zurück. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Fall überprüfen wir , </font><font style="vertical-align: inherit;">ob der Knoten bezieht sich </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und tut etwas anderes als den Wert geladen</font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Denken Sie an das Kontextfeld </font></font><code>ctx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> ast<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVisitor</span>(<span class="hljs-params">ast.NodeVisitor</span>):</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>
        self.modify_pi = <span class="hljs-literal">False</span><font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_FunctionDef</span>(<span class="hljs-params">self, node: ast.FunctionDef</span>):</span>
        <span class="hljs-keyword">if</span> node.name == <span class="hljs-string">'pi'</span>:<font></font>
            self.modify_pi = <span class="hljs-literal">True</span><font></font>
        self.generic_visit(node)<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visit_Name</span>(<span class="hljs-params">self, node: ast.Name</span>):</span>
        <span class="hljs-keyword">if</span> node.id == <span class="hljs-string">'pi'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> isinstance(node.ctx, ast.Load):<font></font>
            self.modify_pi = <span class="hljs-literal">True</span><font></font>
 <font></font>
program = <span class="hljs-string">"""
def pi():
    return 3.1415
print(2 * pi())
"""</span><font></font>
tree = ast.parse(program)<font></font>
my_visitor = MyVisitor()<font></font>
my_visitor.visit(tree)<font></font>
print(<span class="hljs-string">"Pi modified:"</span>, my_visitor.modify_pi)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Methode </font></font><code>generic_visit(node)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird vom Besucher für jeden Knoten aufgerufen, für den wir keine spezielle Besuchsmethode bereitstellen. </font><font style="vertical-align: inherit;">Mit anderen Worten: Es gibt keine solche Methode </font></font><code>visit_FunctionDef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Klasse </font></font><code>NodeVisitor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die wir mit aufrufen könnten </font></font><code>super()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In Bezug auf Funktionsdefinitionen müssen wir einen generischen Besucher anrufen, um sicherzustellen, dass auch der gesamte Funktionskörper korrekt verarbeitet wird. </font><font style="vertical-align: inherit;">Andernfalls könnten wir die Anweisung in der Funktion ausblenden </font></font><code>global pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und den Wert global ändern </font></font><code>pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sodass unser Optimierer nichts bemerkt.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lokale Werte in Python</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere Methode, mit der wir feststellen können, ob der Programmierer pi geändert hat, erwies sich als ziemlich unhöflich. </font><font style="vertical-align: inherit;">Der Python-Compiler verhält sich jedoch sehr ähnlich, wenn er bestimmt, welche Namen im Bereich einer Funktion lokalen Variablen entsprechen. </font><font style="vertical-align: inherit;">Wenn sich eine Variable irgendwo im Funktionsumfang ändert (und beispielsweise mit der globalen Anweisung nicht explizit globalisiert wird), wird diese Variable im gesamten Funktionsumfang als lokal betrachtet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das folgende Beispiel wird ohne die vierte Zeile einwandfrei ausgeführt. </font><font style="vertical-align: inherit;">Obwohl </font></font><code>x = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die vierte Zeile nie ausgeführt wird, wird sie dennoch als Zuweisung an betrachtet</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und deshalb wird x eine lokale Variable auf der Skala der gesamten Funktion und sogar in Zeile 3. Deshalb wird Python schwören, dass die Variable x in der dritten Zeile noch keine Rolle spielt.</font></font><br>
<br>
<pre><code class="python hljs">x = <span class="hljs-number">1</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_x</span>():</span><font></font>
    print(x)<font></font>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>: x = <span class="hljs-number">0</span>
print_x()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie genau </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wissen möchten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wie Python hier funktioniert, </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">lesen Sie Python / symtable.c</font></a><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Python wird wie in den meisten Programmiersprachen ein bestimmtes Programm nicht direkt aus dem Quellcode ausgeführt. </font><font style="vertical-align: inherit;">Tatsächlich erfolgt die Übersetzung des Quellcodes in zwei Schritten: Zuerst wird ein abstrakter Syntaxbaum (AST) daraus erstellt und dann Bytecode für die gestapelte virtuelle Maschine. </font><font style="vertical-align: inherit;">Python bietet auch eine Reihe sehr nützlicher Funktionen zum Analysieren und sogar Transformieren des AST eines bestimmten Python-Programms, wonach der modifizierte AST kompiliert und ausgeführt werden kann. </font><font style="vertical-align: inherit;">So können wir problemlos unsere eigenen Optimierungen implementieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich habe ich hier einfach viele Details weggelassen. </font><font style="vertical-align: inherit;">Es ist nicht trivial, sicherzustellen, dass Ihre Optimierung in allen möglichen Fällen und Umständen korrekt funktioniert. </font><font style="vertical-align: inherit;">Der Zweck dieses Artikels besteht jedoch nicht darin, Sie über die Optimierung zu informieren, die für die Produktion bereit ist, sondern eine grundlegende Vorstellung davon zu geben, wie Python Ihren Programmcode analysiert, damit Sie lernen, wie Sie ihn richtig konvertieren und dann optimieren.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de493408/index.html">DJI Mavic Mini Copter fiel wie eine Brechstange</a></li>
<li><a href="../de493412/index.html">Spiele mit Wifi auf ESP32</a></li>
<li><a href="../de493416/index.html">IDA Pro und Reverse Engineering-Techniken</a></li>
<li><a href="../de493418/index.html">Warum maschinelles Lernen „synthetische“ Daten verwendet</a></li>
<li><a href="../de493420/index.html">Mein Weg, Schüler der Mittelstufe in Python einzuführen</a></li>
<li><a href="../de493426/index.html">Organisation von Code in Microservices und mein Ansatz zur Verwendung von hexagonaler Architektur und DDD</a></li>
<li><a href="../de493428/index.html">"Wir werden keine Verschwörungstheorien hervorbringen." Sprechen Sie über ML-Konferenzen mit Menschen aus Wissenschafts- und IT-Unternehmen</a></li>
<li><a href="../de493430/index.html">Netzarchitektur für Webanwendungen</a></li>
<li><a href="../de493432/index.html">Warum nicht eine Karriere in einem kleinen Nicht-IT-Unternehmen beginnen?</a></li>
<li><a href="../de493436/index.html">Programm zum Ändern von Zugriffsrechten und zum Registrieren von Datei- / Verzeichnisnamen auf Bash</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>