<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳🏽 🛑 🛡️ 使用波函数折叠算法的提示 ✨ 🍄 🕍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近，我已经对基于过程约束的生成进行了很多实验。特别是使用Wave函数折叠算法（WFC，wave function折叠）。我什至写了自己的开源库和统一资产。
 
 WFC是一种非常灵活的算法，尤其是在我开发的改进中。但是与此同时，我发现很难借助它来创建适用于计算机游戏的实用关卡。主要困难在于WFC没...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>使用波函数折叠算法的提示</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488336/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2f/556/757/f2f556757da50dae74a44909dca1e76d.png" alt="图片"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近，我已经对基于过程约束的生成进行了很多实验。特别是使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wave函数折叠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法</font><font style="vertical-align: inherit;">（WFC，wave function折叠）。我什至写了自己的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开源库</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一资产</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WFC是一种非常灵活的算法，尤其是在我开发的改进中。但是与此同时，我发现很难借助它来创建</font><font style="vertical-align: inherit;">适用于计算机游戏的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实用</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关卡。主要困难在于WFC没有任何全局结构。他所做的只是使输出生成在本地看起来类似于输入，例如，通过查看输出的各个小矩形。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我将告诉您我学到了什么，以及基于限制将其提高到一个新水平的能力。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基础</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您不知道WFC的工作原理，则很难使用它。这是一种</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于约束的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过程生成算法</font><font style="vertical-align: inherit;">，最近受到了极大的关注。实际上，它几乎与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">量子物理学</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">概念</font></a><font style="vertical-align: inherit;">无关</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WFC很容易配置-你只需要给算法为例卡，在这之后产生的新卡，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看起来</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像原来的卡，由于反复使用它的小片段。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它有两种类型-相邻排列或元素覆盖。它可以2D或3D </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">格式</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成，甚至可以在</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">六边形</font></a><font style="vertical-align: inherit;">或</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">不规则</font></a><font style="vertical-align: inherit;">网格上完成</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网格。</font><font style="vertical-align: inherit;">无论您如何使用算法，我的大多数技巧都适用。</font><font style="vertical-align: inherit;">如果您对技术细节感兴趣，</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我建议您玩</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这个演示</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以了解有关算法的知识，并阅读</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此介绍</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font><font style="vertical-align: inherit;">Habré上的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻译</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平铺设计</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WFC算法是基于图块的。</font><font style="vertical-align: inherit;">从这个意义上讲，其质量取决于您转移到其上进行工作的图块。</font><font style="vertical-align: inherit;">我不是艺术家，因此我在绘制漂亮的图块时几乎无济于事（尽管您可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此处看到</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），但是好的图块也需要技术知识。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行进的多维数据集</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行进多维数据集</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一种算法，它根据图块的每个顶点是满还是空来选择要设置的图块。</font><font style="vertical-align: inherit;">这是用于2D的图块列表。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/404/214/092/404214092cf2f31e96b3b6f2a267c622.svg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您构建瓷砖以使黑白角始终匹配，则红线将始终正确连接。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里我们不需要了解整个算法，但是应该注意的是，设计仅在角落具有行为的瓷砖的想法是一种非常强大的技术。</font><font style="vertical-align: inherit;">它可用于许多最好的图块集，因为它可以确保图块始终保持良好的连接。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此技术对于WFC尤其强大。</font><font style="vertical-align: inherit;">确实发生了，因为如果您错过了一些图块，那么WFC没关系。</font><font style="vertical-align: inherit;">他将规避此问题，并且永远不会创建需要缺少图块的配置。</font><font style="vertical-align: inherit;">这对于3D十分方便，因为存在许多潜在的图块，并且仅在非常困难的情况下才需要其中的一些图块。</font><font style="vertical-align: inherit;">请参阅下面的“基础”部分，在该部分中，我将更广泛地使用此技巧。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
知道</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他平铺模式</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也可能会有所帮助</font><font style="vertical-align: inherit;">，但是进行多维数据集是最好的。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">房间</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有时，使用简单的图块集最容易。</font><font style="vertical-align: inherit;">4张瓷砖（其中一张瓷砖是空的）的这种组合很容易生成方形房间。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd0/bbb/376/dd0bbb3765876baac62417e760149058.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e76/245/14b/e7624514b5103da9afa5e4be2fce86c3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过改变每个瓷砖的重量，可以轻松地改变房间的大小。</font><font style="vertical-align: inherit;">添加门砖和走廊砖后，您可以创建人们平面布置图特有的多样性。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基础</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用WFC时，尝试磁贴集会很有趣。</font><font style="vertical-align: inherit;">如果仅放一块瓷砖，WFC就会从剩余空间中挤出最大的空间。</font><font style="vertical-align: inherit;">有时，这会导致截然不同的结果，如Maxim Gumin的图像所示：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/980/7b9/a4f9807b976fa295e85b9ae0d36d3918.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以使用这种行为来刺激WFC生成许多可识别的结构。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一座城堡的示例（受</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@greentecq</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启发</font><font style="vertical-align: inherit;">）：</font></font><br>
<br>
<div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1183359478734958593"></twitter-widget>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在其中，我使用了以下图块集：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0b/852/df1/c0b852df1c18974c8114d48d3b7f3290.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些图块具有重要的属性-底部的所有图块的宽度均不小于顶部的宽度。</font><font style="vertical-align: inherit;">这意味着不可能以不受支持的方式构建这些图块。</font><font style="vertical-align: inherit;">WFC立即对此做出回应，并创建了具有良好基础的建筑物。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分形近似</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过选择适当的图块集来研究刺激某些行为的主题，我发现如果图块集由直的道路和分支组成，但是没有拐角，那么您可以很好地近似于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">递归拆分</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（没有“递归”部分）。</font><font style="vertical-align: inherit;">这对于网格级别来说是相当不错的。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大瓷砖</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以添加WFC来支持比常规图块大几倍的图块。例如，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我的Tessera插件</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支持该功能</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大瓷砖可以多种方式使用。由于它们超出了网格的边界，因此可以使用它们来添加比捕捉网格时通常更平滑和更宽的曲线。它们也适用于大量图块中的元素，或者只是掩盖了基于图块的生成。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是从</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bad North</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏中向</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oscar Stalberg</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">学习的示例</font><font style="vertical-align: inherit;">。奥斯卡（Oscar）展示了他是如何使用大瓷砖来增加平滑弯曲的海岸，大房子和悬崖易变性的。</font></font><br>
<br>
<div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-1" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1131228226901172226"></twitter-widget>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">局限性</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WFC的核心是基于约束的算法。</font><font style="vertical-align: inherit;">这意味着他寻求生成与一组特定标准相对应的级别。</font><font style="vertical-align: inherit;">在纯WFC中，只有一个标准-水平在本地看起来像样本输入。</font><font style="vertical-align: inherit;">下面，我将讨论WFC增强功能以​​添加新类型的限制。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">固定瓷砖</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在WFC中生成关卡之前，很容易修复单个图块。</font><font style="vertical-align: inherit;">后来，它们与生成的级别无缝集成。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f0/df3/619/1f0df3619f947a7a71e72b389bc38e15.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成之前</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93f/2c2/5be/93f2c25be4b716f62fa16b0b67c36a5b.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成后</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
可以多种不同方式使用此技术。</font><font style="vertical-align: inherit;">这里有一些想法：</font></font><br>
<br>
<ul>
<li>      </li>
<li>  - ,   WFC    .</li>
<li>    ,    </li>
<li> /    WFC   </li>
</ul><br>
<br>
<h3> </h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">限制路径</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（路径约束）-这是我对WFC的贡献。这是一项非常强大的技术，但是完整的文章很可能需要单独的文章。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此限制会</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全局</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扫描所有生成的输出，并强制指示在标记的图块之间必须经过路径。换句话说，它告诉瓦片的一个子集形成图的单个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组件</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。由于其全球性，它补充了通常只考虑本地图块的WFC行为。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我发现添加此限制会严重影响生成级别的外观。没有它，WFC经常会生成几个看起来不切实际并且不是人为创造的分隔房间或区域。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/353/c19/b88353c19a3ebc27db979150a3c30af2.png"></div><br>
<i>   </i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a91/928/346/a919283460b31c6c8b901609d9490ede.png"></div><br>
<i>   .       .</i><br>
<br>
<h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
限制路径的另一种情况是绘制路径。默认情况下，路径限制仅确保</font><font style="vertical-align: inherit;">图块之间</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存在</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">路由。它不能保证路径尽可能的简单。因此，在河流和道路的情况下，他经常在可选位置绘制T形接头。诀窍是要么简单地移除所有T型接头的瓷砖，要么给它们一个很轻的重量，以便仅在紧急情况下才选择它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我喜欢使用固定的图块来固定路径的端点。因此，需要路径限制来插入使其余路径连接的图块。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa0/448/f77/aa0448f778179d53dd4b9236fc33aa17.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过固定四角为路径的终点产生的路径，</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
如果你想与路径进行实验，然后我有一个设计了一个小型的JavaScript演示</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多元化</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">替代瓷砖</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
向WFC算法添加平铺选项非常容易。</font><font style="vertical-align: inherit;">只需将图块添加到可能的图块列表中，使其与替换的图块具有相同的连接即可。</font><font style="vertical-align: inherit;">或者也可以在后处理阶段完成，就像通常在其他样式的过程生成中一样。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d7/b6c/43a/3d7b6c43a0be6522b6a2eac5d85dbd69.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两块墙面瓷砖，其中一个带有窗户。</font><font style="vertical-align: inherit;">它们是完全可互换的，并且仅增加设计的可变性。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平铺瓷砖的可变性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您花很多精力来创建拼贴设置设计，您会发现WFC的随机性开始伤害他。</font><font style="vertical-align: inherit;">它使用了整个图块，也就是说，您可以获得混合了熔岩，雪和沙漠的关卡。</font><font style="vertical-align: inherit;">通常，这看起来完全不合逻辑。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以通过一种简单的方法恢复完整性：预先确定</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">级别属于</font><font style="vertical-align: inherit;">哪个</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">生物群落</font></a><font style="vertical-align: inherit;">，然后禁用所有不适合该生物群落的图块。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bad North</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（再次）是一个很好的例子。</font><font style="vertical-align: inherit;">在某些层次上，岩石是完全被禁止的，在另一些层次上，则有很多植被，在第三处遗址中增加了墓地。</font><font style="vertical-align: inherit;">这为每个级别提供了独特的样式，而无需对生成样式进行重大更改。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2f/556/757/f2f556757da50dae74a44909dca1e76d.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在右上角可见的岛屿中，只有约10％具有洞穴元素。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地图中图块的变异性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
混合磁贴甚至可以走得更远。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果使用WFC生成大卡，则它看起来非常统一。</font><font style="vertical-align: inherit;">这是该算法是</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">局部</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约束</font><font style="vertical-align: inherit;">的求解器这一事实的另一个结果</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我在《</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">凯夫的洞穴</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">》游戏中看到了解决此问题的最佳方法</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在开发者的关于代（故事</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），他们说他们的地图划分成不同的区域，然后与用于地图的子集独立参数开始WFC。</font><font style="vertical-align: inherit;">这意味着在地图上可能存在一片废墟区域和一个城市区域，在其中使用了完全不同的模板和图块。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b9/45f/762/1b945f762795751a1e66eaa0712110ab.png"></div><br><font style="vertical-align: inherit;"><em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">游戏开发人员的数学</font></a></em><font style="vertical-align: inherit;"> 
示例</font></font><em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：使用“ Qud of Cad”中的波动函数折叠生成基于图块的地图</font></font></a></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与所有基于约束的生成技术一样，WFC算法的原理是</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谨慎满足您的需求</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">易于自定义并获得漂亮的结果，但是要实现游戏所需的特定细节可能非常困难。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我希望我介绍的技术可以帮助您驯服这个怪物，但最后，最好是基于程序生成的优势来创建游戏设计，而不是试图迫使它为您创建太多游戏。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我建议您扮演</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bad North</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caves of Qud</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">两种游戏都是在真实条件下使用WFC的绝佳示例，并且开发人员已经深思熟虑了在其游戏中算法的最佳使用。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN488322/index.html">手势</a></li>
<li><a href="../zh-CN488324/index.html">控制台鬼。松下M2</a></li>
<li><a href="../zh-CN488326/index.html">爱还是解雇</a></li>
<li><a href="../zh-CN488330/index.html">与乔治·卡林（George Karlin）的英语：我们分析了有关词组学的巧妙表述</a></li>
<li><a href="../zh-CN488332/index.html">零，一，二，弗雷迪会接你</a></li>
<li><a href="../zh-CN488338/index.html">Google实习机会：苏黎世，伦敦和硅谷</a></li>
<li><a href="../zh-CN488340/index.html">职业：后端开发人员</a></li>
<li><a href="../zh-CN488342/index.html">随机森林，主成分方法和超参数优化：解决Python分类问题的示例</a></li>
<li><a href="../zh-CN488346/index.html">在Linux上的Python 3.7虚拟环境中使用SCIP和GLPK安装或工具</a></li>
<li><a href="../zh-CN488348/index.html">网络研讨会“十大敏捷挑战和在一小时内克服挑战的方式”，2月17日，莫斯科时间</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>