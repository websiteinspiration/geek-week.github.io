<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🤝‍👨🏼 🏇🏿 🧕🏽 Unity Editor Adventures: Matriochka sérialisé 👨🏽‍💻 🚾 😙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Brève introduction
 En règle générale, pour accéder au domaine d'une propriété sérialisée qui nous intéresse, la thérapie manuelle nous conseille d'ut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Unity Editor Adventures: Matriochka sérialisé</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502836/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brève introduction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En règle générale, pour accéder au domaine d'une propriété sérialisée qui nous intéresse, la thérapie manuelle nous conseille d'utiliser la méthode FindPropertyRelative (), dans laquelle le nom de la variable est jeté. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour certaines raisons, cette approche n'est pas toujours pratique. Les raisons peuvent être très diverses. Par exemple, le nom d'une variable peut changer, nous avons besoin d'un accès par le nez à une propriété non sérialisée, nous devons avoir accès à des accesseurs de définition ou même à des méthodes d'un objet sérialisé. Nous ne poserons pas les questions «pourquoi en avez-vous besoin du tout» et «pourquoi vous ne pourriez pas vous passer des méthodes traditionnelles». Supposons que nous ayons besoin - et c'est tout.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors, découvrons comment obtenir l'objet avec lequel nous travaillons, ainsi que tous ses objets parents à partir de la propriété sérialisée, et ne pas se laisser prendre sur la route de sérialisation pleine d'embûches. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attention. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cet article suppose que vous savez déjà comment travailler avec UnityEditor, que vous avez écrit au moins une fois des PropertyDrawers personnalisés et que vous comprenez en général comment la propriété sérialisée diffère d'un objet sérialisé.</font></font><br>
<br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chemin de sérialisation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour commencer, mettez tous les points sur O.Dans </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
le cas le plus primitif, nous avons une certaine classe héritière de MonoBehaviour, et elle a un certain champ appartenant à une classe sérialisée, évidemment pas un héritier de la vache unitaire sacrée de A.K.A. </font><font style="vertical-align: inherit;">UnityEngine.Object.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExamplePulsar</span> : <span class="hljs-title">MonoBehaviour</span><font></font>
{<font></font>
...<font></font>
        [<span class="hljs-meta">Space</span>][Header(<span class="hljs-string">"Example Sandbox Inspector Field"</span>)]
        <span class="hljs-keyword">public</span> SandboxField sandboxField;<font></font>
...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le code ci-dessus, SandboxField est une classe avec l'attribut Serializable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour accéder au MonoBehaviour du propriétaire n'est pas un problème:</font></font><br>
<br>
<pre><code class="cs hljs">UnityEngine.Object serializationRoot = property.serializedObject.targetObject;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous le souhaitez, vous pouvez le faire au fur et à mesure, mais maintenant nous n'en avons plus besoin. </font><font style="vertical-align: inherit;">Nous nous intéressons au champ sérialisé lui-même afin de le dessiner avec tout le blackjack comme dans la figure ci-dessous.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/-w/3n/th/-w3nthkn0gmcdeuvpqlw2zctxhy.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons prendre le chemin de sérialisation comme suit:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">string</span> serializationPath = property.propertyPath;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre cas, le chemin de sérialisation se composera de l'un de nos champs et renverra «sandboxField», dont nous ne sommes ni froid ni chaud, car pour le premier niveau d'imbrication nous n'avons besoin de connaître que le nom de la variable (qui, soit dit en passant, nous a été retournée). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veuillez noter qu'il n'y a pas de comportement Mono parent sur le chemin. </font><font style="vertical-align: inherit;">Maintenant, cela n'a plus d'importance, mais cela deviendra important lorsque nous commencerons à démonter une poupée russe qui ressemble à ceci:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nestedClassVariable.exampleSandboxesList.Array.data [0] .evenMoreNested.Array.data [0]</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afin de ne pas se faire prendre plus tard, lorsque les propriétés sont imbriquées, nous procéderons à l'avance comme suit:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">string</span>[] path = property.propertyPath.Split(<span class="hljs-string">'.'</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons maintenant tous les nœuds du chemin de sérialisation. </font><font style="vertical-align: inherit;">Mais dans le cas le plus primitif, nous n'avons besoin que du nœud zéro. </font><font style="vertical-align: inherit;">Prends-le:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">string</span> pathNode = path[<span class="hljs-number">0</span>];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Allumez un peu de réflexion et obtenez le champ d'ici:</font></font><br>
<br>
<pre><code class="cs hljs">Type objectType = serializationRoot.GetType();<font></font>
FieldInfo objectFieldInfo = objectType.GetField(pathNode);<font></font>
<span class="hljs-keyword">object</span> field = objectFieldInfo.GetValue(serializationRoot);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous laissons derrière les coulisses la question de la rapidité de cette aventure. Pour un petit nombre de ces champs et une petite imbrication, les coûts de réflexion seront nettement inférieurs à ceux de tout ce qui se passe sous le capot d'UnityEditor lors du rendu. Si vous voulez des preuves - sur un github, les développeurs Unity ont une chose si intéressante, UnityCsReference, regardez à votre guise, comment le rendu ObjectField est implémenté, par exemple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, ce </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'est pas (ha ha)</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tout. Nous avons le champ, nous sommes heureux, nous pouvons faire tout ce que nous voulons avec lui et même essayer d'écrire notre propre UnityEvent avec tous les boutons et actions importantes qui n'affectent que notre champ, quel que soit l'objet sur lequel il s'accroche.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au moins, alors qu'il se bloque à la racine de cet objet, tout ira bien, mais alors ce n'est plus tellement. </font><font style="vertical-align: inherit;">Sur le chemin de la sérialisation, nous attendons des tableaux et toutes sortes de listes, dont le principal désir est de nous mettre dans des pantoufles, en changeant en temps opportun le nombre d'éléments. </font><font style="vertical-align: inherit;">Mais au diable avec cela, nous creuserions d'abord sous le tableau lui-même.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre objectif est la résistance à de telles poupées</font></font></b>
                        <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/l7/do/h3/l7doh3b9j_da24zsw9rc-7xefjs.png"></div></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous n'avions pas de tableaux dans le chemin de sérialisation, la tâche serait triviale: nous ferions une boucle à travers les nœuds de sérialisation jusqu'à atteindre la fin de la chaîne. </font><font style="vertical-align: inherit;">Quelque chose comme le code suivant:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">object</span> currentObject = serializationRoot;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; directSearchDepth; i++)<font></font>
{<font></font>
       <span class="hljs-keyword">string</span> pathNode = path[i];<font></font>
       Type objectType = currentObject.GetType();<font></font>
       FieldInfo objectFieldInfo = objectType.GetField(pathNode);<font></font>
       <span class="hljs-keyword">object</span> nextObject = objectFieldInfo.GetValue(currentObject);<font></font>
       currentObject = nextObject;<font></font>
}<font></font>
<span class="hljs-keyword">return</span> currentObject;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous attendons deux nouvelles désagréables à la fois. </font><font style="vertical-align: inherit;">Je vais commencer par le second. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'étape de prise de nextObject peut soudainement retourner null au lieu de l'objet attendu. </font><font style="vertical-align: inherit;">Habituellement, cela se produit lorsque nous créons pour la première fois l'objet parent dans l'inspecteur et que le chemin de sérialisation existe déjà, mais le champ correspondant n'existe pas (cela nous apportera encore plus de commodités). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, il serait bien d'ajouter immédiatement la sortie de la méthode avec le retour null:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">object</span> nextObject = objectFieldInfo.GetValue(currentObject);
<span class="hljs-keyword">if</span> (nextObject == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
currentObject = nextObject;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Attends une minute! </font><font style="vertical-align: inherit;">- vous dites. </font><font style="vertical-align: inherit;">"Et que faire alors dans OnGUI si zéro nous était retourné?" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Réponse: rien. </font><font style="vertical-align: inherit;">Rien littéralement. </font><font style="vertical-align: inherit;">Faites simplement un retour et sautez ainsi cette étape de dessin, en attendant que le champ soit créé. </font><font style="vertical-align: inherit;">Il ne se passera rien de terrible de cela.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>(<span class="hljs-params">Rect position, SerializedProperty property, GUIContent label</span>)</span><font></font>
{<font></font>
       SandboxField sandboxField = GetTarget&lt;T&gt;(property);<font></font>
       <span class="hljs-keyword">if</span> (sandboxField == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<font></font>
…<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ici GetTarget () est la fonction correspondante, prenant l'objet sérialisé de la propriété. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit dit en passant, je vous conseillerai de prendre le champ d'intérêt pour nous non pas ici, mais dans GetPropertyHeight. Cela sera nécessaire dans le cas où nous écrivons des champs extensibles pliables avec différentes tailles en fonction du contenu. GetPropertyHeight () est appelée avant OnGUI (), donc si nous y prenons un champ et l'écrivons dans le champ de notre PropertyDrawer, nous n'aurons pas à le reprendre à OnGUI.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veuillez noter qu'une instance du PropertyDrawer personnalisé est créée seule pour dessiner toutes les propriétés sérialisées actuellement visibles, et de nouvelles propriétés sont lancées à son tour de haut en bas. Cela doit être pris en compte afin de ne pas perturber le calcul de la hauteur de la propriété suivante, sinon vous risquez d'obtenir une situation désagréable lorsque vous cliquez sur le dépliant et que le champ que vous attendez est développé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En outre, tous les guirlandes responsables de l'affichage du champ dans l'éditeur et que vous souhaitez sérialiser, vous devez sérialiser du côté de la classe sérialisable, et non par PropertyDrawer, et pour des raisons de précision - joignez des crochets de compilation conditionnels afin que toute cette honte espagnole n'essaye pas d'aller à la génération :</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">Serializable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SandboxField</span><font></font>
{<font></font>
…<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> UNITY_EDITOR</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> editorFoldout;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
…<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autre écueil qui nous attend ici: tous les champs créés via l'éditeur ont voulu cracher sur le constructeur de classe et sur les valeurs par défaut spécifiées dans la classe. </font><font style="vertical-align: inherit;">Si vous faites, par exemple, comme ça (exemple de mon projet, où c'était la valeur des nœuds de la surface de l'eau):</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">SerializeField</span>]<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m_nodesPerUnit = <span class="hljs-number">5</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette valeur sera ignorée de la sérialisation à blanc dès que vous ajouterez un nouvel élément à la liste. </font><font style="vertical-align: inherit;">Appeler le constructeur à l'aide n'est pas moins inutile: tout ce que vous y avez écrit sera ignoré. </font><font style="vertical-align: inherit;">Le nouvel objet est un objectif comme un faucon, toutes ses valeurs sont vraiment les valeurs par défaut, ce n'est tout simplement pas celles que vous voulez voir là-bas, mais toutes sortes de null, false, 0, Color.clear et autres choses obscènes.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Béquille à la viande</font></font></b>
                        <div class="spoiler_text">  .   NonUnitySerializableClass,       .      , DefaultEditorObject(),    . <br>
<br>
  - :<br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NonUnitySerializableClass</span><font></font>
{<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DefaultEditorObject</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-comment">// virtually do nothing</span><font></font>
        }<font></font>
<font></font>
        [<span class="hljs-meta">SerializeField</span>]<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> validated = <span class="hljs-literal">false</span>;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">EditorCreated</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> force = <span class="hljs-literal">false</span></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (validated &amp;&amp; !force) <span class="hljs-keyword">return</span>;<font></font>
            DefaultEditorObject();<font></font>
            validated = <span class="hljs-literal">true</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NonUnitySerializableClass</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            EditorCreated(<span class="hljs-literal">true</span>);<font></font>
        }<font></font>
}</code></pre><br>
        DefaultEditorObject(),    ,   EditorCreated     .<br>
<br>
 :       .<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fg/dh/dr/fgdhdrfczfhhcki7dw6plxzj7vi.png"></div><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Revenons à nos moutons, ou plutôt aux tableaux. </font><font style="vertical-align: inherit;">Un autre problème qui peut survenir à un stade encore plus précoce réside dans cette ligne:</font></font><br>
<br>
<pre><code class="cs hljs">FieldInfo objectFieldInfo = objectType.GetField(pathNode);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le côté droit peut nous renvoyer zéro s'il se heurte à un tableau dans le chemin de sérialisation (et tout objet "IList" sera le tableau "Array"). </font><font style="vertical-align: inherit;">Désagréable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que faire? </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essayez de ne pas tomber dans de telles situations en</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> écrivant un gestionnaire:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pathNode.Length; i++)<font></font>
{<font></font>
        <span class="hljs-keyword">string</span> pathNode = path[i];<font></font>
        Type objectType = currentObject.GetType();<font></font>
        FieldInfo objectFieldInfo = objectType.GetField(pathNode);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (objectFieldInfo == <span class="hljs-literal">null</span>)<font></font>
        {<font></font>
                <span class="hljs-keyword">if</span> (pathNode == <span class="hljs-string">"Array"</span>)<font></font>
                {<font></font>
                        i++;<font></font>
                        <span class="hljs-keyword">string</span> nextNode = path[i];
                        <span class="hljs-keyword">string</span> idxstr = nextNode.Substring(nextNode.IndexOf(<span class="hljs-string">"["</span>) + <span class="hljs-number">1</span>);<font></font>
                        idxstr = idxstr.Replace(<span class="hljs-string">"]"</span>, <span class="hljs-string">""</span>);
                        <span class="hljs-keyword">int</span> arrayNumber = Convert.ToInt32(idxstr);<font></font>
                        IList collection = currentObject <span class="hljs-keyword">as</span> IList;
                        <span class="hljs-keyword">if</span> (collection.Count &lt;= arrayNumber) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
                        currentObject = collection[arrayNumber];<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span><font></font>
                {<font></font>
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(<span class="hljs-string">"   "</span>);<font></font>
                }<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> <span class="hljs-comment">//  ,     </span><font></font>
        {<font></font>
                <span class="hljs-keyword">object</span> nextObject = objectFieldInfo.GetValue(currentObject);
                <span class="hljs-keyword">if</span> (nextObject == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
                currentObject = nextObject;<font></font>
        }<font></font>
}<font></font>
<span class="hljs-keyword">return</span> currentObject;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui, nous pouvons même entrer dans une situation désagréable ici, lorsque le chemin de sérialisation a déjà, par exemple, l'élément data [0] ou data [1] et que le tableau ne l'a pas encore implémenté. </font><font style="vertical-align: inherit;">Par exemple, nous avons créé une liste vide. </font><font style="vertical-align: inherit;">On lui demande N éléments - et sans cette belle ligne:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">if</span> (collection.Count &lt;= arrayNumber) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... nous obtenons un tas d'exceptions dans les ronronnements. </font><font style="vertical-align: inherit;">Et tout ce qui était nécessaire était de sauter l'étape de rendu, après avoir attendu la création des champs qui nous intéressaient. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'ai pas encore rencontré d'autres cas où objectFieldInfo == null, mais le nœud de sérialisation n'est pas désigné comme Array, donc lancer une terrible exception dans une situation aussi hypothétique exceptionnelle est de la casser par la suite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, nous avons une fonction plus ou moins fonctionnelle qui nous permet d'extraire un champ par sa propriété sérialisée. </font><font style="vertical-align: inherit;">À l'avenir, cette fonction peut être modifiée en forçant à extraire tous les objets dans le chemin de sérialisation, ainsi qu'en recherchant le «parent» le plus proche, en incluant ou en excluant les tableaux le long du chemin.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Life hack pour dessiner des propriétés imbriquées</font></font></b>
                        <div class="spoiler_text">      -  ,   Rect position  Rect indentedPosition = EditorGUI.IndentedRect(position).     ,         EditorGUI,      position ,       GUI –    indentedPosition.   EditorGUILayout  OnGUI,       (   ,   ).<br>
<br>
    ,   MonoScript   (     -,   ),     static-,      AssetDatabase,        <i></i>         .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Merci pour l'attention.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr502818/index.html">Y Messenger: Messenger décentralisé sur la blockchain *</a></li>
<li><a href="../fr502826/index.html">Présentation du scanner 3D Creaform MetraSCAN 3D</a></li>
<li><a href="../fr502830/index.html">Hackathon en ligne "New Reality" VirusHack. Comment c'était</a></li>
<li><a href="../fr502832/index.html">Certification ISTQB disponible en ligne: expérience personnelle</a></li>
<li><a href="../fr502834/index.html">Comment devenir ingénieur DevOps en six mois ou plus vite. Partie 5. Déploiement</a></li>
<li><a href="../fr502838/index.html">Quelle est la différence entre les métiers de l'informatique et du numérique: transformation numérique et avis d'experts</a></li>
<li><a href="../fr502840/index.html">Test du scanner 3D Shin 3D EinScan Pro 2X Plus</a></li>
<li><a href="../fr502842/index.html">Comment protéger les données biométriques des utilisateurs contre une utilisation criminelle</a></li>
<li><a href="../fr502844/index.html">[Partie 2/2] Guide de FFmpeg et SDL ou Comment écrire un lecteur vidéo en moins de 1000 lignes</a></li>
<li><a href="../fr502846/index.html">Zuckerberg a lancé Shops. Instagram et Facebook deviennent progressivement des magasins.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>