<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏱️ 🧛🏾 ☮️ アークは、単一リポジトリのバージョン管理システムです。Yandexレポート 🌲 ⛅️ 📥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="バージョン管理システムは、長い間、開発者にとって日常的なツールでした。大規模なモノリポジトリでは、それらの要件は非常に特殊です。このため、企業はFacebookがMercurialやMicrosoftでGitを使用するように既存のソリューションを採用するか、独自のシステムを開発します。Googleの...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>アークは、単一リポジトリのバージョン管理システムです。Yandexレポート</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/482926/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バージョン管理システムは、長い間、開発者にとって日常的なツールでした。</font><font style="vertical-align: inherit;">大規模なモノリポジトリでは、それらの要件は非常に特殊です。</font><font style="vertical-align: inherit;">このため、企業はFacebookがMercurialやMicrosoftでGitを使用するように既存のソリューションを採用するか、独自のシステムを開発します。GoogleのPiperとCitC、YandexのArc VCSです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レポートでは、開発者Vladimir Kikhtenko</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キクト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandexが独自のバージョン管理システムを必要とした理由とその仕組みを説明します。通常の開発者の側から検討してください。ソースコードにアクセスし、開発用のブランチを確保し、変更を共通のコードベースに統合する方法です。私たちは内部を調べます-データの内部表現と、作業コピーを備えた仮想ファイルシステムでのその表示について学習します。仮想ファイルシステムにVCS機能を実装する際の難しさと、データを遅延読み込みする場合の問題について説明します。リポジトリのサーバーインフラストラクチャの信頼性を確保する方法について話しましょう。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、レポートの非公式の記録を見ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-皆さん、こんにちは。私の名前はウラジミールです。あなたは皆、バイクを書かないことについてのスピーチを聞いた。私の報告はバリケードの反対側になります。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、Yandexには多数のコードが含まれる単一リポジトリーがあります。そして、バージョン管理システムを開発しているという結論に達しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/l3/y8/lq/l3y8lqxua4etd-ukds2vvc5kxkg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのようにして私たちはそのような生活に行きましたか？歴史的に、この単一リポジトリはSVNで私たちと一緒に住んでいました。トランクベースの開発を実践しています。例外がほとんどないブランチはありません。すべてのコードは最初にトランクに入り、次に満杯になる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リポジトリの成長に伴い、SVNでサポートされているため、リポジトリを操作する唯一の可能な方法は選択的チェックアウトでした。リポジトリ全体を自分にアップロードすることは完全に不可能ではありませんが、それを使用することは非常に困難です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rw/i0/wa/rwi0wambw-yjb_ahmiwoytmvytk.jpeg"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの問題の規模は何ですか？ここにいくつかの数があります：600万のコミット、ほぼ200万の個別ファイル。リポジトリの全履歴を含む合計サイズは2 TBです。これらの数値が他の典型的なリポジトリと比較して何を意味するかを明確にするために、ここにグラフがあります。 GitHubの中央値は、GitHub上のリポジトリサイズの中央値、1 MBです。 GitHubの90パーセンタイルは、同僚が「母のガールフレンドの息子のリポジトリ」と呼んだものです。そして、他のすべては有名な大きなリポジトリです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sb/dd/ek/sbddeks2vvyhyzwwmwsotp-etne.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の知る限り、世界最大のリポジトリはGoogleのものです。そのサイズの推定値は、2015年の記事から提供されています。ご覧のとおり、スケールは対数です。私たちも非常に大きいことがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このリポジトリ全体をダウンロードしようとすると、さまざまなバージョン管理システムがどのように機能しますか？当然、バージョン管理システムの開発はすぐには開始されませんでした。リポジトリを別のシステムに変換しようとしました。最も深刻な試みはMercurialで行われました。そして、典型的な操作の時間の結果は、まだ私たちには合いません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xu/ww/bz/xuwwbztsv7_qyoptjukm2pu3nay.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レポートの準備中、残念ながらgit-svnはリポジトリ全体を変換できませんでした。少数のコミットの一部を変換したため、履歴に関連する操作の数を見積もることができません。 1つのセグメントでは高速で、600万回のコミットがどのようになるかはあまり明確ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、バージョン管理システムの番号を示します。すぐに作業コピーを取得できます。最初の起動では、ログ操作がわずかに遅くなり、2番目の起動では、すべてが迅速に動作します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後の桁。私たちのバージョン管理システムはすべてのデータを遅延ダウンロードするため、実際に使用したソースのみがディスク上にあります。これは全体をダウンロードするよりもかなり少ないです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ig/8e/oh/ig8eohthc8a_mfyfyiaxjslhrka.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どうやってこれを達成したのですか？主な機能：作成する作業コピーは、ディスク上の実際のファイルではありません。これは仮想ファイルシステムです。 LinuxとMacでは、これはfuseで行われ、WindowsではProjFSで行われます。すべてのデータをレイジーにロードするため、本当に必要なだけのディスク容量が使用され、すべてを事前にロードすることはしません。そして、サーバーに対してあらゆる種類の重い操作を実行します。特に-ログの操作など。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ig/jg/jw/igjgjww9nzy70irbsg-svup6_vi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
概して、バージョン管理システムのインターフェースはGitを繰り返しているため、一般的なワークフローがどのように見えるかは示しません。 Gitを想像してみてください。すべて同じです：目的のリビジョンを取得するためのチェックアウト、ブランチを作成するためのブランチ、コミットのためのコミット、スタッシュも同じ方法でサポートされています。このアプローチは何をもたらしますか？エントリーしきい値を大幅に削減しました。 Yandex内外のほとんどの開発者がGitを使用できます。新しいことを学ぶ必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方で、Gitの代わりにドロップインするという目標はありません。これについては、後で詳しく説明します。さまざまなgitチームをすべてサポートするのはおかしいようですが、すべてを必要とすることはほとんどありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/u2/fh/ke/u2fhkejztyav2rfuwrcsvmwmzv4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部について、すべてがどのように機能するかについて少しお話します。データモデルから始めましょう。私たちのデータモデルは地理的なものと非常によく似ていますが、いくつかの違いがあります。同様に、内部で作成するすべてのオブジェクトは不変であり、そのコンテンツのハッシュによってアドレス指定され、内部はフラットバッファに格納されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0y/xn/5f/0yxn5fgiyjkgkuatsacat0igx44.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造はどのように見えますか？コミットオブジェクトがあり、各コミットには個別またはいくつかの祖先があります。このようにして、DAG（有向非循環グラフ）ストーリーを構築します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vj/gq/ai/vjgqaiudbezdynjexr6ys2qnh30.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが持っているものとGitにすぐに現れなかったものは世代番号です。単純なアルゴリズムを使用して、ツリーのルートから特定の距離を考慮します。なぜ私たちはこれが必要なのですか？これはすべて、一度修正されるとオブジェクトの構造に組み込まれ、二度と変更されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バージョン管理システムにとって非常に重要な操作は、2つのコミットの共通の最小祖先を見つけることです。基本バージョンでは、いくつかの2つのポイントから始めて、そこに到達したすべてのコミットを1つまたは別の記号でマークすることで、幅を一周するだけで実装できます。これらの記号の両方を持つコミットが見つかるとすぐに、共通の祖先が最も少なくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは単純な実装ではどのように機能しますか？このようなもの：周りを回って、目的のコミットを見つけます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_k/ua/ra/_kuarauekfozlpunbtufesyaxem.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は不要なBです。中に入ることができなかったようですが、見ました。また、例を使用してブランチとトランクの違いが大きいほど、そのような追加のコミットが多くなります。単一リポジトリーの場合、トランクへのコミット率が十分に高い場合、この距離は非常に大きくなる可能性があります。そして、そのような余分なコミットが何万にも及ぶでしょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ls/qe/ko/lsqekoyn9trz8dxsqejf8tfkvdy.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/b2/_i/ld/b2_ild3rkleepwd-w2gwvnoegak.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
世代番号がある場合、クロール時に優先キューを使用できます。クロールは次のようになります。1回-必要なものをすぐに見つけます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xq/dy/hx/xqdyhxj1w29lm5r0j_xdftsmg8y.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、モデル間の違いの一例です。 Gitでは、これは以前サポートされていました。世代番号のタイムスタンプを使用していましたが、これは、コミットの作成時間がコミットグラフと一致している場合にのみ機能します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/l2/nz/ob/l2nzobltj8dcwjfefjrp_dpea68.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、これは私たちのリポジトリ履歴には当てはまりません。別のリポジトリーのマイグレーションの結果としてのコミットがあり、時間が逆戻りし始めます。 Gitではこのことがサポートされていましたが、Gitではコミットオブジェクトをローカルで別のオブジェクトに置き換えることができるため、常に適用できるわけではありません。モデルの耐性はこれに影響を受けます。したがって、記録されない世代番号は、それらに書き込まれているものに適用できない場合があります。これは真実ではありません。そのような問題はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この最適化のもう1つの利点は、完全にローカルであることです。これらの数値を使用するために、コミットグラフ全体を用意する必要はありません。通常はまったくありません。遅延してロードされます。遅延読み込みが少ないほど、私たちはよりよく生きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コミット以外は、モデルはGitに非常に似ています。各コミットはツリーの特定のオブジェクトをポイントします。ツリーはレコードで構成され、各レコードは別のツリーであるため、ディレクトリ階層がここに表示されるか、ブロブまたはファイルになります。さらに、BlobRefなどがあります。ファイルが非常に大きい場合は、ファイルを分割して特別なオブジェクトで表示します。 Gitの場合と同じです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zx/ma/yb/zxmaybpia7hh2rnjgzledt6ikg8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gitで嫌いなことは何ですか？これをコピー情報と呼びます。ファイルがなんらかのコミットでコピーされた場合、Gitはこの情報を保存せず、差分とステータスが表示されたときにヒューリスティックを使用してファイルを回復しようとします。この情報をグラフに保存します。レコードには、別のコミット、このコミットのリポジトリ内のパスへのコピー情報リンクが含まれている場合があります。これにより、このファイルはこのコミットでコピーされたことがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
側面では、このBLOBは一度保存されるため、重複排除はまだあります。ただし、ファイルの内容は変更されなかったため、重複排除はすべて同じであり、ハッシュによって重複排除されていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックエンドはどのように配置されますか？ Gitに分散バージョン管理システムがある場合、バックエンドは必要ありません。これは、GitHubがダウンしているときに特に深刻に感じます。 Gitにはバックエンドが不要であることを明確に理解しています。私たちのクライアントサーバーシステムは、サーバーにすべてのデータを保存し、まだクライアント上にないオブジェクトをダウンロードするためにサーバーの可用性が必要です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tn/ra/uz/tnrauzebvya5hi9zuvdjsorttxe.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandexデータベースに保存するすべてのデータ。これは、トランザクション、必要なレベルの信頼性を提供する非常に優れたデータベースです。必要なものがすべてそろっていて、このことで多くの問題から私たちを救いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このため、バックエンド自体は完全にステートレスであり、状態全体がデータベース内にあり、必要なだけ非常に簡単にスケーリングできるバックエンドです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントとのやり取り、サーバー間でのやり取りについては、gRPCを使用しています。今日、それに関する詳細なレポートがありました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ce/xh/at/cexhatxlfxthnfdofvi1wedwexq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのシステムはどのようにSVNと統合されていますか？ SVNリポジトリは引き続き機能します。さらに、私たちのバージョン管理システムはまだ自給自足ではありません。彼女はこの部分でどのように働いていますか？最初は、SVNリポジトリのステータスを監視し、SVNコミットをバージョン管理システムであるArcコミットに変換するConverterコンポーネントがいくつかあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、作業コピーをマウントしてサーバーにデータを送信するクライアントがあります。開発者が何かをコミットすると、最初にそれがArcサーバーに送信されますが、これらの変更をトランク（メインブランチ）に送信するには、プールリクエストシステムとコードレビューシステムを経由する必要があります。 Arcのブランチを監視する別のサービスが登場し、ブランチが更新された場合、システムのコードレビューにプールリクエストを送信します。次はコードレビューシステムで、このパッチをマージする必要があると判断されたときに、SVNにコミットします。それほど単純ではありません。これは、このコミットが実際にそのようなArcからのそのようなブランチのマージであることを示す一定量のメタデータを追加します。そして、このコミットはコンバーターをすでに認識しており、その中でこのメタデータを見つけて、Arcサーバーにコミットを作成します。これはコミットのサイクルです。したがって、SVNにはトランクがあるため、SVNなしでは生活できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインブランチは常にサーバーと同期していますが、直接コミットすることはできません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gi/a0/-1/gia0-1aqpsq2bt3xsikjhilcr2g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックエンドの信頼性について。もちろん、すべてのYandex開発者がこれを使用することを計画しているので、壊れないことが重要です。これはそのようなインデックス内標準です。私たちのサービスは、あらゆるデータセンターの障害に耐えなければなりません。バージョン管理システムも例外ではありません。ここでは、YDBがこれをサポートしていることで、私たちは大いに助かります。そして、私たちのバックエンドはステートレスであり、異なる部分がわずかに異なる方法でそこで実装されています。 Arcオブジェクトで動作するサーバーはブランチで動作し、ステートレスで複製されます。 SVNから常に変換するコンバーターは、アクティブ-アクティブ方式で複製されます。同時に動作するいくつかのコンバーターがあり、それらは同時に変換し、Arcブランチを更新しようとした瞬間に、競合を解決します。 1つは成功し、もう1つは失敗しました。彼は何かをさらに変換しようとしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プール要求サービスは、マスタースレーブによって複製されます。主なものは動作しています。失敗した場合は、YDBを通じて新しいものが選択されます。アクセシビリティ、信頼性を真剣に保証しているセマフォのような素晴らしいものがあります。セマフォへのアクセスは完全にシリアル化されます。セマフォは、プールリクエストの検出サービスとリーダーの選択の両方に使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントの動作について少し。これは、仮想ファイルシステムが存在するため、バージョン管理システムの最も難しい部分です。実際、すべての操作を自分たちでファイルに実装することを余儀なくされています。いくつかの基本的な操作について説明します。これらの操作を行うと、内部で何が起こるかを指で大まかに説明します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/is/sg/5l/issg5lt5g8ozy9hfmjalxuhhbig.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、書き込み用にファイルを開きました。書き込み用にファイルを開くと、オブジェクトモデルの対応するblobが見つかります。必要に応じて、サーバーから何かをアップロードします。特別なストアにファイルを物理的に作成した場合、このファイルへのすべてのリクエストはそこでプロキシされます。したがって、ローカライズされた変更がコミットされるまで（Gitではステージング解除と呼ばれます）、一時的なストレージに入れられます。このようなファイルをマテリアライズドと呼びます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wi/ig/ar/wiigarboe1byzw6g2dm1tpj3mda.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読み取りのためにファイルを開くと、何も具体化できず、BLOBから直接データを提供するだけです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kt/4w/qg/kt4wqgxgb6p155jfrcsmej5kxek.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが、ファイルをインデックスに追加した瞬間です。この時点で、何かが具体化されているかどうかを確認する必要があります。変更されたファイルはありますか？存在する場合は、そのblobを作成し、インデックスに保存します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-d/qj/lx/-dqjlxli2tamjacrjl2aus-iinu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の操作はアークステータスです。興味深いのは、従来のバージョン管理システムでは、ファイルツリー全体を走査する必要があるため、速度が遅いことが判明しているためです。ファイルを変更するためのすべての要求は、ヒューズドライバーを経由するため、ファイルツリー全体を移動する必要はありません。変更を確認する価値のあるファイルがすぐにわかります。インデックスに何を書き込んだかを確認し、答えを出力します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wa/7f/0e/wa7f0emrhfllexxyj8asf0kplso.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コミットタイム。すべてがはっきりしているようです。インデックスがあります。これらのオブジェクトのblobを既に作成し、この状態に対応するツリーオブジェクトを作成し、新しいコミットオブジェクトを作成し、オブジェクトストレージに書き込みます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/eb/p4/uj/ebp4ujcdu2jg9vk18vnsgg9by9o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、作業コピーを新しいコミットに切り替えます。これはトリッキーな操作であり、checkoutコマンドを使用して明らかに実行できます。ここで、ローカルでのすべての変更がすでに実体化しているように思われるかもしれませんが、新しいコミットで実体化されていないファイルを返さなければならないと想定できます。以上です。その後の操作はすべて、別のツリーとBLOBに送信されるだけです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ne/qa/cu/neqacudmw91qauhiaoonre_49zm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこれが機能しないのでしょうか？最初のバージョンはこれについてでした。問題は、アークリセット--softのようなあらゆる種類のトリッキーな操作にあります。彼らは私たちにツリーを切り替えますが、ファイルを具体化しません。彼らは神聖な場所に存在し続けます。また、追跡されずに無視されたファイルもあり、これらも特別な方法で処理する必要があります。この場所で、多くのレーキを収集し、最終的に、チェックアウト中にツリー（現在は1つの作業コピー）を取得し、切り替え先のコミットのツリーを取得し、インデックスを取得し、適切に対処する必要があるという結論に達しました。つかまっている。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、アルゴリズムの複雑さの観点からは、ここでは何も失うことはありませんでした。ローカル変更のこれらすべてのツリーは、行った変更に比例しています。したがって、これらの操作でリポジトリ全体を回避する必要はありません。これらの操作は非常に迅速に機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、ファイルに与えるタイムスタンプが多少正確になるように、いくつかの魔法をかけています。ファイルシステムにファイルを保存するだけの場合は、これを監視し、常に時間が経過します。ここで私たちは、ユーザーがどの時点でどのファイルを見たかを何らかの形で覚えておかなければなりません。そして、彼が以前のコミットに切り替えた場合、彼に以前の時間を与え始めないでください。アセンブリシステム、すべてのIDEがこれに対応しているわけではないため、多くのものが取り除かれます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/r7/h7/fd/r7h7fdedl8-aip9z49ovoeb3zci.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのバージョン管理システムでは、トランクベースの開発のサポートが釘付けにされています。まず、私がすでに言ったこと：すべての変更はプール要求とトランクを通過します。さらにいくつかのポイントがあります。グループブランチのサポートはありません。 Arcで作成されたブランチは特定のユーザーに関連付けられており、彼だけがそこでコミットできます。これにより、長命のブランチを回避できます。 SVNでは、ブランチを作るのは不便なので、これは特にありませんでした。そして、それらをArcで実行すると便利です。これが制御されない場合、単一リポジトリの一部がブランチに向けて出発し、そこで開発が行われるのではないかと心配しています。これは、実行したいモデルとは逆です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uq/9a/bv/uq9abvkh2dunwxijq1vpuqefh7a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、マージコマンドはありません。ブランチのすべての合併は私たちの厳格な管理下で行われます。現在、マージも可能なリリースのブランチを開発しています。これは、一部のユーザーチームではなく、サーバーの機構によっても実行されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qa/dk/yl/qadkylvgcbgyx8lwuvc3n93ix7e.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
計画はありますか？単一リポジトリ開発者の20％は、すでにバージョン管理システムを使用しています。私たちはすでにある種の幼児国家から脱出しており、これは真剣に使用されているシステムであり、そのようにそれを捨てることは単に不可能です。最終的な目標は、Yandexのメインバージョン管理システムになることです。残りの80％の開発者は、私たちがかなり安定していて、信頼性が高く、使いやすいことを納得させる必要があります。このためには、すべてのバグを修正し、Gitにある機能を完了する必要があることは明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然のことながら、一部の観点では、私たちは自給自足になるか、コンバーターを放棄するか、または逆方向に展開することを計画しています。これにより、最初にすべての変更がArcに行き、次に最も永続的なプログラマーのSVNに行きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、私たちは大きな課題を抱えています。バージョン管理システムを自動アセンブリ、CI、その他のパイプラインに統合することです。課題は、人々は精神が弱く、ゆっくりとコードを入力し、ゆっくりとコミットすることです。また、コードのダウンロードが遅すぎます。そしてロボットはこの欠点を奪われています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
冗談として、最近1つのプロジェクトで、CIのためにロボットが直接Arcに移動して少しコミットすることを許可しました。また、すべてのYandex開発者を組み合わせた場合よりも2倍のワークロードが作成されました。そして、これはほんの一部です。モノリポジトリのC ++コードの主要部分を担当する大規模な自動アセンブリが来ると、負荷が数百倍に増えると予想されます。これに真剣に備える必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
議論のための提案。 「Gitのように」という言葉をずっと繰り返し続けました。そして、一般的に、私たちの計画は同じです：Gitを繰り返すというインターフェース。しかし、これを実行すればするほど、これがうまく機能しないことに気づきます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの問題があります。 Gitインターフェースは非常に低レベルです。これらは、オブジェクトのグラフと直接対話するほとんどの操作を提供します。同時に、プログラマーはある種の高度な操作を望んでいます。また、作業コピーの内容を壊さないように、チェックアウトまたはリセットコマンドに引数を設定する方法と方法を誰もが理解するわけではありません。私がこれを知っているのは、バージョン管理システムに切り替えるユーザーをサポートしているためです。あなたは定期的に人々に話します：すべてはGitのようです。 「まあ、私はそれをやった、そしてすべてが壊れた。」 Gitも壊れるでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を説明するために、例を挙げることができます。 git begin-wave-stashのような便利で便利なGitコマンドを知っていますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
聴衆から：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-非常に便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-Gitにはそのようなチームがあると思いますか？</font><font style="vertical-align: inherit;">これが問題です。お気に入りの検索エンジンがなければ、それが何をするかわからないだけでなく、原理的には、それが存在するかどうかもわかりません。</font><font style="vertical-align: inherit;">彼女はそこにいません、私はそれを発明しました。</font><font style="vertical-align: inherit;">したがって、Gitには欠陥がないわけではありません。</font><font style="vertical-align: inherit;">また、バージョン管理システムを開発しているため、機会を利用して修正しないのは奇妙です。</font><font style="vertical-align: inherit;">感謝。</font></font><br>
<br>
<a name="video"></a><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非公式レポートの記録</font></font></b><div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/PQWdvuo6Gzc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja482914/index.html">macOS組み込みツールを備えたWi-Fiポーク</a></li>
<li><a href="../ja482916/index.html">NESでの音楽の仕組み</a></li>
<li><a href="../ja482918/index.html">トランザクションでArduinoのEEPROMにデータを保存する</a></li>
<li><a href="../ja482920/index.html">自動操縦装置がどのように私たちの生活に入ったか、私たちは気づかなかった</a></li>
<li><a href="../ja482922/index.html">Drupal Digest-2019/12月</a></li>
<li><a href="../ja482928/index.html">Predator Vision：Thermal Vision Effect</a></li>
<li><a href="../ja482930/index.html">系図調査-計量図書、国勢調査、アーカイブ、オープンデータベース</a></li>
<li><a href="../ja482932/index.html">IIoT-または、従業員が意図したとおりに脳を使用できるようにする方法</a></li>
<li><a href="../ja482934/index.html">ERPプロジェクトの失敗（Liqui Moly、Otto、および彼のような他の人）</a></li>
<li><a href="../ja482936/index.html">ASGIの概要：非同期Python Webエコシステムの構築</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>