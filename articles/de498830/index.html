<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♌️ 🧑🏽‍🤝‍🧑🏽 👩‍👧‍👦 Hash + Cache: Optimierung der Stream-Verarbeitung 🚈 👩🏻‍🎨 📛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was soll ich tun, wenn ich viele „Fakten“ in die Datenbank eines viel größeren Volumens schreiben möchte, als es aushalten kann? Zunächst bringen wir ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Hash + Cache: Optimierung der Stream-Verarbeitung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/498830/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was soll ich tun, wenn ich viele „Fakten“ in die Datenbank eines viel größeren Volumens schreiben möchte, als es aushalten kann? Zunächst bringen wir die Daten natürlich in eine wirtschaftlichere </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normalform</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und erhalten „Wörterbücher“, die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir einmal schreiben werden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Aber wie geht das am effektivsten? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist genau die Frage, mit der wir bei der Entwicklung der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überwachung und Analyse von PostgreSQL-Serverprotokollen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> konfrontiert waren </font><font style="vertical-align: inherit;">, als andere </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methoden zur Optimierung des Datensatzes in der Datenbank</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erschöpft waren.</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/0y/34/cp/0y34cps5t4nqozitxa0xb7urypm.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir </font><font style="vertical-align: inherit;">
reservieren sofort, dass auf unseren Sammlern </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node.js ausgeführt wird</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sodass wir in keiner Weise mit Prozessorregistern und Caches interagieren. </font><font style="vertical-align: inherit;">Und die Option, "hundert" oder externe Caching-Dienste / Datenbanken zu verwenden, führt zu einer zu großen Verzögerung für </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eingehende Streams mit mehreren hundert Mbit / s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher versuchen wir, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alles im RAM zwischenzuspeichern</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , insbesondere im Speicher des JavaScript-Prozesses. </font><font style="vertical-align: inherit;">Wie wir dies effizienter organisieren können, und wir werden noch weiter gehen.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verfügbarkeits-Caching</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere Hauptaufgabe besteht darin, sicherzustellen, dass die einzige Instanz eines Objekts in die Datenbank gelangt. Dies sind die wiederholt wiederholten Originaltexte von SQL-Abfragen, Vorlagen von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plänen für ihre Implementierung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Knoten dieser Pläne - kurz einige </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textblöcke</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der </font></font><code>UUID</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergangenheit haben </font><font style="vertical-align: inherit;">wir als Bezeichner einen </font><font style="vertical-align: inherit;">Wert verwendet, der als Ergebnis der direkten Berechnung des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MD5-Hash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus dem Text des Objekts erhalten wurde. Danach überprüfen wir die Verfügbarkeit eines solchen Hash im lokalen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Wörterbuch" im Prozessspeicher</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und wenn er nicht vorhanden ist, schreiben wir erst dann in die Datenbank in der Tabelle "Wörterbuch".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, wir müssen den ursprünglichen Textwert nicht selbst speichern (und manchmal dauert es mehrere zehn Kilobyte) - allein die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsache, dass der entsprechende Hash</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Wörterbuch vorhanden </font><font style="vertical-align: inherit;">ist, reicht aus </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlüsselwörterbuch</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein solches Wörterbuch kann aufbewahrt </font></font><code>Array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Array.includes()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zur Überprüfung der Verfügbarkeit verwendet werden, dies ist jedoch ziemlich redundant - die Suche verschlechtert sich (zumindest in früheren Versionen von V8) linear von der Größe des Arrays O (N). </font><font style="vertical-align: inherit;">Und in modernen Implementierungen verliert es trotz aller Optimierungen mit einer Geschwindigkeit von 2-3%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Zeit vor ES6 war Speicher daher die traditionelle Lösung </font></font><code>Object</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit gespeicherten Werten als Schlüssel. </font><font style="vertical-align: inherit;">Aber jeder hat den Werten der Schlüssel das zugewiesen, was er wollte - zum Beispiel </font></font><code>Boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> dict = {};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">has</span>(<span class="hljs-params">key</span>) </span>{
  <span class="hljs-keyword">return</span> dict[key] !== <span class="hljs-literal">undefined</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">key</span>) </span>{<font></font>
  dict[key] = <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist jedoch ziemlich offensichtlich, dass wir hier eindeutig den Überschuss speichern - den Wert des Schlüssels, den niemand benötigt. Aber was ist, wenn es überhaupt nicht gespeichert ist? Also erschien das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Set-Objekt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ist Tests zeigen , </font><font style="vertical-align: inherit;">dass mit Hilfe der </font><font style="vertical-align: inherit;">Suche </font></font><code>Set.has()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etwa 20-25% schneller als Schlüsselüberprüfung c </font></font><code>Object</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies ist jedoch nicht sein einziger Vorteil. Da wir weniger speichern, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollten wir weniger Speicher benötigen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - und dies wirkt sich direkt auf die Leistung aus, wenn es um Hunderttausende solcher Schlüssel geht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also, </font></font><code>Object</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der es 100 UUID Schlüssel in einer Textdarstellung, nimmt es </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6216 Bytes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Speicher </font><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1e/n6/ge/1en6gefozucw86wki6odp-j3ria.png"><br>
<br>
<code>Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit dem gleichen Inhalt - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2632 Bytes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ri/59/cb/ri59cbgqbmmbqhivlopro2gspuu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, es </font></font><code>Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arbeitet schneller und zugleich nimmt</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,5-mal weniger Speicher</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - der Gewinner liegt auf der Hand.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir optimieren die Speicherung von UUID-Schlüsseln</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der </font><font style="vertical-align: inherit;">Regel in der Art von verteilten Systemen, UUID Schlüssel sind durchaus üblich - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in unserem VLSI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sie sind, auf ein Minimum, verwendet , um </font><font style="vertical-align: inherit;">Dokumente und Vorschriften zu identifizieren , die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elektronische Dokumentenverwaltung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die </font><font style="vertical-align: inherit;">Menschen in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Messaging</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun lasst uns schauen Sie </font><font style="vertical-align: inherit;">genau auf das Bild oben - jeder UUID- Der in der Hex-Darstellung gespeicherte Schlüssel „kostet“ uns </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">56 Byte Speicher</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Aber wir haben Hunderttausende von ihnen, daher ist es vernünftig zu fragen: "Ist es möglich, weniger zu haben?" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken Sie zunächst daran, dass die UUID eine 16-Byte-Kennung ist. Im Wesentlichen ein Stück Binärdaten. Und für die Übertragung per E-Mail werden beispielsweise Binärdaten in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base64</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> codiert </font><font style="vertical-align: inherit;">- versuchen Sie, sie anzuwenden:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> str = Buffer.from(uuidstr, <span class="hljs-string">'hex'</span>).toString(<span class="hljs-string">'base64'</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/pd/jc/ks/pdjckslsoycw92xnx4moahgmweg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bereits 48 Bytes sind besser, aber unvollkommen. </font><font style="vertical-align: inherit;">Versuchen wir, die hexadezimale Darstellung direkt in eine Zeichenfolge zu übersetzen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> str = Buffer.from(uuidstr, <span class="hljs-string">'hex'</span>).toString(<span class="hljs-string">'binary'</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/6i/nn/_5/6inn_5k8y3pnogatsv-r5ntrdzo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anstelle von 56 Bytes pro Schlüssel - 40 Bytes, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">was fast 30% spart</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meister, Arbeiter - wo Wörterbücher aufbewahren?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Anbetracht der Tatsache, dass sich die Vokabeldaten der Mitarbeiter sehr stark überschneiden, haben wir die Wörterbücher gespeichert und im Master-Prozess in die Datenbank geschrieben sowie die Daten der Mitarbeiter über </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den IPC-Nachrichtenmechanismus übertragen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein erheblicher Teil der Zeit des Masters wurde jedoch für die </font></font><code>channel.onread</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verarbeitung des Empfangs von Paketen mit "Wörterbuch" -Informationen von untergeordneten Prozessen </font><font style="vertical-align: inherit;">aufgewendet </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/kr/nr/sdkrnrm1c_amswktwm57kl3qsfo.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dual Set Write Barrier</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken wir jetzt eine Sekunde darüber nach - die Mitarbeiter senden und senden dem Master dieselben Vokabeldaten (im Grunde sind dies die Planvorlagen und die sich wiederholenden Anforderungskörper), er analysiert sie mit seinem Schweiß und ... tut nichts, weil sie bereits zuvor an die Datenbank gesendet wurden ! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir also </font></font><code>Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Datenbank mit einem Wörterbuch vor einer erneuten Aufzeichnung vom Master „geschützt“ haben, warum nicht den gleichen Ansatz verwenden, um den Master vor der Übertragung durch den Worker zu „schützen“? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich wurde dies getan und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die direkten Kosten für</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die </font><b><font style="vertical-align: inherit;">dreimalige</font></b><font style="vertical-align: inherit;"> Wartung des Austauschkanals </font><b><font style="vertical-align: inherit;">gesenkt</font></b><font style="vertical-align: inherit;"> : </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y1/h4/aj/y1h4ajs-o3hdg1xfoyf9j_kflpc.png"><br>
<br>
<img src="https://habrastorage.org/webt/vl/be/na/vlbenalj_sd_2jk36xdkhaouhp8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber jetzt scheinen die Arbeiter mehr zu arbeiten - Wörterbücher speichern und nach ihnen filtern? </font><font style="vertical-align: inherit;">Oder nicht? .. Tatsächlich begannen sie deutlich weniger zu arbeiten, da die Übertragung großer Mengen (auch über IPC!) Nicht billig ist.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/dz/7k/mb/dz7kmbdj5jnirhajahmwrpcwzfw.png"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schöner Bonus</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als der Assistent nun eine viel geringere Menge an Informationen erhielt, wurde diesen Containern viel weniger Speicher zugewiesen. Dies bedeutet, dass die für die Arbeit des Garbage Collector aufgewendete Zeit erheblich abnahm, was sich positiv auf die Latenz des gesamten Systems auswirkte.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fg/af/el/fgafel26_6der0h-knhglqckt8k.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein solches Schema bietet Schutz vor wiederholten Einträgen auf Kollektorebene. Was ist jedoch, wenn wir mehrere Kollektoren haben? </font><font style="vertical-align: inherit;">Hier hilft nur der Auslöser mit </font></font><code>INSERT ... ON CONFLICT DO NOTHING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschleunigen Sie die Hash-Berechnung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserer Architektur wird der gesamte Protokolldatenstrom von einem PostgreSQL-Server von einem Worker verarbeitet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, ein Server ist eine Aufgabe für den Mitarbeiter. Gleichzeitig wird die Belastung der Worker durch den Zweck der Server-Tasks ausgeglichen, so dass der CPU-Verbrauch der Worker aller Kollektoren ungefähr gleich ist. Dies ist ein separater Service-Dispatcher. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
„Im Durchschnitt“ erledigt jeder Mitarbeiter Dutzende von Aufgaben, die ungefähr die gleiche Gesamtlast erzeugen. Es gibt jedoch Server, die den Rest der Anzahl der Protokolleinträge deutlich übertreffen. Und selbst wenn der Dispatcher diese Aufgabe als einzige auf dem Worker belässt, ist der Download viel höher als bei den anderen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/p1/9a/olp19ahpqzn4e5aaek0oyg1tjt0.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben das CPU-Profil dieses Workers entfernt: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/2q/zk/fs/2qzkfsaqceti_tietxizjhfmioi.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den obersten Zeilen die Berechnung von MD5-Hashes. </font><font style="vertical-align: inherit;">Und sie sind wirklich eine riesige Menge - für den gesamten Strom eingehender Objekte.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xxHash</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie kann man diesen Teil optimieren, außer diesen Hashes, die wir nicht können? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben uns entschlossen, eine andere Hash-Funktion </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auszuprobieren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">xxHash</font></a><font style="vertical-align: inherit;"> , die einen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extrem schnellen nicht-kryptografischen Hash-Algorithmus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementiert </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das Modul für Node.js ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xxhash-addon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das die neueste Version der Bibliothek xxHash 0.7.3 mit dem neuen XXH3-Algorithmus verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Überprüfen Sie dies, indem Sie jede Option für eine Reihe von Zeilen unterschiedlicher Länge ausführen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> { XXHash3, XXHash64 } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'xxhash-addon'</span>);
<span class="hljs-keyword">const</span> hasher3 = <span class="hljs-keyword">new</span> XXHash3(<span class="hljs-number">0xDEADBEAF</span>);
<span class="hljs-keyword">const</span> hasher64 = <span class="hljs-keyword">new</span> XXHash64(<span class="hljs-number">0xDEADBEAF</span>);<font></font>
<font></font>
<span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">16</span>);
<span class="hljs-keyword">const</span> getBinFromHash = <span class="hljs-function">(<span class="hljs-params">hash</span>) =&gt;</span> buf.fill(hash, <span class="hljs-string">'hex'</span>).toString(<span class="hljs-string">'binary'</span>);<font></font>
<font></font>
<span class="hljs-keyword">const</span> funcs = {
  <span class="hljs-attr">xxhash64</span> : <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> hasher64.hash(Buffer.from(str)).toString(<span class="hljs-string">'binary'</span>)<font></font>
, <span class="hljs-attr">xxhash3</span>  : <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> hasher3.hash(Buffer.from(str)).toString(<span class="hljs-string">'binary'</span>)<font></font>
, <span class="hljs-attr">md5</span>      : <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> getBinFromHash(crypto.createHash(<span class="hljs-string">'md5'</span>).update(str).digest(<span class="hljs-string">'hex'</span>))<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">const</span> check = <span class="hljs-function">(<span class="hljs-params">hash</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> log = [];
  <span class="hljs-keyword">let</span> cnt = <span class="hljs-number">10000</span>;
  <span class="hljs-keyword">while</span> (cnt--) log.push(crypto.randomBytes(cnt).toString(<span class="hljs-string">'hex'</span>));<font></font>
<font></font>
  <span class="hljs-built_in">console</span>.time(hash);<font></font>
  log.forEach(funcs[hash]);<font></font>
  <span class="hljs-built_in">console</span>.timeEnd(hash);<font></font>
};<font></font>
<font></font>
<span class="hljs-built_in">Object</span>.keys(funcs).forEach(check);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ergebnisse:</font></font><br>
<pre><code class="plaintext hljs">xxhash64 : 148.268ms<font></font>
xxhash3  : 108.337ms<font></font>
md5      : 317.584ms<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erwartet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> war xxhash3 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">viel schneller als MD5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es bleibt die Beständigkeit gegen Kollisionen zu prüfen. </font><font style="vertical-align: inherit;">Jeden Tag werden Abschnitte mit Wörterbuchtabellen für uns erstellt, sodass wir außerhalb der Tagesgrenzen die Schnittmenge von Hashes sicher zulassen können. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber nur für den Fall, wir haben im Abstand von drei Tagen mit einem Spielraum nachgesehen - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kein einziger Konflikt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der uns mehr als genug zusagt.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hash-Ersatz</font></font></h4><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/rz/ga/3drzgasyjhevujtp-etsjcwlnz8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können jedoch einfach keine alten UUID-Felder in den Wörterbuchtabellen gegen einen neuen Hash austauschen, da sowohl die Datenbank als auch das vorhandene Frontend darauf warten, dass Objekte weiterhin von der UUID identifiziert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher werden wir dem Kollektor </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen weiteren Cache</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hinzufügen </font><font style="vertical-align: inherit;">- für bereits berechnetes MD5. Jetzt wird es eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karte sein</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in der die Schlüssel xxhash3 sind, die Werte sind MD5. Bei identischen Zeilen wird der „teure“ MD5 nicht erneut nachgezählt, sondern aus dem Cache entnommen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> getHashFromBin = <span class="hljs-function">(<span class="hljs-params">bin</span>) =&gt;</span> Buffer.from(bin, <span class="hljs-string">'binary'</span>).toString(<span class="hljs-string">'hex'</span>);
<span class="hljs-keyword">const</span> dictmd5 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
<span class="hljs-keyword">const</span> getmd5 = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> hash = xxhash(data);
  <span class="hljs-keyword">let</span> md5hash = dictmd5.get(hash);
  <span class="hljs-keyword">if</span> (!md5hash) {<font></font>
    md5hash = md5(data);<font></font>
    dictmd5.set(hash, getBinFromHash(md5hash));<font></font>
    <span class="hljs-keyword">return</span> md5hash;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> getHashFromBin(md5hash);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir entfernen das Profil - der Bruchteil der Zeit für die Berechnung von Hashes hat sich deutlich verringert, Prost! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/el/5q/ce/el5qcei3ahbakyyerswutw2rulk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt zählen wir xxhash3, überprüfen dann den MD5-Cache und erhalten den gewünschten MD5 und überprüfen dann den Wörterbuch-Cache. Wenn dieser md5 nicht vorhanden ist, senden Sie ihn zum Schreiben an die Datenbank. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Etwas zu viele Überprüfungen ... Warum den Wörterbuch-Cache überprüfen, wenn Sie den MD5-Cache bereits überprüft haben? </font><font style="vertical-align: inherit;">Es stellt sich heraus, dass nicht mehr alle Wörterbuch-Caches benötigt werden und es ausreicht, nur einen Cache zu haben - für MD5, mit dem alle grundlegenden Operationen ausgeführt werden: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wl/e_/uc/wle_ucs0o22wpxmrjlg_2sokzvm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen haben wir die Prüfung in mehreren "Objekt" -Wörterbüchern durch einen MD5-Cache ersetzt, und die ressourcenintensive Berechnung von MD5 ist erforderlich Hash wird nur für neue Einträge ausgeführt, wobei der wesentlich effizientere xxhash für den eingehenden Stream verwendet wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Danke</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kilor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für Hilfe bei der Vorbereitung des Artikels.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de498814/index.html">Sie haben eine theoretische Frage zur sozialen Sicherheit nicht beantwortet, und sie haben Ihnen ein Ende gesetzt. Es ist in Ordnung? // Wir sind zum Scheitern verurteilt # 3</a></li>
<li><a href="../de498816/index.html">Die Wahrheit zuallererst oder warum das System basierend auf dem Datenbankgerät entworfen werden muss</a></li>
<li><a href="../de498820/index.html">Einige weitere knifflige Fragen zu .NET und C #</a></li>
<li><a href="../de498826/index.html">SIL und Salesforce</a></li>
<li><a href="../de498828/index.html">Wie Speisesalz und Proteine ​​das Überleben von Implantaten erhöhen</a></li>
<li><a href="../de498832/index.html">Überblick über die Möglichkeiten von Qt Creator 4.12 und QBS 1.16 zur Programmierung von Mikrocontrollern</a></li>
<li><a href="../de498834/index.html">33 Online-Mitaps der Woche. Wählen Sie eine oder haben Sie Zeit für alles?</a></li>
<li><a href="../de498836/index.html">[Infografiken] Top 50 Gaming-Franchise-Unternehmen mit einem Umsatz von über einer Milliarde</a></li>
<li><a href="../de498840/index.html">Der Bot überwacht und steuert den Computer per Telegramm</a></li>
<li><a href="../de498842/index.html">Moderation von Kommentaren: Können wir den Benutzern dennoch vertrauen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>