<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙🏼 👲🏿 🧑🏽‍🤝‍🧑🏽 「Java Concurrency in Practice」という本 👋🏻 🙁 🤽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、habrozhiteli！ストリームはJavaプラットフォームの基本的な部分です。マルチコアプロセッサは一般的であり、高パフォーマンスアプリケーションを作成するには、同時実行性を効果的に使用する必要があります。改善されたJava仮想マシン、高性能クラスのサポート、および並列化タスク用の豊...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>「Java Concurrency in Practice」という本</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/489038/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/1r/ku/4r/1rku4rb0w0tevxfiae9gxkkkzse.jpeg" align="left" alt="画像"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、habrozhiteli！ストリームはJavaプラットフォームの基本的な部分です。マルチコアプロセッサは一般的であり、高パフォーマンスアプリケーションを作成するには、同時実行性を効果的に使用する必要があります。改善されたJava仮想マシン、高性能クラスのサポート、および並列化タスク用の豊富なビルディングブロックのセットは、かつては並列アプリケーションの開発における画期的なものでした。 Java Concurrency in Practiceでは、画期的なテクノロジーの作成者自身が、その機能だけでなく、デザインパターンについても説明します。効果があると思われる競争力のあるプログラムを作成するのは簡単です。ただし、マルチスレッドプログラムの開発、テスト、デバッグには多くの問題があります。負荷が大きい場合、コードは最も重要なときに機能しなくなります。「Java Concurrency in Practice」では、信頼性が高く、スケーラブルでサポートされている並列アプリケーションを作成するための理論と特定の方法の両方を見つけることができます。著者は、APIと並列化メカニズムのリストを提供していません;それらは、Javaバージョンに依存せず、長年にわたって関連性と効果を維持する設計ルール、パターン、モデルを紹介しています。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抜粋。</font><font style="vertical-align: inherit;">スレッドセーフ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
競争プログラミングがスレッドまたはロックに関連付けられていることに驚くかもしれません</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">土木工学はリベットとIビームに関連付けられているにすぎません。</font><font style="vertical-align: inherit;">もちろん、ブリッジの構築には多数のリベットとIビームを正しく使用する必要があります。これは、スレッドとロックを正しく使用する必要がある競合プログラムの構築にも当てはまります。</font><font style="vertical-align: inherit;">しかし、これらは単なるメカニズム-目標を達成する手段です。</font><font style="vertical-align: inherit;">スレッドセーフコードの記述は、本質的に、状態、特に変更可能な状態へのアクセスを制御することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、オブジェクトの状態は、インスタンス変数や静的フィールド、他の依存オブジェクトのフィールドなどの状態変数に格納されたデータです。 HashMapハッシュの状態の一部はHashMap自体に格納されますが、多くのMap.Entryオブジェクトにも格納されます。オブジェクトの状態には、その動作に影響を与える可能性のあるデータが含まれます。</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1）</font></font></b>     lock  block,      «»,     ,  .            blocking.   lock    «», «  ».     lock ,  ,   ,    «».  —          .       ,          , ,         . — . . .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のスレッドが変更された共有変数にアクセスできます-その値を変更します。実際、私たちは制御されていない競争的なアクセスから、コードではなくデータを保護しようとしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッドセーフオブジェクトを作成するには、変化した状態へのアクセスを調整するための同期、データの破損やその他の望ましくない結果につながる可能性のある実行の失敗が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のスレッドが状態変数にアクセスし、そのうちの1つのスレッドが状態変数に書き込む可能性がある場合は常に、すべてのスレッドが同期を使用して状態変数へのアクセスを調整する必要があります。 Javaでの同期は、synchronizedキーワードによって提供されます。これは、排他的ロック、揮発性変数、アトミック変数、および明示的ロックを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同期を必要としない状況があると考える誘惑に抵抗します。</font><font style="vertical-align: inherit;">プログラムは機能し、そのテストに合格することができますが、いつでも誤動作およびクラッシュしたままです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のスレッドが適切に同期せずに状態が変化した同じ変数にアクセスする場合、プログラムは誤動作しています。</font><font style="vertical-align: inherit;">それを修正するには3つの方法があります：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのスレッドで状態変数を共有しない</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態変数を変更不可にします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態変数にアクセスするたびに状態同期を使用します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
修正には大幅な設計変更が必要になる場合があるため、後でアップグレードするよりも、スレッドセーフなクラスをすぐに設計する方がはるかに簡単です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のスレッドがこの変数またはその変数にアクセスするかどうかを確認することは困難です。幸いなことに、データのカプセル化や非表示など、よく整理された保守しやすいクラスの作成に役立つオブジェクト指向の技術ソリューションも、スレッドセーフなクラスの作成に役立ちます。特定の変数にアクセスできるスレッドが少ないほど、同期を確実にし、この変数にアクセスできる条件を設定するのが簡単になります。 Java言語は、状態をカプセル化することを強制しません-パブリックフィールド（パブリック静的フィールドを含む）に状態を格納するか、それ以外の場合は内部にあるオブジェクトへのリンクを公開することは完全に許容されますが、プログラムの状態はより適切にカプセル化されます。プログラムをスレッドセーフにし、メンテナーがその方法を維持するのを支援する方が簡単です。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドセーフなクラスを設計する場合、オブジェクト指向の優れた技術的ソリューション：カプセル化、可変性、不変条件の明確な仕様が助力になります。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
優れたオブジェクト指向設計の技術ソリューションが開発者のニーズと異なる場合は、パフォーマンスまたはレガシーコードとの下位互換性のために、優れた設計のルールを犠牲にする必要があります。</font><font style="vertical-align: inherit;">多くの場合、多くの開発者が信じているほどではありませんが、抽象化とカプセル化はパフォーマンスによって異なる場合がありますが、ベストプラクティスは、コードを最初に正しく、次に高速にすることです。</font><font style="vertical-align: inherit;">生産性とニーズの測定結果から最適化を実行する必要があることが示された場合にのみ、最適化を使用してください</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（2）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（2）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">競争力のあるコードでは、この慣行を通常よりも厳守する必要があります。競合エラーは再現が非常に難しく、デバッグが容易ではないため、まれにしか使用されないコードブランチでパフォーマンスがわずかに向上するという利点は、プログラムが動作条件下でクラッシュするリスクに比べれば、ごくわずかです。</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
カプセル化を解除する必要があると判断した場合、すべてが失われるわけではありません。プログラムをスレッドセーフにすることはできますが、プロセスはより複雑で高価になり、結果は信頼できなくなります。第4章では、状態変数のカプセル化を安全に緩和できる条件について説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまで、「スレッドセーフクラス」と「スレッドセーフプログラム」という用語をほぼ同じ意味で使用してきました。スレッドセーフプログラムは完全にスレッドセーフクラスから構築されていますか？オプション：完全にスレッドセーフクラスで構成されるプログラムは、スレッドセーフではない場合があり、スレッドセーフプログラムには、スレッドセーフでないクラスが含まれている場合があります。スレッドセーフクラスのレイアウトに関する問題については、第4章でも説明します。いずれの場合でも、スレッドセーフクラスの概念は、クラスが独自の状態をカプセル化する場合にのみ意味があります。 「スレッドセーフティ」という用語はコードに適用できますが、状態を表し、その状態をカプセル化するコードの配列（オブジェクトまたはプログラム全体）にのみ適用できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1。</font><font style="vertical-align: inherit;">スレッドセーフとは</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッドセーフの定義は簡単ではありません。</font><font style="vertical-align: inherit;">Googleをすばやく検索すると、次のような多数のオプションが提供されます</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。...複数のプログラムスレッドから、スレッド間の不要な相互作用なしに呼び出すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...呼び出し元から他のアクションを必要とせずに、同時に2つ以上のスレッドから呼び出すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような定義を前提として、スレッドセーフが混乱するのは当然のことです。</font><font style="vertical-align: inherit;">スレッドセーフなクラスと安全でないクラスを区別するにはどうすればよいですか？</font><font style="vertical-align: inherit;">「安全」という言葉はどういう意味ですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッドセーフの合理的な定義の中心にあるのは、正確性の概念です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正確性は、クラスがその仕様に準拠していることを意味します。</font><font style="vertical-align: inherit;">この仕様では、オブジェクトの状態を制限する不変条件と、操作の影響を説明する事後条件を定義しています。</font><font style="vertical-align: inherit;">クラスの仕様が正しいことをどのようにして知っていますか？</font><font style="vertical-align: inherit;">まさか、しかしこれはコードが機能することを確信した後でそれらを使用することを妨げません。</font><font style="vertical-align: inherit;">したがって、シングルスレッドの正確さが目に見えるものであると仮定しましょう。</font><font style="vertical-align: inherit;">これで、スレッドセーフクラスが複数のスレッドからのアクセス中に正しく動作すると仮定できます。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作業環境によってこれらのスレッドがどのようにスケジュールまたはインターリーブされているかに関係なく、複数のスレッドからのアクセス中にクラスが正しく動作する場合、クラスはスレッドセーフであり、追加の同期や呼び出しコードのその他の調整は必要ありません。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マルチスレッドプログラムは、シングルスレッド環境</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（3）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でも正しくない場合、スレッドセーフになることはできません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">オブジェクトが正しく実装されている場合、操作のシーケンス（パブリックメソッドへのアクセス、パブリックフィールドへの読み取りまたは書き込み）は、その不変条件または事後条件に違反しません。</font><font style="vertical-align: inherit;">スレッドセーフクラスのインスタンスに対して順次または競合的に実行される一連の操作によって、インスタンスが無効な状態になることはありません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（3）</font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正確性という用語の使い方を誤ると、ここでスレッドセーフなクラスを、シングルスレッド環境だけでなく、競合環境でも欠陥があるクラスと考えることができます。</font></font></i><br>
 <br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドセーフクラスは、必要な同期自体をカプセル化し、クライアントの助けを必要としません。</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1.1。</font><font style="vertical-align: inherit;">例：内部状態をサポートしないサーブレット</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第1章では、スレッドを作成し、スレッドの安全性を担当するコンポーネントを呼び出す構造をリストしました。</font><font style="vertical-align: inherit;">今度は、サーブレットの因数分解サービスを開発し、スレッドの安全性を維持しながら、その機能を徐々に拡張していきます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト2.1は、クエリから数値を解凍し、それを因数分解し、応答に結果をラップする単純なサーブレットを示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト2.1 </font><font style="vertical-align: inherit;">内部状態をサポートしないサーブレット</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@ThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatelessFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどのサーブレットと同様に、StatelessFactorizerクラスには内部状態がありません。フィールドが含まれておらず、他のクラスのフィールドを参照していません。</font><font style="vertical-align: inherit;">特定の計算の状態は、ストリームスタックに格納され、実行中のストリームでのみ使用できるローカル変数にのみ存在します。</font><font style="vertical-align: inherit;">StatelessFactorizerにアクセスする1つのスレッドは、別のスレッドが同じことを行う結果に影響を与えることはできません。これらのスレッドは状態を共有しないためです。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部状態をサポートしないオブジェクトは、常にスレッドセーフです。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどのサーブレットは内部状態のサポートなしで実装できるため、サーブレット自体のスレッド化の負担が大幅に軽減されます。</font><font style="vertical-align: inherit;">そして、サーブレットが何かを覚える必要がある場合にのみ、スレッドセーフの要件が増加します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2。</font><font style="vertical-align: inherit;">原子性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部状態サポートなしでオブジェクトに状態アイテムが追加されるとどうなりますか？処理されたリクエストの数を測定するヒットカウンターを追加するとします。リスト2.2のUnsafeCountingFactorizerに示すように、long型のフィールドをサーブレットに追加し、リクエストごとにインクリメントできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト2.2。必要な同期なしでリクエストをカウントするサーブレット。これはすべきではありません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/lj/hg/geljhgzyo9aogxu-ttztrzuawqo.jpeg" alt="画像"></div><br>
<pre><code class="java hljs"><span class="hljs-meta">@NotThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeCountingFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> count = <span class="hljs-number">0</span>;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> count; }<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            ++count;<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、UnsafeCountingFactorizerクラスは、シングルスレッド環境で正常に機能しても、スレッドセーフではありません。 UnsafeSequenceと同様に、更新が失われる傾向があります。増分演算++カウントの構文はコンパクトですが、アトミックではありません。つまり、不可分ではありません。現在の値を配信し、値を1つ追加し、新しい値を書き戻すという3つの操作のシーケンスです。 「読み取り、変更、書き込み」操作では、結果の状態は前の状態から派生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図では </font><font style="vertical-align: inherit;">1.1これは、2つのスレッドが同期せずに同時にカウンターを増加させた場合に何が起こるかを示しています。</font><font style="vertical-align: inherit;">カウンターが9の場合、時間調整が失敗したため、両方のスレッドが値9を参照し、それに1を加算して、値を10に設定します。したがって、ヒットカウンターは1つ遅れます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Webサービスにわずかに不正確なヒットカウンターがあることは許容できる損失であると考えるかもしれません。</font><font style="vertical-align: inherit;">ただし、カウンターを使用してオブジェクトのシーケンスまたは一意の識別子を作成する場合、複数のアクティブ化から同じ値を返すと、データの整合性に重大な問題が発生する可能性があります。</font><font style="vertical-align: inherit;">競合状態では、時間調整の失敗が原因で誤った結果が表示される可能性があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.1。</font><font style="vertical-align: inherit;">レース条件</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UnsafeCountingFactorizerクラスにはいくつかの競合状態</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（4）があり</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。最も一般的なタイプの競合状態は、「チェックしてから行動する」状況です。この状況では、古くなった可能性のある観測を使用して次に何をするかを決定します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（4）</font></font></b> <i>          (data race).   ,            .        ,    ,       ,   ,         ,      .               Java.       ,        ,             . UnsafeCountingFactorizer   .       16.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実生活では、しばしば競合状態に遭遇します。正午に、Universitetskiy ProspektにあるStarbucksCaféで友人に会う予定だとします。しかし、University Avenueには2つのスターバックスがあることがわかります。 12時10分に、カフェAに友達がいなくてカフェBに行きますが、彼もそこにいません。友人が遅刻したか、あなたが去った直後にカフェAに到着したか、または彼がカフェBにいたが、あなたを探しに行って、今カフェAに行く途中です。後者、つまり最悪のオプションを選択します。さて12:15、そしてあなた方二人はあなたの友人が彼の約束を守ったかどうか疑問に思っています。別のカフェに戻りますか？何回行ったり来たりしますか？プロトコルに同意していない場合は、カフェインされた陶酔でユニバーシティアベニューに沿って1日中歩くことができます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「散歩して彼がそこにいるかどうかを確認する」アプローチの問題は、2つのカフェの間を通りに沿って歩くのに数分かかり、この間にシステムの状態が変化する可能性があることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スターバックスを使用した例は、イベントの相対的な時間調整（カフェなどで友達を待つ時間など）に対する結果の依存性を示しています。</font><font style="vertical-align: inherit;">彼がカフェAにいないという観察は無効になる可能性があります。正面玄関を出るとすぐに、彼は裏口から入ることができます。</font><font style="vertical-align: inherit;">ほとんどの競合状態は、予期しない例外、上書きされたデータ、ファイルの破損などの問題を引き起こします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.2。</font><font style="vertical-align: inherit;">例：遅延初期化の競合状態</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「チェックアンドアクトアクション」アプローチを使用する一般的なトリックは、遅延初期化（LazyInitRace）です。その目的は、オブジェクトの初期化が必要になるまで延期すること、およびオブジェクトが1回だけ初期化されるようにすることです。リスト2.3のgetInstanceメソッドは、ExpensiveObjectが初期化されていることを確認して既存のインスタンスを返すか、そうでない場合は、新しいインスタンスを作成し、それへの参照を維持した後でそれを返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト2.3競合状態は遅延初期化です。これはすべきではありません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/lj/hg/geljhgzyo9aogxu-ttztrzuawqo.jpeg" alt="画像"></div><br>
<pre><code class="java hljs"><span class="hljs-meta">@NotThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyInitRace</span> </span>{
      <span class="hljs-keyword">private</span> ExpensiveObject instance = <span class="hljs-keyword">null</span>;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> ExpensiveObject <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)<font></font>
                instance = <span class="hljs-keyword">new</span> ExpensiveObject();
            <span class="hljs-keyword">return</span> instance;<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LazyInitRaceクラスには競合状態が含まれています。スレッドAとBが同時にgetInstanceメソッドを実行するとします。はインスタンスフィールドがnullであることを確認し、新しいExpensiveObjectを作成します。スレッドBは、インスタンスフィールドが同じnullかどうかも確認します。この時点でフィールドにnullが存在するかどうかは、計画のばらつきやExpensiveObjectのインスタンスを作成してインスタンスフィールドに値を設定するのに必要な時間など、時間調整に依存します。 Bがチェックするときにインスタンスフィールドがnullの場合、getInstanceメソッドが常に同じインスタンスを返すことになっている場合でも、getInstanceメソッドを呼び出す2つのコード要素は2つの異なる結果を取得できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UnsafeCountingFactorizerのヒットカウンターにも競合状態が含まれています。 「読み取り、変更、書き込み」のアプローチは、カウンターをインクリメントするために、ストリームが以前の値を認識し、更新プロセス中に他のユーザーがこの値を変更または使用しないようにする必要があることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの競合エラーと同様に、競合状態は常に失敗につながるわけではなく、一時的な調整が成功しています。</font><font style="vertical-align: inherit;">ただし、LazyInitRaceクラスを使用してアプリケーション全体のレジストリをインスタンス化すると、複数のアクティベーションから異なるインスタンスが返されると、登録が失われるか、アクションが登録されたオブジェクトのセットの競合する表現を受け取ります。</font><font style="vertical-align: inherit;">または、UnsafeSequenceクラスを使用してデータ保存構造でエンティティ識別子を生成する場合、2つの異なるオブジェクトが同じ識別子を持つ可能性があり、IDの制限に違反します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.3。</font><font style="vertical-align: inherit;">複合アクション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LazyInitRaceとUnsafeCountingFactorizerの両方に、アトミックである必要がある一連の操作が含まれています。</font><font style="vertical-align: inherit;">しかし、競合状態を防ぐために、1つのスレッドが変数を変更している間、他のスレッドが変数を使用するのに障害があるはずです。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作AとBは、操作Aを実行するスレッドの観点から、操作Bが別のスレッドによって完全に実行されたか、部分的に実行されなかった場合、アトミックです。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UnsafeSequenceのインクリメント操作のアトミック性は、図4に示す競合状態を回避します。 1.1。 「チェックしてから実行」および「読み取り、変更、書き込み」の操作は、常にアトミックである必要があります。それらは複合アクションと呼ばれ、スレッドセーフを維持するためにアトミックに実行する必要がある一連の操作です。次のセクションでは、アトミック性を提供するJavaに組み込まれたメカニズムであるロックについて検討します。それまでの間、リスト2.4のCountingfactorizerに示すように、既存のスレッドセーフクラスを適用することにより、別の方法で問題を修正します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト2.4 AtomicLongを使用したリクエストをカウントするサーブレット</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@ThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicLong count = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> count.get(); }<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            count.incrementAndGet();<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
java.util.concurrent.atomicパッケージには、クラスの状態を管理するためのアトミック変数が含まれています。カウンタータイプをlongからAtomicLongに置き換えると、カウンターの状態を参照するすべてのアクションがatomic1になることが保証されます。サーブレットの状態はカウンターの状態であり、カウンターはスレッドセーフであるため、サーブレットはスレッドセーフになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部状態をサポートしないクラスに単一の状態要素が追加されると、状態がスレッドセーフオブジェクトによって完全に制御される場合、結果のクラスはスレッドセーフになります。ただし、次のセクションで説明するように、ある状態変数から次の状態変数への遷移は、0から1への遷移ほど単純ではありません。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">便利な場合は、AtomicLongなどの既存のスレッドセーフオブジェクトを使用して、クラスの状態を制御します。</font><font style="vertical-align: inherit;">既存のスレッドセーフオブジェクトの可能な状態と他の状態へのそれらの遷移は、任意の状態変数よりも、スレッドセーフの維持とチェックが簡単です。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本についての詳しい情報はで見つけることができます» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版社のウェブサイト</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抜粋</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
クーポンのためにKhabrozhiteley 25％割引- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javaの</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
書籍の紙のバージョンの支払い後、電子書籍を電子メールで送信されます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja489022/index.html">MonbMQパート2でのRabbitMQの使用</a></li>
<li><a href="../ja489024/index.html">初心者の目から見たWebix JavaScriptライブラリ。パート5.ユーザー側でデータを操作する</a></li>
<li><a href="../ja489026/index.html">Google AdSenseアルゴリズムを変更すると、サイトの所有者やウェブマスターにつながる可能性があります</a></li>
<li><a href="../ja489028/index.html">遠隔作業について</a></li>
<li><a href="../ja489034/index.html">新しいUISモバイルアプリ-公共調達を求める人のための苦痛または救済？</a></li>
<li><a href="../ja489040/index.html">Contact Center AI：会話中のサードパーティは問題ありません</a></li>
<li><a href="../ja489042/index.html">ストアのグランドオープン：コルーチンを使用したAndroidへのデータの読み込み</a></li>
<li><a href="../ja489044/index.html">テキストの物理学。パート1.シンボル</a></li>
<li><a href="../ja489046/index.html">自動運転GAZ66モンスタートラック1/16</a></li>
<li><a href="../ja489048/index.html">ログとクエリのトレースはベストプラクティスです。Yandexレポート</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>