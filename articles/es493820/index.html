<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßúüèª ‚úãüèº üò™ Kubernetes equilibra la carga y escala las conexiones de larga duraci√≥n üöª üèÇüèΩ üë¶üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo le ayudar√° a comprender c√≥mo funciona el equilibrio de carga en Kubernetes, qu√© sucede al escalar conexiones de larga duraci√≥n y por qu√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kubernetes equilibra la carga y escala las conexiones de larga duraci√≥n</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/493820/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/445/275/8af/4452758afb53f8b3161ace47d8c6ea49.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este art√≠culo le ayudar√° a comprender c√≥mo funciona el equilibrio de carga en Kubernetes, qu√© sucede al escalar conexiones de larga duraci√≥n y por qu√© deber√≠a considerar el equilibrio en el lado del cliente si utiliza HTTP / 2, gRPC, RSockets, AMQP u otros protocolos de larga duraci√≥n.&nbsp;</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un poco sobre c√≥mo se redistribuye el tr√°fico en Kubernetes&nbsp;</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes proporciona dos abstracciones convenientes para la implementaci√≥n de aplicaciones: servicios e implementaciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las implementaciones describen c√≥mo y cu√°ntas copias de su aplicaci√≥n deber√≠an ejecutarse en un momento dado. </font><font style="vertical-align: inherit;">Cada aplicaci√≥n se implementa como en (Pod) y se le asigna una direcci√≥n IP. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los servicios de caracter√≠sticas son similares a un equilibrador de carga. </font><font style="vertical-align: inherit;">Est√°n dise√±ados para distribuir el tr√°fico a trav√©s de m√∫ltiples hogares. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veamos como se ve</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el siguiente diagrama, ver√° tres instancias de la misma aplicaci√≥n y un equilibrador de carga:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80f/58d/4f9/80f58d4f9cd1e34a88aa7b8a33c0a82f.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El equilibrador de carga se llama Servicio, se le asigna una direcci√≥n IP. </font><font style="vertical-align: inherit;">Cualquier solicitud entrante se redirige a uno de los pods:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63e/7ef/b73/63e7efb73e75ce67fcd47f74b03aa04d.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El script de implementaci√≥n determina el n√∫mero de instancias de la aplicaci√≥n. </font><font style="vertical-align: inherit;">Casi nunca tendr√° que implementar directamente en:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/121/8c3/a961218c382f2343f72bdcf639f20222.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A cada pod se le asigna su propia direcci√≥n IP:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c0/699/ef3/3c0699ef3d5a60d5b08f7afdfdedac29.png"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es √∫til considerar los servicios como un conjunto de direcciones IP. </font><font style="vertical-align: inherit;">Cada vez que accede al servicio, se selecciona una de las direcciones IP de la lista y se utiliza como direcci√≥n de destino. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto es lo siguiente</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay una solicitud curl 10.96.45.152 al servicio:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60a/52c/539/60a52c539ed6d1791cbafa794db2c4a9.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El servicio selecciona una de las tres direcciones de pod como destino:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a8/ac4/e23/2a8ac4e23e79da06ee64c01e071b9089.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El tr√°fico se redirige a un pod espec√≠fico:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ec/f2c/38e/7ecf2c38ef0af62d07d169c120ca5def.png"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si su aplicaci√≥n consta de un front-end y un back-end, tendr√° un servicio y una implementaci√≥n para cada uno. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando el frontend cumple con la solicitud al backend, no necesita saber exactamente cu√°ntos montones sirve el backend: puede haber uno, diez o cien. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, el frontend no sabe nada sobre las direcciones de los hogares que sirven al backend. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando el frontend hace una solicitud al backend, usa la direcci√≥n IP del servicio de backend, que no cambia. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As√≠ es como se ve</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bajo 1 solicita el componente interno del backend. </font><font style="vertical-align: inherit;">En lugar de elegir uno espec√≠fico para el backend, realiza una solicitud de servicio:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ff/50c/a99/1ff50ca9970854efe8af15ac2a7d1791.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El servicio selecciona uno de los pods de back-end como la direcci√≥n de destino:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/dd9/9ad/530dd99add6451742a891d69ef06d03b.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El tr√°fico va del hogar 1 al hogar 5 seleccionado por el servicio:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ea/bdb/808/2eabdb8086fefc2c48d171f3c0e2c87e.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menos de 1, no sabe exactamente cu√°ntos hogares de menos de 5 est√°n ocultos detr√°s del servicio:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/665/f5e/edc/665f5eedc580d007fd9db6ced40f86d1.png"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero, ¬øc√≥mo distribuye exactamente el servicio las solicitudes? </font><font style="vertical-align: inherit;">¬øParece que se usa el balanceo round-robin? </font><font style="vertical-align: inherit;">Vamos a hacerlo bien.&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Equilibrio en los servicios de Kubernetes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los servicios de Kubernetes no existen. No hay proceso para el servicio al que se le asigna una direcci√≥n IP y un puerto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede verificar esto yendo a cualquier nodo en el cl√∫ster y ejecutando el comando netstat -ntlp. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ni siquiera puede encontrar la direcci√≥n IP asignada al servicio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La direcci√≥n IP del servicio se encuentra en la capa de control, en el controlador y se registra en la base de datos, etc. Otro componente utiliza la misma direcci√≥n: kube-proxy. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kube-proxy recibe una lista de direcciones IP para todos los servicios y forma un conjunto de reglas de iptables en cada nodo del cl√∫ster. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas reglas dicen: "Si vemos la direcci√≥n IP del servicio, debemos modificar la direcci√≥n de destino de la solicitud y enviarla a uno de los pods".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La direcci√≥n IP del servicio se usa solo como un punto de entrada y no es servida por ning√∫n proceso que escuche esta direcci√≥n IP y puerto. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Miremos eso</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .&nbsp;</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere un grupo de tres nodos. </font><font style="vertical-align: inherit;">Hay pods en cada nodo:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/605/ed6/e82/605ed6e82d24139c7122fd0886fb3f5f.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los hogares de punto pintados en beige son parte del servicio. </font><font style="vertical-align: inherit;">Como el servicio no existe como proceso, est√° atenuado:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/175/57b/919/17557b91988036bf15bdb5fd02b25c44.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El primero solicita el servicio y debe recaer en uno de los hogares relacionados:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13d/49c/2df/13d49c2dff1c5a15bfced3347ad4bc6c.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero el servicio no existe, no hay proceso. </font><font style="vertical-align: inherit;">¬øComo funciona?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7e/362/c43/a7e362c43d31ac5ba0368cbbfceae398.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de que la solicitud abandone el nodo, sigue las reglas de iptables:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29d/eea/0ef/29deea0efafef803b87c66a7c17cc9cc.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las reglas de iptables saben que no hay servicio y reemplazan su direcci√≥n IP con una de las direcciones IP de los pods asociados con este servicio:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4e/ec6/0ad/a4eec60ad28fbf16b085d9b8697dce81.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La solicitud recibe una direcci√≥n IP v√°lida como direcci√≥n de destino y normalmente se procesa:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/653/ef7/4b8/653ef74b8f34567652c2e0a00c89d9a7.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependiendo de la topolog√≠a de la red, la solicitud finalmente llega al hogar:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/696/c59/873/696c5987341d20780825ff2a4f6f7d12.png"></div></li>
</ol><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øSon iptables capaces de equilibrar la carga?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No, las iptables se usan para filtrar y no se dise√±aron para equilibrar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, es posible escribir un conjunto de reglas que funcionen como un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pseudo equilibrador</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y eso es exactamente lo que hace Kubernetes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si tiene tres pods, kube-proxy escribir√° las siguientes reglas:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elija el primero con una probabilidad del 33%, de lo contrario, vaya a la siguiente regla.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elija el segundo con una probabilidad del 50%, de lo contrario pase a la siguiente regla.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elige el tercero debajo.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tal sistema lleva al hecho de que cada sub se selecciona con una probabilidad del 33%.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08e/d59/2bc/08ed592bc03dd1f9740f29985451aaca.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y no hay garant√≠a de que bajo 2 se seleccionar√° despu√©s del archivo 1. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : iptables utiliza un m√≥dulo estad√≠stico de distribuci√≥n aleatoria. </font><font style="vertical-align: inherit;">Por lo tanto, el algoritmo de equilibrio se basa en una selecci√≥n aleatoria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora que comprende c√≥mo funcionan los servicios, veamos escenarios de trabajo m√°s interesantes.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las conexiones de larga duraci√≥n en Kubernetes no se escalan de forma predeterminada</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada solicitud HTTP desde el front-end hasta el back-end es atendida por una conexi√≥n TCP separada, que se abre y se cierra. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si el frontend env√≠a 100 solicitudes por segundo al backend, se abren y cierran 100 conexiones TCP diferentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede reducir el tiempo de procesamiento de la solicitud y reducir la carga si abre una conexi√≥n TCP y la usa para todas las solicitudes HTTP posteriores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El protocolo HTTP contiene una caracter√≠stica llamada HTTP keep-alive o reutilizaci√≥n de la conexi√≥n. En este caso, se usa una conexi√≥n TCP para enviar y recibir muchas solicitudes y respuestas HTTP:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a65/cef/c9f/a65cefc9f558265089c48cdf96a1d049.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta caracter√≠stica no est√° habilitada de manera predeterminada: tanto el servidor como el cliente deben configurarse en consecuencia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La configuraci√≥n en s√≠ es simple y accesible para la mayor√≠a de los lenguajes y entornos de programaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ hay algunos enlaces a ejemplos en diferentes idiomas:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://medium.com/%40onufrienkos/keep-alive-connection-on-inter-service-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keep-alive en Node.js</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://www.baeldung.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mantente vivo en la bota de primavera</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://blog.insightdatascience.com/learning-about-the-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keep-alive en Python</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://docs.microsoft.com/en-us/dotnet/api/system.net."><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keep-alive en .NET</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øQu√© pasa si usamos keep-alive en Kubernetes? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que tanto el frontend como el backend admiten mantener vivo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenemos una copia del frontend y tres copias del backend. El frontend realiza la primera solicitud y abre una conexi√≥n TCP al backend. La solicitud llega al servicio, uno de los pods del backend se selecciona como la direcci√≥n de destino. Env√≠a una respuesta al backend y la interfaz la recibe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A diferencia de la situaci√≥n habitual, cuando la conexi√≥n TCP se cierra despu√©s de recibir la respuesta, ahora se mantiene abierta para las siguientes solicitudes HTTP. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øQu√© sucede si el frontend env√≠a m√°s solicitudes de backend? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para reenviar estas solicitudes, se utilizar√° una conexi√≥n TCP abierta, todas las solicitudes se enviar√°n a la misma debajo del backend, donde se obtuvo la primera solicitud.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øNo deber√≠an iptables redistribuir el tr√°fico? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No en este caso </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando se crea una conexi√≥n TCP, sigue las reglas de iptables, que seleccionan una espec√≠fica para el backend donde ir√° el tr√°fico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como todas las siguientes solicitudes pasan por una conexi√≥n TCP ya abierta, las reglas de iptables ya no se invocan. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veamos como se ve</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El primer sub env√≠a una solicitud al servicio:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d1/235/11b/0d123511bd0e4e5d3806fdd7917e0bd7.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya sabes lo que suceder√° despu√©s. </font><font style="vertical-align: inherit;">El servicio no existe, pero hay reglas de iptables que manejar√°n la solicitud:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d1/235/11b/0d123511bd0e4e5d3806fdd7917e0bd7.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se seleccionar√° uno de los pods de backend como direcci√≥n de destino:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ae/5c0/e5b/9ae5c0e5bd3478f20d1546951a298dfd.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La solicitud llega al hogar. </font><font style="vertical-align: inherit;">En este punto, se establecer√° una conexi√≥n TCP permanente entre los dos pods:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b23/154/129/b23154129408fd401651880d3b94d816.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cualquier solicitud siguiente del primer pod pasar√° por una conexi√≥n ya establecida:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/e1c/232/f90e1c232dbc399d39aaff47045b9aa8.gif"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, obtuvo una respuesta m√°s r√°pida y un mayor ancho de banda, pero perdi√≥ la capacidad de escalar el back-end. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Incluso si tiene dos m√≥dulos en el back-end, con una conexi√≥n constante, el tr√°fico siempre ir√° a uno de ellos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øSe puede arreglar esto? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como Kubernetes no sabe c√≥mo equilibrar las conexiones persistentes, esta tarea es su responsabilidad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los servicios son un conjunto de direcciones IP y puertos llamados puntos finales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Su aplicaci√≥n puede obtener una lista de puntos finales del servicio y decidir c√≥mo distribuir las solicitudes entre ellos. Puede abrir una conexi√≥n persistente a cada hogar y equilibrar las solicitudes entre estas conexiones utilizando round-robin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O aplique </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmos de equilibrio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> m√°s </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">sofisticados</font></a><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El c√≥digo del lado del cliente responsable del equilibrio debe seguir esta l√≥gica:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtenga la lista de puntos finales del servicio.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para cada punto final, abra una conexi√≥n persistente.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando necesite hacer una solicitud, use una de las conexiones abiertas.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actualice regularmente la lista de puntos finales, cree otros nuevos o cierre conexiones persistentes antiguas si la lista cambia.</font></font></li>
</ol><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As√≠ es como se ver√°</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En lugar de enviar la primera solicitud al servicio, puede equilibrar las solicitudes en el lado del cliente:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98f/91a/0c9/98f91a0c9ecae76bd8f286ba3a282ff1.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debe escribir un c√≥digo que pregunte qu√© pods son parte del servicio:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/040/203/cb5/040203cb52d6b22bb8179a6870d2485f.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tan pronto como reciba la lista, gu√°rdela en el lado del cliente y √∫sela para conectarse a los pods:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e5/741/3e7/4e57413e7b01b017cf57fab312b28089.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usted mismo es responsable del algoritmo de equilibrio de carga:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/bc6/7ad/8d9bc67ad511790b477c8509c91fffb0.gif"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora la pregunta es: ¬øeste problema solo se aplica a HTTP keep-alive?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Balanceo de carga del lado del cliente</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTTP no es el √∫nico protocolo que puede usar conexiones TCP persistentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si su aplicaci√≥n usa una base de datos, la conexi√≥n TCP no se abre cada vez que necesita ejecutar una solicitud u obtener un documento de la base de datos.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cambio, se abre y utiliza una conexi√≥n TCP permanente a la base de datos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si su base de datos se implementa en Kubernetes y el acceso se proporciona como un servicio, entonces se encontrar√° con los mismos problemas que se describen en la secci√≥n anterior. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una r√©plica de la base de datos se cargar√° m√°s que el resto. </font><font style="vertical-align: inherit;">Kube-proxy y Kubernetes no ayudar√°n a equilibrar las conexiones. </font><font style="vertical-align: inherit;">Debe encargarse de equilibrar las consultas a su base de datos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seg√∫n la biblioteca que use para conectarse a la base de datos, puede tener varias opciones para resolver este problema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El siguiente es un ejemplo de acceso a un cl√∫ster de base de datos MySQL desde Node.js:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mysql'</span>);
<span class="hljs-keyword">var</span> poolCluster = mysql.createPoolCluster();<font></font>
<font></font>
<span class="hljs-keyword">var</span> endpoints = <span class="hljs-comment">/* retrieve endpoints from the Service */</span><font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> [index, endpoint] <span class="hljs-keyword">of</span> endpoints) {<font></font>
&nbsp; poolCluster.add(<span class="hljs-string">`mysql-replica-<span class="hljs-subst">${index}</span>`</span>, endpoint);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Make queries to the clustered MySQL database</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay muchos otros protocolos que usan conexiones TCP persistentes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WebSockets y WebSockets seguros</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gRPC</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RSockets</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMQP</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya debe estar familiarizado con la mayor√≠a de estos protocolos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero si estos protocolos son tan populares, ¬øpor qu√© no hay una soluci√≥n de equilibrio estandarizada? ¬øPor qu√© se requiere un cambio en la l√≥gica del cliente? ¬øExiste una soluci√≥n nativa de Kubernetes? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kube-proxy e iptables est√°n dise√±ados para cerrar la mayor√≠a de los escenarios de implementaci√≥n est√°ndar para Kubernetes. Esto es por conveniencia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si utiliza un servicio web que proporciona una API REST, tiene suerte: en este caso, no se utilizan conexiones TCP permanentes, puede utilizar cualquier servicio de Kubernetes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero tan pronto como comience a usar conexiones TCP persistentes, tendr√° que descubrir c√≥mo distribuir uniformemente la carga en los backends. Kubernetes no contiene soluciones preparadas para este caso.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, por supuesto, hay opciones que pueden ayudar.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Equilibrando conexiones duraderas en Kubernetes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes tiene cuatro tipos de servicios:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clusterip</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NodePort</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loadbalancer</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin cabeza</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los primeros tres servicios se basan en la direcci√≥n IP virtual, que es utilizada por kube-proxy para construir reglas de iptables. </font><font style="vertical-align: inherit;">Pero la base fundamental de todos los servicios es un servicio de tipo sin cabeza. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ninguna direcci√≥n IP est√° asociada con el servicio sin cabeza, y solo proporciona un mecanismo para obtener una lista de direcciones IP y puertos de hogares asociados (puntos finales). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos los servicios se basan en el servicio sin cabeza. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El servicio ClusterIP es un servicio sin cabeza con algunas adiciones:&nbsp;</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La capa de administraci√≥n le asigna una direcci√≥n IP.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kube-proxy forma las reglas necesarias de iptables.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, puede ignorar kube-proxy y usar directamente la lista de puntos finales recibidos del servicio sin cabeza para equilibrar la carga en su aplicaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero, ¬øc√≥mo agregar una l√≥gica similar a todas las aplicaciones implementadas en un cl√∫ster? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si su aplicaci√≥n ya est√° implementada, tal tarea puede parecer imposible. </font><font style="vertical-align: inherit;">No obstante, hay una alternativa.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Service Mesh te ayudar√°</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probablemente ya haya notado que la estrategia de equilibrio de carga del lado del cliente es bastante est√°ndar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando se inicia la aplicaci√≥n, esta:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtiene una lista de direcciones IP del servicio.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abre y mantiene un grupo de conexiones.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actualiza peri√≥dicamente el grupo, agregando o eliminando puntos finales.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tan pronto como la aplicaci√≥n quiera hacer una solicitud, esta:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selecciona una conexi√≥n disponible utilizando alg√∫n tipo de l√≥gica (por ejemplo, round-robin).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cumple la solicitud</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estos pasos funcionan para WebSockets, gRPC y AMQP. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede separar esta l√≥gica en una biblioteca separada y usarla en sus aplicaciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, se pueden utilizar cuadr√≠culas de servicio como Istio o Linkerd. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Service Mesh complementa su aplicaci√≥n con un proceso que:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Busca autom√°ticamente las direcciones IP de los servicios.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comprueba conexiones como WebSockets y gRPC.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Balancea las solicitudes utilizando el protocolo correcto.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Service Mesh ayuda a administrar el tr√°fico dentro del cl√∫ster, pero requiere bastante recursos. </font><font style="vertical-align: inherit;">Otras opciones son utilizar bibliotecas de terceros, como Netflix Ribbon, o servidores proxy programables, como Envoy.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© sucede si ignoras los problemas de equilibrio?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No puede usar el equilibrio de carga y no notar ning√∫n cambio. Veamos algunos escenarios de trabajo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si tiene m√°s clientes que servidores, este no es un gran problema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que hay cinco clientes que se conectan a dos servidores. Incluso si no hay equilibrio, se utilizar√°n ambos servidores:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3eb/2a3/ebf/3eb2a3ebfd09862d4200744170daec7e.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las conexiones se pueden distribuir de manera desigual: tal vez cuatro clientes conectados al mismo servidor, pero hay una buena posibilidad de que se utilicen ambos servidores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo que es m√°s problem√°tico es el escenario opuesto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si tiene menos clientes y m√°s servidores, es posible que sus recursos no se utilicen lo suficiente y aparezca un posible cuello de botella. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que hay dos clientes y cinco servidores. </font><font style="vertical-align: inherit;">En el mejor de los casos, habr√° dos conexiones permanentes a dos de cada cinco servidores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otros servidores estar√°n inactivos:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee5/0d2/eaf/ee50d2eaf1dbefd5933dd9ec5221bd58.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si estos dos servidores no pueden manejar el procesamiento de solicitudes del cliente, la escala horizontal no ayudar√°.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusi√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los servicios de Kubernetes est√°n dise√±ados para funcionar en la mayor√≠a de los escenarios de aplicaciones web est√°ndar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, tan pronto como comience a trabajar con protocolos de aplicaci√≥n que usan conexiones TCP persistentes, como bases de datos, gRPC o WebSockets, los servicios ya no son adecuados. </font><font style="vertical-align: inherit;">Kubernetes no proporciona mecanismos internos para equilibrar las conexiones TCP persistentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto significa que debe escribir aplicaciones con la posibilidad de equilibrar en el lado del cliente. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traducci√≥n preparado por un equipo </font></font></i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes aaS a partir de Mail.ru</font></font></i></a><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font></i><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu√© m√°s leer sobre el tema</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tres niveles de autoescalado en Kubernetes y c√≥mo usarlos de manera efectiva</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .&nbsp;</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes en el esp√≠ritu de la pirater√≠a con una plantilla de implementaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   Kubernetes  </a>.</li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es493808/index.html">C√≥digo asincr√≥nico linealizado con corutina</a></li>
<li><a href="../es493810/index.html">Cinco a√±os de desarrollo intensivo del mercado para el reconocimiento de documentos.</a></li>
<li><a href="../es493814/index.html">C√≥mo realizamos entrevistas en Barcelona</a></li>
<li><a href="../es493816/index.html">Git Guide N√∫mero de parte 1: todo lo que necesita saber sobre el directorio .git</a></li>
<li><a href="../es493818/index.html">Git Guide Parte n√∫mero 2: la regla de oro y otros conceptos b√°sicos de rebase</a></li>
<li><a href="../es493822/index.html">Problemas y caracter√≠sticas de la implementaci√≥n de UEFI en varias plataformas</a></li>
<li><a href="../es493826/index.html">Divide y vencer√°s: mejora la electr√≥lisis del agua</a></li>
<li><a href="../es493828/index.html">C√≥mo la interfaz cuenta historias en videojuegos</a></li>
<li><a href="../es493830/index.html">¬øQu√© preguntas hace el desarrollador junior de iOS en las primeras entrevistas?</a></li>
<li><a href="../es493832/index.html">Panel de distribuci√≥n de Coronavirus COVID-19 (React + Chart.js + BootstrapTable)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>