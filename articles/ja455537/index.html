<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🏭 🔪 🤹🏽 広範な検索の最適化：100億状態のグラフを処理する方法 🥩 💖 😑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="数か月前、私はようやく、スネークバードパズルのいくつかのレベルを通過するほど賢くなかったことを認めなければなりませんでした。自尊心を取り戻す唯一の方法は、ソルバーを書くことでした。したがって、パズルを解くプログラムを作成することは、自分で解くこととほとんど同じであると偽ることができます。結果のC +...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>広範な検索の最適化：100億状態のグラフを処理する方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455537/"><div style="text-align:center;"><img src="https://nordicgame.com/wp-content/uploads/2015/05/noumenon.games_.snakebird.850.560.jpg" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数か月前、私はようやく、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スネークバード</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パズルのいくつかのレベルを通過するほど賢くなかったことを認めなければなりませんでした</font><font style="vertical-align: inherit;">。自尊心を取り戻す唯一の方法は、ソルバーを書くことでした。したがって、パズルを解くプログラムを作成することは、自分で解くこととほとんど同じであると偽ることができます。結果のC ++プログラムのコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で入手できます</font><font style="vertical-align: inherit;">。この記事で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取り上げ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たコードの主要部分は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">search.h</font></a><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compress.hに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装されてい</font><font style="vertical-align: inherit;">ます。この記事では、幅優先検索の最適化について主に説明します。これは、4 GBに収まるように50〜100 GBのメモリを必要とします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
後で、ゲームの詳細を説明する別の投稿を書きます。この投稿では、ブルートフォースに代わる優れた方法が見つからなかったということを知っておく必要があります。動くオブジェクトや押し出されたオブジェクトがたくさんあり、そのうちのいくつかの形状が重要であるので、ゲームには多くの状態があり、時間とともに変化する可能性があります。サーチスペースを狭めるA *のようなアルゴリズムに適した保守的なヒューリスティックはありませんでした。検索グラフは方向性があり暗黙的に指定されていたため、順方向と逆方向の同時検索は不可能でした。唯一の動きは、多くの無関係な方法で状態を変更する可能性があるため、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zobristをハッシュ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するほど便利なものはありません</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大まかな見積もりでは、最大のパズルでは、すべての対称的な位置を排除した後、約100億の状態が存在することが示されています。状態の説明を最大密度でパックした後でも、状態のサイズは8〜10バイトでした。 100 GBのメモリがあれば、タスクは取るに足らないものになりますが、16 GBのメモリを搭載した私の自宅のマシンには当てはまりません。また、Chromeには12 GB必要なので、実際のメモリ供給は4 GBに近くなります。このボリュームを超えるものはすべてディスク（古くて錆びたハードドライブ）に保存する必要があります。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4 GBのRAMに100 GBのデータを収めるには？</font><font style="vertical-align: inherit;">a）状態は元の最適化されたサイズの1/20に圧縮する必要がある、またはb）アルゴリズムは状態をディスクとの間で効率的に保存できる必要がある、またはc）上記の2つの方法の組み合わせ、またはd）追加購入する必要があるRAMまたは強力な仮想マシンを数日間レンタルします。</font><font style="vertical-align: inherit;">退屈すぎるので、オプションDは考慮しませんでした。</font><font style="vertical-align: inherit;">オプションAおよびBは、gzipを使用した概念実証の後に除外されました。50MBの状態記述のフラグメントは、35 MBのみに圧縮されました。</font><font style="vertical-align: inherit;">これは状態ごとに約7バイトであり、私のメモリは状態ごとに約0.4バイトです。</font><font style="vertical-align: inherit;">つまり、幅優先検索がセカンダリドライブのストレージにかなり不便に思われたとしても、オプションBは残りました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはかなり長い記事なので、以下のセクションの概要を示します。</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">教科書での</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幅優先検索-通常の幅優先検索（BFS）の表現は何ですか。また、状態の一部をディスクに保存するのに適さないのはなぜですか。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並べ替えとマージによるBFS-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">冗長データの効率的なバッチ処理のためのアルゴリズムの変更。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">圧縮</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -標準圧縮とネイティブ圧縮の組み合わせにより、メモリ使用量を100分の1に削減します。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おおお、ごまかした！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-最初のセクションで、私は何かについて沈黙を守りました。ソリューションがどこにあるかを知るだけでは十分ではありませんが、それを達成する方法を正確に理解する必要があります。</font><font style="vertical-align: inherit;">このセクションでは、基本アルゴリズムを更新して、最後の状態からソリューションを再作成するのに十分なデータを転送します。</font></font></li>
<li><b> +    </b> —          .   +   ,       : ,  ,    ,          .</li>
<li><b></b> —   Linux  ,   .</li>
<li><b>    </b> —           .  ,       ,    .           .</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">親の状態でスペースを節約</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する-CPU /メモリを使用して最終的にソリューションを再作成することのトレードオフを調べます。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">うまくいかなかったり、うまくいかなかったりするもの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -有望に思えたアイデアもありますが、結果としてそれらをロールバックする必要がありましたが、研究者と思われる他のアイデアは、直感的にこの場合は不適切に思えました。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「教科書による」ワイド検索</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幅優先検索はどのように見え、ディスクを使用しないのはなぜですか？</font><font style="vertical-align: inherit;">この小さなプロジェクトの前は、たとえば「教科書から」という言い回しのオプションのみを検討していました。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">graph, start, end</span>):</span><font></font>
    visited = {start}<font></font>
    todo = [start]<font></font>
    <span class="hljs-keyword">while</span> todo:<font></font>
        node = todo.pop_first()<font></font>
        <span class="hljs-keyword">if</span> node == end:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">for</span> kid <span class="hljs-keyword">in</span> adjacent(node):
            <span class="hljs-keyword">if</span> kid <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<font></font>
                visited.add(kid)<font></font>
                todo.push_back(kid)<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムによって新しい候補ノードを作成するプロセスでは、各ノードは、すでに訪問したノードのハッシュテーブルでチェックされます。ハッシュテーブルに既にある場合、ノードは無視されます。それ以外の場合は、キューとハッシュテーブルに追加されます。実装では、「訪問済み」の情報が外部テーブルではなくノードに入力される場合があります。しかし、これは危険な最適化であり、グラフが暗黙的に指定されている場合は完全に不可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハッシュテーブルの使用に問題があるのはなぜですか？ハッシュテーブルは完全にランダムなメモリアクセスパターンを作成する傾向があるためです。そうでない場合、これは悪いハッシュ関数であり、衝突のためにハッシュテーブルのパフォーマンスが低下する可能性があります。データがメモリに収まる場合でも、このランダムアクセスパターンはパフォーマンスの問題を引き起こす可能性があります。巨大なハッシュテーブルへのアクセスは、キャッシュミスや連想変換バッファ（TLB）を引き起こす可能性があります。しかし、データの大部分がメモリ上ではなくディスク上にある場合はどうでしょうか。結果は壊滅的なものになります：検索操作ごとに10ミリ秒のオーダーの何か。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
100億の一意の状態があるため、ハッシュテーブルにアクセスするだけで、ディスクI / Oを待つのに約4か月かかります。</font><font style="vertical-align: inherit;">これは私たちには合いません。</font><font style="vertical-align: inherit;">プログラムが大きなデータパケットを1回のパスで処理できるように、タスクは絶対に変換する必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並べ替えとマージを行うBFS</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データアクセス操作を可能な限りパッケージに統合したい場合、達成可能な最大の近似値は何でしょうか。プログラムは、層Nが完全に処理されるまで、深さN + 1の層で処理するノードを認識しないため、深さごとに少なくとも1回は状態を重複排除する必要があることは明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レイヤー全体を同時に操作する場合、ハッシュテーブルを放棄し、訪問済みの状態と新しい状態のセットを並べ替えられたストリーム（ファイルストリーム、配列、リストなど）として記述できます。ストリームのセットを組み合わせることにより、新しく訪問したセットを簡単に見つけることができます。また、セットの違いを使用してTODOセットを簡単に見つけることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セットを持つ2つの操作を組み合わせて、両方のスレッドで1つのパスで機​​能するようにできます。実際、両方のストリームを調べ、小さい方の要素を処理してから、要素の取得元のストリームに沿って（または、最初の要素が同じ場合は両方のフローに沿って）進みます。どちらの場合も、アイテムを新しい訪問済みセットに追加します。次に、新しい状態のストリームに沿って進み、要素を新しいtodoセットに追加します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">graph, start, end</span>):</span><font></font>
    visited = Stream()<font></font>
    todo = Stream()<font></font>
    visited.add(start)<font></font>
    todo.add(start)<font></font>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
        new = []<font></font>
        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> todo:
            <span class="hljs-keyword">if</span> node == end:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
            <span class="hljs-keyword">for</span> kid <span class="hljs-keyword">in</span> adjacent(node):<font></font>
                new.push_back(kid)<font></font>
        new_stream = Stream()<font></font>
        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> new.sorted().uniq():<font></font>
            new_stream.add(node)<font></font>
        todo, visited = merge_sorted_streams(new_stream, visited)<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><font></font>
<font></font>
<span class="hljs-comment"># Merges sorted streams new and visited. Return a sorted stream of</span>
<span class="hljs-comment"># elements that were just present in new, and another sorted</span>
<span class="hljs-comment"># stream containing the elements that were present in either or</span>
<span class="hljs-comment"># both of new and visited.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_sorted_streams</span>(<span class="hljs-params">new, visited</span>):</span><font></font>
    out_todo, out_visited = Stream(), Stream()<font></font>
    <span class="hljs-keyword">while</span> visited <span class="hljs-keyword">or</span> new:
        <span class="hljs-keyword">if</span> visited <span class="hljs-keyword">and</span> new:
            <span class="hljs-keyword">if</span> visited.peek() == new.peek():<font></font>
                out_visited.add(visited.pop())<font></font>
                new.pop()<font></font>
            <span class="hljs-keyword">elif</span> visited.peek() &lt; new.peek():<font></font>
                out_visited.add(visited.pop())<font></font>
            <span class="hljs-keyword">elif</span> visited.peek() &gt; new.peek():<font></font>
                out_todo.add(new.peek())<font></font>
                out_visited.add(new.pop())<font></font>
        <span class="hljs-keyword">elif</span> visited:<font></font>
            out_visited.add(visited.pop())<font></font>
        <span class="hljs-keyword">elif</span> new:<font></font>
            out_todo.add(new.peek())<font></font>
            out_visited.add(new.pop())<font></font>
    <span class="hljs-keyword">return</span> out_todo, out_visited</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データアクセスパターンは完全に線形で予測可能なものになり、合併全体で任意のアクセスはありません。したがって、ディスク操作の遅延は私たちにとって重要ではなくなり、重要なままである唯一のものは帯域幅です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それぞれが1億の状態を持つ100の深さレベルにわたるデータの単純化された分布で、理論上のパフォーマンスはどのようになりますか？平均化された状態は、50回読み取られ、書き込まれます。これにより、10バイト/状態* 50億状態* 50 = 2.5 TBになります。私のハードディスクはおそらく100 MB /秒の平均速度で読み書きできます。つまり、平均してI / Oは（2 * 2.5 TB）/（100 MB /秒）=〜50k /秒=〜13時間かかります。これは、以前の結果（4か月）よりも数回少ない注文です！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、この簡略化されたモデルでは、新しく生成された状態のサイズが考慮されないことにも注意してください。</font><font style="vertical-align: inherit;">マージステップの前に、ソート+重複排除のためにそれらをメモリに保存する必要があります。</font><font style="vertical-align: inherit;">これについては、以下のセクションで説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">圧縮</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はじめに、最初の実験では、状態圧縮は有望に見えず、圧縮率は30％に過ぎなかったと述べました。</font><font style="vertical-align: inherit;">しかし、アルゴリズムに変更を加えた後、州は合理化されました。</font><font style="vertical-align: inherit;">圧縮がはるかに簡単になるはずです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この理論をテストするために、1460万の状態のパズルでzstdを使用しました。各状態のサイズは8バイトでした。</font><font style="vertical-align: inherit;">ソート後、平均して状態ごとに1.4バイトに圧縮されました。</font><font style="vertical-align: inherit;">深刻な前進のようです。</font><font style="vertical-align: inherit;">プログラム全体をメモリで実行するだけでは十分ではありませんが、ディスクのI / O時間を数時間に短縮できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ構造について何か知っていれば、現代の汎用圧縮アルゴリズムの結果を何らかの形で改善することは可能ですか？あなたはそれをほぼ確信することができます。この良い例がPNG形式です。理論的には、圧縮は単なる標準のDeflateパスです。ただし、生データを圧縮する代わりに、画像はまず</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">PNGフィルター</font></a><font style="vertical-align: inherit;">を使用して変換されます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 PNGフィルターは基本的に、前の行の同じバイトの値および/または前のピクセルの同じバイトの値に基づいて、生データのバイトの値を予測するための式です。たとえば、「アップ」フィルターは、圧縮時に前の行の値をそのバイトから差し引き、アンパック時に逆の操作を実行することにより、各バイトを変換します。 PNGが使用される画像のタイプを考えると、ほとんどの場合、結果はゼロまたはゼロに近い数値で構成されます。 Deflateは、生データよりもはるかに優れたデータを圧縮できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この原則をBFS状態レコードに適用できますか？これは可能なはずです。 PNGと同様に、ラインサイズは一定であり、隣接するラインは非常に似ていると予想できます。減算/加算フィルターを使用した最初のサンプル、その後にzstdを使用すると、圧縮率がさらに40％向上しました（状態あたり0.87バイト）。フィルタリング操作は簡単なので、CPU消費の観点から見ると、ほとんど「無料」です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他の改善が可能かどうか、またはこれが実際的な限界であるかどうかは、私にはわかりませんでした。画像データでは、同じ行の隣接するバイトが類似していると論理的に期待できます。しかし、これらの州ではそのようなことはありません。しかし、実際には、少し高度なフィルターを使用しても、結果を改善できます。結局、私はこのシステムに来ました：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
隣接する行R1 = [1、2、3、4]とR2 = [1、2、6、4]があるとします。 R2を出力するとき、各バイトを前の行の同じバイトと比較し、0は一致を示し、1は不一致を示します：diff = [0、0、1、0]。次に、このビットマップをVarIntとしてエンコードし、その後に前の行と一致しないバイトのみを渡します。この例では、2バイトの0b00000100 6を取得します。このフィルターだけで、参照データを2.2バイト/状態に圧縮します。ただし、+ zstdフィルターを組み合わせることにより、データサイズを0.42バイト/状態に削減しました。または、言い換えると、これは3.36ビット/ステートになります。これは、すべてのデータがRAMに収まるようにするために必要な概算の計算済みインジケーターよりも少し多いだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、ソートされたセットがより高密度になるため、圧縮率が向上します。メモリが問題を引き起こし始めるポイントに検索が到達すると、圧縮率が大幅に向上します。最大の問題は、最終的に46億の訪問国が訪れることです。ソート後、これらの状態は405 MBを占有し、上記のスキームに従って圧縮されます。これにより、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態ごとに0.7ビット</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が得られ</font><font style="vertical-align: inherit;">ます。結局、圧縮と解凍はプログラムのCPU時間の約25％を占めますが、これはメモリ消費量を100倍削減するための大きな妥協です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のフィルターは、各行にVarIntヘッダーがあるため、少しコストがかかります。低CPUコストまたは複雑さのわずかな増加を犠牲にしてアップグレードするのは簡単なようです。列ごとにデータを転置したり、大きなブロックにビットマスクを書き込んだりするなど、いくつかの異なるオプションを試しました。これらのオプションを単独で使用すると、はるかに高い圧縮率が得られますが、フィルター出力がzstdによって圧縮された場合、パフォーマンスは低下しました。そして、これはある種のzstdエラーではなく、gzipとbzip2の結果は同様であることが判明しました。この特定のタイプのコーディングが他のオプションよりも圧縮においてはるかに優れていることが判明した理由について、特に独創的な理論はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの謎：ビッグエンディアンではなくリトルエンディアンでデータを並べ替えると、圧縮率が大幅に向上することがわかりました。</font><font style="vertical-align: inherit;">最初は、リトルエンディアンの並べ替えでは、VarIntによってエンコードされたビットマスクを持つ先行ゼロが多いため、それが起こったと思いました。</font><font style="vertical-align: inherit;">ただし、このような依存関係を持たないフィルターを使用しても、この違いは持続します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（ソートされた整数のセットの圧縮は、検索エンジンの基本的なビルディングブロックであるため、多くの調査が行われています。しかし、一定の長さのソートされたレコードの圧縮についてはあまり情報がなく、推測したくありませんでした。任意の精度の整数値としてデータを提示しました。）</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おおお、ごまかした！</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
疑似コードでの上記のBFS実装はブール値のみを返すことに気づいたかもしれません-ソリューションが見つかった/見つからなかった。これは特に役に立ちません。ほとんどの場合、ソリューションの可用性を報告するだけでなく、ソリューションの正確な手順のリストを作成する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初はこの問題は簡単に解決できるようです。状態のセットを収集する代わりに、親状態との状態関係を収集する必要があります。次に、ソリューションを見つけたら、ペアレンタルソリューションのリストから最後から最初に戻るだけです。ハッシュテーブルベースのソリューションの場合、これは次のようになります。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">graph, start, end</span>):</span>
    visited = {start: <span class="hljs-literal">None</span>}<font></font>
    todo = [start]<font></font>
    <span class="hljs-keyword">while</span> todo:<font></font>
        node = todo.pop_first()<font></font>
        <span class="hljs-keyword">if</span> node == end:
            <span class="hljs-keyword">return</span> trace_solution(node, visited)
        <span class="hljs-keyword">for</span> kid <span class="hljs-keyword">in</span> adjacent(node):
            <span class="hljs-keyword">if</span> kid <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<font></font>
                visited[kid] = node<font></font>
                todo.push_back(kid)<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">trace_solution</span>(<span class="hljs-params">state, visited</span>):</span>
  <span class="hljs-keyword">if</span> state <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
    <span class="hljs-keyword">return</span> []
  <span class="hljs-keyword">return</span> trace_solution(start, visited[state]) + [state]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、これは前のセクションで得られたすべての圧縮の利点を破壊します。</font><font style="vertical-align: inherit;">それらは隣接する線が非常に類似しているという仮定に基づいています。</font><font style="vertical-align: inherit;">私たちが州そのものを見ると、これは真実です。</font><font style="vertical-align: inherit;">しかし、これが親の国に当てはまると信じる理由はありません。</font><font style="vertical-align: inherit;">実際、それらはランダムなデータです。</font><font style="vertical-align: inherit;">次に、並べ替えとマージのソリューションでは、各反復で表示されるすべての状態を読み書きする必要があります。</font><font style="vertical-align: inherit;">状態/親状態のリンクを保存するには、圧縮が不十分なデータすべてを反復ごとにディスクに読み書きする必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソート+複数の出力とマージ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、ソリューションに戻るとき、プログラムは状態/親状態のバンドルのみを必要とするため、2つのデータ構造を並列に格納できます。</font><font style="vertical-align: inherit;">Visitedは、以前にマージ中に再計算されたように、引き続き訪問された状態のセットになります。</font><font style="vertical-align: inherit;">親は、少なくとも、上書きされない状態/親状態のペアのソートされたリストです。</font><font style="vertical-align: inherit;">各マージ操作の後、状態+親状態のペアが親に追加されます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">graph, start, end</span>):</span><font></font>
    parents = Stream()<font></font>
    visited = Stream()<font></font>
    todo = Stream()<font></font>
    parents.add((start, <span class="hljs-literal">None</span>))<font></font>
    visited.add(start)<font></font>
    todo.add(start)<font></font>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
        new = []<font></font>
        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> todo:
            <span class="hljs-keyword">if</span> node == end:
                <span class="hljs-keyword">return</span> trace_solution(node, parents)
            <span class="hljs-keyword">for</span> kid <span class="hljs-keyword">in</span> adjacent(node):<font></font>
                new.push_back(kid)<font></font>
        new_stream = Stream()<font></font>
        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> new.sorted().uniq():<font></font>
            new_stream.add(node)<font></font>
        todo, visited = merge_sorted_streams(new_stream, visited, parents)<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><font></font>
<font></font>
<span class="hljs-comment"># Merges sorted streams new and visited. New contains pairs of</span>
<span class="hljs-comment"># key + value (just the keys are compared), visited contains just</span>
<span class="hljs-comment"># keys.</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># Returns a sorted stream of keys that were just present in new,</span>
<span class="hljs-comment"># another sorted stream containing the keys that were present in either or</span>
<span class="hljs-comment"># both of new and visited. Also adds the keys + values to the parents</span>
<span class="hljs-comment"># stream for keys that were only present in new.</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_sorted_streams</span>(<span class="hljs-params">new, visited, parents</span>):</span><font></font>
    out_todo, out_visited = Stream(), Stream()<font></font>
    <span class="hljs-keyword">while</span> visited <span class="hljs-keyword">or</span> new:
        <span class="hljs-keyword">if</span> visited <span class="hljs-keyword">and</span> new:<font></font>
            visited_head = visited.peek()<font></font>
            new_head = new.peek()[<span class="hljs-number">0</span>]
            <span class="hljs-keyword">if</span> visited_head == new_head:<font></font>
                out_visited.add(visited.pop())<font></font>
                new.pop()<font></font>
            <span class="hljs-keyword">elif</span> visited_head &lt; new_head:<font></font>
                out_visited.add(visited.pop())<font></font>
            <span class="hljs-keyword">elif</span> visited_head &gt; new_head:<font></font>
                out_todo.add(new_head)<font></font>
                out_visited.add(new_head)<font></font>
                out_parents.add(new.pop())<font></font>
        <span class="hljs-keyword">elif</span> visited:<font></font>
            out_visited.add(visited.pop())<font></font>
        <span class="hljs-keyword">elif</span> new:<font></font>
            out_todo.add(new.peek()[<span class="hljs-number">0</span>])<font></font>
            out_visited.add(new.peek()[<span class="hljs-number">0</span>])<font></font>
            out_parents.add(new.pop())<font></font>
    <span class="hljs-keyword">return</span> out_todo, out_visited</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、ランタイムとワークセットの両面で両方のアプローチを利用できますが、より多くのセカンダリストレージスペースが必要になります。</font><font style="vertical-align: inherit;">さらに、将来的には、他の理由により、訪問した州の個別のコピーが深さごとにグループ化されて役立つことがわかります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スワップ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
疑似コードでは、別の詳細は無視されます。ディスクI / Oの明示的なコードはなく、抽象的なStreamインターフェイスのみです。ストリームはファイルストリームでもメモリ内の配列でもかまいませんが、この実装の詳細は無視しました。代わりに、疑似コードは、ディスクの最適な使用を可能にするメモリアクセスパターンを作成しています。理想的な世界ではそれで十分であり、OSの仮想メモリサブシステムが残りを実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これは少なくともLinuxでは起こりません。ある時点（データのワーキングセットをメモリサイズに圧縮できるようになる前）に、プログラムを約11時間で実行し、データは主にディスクに保存されました。次に、ファイルに保存するのではなく匿名のページを使用するようにプログラムを設定し、同じドライブに十分なサイズのスワップファイルを選択しました。しかし、3日後、プログラムは4分の1しか進んでおらず、時間の経過とともにプログラムは遅くなりました。私の楽観的な見積もりによると、彼女は20日で仕事を終えるはずでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明確にします-同じコードで</font><i><font style="vertical-align: inherit;">まったく同じアクセスパターン</font></i><font style="vertical-align: inherit;">でした</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。変更された唯一の点は、メモリが明示的なディスクファイルとしてではなく、スワップとして保存されたことです。スワッピングがLinuxのパフォーマンスを完全に破壊するという証拠はほとんど必要ありませんが、通常のファイルI / Oはそうではありません。これは、プログラムがRAMをランダムアクセスメモリと見なす傾向があるためだといつも思っていました。しかし、そうではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイル保存ページと匿名ページは、仮想マシンサブシステムによって異なる方法で処理されることがわかります。これらは、有効期限ポリシーが異なる別のLRUキャッシュに保存されます。さらに、読み取り/読み込み先読みプロパティが異なるようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linuxでのスワッピングは、最適な条件下でもうまく機能しない可能性が高いです。</font><font style="vertical-align: inherit;">アドレススペースの一部がディスクにしばらくアンロードされる可能性がある場合は、スワップを信頼するよりも手動でファイルに保存することをお勧めします。</font><font style="vertical-align: inherit;">私は、最初はメモリでのみ機能する独自のベクトルのクラスを実装することでこれを達成し、特定のサイズのしきい値を超えた後、一時的な別のファイルでmmapに切り替えました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マージ前の新しい状態の圧縮</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡略化されたパフォーマンスモデルでは、各深度で1億の新しい条件が発生すると想定しました。これは現実からそれほど遠くないことが判明しました（最も複雑なパズルでは、最大で1億5,000万を超える、1つの深さの層に固有の新しい状態）。しかし、これは測定されるものではありません。マージ前のワーキングセットは、一意の状態だけでなく、この反復で推定されたすべての状態にも関連付けられています。この数値は、深度レイヤーあたり8億8千万の出力状態に達します。これらの8億8千万の状態は、a）並べ替えのためにランダムアクセスパターンで処理する必要がある、b）並べ替えがないため効果的に圧縮できない、c）親状態と一緒に保存する必要があるこのワーキングセットは約16 GBです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明白な解決策：ある種の外部ソートを使用します。すべての状態をディスクに書き込み、外部ソートを実行し、重複排除を行ってから、通常どおりマージを実行します。最初はこのソリューションを使用しましたが、問題Aはほとんど解消されましたが、BとCには対処できませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、別のアプローチを採用しました。状態をメモリ内の配列に収集しました。配列が大きくなりすぎると（たとえば、1億個を超える要素など）、配列はソート、重複排除、および圧縮されます。これにより、ソートされた状態の実行のパッケージが得られ、各実行内に重複はありませんが、実行間で重複する可能性があります。基本的に、新しい状態と訪問した状態をマージするコードは同じままです。それはまだ小川を徐々に通過することに基づいています。唯一の違いは、2つのストリームを単に通過する代わりに、新しい状態のソートされた実行ごとに個別のストリームが存在することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、これらの1億状態の実行の圧縮率は、すべての訪問状態のセットの圧縮ほど良くありません。</font><font style="vertical-align: inherit;">ただし、このようなインジケーターがあっても、ワーキングセットのボリュームとディスクI / Oの要件の両方のボリュームが大幅に減少します。</font><font style="vertical-align: inherit;">プライオリティキューを処理するにはもう少しCPUリソースが必要ですが、いずれにしてもそれは大きな妥協です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">親州の省スペース</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階では、プログラムが占めるスペースの大部分が親の状態の保存に費やされているため、ソリューションを見つけた後、そのプロセスを再現できます。</font><font style="vertical-align: inherit;">ほとんどの場合、それらをうまく絞ることはほとんどできませんが、CPUとメモリの間に何らかの妥協があるのでしょうか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
深さD + 1の状態Sをその深さDの親状態Sに接続する必要があります。考えられるすべての親の状態Sを反復処理できる場合、訪問したセットの深さDにそれらのいずれかが表示されるかどうかを確認できます。 。 （私たちはすでに、マージ中の状態/親状態のバンドルの派生の便利な副産物として、深さでグループ化された訪問済みの多くを作成しました）。残念ながら、このアプローチはこのタスクでは機能しません。与えられたS 'に対して、Sのすべての可能な状態を生成することは単純に困難です。ただし、他の多くの検索タスクでは、このようなソリューションが機能する場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状態間の遷移のみを生成でき、後退はできない場合は、なぜこれを実行しないのですか？深さDのすべての状態を繰り返し調べて、どのような出力状態が得られるかを見てみましょう。出力の一部の状態がS 'である場合、適切なSが見つかりました。この計画の問題は、プログラムの合計CPU消費量が50％増加することです。 （100％ではありません。平均して深さDの半分の状態を見るとSが見つかるためです）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、私は制限的なケースの1つを好きではありませんが、ここでは、少なくとも、CPU /メモリ間の妥協が可能です。</font><font style="vertical-align: inherit;">中間のどこかにもっと受け入れられる解決策はありますか？</font><font style="vertical-align: inherit;">最終的に、ペア（S '、S）ではなく、ペア（S'、H（S））を保存することにしました。ここで、Hは8ビットのハッシュ関数です。</font><font style="vertical-align: inherit;">与えられたS 'のSを見つけるために、再び深さDのすべての状態を繰り返し処理します。しかし、何かを行う前に、同じハッシュを計算します。</font><font style="vertical-align: inherit;">出力がH（S）と一致しない場合、これは私たちが探している状態ではなく、単にスキップすることができます。</font><font style="vertical-align: inherit;">この最適化により、コストのかかる再計算を実行する必要があるのは1/256状態のみであり、CPU負荷がわずかに増加すると同時に、親状態を格納するためのメモリ量が8〜10バイトから1バイトに減少します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能しなかった、または機能しなかった可能性があるもの</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前のセクションでは、機能する一連の高レベルの最適化について説明しました。機能しない、または文献で見つけた他のことを試しましたが、この特定のケースでは機能しないと判断しました。以下はリストの一部です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点では、各反復でアクセスしたセット全体を再計算しません。代わりに、ソートされた実行として保存され、これらの実行は時々圧縮されました。このアプローチの利点は、圧縮に使用されるディスク書き込みとCPUリソースが少なくなることです。欠点は、コードの複雑さが増し、圧縮率が低下することです。私の場合、書き込み操作は読み取りよりもコストがかかるため、最初はそのようなスキームは理にかなっていると思いました。しかし結局、圧縮率は2倍以上になりました。そのような妥協の利点は明らかではないので、結果として、私はより単純な形に戻りました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セカンダリストレージで暗黙的に定義されたグラフのボリューム横型検索を実行することについては、ほとんど研究が行われていません。このトピックの調査を開始できます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この2008年の記事から</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ご想像のとおり、重複排除と並べ替え+セカンダリストレージでのマージを行うという考えは新しいものではありません。驚いたのは、1993年に開店したことです。かなり遅い！並べ替え手順を必要としない二次ストレージでの幅優先検索の提案は後であります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらの1つは、状態を整数にバインドし、訪問した状態のビットマップをメモリに格納することでした。私の場合、エンコードされた状態のサイズは実際に到達可能な状態空間とは大きく異なるため、これはまったく役に立ちません。そして、そのようなアプローチが機能する興味深いタスクがあることを私は非常に疑っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の深刻な代替策は、一時ハッシュテーブルに基づいています。訪問済みの状態は、ファイルにソートせずに保存されます。深さDから取得した出力をハッシュテーブルに保存します。次に、訪問した状態を繰り返し巡回し、ハッシュテーブルでそれらを探します。アイテムがハッシュテーブルで見つかった場合は、削除します。ファイル全体を繰り返し走査した後、重複していない要素のみがファイルに残ります。次に、それらはファイルに追加され、次の反復のためにtodoリストを初期化するために使用されます。出力データの量が多すぎてハッシュテーブルがメモリに収まらない場合、ファイルとハッシュテーブルの両方を同じ基準（たとえば、上位ステータスビット）を使用して部分に分割でき、各部分は個別に処理する必要があります。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ベンチマーク</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
はあり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ますが</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハッシュベースのアプローチは、ソート+マージよりも約30％高速であることを示していますが、圧縮を考慮していないようです。私は圧縮の利点の拒絶がそれ自体を正当化することができる方法を見なかったので、私はそのようなアプローチで実験さえしませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注目に値する研究のもう一つの領域は、データベースクエリの最適化でした。のようです。重複排除タスクは結合データベースに強く関連しており、データベースの結合</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">とハッシュの</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジレンマ</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はまったく同じです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">明らかに、これらの研究のいくつかは検索問題に適用できます。</font><font style="vertical-align: inherit;">違いは、結合データベースの出力が一時的なものであり、BFS重複排除の出力が計算の終わりまで保存されることです。</font><font style="vertical-align: inherit;">これにより、妥協のバランスが変化しているようです。これは、1つの反復の最も効率的な処理だけでなく、次の反復に最適な出力データ形式の作成にも関係しています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、ブルートフォースによって他の検索タスクに一般的に適用できるプロジェクトから学んだことの私の説明は終わりです。</font><font style="vertical-align: inherit;">これらのトリックの組み合わせにより、ゲームの最も複雑なパズルのソリューションの量を50〜100 GBから500 MBに減らし、タスクが使用可能なメモリを超えてディスクに書き込まれた場合にコストをスムーズに増やすことができました。</font><font style="vertical-align: inherit;">さらに、私のソリューションは、メモリに収まるパズルであっても、ハッシュテーブルに基づく状態の単純な重複排除よりも50％高速です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Snakebirdは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Steam</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google Play、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">App Store</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で購入できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">非常に複雑だが正直なパズルに興味がある人には、ぜひお勧めします。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja455525/index.html">ジンブラとメール爆弾防御</a></li>
<li><a href="../ja455527/index.html">これには何が書いてあるの？JavaScriptオブジェクトの舞台裏</a></li>
<li><a href="../ja455529/index.html">自己暗号化外付けAigo HDDを逆にしてハッキングする。パート2：サイプレスPSoCでのダンプ</a></li>
<li><a href="../ja455533/index.html">バブル物理学：泡破壊メカニズムの探索</a></li>
<li><a href="../ja455535/index.html">クラウドとコンテナでのSSL / TLS証明書の管理-人間の作業ではない</a></li>
<li><a href="../ja455539/index.html">モバイルサイキック：ウェアラブルデバイスがあなたを見ている様子に関する10の新しい事実</a></li>
<li><a href="../ja455543/index.html">Kubernetes Clusterは準備が簡単で便利ですか？アドオンオペレーターを発表する</a></li>
<li><a href="../ja455545/index.html">ゼロからのプロセスの構築：カオスからオーダーまで</a></li>
<li><a href="../ja455547/index.html">ロシア語のモノのインターネット。RTL-SDRオーナー向けのベースバンドホテルLoRaWAN</a></li>
<li><a href="../ja455549/index.html">Facebookグループを使用して宣伝する方法：Webを作成する</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>