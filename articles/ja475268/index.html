<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎲 🧗🏼 👩🏿‍🤝‍👩🏽 C ++およびJavaでアプリケーションアーキテクチャを構築するための普遍的な方法としての不確実なパラメーター化。価格 🆕 👨🏻‍🎓 🖐🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++は混乱を招く言語であり、その主な欠点は、コードの独立したブロックを作成することが難しいことです。典型的なプロジェクトでは、すべてがすべてに依存します。この記事では、特定のライブラリー（標準ライブラリーを含む）、実装にほとんど依存しない高度に絶縁されたコードを作成して、コードの一部がインターフ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C ++およびJavaでアプリケーションアーキテクチャを構築するための普遍的な方法としての不確実なパラメーター化。価格</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475268/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++は混乱を招く言語であり、その主な欠点は、コードの独立したブロックを作成することが難しいことです。典型的なプロジェクトでは、すべてがすべてに依存します。この記事では、特定のライブラリー（標準ライブラリーを含む）、実装にほとんど依存しない高度に絶縁されたコードを作成して、コードの一部がインターフェースのセットに依存しないようにする方法を示します。さらに、コードのパラメーター化のためのアーキテクチャソリューションが提案されます。これは、C ++プログラマーだけでなく、Javaプログラマーにとっても興味深いものです。そして重要なことは、提案されたソリューションは開発時間の面で非常に経済的です。</font></font><br>
<a name="habracut"></a><br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">免責事項</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：この記事では、理想的なアーキテクチャに関するアイデアを集めました。一部のアイデアは私のものではありませんが（誰のアイデアか覚えていません）、一部のアイデアはありふれたものであり、誰にでも知られています。これは重要ではありません。優れたアーキテクチャに関するアイデアは提供していませんが、このアーキテクチャに最低価格でアプローチできる特定のコードを提供しているためです。</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">免責事項N2</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：言葉で表現された建設的なフィードバックに満足します。あなたが私より理解が悪く、私を叱る場合、それはどこかで私が明確に十分に説明していないことを意味し、テキストを書き直すことは理にかなっています。私より理解が深ければ、貴重な経験ができるということです。前もって感謝します。</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">免責事項N3</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：大きなアプリケーションを最初から作成しましたが、サーバーおよびクライアントのエンタープライズアプリケーションは作成しませんでした。ここではすべてが異なり、おそらく私の経験はこの分野の専門家には奇妙に思えるでしょう。そして、記事はそれについてではなく、同じスケーラビリティの問題はここではまったく考慮されていません。</font></font><br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">免責事項N4</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Upd。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コメントに基づいて）：一部のコメンテーターは、私がファウラーを再発明し、長く知られたデザインパターンを提供することを提案しています。これは間違いなくそうではありません。最小限の落書きでこれらのパターンを実装できる非常に小さなパラメーター化ツールを提案します。 FowlerのDependency InjectionとService Locatorを含めるだけでなく、TypedSetクラスを使用して、一連の戦略を経済的に実装することもできます。この場合、ファウラーは回線を介してアクセスしましたが、これはコストがかかります-私のゼロコストツール、ゼロコスト（絶対に厳密に言えば、2M * log（N）ではなくlog（N）です。ここで、Mはサービスロケーターのパラメーター文字列の長さです。 c ++ 20でのconstexpr typeidの出現後、価格は完全にゼロになるはずです）。したがって、記事の意味をデザインパターンに拡張しないでください。ここには</font><b><i><font style="vertical-align: inherit;">メソッド</font></i></b><font style="vertical-align: inherit;">しかありません</font></font><b><i><font style="vertical-align: inherit;"></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらのパターンの安価な実装。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例はC ++になりますが、言われていることはすべてJavaで実現可能です。</font><font style="vertical-align: inherit;">おそらく、時間が経つにつれ、あなたからのコメントにリクエストがある場合は、Java用のコードを提供する予定です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート1.真空の球形アーキテクチャー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての困難を見事に解決する前に、それらを正しく作成する必要があります。</font><font style="vertical-align: inherit;">適切な場所で自分自身のために困難を巧みに作成すると、その解決策を大幅に促進できます。</font><font style="vertical-align: inherit;">このために、私たちは方法を考え出す解決策の目標を策定します-優れたアーキテクチャの最小原則。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、優れたアーキテクチャの魔法は2つの原則にすぎず、以下に書かれているのは単なるデコードです。最初の原則は、コードのテスト容易性です。テスト容易性は、優れたアーキテクチャに導くアリアドネのスレッドのようなものです。機能のテストを作成する方法がわからない場合は、アーキテクチャが損なわれています。優れたアーキテクチャを作成する方法がわからない場合は、計画した機能に対するテストを考えてください。そうすれば、アーキテクチャの品質が非常に高く、非常に高いレベルのバーが自動的に作成されます。テストを検討すると、モジュール性が自動的に向上し、接続性が低下し、アーキテクチャがより論理的になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして私はTDDを意味しません。多くのプログラマーの典型的な病気は、その有効性の限界を理解せずにどこかで読まれたテクノロジーの宗教的崇拝です。 TDDは、複数のプログラマーがコードに取り組んでいるとき、テスト部門があり、当局が優れたコーディングプラクティスが必要な理由を理解していて、問題を解決する一部のコードだけでなく、その信頼性に対しても支払う準備ができている場合に適しています。上司が支払う準備ができていない場合は、より経済的に働く必要があります。それでもなお、コードをテストする必要があります-もちろん、あなたが自己保持の感覚を持っていない限り。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二の原則はモジュール性です。</font><font style="vertical-align: inherit;">より正確には、モジュール自体に関連しないライブラリ/ハードコードを使用しない、高度に絶縁されたモジュール性。</font><font style="vertical-align: inherit;">サーバーアーキテクチャを設計するとき、モノリスをマイクロサービスに分割することはファッショナブルです。</font><font style="vertical-align: inherit;">ひどい秘密をお伝えします-モノリスの各モジュールはマイクロサービスのようでなければなりません。</font><font style="vertical-align: inherit;">テスト環境では、最小限の接続ヘッダーで一般的なコードから簡単に目立つ必要があるという意味で。</font><font style="vertical-align: inherit;">それはまだ明確ではありませんが、例を挙げて説明します：ブーストからshared_ptrを割り当てようとしたことがありますか？</font><font style="vertical-align: inherit;">同時にブースト全体だけでなく、原材料の半分だけをドラッグすることに成功した場合、それは不要な依存症を断つために3〜5日を殺したことを意味します!!! </font><font style="vertical-align: inherit;">同時に、それは間違いなくshared_ptrとは何の関係もないという事実に沿ってドラッグします!!!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてそれは間違いよりも悪いです-それは建築犯罪です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
優れたアーキテクチャがあれば、shared_ptrに関係のないすべてのものをテストバージョンで苦痛なく迅速に置き換えることで、shared_ptrを切り離すことができるはずです。たとえば、アロケータのテストバージョン。または、ブーストを忘れます。 xml / htmlパーサーを作成するとします。文字列を操作し、パーサーのファイルを操作する必要があります。また、特定のプロダクション/ソフトウェア会社のニーズに結び付けられていない理想的なアーキテクチャについて話している場合、理想的なアーキテクチャを持つパーサーには、std :: istream、std :: file_system、std ::文字列、および文字列を使用したハードコード検索操作を使用する権利がありません。パーサーで。ストリームインターフェイス、ファイル操作用のインターフェイス（おそらくサブインターフェイスに分割されますが、サブインターフェイスへのアクセスはファイル操作モジュールのインターフェイスを介して行う必要があります）、文字列を操作するためのインターフェイスを提供する必要があります。アロケータインターフェイス、理想的には回線自体のインターフェイス。その結果、解析に関係のないすべてのものをテストブランクで簡単に置き換えることができます。または、アロケータのテストバージョンを挿入する/ファイルを処理する/追加のチェックを行う文字列検索を行うことができます。そして、ソリューションの汎用性が高まります-明日はストリームのインターフェースの下にファイルはなく、インターネット上のどこかにあるサイトがあり、誰もそれに気付かないでしょう。標準ライブラリをQtに置き換えてから、ビジュアルc ++に切り替えて、Linuxのものだけを使い始めることができます-変更は最小限になります。ネタバレとして、このアプローチでは、完全な成長で価格の問題が発生すると言います。標準ライブラリの要素を含むすべてをインターフェースで閉じるのはコストがかかりますが、これは目標ではなく解決策です。その結果、解析に関係のないすべてのものをテストブランクで簡単に置き換えることができます。または、アロケータのテストバージョンを挿入する/ファイルを処理する/追加のチェックを行う文字列検索を行うことができます。そして、ソリューションの汎用性が高まります-明日はストリームのインターフェースの下にファイルはなく、インターネット上のどこかにあるサイトがあり、誰もそれに気付かないでしょう。標準ライブラリをQtに置き換えてから、ビジュアルc ++に切り替えて、Linuxのものだけを使い始めることができます-変更は最小限になります。ネタバレとして、このアプローチでは、完全な成長で価格の問題が発生すると言います。標準ライブラリの要素を含むすべてをインターフェースで閉じるのはコストがかかりますが、これは目標ではなく解決策です。その結果、解析に関係のないすべてのものをテストブランクで簡単に置き換えることができます。または、アロケータのテストバージョンを挿入する/ファイルを処理する/追加のチェックを行う文字列検索を行うことができます。そして、ソリューションの汎用性が高まります-明日はストリームのインターフェースの下にファイルはなく、インターネット上のどこかにあるサイトがあり、誰もそれに気付かないでしょう。標準ライブラリをQtに置き換えてから、ビジュアルc ++に切り替えて、Linuxのものだけを使い始めることができます-変更は最小限になります。ネタバレとして、このアプローチでは、完全な成長で価格の問題が発生すると言います。標準ライブラリの要素を含むすべてをインターフェースで閉じるのはコストがかかりますが、これは目標ではなく解決策です。または、アロケータのテストバージョンを挿入する/ファイルを操作する/追加のチェックを行う文字列検索。そして、ソリューションの汎用性が高まります-明日はストリームのインターフェースの下にファイルはなく、インターネット上のどこかにあるサイトがあり、誰もそれに気付かないでしょう。標準ライブラリをQtに置き換えてから、ビジュアルc ++に切り替えて、Linuxのものだけを使い始めることができます-変更は最小限になります。ネタバレとして、このアプローチでは、完全な成長で価格の問題が発生すると言います。標準ライブラリの要素を含むすべてをインターフェースで閉じるのはコストがかかりますが、これは目標ではなく解決策です。または、アロケータのテストバージョンを挿入する/ファイルを操作する/追加のチェックを行う文字列検索。そして、ソリューションの汎用性が高まります-明日はストリームのインターフェースの下にファイルはなく、インターネット上のどこかにあるサイトがあり、誰もそれに気付かないでしょう。標準ライブラリをQtに置き換えてから、ビジュアルc ++に切り替えて、Linuxのものだけを使い始めることができます-変更は最小限になります。ネタバレとして、このアプローチでは、完全な成長で価格の問題が発生すると言います。標準ライブラリの要素を含むすべてをインターフェースで閉じるのはコストがかかりますが、これは目標ではなく解決策です。その後、ビジュアルc ++に移動し、Linuxのものだけを使い始めます-変更は最小限になります。ネタバレとして、このアプローチでは、完全な成長で価格の問題が発生すると言います。標準ライブラリの要素を含むすべてをインターフェースで閉じるのはコストがかかりますが、これは目標ではなく解決策です。その後、ビジュアルc ++に移動し、Linuxのものだけを使い始めます-変更は最小限になります。ネタバレとして、このアプローチでは、完全な成長で価格の問題が発生すると言います。標準ライブラリの要素を含むすべてをインターフェースで閉じるのはコストがかかりますが、これは目標ではなく解決策です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、この記事で宣言されている過激なmodule-as-microserviceの原則は、C ++の痛ましい点であり、一般的には典型的なplus codeです。宣言ファイルを作成し、実装とは別にインターフェイスを分離する場合でも、cppファイルの独立性と分離を作成できます。100％ではなく、相対的である場合、ヘッダーは通常、固いモノリスに織り込まれ、そこから肉を抜き取ることはできません。そして、これはコンパイル時間にひどい影響を与えますが、そうです。さらに、たとえ見出しの独立性が達成されたとしても、これは自動的にクラスを集約できないことを意味します。実際、c ++で.cppファイルとヘッダーの両方の独立性を実現する唯一の方法は、事前に使用されたクラスを（定義せずに）宣言し、それらへのポインターのみを使用することです。ヘッダーファイルでクラスポインターの代わりにクラス自体を使用する（つまり、それを集約する）とすぐに、この見出しとクラス定義を含む.cpp-shnikを含むすべての.cpp-shnikの束が作成されます。 fastpimplもありますが、cppレベルで依存関係が作成されることが保証されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、優れたアーキテクチャでは、モジュールの分離が重要です。1つ目のモジュールはマクロとライブラリの主要なタイプを接続し、2つ目のヘッダーは宣言といくつかのインクルードによって一連のインターフェースを接続します。そして、この機能に関連するものだけ、そして他のすべてのものは他のモジュールに保存され、インターフェースを通じてのみアクセスできるべきです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のポイントを含む、優れたアーキテクチャの主な特徴をポイントごとに定式化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「モジュール」という用語を定義しましょう。モジュールは、論理的に関連する機能の合計です。たとえば、ストリームやファイルの作業、またはHTMLパーサーで作業します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「ファイル作業」モジュールは、ファイルを開く、閉じる、配置する、プロパティを読み取る、ファイルサイズを読み取るなど、多くの機能を組み合わせることができます。</font><font style="vertical-align: inherit;">同時に、フォルダースキャナーは、「ファイル作業」インターフェイスの一部として設計することも、別のモジュールとして設計することもでき、ストリームを使用する作業は、確実に別のモジュールに配置できます。</font><font style="vertical-align: inherit;">ただし、これにより、「ファイル作業」を通じて間接的にストリームやフォルダスキャナへの他のすべてのモジュールへのアクセスを整理することは妨げられません。</font><font style="vertical-align: inherit;">これは必須ではありませんが、かなり論理的です。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュール性。</font><font style="vertical-align: inherit;">必須の「Module-as-microservice」。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20％のコードの割り当てが、80％の時間を別のライブラリで実行-プログラムの中核</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各モジュールの各機能のテスト容易性</font></font></li>
<li>,    .      ,      ,                  .</li>
<li>      .   « » ,      .   ,   ( ) //</li>
<li>       fastpimpl    ,     .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、これらすべてを低価格ですばやく実現する方法を理解しますが、私は別の問題に注意を向けたいと思います。その解決策は私たちにとってボーナスになります-プラットフォーム依存のパラメーターの転送。たとえば、AndroidとWindowsの両方で同等に機能するコードを作成する必要がある場合は、プラットフォーム依存のアルゴリズムを個別のモジュールに割り当てるのが合理的です。この場合、おそらく、Androidの実装には、Java（jni）環境への参照、JNIEnv *、およびおそらくいくつかのJavaオブジェクトが必要になる可能性があります。また、Windowsでの実装には、プログラムの作業フォルダーが必要になる場合があります（Androidでは、JNIEnv *を使用してシステムから要求できます）。トリックは、同じJNIEnv *がWindowsコンテキストに存在しないため、型付き共用体またはstd ::バリアントのc ++の代替でさえ不可能です。もちろん可能ですvoid *ベクトルまたはstd ::任意のベクトルをパラメーターとして渡しますが、正直なところ、これは非定型の松葉杖です。非定型-C ++の強力な型指定の主な利点を拒否するため。これはSARSよりも危険です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、厳密に典型的な方法でこの問題を解決する方法を分析します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート2.魔法の弾丸とその値札</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ゼロから作成する必要のあるコードが大量にあり、結果として非常に大規模なプロジェクトになるとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが決定した原則に従ってどのように組み立てることができますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのマニュアルで承認されている古典的な方法は、すべてをインターフェイスと戦略に分割することです。インターフェースと戦略の助けを借りて、それらがたくさんある場合、「micro-as-microservice」原理がそれに取り掛かるほど、プロジェクトの副問題を分離することができます。しかし、私の個人的な経験では、プロジェクトを20〜30の部分に分割すると、「module-as-microservice」のレベルに分離され、成功します。しかし、優れたアーキテクチャの主な特徴は、プロジェクトのコンテキスト外で任意のクラスをテストできることです。そして、各クラスをすでに分離している場合、すでに500以上のモジュールがあり、私の経験では、これにより開発時間が3〜5倍増加します。つまり、「戦闘条件」ではこれを行わず、価格と品質の間で妥協します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰かが疑う可能性があり、彼自身の権利になります。おおよその見積もりをしましょう。中間クラスに3-5のメンバーと20の関数と3つのコンストラクターがあるとします。さらに、メンバーにアクセスするための6〜10個のゲッターとセッター（ミューテーター）。クラス全体で約40ユニット。典型的なプロジェクトでは、各「センター」クラスはセンターから3ではなく、平均5つの機能にアクセスする必要があります。たとえば、非常に多くのクラスには、アロケーター、ファイルシステム、文字列の操作、ストリームの操作、およびデータベースへのアクセスが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各戦略/インターフェイスには、1つのタイプメンバーが必要です</font></font><code>std::shared_ptr&lt;CreateStreamStrategy&gt; m_create_stream;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 2つのミューテーターと、3つのコンストラクターそれぞれの初期化。さらに、クラスの初期化のどこかで、次のようなものを呼び出す必要があります</font></font><code>myclass-&gt;SetCreateStreamStrategy( my_create_stream_strategy )</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、インターフェース/戦略ごとに合計8ユニット、そして約5ユニットあるため、40ユニットになります。つまり、元のクラスを2倍扱いにくくしました。そして、本質的に何も変わっていないように見えるという事実にもかかわらず、単純さの喪失は、必然的に可読性に、そしてデバッグのプロセスの他の場所に半時間影響します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ですから問題です。同じことをするにはどうすればよいのですか？最初に頭に浮かぶのは、AlexandrescuとLokiライブラリーのスタイルでのテンプレートの静的パラメーター化です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはスタイルでクラスを書いています</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Traits</span> &gt; <span class="hljs-title">class</span> <span class="hljs-title">MyClass</span> {</span>
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoMainTaskFunction</span><span class="hljs-params">()</span> </span>{<font></font>
    ...<font></font>
    MyStream stream = Traits::streamwork::Open( stream_name );<font></font>
    ...<font></font>
  }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このソリューションには、最初の部分で特定したすべてのアーキテクチャ上の利点があります。しかし、欠点もたくさんあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ぼくはぼくがしゃべるのが大好きだ。でも、自分が認めたのは後悔している。普通のコードのテンプレートは、テンプレートマジシャンだけが愛している。 「テンプレート」という言葉を持つプログラマーの大部分はわずかに眉をひそめています。さらに、業界では、プラスの大部分は実際にはプラスではありませんが、プラスについての深い知識はなく、「テンプレート」という言葉に該当し、死んだふりをするc ++システムで少し再トレーニングされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これをプロダクション言語に変換すると、静的パラメーター化に関するコードの保守はより高価で複雑になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、読みやすくするために、クラスの外部で関数の本体を注意深く削除したい場合は、テンプレートとテンプレートパラメータの名前をたくさんの落書きを取得します。</font><font style="vertical-align: inherit;">また、コンパイルエラーが発生した場合は、複雑なネストされたテンプレートが多数あるため、人間が理解できる原因と問題領域の長い棚が表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、簡単な方法があります。</font><font style="vertical-align: inherit;">テンプレートマジシャンとして、静的パラメータ化/静的ポリモーフィズムを使用して実行できるほとんどすべてのことを動的ポリモーフィズムに転送できることを宣言します。</font><font style="vertical-align: inherit;">いいえ、もちろん、テンプレートの悪を根絶することはしませんが、各クラスでパラメーター化するために寛大な手でそれを分散させることはしませんが、いくつかのインストゥルメンタルクラスに制限します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート３。</font><font style="vertical-align: inherit;">提案されたソリューションと</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CODENIこの決定コード</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だからそこに!!!テンプレートクラスTypedSetを満たします。彼はこのタイプの1つのスマートポインターを1つのタイプに関連付けます。さらに、指定されたタイプにはオブジェクトがある場合がありますが、ない場合もあります。名前が気に入らないので、コメントでもっと成功したオプションを教えていただければありがたいです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つのタイプ-1つのオブジェクト。ただし、タイプの数に制限はありません。したがって、そのようなクラスをパラメーター化子として渡すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたの注意を一点引きたいと思います。ある時点で、1つのインターフェースで2つのオブジェクトが必要になる場合があります。実際、そのような必要性が生じた場合、（私の意見では）これはアーキテクチャ上のエラーを意味します。つまり、1つのインターフェースの下に2つのオブジェクトがある場合、それらはもはや機能アクセスインターフェースではありません。これらは関数の入力変数であるか、アクセスする必要がある機能が1つではなく2つある場合、インターフェースを2つに分割することをお勧めします。 。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Create、Get、Hasの3つの基本的な関数を作成します。したがって、要素の存在の作成、受信、および検証。</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-comment">/// @brief    .      ,   </span>
<span class="hljs-comment">///                 </span>
<span class="hljs-comment">///</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedSet</span> {</span>
 <span class="hljs-keyword">public</span>: 
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedElement</span>&gt; <span class="hljs-title">void</span> <span class="hljs-title">Create</span>( <span class="hljs-title">const</span> <span class="hljs-title">std</span>:</span>:<span class="hljs-built_in">shared_ptr</span>&lt;TypedElement&gt; &amp; value );
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedElement</span>&gt; <span class="hljs-title">std</span>:</span>:<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;TypedElement&gt; <span class="hljs-title">Get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedElement</span>&gt; <span class="hljs-title">bool</span> <span class="hljs-title">Has</span>() <span class="hljs-title">const</span>;</span><font></font>
  <font></font>
  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> storage_.size(); }<font></font>
 <font></font>
 <span class="hljs-keyword">protected</span>:
  <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt; <span class="hljs-keyword">size_t</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">void</span>&gt; &gt; Storage;<font></font>
  <font></font>
  <span class="hljs-function">Storage <span class="hljs-keyword">const</span> &amp;     <span class="hljs-title">storage</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> storage_; }
  <span class="hljs-function">Storage       &amp; <span class="hljs-title">get_storage</span><span class="hljs-params">()</span>       </span>{ <span class="hljs-keyword">return</span> storage_; }  <font></font>
  <font></font>
 <span class="hljs-keyword">private</span>:<font></font>
  Storage storage_;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedElement</span>&gt; <span class="hljs-title">void</span> <span class="hljs-title">TypedSet</span>:</span>:Create(
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;TypedElement&gt; &amp; value ) {
  <span class="hljs-keyword">size_t</span> hash = <span class="hljs-keyword">typeid</span>(TypedElement).hash_code();
  <span class="hljs-keyword">if</span> (  storage().count( hash ) &gt; <span class="hljs-number">0</span>   ) {<font></font>
      LogError( <span class="hljs-string">"Access Violation"</span> );
      <span class="hljs-keyword">return</span>;<font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">void</span>&gt; <span class="hljs-title">to_add</span> <span class="hljs-params">( value )</span></span>;<font></font>
  get_storage().insert(   <span class="hljs-built_in">std</span>::pair( <span class="hljs-keyword">typeid</span>(TypedElement).hash_code(), to_add )   );<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedElement</span>&gt; <span class="hljs-title">bool</span> <span class="hljs-title">TypedSet</span>:</span>:Has() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">size_t</span> hash = <span class="hljs-keyword">typeid</span>(TypedElement).hash_code();
  <span class="hljs-keyword">return</span> storage().count( hash ) &gt; <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedElement</span>&gt; <span class="hljs-title">std</span>:</span>:<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;TypedElement&gt; <span class="hljs-title">TypedSet::Get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
    <span class="hljs-keyword">size_t</span> hash = <span class="hljs-keyword">typeid</span>(TypedElement).hash_code();
    <span class="hljs-keyword">if</span> (  storage().count( hash ) &gt; <span class="hljs-number">0</span>   ) {
        <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">void</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">( storage().at(hash) )</span></span>;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::static_pointer_cast&lt;TypedElement&gt;( ret );<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        LogError( <span class="hljs-string">"Access Violation"</span> );
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;TypedElement&gt; ();<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ところで、Qtで書いている同僚からの代替ソリューションを見ました。そこで、目的のインターフェースへのアクセスは、テキスト行（!!!）を介してVaraintにパックされた目的のインターフェースを「マップ」したシングルトンを通じて実行され、このオプションをキャストした後、結果を使用できました。</font></font><br>
<br>
<pre><code class="cpp hljs">GlobalConfigurator()[<span class="hljs-string">"FileSystem"</span>].Get().As&lt;FileSystem&gt;()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは確かに機能しますが、長さを数え、文字列をさらにハッシュするオーバーヘッドは、私の楽観的な魂にとってやや怖いです。ここでは、オーバーヘッドはゼロです。必要なインターフェイスの選択はコンパイル時に実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypedSetに基づいて、StrategiesSetクラスを作成できます。これは、すでにより高度なクラスです。その中に、各機能のアクセスインターフェイスごとに1つのオブジェクトだけでなく、各インターフェイス（以降、ストラテジーと呼びます）にも、このストラテジーのパラメーターを持つ追加のTypedSetを格納します。明確にします。パラメータは、関数変数とは異なり、プログラムの初期化時に1回、または大規模なプログラムの実行時に1回設定されるものです。パラメータを使用すると、コードを真にクロスプラットフォームにすることができます。プラットフォームに依存するキッチン全体を運転するのは彼らです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、Create、Get、CreateParamsSet、GetParamsSetなどのより基本的な関数を使用します。アーキテクチャ上冗長であるため、敷設されていません。コードがファイルシステムを操作する機能を参照し、呼び出し側のコードがそれを提供しなかった場合、例外をスローするかアサートするか</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、sebukkaプログラム</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にabort（）関数を呼び出さ</font><s><font style="vertical-align: inherit;">せる</font></s><font style="vertical-align: inherit;">だけ</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrategiesSet</span> {</span>
 <span class="hljs-keyword">public</span>:  
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span>&gt; <span class="hljs-title">void</span> <span class="hljs-title">Create</span>( <span class="hljs-title">const</span> <span class="hljs-title">std</span>:</span>:<span class="hljs-built_in">shared_ptr</span>&lt;Strategy&gt; &amp; value );
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span>&gt; <span class="hljs-title">std</span>:</span>:<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;Strategy&gt; <span class="hljs-title">Get</span><span class="hljs-params">()</span></span>;<font></font>
    <font></font>
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span>&gt; <span class="hljs-title">void</span> <span class="hljs-title">CreateParamsSet</span>();</span>
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span>&gt; <span class="hljs-title">std</span>:</span>:<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;TypedSet&gt; <span class="hljs-title">GetParamsSet</span><span class="hljs-params">()</span></span>;
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span>, <span class="hljs-title">class</span> <span class="hljs-title">ParamType</span>&gt; <span class="hljs-title">void</span> <span class="hljs-title">CreateParam</span>( <span class="hljs-title">const</span> <span class="hljs-title">std</span>:</span>:<span class="hljs-built_in">shared_ptr</span>&lt;ParamType&gt; &amp; value );
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span>, <span class="hljs-title">class</span> <span class="hljs-title">ParamType</span>&gt; <span class="hljs-title">std</span>:</span>:<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;ParamType&gt; <span class="hljs-title">GetParam</span><span class="hljs-params">()</span></span>;<font></font>
  <font></font>
 <span class="hljs-keyword">protected</span>:
  <span class="hljs-function">TypedSet <span class="hljs-keyword">const</span> &amp;     <span class="hljs-title">strategies</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> strategies_; }
  <span class="hljs-function">TypedSet       &amp; <span class="hljs-title">get_strategies</span><span class="hljs-params">()</span>       </span>{ <span class="hljs-keyword">return</span> strategies_; }
  <span class="hljs-function">TypedSet <span class="hljs-keyword">const</span> &amp;     <span class="hljs-title">params</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> params_; }
  <span class="hljs-function">TypedSet       &amp; <span class="hljs-title">get_params</span><span class="hljs-params">()</span>       </span>{ <span class="hljs-keyword">return</span> params_; }<font></font>
  <font></font>
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">struct</span> <span class="hljs-title">ParamHolder</span> {</span>
    ParamHolder( ) : param_ptr( <span class="hljs-built_in">std</span>::make_shared&lt;TypedSet&gt;() ) {}<font></font>
    <font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;TypedSet&gt; param_ptr;<font></font>
  };<font></font>
 <font></font>
 <span class="hljs-keyword">private</span>:<font></font>
   TypedSet strategies_;<font></font>
   TypedSet params_;<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span>&gt; <span class="hljs-title">void</span>
<span class="hljs-title">StrategiesSet</span>:</span>:Create( <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Strategy&gt; &amp; value ) { <font></font>
      get_strategies().Create&lt;Strategy&gt;( value ); <font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span>&gt; <span class="hljs-title">std</span>:</span>:<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;Strategy&gt;
<span class="hljs-title">StrategiesSet::Get</span><span class="hljs-params">()</span> </span>{ 
  <span class="hljs-keyword">return</span> get_strategies().Get&lt;Strategy&gt;();<font></font>
}<font></font>
    <font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span>&gt; <span class="hljs-title">void</span>
<span class="hljs-title">StrategiesSet</span>:</span>:CreateParamsSet(  ) {
  <span class="hljs-keyword">typedef</span> ParamHolder&lt;Strategy&gt; Holder;    
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt; Holder &gt; ptr = <span class="hljs-built_in">std</span>::make_shared&lt; Holder &gt;( );<font></font>
  ptr-&gt;param_ptr = <span class="hljs-built_in">std</span>::make_shared&lt; TypedSet &gt;();<font></font>
  get_params().Create&lt; Holder &gt;( ptr );<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span>&gt; <span class="hljs-title">std</span>:</span>:<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;TypedSet&gt; 
<span class="hljs-title">StrategiesSet::GetParamsSet</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">typedef</span> ParamHolder&lt;Strategy&gt; Holder;
  <span class="hljs-keyword">if</span> ( get_params().Has&lt; Holder &gt;() ) {
    <span class="hljs-keyword">return</span> get_params().Get&lt; Holder &gt;()-&gt;param_ptr;<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    LogError(<span class="hljs-string">"StrategiesSet::GetParamsSet : get unexisting!!!"</span>);      
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;TypedSet&gt;();<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span>, <span class="hljs-title">class</span> <span class="hljs-title">ParamType</span>&gt; <span class="hljs-title">void</span> 
<span class="hljs-title">StrategiesSet</span>:</span>:CreateParam( <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;ParamType&gt; &amp; value ) {
  <span class="hljs-keyword">typedef</span> ParamHolder&lt;Strategy&gt; Holder;
  <span class="hljs-keyword">if</span> ( !params().Has&lt;Holder&gt;() ) CreateParamsSet&lt;Strategy&gt;();
  <span class="hljs-keyword">if</span> ( params().Has&lt;Holder&gt;() ) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;TypedSet&gt; params_set = GetParamsSet&lt;Strategy&gt;();<font></font>
    params_set-&gt;Create&lt;ParamType&gt;( value );<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
      LogError( <span class="hljs-string">"Param creating error: Access Violation"</span> );<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span>, <span class="hljs-title">class</span> <span class="hljs-title">ParamType</span>&gt; <span class="hljs-title">std</span>:</span>:<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;ParamType&gt;
<span class="hljs-title">StrategiesSet::GetParam</span><span class="hljs-params">()</span> </span>{    
  <span class="hljs-keyword">typedef</span> ParamHolder&lt;Strategy&gt; Holder;
  <span class="hljs-keyword">if</span> ( params().Has&lt;Holder&gt;() ) {
    <span class="hljs-keyword">return</span> GetParamsSet&lt;Strategy&gt;()-&gt;<span class="hljs-keyword">template</span> Get&lt;ParamType&gt;(); <span class="hljs-comment">//   template          .    .</span>
  } <span class="hljs-keyword">else</span> {<font></font>
    LogError( <span class="hljs-string">"Access Violation"</span> );
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;ParamType&gt; ();<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
追加のプラスは、プロトタイピングの段階で、1つの超大規模なタイピングクラスを作成し、すべてのモジュールへのアクセスをクラミングして、すべてのモジュールにパラメーターとして渡し、すぐに小さくして、各モジュールに最小限必要な部分に静かに分割できることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、そして小さくて（まだ）過度に単純化されたユースケース。</font><font style="vertical-align: inherit;">コメントであなたが私にあなたが簡単な例として見たいものを私に提案することを願っています、そして私は記事を小さなアップグレードにします。</font><font style="vertical-align: inherit;">人気のプログラミングの知恵が言うように、「できるだけ早くリリースし、リリース後にフィードバックを使用して改善する」。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Interface1</span> {</span>
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span> </span>{ <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\niface1\n"</span>);}
  <span class="hljs-keyword">virtual</span> ~Interface1() {}<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Interface2</span> {</span>
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span> </span>{ <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\niface2\n"</span>);}
  <span class="hljs-keyword">virtual</span> ~Interface2() {}<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Interface3</span> {</span>
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span> </span>{ <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\niface3\n"</span>);}
  <span class="hljs-keyword">virtual</span> ~Interface3() {}<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Implementation1</span> :</span> <span class="hljs-keyword">public</span> Interface1 {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nimpl1\n"</span>);}<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Implementation2</span> :</span> <span class="hljs-keyword">public</span> Interface2 {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fun</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nimpl2\n"</span>);}<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintParams</span> {</span>
 <span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">virtual</span> ~PrintParams() {}
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">GetOs</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintParamsUbuntu</span> :</span> <span class="hljs-keyword">public</span> PrintParams  {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">GetOs</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">"Ubuntu"</span>; }<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintParamsWindows</span> :</span> <span class="hljs-keyword">public</span> PrintParams  {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">GetOs</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">"Windows"</span>; }<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintStrategy</span> {</span>
 <span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">virtual</span> ~PrintStrategy() {}
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> TypedSet&amp; params, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp; str )</span> </span>= <span class="hljs-number">0</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintWithOsStrategy</span> :</span> <span class="hljs-keyword">public</span> PrintStrategy {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">( <span class="hljs-keyword">const</span> TypedSet&amp; params, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp; str )</span> <span class="hljs-keyword">override</span> </span>{
    <span class="hljs-keyword">auto</span> os = params.Get&lt; PrintParams &gt;()-&gt;GetOs();
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">" Printing: %s (OS=%s)"</span>, str.c_str(), os.c_str() );<font></font>
  }<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TestTypedSet</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<font></font>
  TypedSet a;<font></font>
  a.Create&lt;Interface1&gt;( make_shared&lt;Implementation1&gt;() ); <font></font>
  a.Create&lt;Interface2&gt;( make_shared&lt;Implementation2&gt;() ); <font></font>
  a.Get&lt;Interface1&gt;()-&gt;Fun();<font></font>
  a.Get&lt;Interface2&gt;()-&gt;Fun();<font></font>
  Log(<span class="hljs-string">"Double creation:"</span>);    <font></font>
  a.Create&lt;Interface1&gt;( make_shared&lt;Implementation1&gt;() ); <font></font>
    <font></font>
  Log(<span class="hljs-string">"Get unexisting:"</span>); <font></font>
  a.Get&lt;Interface3&gt;();<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TestStrategiesSet</span><span class="hljs-params">()</span> </span>{    
  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<font></font>
  StrategiesSet printing;<font></font>
  printing.Create&lt; PrintStrategy &gt;( make_shared&lt;PrintWithOsStrategy&gt;() );<font></font>
  printing.CreateParam&lt; PrintStrategy, PrintParams &gt;( make_shared&lt;PrintParamsWindows&gt;() );<font></font>
    <font></font>
  <span class="hljs-keyword">auto</span> print_strategy_ptr = printing.Get&lt; PrintStrategy &gt;();
  <span class="hljs-keyword">auto</span> &amp; print_strategy = *print_strategy_ptr;
  <span class="hljs-keyword">auto</span> &amp; print_params = *printing.GetParamsSet&lt; PrintStrategy &gt;();<font></font>
  print_strategy( print_params, <span class="hljs-string">"Done!"</span> );<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
  TestTypedSet();    <font></font>
  TestStrategiesSet();    <font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようにして、重要な問題を解決しました。クラスの機能に直接関連するインターフェースのみをクラスに残しました。残りの部分はStrategiesSetに「押し込まれ」、一方、不要な要素でクラスが乱雑になること、および必要な機能の特定のアルゴリズムがアルゴリズムに「釘付け」になることを回避しました。これにより、実装やライブラリへの依存性がまったくない、高度に絶縁されたコードを作成できるだけでなく、時間を大幅に節約できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプルとツールクラスのコードは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">Updで</font></b><font style="vertical-align: inherit;">完全に見つけることができます</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 2019年11月13日から</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、ここに示すコードは、読みやすくするための単純な例にすぎません。</font><font style="vertical-align: inherit;">実際には、typeid（）です。Hash_codeは、最近のコンパイラーではゆっくりと非効率的に実装されています。</font><font style="vertical-align: inherit;">その使用は意味の多くを殺します。</font><font style="vertical-align: inherit;">さらに、尊敬される人によって示唆されたように</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xd34df00d</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、標準はハッシュコードでタイプを区別する能力を保証しません（実際には、このアプローチは機能します）。</font><font style="vertical-align: inherit;">しかし、その例はよく読まれています。</font><font style="vertical-align: inherit;">Typeid（）を使用せずにTypedSetを書き直しました。さらに、Hash_code（）を使用してマップを配列に置き換えました（ただし、＃ifの1桁を変更することで、マップから配列に、またはその逆にすばやく切り替えることができます）。</font><font style="vertical-align: inherit;">難しいことでしたが、実用的にはもっと興味深いものでした。</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コリルで</font></font></a><br>
<pre><code class="cpp hljs">
 <span class="hljs-keyword">namespace</span> metatype {<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Counter</span> {</span>
  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">GetAndIncrease</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> counter_++; }
 <span class="hljs-keyword">private</span>:
   <span class="hljs-keyword">size_t</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> counter_ = <span class="hljs-number">1</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashGetterBody</span> {</span><font></font>
  HashGetterBody() : hash_( counter_.GetAndIncrease() ) {<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">GetHash</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> hash_; }
 <span class="hljs-keyword">private</span>:<font></font>
  Counter counter_;<font></font>
  <span class="hljs-keyword">size_t</span> hash_;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashGetter</span> {</span>
  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">GetHash</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">return</span> hasher_.GetHash(); }
 <span class="hljs-keyword">private</span>:
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> HashGetterBody&lt;Type&gt; hasher_;<font></font>
};<font></font>
     <font></font>
} <span class="hljs-comment">// namespace metatype</span><font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt; <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">GetTypeHash</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> metatype::HashGetter&lt;Type&gt;().GetHash();<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">namespace</span> details {
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 1 <span class="hljs-comment">//   ,        ()</span></span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedSetStorage</span> {</span>
 <span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> kMaxTypes = <span class="hljs-number">100</span>;
  <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">void</span>&gt;, kMaxTypes &gt; Storage;
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Set</span><span class="hljs-params">( <span class="hljs-keyword">size_t</span> hash_index, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">void</span>&gt; &amp; value )</span> </span>{<font></font>
    ++size_;<font></font>
    assert( hash_index &lt; kMaxTypes ); <span class="hljs-comment">// too many types</span><font></font>
    data_[hash_index] = value;<font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">void</span>&gt; &amp; <span class="hljs-title">Get</span><span class="hljs-params">( <span class="hljs-keyword">size_t</span> hash_index )</span> </span>{<font></font>
    assert( hash_index &lt; kMaxTypes );<font></font>
    <span class="hljs-keyword">return</span> data_[hash_index]; <font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">void</span>&gt; &amp; <span class="hljs-title">Get</span><span class="hljs-params">( <span class="hljs-keyword">size_t</span> hash_index )</span> <span class="hljs-keyword">const</span> </span>{ 
    <span class="hljs-keyword">if</span> ( hash_index &gt;= kMaxTypes ) <span class="hljs-keyword">return</span> empty_ptr_;
    <span class="hljs-keyword">return</span> data_[hash_index]; <font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Has</span><span class="hljs-params">( <span class="hljs-keyword">size_t</span> hash_index )</span> <span class="hljs-keyword">const</span> </span>{
    <span class="hljs-keyword">if</span> (  hash_index &gt;= kMaxTypes ) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">bool</span>)data_[hash_index];<font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> size_; }<font></font>
  <font></font>
 <span class="hljs-keyword">private</span>:<font></font>
  Storage data_;<font></font>
  <span class="hljs-keyword">size_t</span> size_ = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">inline</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">void</span>&gt; empty_ptr_;<font></font>
};<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span> <span class="hljs-comment">//    ,        (std::map)</span></span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedSetStorage</span> {</span>
 <span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">typedef</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt; <span class="hljs-keyword">size_t</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">void</span>&gt; &gt; Storage;
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Set</span><span class="hljs-params">( <span class="hljs-keyword">size_t</span> hash_index, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">void</span>&gt; &amp; value )</span> </span>{ data_[hash_index] = value; }
  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">void</span>&gt; &amp; <span class="hljs-title">Get</span><span class="hljs-params">( <span class="hljs-keyword">size_t</span> hash_index )</span> </span>{ <span class="hljs-keyword">return</span> data_[hash_index]; }
  <span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">void</span>&gt; &amp; <span class="hljs-title">Get</span><span class="hljs-params">( <span class="hljs-keyword">size_t</span> hash_index )</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> data_.at(hash_index);   }
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Has</span><span class="hljs-params">( <span class="hljs-keyword">size_t</span> hash_index )</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> data_.count(hash_index) &gt; <span class="hljs-number">0</span>; }  
  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> data_.size(); }<font></font>
  <font></font>
 <span class="hljs-keyword">private</span>:<font></font>
  Storage data_;<font></font>
};<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
    <font></font>
} <span class="hljs-comment">// namespace details</span><font></font>
<font></font>
<span class="hljs-comment">/// @brief    .      ,   </span>
<span class="hljs-comment">///                 </span>
<span class="hljs-comment">///</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedSet</span> {</span>
 <span class="hljs-keyword">public</span>: 
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedElement</span>&gt; <span class="hljs-title">void</span> <span class="hljs-title">Create</span>( <span class="hljs-title">const</span> <span class="hljs-title">std</span>:</span>:<span class="hljs-built_in">shared_ptr</span>&lt;TypedElement&gt; &amp; value );
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedElement</span>&gt; <span class="hljs-title">std</span>:</span>:<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;TypedElement&gt; <span class="hljs-title">Get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
  <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedElement</span>&gt; <span class="hljs-title">bool</span> <span class="hljs-title">Has</span>() <span class="hljs-title">const</span>;</span><font></font>
  <font></font>
  <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> storage_.GetSize(); }<font></font>
 <font></font>
 <span class="hljs-keyword">protected</span>:
  <span class="hljs-keyword">typedef</span> details::TypedSetStorage Storage;<font></font>
  <font></font>
  <span class="hljs-function">Storage <span class="hljs-keyword">const</span> &amp;     <span class="hljs-title">storage</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> storage_; }
  <span class="hljs-function">Storage       &amp; <span class="hljs-title">get_storage</span><span class="hljs-params">()</span>       </span>{ <span class="hljs-keyword">return</span> storage_; }<font></font>
  <font></font>
  <font></font>
 <span class="hljs-keyword">private</span>:<font></font>
  Storage storage_;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedElement</span>&gt; <span class="hljs-title">void</span> <span class="hljs-title">TypedSet</span>:</span>:Create(
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;TypedElement&gt; &amp; value ) {                        
  <span class="hljs-keyword">size_t</span> hash = GetTypeHash&lt;TypedElement&gt;();
  <span class="hljs-keyword">if</span> (  storage().Has( hash )  ) {<font></font>
      LogError( <span class="hljs-string">"Access Violation"</span> );
      <span class="hljs-keyword">return</span>;<font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">void</span>&gt; <span class="hljs-title">to_add</span> <span class="hljs-params">( value )</span></span>;<font></font>
  get_storage().Set( hash,  to_add );<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedElement</span>&gt; <span class="hljs-title">bool</span> <span class="hljs-title">TypedSet</span>:</span>:Has() <span class="hljs-keyword">const</span> {
  <span class="hljs-keyword">size_t</span> hash = GetTypeHash&lt;TypedElement&gt;();
  <span class="hljs-keyword">return</span> storage().Has( hash );<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedElement</span>&gt; <span class="hljs-title">std</span>:</span>:<span class="hljs-function"><span class="hljs-built_in">shared_ptr</span>&lt;TypedElement&gt; <span class="hljs-title">TypedSet::Get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
    <span class="hljs-keyword">size_t</span> hash = GetTypeHash&lt;TypedElement&gt;();    
    <span class="hljs-keyword">if</span> ( storage().Has( hash )   ) {
      <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">void</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">( storage().Get( hash ) )</span></span>;
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::static_pointer_cast&lt;TypedElement&gt;( ret );<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      LogError( <span class="hljs-string">"Access Violation"</span> );
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;TypedElement&gt; ();<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、アクセスは線形時間で実行され、タイプハッシュはmain（）が実行される前にカウントされます。損失は検証チェックにのみ使用され、必要に応じて破棄できます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja475258/index.html">サンクトペテルブルクの選挙の視覚的表現-音声ラッピングの魔法</a></li>
<li><a href="../ja475260/index.html">非同期関数とpromiseを返す関数の違い</a></li>
<li><a href="../ja475262/index.html">先週のフロントエンドの世界からの新鮮な食材のダイジェストNo.388（2019年11月4-10日）</a></li>
<li><a href="../ja475264/index.html">できるスニファ：FakeSecurityファミリがオンラインストアに感染した方法</a></li>
<li><a href="../ja475266/index.html">私たちはアンドロイドの下でモバイル1を逆にします。少しの機能を追加して数夜を捨てる方法</a></li>
<li><a href="../ja475270/index.html">SwiftUI：リストビューで展開可能/折りたたみ可能なセクションを作成する</a></li>
<li><a href="../ja475272/index.html">Rustの非同期待機インフラストラクチャへの移行</a></li>
<li><a href="../ja475276/index.html">アサートを正しく書く方法</a></li>
<li><a href="../ja475278/index.html">ハッカーがあなたを覗き見している間にハッカーを覗き見する方法</a></li>
<li><a href="../ja475280/index.html">シスコのパスワード、DNSゾーン転送、ゼロLDAP要求、イーサネットパケットを収集します。r0ot-miを使用してネットワーク上の問題を解決します。パート2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>