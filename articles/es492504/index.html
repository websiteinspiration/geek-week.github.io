<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💒 👧🏼 🕉️ ¿Qué sucede cuando un módulo JS se importa dos veces? 🏂🏼 🎽 👂🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comencemos este artículo con una pregunta. El módulo ES2015 incrementcontiene el siguiente código:
 
 

// increment.js let counter = 0; counter++;  e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>¿Qué sucede cuando un módulo JS se importa dos veces?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/492504/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos este artículo con una pregunta. </font><font style="vertical-align: inherit;">El módulo ES2015 </font></font><code>increment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contiene el siguiente código:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// increment.js</span>
<span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;<font></font>
counter++;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> counter;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En otro módulo, que llamaremos </font></font><code>consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, el módulo anterior se importa 2 veces:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// consumer.js</span>
<span class="hljs-keyword">import</span> counter1 <span class="hljs-keyword">from</span> <span class="hljs-string">'./increment'</span>;
<span class="hljs-keyword">import</span> counter2 <span class="hljs-keyword">from</span> <span class="hljs-string">'./increment'</span>;<font></font>
<font></font>
counter1; <span class="hljs-comment">// =&gt; ???</span>
counter2; <span class="hljs-comment">// =&gt; ???</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y ahora, en realidad, una pregunta. </font><font style="vertical-align: inherit;">¿Qué se obtiene en las variables </font></font><code>counter1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>counter2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">después del módulo </font></font><code>consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">
Para responder a esta pregunta, debe comprender cómo JavaScript ejecuta los módulos y cómo se importan.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/-e/gq/3p/-egq3px2qo7a_nyjchhabkyhms4.png"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejecución del módulo</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para entender cómo funcionan los mecanismos internos de JavaScript, es útil analizar la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">especificación</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Según la especificación, cada módulo de JavaScript está asociado con una entidad de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registro de módulo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esta entrada tiene un método </font></font><code>Evaluate()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que ejecuta el módulo: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
si este módulo ya se ha ejecutado con éxito, devuelva undefined; </font><font style="vertical-align: inherit;">[...] </font><font style="vertical-align: inherit;">De lo contrario, ejecute transitivamente todas las dependencias de este módulo y luego ejecute este módulo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, resulta que el mismo módulo se ejecuta solo una vez. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desafortunadamente, lo que necesita saber para responder nuestra pregunta no se limita a esto. </font><font style="vertical-align: inherit;">Cómo asegurarse de que la instrucción llame</font></font><code>import</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilizando las mismas rutas devolverá el mismo módulo?</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Permitir comandos de importación</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La operación abstracta </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HostResolveImportedModule ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es responsable de asociar la ruta al módulo (especificador) con un módulo específico </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El código de importación del módulo se ve así:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> <span class="hljs-built_in">module</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto es lo que dice la especificación al respecto: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
una implementación de HostResolveImportedModule debe cumplir los siguientes requisitos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El valor de retorno normal debe ser una instancia de una subclase particular de Registro de módulo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la entidad de registro del módulo correspondiente al par que hace referencia a ScriptOrModule, el especificador no existe, o tal entidad no se puede crear, se lanzará una excepción.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada vez que se llama a esta operación y se le pasa como argumento un par específico de referenciaScriptOrModule, especificador, debería, en el caso de su ejecución habitual, devolver la misma instancia de la entidad de Registro de Módulo.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora considere esto de una manera más comprensible. </font></font><br>
<br>
<code>HostResolveImportedModule(referencingScriptOrModule, specifier)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- una operación abstracta que devuelve el módulo que corresponde a un par de parámetros </font></font><code>referencingScriptOrModule</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>specifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El parámetro </font></font><code>referencingScriptOrModule</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es el módulo actual, es decir, el módulo que importa.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un parámetro </font></font><code>specifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es una cadena que coincide con la ruta del módulo en la instrucción </font></font><code>import</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al final de la descripción </font></font><code>HostResolveImportedModule()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se dice que al importar módulos que corresponden a la misma ruta, se importa el mismo módulo:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> moduleA <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;
<span class="hljs-keyword">import</span> moduleB <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;
<span class="hljs-keyword">import</span> moduleC <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;<font></font>
<font></font>
<span class="hljs-comment">// moduleA, moduleB  moduleC -    </span><font></font>
<font></font>
moduleA === moduleB; <span class="hljs-comment">// =&gt; true</span>
moduleB === moduleC; <span class="hljs-comment">// =&gt; true</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Curiosamente, la especificación indica que el host (navegador, entorno Node.js, en general, cualquier cosa que intente ejecutar código JavaScript) debe proporcionar una implementación específica </font></font><code>HostResolveImportedModule()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Responder</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de una lectura cuidadosa de la especificación, queda claro que los módulos JavaScript se ejecutan solo una vez durante la importación. </font><font style="vertical-align: inherit;">Y al importar un módulo utilizando la misma ruta, se devuelve la misma instancia del módulo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Volvamos a nuestra pregunta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un módulo </font></font><code>increment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siempre se ejecuta solo una vez:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// increment.js</span>
<span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;<font></font>
counter++;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> counter;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Independientemente de cuántas veces se haya importado un módulo </font></font><code>increment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, una expresión se </font></font><code>counter++</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">evalúa solo una vez. </font><font style="vertical-align: inherit;">Una variable </font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exportada utilizando el mecanismo de exportación predeterminado es importante </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora eche un vistazo al módulo </font></font><code>consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// consumer.js</span>
<span class="hljs-keyword">import</span> counter1 <span class="hljs-keyword">from</span> <span class="hljs-string">'./increment'</span>;
<span class="hljs-keyword">import</span> counter2 <span class="hljs-keyword">from</span> <span class="hljs-string">'./increment'</span>;<font></font>
<font></font>
counter1; <span class="hljs-comment">// =&gt; 1</span>
counter2; <span class="hljs-comment">// =&gt; 1</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los comandos </font></font><code>import counter1 from './increment'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>import counter2 from './increment'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizan la misma ruta - </font></font><code>'./increment'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como resultado, resulta que se importa la misma instancia del módulo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resulta que </font><font style="vertical-align: inherit;">el mismo valor 1 </font><font style="vertical-align: inherit;">se </font><font style="vertical-align: inherit;">escribe </font><font style="vertical-align: inherit;">en las variables </font></font><code>counter1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>counter2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resumen</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tras examinar una pregunta simple, pudimos descubrir más sobre cómo se ejecutan e importan los módulos JavaScript. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las reglas utilizadas al importar módulos son bastante simples: el mismo módulo se ejecuta solo una vez. En otras palabras, lo que está dentro del alcance del módulo se realiza solo una vez. Si un módulo que ya se ha ejecutado una vez se importa de nuevo, no se volverá a ejecutar. Al importar un módulo, utiliza lo que se obtuvo como resultado de una sesión anterior para averiguar qué exporta exactamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si un módulo se importa varias veces, pero el especificador del módulo (la ruta al mismo) permanece igual, entonces la especificación de JavaScript garantiza que se importe la misma instancia del módulo. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Queridos lectores!</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¿Con qué frecuencia recurre a leer la especificación de JavaScript para descubrir las características del funcionamiento de ciertas construcciones de lenguaje?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es492488/index.html">OpenID Connect: autorización de aplicaciones internas de genérico a estándar</a></li>
<li><a href="../es492492/index.html">NikiRobot - una evolución en robótica educativa</a></li>
<li><a href="../es492496/index.html">Ejemplo de Simple Notes SPA en Mithril.js</a></li>
<li><a href="../es492500/index.html">Science Garage en ruso. Experiencia traduciendo un show americano</a></li>
<li><a href="../es492502/index.html">MIP * = RE: evidencia de la época del campo de la informática que causó el efecto dominó en física y matemáticas</a></li>
<li><a href="../es492506/index.html">3 formas de renderizar listas grandes en Angular</a></li>
<li><a href="../es492508/index.html">Libro Kubernetes para DevOps</a></li>
<li><a href="../es492510/index.html">Módulos ES6 en el navegador: ¿están listos o no?</a></li>
<li><a href="../es492512/index.html">CSS: aventuras en la tierra de la translucidez</a></li>
<li><a href="../es492514/index.html">¿Cómo establecer un flujo de documentos electrónicos legalmente significativo de contrapartes en Rusia y Kazajstán?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>