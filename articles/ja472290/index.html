<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚯 👍🏾 🎳 構造体とクラス 📱 ℹ️ 🧜🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="プログラミングを始めた当初から、パフォーマンスを向上させるために何を使用するかという疑問が生じました。構造体またはクラスです。どの配列がどの配列を使用する方が良いか。構造に関しては、Appleはそれらの使用を歓迎し、最適化に優れていることを説明し、Swift言語の本質はすべて構造です。しかし、あるク...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>構造体とクラス</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472290/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラミングを始めた当初から、パフォーマンスを向上させるために何を使用するかという疑問が生じました。構造体またはクラスです。どの配列がどの配列を使用する方が良いか。構造に関しては、Appleはそれらの使用を歓迎し、最適化に優れていることを説明し、Swift言語の本質はすべて構造です。しかし、あるクラスを別のクラスから継承し、そのようなクラスを操作することでコードを美しく簡略化できるため、これに同意しない人もいます。クラスでの作業をスピードアップするために、特にクラス用に最適化されたさまざまなモディファイアとオブジェクトを作成しましたが、どの場合でも何がより高速になるかを言うのはすでに困難です。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのポイントを「e」に配置するために、メソッドへの受け渡し、コピー、配列の操作など、データ処理への通常のアプローチを使用するいくつかのテストを書きました。私は大きな結論を出さないことにしました。誰もがテストを信じる価値があるかどうかを自分で決定し、プロジェクトをダウンロードして、それがどのように機能するかを確認し、特定のテストの操作を最適化しようとします。おそらく、私が言及しなかった新しいチップでさえ出てくるかもしれませんし、それらがあまり使用されていないので聞いたことがないかもしれません。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 PS私はXcode 10.3に関する記事の作成を開始し、その速度をXcode 11と比較しようと考えましたが、それでも記事は2つのアプリケーションの比較ではなく、アプリケーションの速度についてです。</font><font style="vertical-align: inherit;">関数の実行時間が減り、最適化が不十分だったものが速くなることは間違いありません。</font><font style="vertical-align: inherit;">その結果、私は新しいSwift 5.1を待ち、実際に仮説をテストすることにしました。</font><font style="vertical-align: inherit;">読書を楽しむ。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト1：構造体とクラスの配列を比較する </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 特定のクラスがあり、このクラスのオブジェクトを配列に入れたい場合、配列に対する通常のアクションは、それをループすることです。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列では、クラスを使用してそれをウォークスルーしようとすると、リンクの数が増加し、完了後、オブジェクトへのリンクの数は減少します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造を調べると、オブジェクトがインデックスによって呼び出されたときに、同じメモリ領域を見てオブジェクトのコピーが作成されますが、不変とマークされています。</font><font style="vertical-align: inherit;">オブジェクトへのリンクの数の増加、または変更できないメモリ内の領域へのリンクの作成。</font><font style="vertical-align: inherit;">実際に確認してみましょう</font></font><br>
<br>
<img src="https://habrastorage.org/webt/me/i5/2g/mei52ghwjxv_pg3c1toaoqachty.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">1：構造とクラスに基づいて配列から変数を取得する比較</font></font></i><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト2. ContiguousArrayと配列の比較 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 さらに興味深いのは、配列（Array）のパフォーマンスを参照配列（ContiguousArray）と比較することです。これは、配列に格納されたクラスを操作するために特に必要です。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 次の場合のパフォーマンスを確認してみましょう：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ContiguousArray、型</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ContiguousArrayの</font><font style="vertical-align: inherit;">値を持つ構造体の格納、</font><font style="vertical-align: inherit;">文字列</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ContiguousArrayを</font><font style="vertical-align: inherit;">持つ構造体の</font><font style="vertical-align: inherit;">格納、型</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ContiguousArrayの</font><font style="vertical-align: inherit;">値を持つ</font><font style="vertical-align: inherit;">クラスの格納、文字列</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列を</font><font style="vertical-align: inherit;">持つクラスの</font><font style="vertical-align: inherit;">格納、型</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列の</font><font style="vertical-align: inherit;">値を持つ</font><font style="vertical-align: inherit;">構造体の格納、文字列</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列を</font><font style="vertical-align: inherit;">持つ構造体の</font><font style="vertical-align: inherit;">格納、クラスの格納</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stringのクラスを格納するArray </font><font style="vertical-align: inherit;">型の値</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テスト結果（テスト：インライン最適化がオフになっている関数に渡す、インライン最適化がオンになっている関数に渡す、要素の削除、要素の追加、ループ内の要素への順次アクセス）には、多数のテストが含まれます（それぞれ5つのテストの8つの配列）。 、私は最も重要な結果を与えます：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を呼び出して配列を渡し、インラインをオフにすると、そのような呼び出しは非常に負荷が高くなります（参照文字列に基づくクラスの場合、20,000倍遅くなります。値に基づくクラスの場合、インラインオプティマイザーをオフにすると、型が60,000倍悪くなります）。 。</font></font></li>
<li>   (inline)   ,       2 ,    ,       .    value ,   ,   ContiguousArray —    .</li>
<li>  —         20% (   Array).</li>
<li>  (append) —   ,   ,  ContiguousArray     20% ,   Array    ,   Array       ,   ContiguousArray  .</li>
<li>           ,     ,    ContiguousArray ( 500  ).</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、通常の配列を使用してオブジェクトを処理する方が効率的です。以前使用した、さらに使用しています。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列のループ最適化は、レイジーコレクションイニシャライザーによって提供されます。これにより、配列要素に対して複数のフィルターまたはマップが使用されている場合でも、配列全体を1回だけ歩くことができます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造を最適化ツールとして使用する場合、文字列、辞書、参照配列など、内部で参照の性質を持つ型を使用するなどの落とし穴があります。次に、参照型自体を格納する変数を関数に入力すると、クラスである要素ごとに追加の参照が作成されます。これにはもう少し別の側面があります。変数に対してラッパークラスを使用してみることができます。その後、関数に渡されるときのリンクの数はその関数に対してのみ増加し、構造内の値へのリンクの数は同じままになります。一般に、構造体に参照型の変数をいくつ含める必要があるかを調べて、同じパラメーターを持つクラスのパフォーマンスよりもパフォーマンスが低下するようにします。同じ質問をしてそれに答える「Stop Structs！」というウェブ上の記事があります。私はプロジェクトをダウンロードし、どこで何が起こり、どのような場合に遅い構造になるかを理解することにしました。著者は、クラスと比較して構造のパフォーマンスが低いことを示しており、新しいオブジェクトの作成はオブジェクトへの参照を増やすよりもはるかに遅いと主張しています（そのため、ループで新しいオブジェクトが作成される行を毎回削除しました）。しかし、オブジェクトへのリンクを作成せずに、それを関数に渡して操作する場合、パフォーマンスの違いは非常に重要ではなくなります。置くたびに著者は、クラスと比較して構造のパフォーマンスが低いことを示しており、新しいオブジェクトの作成はオブジェクトへの参照を増やすよりもはるかに遅いと主張しています（そのため、ループで新しいオブジェクトが作成される行を毎回削除しました）。しかし、オブジェクトへのリンクを作成せずに、それを関数に渡して操作する場合、パフォーマンスの違いは非常に重要ではなくなります。置くたびに著者は、クラスと比較して構造のパフォーマンスが低いことを示しており、新しいオブジェクトの作成はオブジェクトへの参照を増やすよりもはるかに遅いと主張しています（そのため、ループで新しいオブジェクトが作成される行を毎回削除しました）。しかし、オブジェクトへのリンクを作成せずに、それを関数に渡して操作する場合、パフォーマンスの違いは非常に重要ではなくなります。置くたびに置くたびに置くたびに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列をなして</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（決して）関数の場合、アプリケーションはそれを実行する必要があり、文字列内にコードを作成しないでください。</font><font style="vertical-align: inherit;">テストから判断すると、Appleは、関数に渡されたオブジェクトがわずかに変更されるようにしました。構造体の場合、コンパイラーは可変性を変更し、オブジェクトの変更不可能なプロパティへのアクセスを遅延させます。</font><font style="vertical-align: inherit;">クラスでも同様のことが起こりますが、同時にオブジェクトへの参照数が増加します。</font><font style="vertical-align: inherit;">そして今、遅延オブジェクトがあり、そのすべてのフィールドも遅延であり、オブジェクト変数を呼び出すたびに初期化されます。</font><font style="vertical-align: inherit;">この場合、構造には同等のものはありません。関数が2つの変数を呼び出す場合、オブジェクトの構造はクラスの速度よりもわずかに劣ります。</font><font style="vertical-align: inherit;">3つ以上呼び出すと、構造は常に高速になります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト3：大きなクラスを格納する構造体とクラスのパフォーマンスを比較する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 また、別の変数が追加されたときに呼び出されるメソッド自体を少し変更しました（このようにして、3つの変数がメソッドで初期化され、記事では2つではありませんでした）。Intオーバーフローが発生しないため、変数の演算を合計と減算で置き換えました。</font><font style="vertical-align: inherit;">よりわかりやすい時間メトリックを追加しました（スクリーンショットでは数秒ですが、それほど重要ではありません。結果の比率を理解することは重要です）。Darwinフレームワークを削除しました（プロジェクトを使用していない、多分無駄です。テストにフレームワークを追加する前/後にテストに違いはありません）。最大の最適化とリリースビルドへのビルドの組み込み（これはより正直になるようです）、これが結果です</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zv/q_/en/zvq_ens-bwgnuetcl53shkecjd0.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">2：記事「Structsの使用の停止」の構造とクラスのパフォーマンス</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
テスト結果の違いはわずかです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト4：ジェネリックを受け入れる関数、プロトコル、およびジェネリックなしの関数</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 ジェネリック関数を取り、2つの値を渡し、これらの値を比較する可能性によってのみ結合される場合（func min）、3行のコードは8つのコードに変わります（Appleによると）。ただし、これは常に当てはまるわけではありません。Xcodeには最適化メソッドがあり、関数を呼び出すときに2つの構造値が渡されたことが確認されると、2つの構造を取り、値をコピーしない関数が自動的に生成されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zo/fd/2v/zofd2v5qz7q3dkhzdcp_srpspyg.png"><br>
 <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 3：典型的なジェネリック関数</font></font></i><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの関数をテストすることにしました。最初の関数ではGenericデータ型が宣言され、2番目の関数ではプロトコルのみを受け入れます。</font><font style="vertical-align: inherit;">Swift 5.1プロトコルの新しいバージョンでは、Genericよりも少し高速です（Swift 5.1より前のプロトコルは2倍遅くなりました）。Appleによると、それは逆であるはずですが、配列を通過する場合、入力する必要があるため、速度が低下します汎用（ただし、プロトコルよりも高速であるため、依然として優れています）：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/k-/ox/vr/k-oxvrhsx5mbw_osj7azkzu9x7y.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図 </font><font style="vertical-align: inherit;">4：ジェネリックとプロトコルのホスト機能の比較。</font></font></i><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト5：親メソッドの呼び出しとネイティブメソッドの呼び出しを比較し、同時にそのような呼び出しの最終クラスを確認する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 また、常に興味を持っているのは、クラスが多数の親と連携して動作する速度、クラスがその機能と親の機能を呼び出す速度です。クラスを受け取るメソッドを呼び出そうとしている場合、動的ディスパッチが機能します。それは何ですか？関数内でメソッドまたは変数が呼び出されるたびに、オブジェクトにこの変数またはメソッドを要求するメッセージが生成されます。そのような要求を受け取ったオブジェクトは、そのクラスのディスパッチテーブルでメソッドの検索を開始し、メソッドまたは変数のオーバーライドが呼び出された場合は、それを受け取って戻るか、再帰的に基本クラスに到達します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tr/wz/i-/trwzi-l8v51yv4oftdl33a-30z4.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 5：クラスメソッド呼び出し、ディスパッチテスト用</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のテストからいくつかの結論を導き出すことができます。親クラスのクラスが大きいほど、動作が遅くなります。速度の違いが非常に小さいため無視しても問題はありません。コードの最適化によって速度に違いが生じない可能性があります。</font><font style="vertical-align: inherit;">この例では、finalクラス修飾子には利点がありません。逆に、クラスの処理はさらに遅くなります。これは、おそらく高速な関数にならないためと思われます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト6：通常のクラス変数に対してfinal修飾子を使用して変数を呼び出す</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 final修飾子を変数に割り当てると、非常に興味深い結果が得られます。クラスの相続人のどこかで変数が書き換えられないことが確実な場合に使用できます。</font><font style="vertical-align: inherit;">final修飾子を変数に追加してみましょう。</font><font style="vertical-align: inherit;">テストで変数を1つだけ作成し、そのプロパティを呼び出した場合、その変数は1回初期化されます（結果は以下のとおりです）。</font><font style="vertical-align: inherit;">新しいオブジェクトを毎回正直に作成してその変数を要求すると、速度が著しく遅くなります（結果は上記のとおりです）</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ef/t7/d7/eft7d7u2wpc4htxcas5tiffnari.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">6：最終的な変数の呼び出し</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
明らかに、修飾子は変数のメリットを生かさず、常に競合他社よりも低速です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト7：構造の多態性とプロトコルの問題。</font><font style="vertical-align: inherit;">またはパフォーマンス存在コンテナ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 問題：特定のメソッドをサポートするプロトコルと、このプロトコルから継承された複数の構造体を使用する場合、元のプロトコルによって結合された、格納された値のボリュームが異なる構造体を1つの配列に配置すると、コンパイラーはどう思いますか？</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
相続人で事前定義されたメソッドを呼び出す問題を解決するために、プロトコル監視テーブルメカニズムが使用されます。必要なメソッドを参照するシェル構造を作成します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データストレージの問題を解決するために、Existentialコンテナが使用されます。それぞれ8バイトの5つの情報セルを格納します。最初の3つでは、構造に格納されたデータにスペースが割り当てられ（データが収まらない場合は、データが格納されているヒープへのリンクが作成されます）、4番目には、構造で使用されるデータのタイプに関する情報が格納され、このデータの管理方法が示されます、5番目にはオブジェクトのメソッドへの参照が含まれています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jh/tu/6c/jhtu6cgi7hcnllrybgfphk9gx-i.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図7.オブジェクトへのリンクを作成し、それを含む配列のパフォーマンスの比較</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初と2番目の結果の間で、変数の数は3倍になりました。</font><font style="vertical-align: inherit;">理論的には、それらはコンテナに配置する必要があり、これらはこのコンテナに格納されます。速度の違いは、構造の体積によるものです。</font><font style="vertical-align: inherit;">興味深いことに、2番目の構造で変数の数を減らしても、動作時間は変化しません。つまり、コンテナーは実際に3つまたは2つの変数を格納しますが、明らかに、1つの変数に速度を大幅に向上させる特別な条件があります。</font><font style="vertical-align: inherit;">2番目の構造はコンテナーに完全に適合し、3番目の構造と体積が半分だけ異なるため、他の構造と比較してランタイムが大幅に低下します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトを最適化するためのちょっとした理論</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 以下の要因が構造のパフォーマンスに影響を与える可能性があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数が格納される場所（ヒープ/スタック）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティの参照カウントの必要性。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スケジューリング方法（静的/動的）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Copy-On-Writeは、内部で構造体（文字列、配列、セット、辞書）のふりをする参照型であるデータ構造体によってのみ使用されます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 スタック内にプロパティを格納するオブジェクトがすべての中で最速になることをすぐに明らかにすることは価値があります。静的な診察方法で参照カウントを使用しないでください。</font></font><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスは構造に比べて悪くて危険です</font></font></h4><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは常にオブジェクトのコピーを制御するわけではありません。これを行うと、管理が困難なコピーが多すぎる可能性があります（たとえば、ビューの作成を担当するプロジェクト内にオブジェクトを作成しました）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらは構造物ほど速くありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトへのリンクがあり、アプリケーションをマルチスレッドスタイルで管理しようとしている場合、オブジェクトが2つの異なる場所から使用されると競合状態が発生する可能性があります（Xcodeでビルドされたプロジェクトは常に少し遅いので、それほど難しくありませんが、ストアバージョンより）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
競合状態を回避しようとすると、ロックとデータに多くのリソースを費やします。これは、高速処理の代わりにリソースを消費して時間を浪費し始め、構造上に構築された同じオブジェクトよりもさらに遅いオブジェクトを取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のすべてのアクションをオブジェクト（リンク）に対して実行すると、予期しないデッドロックの可能性が高くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このため、コードの複雑さが増しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より多くのコード=より多くのバグ、常に！</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 私は時々記事を読みたくないので、この記事の結論は単に必要であると思いました。ポイントの統合されたリストが単に必要です。</font><font style="vertical-align: inherit;">テストの下の行を要約すると、以下を強調したいと思います。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造体を配列に配置するのが最善です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスから配列を作成する場合は、通常の配列を選択することをお勧めします。これは、ContiguousArrayが利点を提供することはめったになく、それらはそれほど高くないためです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インライン最適化は作業をスピードアップします。オフにしないでください。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列要素へのアクセスは、常にContiguousArray要素へのアクセスよりも高速です。</font></font></li>
<li>    (   Whole module optimization   ).</li>
<li>        ,   ,   .</li>
<li>    ,   Generic  Protocol, Generic  .</li>
<li>       .</li>
<li>   final    .</li>
<li>   ,    ,     ,       ,        .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リンク：</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">medium.com/@vhart/protocols-generics-and-existential-containers-wait-what-e2e698262ab1 </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">developer.apple.com/videos/play/wwdc2016/416 </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">developer.apple.com/videos/play/wwdc2015/409 </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">developer.apple.com/videos/play/wwdc2016/419 </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">medium.com/commencis/stop-using-structs-e1be9a86376fテスト</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja472272/index.html">Three.jsの古い雰囲気の新しいゲーム。パート2</a></li>
<li><a href="../ja472274/index.html">リモートSSH：ヒントとハック</a></li>
<li><a href="../ja472278/index.html">私のお気に入りのgit commit</a></li>
<li><a href="../ja472280/index.html">静脈スキャナーで手のひらの存在を判断するタスク</a></li>
<li><a href="../ja472288/index.html">開発者向けの9つの便利なブラウザー拡張機能（2020のリスト）</a></li>
<li><a href="../ja472292/index.html">コンテンツブロッキング：世界の舞台</a></li>
<li><a href="../ja472294/index.html">YouTubeでゲームやビデオを作成します。私の相互作用実験とこれからの収入</a></li>
<li><a href="../ja472296/index.html">洗濯機の漏れ防止システム</a></li>
<li><a href="../ja472298/index.html">先週フロントエンドの世界からの新鮮な食材のダイジェストNo.385（2019年10月14日〜20日）</a></li>
<li><a href="../ja472300/index.html">バイナリ分類問題における対数損失関数（LogLoss）の確率的勾配降下法（SGD）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>