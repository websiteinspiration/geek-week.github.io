<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏻 🌏 ☕️ Kubernetes负载平衡和扩展长期连接 🔂 🔦 🎿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文将帮助您了解Kubernetes中的负载平衡如何工作，扩展长期连接时会发生什么以及如果使用HTTP / 2，gRPC，RSockets，AMQP或其他长期协议，为什么应该考虑在客户端进行平衡。 
 
 关于如何在Kubernetes中重新分配流量 
 Kubernetes为部署应用程序提供了两种...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kubernetes负载平衡和扩展长期连接</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/493820/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/445/275/8af/4452758afb53f8b3161ace47d8c6ea49.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文将帮助您了解Kubernetes中的负载平衡如何工作，扩展长期连接时会发生什么以及如果使用HTTP / 2，gRPC，RSockets，AMQP或其他长期协议，为什么应该考虑在客户端进行平衡。&nbsp;</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于如何在Kubernetes中重新分配流量&nbsp;</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes为部署应用程序提供了两种方便的抽象：服务和部署。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
部署描述了在任何给定时间应运行的应用程序副本的数量以及数量。</font><font style="vertical-align: inherit;">每个应用程序都在（Pod）下部署，并分配了一个IP地址。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
功能服务类似于负载均衡器。</font><font style="vertical-align: inherit;">它们旨在将流量分布在多个炉膛上。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们看看它的外观</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在下图中，您将看到同一应用程序的三个实例和一个负载均衡器：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80f/58d/4f9/80f58d4f9cd1e34a88aa7b8a33c0a82f.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">负载平衡器称为服务，已为其分配IP地址。</font><font style="vertical-align: inherit;">任何传入的请求都将重定向到其中一个pod：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63e/7ef/b73/63e7efb73e75ce67fcd47f74b03aa04d.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部署脚本确定应用程序实例的数量。</font><font style="vertical-align: inherit;">您几乎永远不必直接在以下位置进行部署：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/121/8c3/a961218c382f2343f72bdcf639f20222.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个Pod分配有自己的IP地址：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c0/699/ef3/3c0699ef3d5a60d5b08f7afdfdedac29.png"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将服务视为一组IP地址很有用。</font><font style="vertical-align: inherit;">每次访问该服务时，都会从列表中选择一个IP地址并将其用作目标地址。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如下</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该服务有一个curl请求10.96.45.152：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60a/52c/539/60a52c539ed6d1791cbafa794db2c4a9.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该服务选择三个Pod地址之一作为目的地：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a8/ac4/e23/2a8ac4e23e79da06ee64c01e071b9089.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流量被重定向到特定的Pod：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ec/f2c/38e/7ecf2c38ef0af62d07d169c120ca5def.png"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您的应用程序由一个前端和一个后端组成，那么您将同时拥有一个服务和一个部署。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当前端完成对后端的请求时，它不需要确切知道后端服务多少个炉膛：可以有一个，十个或一百个。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，前端对服务于后端的炉床地址一无所知。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前端向后端发出请求时，它将使用后端服务的IP地址，该地址不会更改。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是它的样子</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Under 1请求后端内部组件。</font><font style="vertical-align: inherit;">它没有为后端选择特定的对象，而是执行服务请求：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ff/50c/a99/1ff50ca9970854efe8af15ac2a7d1791.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该服务选择一个后端Pod作为目标地址：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/dd9/9ad/530dd99add6451742a891d69ef06d03b.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流量从服务选择的炉床1到炉床5：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ea/bdb/808/2eabdb8086fefc2c48d171f3c0e2c87e.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在1以下，它不知道该服务背后隐藏了多少5以下的炉床：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/665/f5e/edc/665f5eedc580d007fd9db6ced40f86d1.png"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是该服务如何准确地分配请求？</font><font style="vertical-align: inherit;">似乎使用轮循平衡吗？</font><font style="vertical-align: inherit;">让我们做对。&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes服务的平衡</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes服务不存在。没有为该服务分配IP地址和端口的过程。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以通过转到集群中的任何节点并运行netstat -ntlp命令来验证这一点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您甚至找不到分配给该服务的IP地址。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
服务的IP地址位于控制层，控制器中，并记录在数据库-etcd中。另一个组件kube-proxy使用相同的地址。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kube-proxy接收所有服务的IP地址列表，并在集群的每个节点上形成一组iptables规则。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些规则说：“如果我们看到服务的IP地址，则需要修改请求的目标地址并将其发送到其中一个Pod。”</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
服务的IP地址仅用作入口点，侦听此IP地址和端口的任何进程均不提供该服务的IP地址。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们来看一下</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。&nbsp;</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑由三个节点组成的集群。</font><font style="vertical-align: inherit;">每个节点上都有Pod：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/605/ed6/e82/605ed6e82d24139c7122fd0886fb3f5f.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浅米色的针织壁炉是这项服务的一部分。</font><font style="vertical-align: inherit;">由于该服务不作为进程存在，因此将其灰显：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/175/57b/919/17557b91988036bf15bdb5fd02b25c44.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个请求服务，应该落在以下相关的壁炉中：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13d/49c/2df/13d49c2dff1c5a15bfced3347ad4bc6c.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是服务不存在，没有进程。</font><font style="vertical-align: inherit;">它是如何工作的？</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7e/362/c43/a7e362c43d31ac5ba0368cbbfceae398.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在请求离开节点之前，它会通过iptables规则：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29d/eea/0ef/29deea0efafef803b87c66a7c17cc9cc.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iptables规则知道没有服务，并用与此服务关联的Pod的IP地址之一替换其IP地址：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4e/ec6/0ad/a4eec60ad28fbf16b085d9b8697dce81.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该请求会收到一个有效的IP地址作为目标地址，并且通常会被处理：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/653/ef7/4b8/653ef74b8f34567652c2e0a00c89d9a7.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据网络拓扑，请求最终到达壁炉：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/696/c59/873/696c5987341d20780825ff2a4f6f7d12.png"></div></li>
</ol><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iptables是否能够平衡负载？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不，iptables用于过滤，并非用于平衡。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，可以编写一组类似于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">伪平衡器</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的规则</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而这正是Kubernetes所做的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您有三个Pod，kube-proxy将编写以下规则：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择第一个概率为33％的规则，否则转到下一个规则。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择第二个可能性为50％的对象，否则转到下一条规则。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在下面选择第三个。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样的系统导致以33％的概率选择每个子的事实。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08e/d59/2bc/08ed592bc03dd1f9740f29985451aaca.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并且不能保证在文件1之后会在2以下选择它。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：iptables使用随机分布统计模块。</font><font style="vertical-align: inherit;">因此，平衡算法基于随机选择。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在您了解了服务的工作原理，让我们看一下更有趣的工作场景。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认情况下，Kubernetes中的长期连接不会扩展</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从前端到后端的每个HTTP请求都由一个单独的TCP连接来服务，该TCP连接将打开和关闭。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果前端每秒向后端发送100个请求，则将打开和关闭100个不同的TCP连接。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果打开一个TCP连接并将其用于所有后续HTTP请求，则可以减少请求的处理时间并减少负载。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTTP协议包含一个称为HTTP保持活动或重新使用连接的功能。在这种情况下，一个TCP连接用于发送和接收许多HTTP请求和响应：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a65/cef/c9f/a65cefc9f558265089c48cdf96a1d049.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
默认情况下不启用此功能：必须相应配置服务器和客户端。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
设置本身很简单，可用于大多数编程语言和环境。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是一些使用不同语言编写的示例的链接：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://medium.com/%40onufrienkos/keep-alive-connection-on-inter-service-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Node.js中保持活动</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://www.baeldung.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在春季启动时保持活跃</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://blog.insightdatascience.com/learning-about-the-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Python中保持活动</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://docs.microsoft.com/en-us/dotnet/api/system.net."><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在.NET中保持活动</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果在Kubernetes中使用keep-alive，会发生什么？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设前端和后端都支持keep-alive。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们有一个前端副本和三个后端副本。前端发出第一个请求，并打开到后端的TCP连接。请求到达服务，后端容器之一被选择为目标地址。它发送一个响应到后端，前端接收它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与通常的情况不同，当TCP连接在收到响应后关闭时，现在对于以下HTTP请求保持打开状态。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果前端发送更多的后端请求会怎样？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了转发这些请求，将使用一个开放的TCP连接，所有请求都将被发送到第一个请求到达的后端的同一请求。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
iptables不应该重新分配流量吗？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下不行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建TCP连接时，它将通过iptables规则，该规则为流量将流向的后端选择特定的规则。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于以下所有请求都通过已经打开的TCP连接进行，因此不再调用iptables规则。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们看看它的外观</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个子程序向服务发送请求：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d1/235/11b/0d123511bd0e4e5d3806fdd7917e0bd7.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您已经知道接下来会发生什么。</font><font style="vertical-align: inherit;">该服务不存在，但是有iptables规则可以处理请求：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d1/235/11b/0d123511bd0e4e5d3806fdd7917e0bd7.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">后端容器之一将被选为目标地址：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ae/5c0/e5b/9ae5c0e5bd3478f20d1546951a298dfd.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该请求到达了壁炉。</font><font style="vertical-align: inherit;">此时，将在两个容器之间建立永久的TCP连接：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b23/154/129/b23154129408fd401651880d3b94d816.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来自第一个pod的任何下一个请求都将通过一个已经建立的连接：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/e1c/232/f90e1c232dbc399d39aaff47045b9aa8.gif"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，您获得了更快的响应和更高的带宽，但是失去了扩展后端的能力。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
即使您的后端有两个Pod，且连接保持恒定，流量也始终会流向其中一个。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这个可以解决吗？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于Kubernetes不知道如何平衡持久连接，因此此任务是您的责任。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
服务是称为端点的一组IP地址和端口。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您的应用程序可以从服务获取端点列表，并决定如何在端点之间分配请求。您可以使用循环方式打开与每个炉床的持久连接并平衡这些连接之间的请求。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
或者应用更</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复杂的平衡算法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
负责平衡的客户端代码应遵循以下逻辑：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从服务获取端点列表。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于每个端点，打开一个持久连接。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当您需要发出请求时，请使用打开的连接之一。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定期更新端点列表，创建新端点或在端点更改时关闭旧的持久连接。</font></font></li>
</ol><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是它的外观</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以在客户端平衡请求，而不是向服务发送第一个请求：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98f/91a/0c9/98f91a0c9ecae76bd8f286ba3a282ff1.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您需要编写代码来询问哪些Pod是服务的一部分：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/040/203/cb5/040203cb52d6b22bb8179a6870d2485f.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">收到列表后，立即将其保存在客户端，并使用它连接到Pod：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e5/741/3e7/4e57413e7b01b017cf57fab312b28089.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您自己负责负载平衡算法：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/bc6/7ad/8d9bc67ad511790b477c8509c91fffb0.gif"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在的问题是：此问题仅适用于HTTP保持活动状态吗？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">客户端负载平衡</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTTP不是唯一可以使用持久TCP连接的协议。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您的应用程序使用数据库，则每次需要执行请求或从数据库获取文档时，TCP连接都不会打开。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而是打开并使用与数据库的永久TCP连接。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您的数据库部署在Kubernetes中，并且访问作为服务提供，那么您将遇到与上一节所述相同的问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个数据库副本将比其余副本加载更多。</font><font style="vertical-align: inherit;">Kube-proxy和Kubernetes将无助于平衡连接。</font><font style="vertical-align: inherit;">您应该注意平衡对数据库的查询。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据用于连接数据库的库，您可能有多种选择来解决此问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是从Node.js访问MySQL数据库集群的示例：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mysql'</span>);
<span class="hljs-keyword">var</span> poolCluster = mysql.createPoolCluster();<font></font>
<font></font>
<span class="hljs-keyword">var</span> endpoints = <span class="hljs-comment">/* retrieve endpoints from the Service */</span><font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> [index, endpoint] <span class="hljs-keyword">of</span> endpoints) {<font></font>
&nbsp; poolCluster.add(<span class="hljs-string">`mysql-replica-<span class="hljs-subst">${index}</span>`</span>, endpoint);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Make queries to the clustered MySQL database</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还有大量其他使用持久性TCP连接的协议：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WebSocket和安全的WebSocket</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gRPC</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">插座</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMQP</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您应该已经熟悉其中的大多数协议。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，如果这些协议如此流行，为什么没有标准化的平衡解决方案呢？为什么需要更改客户端逻辑？有原生的Kubernetes解决方案吗？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kube-proxy和iptables旨在关闭Kubernetes的大多数标准部署方案。这是为了方便。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您使用提供REST API的Web服务，那么您很幸运-在这种情况下，不使用永久TCP连接，则可以使用任何Kubernetes服务。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，一旦您开始使用持久的TCP连接，就必须弄清楚如何在后端平均分配负载。 Kubernetes不包含针对这种情况的现成解决方案。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，当然，有些选项可能会有所帮助。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平衡Kubernetes中的长期连接</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes提供四种服务类型：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clusterip</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">节点端口</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">负载均衡器</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无头</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前三个服务基于虚拟IP地址，kube-proxy使用它来构建iptables规则。</font><font style="vertical-align: inherit;">但是所有服务的基本基础都是无头式服务。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
没有IP地址与无头服务关联，它仅提供一种机制，用于获取IP地址列表和关联的炉床（端点）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有服务均基于无头服务。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ClusterIP服务是一项无头服务，其中包括一些附加功能：&nbsp;</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">管理层为它分配一个IP地址。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kube-proxy形成必要的iptables规则。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，您可以忽略kube-proxy，而直接使用从无头服务收到的端点列表来平衡应用程序中的负载。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是如何为集群中部署的所有应用程序添加类似的逻辑？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您的应用程序已经被部署，那么这样的任务似乎是不可能的。</font><font style="vertical-align: inherit;">但是，还有另一种选择。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务网格将为您提供帮助</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可能已经注意到，客户端负载平衡策略是非常标准的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当应用程序启动时，它：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从服务获取IP地址列表。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">打开并维护连接池。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定期更新池，添加或删除端点。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一旦应用程序要发出请求，它就会：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用某种逻辑（例如轮询）选择可用的连接。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成请求。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些步骤适用于WebSockets，gRPC和AMQP。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以将此逻辑分为一个单独的库，并在您的应用程序中使用它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，可以改用Istio或Linkerd之类的服务网格。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Service Mesh通过以下过程来补充您的应用程序：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自动搜索服务的IP地址。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查连接，例如WebSockets和gRPC。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用正确的协议平衡请求。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Service Mesh可以帮助管理群集中的流量，但是它占用大量资源。</font><font style="vertical-align: inherit;">其他选项使用的是第三方库（例如Netflix Ribbon）或可编程代理（例如Envoy）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您忽略平衡问题会怎样？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您不能使用负载平衡，也不会注意到任何更改。让我们看一些工作方案。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您的客户端多于服务器，那么这不是什么大问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设有五个客户端连接到两个服务器。即使没有平衡，也将使用两个服务器：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3eb/2a3/ebf/3eb2a3ebfd09862d4200744170daec7e.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
连接分布不均：可能有四个客户端连接到同一服务器，但是很有可能同时使用这两个服务器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更有问题的是相反的情况。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果客户端较少，服务器更多，则可能无法充分利用您的资源，并且可能会出现瓶颈。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设有两个客户端和五个服务器。</font><font style="vertical-align: inherit;">充其量，将有两个永久连接到五分之二的服务器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其他服务器将处于空闲状态：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee5/0d2/eaf/ee50d2eaf1dbefd5933dd9ec5221bd58.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果这两个服务器无法处理客户端请求处理，则水平扩展将无济于事。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes服务旨在在大多数标准Web应用程序场景中工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，一旦开始使用使用持久性TCP连接的应用程序协议（例如数据库，gRPC或WebSockets），服务就不再适用。</font><font style="vertical-align: inherit;">Kubernetes不提供用于平衡持久TCP连接的内部机制。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这意味着您必须编写具有客户端平衡功能的应用程序。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由</font></font></i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mail.ru的Kubernetes aaS</font></font></i></a><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">团队准备的翻译</font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></i><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有什么要阅读的主题</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes中的三个级别的自动缩放以及如何有效地使用它们</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。&nbsp;</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes本着盗版的精神，提供了一个实现模板</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   Kubernetes  </a>.</li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN493808/index.html">用corutin线性化异步代码</a></li>
<li><a href="../zh-CN493810/index.html">五年的文件识别市场密集开发</a></li>
<li><a href="../zh-CN493814/index.html">我们如何在巴塞罗那进行采访</a></li>
<li><a href="../zh-CN493816/index.html">Git指南 第1部分：有关.git目录的所有信息</a></li>
<li><a href="../zh-CN493818/index.html">Git指南 部分2：黄金法则和其他基础基础</a></li>
<li><a href="../zh-CN493822/index.html">UEFI在各种平台上实施的问题和功能</a></li>
<li><a href="../zh-CN493826/index.html">分而治之：改善水的电解</a></li>
<li><a href="../zh-CN493828/index.html">界面如何讲述视频游戏中的故事</a></li>
<li><a href="../zh-CN493830/index.html">初级iOS开发人员在初次采访中会问什么问题</a></li>
<li><a href="../zh-CN493832/index.html">冠状病毒COVID-19分发仪表板（React + Chart.js + BootstrapTable）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>