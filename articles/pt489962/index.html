<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèæ üë≤ ü§ôüèª Distribui√ß√£o de dados no Apache Ignite üòπ üåõ üòª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√°! Este post √© uma vers√£o resumida da minha palestra de mesmo nome na reuni√£o da comunidade Apache Ignite . Voc√™ pode assistir √† vers√£o em v√≠deo com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Distribui√ß√£o de dados no Apache Ignite</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/gridgain/blog/489962/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ol√°! </font><font style="vertical-align: inherit;">Este post √© uma vers√£o resumida da minha palestra de mesmo nome na reuni√£o da comunidade </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apache Ignite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Voc√™ pode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assistir √†</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vers√£o em v√≠deo completa, juntamente com perguntas e respostas </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">aqui</font></a><font style="vertical-align: inherit;"> , e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baixar os</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> slides </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">aqui</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">No relat√≥rio, tentei mostrar por exemplos como os dados s√£o distribu√≠dos no Apache Ignite.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que voc√™ precisa distribuir qualquer coisa</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um hist√≥rico bastante padr√£o do desenvolvimento de qualquer sistema que exija armazenamento e processamento de dados √© a conquista de um determinado limite. Existem muitos dados e eles n√£o s√£o fisicamente colocados no dispositivo de armazenamento ou a carga est√° aumentando a uma taxa que um servidor n√£o consegue mais processar um n√∫mero t√£o grande de solicita√ß√µes. Existem casos frequentes em que ambos ocorrem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como regra, eles v√™m para uma das duas solu√ß√µes: compartilhar o armazenamento existente ou alternar para um banco de dados distribu√≠do. Ambas as solu√ß√µes t√™m v√°rios recursos comuns, o mais √≥bvio dos quais √© o uso de mais de um n√≥ para trabalhar com dados. Al√©m disso, muitos n√≥s chamarei de topologia.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O problema da distribui√ß√£o de dados entre os n√≥s da topologia pode ser formulado como um conjunto de requisitos, que nossa distribui√ß√£o deve satisfazer:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â necess√°rio um algoritmo que permita que todos os n√≥s da topologia e aplicativos clientes cheguem √† mesma conclus√£o sobre em qual n√≥ ou n√≥s o determinado objeto (ou chave) est√°.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uniformidade de distribui√ß√£o. </font><font style="vertical-align: inherit;">Quanto mais uniformemente os dados s√£o distribu√≠dos entre os n√≥s, mais uniformemente a carga nesses n√≥s ser√° distribu√≠da. </font><font style="vertical-align: inherit;">Aqui, suponho que nossos n√≥s tenham aproximadamente os mesmos recursos.</font></font></li>
<li>  .      ,       ,    .   ,       ,       ,     .<br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atingir os dois primeiros requisitos √© bastante f√°cil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma abordagem familiar, frequentemente usada para equilibrar a carga entre servidores funcionalmente equivalentes, dividindo o m√≥dulo N, em que N √© o n√∫mero de n√≥s na topologia e temos uma correspond√™ncia individual entre o n√∫mero do n√≥ e seu identificador. Ent√£o, tudo o que precisamos fazer √© representar a chave do objeto como um valor num√©rico usando uma fun√ß√£o hash e tirar o restante da divis√£o por N. do valor </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zi/7x/ii/zi7xiiu8xmrjgaeghuc8xkekubk.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
obtido.O diagrama mostra a distribui√ß√£o de 16 chaves em 3 n√≥s. Pode-se observar que essa distribui√ß√£o √© uniforme e o algoritmo para obter o n√≥ para o objeto √© simples e garante que, se todos os n√≥s da topologia usarem esse algoritmo, o mesmo resultado ser√° obtido para a mesma chave e o mesmo N.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas o que acontece se introduzirmos o quarto n√≥ na topologia? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/82/ro/-i/82ro-ipa6d3lw8stb_fx7e9_wos.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nossa fun√ß√£o mudou, agora tomamos o restante da divis√£o por 4, n√£o por 3. E se a fun√ß√£o mudou, a distribui√ß√£o mudou e muito. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui, o local anterior dos objetos para a vers√£o anterior da topologia de tr√™s n√≥s √© mostrado em vermelho e a posi√ß√£o dos objetos para a nova vers√£o da topologia de quatro n√≥s √© verde, respectivamente. Isso √© muito parecido com os arquivos diff comuns, mas em vez de arquivos, temos n√≥s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â f√°cil ver que os dados foram movidos n√£o apenas para o novo n√≥, mas tamb√©m houve uma troca de dados entre os n√≥s que j√° estavam na topologia. Essa. observamos tr√°fego esp√∫rio entre n√≥s e o requisito de uma altera√ß√£o m√≠nima na distribui√ß√£o n√£o √© atendido.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Duas maneiras populares de resolver o problema da distribui√ß√£o de dados, levando em considera√ß√£o os requisitos listados, s√£o as seguintes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hash consistente</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maior algoritmo de peso aleat√≥rio (HRW), tamb√©m conhecido como hash de encontro.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ambos os algoritmos s√£o muito simples. </font><font style="vertical-align: inherit;">Suas descri√ß√µes na Wikipedia se encaixam em v√°rias frases. </font><font style="vertical-align: inherit;">Embora seja dif√≠cil cham√°-los √≥bvios. </font><font style="vertical-align: inherit;">Para os interessados, recomendo a leitura dos artigos originais </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hashing consistente e √°rvores aleat√≥rias: protocolos de armazenamento em cache distribu√≠dos para al√≠vio de pontos quentes na World Wide Web</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um esquema de mapeamento baseado em nome para encontro</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mais compreensivelmente, na minha opini√£o, a id√©ia de um algoritmo de hash consistente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© transmitida neste curso de Stanford</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vejamos esses algoritmos com mais detalhes.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hashing Consistente</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O truque subjacente ao algoritmo de hash consistente √© mapear os n√≥s e os objetos armazenados no mesmo espa√ßo identificador. </font><font style="vertical-align: inherit;">Isso torna nossas entidades, objetos e n√≥s aparentemente diferentes compar√°veis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para obter esse mapeamento, simplesmente aplicamos a mesma fun√ß√£o de hash √†s chaves dos objetos e aos identificadores dos n√≥s. </font><font style="vertical-align: inherit;">O resultado da fun√ß√£o de hash para o n√≥ ser√° chamado de token; isso ser√° √∫til para n√≥s posteriormente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Representamos nosso espa√ßo identificador na forma de um c√≠rculo, ou seja, </font><font style="vertical-align: inherit;">simplesmente assumimos que o valor m√°ximo do identificador segue imediatamente o valor m√≠nimo do identificador.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, para determinar em qual n√≥ o objeto vive, voc√™ precisa obter o valor da fun√ß√£o hash de sua chave e simplesmente mover no sentido hor√°rio ao redor do c√≠rculo at√© encontrarmos o token de um n√≥ no caminho. A dire√ß√£o do movimento n√£o √© importante, mas deve ser fixa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O movimento imagin√°rio no sentido hor√°rio √© funcionalmente equivalente a uma pesquisa bin√°ria em uma matriz classificada de tokens de n√≥. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ca/dh/fy/cadhfyrlc9b_maoinnjw0kvp6fm.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No diagrama, cada setor de uma cor espec√≠fica reflete o espa√ßo identificador pelo qual um n√≥ espec√≠fico √© respons√°vel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se adicionarmos um novo n√≥, </font></font><br>
<br>
<img src="https://habrastorage.org/webt/v7/an/3r/v7an3r9bwxn9hnziy-w7umr5viq.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ele dividir√° um dos setores em duas partes e assumir√° completamente as chaves correspondentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste exemplo, o n√≥ 3 assumiu parte das chaves do n√≥ 1.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como voc√™ pode ver, essa abordagem fornece uma distribui√ß√£o bastante desigual de objetos entre n√≥s, porque √© altamente dependente dos identificadores dos pr√≥prios n√≥s. Como essa abordagem pode ser melhorada? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ pode atribuir mais de um token aos n√≥s (geralmente centenas). Isso pode ser alcan√ßado, por exemplo, introduzindo muitas fun√ß√µes de hash para o n√≥ (uma por token) ou aplicando repetidamente a mesma fun√ß√£o de hash ao token obtido na etapa anterior. Mas n√£o devemos esquecer as colis√µes. N√£o deve haver dois n√≥s com o mesmo token. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7i/m2/ay/7im2ay5cr_ydc5hh62vlwcaqhp0.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste exemplo, cada n√≥ possui 4 tokens.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que mais √© importante mencionar: se queremos garantir a seguran√ßa dos dados no caso de um n√≥ sair da topologia, precisamos armazenar as chaves em v√°rios n√≥s (as chamadas r√©plicas ou backups). </font><font style="vertical-align: inherit;">No caso do algoritmo de hash consistente, as r√©plicas ser√£o os seguintes n√≥s N-1 no c√≠rculo, onde N √© o fator de replica√ß√£o. </font><font style="vertical-align: inherit;">Obviamente, a ordem dos n√≥s deve ser determinada por um token espec√≠fico (por exemplo, pelo primeiro), porque </font><font style="vertical-align: inherit;">ao usar v√°rios tokens para cada um deles, a organiza√ß√£o dos n√≥s pode ser diferente. </font><font style="vertical-align: inherit;">Preste aten√ß√£o ao esquema: ele n√£o possui um padr√£o claro de repeti√ß√£o de n√≥s.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quanto √† exig√™ncia de uma altera√ß√£o m√≠nima na distribui√ß√£o ao alterar a topologia, ela √© satisfeita porque a ordem m√∫tua dos n√≥s no c√≠rculo permanece inalterada. </font><font style="vertical-align: inherit;">Essa. </font><font style="vertical-align: inherit;">remover um n√≥ da topologia n√£o alterar√° a rela√ß√£o de ordem entre os n√≥s restantes.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hash de encontro</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O algoritmo de hash Rendezvous parece ainda mais simples que o hash consistente. O algoritmo √© baseado no mesmo princ√≠pio de invari√¢ncia das rela√ß√µes de ordem. Mas, em vez de tornar n√≥s e objetos compar√°veis, fazemos apenas n√≥s para um objeto espec√≠fico compar√°vel. Essa. determinamos a rela√ß√£o de ordem entre os n√≥s para cada objeto independentemente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais uma vez, o hash nos ajuda com isso. Mas agora, para determinar o peso do n√≥ N para um determinado objeto O, misturamos o identificador do objeto com o identificador do n√≥ e obtemos o hash desse mix. Depois de fazer essa opera√ß√£o para cada n√≥, obtemos um conjunto de pesos pelos quais classificamos os n√≥s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O n√≥ que acabou sendo o primeiro e ser√° respons√°vel por armazenar o objeto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como todos os n√≥s da topologia usam os mesmos dados de entrada, o resultado para eles ser√° id√™ntico. O que satisfaz o primeiro requisito. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ox/hs/bw/oxhsbwgq8xrlfrirs8xupmx3hww.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere um exemplo. Aqui temos uma rela√ß√£o de ordem entre tr√™s n√≥s para quatro chaves diferentes. Amarelo indica o n√≥ com maior peso, ou seja, o n√≥ que ser√° respons√°vel por uma chave espec√≠fica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adicione outro n√≥ √† topologia.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hc/a9/4s/hca94sz_p5pz-lwflppuqlm7c54.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu deliberadamente coloquei na diagonal para levar em conta todas as op√ß√µes poss√≠veis. Aqui, o n√≥ 3, mostrado em verde, entrou na topologia. Portanto, a distribui√ß√£o de peso dos n√≥s para cada uma das chaves foi alterada. Vermelho indica os n√≥s que mudaram de local na lista para uma chave espec√≠fica, porque os pesos desses n√≥s eram menores que o peso do n√≥ adicionado. No entanto, essa altera√ß√£o afetou apenas uma das chaves, K3. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos derivar trai√ßoeiramente um n√≥ de uma topologia. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ds/gr/d_/dsgrd_q9ai9yi9p5x08ubfgflem.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais uma vez, as altera√ß√µes afetaram apenas uma tecla, desta vez K1. Os objetos restantes n√£o foram afetados. O motivo, como no caso de hash consistente, √© a invari√¢ncia do relacionamento de ordem entre qualquer par de n√≥s. Essa. o requisito de uma altera√ß√£o m√≠nima na distribui√ß√£o √© atendido e n√£o h√° tr√°fego esp√∫rio entre os n√≥s.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A distribui√ß√£o para o encontro parece muito boa e n√£o requer truques adicionais em compara√ß√£o com hash consistente como tokens. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Caso desejemos oferecer suporte √† replica√ß√£o, o pr√≥ximo n√≥ da lista ser√° a primeira r√©plica do objeto, o pr√≥ximo n√≥ ser√° a segunda r√©plica etc.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o hash de encontro √© usado no Apache Ignite</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A chamada fun√ß√£o de afinidade √© respons√°vel pela distribui√ß√£o de dados no Apache Ignite (consulte a interface </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AffinityFunction</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). A implementa√ß√£o padr√£o √© o hash de encontro (consulte a classe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RendezvousAffinityFunction</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira coisa que voc√™ precisa prestar aten√ß√£o √© que o Apache Ignite n√£o mapeia objetos armazenados diretamente nos n√≥s de topologia. Em vez disso, √© introduzido um conceito adicional - parti√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma parti√ß√£o √© um cont√™iner para objetos e uma unidade de replica√ß√£o. Al√©m disso, o n√∫mero de parti√ß√µes para um cache espec√≠fico (este √© um an√°logo da tabela nos bancos de dados familiares) √© definido no est√°gio de configura√ß√£o e n√£o muda durante o ciclo de vida do cache.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, podemos exibir objetos em parti√ß√µes usando divis√£o de m√≥dulo efetiva e usar hash de encontro para exibir parti√ß√µes em n√≥s. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wd/wr/vt/wdwrvtuau9ywcgq4uqk0hhqscu8.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Porque como o n√∫mero de parti√ß√µes para o cache √© constante, podemos calcular a distribui√ß√£o da parti√ß√£o por n√≥s uma vez e armazenar em cache o resultado at√© que a topologia seja alterada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada n√≥ calcula essa distribui√ß√£o independentemente, mas em todos os n√≥s com os mesmos dados de entrada, essa distribui√ß√£o ser√° id√™ntica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A parti√ß√£o pode ter v√°rias c√≥pias, n√≥s as chamamos de backups. A parti√ß√£o prim√°ria √© chamada de parti√ß√£o prim√°ria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para a melhor distribui√ß√£o de chaves entre parti√ß√µes e parti√ß√µes por n√≥s, a seguinte regra deve ser cumprida: o n√∫mero de parti√ß√µes deve ser significativamente maior que o n√∫mero de n√≥s; por sua vez, o n√∫mero de chaves deve ser significativamente maior que o n√∫mero de parti√ß√µes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os caches no Ignite s√£o particionados e replicados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em um cache particionado, o n√∫mero de backups √© definido no est√°gio de cria√ß√£o do cache. Parti√ß√µes - prim√°rias e backups - s√£o distribu√≠das igualmente entre os n√≥s. Esse cache √© mais adequado para trabalhar com dados operacionais, como fornece o melhor desempenho de grava√ß√£o, o que depende diretamente do n√∫mero de backups. Em geral, quanto mais backups, mais n√≥s devem confirmar o registro de chave.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hh/fs/_u/hhfs_ujczi2m1p8kl4c5z3p2ra4.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste exemplo, o cache possui um backup. </font><font style="vertical-align: inherit;">Essa. </font><font style="vertical-align: inherit;">podemos perder um n√≥ e n√£o perder dados, porque </font><font style="vertical-align: inherit;">Os backups de parti√ß√£o nunca s√£o armazenados no mesmo n√≥ que a parti√ß√£o prim√°ria ou seu outro backup. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No cache replicado, o n√∫mero de backups √© sempre igual ao n√∫mero de n√≥s de topologia menos 1. Ou seja, </font><font style="vertical-align: inherit;">cada n√≥ sempre cont√©m c√≥pias de todas as parti√ß√µes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/n-/fk/by/n-fkbyie-hipm40twvyg_erjjm0.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse cache √© mais adequado para trabalhar com dados raramente alterados (por exemplo, diret√≥rios) e fornece a maior disponibilidade, como </font><font style="vertical-align: inherit;">podemos perder n√≥s N-1 (neste caso, 3) sem perder dados. </font><font style="vertical-align: inherit;">Tamb√©m nesta op√ß√£o, obteremos o desempenho m√°ximo de leitura se permitirmos ler dados das parti√ß√µes prim√°rias e dos backups.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coloca√ß√£o de dados no Apache Ignite</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um conceito importante a ser lembrado para obter o melhor desempenho √© a coloca√ß√£o. Coloca√ß√£o √© a coloca√ß√£o de qualquer objeto no mesmo local. No nosso caso, objetos s√£o entidades armazenadas no cache e um local √© um n√≥. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se os objetos forem distribu√≠dos por parti√ß√µes da mesma fun√ß√£o de afinidade, √© l√≥gico que objetos com a mesma chave de afinidade caiam na mesma parti√ß√£o e, portanto, no mesmo n√≥. No Ignite, isso √© chamado de colocation de afinidade. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por padr√£o, uma chave de afinidade √© a chave prim√°ria de um objeto. Mas no Ignite, voc√™ pode usar qualquer outro campo de um objeto como uma chave de afinidade.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A disposi√ß√£o reduz significativamente a quantidade de dados enviados entre os n√≥s para executar c√°lculos ou consultas SQL, o que naturalmente leva a uma redu√ß√£o no tempo gasto nessas tarefas. Considere esse conceito por exemplo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deixe nosso modelo de dados consistir em duas entidades: order (Order) e position position (OrderItem). Um pedido pode corresponder a muitos itens. Os identificadores de pedido e item de linha s√£o independentes, mas o item de linha possui uma chave estrangeira que se refere ao pedido correspondente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que precisamos executar alguma tarefa, que para cada pedido deve executar c√°lculos para as posi√ß√µes desse pedido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por padr√£o, uma chave de afinidade √© uma chave prim√°ria. Portanto, ordens e posi√ß√µes ser√£o distribu√≠das entre os n√≥s de acordo com suas chaves prim√°rias, as quais, lembro-me, s√£o independentes.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tk/q-/vq/tkq-vq1_sbghpcqdsz8ythpehim.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No diagrama, as ordens s√£o representadas por quadrados e posi√ß√µes em c√≠rculos. Cor indica que o item pertence ao pedido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com essa distribui√ß√£o de dados, nossa tarefa hipot√©tica ser√° enviada para o n√≥ em que a ordem desejada est√° localizada e, em seguida, ser√° necess√°rio ler as posi√ß√µes de todos os outros n√≥s ou enviar uma subtarefa para esses n√≥s e obter o resultado do c√°lculo. Essa √© uma intera√ß√£o de rede desnecess√°ria que pode e deve ser evitada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E se dissermos ao Ignite que os itens do pedido devem ser colocados nos mesmos n√≥s que os pr√≥prios pedidos, ou seja, coletar dados? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como chave de afinidade para a posi√ß√£o, pegamos a chave estrangeira OrderId e esse campo ser√° usado ao calcular a parti√ß√£o √† qual o registro pertence. Al√©m disso, dentro da parti√ß√£o, sempre podemos encontrar nosso objeto pela chave prim√°ria.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lv/uq/kg/lvuqkgzf9gpoot8gjnr25uxb6ve.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, se os dois caches (Order e OrderItem) usarem a mesma fun√ß√£o de afinidade com os mesmos par√¢metros, nossos dados estar√£o pr√≥ximos e n√£o precisaremos percorrer a rede para obter itens de pedido.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configura√ß√£o de afinidade no Apache Ignite</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na implementa√ß√£o atual, um objeto de fun√ß√£o de afinidade √© um par√¢metro de configura√ß√£o de cache. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pr√≥pria fun√ß√£o de afinidade aceita os seguintes argumentos ao criar:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√∫mero de parti√ß√µes;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O n√∫mero de backups (na verdade, esse tamb√©m √© o par√¢metro de configura√ß√£o do cache);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Filtro de backup;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sinalizar excludeNeighbors.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essas configura√ß√µes n√£o podem ser alteradas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com o n√∫mero de parti√ß√µes e backups, tudo parece estar claro. Falarei sobre o filtro de backup e o sinalizador excludeNeighbors um pouco mais tarde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No tempo de execu√ß√£o, a fun√ß√£o de afinidade de entrada recebe a topologia atual do cluster - essencialmente uma lista de n√≥s do cluster - e calcula a distribui√ß√£o da parti√ß√£o por n√≥s de acordo com os exemplos que mostrei quando falei sobre o algoritmo de hash de encontro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quanto ao filtro de backup, este √© um predicado que permite impedir que fun√ß√µes de afinidade designem parti√ß√µes de backup para um n√≥ para o qual o predicado retornou falso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como exemplo, suponha que nossos n√≥s f√≠sicos - servidores - estejam localizados no datacenter em diferentes racks. Normalmente, cada rack tem seu pr√≥prio poder independente ...</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5e/ts/wy/5etswypgpotv2e9exzu3gsyl9f8.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... e se perdermos o rack, perderemos os dados. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nz/hy/5d/nzhy5dzl77t7pxhtxbtqubcbzek.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste exemplo, perdemos metade das parti√ß√µes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas se definirmos o filtro de backup correto, a distribui√ß√£o ser√° alterada de maneira que ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/20/90/gy/2090gyzlg_0-80-dhkw8hvplftm.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... se o rack for perdido, n√£o haver√° perda de dados e eles ainda estar√£o dispon√≠veis. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/oo/eg/k5/ooegk5vas7xhk7qzrergws5ieli.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O sinalizador excludeNeighbors executa uma fun√ß√£o semelhante e, na verdade, √© uma abrevia√ß√£o para um caso espec√≠fico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Geralmente, v√°rios n√≥s do Ignite s√£o executados no mesmo host f√≠sico. Esse caso √© muito parecido com o exemplo de racks no data center, s√≥ que agora estamos lutando contra a perda de dados com a perda do host, n√£o os racks. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tk/ze/wn/tkzewnmjc5iigjd_appzyvfoheo.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O resto √© o mesmo. Voc√™ pode implementar esse comportamento usando um filtro de backup. Esse sinalizador √© um legado hist√≥rico e pode ser removido na pr√≥xima vers√£o principal do Ignite.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece que eu falei sobre a fun√ß√£o de afinidade e distribui√ß√£o de dados, tudo o que um desenvolvedor que usa o Apache Ignite precisa saber. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Concluindo, vejamos um exemplo da distribui√ß√£o de 16 parti√ß√µes de acordo com a topologia de 3 n√≥s. Por simplicidade e clareza, acreditamos que as parti√ß√µes n√£o possuem backups. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acabei de fazer e escrevi um pequeno teste que me trouxe a distribui√ß√£o real: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yy/lm/np/yylmnpenoifogzoo0lig3kzw_5g.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
como voc√™ pode ver, a uniformidade da distribui√ß√£o n√£o √© ideal. Mas o erro ser√° visivelmente mais baixo com um aumento no n√∫mero de n√≥s e parti√ß√µes. A regra principal que deve ser observada √© que o n√∫mero de parti√ß√µes √© significativamente maior que o n√∫mero de n√≥s. Agora, no Ignite, o n√∫mero padr√£o de parti√ß√µes para um cache particionado √© 1024. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, adicione um novo n√≥ √† topologia.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xd/xf/sp/xdxfspt29ky3x0gfceqi_xiswv0.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parte das partes se mudou para ele. Ao mesmo tempo, foi observado o requisito de uma altera√ß√£o m√≠nima na distribui√ß√£o: o novo n√≥ recebeu parte das parti√ß√µes, enquanto os outros n√≥s n√£o trocaram parti√ß√µes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Removemos da topologia o n√≥ que estava presente no est√°gio inicial: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ym/b5/il/ymb5ilednyy4dxf6ynojfva7gao.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora todas as parti√ß√µes associadas ao n√≥ zero foram redistribu√≠das entre outros n√≥s da topologia, sem violar nossos requisitos de distribui√ß√£o.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como voc√™ pode ver, a solu√ß√£o para problemas complexos geralmente √© baseada em id√©ias bastante triviais, embora n√£o totalmente √≥bvias. </font><font style="vertical-align: inherit;">As solu√ß√µes descritas s√£o usadas na maioria dos bancos de dados distribu√≠dos e fazem um bom trabalho. </font><font style="vertical-align: inherit;">Mas essas decis√µes s√£o aleat√≥rias e, portanto, a uniformidade da distribui√ß√£o est√° longe de ser ideal. </font><font style="vertical-align: inherit;">A uniformidade pode ser aprimorada sem sacrificar o desempenho e outros requisitos de distribui√ß√£o? </font><font style="vertical-align: inherit;">A quest√£o permanece em aberto.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt489952/index.html">Pap√©is de parede ao vivo e motivadores</a></li>
<li><a href="../pt489954/index.html">Seagate SkyHawk AI - enorme e vingativo</a></li>
<li><a href="../pt489956/index.html">Animamos o RecyclerView facilmente, sem mudar para o ViewPager2</a></li>
<li><a href="../pt489958/index.html">Explica√ß√£o: por que o wc em Haskell acabou sendo "mais r√°pido" do que o anal√≥gico em C</a></li>
<li><a href="../pt489960/index.html">Constru√ß√£o automatizada de uma aplica√ß√£o Delphi</a></li>
<li><a href="../pt489968/index.html">Detectamos a degrada√ß√£o das baterias AA e AAA em correntes de 0,3 a partir da capacit√¢ncia</a></li>
<li><a href="../pt489970/index.html">Programador, Pack e John Steinbeck</a></li>
<li><a href="../pt489974/index.html">Kha vs HTML5: compilando JavaScript em C ++</a></li>
<li><a href="../pt489984/index.html">AMA sobre udalenka: perguntar - n√≥s respondemos</a></li>
<li><a href="../pt489986/index.html">Utilit√°rio Designer de est√°gio de energia - Ferramenta para desenvolvedores de eletr√¥nicos de pot√™ncia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>