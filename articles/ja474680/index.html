<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖼️ 📬 🤘🏻 AIと2048。パート2：ミニマックス+アルファベータクリッピング 🙆 🕍 🌠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="モンテカルロ法を検討しました。今日は、アルファベータクリッピングを備えた古き良きミニマックスを使用して、2048年にコンピューターの心がどのように機能するかを確認します。
 
 
 この記事は、モバイルアプリケーションを開発し、ソフトウェアテストサービスを提供する企業であるEDISONのサポートを得...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>AIと2048。パート2：ミニマックス+アルファベータクリッピング</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/474680/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><div style="text-align:center;"><img width="690" height="314" src="https://habrastorage.org/webt/9t/ym/10/9tym105d327kylbfpejz4inkdxu.png"></div></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モンテカルロ法を検討しました</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。今日は、アルファベータクリッピングを備えた古き良きミニマックスを使用して、2048年にコンピューターの心がどのように機能するかを確認します。</font></font><a name="habracut"></a><br>
<br>
<blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="EDISONソフトウェア-ウェブ開発"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISONソフトウェア-ウェブ開発"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モバイルアプリケーション</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">開発</font></a><font style="vertical-align: inherit;">し、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソフトウェアテストサービス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を提供</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">する</font></a><font style="vertical-align: inherit;">企業であるEDISONのサポートを得て作成されました</font><font style="vertical-align: inherit;">。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソリューションは</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、2048年のゲームでAIを教える方法</font></a><font style="vertical-align: inherit;">についての議論で言及し</font><font style="vertical-align: inherit;">たユーザーstackoverflow </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img width="14" height="14" src="https://habrastorage.org/webt/7c/q2/x_/7cq2x_1w7otpr1ksh4yryg83h4c.jpeg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ovolve</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によってスパイされました</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ovolveからのコメント翻訳</font></font></b><div class="spoiler_text"> —  ,      .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>.<br>
<br>
       90% ,  java-     ,  100    ,     ,   .<br>
<br>
         ,         ,     ,       ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">- </a>.         ,       ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  </a>     ,    .<br>
<br>
<img align="right" width="344" height="343" src="https://habrastorage.org/webt/hm/s0/cu/hms0cuvsvpeyvyvozxm-3f88xui.png"><br clear="left">
<h3></h3><br>
   ,      ,    /,   /.       ,     ,         . ,  ,           ,       <em>ó</em>.<br>
<br>
    .    ,     eval-,        .<br>
<br>
<img align="right" width="342" height="343" src="https://habrastorage.org/webt/iq/wp/4p/iqwp4pn8rsoynb1u6eknm99gmt8.png"><br clear="left">
<h3> (, )</h3><br>
        ,       , ,  ,       .          ,    .<br>
<br>
  Hacker News  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>       .<br>
<br>
<div class="spoiler"><b class="spoiler_title">   Hacker News</b><div class="spoiler_text"><blockquote>     ,   ,     ,       .<br>
<br>
    , ,   ,   .  -     , OP       ,     .<br>
<br>
     ,   ,   ,        <b>G(V, E)</b>,  <b>V</b> —   ,  <b>E</b> —  ,   ,    <b>c(v1, v2)</b>,        .      ,          .<br>
<br>
   ,        —          ,     <b>G</b>   0.  ,      .               ,            ,   .<br>
<br>
  ,         ,                   .</blockquote></div></div><br>
<br>
    ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://web.archive.org/web/20140315093348/"> </a>. <i>(  -,   -               —  ).</i><br>
<br>
<h3> </h3><br>
, ,    ,     ,     ,      .<br>
<br>
  !            .      ,  ,      ,  ,         .      ,    ,   , , ,     ,      .<br>
<br>
<img align="right" width="345" height="499" src="https://habrastorage.org/webt/tc/oi/hz/tcoihzahmdqlw9cxthywpapiwsa.png"><br clear="left">
<h3> </h3><br>
    .       (       2048),       .<br>
<br>
,  4096   2048. =)  ,      2048   .</div></div><br>
<hr><hr><hr><hr><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の記事では、アルファベータクリッピングと、stackoverflowユーザーovolveからの静的評価関数を使用したミニマックスのJavaスクリプトコードを示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ミニマックス法はいくつかの優れた記事に専念しているので、それが何で構成されるかについての学術的な詳細な説明は省略します。</font></font><strike><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ITコミュニティ</font></font></strike><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><strike><font style="vertical-align: inherit;">参加した</font></strike><font style="vertical-align: inherit;">人</font><strike><font style="vertical-align: inherit;">は、最近</font></strike><font style="vertical-align: inherit;">「ミニマックス」と「アルファ-ベータクリッピング」という美しい用語を聞きましたが、これが何を意味するのかわからないので、文字列をいくつかの段落で見て、最も一般的な意味を説明してみましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ミニマックス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のゲームでは、（順番に移動する）2人のプレイヤー間のゲームのプロセスは、いわゆるオプションのツリーとして表すことができます。それぞれの特定の位置では、各プレーヤーは通常、自分の移動についてさまざまなオプションから選択できます。そして、これらのオプションのそれぞれに対応して、対戦相手も多くの点で似ている可能性があります。</font></font><br>
<br>
<div style="text-align:center;"><img width="690" height="525" src="https://habrastorage.org/webt/xi/ye/j2/xiyej2z5e4n-kigoscjrgfpf2i8.png"></div><br>
<sup><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプションツリーのフラグメント</font></font></em></sup><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ゲームにはいつでも競技場の状態に関する完全な情報があるため、現在の位置の状態は常に正確に推定できます。このような関数は、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的評価関数</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または省略</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SFO</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。さらに、特定の位置を評価するときにこの関数が重要になるほど、1人のプレーヤーの位置が有利になります（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大化プレーヤー</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼びましょう</font><font style="vertical-align: inherit;">）。位置を評価するときにこの関数の数値が小さいほど、2番目のプレーヤーの位置が有利になります（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小化プレーヤー</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼びます</font><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
移動するたびに位置が変わるため、スコアも変わります。</font><font style="vertical-align: inherit;">オプションのツリーを検討するとき、各プレーヤーは、レーティングが彼にとって最も有利なブランチだけを優先する必要はありません。</font><font style="vertical-align: inherit;">また、ポジションの評価が対戦相手にとって有利であるブランチも回避する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
対戦相手も合理主義に導かれ、負ける可能性のある選択肢を回避していると想定されています。</font><font style="vertical-align: inherit;">つまり、各プレーヤーは、オプションを選択すると、ゲインを最大化すると同時に、対戦相手の利益を最小化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはミニマックスです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルファベータクリッピング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bの位置ツリー計算する人は明白である</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ó</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際には、より大きな深さを、そしてより多くのチャンスを獲得します。しかし、厄介な点が1つあります。ゲームのオプションツリーには、ネストの各レベルで分岐して指数関数的に成長するという厄介な癖があります。プログラムの数え上げ能力はさらに制限されているため、人々は制限されています。プレーヤーが競技場を適切に評価できる位置まで数えたことが簡単にわかる場合がありますが、文字通り次の（判読不能）レベルでは、対戦相手は位置の見積もりを反対に根本的に変えるような動きをする機会があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰が責任を負い、何をすべきか？計算の複雑さは完全なツリーウォークのせいであり、不要なブランチを切り取って戦うことが提案されています。ポジションを評価しているプレイヤーが、オプションツリーの一部のブランチ</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
がすでに分析されている他のブランチよりも利益が少ないか、すでに分析されている</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のブランチよりも対戦相手の利益が多いことを確認した</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
場合、プレーヤーはこのブランチを破棄します。彼にとってこの最悪のブランチからのサブオプションを検討するために時間とリソースを費やします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、あなたは、Bのより良好な枝を計算するために多くのコンピューティングリソースを割り当てることができます</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">óを</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプションツリーの計算ミスの深さが小さい。オプションツリーのさまざまなレベルでプレイフィールドを評価するプロセスでは、プレーヤーは2つの動的に変化する係数で動作します- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルファ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ブランチで最小限に遭遇するSFDの値-つまり、最小化プレイヤーにとってより有利です）と</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベータ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ブランチで最も遭遇するSFOの値-つまり、最大化するプレーヤーにとってより有利です）。各レベルで、現在の位置のSFDを</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルファ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">係数</font><font style="vertical-align: inherit;">と</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベータ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">係数</font><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">比較すると、</font><font style="vertical-align: inherit;">プレーヤーが位置を評価</font><font style="vertical-align: inherit;">するのに</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あまり有利</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では</font><em><font style="vertical-align: inherit;">ない</font></em><font style="vertical-align: inherit;">、および/または</font><font style="vertical-align: inherit;">対戦相手に</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有利な</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分岐を（完全に計算せずに）スイープできます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはアルファベータクリッピングです。</font></font><br>
<br>
<h3>    - </h3><br>
<div class="spoiler"><b class="spoiler_title">2048      Excel-   VBA,      --     .</b><div class="spoiler_text"><pre><code class="vbscript hljs"><span class="hljs-comment">'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</span>
<span class="hljs-comment">'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</span>
<span class="hljs-comment">'''''''''''''''''''''''( - )'''''''''''''''''''''''''</span>
<span class="hljs-comment">'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</span><font></font>
<font></font>
<span class="hljs-comment">'       --</span>
<span class="hljs-comment">'Position -  4  4    </span>
<span class="hljs-comment">'Depth - ,   </span>
<span class="hljs-comment">'Alpha, Beta -        </span>
<span class="hljs-comment">'MaximisingPlayer -      ?</span>
<span class="hljs-keyword">Private</span> <span class="hljs-keyword">Function</span> MiniMaxAlpaBeta_Evaluation(Position As Variant, Depth As Long, _<font></font>
                                            Alpha As Double, Beta As Double, _<font></font>
                                            MaximisingPlayer As Boolean, _<font></font>
                                            Optional MainLevel As Boolean = <span class="hljs-literal">False</span>) As Double<font></font>
    <font></font>
    <span class="hljs-keyword">Dim</span> MaxEval As Double <span class="hljs-comment">' </span>
    <span class="hljs-keyword">Dim</span> MinEval As Double <span class="hljs-comment">' </span>
    <span class="hljs-keyword">Dim</span> PositionNext As Variant <span class="hljs-comment">'    </span>
    <span class="hljs-keyword">Dim</span> PositionTemp As Variant <span class="hljs-comment">'    </span>
    <span class="hljs-keyword">Dim</span> <span class="hljs-built_in">Eval</span> As Double <span class="hljs-comment">'  </span>
    <span class="hljs-keyword">Dim</span> Way As Long <span class="hljs-comment">'   -     </span>
    <span class="hljs-keyword">Dim</span> Row As Long <span class="hljs-comment">'    </span>
    <span class="hljs-keyword">Dim</span> Col As Long <span class="hljs-comment">'    </span>
    <span class="hljs-keyword">Dim</span> TileNew As Long <span class="hljs-comment">'     </span><font></font>
    <font></font>
    <span class="hljs-comment">'   (  ,  </span>
	<span class="hljs-comment">'     )</span>
    <span class="hljs-keyword">If</span> GameOverPosition(Position) <span class="hljs-keyword">Then</span> <span class="hljs-comment">'    ?</span>
        <span class="hljs-comment">'    </span>
        MiniMaxAlpaBeta_Evaluation = <span class="hljs-number">-1000000</span> + TileMax(Position) <font></font>
<font></font>
    <span class="hljs-comment">'        </span>
    <span class="hljs-keyword">ElseIf</span> Depth = <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span>
        <span class="hljs-comment">'    </span><font></font>
        MiniMaxAlpaBeta_Evaluation = StaticEvaluation(Position) <font></font>
       <font></font>
    <span class="hljs-comment">'  ,    </span>
    <span class="hljs-comment">'     ()</span>
    <span class="hljs-keyword">ElseIf</span> MaximisingPlayer <span class="hljs-keyword">Then</span>
        MaxEval = <span class="hljs-number">-1000000</span> <span class="hljs-comment">'     </span>
        <span class="hljs-keyword">For</span> Way = <span class="hljs-number">1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">4</span> <span class="hljs-comment">' 4   - (, , , )</span>
            ChangeCount = <span class="hljs-number">0</span> <span class="hljs-comment">' ,     </span>
            <span class="hljs-comment">',      </span><font></font>
            PositionNext = StepHuman(Position, Way)<font></font>
            <span class="hljs-keyword">If</span> ChangeCount &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span> <span class="hljs-comment">'    </span>
                <span class="hljs-comment">'      , </span>
                <span class="hljs-comment">'    ()</span>
                <span class="hljs-built_in">Eval</span> = MiniMaxAlpaBeta_Evaluation(PositionNext, Depth - <span class="hljs-number">1</span>, _<font></font>
                                                  Alpha, Beta, <span class="hljs-literal">False</span>)
                <span class="hljs-keyword">If</span> <span class="hljs-built_in">Eval</span> &gt; MaxEval <span class="hljs-keyword">Then</span> MaxEval = <span class="hljs-built_in">Eval</span> <span class="hljs-comment">' </span>
                <span class="hljs-comment">'    </span>
                <span class="hljs-keyword">If</span> <span class="hljs-built_in">Eval</span> &gt; Alpha <span class="hljs-keyword">Then</span> Alpha = <span class="hljs-built_in">Eval</span> 
                <span class="hljs-comment">'    ,   </span>
                <span class="hljs-comment">'   -   </span>
                <span class="hljs-keyword">If</span> Beta &gt; Alpha <span class="hljs-keyword">Then</span> <span class="hljs-keyword">Exit</span> <span class="hljs-keyword">For</span> 
            <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
        <span class="hljs-keyword">Next</span>
        <span class="hljs-comment">'         </span><font></font>
        MiniMaxAlpaBeta_Evaluation = MaxEval <font></font>
        <font></font>
    <span class="hljs-comment">'  ,    </span>
    <span class="hljs-comment">'     ()</span>
    <span class="hljs-keyword">Else</span> <span class="hljs-comment">'Not MaximisingPlayer</span>
        MinEval = <span class="hljs-number">1000000</span> <span class="hljs-comment">'     </span>
        <span class="hljs-keyword">For</span> Row = <span class="hljs-number">1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">4</span> <span class="hljs-comment">'    </span>
            <span class="hljs-keyword">For</span> Col = <span class="hljs-number">1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">4</span> <span class="hljs-comment">'    </span>
                <span class="hljs-keyword">If</span> Position(Row, Col) = <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span> <span class="hljs-comment">'  </span>
                    <span class="hljs-keyword">For</span> TileNew = <span class="hljs-number">2</span> <span class="hljs-keyword">To</span> <span class="hljs-number">4</span> <span class="hljs-keyword">Step</span> <span class="hljs-number">2</span> <span class="hljs-comment">'    2  4</span>
                        <span class="hljs-comment">',       </span>
						<span class="hljs-comment">'   </span><font></font>
                        PositionNext = StepComp(Position, Row, Col, TileNew)<font></font>
                        <span class="hljs-comment">'     , </span>
                        <span class="hljs-comment">'    ()</span>
                        <span class="hljs-built_in">Eval</span> = MiniMaxAlpaBeta_Evaluation(PositionNext, Depth - <span class="hljs-number">1</span>, _<font></font>
                                                          Alpha, Beta, <span class="hljs-literal">True</span>)
                        <span class="hljs-keyword">If</span> <span class="hljs-built_in">Eval</span> &lt; MinEval <span class="hljs-keyword">Then</span> MinEval = <span class="hljs-built_in">Eval</span> <span class="hljs-comment">' </span>
                        <span class="hljs-comment">'    </span>
                        <span class="hljs-keyword">If</span> <span class="hljs-built_in">Eval</span> &lt; Beta <span class="hljs-keyword">Then</span> Beta = <span class="hljs-built_in">Eval</span> 
                        <span class="hljs-comment">'    ,  </span>
                        <span class="hljs-comment">'   -   </span>
                        <span class="hljs-keyword">If</span> Alpha &lt; Beta <span class="hljs-keyword">Then</span> <span class="hljs-keyword">Exit</span> <span class="hljs-keyword">For</span> 
                    <span class="hljs-keyword">Next</span>
                <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
            <span class="hljs-keyword">Next</span>
        <span class="hljs-keyword">Next</span>
        <span class="hljs-comment">'         </span><font></font>
        MiniMaxAlpaBeta_Evaluation = MinEval <font></font>
    <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span><font></font>
 <font></font>
<span class="hljs-keyword">End</span> <span class="hljs-keyword">Function</span></code></pre></div></div><br>
<div class="spoiler"><b class="spoiler_title"> ovolve  java-script</b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AI</span>(<span class="hljs-params">grid</span>) </span>{
  <span class="hljs-keyword">this</span>.grid = grid;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//   ()</span>
AI.prototype.eval = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> emptyCells = <span class="hljs-keyword">this</span>.grid.availableCells().length;<font></font>
<font></font>
  <span class="hljs-keyword">var</span> smoothWeight = <span class="hljs-number">0.1</span>,
      <span class="hljs-comment">//monoWeight   = 0.0,</span>
      <span class="hljs-comment">//islandWeight = 0.0,</span>
      mono2Weight  = <span class="hljs-number">1.0</span>,<font></font>
      emptyWeight  = <span class="hljs-number">2.7</span>,<font></font>
      maxWeight    = <span class="hljs-number">1.0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.grid.smoothness() * smoothWeight
       <span class="hljs-comment">//+ this.grid.monotonicity() * monoWeight</span>
       <span class="hljs-comment">//- this.grid.islands() * islandWeight</span>
       + <span class="hljs-keyword">this</span>.grid.monotonicity2() * mono2Weight<font></font>
       + <span class="hljs-built_in">Math</span>.log(emptyCells) * emptyWeight<font></font>
       + <span class="hljs-keyword">this</span>.grid.maxValue() * maxWeight;<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// alpha-beta depth first search</span>
AI.prototype.search = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">depth, alpha, beta, positions, cutoffs</span>) </span>{
  <span class="hljs-keyword">var</span> bestScore;
  <span class="hljs-keyword">var</span> bestMove = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">var</span> result;<font></font>
<font></font>
  <span class="hljs-comment">// the maxing player</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.grid.playerTurn) {<font></font>
    bestScore = alpha;<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> direction <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) {
      <span class="hljs-keyword">var</span> newGrid = <span class="hljs-keyword">this</span>.grid.clone();
      <span class="hljs-keyword">if</span> (newGrid.move(direction).moved) {<font></font>
        positions++;<font></font>
        <span class="hljs-keyword">if</span> (newGrid.isWin()) {
          <span class="hljs-keyword">return</span> { <span class="hljs-attr">move</span>: direction, <span class="hljs-attr">score</span>: <span class="hljs-number">10000</span>, <span class="hljs-attr">positions</span>: positions, <span class="hljs-attr">cutoffs</span>: cutoffs };<font></font>
        }<font></font>
        <span class="hljs-keyword">var</span> newAI = <span class="hljs-keyword">new</span> AI(newGrid);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (depth == <span class="hljs-number">0</span>) {<font></font>
          result = { <span class="hljs-attr">move</span>: direction, <span class="hljs-attr">score</span>: newAI.eval() };<font></font>
        } <span class="hljs-keyword">else</span> {<font></font>
          result = newAI.search(depth<span class="hljs-number">-1</span>, bestScore, beta, positions, cutoffs);
          <span class="hljs-keyword">if</span> (result.score &gt; <span class="hljs-number">9900</span>) { <span class="hljs-comment">// win</span>
            result.score--; <span class="hljs-comment">// to slightly penalize higher depth from win</span><font></font>
          }<font></font>
          positions = result.positions;<font></font>
          cutoffs = result.cutoffs;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (result.score &gt; bestScore) {<font></font>
          bestScore = result.score;<font></font>
          bestMove = direction;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (bestScore &gt; beta) {<font></font>
          cutoffs++<font></font>
          <span class="hljs-keyword">return</span> { <span class="hljs-attr">move</span>: bestMove, <span class="hljs-attr">score</span>: beta, <span class="hljs-attr">positions</span>: positions, <span class="hljs-attr">cutoffs</span>: cutoffs };<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span> { <span class="hljs-comment">// computer's turn, we'll do heavy pruning to keep the branching factor low</span><font></font>
    bestScore = beta;<font></font>
<font></font>
    <span class="hljs-comment">// try a 2 and 4 in each cell and measure how annoying it is</span>
    <span class="hljs-comment">// with metrics from eval</span>
    <span class="hljs-keyword">var</span> candidates = [];
    <span class="hljs-keyword">var</span> cells = <span class="hljs-keyword">this</span>.grid.availableCells();
    <span class="hljs-keyword">var</span> scores = { <span class="hljs-number">2</span>: [], <span class="hljs-number">4</span>: [] };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> value <span class="hljs-keyword">in</span> scores) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> cells) {<font></font>
        scores[value].push(<span class="hljs-literal">null</span>);
        <span class="hljs-keyword">var</span> cell = cells[i];
        <span class="hljs-keyword">var</span> tile = <span class="hljs-keyword">new</span> Tile(cell, <span class="hljs-built_in">parseInt</span>(value, <span class="hljs-number">10</span>));
        <span class="hljs-keyword">this</span>.grid.insertTile(tile);<font></font>
        scores[value][i] = -<span class="hljs-keyword">this</span>.grid.smoothness() + <span class="hljs-keyword">this</span>.grid.islands();
        <span class="hljs-keyword">this</span>.grid.removeTile(cell);<font></font>
      }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// now just pick out the most annoying moves</span>
    <span class="hljs-keyword">var</span> maxScore = <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>, scores[<span class="hljs-number">2</span>]), <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>, scores[<span class="hljs-number">4</span>]));
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> value <span class="hljs-keyword">in</span> scores) { <span class="hljs-comment">// 2 and 4</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;scores[value].length; i++) {
        <span class="hljs-keyword">if</span> (scores[value][i] == maxScore) {<font></font>
          candidates.push( { <span class="hljs-attr">position</span>: cells[i], <span class="hljs-attr">value</span>: <span class="hljs-built_in">parseInt</span>(value, <span class="hljs-number">10</span>) } );<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// search on each candidate</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;candidates.length; i++) {
      <span class="hljs-keyword">var</span> position = candidates[i].position;
      <span class="hljs-keyword">var</span> value = candidates[i].value;
      <span class="hljs-keyword">var</span> newGrid = <span class="hljs-keyword">this</span>.grid.clone();
      <span class="hljs-keyword">var</span> tile = <span class="hljs-keyword">new</span> Tile(position, value);<font></font>
      newGrid.insertTile(tile);<font></font>
      newGrid.playerTurn = <span class="hljs-literal">true</span>;<font></font>
      positions++;<font></font>
      newAI = <span class="hljs-keyword">new</span> AI(newGrid);<font></font>
      result = newAI.search(depth, alpha, bestScore, positions, cutoffs);<font></font>
      positions = result.positions;<font></font>
      cutoffs = result.cutoffs;<font></font>
<font></font>
      <span class="hljs-keyword">if</span> (result.score &lt; bestScore) {<font></font>
        bestScore = result.score;<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span> (bestScore &lt; alpha) {<font></font>
        cutoffs++;<font></font>
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">move</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">score</span>: alpha, <span class="hljs-attr">positions</span>: positions, <span class="hljs-attr">cutoffs</span>: cutoffs };<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">move</span>: bestMove, <span class="hljs-attr">score</span>: bestScore, <span class="hljs-attr">positions</span>: positions, <span class="hljs-attr">cutoffs</span>: cutoffs };<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// performs a search and returns the best move</span>
AI.prototype.getBest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterativeDeep();<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// performs iterative deepening over the alpha-beta search</span>
AI.prototype.iterativeDeep = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> start = (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).getTime();
  <span class="hljs-keyword">var</span> depth = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> best;
  <span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">var</span> newBest = <span class="hljs-keyword">this</span>.search(depth, <span class="hljs-number">-10000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">0</span> ,<span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (newBest.move == <span class="hljs-number">-1</span>) {
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      best = newBest;<font></font>
    }<font></font>
    depth++;<font></font>
  } <span class="hljs-keyword">while</span> ( (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).getTime() - start &lt; minSearchTime);
  <span class="hljs-keyword">return</span> best<font></font>
}<font></font>
<font></font>
AI.prototype.translate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">move</span>) </span>{
 <span class="hljs-keyword">return</span> {
    <span class="hljs-number">0</span>: <span class="hljs-string">'up'</span>,
    <span class="hljs-number">1</span>: <span class="hljs-string">'right'</span>,
    <span class="hljs-number">2</span>: <span class="hljs-string">'down'</span>,
    <span class="hljs-number">3</span>: <span class="hljs-string">'left'</span><font></font>
  }[move];<font></font>
}</code></pre></div></div><br>
<h2>  </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オプションツリーの各レベルでは、プレーイングフィールドを評価する必要があるため（どのプレーヤーを決定するために、推定位置が実際により有利であるか）、良い位置と悪い位置を区別するための基準によって決定する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最大化プレイヤーは、4つの方向（上、左、右、下）のどれをすべてのタイルに移動するかを決定する人（またはAI）であると想定します。最小化プレイヤーとは、最も不適切な場所でランダムに2または4を生成する陰湿なサブルーチンです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SFOは、最大化するプレーヤーの観点からコンパイルされます。競技場のSFDレーティングが高いほど、「マキシマリスト」のポジションが高くなります。低いほど、「ミニマリスト」のボード上の位置が快適になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2048年の場合-タイルを動かす人にとってどのような要素が好ましいと考えられていますか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単調</font></font></h3><img align="right" width="388" height="189" src="https://habrastorage.org/webt/r8/jc/qt/r8jcqtbvrsyvrfwwsmeedgfrzrg.png"><br clear="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一に、タイルはいくつかの方向に昇順/降順で配置されることが望ましい。</font><font style="vertical-align: inherit;">これを行わないと、新しいタイルを生成するときに、ランダムに配置されたさまざまなサイズのタイルがすぐに詰まり、すぐには正常に相互に接続できなくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シベリア連邦管区では、4つの方向すべて（上から下、左から右、右から左、下から上）を見て、タイルの進行が減少または増加している場所を計算する必要があります。</font><font style="vertical-align: inherit;">一般的なシリーズに収まらないタイルがある場合、これにより単調性の数値係数が減少します。</font><font style="vertical-align: inherit;">次に、全方向の4つの係数から、最良の係数が選択されます。これは、シベリア連邦管区の合計値で考慮されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">滑らかさ</font></font></h3><img align="right" width="387" height="189" src="https://habrastorage.org/webt/uw/mq/wh/uwmqwht6dm82fc_zptwwdqdar2c.png"><br clear="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、タイルの列に立ってからの進行が単に増加しているだけでなく減少していない（または列を減少させるのではなく、増加しないことが好ましい）場合、つまり、同じタイルが近くにあり、それらが1つに折りたたまれてポイントを獲得し、競技場の空き容量を増やします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、シベリア連邦管区は、同じ隣接タイルを競技場で探し、そのようなペアの数を特別な係数で考慮します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空のセル</font></font></h3><img align="right" width="387" height="193" src="https://habrastorage.org/webt/qj/as/ay/qjasayisfgowdqcciifm0igt3ru.png"><br clear="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、空き容量が多いほど、操作の余地が多くなり、すぐに失う可能性が低くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SFOはフィールド上の空のセルを考慮し、これらの数が多いほど、ポジションを最大化しているプレーヤーにとってより利益があると見なされます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大タイル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このゲームの主な目的は、フィールドに大きなタイルを配置することです。2048、4096、8192（またはあなたが強みと忍耐力を持っているもの）が多いほど、タイルの最大値が大きいオプションは、最も収益性の高いSFDと見なされます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2048年のシベリア連邦管区</font></font></h3><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBAマクロとしてのシベリア連邦管区の実装</font></font></b><div class="spoiler_text"><pre><code class="vbscript hljs"><span class="hljs-comment">'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</span>
<span class="hljs-comment">'''''''''''''''''''''''  ''''''''''''''''''''''''</span>
<span class="hljs-comment">'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''</span><font></font>
<font></font>
<span class="hljs-comment">'    </span>
<span class="hljs-comment">'Position -  4  4    </span>
<span class="hljs-keyword">Private</span> <span class="hljs-keyword">Function</span> StaticEvaluation(Position As Variant) As Double<font></font>
<font></font>
    <span class="hljs-keyword">Dim</span> Smoothness As Double <span class="hljs-comment">'</span>
    <span class="hljs-keyword">Dim</span> Monotonicity As Double <span class="hljs-comment">'</span>
    <span class="hljs-keyword">Dim</span> EmptyCount As Double <span class="hljs-comment">' </span>
    <span class="hljs-keyword">Dim</span> MaxValue As Long <span class="hljs-comment">' </span><font></font>
<font></font>
    <span class="hljs-comment">'  </span>
    <span class="hljs-keyword">Const</span> SmoothWeight = <span class="hljs-number">0.1</span>
    <span class="hljs-keyword">Const</span> MonoWeight = <span class="hljs-number">1</span>
    <span class="hljs-keyword">Const</span> EmptyWeight = <span class="hljs-number">2.7</span>
    <span class="hljs-keyword">Const</span> MaxWeight = <span class="hljs-number">1</span><font></font>
    <font></font>
    <span class="hljs-keyword">Dim</span> k As Long <span class="hljs-comment">'  </span>
    <span class="hljs-keyword">Dim</span> i As Long <span class="hljs-comment">' </span>
    <span class="hljs-keyword">Dim</span> j  As Long <span class="hljs-comment">' </span>
    <span class="hljs-keyword">Dim</span> x As Long <span class="hljs-comment">' </span>
    <span class="hljs-keyword">Dim</span> y As Long <span class="hljs-comment">' </span><font></font>
<font></font>
    <span class="hljs-comment">'</span>
    <span class="hljs-keyword">Dim</span> Value As Double <span class="hljs-comment">'      </span>
    <span class="hljs-comment">'        </span>
    <span class="hljs-keyword">Dim</span> TargetValue As Double <font></font>
    Smoothness = <span class="hljs-number">0</span> <span class="hljs-comment">'   </span>
    <span class="hljs-keyword">For</span> i = <span class="hljs-number">1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">4</span> <span class="hljs-comment">'    </span>
        <span class="hljs-keyword">For</span> j = <span class="hljs-number">1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">4</span> <span class="hljs-comment">'    </span>
            <span class="hljs-keyword">If</span> Position(i, j) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span> <span class="hljs-comment">'  </span>
                Value = <span class="hljs-built_in">Log</span>(Position(i, j)) / <span class="hljs-built_in">Log</span>(<span class="hljs-number">2</span>)
                <span class="hljs-keyword">If</span> i &lt; <span class="hljs-number">4</span> <span class="hljs-keyword">Then</span> <span class="hljs-comment">'      </span>
                    <span class="hljs-keyword">For</span> x = i + <span class="hljs-number">1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">4</span> <span class="hljs-comment">'   </span>
                        <span class="hljs-keyword">If</span> Position(x, j) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span> <span class="hljs-comment">'   </span>
                            <span class="hljs-comment">'   </span>
                            TargetValue = <span class="hljs-built_in">Log</span>(Position(x, j)) / <span class="hljs-built_in">Log</span>(<span class="hljs-number">2</span>) 
                            <span class="hljs-comment">',  </span>
                            Smoothness = <span class="hljs-built_in">Abs</span>(Value - TargetValue) 
                            <span class="hljs-comment">'      </span>
                            <span class="hljs-keyword">Exit</span> <span class="hljs-keyword">For</span> 
                        <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
                    <span class="hljs-keyword">Next</span>
                <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
                <span class="hljs-keyword">If</span> j &lt; <span class="hljs-number">4</span> <span class="hljs-keyword">Then</span> <span class="hljs-comment">'      </span>
                    <span class="hljs-keyword">For</span> y = j + <span class="hljs-number">1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">4</span> <span class="hljs-comment">'   </span>
                        <span class="hljs-keyword">If</span> Position(i, y) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span> <span class="hljs-comment">'   </span>
                            <span class="hljs-comment">'   </span>
                            TargetValue = <span class="hljs-built_in">Log</span>(Position(i, y)) / <span class="hljs-built_in">Log</span>(<span class="hljs-number">2</span>) 
                            <span class="hljs-comment">',  </span>
                            Smoothness = <span class="hljs-built_in">Abs</span>(Value - TargetValue) 
                            <span class="hljs-comment">'       </span>
                            <span class="hljs-keyword">Exit</span> <span class="hljs-keyword">For</span> 
                        <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
                    <span class="hljs-keyword">Next</span>
                <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
            <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
        <span class="hljs-keyword">Next</span>
    <span class="hljs-keyword">Next</span><font></font>
    <font></font>
    <span class="hljs-comment">'</span>
    <span class="hljs-keyword">Dim</span> arrTotals(<span class="hljs-number">1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">4</span>) As Double <span class="hljs-comment">'    </span>
    <span class="hljs-keyword">Dim</span> Current As Long <span class="hljs-comment">'  </span>
    <span class="hljs-keyword">Dim</span> Next_ As Long <span class="hljs-comment">'     </span>
    <span class="hljs-keyword">Dim</span> CurrentValue As Double <span class="hljs-comment">'     </span>
    <span class="hljs-keyword">Dim</span> NextValue As Double <span class="hljs-comment">'       </span><font></font>
    <font></font>
    Monotonicity = <span class="hljs-number">0</span> <span class="hljs-comment">'   </span><font></font>
    <font></font>
    <span class="hljs-comment">'     </span>
    <span class="hljs-keyword">For</span> k = <span class="hljs-number">1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">4</span>
        arrTotals(k) = <span class="hljs-number">0</span>
    <span class="hljs-keyword">Next</span>
    <span class="hljs-comment">' -  -</span>
    <span class="hljs-keyword">For</span> x = <span class="hljs-number">1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">4</span> <span class="hljs-comment">'  </span>
        Current = <span class="hljs-number">1</span> <span class="hljs-comment">'     </span>
        <span class="hljs-comment">'   (     ) </span>
        Next_ = Current + <span class="hljs-number">1</span> 
        <span class="hljs-keyword">Do</span> <span class="hljs-keyword">While</span> Next_ &lt;= <span class="hljs-number">4</span> <span class="hljs-comment">'      </span>
            <span class="hljs-comment">'     </span>
            <span class="hljs-comment">'(       )</span>
            <span class="hljs-keyword">Do</span> <span class="hljs-keyword">While</span> Next_ &lt;= <span class="hljs-number">4</span> <span class="hljs-comment">'      </span>
                <span class="hljs-keyword">If</span> Position(x, Next_) = <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span> <span class="hljs-comment">'    </span>
                    Next_ = Next_ + <span class="hljs-number">1</span> <span class="hljs-comment">'  </span>
                <span class="hljs-keyword">Else</span> <span class="hljs-comment">' -   </span>
                    <span class="hljs-keyword">Exit</span> <span class="hljs-keyword">Do</span> <span class="hljs-comment">' ,  ,  </span>
                <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
            <span class="hljs-keyword">Loop</span>
            <span class="hljs-comment">'        </span>
            <span class="hljs-keyword">If</span> Next_ &gt; <span class="hljs-number">4</span> <span class="hljs-keyword">Then</span> Next_ = <span class="hljs-number">4</span> 
            <span class="hljs-comment">'         </span>
            <span class="hljs-keyword">If</span> Position(x, Current) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span>
                CurrentValue = <span class="hljs-built_in">Log</span>(Position(x, Current)) / <span class="hljs-built_in">Log</span>(<span class="hljs-number">2</span>)
            <span class="hljs-keyword">Else</span>
                CurrentValue = <span class="hljs-number">0</span>
            <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
<span class="hljs-comment">'            MsgBox "Position[" &amp; x &amp; ", " &amp; Next_ &amp; "]=" &amp; Position(x, Next_)</span>
            <span class="hljs-keyword">If</span> Position(x, Next_) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span>
                NextValue = <span class="hljs-built_in">Log</span>(Position(x, Next_)) / <span class="hljs-built_in">Log</span>(<span class="hljs-number">2</span>)
            <span class="hljs-keyword">Else</span>
                NextValue = <span class="hljs-number">0</span>
            <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
            <span class="hljs-keyword">If</span> CurrentValue &gt; NextValue <span class="hljs-keyword">Then</span> <span class="hljs-comment">'   ?</span><font></font>
                arrTotals(Up) = arrTotals(Up) + NextValue - CurrentValue<font></font>
            <span class="hljs-keyword">ElseIf</span> NextValue &gt; CurrentValue <span class="hljs-keyword">Then</span> <span class="hljs-comment">'   ?</span><font></font>
                arrTotals(Down) = arrTotals(Down) + CurrentValue - NextValue<font></font>
            <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
            Current = Next_ <span class="hljs-comment">'      </span>
            Next_ = Next_ + <span class="hljs-number">1</span> <span class="hljs-comment">'   </span>
        <span class="hljs-keyword">Loop</span>
    <span class="hljs-keyword">Next</span>
    <span class="hljs-comment">'      -  -</span><font></font>
    Monotonicity = IIf(arrTotals(Up) &gt;= arrTotals(Down), _<font></font>
                   Monotonicity + arrTotals(Up), _<font></font>
                   Monotonicity + arrTotals(Down))<font></font>
<font></font>
    <span class="hljs-comment">' -  -</span>
    <span class="hljs-keyword">For</span> y = <span class="hljs-number">1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">4</span> <span class="hljs-comment">'  </span>
        Current = <span class="hljs-number">1</span> <span class="hljs-comment">'     </span>
        <span class="hljs-comment">'   (     ) </span>
        Next_ = Current + <span class="hljs-number">1</span> 
        <span class="hljs-keyword">Do</span> <span class="hljs-keyword">While</span> Next_ &lt;= <span class="hljs-number">4</span> <span class="hljs-comment">'      </span>
            <span class="hljs-comment">'     </span>
            <span class="hljs-comment">'(       )</span>
            <span class="hljs-keyword">Do</span> <span class="hljs-keyword">While</span> Next_ &lt;= <span class="hljs-number">4</span> <span class="hljs-comment">'      </span>
                <span class="hljs-keyword">If</span> Position(Next_, y) = <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span> <span class="hljs-comment">'    </span>
                    Next_ = Next_ + <span class="hljs-number">1</span> <span class="hljs-comment">'  </span>
                <span class="hljs-keyword">Else</span> <span class="hljs-comment">' -   </span>
                    <span class="hljs-keyword">Exit</span> <span class="hljs-keyword">Do</span> <span class="hljs-comment">' ,  ,  </span>
                <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
            <span class="hljs-keyword">Loop</span>
            <span class="hljs-comment">'        </span>
            <span class="hljs-keyword">If</span> Next_ &gt; <span class="hljs-number">4</span> <span class="hljs-keyword">Then</span> Next_ = <span class="hljs-number">4</span> 
            <span class="hljs-comment">'         </span>
            <span class="hljs-keyword">If</span> Position(Current, y) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span>
                CurrentValue = <span class="hljs-built_in">Log</span>(Position(Current, y)) / <span class="hljs-built_in">Log</span>(<span class="hljs-number">2</span>)
            <span class="hljs-keyword">Else</span>
                CurrentValue = <span class="hljs-number">0</span>
            <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
            <span class="hljs-keyword">If</span> Position(Next_, y) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span>
                NextValue = <span class="hljs-built_in">Log</span>(Position(Next_, y)) / <span class="hljs-built_in">Log</span>(<span class="hljs-number">2</span>)
            <span class="hljs-keyword">Else</span>
                NextValue = <span class="hljs-number">0</span>
            <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
            <span class="hljs-keyword">If</span> CurrentValue &gt; NextValue <span class="hljs-keyword">Then</span> <span class="hljs-comment">'   ?</span>
                arrTotals(<span class="hljs-built_in">Left</span>) = arrTotals(<span class="hljs-built_in">Left</span>) + NextValue - CurrentValue
            <span class="hljs-keyword">ElseIf</span> NextValue &gt; CurrentValue <span class="hljs-keyword">Then</span> <span class="hljs-comment">'   ?</span>
                arrTotals(<span class="hljs-built_in">Right</span>) = arrTotals(<span class="hljs-built_in">Right</span>) + CurrentValue - NextValue
            <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
            Current = Next_ <span class="hljs-comment">'      </span>
            Next_ = Next_ + <span class="hljs-number">1</span> <span class="hljs-comment">'   </span>
        <span class="hljs-keyword">Loop</span>
    <span class="hljs-keyword">Next</span>
    <span class="hljs-comment">'      -  -</span>
    Monotonicity = IIf(arrTotals(<span class="hljs-built_in">Left</span>) &gt;= arrTotals(<span class="hljs-built_in">Right</span>), _<font></font>
                   Monotonicity + arrTotals(<span class="hljs-built_in">Left</span>), _<font></font>
                   Monotonicity + arrTotals(<span class="hljs-built_in">Right</span>))<font></font>
<font></font>
    <span class="hljs-comment">'    </span>
    EmptyCount = <span class="hljs-number">0</span> <span class="hljs-comment">'     </span>
    MaxValue = <span class="hljs-number">0</span> <span class="hljs-comment">'   </span>
    <span class="hljs-keyword">For</span> i = <span class="hljs-number">1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">4</span> <span class="hljs-comment">'    </span>
        <span class="hljs-keyword">For</span> j = <span class="hljs-number">1</span> <span class="hljs-keyword">To</span> <span class="hljs-number">4</span> <span class="hljs-comment">'    </span>
            <span class="hljs-keyword">If</span> Position(i, j) = <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span> <span class="hljs-comment">'  ...</span>
                <span class="hljs-comment">'...    </span>
                EmptyCount = EmptyCount + <span class="hljs-number">1</span> 
            <span class="hljs-comment">'     ...</span>
            <span class="hljs-keyword">ElseIf</span> Position(i, j) &gt; MaxValue <span class="hljs-keyword">Then</span> 
                MaxValue = Position(i, j) <span class="hljs-comment">'...   </span>
            <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>
        <span class="hljs-keyword">Next</span>
    <span class="hljs-keyword">Next</span><font></font>
    <font></font>
    <span class="hljs-comment">'  </span><font></font>
    StaticEvaluation = Smoothness * SmoothWeight + _<font></font>
                       Monotonicity * MonoWeight + _<font></font>
                       Log_Base_Arg(EmptyCount) * EmptyWeight + _<font></font>
                       MaxValue * MaxWeight<font></font>
<font></font>
<span class="hljs-keyword">End</span> <span class="hljs-keyword">Function</span></code></pre></div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScriptのOvolveコード</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Grid</span>(<span class="hljs-params">size</span>) </span>{
  <span class="hljs-keyword">this</span>.size = size;
  <span class="hljs-keyword">this</span>.startTiles   = <span class="hljs-number">2</span>;<font></font>
<font></font>
  <span class="hljs-keyword">this</span>.cells = [];<font></font>
<font></font>
  <span class="hljs-keyword">this</span>.build();
  <span class="hljs-keyword">this</span>.playerTurn = <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// pre-allocate these objects (for speed)</span><font></font>
Grid.prototype.indexes = [];<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x=<span class="hljs-number">0</span>; x&lt;<span class="hljs-number">4</span>; x++) {<font></font>
  Grid.prototype.indexes.push([]);<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> y=<span class="hljs-number">0</span>; y&lt;<span class="hljs-number">4</span>; y++) {<font></font>
    Grid.prototype.indexes[x].push( {<span class="hljs-attr">x</span>:x, <span class="hljs-attr">y</span>:y} );<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Build a grid of the specified size</span>
Grid.prototype.build = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-keyword">this</span>.size; x++) {
    <span class="hljs-keyword">var</span> row = <span class="hljs-keyword">this</span>.cells[x] = [];<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> y = <span class="hljs-number">0</span>; y &lt; <span class="hljs-keyword">this</span>.size; y++) {<font></font>
      row.push(<span class="hljs-literal">null</span>);<font></font>
    }<font></font>
  }<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-comment">// Find the first available random position</span>
Grid.prototype.randomAvailableCell = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> cells = <span class="hljs-keyword">this</span>.availableCells();<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (cells.length) {
    <span class="hljs-keyword">return</span> cells[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * cells.length)];<font></font>
  }<font></font>
};<font></font>
<font></font>
Grid.prototype.availableCells = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> cells = [];
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;<font></font>
<font></font>
  <span class="hljs-keyword">this</span>.eachCell(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y, tile</span>) </span>{
    <span class="hljs-keyword">if</span> (!tile) {
      <span class="hljs-comment">//cells.push(self.indexes[x][y]);</span>
      cells.push( {<span class="hljs-attr">x</span>:x, <span class="hljs-attr">y</span>:y} );<font></font>
    }<font></font>
  });<font></font>
<font></font>
  <span class="hljs-keyword">return</span> cells;<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// Call callback for every cell</span>
Grid.prototype.eachCell = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-keyword">this</span>.size; x++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> y = <span class="hljs-number">0</span>; y &lt; <span class="hljs-keyword">this</span>.size; y++) {<font></font>
      callback(x, y, <span class="hljs-keyword">this</span>.cells[x][y]);<font></font>
    }<font></font>
  }<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// Check if there are any cells available</span>
Grid.prototype.cellsAvailable = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> !!<span class="hljs-keyword">this</span>.availableCells().length;<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// Check if the specified cell is taken</span>
Grid.prototype.cellAvailable = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cell</span>) </span>{
  <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.cellOccupied(cell);<font></font>
};<font></font>
<font></font>
Grid.prototype.cellOccupied = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cell</span>) </span>{
  <span class="hljs-keyword">return</span> !!<span class="hljs-keyword">this</span>.cellContent(cell);<font></font>
};<font></font>
<font></font>
Grid.prototype.cellContent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cell</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.withinBounds(cell)) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.cells[cell.x][cell.y];<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
  }<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// Inserts a tile at its position</span>
Grid.prototype.insertTile = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tile</span>) </span>{
  <span class="hljs-keyword">this</span>.cells[tile.x][tile.y] = tile;<font></font>
};<font></font>
<font></font>
Grid.prototype.removeTile = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tile</span>) </span>{
  <span class="hljs-keyword">this</span>.cells[tile.x][tile.y] = <span class="hljs-literal">null</span>;<font></font>
};<font></font>
<font></font>
Grid.prototype.withinBounds = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">position</span>) </span>{
  <span class="hljs-keyword">return</span> position.x &gt;= <span class="hljs-number">0</span> &amp;&amp; position.x &lt; <span class="hljs-keyword">this</span>.size &amp;&amp;<font></font>
         position.y &gt;= <span class="hljs-number">0</span> &amp;&amp; position.y &lt; <span class="hljs-keyword">this</span>.size;<font></font>
};<font></font>
<font></font>
Grid.prototype.clone = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<font></font>
  newGrid = <span class="hljs-keyword">new</span> Grid(<span class="hljs-keyword">this</span>.size);<font></font>
  newGrid.playerTurn = <span class="hljs-keyword">this</span>.playerTurn;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-keyword">this</span>.size; x++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> y = <span class="hljs-number">0</span>; y &lt; <span class="hljs-keyword">this</span>.size; y++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cells[x][y]) {<font></font>
        newGrid.insertTile(<span class="hljs-keyword">this</span>.cells[x][y].clone());<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> newGrid;<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// Set up the initial tiles to start the game with</span>
Grid.prototype.addStartTiles = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-keyword">this</span>.startTiles; i++) {
    <span class="hljs-keyword">this</span>.addRandomTile();<font></font>
  }<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// Adds a tile in a random position</span>
Grid.prototype.addRandomTile = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cellsAvailable()) {
    <span class="hljs-keyword">var</span> value = <span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">0.9</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">4</span>;
    <span class="hljs-comment">//var value = Math.random() &lt; 0.9 ? 256 : 512;</span>
    <span class="hljs-keyword">var</span> tile = <span class="hljs-keyword">new</span> Tile(<span class="hljs-keyword">this</span>.randomAvailableCell(), value);<font></font>
<font></font>
    <span class="hljs-keyword">this</span>.insertTile(tile);<font></font>
  }<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// Save all tile positions and remove merger info</span>
Grid.prototype.prepareTiles = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.eachCell(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y, tile</span>) </span>{
    <span class="hljs-keyword">if</span> (tile) {<font></font>
      tile.mergedFrom = <span class="hljs-literal">null</span>;<font></font>
      tile.savePosition();<font></font>
    }<font></font>
  });<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// Move a tile and its representation</span>
Grid.prototype.moveTile = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tile, cell</span>) </span>{
  <span class="hljs-keyword">this</span>.cells[tile.x][tile.y] = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.cells[cell.x][cell.y] = tile;<font></font>
  tile.updatePosition(cell);<font></font>
};<font></font>
<font></font>
<font></font>
Grid.prototype.vectors = {<font></font>
  <span class="hljs-number">0</span>: { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,  <span class="hljs-attr">y</span>: <span class="hljs-number">-1</span> }, <span class="hljs-comment">// up</span>
  <span class="hljs-number">1</span>: { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,  <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> },  <span class="hljs-comment">// right</span>
  <span class="hljs-number">2</span>: { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,  <span class="hljs-attr">y</span>: <span class="hljs-number">1</span> },  <span class="hljs-comment">// down</span>
  <span class="hljs-number">3</span>: { <span class="hljs-attr">x</span>: <span class="hljs-number">-1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> }   <span class="hljs-comment">// left</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Get the vector representing the chosen direction</span>
Grid.prototype.getVector = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">direction</span>) </span>{
  <span class="hljs-comment">// Vectors representing tile movement</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.vectors[direction];<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// Move tiles on the grid in the specified direction</span>
<span class="hljs-comment">// returns true if move was successful</span>
Grid.prototype.move = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">direction</span>) </span>{
  <span class="hljs-comment">// 0: up, 1: right, 2:down, 3: left</span>
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;<font></font>
<font></font>
  <span class="hljs-keyword">var</span> cell, tile;<font></font>
<font></font>
  <span class="hljs-keyword">var</span> vector     = <span class="hljs-keyword">this</span>.getVector(direction);
  <span class="hljs-keyword">var</span> traversals = <span class="hljs-keyword">this</span>.buildTraversals(vector);
  <span class="hljs-keyword">var</span> moved      = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> score      = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> won        = <span class="hljs-literal">false</span>;<font></font>
<font></font>
  <span class="hljs-comment">// Save the current tile positions and remove merger information</span>
  <span class="hljs-keyword">this</span>.prepareTiles();<font></font>
<font></font>
  <span class="hljs-comment">// Traverse the grid in the right direction and move tiles</span>
  traversals.x.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{<font></font>
    traversals.y.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">y</span>) </span>{<font></font>
      cell = self.indexes[x][y];<font></font>
      tile = self.cellContent(cell);<font></font>
<font></font>
      <span class="hljs-keyword">if</span> (tile) {
        <span class="hljs-comment">//if (debug) {</span>
          <span class="hljs-comment">//console.log('tile @', x, y);</span>
        <span class="hljs-comment">//}</span>
        <span class="hljs-keyword">var</span> positions = self.findFarthestPosition(cell, vector);
        <span class="hljs-keyword">var</span> next      = self.cellContent(positions.next);<font></font>
<font></font>
        <span class="hljs-comment">// Only one merger per row traversal?</span>
        <span class="hljs-keyword">if</span> (next &amp;&amp; next.value === tile.value &amp;&amp; !next.mergedFrom) {
          <span class="hljs-keyword">var</span> merged = <span class="hljs-keyword">new</span> Tile(positions.next, tile.value * <span class="hljs-number">2</span>);<font></font>
          merged.mergedFrom = [tile, next];<font></font>
<font></font>
          self.insertTile(merged);<font></font>
          self.removeTile(tile);<font></font>
<font></font>
          <span class="hljs-comment">// Converge the two tiles' positions</span><font></font>
          tile.updatePosition(positions.next);<font></font>
<font></font>
          <span class="hljs-comment">// Update the score</span><font></font>
          score += merged.value;<font></font>
<font></font>
          <span class="hljs-comment">// The mighty 2048 tile</span>
          <span class="hljs-keyword">if</span> (merged.value === <span class="hljs-number">2048</span>) {<font></font>
            won = <span class="hljs-literal">true</span>;<font></font>
          }<font></font>
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">//if (debug) {</span>
            <span class="hljs-comment">//console.log(cell);</span>
            <span class="hljs-comment">//console.log(tile);</span>
          <span class="hljs-comment">//}</span><font></font>
          self.moveTile(tile, positions.farthest);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!self.positionsEqual(cell, tile)) {<font></font>
          self.playerTurn = <span class="hljs-literal">false</span>;
          <span class="hljs-comment">//console.log('setting player turn to ', self.playerTurn);</span>
          moved = <span class="hljs-literal">true</span>; <span class="hljs-comment">// The tile moved from its original cell!</span><font></font>
        }<font></font>
      }<font></font>
    });<font></font>
  });<font></font>
<font></font>
  <span class="hljs-comment">//console.log('returning, playerturn is', self.playerTurn);</span>
  <span class="hljs-comment">//if (!moved) {</span>
    <span class="hljs-comment">//console.log('cell', cell);</span>
    <span class="hljs-comment">//console.log('tile', tile);</span>
    <span class="hljs-comment">//console.log('direction', direction);</span>
    <span class="hljs-comment">//console.log(this.toString());</span>
  <span class="hljs-comment">//}</span>
  <span class="hljs-keyword">return</span> {<span class="hljs-attr">moved</span>: moved, <span class="hljs-attr">score</span>: score, <span class="hljs-attr">won</span>: won};<font></font>
};<font></font>
<font></font>
Grid.prototype.computerMove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.addRandomTile();
  <span class="hljs-keyword">this</span>.playerTurn = <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Build a list of positions to traverse in the right order</span>
Grid.prototype.buildTraversals = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">vector</span>) </span>{
  <span class="hljs-keyword">var</span> traversals = { <span class="hljs-attr">x</span>: [], <span class="hljs-attr">y</span>: [] };<font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> pos = <span class="hljs-number">0</span>; pos &lt; <span class="hljs-keyword">this</span>.size; pos++) {<font></font>
    traversals.x.push(pos);<font></font>
    traversals.y.push(pos);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Always traverse from the farthest cell in the chosen direction</span>
  <span class="hljs-keyword">if</span> (vector.x === <span class="hljs-number">1</span>) traversals.x = traversals.x.reverse();
  <span class="hljs-keyword">if</span> (vector.y === <span class="hljs-number">1</span>) traversals.y = traversals.y.reverse();<font></font>
<font></font>
  <span class="hljs-keyword">return</span> traversals;<font></font>
};<font></font>
<font></font>
Grid.prototype.findFarthestPosition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cell, vector</span>) </span>{
  <span class="hljs-keyword">var</span> previous;<font></font>
<font></font>
  <span class="hljs-comment">// Progress towards the vector direction until an obstacle is found</span>
  <span class="hljs-keyword">do</span> {<font></font>
    previous = cell;<font></font>
    cell     = { <span class="hljs-attr">x</span>: previous.x + vector.x, <span class="hljs-attr">y</span>: previous.y + vector.y };<font></font>
  } <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.withinBounds(cell) &amp;&amp;
           <span class="hljs-keyword">this</span>.cellAvailable(cell));<font></font>
<font></font>
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">farthest</span>: previous,
    <span class="hljs-attr">next</span>: cell <span class="hljs-comment">// Used to check if a merge is required</span><font></font>
  };<font></font>
};<font></font>
<font></font>
Grid.prototype.movesAvailable = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.cellsAvailable() || <span class="hljs-keyword">this</span>.tileMatchesAvailable();<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// Check for available matches between tiles (more expensive check)</span>
<span class="hljs-comment">// returns the number of matches</span>
Grid.prototype.tileMatchesAvailable = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;<font></font>
<font></font>
  <span class="hljs-comment">//var matches = 0;</span><font></font>
<font></font>
  <span class="hljs-keyword">var</span> tile;<font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-keyword">this</span>.size; x++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> y = <span class="hljs-number">0</span>; y &lt; <span class="hljs-keyword">this</span>.size; y++) {<font></font>
      tile = <span class="hljs-keyword">this</span>.cellContent({ <span class="hljs-attr">x</span>: x, <span class="hljs-attr">y</span>: y });<font></font>
<font></font>
      <span class="hljs-keyword">if</span> (tile) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> direction = <span class="hljs-number">0</span>; direction &lt; <span class="hljs-number">4</span>; direction++) {
          <span class="hljs-keyword">var</span> vector = self.getVector(direction);
          <span class="hljs-keyword">var</span> cell   = { <span class="hljs-attr">x</span>: x + vector.x, <span class="hljs-attr">y</span>: y + vector.y };<font></font>
<font></font>
          <span class="hljs-keyword">var</span> other  = self.cellContent(cell);<font></font>
<font></font>
          <span class="hljs-keyword">if</span> (other &amp;&amp; other.value === tile.value) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//matches++; // These two tiles can be merged</span><font></font>
          }<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">//console.log(matches);</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//matches;</span><font></font>
};<font></font>
<font></font>
Grid.prototype.positionsEqual = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">first, second</span>) </span>{
  <span class="hljs-keyword">return</span> first.x === second.x &amp;&amp; first.y === second.y;<font></font>
};<font></font>
<font></font>
Grid.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<font></font>
  string = <span class="hljs-string">''</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">4</span>; j++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cells[j][i]) {<font></font>
        string += <span class="hljs-keyword">this</span>.cells[j][i].value + <span class="hljs-string">' '</span>;<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
        string += <span class="hljs-string">'_ '</span>;<font></font>
      }<font></font>
    }<font></font>
    string += <span class="hljs-string">'\n'</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> string;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// counts the number of isolated groups. </span>
Grid.prototype.islands = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">var</span> mark = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, value</span>) </span>{
    <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt;= <span class="hljs-number">3</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt;= <span class="hljs-number">3</span> &amp;&amp;<font></font>
        self.cells[x][y] &amp;&amp;<font></font>
        self.cells[x][y].value == value &amp;&amp;<font></font>
        !self.cells[x][y].marked ) {<font></font>
      self.cells[x][y].marked = <span class="hljs-literal">true</span>;<font></font>
      <font></font>
      <span class="hljs-keyword">for</span> (direction <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]) {
        <span class="hljs-keyword">var</span> vector = self.getVector(direction);<font></font>
        mark(x + vector.x, y + vector.y, value);<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">var</span> islands = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x=<span class="hljs-number">0</span>; x&lt;<span class="hljs-number">4</span>; x++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> y=<span class="hljs-number">0</span>; y&lt;<span class="hljs-number">4</span>; y++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cells[x][y]) {
        <span class="hljs-keyword">this</span>.cells[x][y].marked = <span class="hljs-literal">false</span><font></font>
      }<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x=<span class="hljs-number">0</span>; x&lt;<span class="hljs-number">4</span>; x++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> y=<span class="hljs-number">0</span>; y&lt;<span class="hljs-number">4</span>; y++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cells[x][y] &amp;&amp;<font></font>
          !<span class="hljs-keyword">this</span>.cells[x][y].marked) {<font></font>
        islands++;<font></font>
        mark(x, y , <span class="hljs-keyword">this</span>.cells[x][y].value);<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-keyword">return</span> islands;<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-comment">// measures how smooth the grid is (as if the values of the pieces</span>
<span class="hljs-comment">// were interpreted as elevations). Sums of the pairwise difference</span>
<span class="hljs-comment">// between neighboring tiles (in log space, so it represents the</span>
<span class="hljs-comment">// number of merges that need to happen before they can merge). </span>
<span class="hljs-comment">// Note that the pieces can be distant</span>
Grid.prototype.smoothness = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> smoothness = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x=<span class="hljs-number">0</span>; x&lt;<span class="hljs-number">4</span>; x++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> y=<span class="hljs-number">0</span>; y&lt;<span class="hljs-number">4</span>; y++) {
      <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.cellOccupied( <span class="hljs-keyword">this</span>.indexes[x][y] )) {
        <span class="hljs-keyword">var</span> value = <span class="hljs-built_in">Math</span>.log(<span class="hljs-keyword">this</span>.cellContent( <span class="hljs-keyword">this</span>.indexes[x][y] ).value) / <span class="hljs-built_in">Math</span>.log(<span class="hljs-number">2</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> direction=<span class="hljs-number">1</span>; direction&lt;=<span class="hljs-number">2</span>; direction++) {
          <span class="hljs-keyword">var</span> vector = <span class="hljs-keyword">this</span>.getVector(direction);
          <span class="hljs-keyword">var</span> targetCell = <span class="hljs-keyword">this</span>.findFarthestPosition(<span class="hljs-keyword">this</span>.indexes[x][y], vector).next;<font></font>
<font></font>
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cellOccupied(targetCell)) {
            <span class="hljs-keyword">var</span> target = <span class="hljs-keyword">this</span>.cellContent(targetCell);
            <span class="hljs-keyword">var</span> targetValue = <span class="hljs-built_in">Math</span>.log(target.value) / <span class="hljs-built_in">Math</span>.log(<span class="hljs-number">2</span>);<font></font>
            smoothness -= <span class="hljs-built_in">Math</span>.abs(value - targetValue);<font></font>
          }<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> smoothness;<font></font>
}<font></font>
<font></font>
Grid.prototype.monotonicity = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">var</span> marked = [];
  <span class="hljs-keyword">var</span> queued = [];
  <span class="hljs-keyword">var</span> highestValue = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> highestCell = {<span class="hljs-attr">x</span>:<span class="hljs-number">0</span>, <span class="hljs-attr">y</span>:<span class="hljs-number">0</span>};
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x=<span class="hljs-number">0</span>; x&lt;<span class="hljs-number">4</span>; x++) {<font></font>
    marked.push([]);<font></font>
    queued.push([]);<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> y=<span class="hljs-number">0</span>; y&lt;<span class="hljs-number">4</span>; y++) {<font></font>
      marked[x].push(<span class="hljs-literal">false</span>);<font></font>
      queued[x].push(<span class="hljs-literal">false</span>);
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cells[x][y] &amp;&amp;
          <span class="hljs-keyword">this</span>.cells[x][y].value &gt; highestValue) {<font></font>
        highestValue = <span class="hljs-keyword">this</span>.cells[x][y].value;<font></font>
        highestCell.x = x;<font></font>
        highestCell.y = y;<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
<font></font>
  increases = <span class="hljs-number">0</span>;<font></font>
  cellQueue = [highestCell];<font></font>
  queued[highestCell.x][highestCell.y] = <span class="hljs-literal">true</span>;<font></font>
  markList = [highestCell];<font></font>
  markAfter = <span class="hljs-number">1</span>; <span class="hljs-comment">// only mark after all queued moves are done, as if searching in parallel</span><font></font>
<font></font>
  <span class="hljs-keyword">var</span> markAndScore = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cell</span>) </span>{<font></font>
    markList.push(cell);<font></font>
    <span class="hljs-keyword">var</span> value;
    <span class="hljs-keyword">if</span> (self.cellOccupied(cell)) {<font></font>
      value = <span class="hljs-built_in">Math</span>.log(self.cellContent(cell).value) / <span class="hljs-built_in">Math</span>.log(<span class="hljs-number">2</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      value = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">for</span> (direction <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]) {
      <span class="hljs-keyword">var</span> vector = self.getVector(direction);
      <span class="hljs-keyword">var</span> target = { <span class="hljs-attr">x</span>: cell.x + vector.x, <span class="hljs-attr">y</span>: cell.y+vector.y }
      <span class="hljs-keyword">if</span> (self.withinBounds(target) &amp;&amp; !marked[target.x][target.y]) {
        <span class="hljs-keyword">if</span> ( self.cellOccupied(target) ) {<font></font>
          targetValue = <span class="hljs-built_in">Math</span>.log(self.cellContent(target).value ) / <span class="hljs-built_in">Math</span>.log(<span class="hljs-number">2</span>);
          <span class="hljs-keyword">if</span> ( targetValue &gt; value ) {
            <span class="hljs-comment">//console.log(cell, value, target, targetValue);</span><font></font>
            increases += targetValue - value;<font></font>
          }<font></font>
        } <font></font>
        <span class="hljs-keyword">if</span> (!queued[target.x][target.y]) {<font></font>
          cellQueue.push(target);<font></font>
          queued[target.x][target.y] = <span class="hljs-literal">true</span>;<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (markAfter == <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">while</span> (markList.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> cel = markList.pop();<font></font>
        marked[cel.x][cel.y] = <span class="hljs-literal">true</span>;<font></font>
      }<font></font>
      markAfter = cellQueue.length;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">while</span> (cellQueue.length &gt; <span class="hljs-number">0</span>) {<font></font>
    markAfter--;<font></font>
    markAndScore(cellQueue.shift())<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> -increases;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// measures how monotonic the grid is. This means the values of the tiles are strictly increasing</span>
<span class="hljs-comment">// or decreasing in both the left/right and up/down directions</span>
Grid.prototype.monotonicity2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// scores for all four directions</span>
  <span class="hljs-keyword">var</span> totals = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<font></font>
<font></font>
  <span class="hljs-comment">// up/down direction</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x=<span class="hljs-number">0</span>; x&lt;<span class="hljs-number">4</span>; x++) {
    <span class="hljs-keyword">var</span> current = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> next = current+<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> ( next&lt;<span class="hljs-number">4</span> ) {
      <span class="hljs-keyword">while</span> ( next&lt;<span class="hljs-number">4</span> &amp;&amp; !<span class="hljs-keyword">this</span>.cellOccupied( <span class="hljs-keyword">this</span>.indexes[x][next] )) {<font></font>
        next++;<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span> (next&gt;=<span class="hljs-number">4</span>) { next--; }
      <span class="hljs-keyword">var</span> currentValue = <span class="hljs-keyword">this</span>.cellOccupied({<span class="hljs-attr">x</span>:x, <span class="hljs-attr">y</span>:current}) ?
        <span class="hljs-built_in">Math</span>.log(<span class="hljs-keyword">this</span>.cellContent( <span class="hljs-keyword">this</span>.indexes[x][current] ).value) / <span class="hljs-built_in">Math</span>.log(<span class="hljs-number">2</span>) :
        <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> nextValue = <span class="hljs-keyword">this</span>.cellOccupied({<span class="hljs-attr">x</span>:x, <span class="hljs-attr">y</span>:next}) ?
        <span class="hljs-built_in">Math</span>.log(<span class="hljs-keyword">this</span>.cellContent( <span class="hljs-keyword">this</span>.indexes[x][next] ).value) / <span class="hljs-built_in">Math</span>.log(<span class="hljs-number">2</span>) :
        <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (currentValue &gt; nextValue) {<font></font>
        totals[<span class="hljs-number">0</span>] += nextValue - currentValue;<font></font>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextValue &gt; currentValue) {<font></font>
        totals[<span class="hljs-number">1</span>] += currentValue - nextValue;<font></font>
      }<font></font>
      current = next;<font></font>
      next++;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// left/right direction</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> y=<span class="hljs-number">0</span>; y&lt;<span class="hljs-number">4</span>; y++) {
    <span class="hljs-keyword">var</span> current = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> next = current+<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> ( next&lt;<span class="hljs-number">4</span> ) {
      <span class="hljs-keyword">while</span> ( next&lt;<span class="hljs-number">4</span> &amp;&amp; !<span class="hljs-keyword">this</span>.cellOccupied( <span class="hljs-keyword">this</span>.indexes[next][y] )) {<font></font>
        next++;<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span> (next&gt;=<span class="hljs-number">4</span>) { next--; }
      <span class="hljs-keyword">var</span> currentValue = <span class="hljs-keyword">this</span>.cellOccupied({<span class="hljs-attr">x</span>:current, <span class="hljs-attr">y</span>:y}) ?
        <span class="hljs-built_in">Math</span>.log(<span class="hljs-keyword">this</span>.cellContent( <span class="hljs-keyword">this</span>.indexes[current][y] ).value) / <span class="hljs-built_in">Math</span>.log(<span class="hljs-number">2</span>) :
        <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> nextValue = <span class="hljs-keyword">this</span>.cellOccupied({<span class="hljs-attr">x</span>:next, <span class="hljs-attr">y</span>:y}) ?
        <span class="hljs-built_in">Math</span>.log(<span class="hljs-keyword">this</span>.cellContent( <span class="hljs-keyword">this</span>.indexes[next][y] ).value) / <span class="hljs-built_in">Math</span>.log(<span class="hljs-number">2</span>) :
        <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (currentValue &gt; nextValue) {<font></font>
        totals[<span class="hljs-number">2</span>] += nextValue - currentValue;<font></font>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextValue &gt; currentValue) {<font></font>
        totals[<span class="hljs-number">3</span>] += currentValue - nextValue;<font></font>
      }<font></font>
      current = next;<font></font>
      next++;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(totals[<span class="hljs-number">0</span>], totals[<span class="hljs-number">1</span>]) + <span class="hljs-built_in">Math</span>.max(totals[<span class="hljs-number">2</span>], totals[<span class="hljs-number">3</span>]);<font></font>
}<font></font>
<font></font>
Grid.prototype.maxValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> max = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x=<span class="hljs-number">0</span>; x&lt;<span class="hljs-number">4</span>; x++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> y=<span class="hljs-number">0</span>; y&lt;<span class="hljs-number">4</span>; y++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cellOccupied(<span class="hljs-keyword">this</span>.indexes[x][y])) {
        <span class="hljs-keyword">var</span> value = <span class="hljs-keyword">this</span>.cellContent(<span class="hljs-keyword">this</span>.indexes[x][y]).value;
        <span class="hljs-keyword">if</span> (value &gt; max) {<font></font>
          max = value;<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.log(max) / <span class="hljs-built_in">Math</span>.log(<span class="hljs-number">2</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// WIP. trying to favor top-heavy distributions (force consolidation of higher value tiles)</span>
<span class="hljs-comment">/*
Grid.prototype.valueSum = function() {
  var valueCount = [];
  for (var i=0; i&lt;11; i++) {
    valueCount.push(0);
  }

  for (var x=0; x&lt;4; x++) {
    for (var y=0; y&lt;4; y++) {
      if (this.cellOccupied(this.indexes[x][y])) {
        valueCount[Math.log(this.cellContent(this.indexes[x][y]).value) / Math.log(2)]++;
      }
    }
  }

  var sum = 0;
  for (var i=1; i&lt;11; i++) {
    sum += valueCount[i] * Math.pow(2, i) + i;
  }

  return sum;
}
*/</span><font></font>
<font></font>
<span class="hljs-comment">// check for win</span>
Grid.prototype.isWin = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x=<span class="hljs-number">0</span>; x&lt;<span class="hljs-number">4</span>; x++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> y=<span class="hljs-number">0</span>; y&lt;<span class="hljs-number">4</span>; y++) {
      <span class="hljs-keyword">if</span> (self.cellOccupied(<span class="hljs-keyword">this</span>.indexes[x][y])) {
        <span class="hljs-keyword">if</span> (self.cellContent(<span class="hljs-keyword">this</span>.indexes[x][y]).value == <span class="hljs-number">2048</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//Grid.prototype.zobristTable = {}</span>
<span class="hljs-comment">//for</span>
<span class="hljs-comment">//Grid.prototype.hash = function() {</span>
<span class="hljs-comment">//}</span></code></pre></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2048.xlsm</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Excelアプリケーション自体</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はGoogleからダウンロードできます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションの機能は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、モンテカルロ法を使用してAIを再生する以前の記事で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明さ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">れています</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">今日のソリューションは、既存のモンテカルロに追加されました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AIおよび2048シリーズのすべての記事</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モンテカルロ</font></font></a></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ミニマックス+アルファベータクリッピング</font></font></strong></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大を待っています</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">神経網</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja474668/index.html">静的ジェネレーターおよびGitHubページ上のサイトのCI / CDとしてのGitHubアクション</a></li>
<li><a href="../ja474672/index.html">React、JSX、WebモジュールなしのブラウザーでのESモジュール（動的を含む）のインポート</a></li>
<li><a href="../ja474674/index.html">マシンビジョンと医学</a></li>
<li><a href="../ja474676/index.html">GLES3およびWebGL2でのGPU上の数十万のユニークな粒子の相互作用アルゴリズム</a></li>
<li><a href="../ja474678/index.html">Khronos GroupがVulkanの例を使用して統合リポジトリを作成しました</a></li>
<li><a href="../ja474686/index.html">幻想的な物語「救い」（10分）</a></li>
<li><a href="../ja474688/index.html">蒸気機関車とレトロな電車</a></li>
<li><a href="../ja474690/index.html">コンピューターでの作業をより便利にするために、高さが可変のコンソールを作成する</a></li>
<li><a href="../ja474692/index.html">Kubernetes開発のSkaffoldレビュー</a></li>
<li><a href="../ja474694/index.html">パフォーマンステストのフレームワークを選択してねじった方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>