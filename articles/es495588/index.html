<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÆ üíÉ üëÅÔ∏è Creando roguelike en Unity desde cero: generador de mazmorras üèáüèæ üî∂ üêë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta vez nos sumergiremos en la implementaci√≥n del algoritmo del generador de mazmorras. En el √∫ltimo art√≠culo, creamos la primera sala, y ahora gener...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Creando roguelike en Unity desde cero: generador de mazmorras</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495588/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09d/9af/aac/09d9afaace836ef3bde082e3d63c580a.png" alt="imagen"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta vez nos sumergiremos en la implementaci√≥n del algoritmo del generador de mazmorras. En el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√∫ltimo art√≠culo,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> creamos la primera sala, y ahora generaremos el resto del nivel de mazmorra. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero antes de comenzar, me gustar√≠a corregir un error de una publicaci√≥n anterior. De hecho, en las √∫ltimas semanas he aprendido algo nuevo, por lo que parte del trabajo que he realizado est√° desactualizado y quiero hablar sobre ello. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øRecuerdas la clase de posici√≥n que creamos? De hecho, Unity ya tiene una clase incorporada que realiza exactamente las mismas funciones, pero con un control ligeramente mejor: es m√°s f√°cil de declarar y procesar. Esta clase se llama Vector2Int. Por lo tanto, antes de comenzar, eliminaremos la clase Position de MapManager.cs y reemplazaremos cada variable de Position con la variable Vector2Int.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/b7d/f40/656b7df4053976af99cbd2d359edd494.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo mismo debe hacerse en varios lugares en el script DungeonGenerator.cs. </font><font style="vertical-align: inherit;">Ahora vamos al resto del algoritmo.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 7 - generaci√≥n de sala / sala</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comenzaremos con un peque√±o cambio en la funci√≥n FirstRoom () creada la √∫ltima vez. </font><font style="vertical-align: inherit;">En lugar de crear otra funci√≥n para generar todos los dem√°s elementos del mapa y duplicar un mont√≥n de c√≥digo, simplemente transformamos esta funci√≥n, convirti√©ndola en una GenerateFeature () generalizada. </font><font style="vertical-align: inherit;">Por lo tanto, cambie el nombre de FirstRoom a GenerateFeature. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora necesitaremos pasar par√°metros a esta funci√≥n. </font><font style="vertical-align: inherit;">En primer lugar, debe saber qu√© funci√≥n genera: una habitaci√≥n o un pasillo. </font><font style="vertical-align: inherit;">Podemos pasar una cadena llamada </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipo</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Luego, la funci√≥n necesita conocer el punto de partida del elemento, es decir, de qu√© pared proviene (porque siempre creamos un nuevo elemento a partir de la pared del elemento m√°s antiguo), y para esto, pasar como argumento de Wall es suficiente. </font><font style="vertical-align: inherit;">Finalmente, la primera sala que se crear√° tiene caracter√≠sticas especiales, por lo que necesitamos una variable bool opcional que indique si el elemento es la primera sala. </font><font style="vertical-align: inherit;">Por defecto, es falso: bool isFirst = false. </font><font style="vertical-align: inherit;">Entonces el t√≠tulo de la funci√≥n cambiar√° de esto:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5f/b79/d17/e5fb79d178098b3bcde238ff733f9ca9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
en este:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45e/124/afc/45e124afc4b4f60b12ab18deaa060719.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Multa. </font><font style="vertical-align: inherit;">El siguiente paso es cambiar la forma de calcular el ancho y la altura del elemento. </font><font style="vertical-align: inherit;">Mientras los calculamos, obtenemos un valor aleatorio entre los valores m√≠nimo y m√°ximo de la altura y el ancho de las habitaciones; esto es ideal para las habitaciones, pero no funcionar√° para los corredores. </font><font style="vertical-align: inherit;">Entonces, hasta ahora tenemos lo siguiente:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f5/c0d/976/2f5c0d9765a596c2d2188b56b1f7b7ff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero los corredores tendr√°n un tama√±o constante de 3 de ancho o alto, dependiendo de la orientaci√≥n. </font><font style="vertical-align: inherit;">Por lo tanto, debemos verificar cu√°l es el elemento: una habitaci√≥n o un corredor, y luego realizar los c√°lculos apropiados.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/071/163/df8/071163df82fc248fc92d370672369743.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces. </font><font style="vertical-align: inherit;">Verificamos si el art√≠culo es una habitaci√≥n. </font><font style="vertical-align: inherit;">En caso afirmativo, hacemos lo mismo que antes </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 : obtenemos un n√∫mero aleatorio en el intervalo entre m√≠nimo y m√°ximo de altura y anchura. </font><font style="vertical-align: inherit;">Pero ahora en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lo</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mismo si necesita hacer algo un poco diferente. </font><font style="vertical-align: inherit;">Necesitamos verificar la orientaci√≥n del corredor. </font><font style="vertical-align: inherit;">Afortunadamente, al generar un muro, guardamos informaci√≥n sobre en qu√© direcci√≥n se dirige, por lo que lo usamos para obtener la orientaci√≥n del corredor.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91a/a84/328/91aa84328140d1414b8512843e1cd397.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero a√∫n no hemos declarado la variable minCorridorLength. </font><font style="vertical-align: inherit;">Debe volver a las declaraciones de variables y declararlo, justo encima de maxCorridorLength.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/857/6e1/f138576e1dc1cb4a9949fd51e8c5fe47.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora volvamos a nuestras declaraciones de cambio condicional. </font><font style="vertical-align: inherit;">Lo que estamos haciendo aqu√≠: obtenemos el valor de la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direcci√≥n de la</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pared, es decir, d√≥nde est√° mirando la pared, desde donde ir√° el corredor. </font><font style="vertical-align: inherit;">La direcci√≥n solo puede tener cuatro valores posibles: Sur, Norte, Oeste y Este. </font><font style="vertical-align: inherit;">En el caso del sur y el norte, el corredor tendr√° un ancho de 3 (dos paredes y un piso en el medio) y una altura variable (longitud). </font><font style="vertical-align: inherit;">Para el oeste y el este, todo ser√° al rev√©s: la altura ser√° constantemente igual a 3, y el ancho tendr√° una longitud variable. </font><font style="vertical-align: inherit;">Hagamoslo.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e2/175/8d6/0e21758d6d2e17406ce516c3fef6ccf5.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Guau. </font><font style="vertical-align: inherit;">Y ah√≠ es donde terminamos dimensionando el nuevo elemento. </font><font style="vertical-align: inherit;">Ahora debe decidir d√≥nde colocarlo. </font><font style="vertical-align: inherit;">Colocamos la primera habitaci√≥n en un lugar aleatorio dentro de los valores de umbral relativos al centro del mapa.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fb/d53/010/6fbd5301066f6b0ba77ab90142370a5d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero para todos los dem√°s elementos, esto no funcionar√°. Deben comenzar al lado del punto aleatorio en la pared desde el cual se genera el elemento. Entonces cambiemos el c√≥digo. Primero, debemos verificar si el elemento es la primera habitaci√≥n. Si esta es la primera habitaci√≥n, definimos los puntos de partida de la misma manera que antes, como la mitad del ancho y la altura del mapa.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d29/44d/ff3d2944da973a48200a6c9c3066d20d.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De lo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contrario,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si el elemento no es la primera habitaci√≥n, obtenemos un punto aleatorio en la pared desde el cual se genera el elemento. Primero, debemos verificar si el muro tiene un tama√±o de 3 (esto significar√° que es el punto final del corredor), y si es as√≠, entonces el punto medio siempre se seleccionar√°, es decir, el √≠ndice 1 del conjunto de muros (con 3 elementos, el conjunto tiene √≠ndices 0, 1, 2). Pero si el tama√±o no es igual a 3 (el muro no es el punto final del corredor), entonces tomamos un punto aleatorio entre el punto 1 y la longitud del muro menos 2. Esto es necesario para evitar pasajes creados en la esquina. Es decir, por ejemplo, en una pared con una longitud de 6, excluimos los √≠ndices 0 y 5 (primero y √∫ltimo), y seleccionamos un punto aleatorio entre los puntos 1, 2, 3 y 4.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/4e1/703/ee24e1703c28b4cfa96e98d84a76c790.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora tenemos la posici√≥n del punto en la pared en el que se crear√° un nuevo elemento. Pero no podemos simplemente comenzar a generar un elemento a partir de ah√≠, porque de esta manera ser√° bloqueado por paredes ya colocadas. Tambi√©n es importante tener en cuenta que el elemento comienza a generarse desde su esquina inferior izquierda, y luego el incremento se realiza hacia la derecha y hacia arriba, por lo que debemos establecer la posici√≥n de inicio en diferentes lugares, dependiendo de la direcci√≥n en la que mira el muro. Adem√°s, la primera columna xy la primera fila y ser√°n paredes, y si comenzamos un nuevo elemento justo al lado de un punto en la pared, podemos crear un corredor que termine en una esquina de la habitaci√≥n y no en un lugar adecuado en la pared.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, si la pared se dirige hacia el norte, entonces es necesario que el elemento comience en una posici√≥n al norte en el eje y, pero en un n√∫mero aleatorio de posiciones al oeste en el eje x, en el rango de 1 al ancho de la habitaci√≥n-2. </font><font style="vertical-align: inherit;">En la direcci√≥n sur, el eje x act√∫a igual, pero la posici√≥n inicial en el eje y es la posici√≥n del punto en la pared menos la altura de la habitaci√≥n. </font><font style="vertical-align: inherit;">Los muros occidental y oriental siguen la misma l√≥gica, solo con ejes invertidos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero antes de hacer todo esto, debemos guardar la posici√≥n del punto de muro en la variable Vector2Int para poder manipularlo m√°s tarde.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/374/129/41a/37412941a3a58f32fd2dd38c1fc2c252.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Excelente. </font><font style="vertical-align: inherit;">Vamos a hacer eso.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/140/2c7/ec0/1402c7ec0596d77f9a9b70b5eac076a9.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, generamos un elemento con el tama√±o y la posici√≥n, y el siguiente paso es colocar el elemento en el mapa. </font><font style="vertical-align: inherit;">Pero primero, necesitamos descubrir si realmente hay espacio en el mapa para este elemento en esta posici√≥n. </font><font style="vertical-align: inherit;">Por ahora, solo llamamos a la funci√≥n CheckIfHasSpace (). </font><font style="vertical-align: inherit;">Se resaltar√° en rojo, porque a√∫n no lo hemos implementado. </font><font style="vertical-align: inherit;">Haremos esto justo despu√©s de terminar lo que se debe hacer aqu√≠ en la funci√≥n GenerateFeature (). </font><font style="vertical-align: inherit;">Por lo tanto, ignore el subrayado rojo y contin√∫e.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b20/805/942/b2080594237c23cae023cabb20b2d20e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la siguiente parte, se crean muros. </font><font style="vertical-align: inherit;">Hasta que lo toquemos, con la excepci√≥n del fragmento en el segundo bucle </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/227/d7f/e2b/227d7fe2bf3c2eef41f423e36b4afc79.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mientras escrib√≠a esta publicaci√≥n, not√© que estas construcciones if-else est√°n completamente equivocadas. Por ejemplo, algunos muros en ellos recibir√°n una longitud de 1. Esto sucede porque cuando la posici√≥n se va a agregar, por ejemplo, al muro norte, entonces si estaba en la esquina con el muro este, no se agregar√° al muro este, como deber√≠a. Esto caus√≥ errores molestos en el algoritmo de generaci√≥n. Elimin√©moslos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arreglarlos es bastante simple. Es suficiente eliminar todo lo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem√°s</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que la posici√≥n pase por todas las construcciones </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y no se detenga en la primera si devuelve </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verdadero</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Entonces el √∫ltimo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√°s</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (el que no es </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">otro si</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) se cambia a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que comprueba que la posici√≥n ya se ha agregado como Muro y, si no lo est√°, la agrega como Piso.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/784/834/65c784834461a2d8b05d1d39dd9ee44c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Incre√≠ble, casi hemos terminado aqu√≠. </font><font style="vertical-align: inherit;">Ahora tenemos un elemento completamente nuevo, creado en el lugar correcto, pero es lo mismo que nuestra primera habitaci√≥n: est√° completamente cerrado por paredes. </font><font style="vertical-align: inherit;">Esto significa que el jugador no podr√° llegar a este nuevo lugar. </font><font style="vertical-align: inherit;">Es decir, necesitamos convertir un punto en la pared (que, como recordamos, se almacena en una variable de tipo Vector2Int) y el punto correspondiente en la pared de un nuevo elemento en Floor. </font><font style="vertical-align: inherit;">Pero solo cuando el elemento no es la primera habitaci√≥n.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/350/67f/5ac/35067f5ac7db26fd304578b8dd53326c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este fragmento de c√≥digo verifica si el nuevo elemento es la primera habitaci√≥n. </font><font style="vertical-align: inherit;">De lo contrario, convierte la √∫ltima posici√≥n de la pared en el piso y luego verifica la direcci√≥n en la que mira la pared para verificar qu√© baldosa del nuevo elemento debe convertirse en el piso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hemos llegado a la √∫ltima parte de la funci√≥n GenerateFeature (). </font><font style="vertical-align: inherit;">Ya tiene l√≠neas que agregan informaci√≥n sobre el elemento que crea la funci√≥n.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fe/165/626/4fe165626aca42951f86568a4d6649c7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ necesitamos cambiar algo. </font><font style="vertical-align: inherit;">En primer lugar, el tipo de elemento no siempre es igual a Room. </font><font style="vertical-align: inherit;">Afortunadamente, la variable requerida se pasa a la funci√≥n como un par√°metro, es decir, la cadena de tipo. </font><font style="vertical-align: inherit;">As√≠ que vamos a reemplazar "Habitaci√≥n" aqu√≠ con el tipo.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b57/d12/f17/b57d12f17802ec40e0c609d26803f661.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno. </font><font style="vertical-align: inherit;">Ahora, para que el algoritmo que genera todos los elementos del juego funcione correctamente, necesitamos agregar nuevos datos aqu√≠. </font><font style="vertical-align: inherit;">A saber, un int que cuenta el n√∫mero de elementos creados y una lista de todos los elementos creados. </font><font style="vertical-align: inherit;">Subimos al lugar donde declaramos todas las variables y declaramos un int con el nombre countFeatures, as√≠ como una Lista de elementos con el nombre allFeatures. </font><font style="vertical-align: inherit;">La lista de todos los elementos debe ser p√∫blica y el contador int puede ser privado.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcb/ebf/8dd/bcbebf8ddbc768864ba70331317cc72c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora regrese a la funci√≥n GenerateFeature () y agregue algunas l√≠neas al final: incremente la variable countFeatures y agregue un nuevo elemento a la lista allFeatures.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e6/8a8/496/5e68a8496d7047c87650a609acb912cf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, nuestro GenerateFeature () est√° casi completo. </font><font style="vertical-align: inherit;">M√°s tarde, tendremos que volver a √©l para completar la funci√≥n CheckIfHasSpace vac√≠a, pero primero debemos crearla. </font><font style="vertical-align: inherit;">Eso es lo que haremos ahora.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 8: verifique si hay un lugar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora creemos una nueva funci√≥n justo despu√©s de que se complete la funci√≥n GenerateFeature (). Necesita dos argumentos: la posici√≥n en la que comienza el elemento y la posici√≥n en la que termina. Puede usar dos variables Vector2Int como ellas. La funci√≥n debe devolver un valor bool para que pueda usarse </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si se</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> busca espacio.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/998/f03/cad/998f03cad9a6bd8a05bd7d8b9658bad6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Est√° subrayado en rojo, porque hasta ahora no ha devuelto nada. Pronto lo arreglaremos, pero por ahora no prestaremos atenci√≥n. En esta funci√≥n, recorreremos todas las posiciones entre el principio y el final del elemento, y comprobaremos si la posici√≥n actual en MapManager.map es nula o si ya hay algo all√≠. Si hay algo all√≠, entonces detenemos la funci√≥n y devolvemos falso. Si no, entonces contin√∫a. Si la funci√≥n llega al final del ciclo sin encontrar los lugares llenos, entonces devuelve verdadero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, antes de verificar la posici√≥n para nulo, necesitamos una l√≠nea para verificar si la posici√≥n est√° dentro del mapa. Porque de lo contrario, podemos obtener un error de √≠ndice de matriz y un bloqueo del juego.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/473/582/a5b/473582a5b560d6738de08b2f6190cf6b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Multa. </font><font style="vertical-align: inherit;">Ahora regrese al lugar donde insertamos esta funci√≥n dentro de la funci√≥n GenerateFeature (). </font><font style="vertical-align: inherit;">Necesitamos arreglar esta llamada porque no pasa los argumentos necesarios. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ queremos insertar una </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">declaraci√≥n if</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para verificar si hay suficiente espacio para el elemento. </font><font style="vertical-align: inherit;">Si el resultado es falso, finalizamos la funci√≥n sin insertar un nuevo elemento en MapManager.map.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/068/661/e53/068661e533ef21536a51f17ae3de570b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Necesitamos pasar los argumentos requeridos, es decir, dos variables Vector2Int. </font><font style="vertical-align: inherit;">Con el primero, todo es simple, esta es la posici√≥n con las coordenadas x e y del punto de inicio del elemento.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c1/869/26d/0c186926d741d2423c791500adbed2cd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo es m√°s dif√≠cil, pero no mucho. </font><font style="vertical-align: inherit;">Este es el punto de partida m√°s la altura para y y el ancho para x, restando 1 de ambos (porque el inicio ya se ha tenido en cuenta).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a18/f85/4a9/a18f854a9e0a0bbe5883012bf2e313ff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora pasemos al siguiente paso: crear un algoritmo para llamar a la funci√≥n GenerateFeature ().</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 9: elementos generados por la llamada</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Volver a la funci√≥n GenerateDungeon () creada en la parte anterior del art√≠culo. </font><font style="vertical-align: inherit;">Ahora deber√≠a verse as√≠:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e9/57c/5e3/3e957c5e316f5329e935353e961df47b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La llamada a FirstRoom () est√° subrayada en rojo porque cambiamos el nombre de esta funci√≥n. </font><font style="vertical-align: inherit;">Entonces llamemos a la primera generaci√≥n de salas.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d6/926/908/8d692690826997750f3bc860ae9216f0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pasamos los argumentos necesarios: "Room" como tipo, porque la primera habitaci√≥n siempre ser√° Room, new Wall (), porque la primera habitaci√≥n no se crear√° de ninguna otra, por lo que simplemente pasamos nulo, y esto es bastante normal. En lugar de nuevo Wall (), puede sustituir </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulo</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , esto es una cuesti√≥n de preferencia personal. El √∫ltimo argumento determina si el nuevo elemento es la primera habitaci√≥n, por lo que en nuestro caso pasamos </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verdadero</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora llegamos al punto principal. Usamos un bucle for que se ejecutar√° 500 veces; s√≠, intentaremos agregar elementos 500 veces. Pero si el n√∫mero de elementos creados (variable countFeatures) es igual al n√∫mero m√°ximo especificado de elementos (variable maxFeatures), entonces interrumpimos este ciclo.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e6/410/ded/9e6410ded47210776fcda40ae2492229.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El primer paso en este ciclo es declarar el elemento a partir del cual se crear√° el nuevo elemento. </font><font style="vertical-align: inherit;">Si hemos creado solo un elemento (la primera sala), entonces ser√° el original. </font><font style="vertical-align: inherit;">De lo contrario, seleccionamos aleatoriamente uno de los elementos ya creados.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddb/e84/f92/ddbe84f92cbb06f56e3ccce561dde991.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora elegiremos qu√© muro de este elemento se usar√° para crear el nuevo elemento.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ad/e7c/0e4/7ade7c0e438985098eed6f5dbdd42e6d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que todav√≠a no tenemos esta funci√≥n ChoseWall (). </font><font style="vertical-align: inherit;">Escrib√°moslo r√°pido. </font><font style="vertical-align: inherit;">Baja hasta el final de la funci√≥n y cr√©ala. </font><font style="vertical-align: inherit;">Deber√≠a devolver un muro y usar un elemento como argumento, para que la funci√≥n pueda seleccionar el muro de este elemento.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aeb/631/9f1/aeb6319f1ee6f601474d0aa0e32e2c77.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo cre√© entre las funciones CheckIfHasSpace () y DrawMap (). </font><font style="vertical-align: inherit;">Tenga en cuenta que si est√° trabajando en Visual Studio, que est√° instalado con Unity, puede usar los campos - / + a la izquierda para contraer / expandir partes del c√≥digo para simplificar el trabajo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En esta funci√≥n encontraremos el muro desde el cual el elemento a√∫n no se ha creado. </font><font style="vertical-align: inherit;">A veces obtendremos elementos con uno o m√°s muros de los cuales otros elementos ya est√°n unidos, por lo que debemos verificar una y otra vez si alguno de los muros aleatorios est√° libre. </font><font style="vertical-align: inherit;">Para hacer esto, usamos un bucle for repetido diez veces: si despu√©s de estas diez veces no se encuentra un muro libre, entonces la funci√≥n devuelve nulo.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/44a/028/b1044a028bf9ab566a0120690311396d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora regrese a la funci√≥n GenerateDungeon () y pase el elemento original como par√°metro a la funci√≥n ChoseWall ().</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a3/281/8aa/0a32818aafc77ddd87f1ffac21b6981e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La l√≠nea </font></font><code>if (wall == null) continue;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">significa que si la funci√≥n de b√∫squeda de muro devuelve falso, entonces el elemento original no puede generar un nuevo elemento, por lo tanto, la funci√≥n </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continuar√° el</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ciclo, es decir, no podr√≠a crear un nuevo elemento y pasar√° a la siguiente iteraci√≥n del ciclo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora necesitamos seleccionar el tipo para el siguiente elemento. </font><font style="vertical-align: inherit;">Si el elemento fuente es una habitaci√≥n, la siguiente debe ser un pasillo (no queremos que la habitaci√≥n conduzca directamente a otra habitaci√≥n sin un pasillo entre ellos). </font><font style="vertical-align: inherit;">Pero si este es un corredor, entonces debemos crear la probabilidad de que otro corredor o habitaci√≥n sea el pr√≥ximo.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b22/df0/954/b22df0954bbe21d82506d42e5118a70f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Multa. </font><font style="vertical-align: inherit;">Ahora solo necesitamos llamar a la funci√≥n GenerateFeature (), pasarle la pared y escribir como par√°metros.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a07/90b/834/a0790b83479f46dc17c57fbb981aef81.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, vaya al inspector de Unity, seleccione el objeto GameManager y cambie los valores a lo siguiente:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cc/09c/786/9cc09c786641bf85a89674cc33042ebf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si ahora hace clic en el bot√≥n de reproducci√≥n, ¬°ya ver√° los resultados!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09d/9af/aac/09d9afaace836ef3bde082e3d63c580a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como dije, esta no es la mejor mazmorra. </font><font style="vertical-align: inherit;">Tenemos muchos callejones sin salida. </font><font style="vertical-align: inherit;">Pero es completamente funcional y garantiza que no tendr√° una habitaci√≥n que no est√© conectada a ninguna otra. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬°Espero que lo hayan disfrutado! </font><font style="vertical-align: inherit;">En la pr√≥xima publicaci√≥n, crearemos un jugador que se mover√° a trav√©s de la mazmorra, y luego convertiremos el mapa de ASCII en sprite.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> UnityEngine.UI;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Post3</span> : <span class="hljs-title">MonoBehaviour</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapWidth;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapHeight;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMaxRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMaxRoom;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> minCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxFeatures;
    <span class="hljs-keyword">int</span> countFeatures;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> isASCII;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> List&lt;Feature&gt; allFeatures;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitializeDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        MapManager.map = <span class="hljs-keyword">new</span> Tile[mapWidth, mapHeight];<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GenerateDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        GenerateFeature(<span class="hljs-string">"Room"</span>, <span class="hljs-keyword">new</span> Wall(), <span class="hljs-literal">true</span>);<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) {<font></font>
            Feature originFeature;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (allFeatures.Count == <span class="hljs-number">1</span>) {<font></font>
                originFeature = allFeatures[<span class="hljs-number">0</span>];<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> {<font></font>
                originFeature = allFeatures[Random.Range(<span class="hljs-number">0</span>, allFeatures.Count - <span class="hljs-number">1</span>)];<font></font>
            }<font></font>
<font></font>
            Wall wall = ChoseWall(originFeature);<font></font>
            <span class="hljs-keyword">if</span> (wall == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
            <span class="hljs-keyword">string</span> type;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (originFeature.type == <span class="hljs-string">"Room"</span>) {<font></font>
                type = <span class="hljs-string">"Corridor"</span>;<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) &lt; <span class="hljs-number">90</span>) {<font></font>
                    type = <span class="hljs-string">"Room"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                    type = <span class="hljs-string">"Corridor"</span>;<font></font>
                }<font></font>
            }<font></font>
<font></font>
            GenerateFeature(type, wall);<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (countFeatures &gt;= maxFeatures) <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
<font></font>
        DrawMap(isASCII);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GenerateFeature</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> type, Wall wall, <span class="hljs-keyword">bool</span> isFirst = <span class="hljs-literal">false</span></span>)</span> {<font></font>
        Feature room = <span class="hljs-keyword">new</span> Feature();<font></font>
        room.positions = <span class="hljs-keyword">new</span> List&lt;Vector2Int&gt;();<font></font>
<font></font>
        <span class="hljs-keyword">int</span> roomWidth = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> roomHeight = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) {<font></font>
            roomWidth = Random.Range(widthMinRoom, widthMaxRoom);<font></font>
            roomHeight = Random.Range(heightMinRoom, heightMaxRoom);<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:<font></font>
                    roomWidth = <span class="hljs-number">3</span>;<font></font>
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:<font></font>
                    roomWidth = <span class="hljs-number">3</span>;<font></font>
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    roomHeight = <span class="hljs-number">3</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    roomHeight = <span class="hljs-number">3</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">int</span> xStartingPoint;
        <span class="hljs-keyword">int</span> yStartingPoint;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFirst) {<font></font>
            xStartingPoint = mapWidth / <span class="hljs-number">2</span>;<font></font>
            yStartingPoint = mapHeight / <span class="hljs-number">2</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">int</span> id;
            <span class="hljs-keyword">if</span> (wall.positions.Count == <span class="hljs-number">3</span>) id = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> id = Random.Range(<span class="hljs-number">1</span>, wall.positions.Count - <span class="hljs-number">2</span>);<font></font>
<font></font>
            xStartingPoint = wall.positions[id].x;<font></font>
            yStartingPoint = wall.positions[id].y;<font></font>
        }<font></font>
<font></font>
        Vector2Int lastWallPosition = <span class="hljs-keyword">new</span> Vector2Int(xStartingPoint, yStartingPoint);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFirst) {<font></font>
            xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth);<font></font>
            yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight);<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> xStartingPoint--;<font></font>
                    yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> xStartingPoint--;<font></font>
                    yStartingPoint ++;<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    xStartingPoint -= roomWidth;<font></font>
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> yStartingPoint--;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    xStartingPoint++;<font></font>
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> yStartingPoint--;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
         <span class="hljs-keyword">if</span> (!CheckIfHasSpace(<span class="hljs-keyword">new</span> Vector2Int(xStartingPoint, yStartingPoint), <span class="hljs-keyword">new</span> Vector2Int(xStartingPoint + roomWidth - <span class="hljs-number">1</span>, yStartingPoint + roomHeight - <span class="hljs-number">1</span>))) {
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        room.walls = <span class="hljs-keyword">new</span> Wall[<span class="hljs-number">4</span>];<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; room.walls.Length; i++) {<font></font>
            room.walls[i] = <span class="hljs-keyword">new</span> Wall();<font></font>
            room.walls[i].positions = <span class="hljs-keyword">new</span> List&lt;Vector2Int&gt;();<font></font>
            room.walls[i].length = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">switch</span> (i) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"South"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"North"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"West"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"East"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; roomHeight; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; roomWidth; x++) {<font></font>
                Vector2Int position = <span class="hljs-keyword">new</span> Vector2Int();<font></font>
                position.x = xStartingPoint + x;<font></font>
                position.y = yStartingPoint + y;<font></font>
<font></font>
                room.positions.Add(position);<font></font>
<font></font>
                MapManager.map[position.x, position.y] = <span class="hljs-keyword">new</span> Tile();<font></font>
                MapManager.map[position.x, position.y].xPosition = position.x;<font></font>
                MapManager.map[position.x, position.y].yPosition = position.y;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">0</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">0</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (y == (roomHeight - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">1</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">1</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">2</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">2</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (x == (roomWidth - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">3</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">3</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (MapManager.map[position.x, position.y].type != <span class="hljs-string">"Wall"</span>) {<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Floor"</span>;<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!isFirst) {<font></font>
            MapManager.map[lastWallPosition.x, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:<font></font>
                    MapManager.map[lastWallPosition.x, lastWallPosition.y - <span class="hljs-number">1</span>].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:<font></font>
                    MapManager.map[lastWallPosition.x, lastWallPosition.y + <span class="hljs-number">1</span>].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    MapManager.map[lastWallPosition.x - <span class="hljs-number">1</span>, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    MapManager.map[lastWallPosition.x + <span class="hljs-number">1</span>, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        room.width = roomWidth;<font></font>
        room.height = roomHeight;<font></font>
        room.type = type;<font></font>
        allFeatures.Add(room);<font></font>
        countFeatures++;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CheckIfHasSpace</span>(<span class="hljs-params">Vector2Int start, Vector2Int end</span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = start.y; y &lt;= end.y; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = start.x; x &lt;= end.x; x++) {
                <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= mapWidth || y &gt;= mapHeight) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">if</span> (MapManager.map != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">Wall <span class="hljs-title">ChoseWall</span>(<span class="hljs-params">Feature feature</span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            <span class="hljs-keyword">int</span> id = Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) / <span class="hljs-number">25</span>;
            <span class="hljs-keyword">if</span> (!feature.walls[id].hasFeature) {
                <span class="hljs-keyword">return</span> feature.walls[id];<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawMap</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> isASCII</span>)</span> {
        <span class="hljs-keyword">if</span> (isASCII) {<font></font>
            Text screen = GameObject.Find(<span class="hljs-string">"ASCIITest"</span>).GetComponent&lt;Text&gt;();<font></font>
<font></font>
            <span class="hljs-keyword">string</span> asciiMap = <span class="hljs-string">""</span>;<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = (mapHeight - <span class="hljs-number">1</span>); y &gt;= <span class="hljs-number">0</span>; y--) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; mapWidth; x++) {
                    <span class="hljs-keyword">if</span> (MapManager.map[x, y] != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">switch</span> (MapManager.map[x, y].type) {
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Wall"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"#"</span>;
                                <span class="hljs-keyword">break</span>;
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Floor"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"."</span>;
                                <span class="hljs-keyword">break</span>;<font></font>
                        }<font></font>
                    }<font></font>
                    <span class="hljs-keyword">else</span> {<font></font>
                        asciiMap += <span class="hljs-string">" "</span>;<font></font>
                    }<font></font>
<font></font>
                    <span class="hljs-keyword">if</span> (x == (mapWidth - <span class="hljs-number">1</span>)) {<font></font>
                        asciiMap += <span class="hljs-string">"\n"</span>;<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
<font></font>
            screen.text = asciiMap;<font></font>
        }<font></font>
    }<font></font>
}</code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es495556/index.html">Fortinet: una selecci√≥n de materiales √∫tiles</a></li>
<li><a href="../es495560/index.html">Tendencias de Internet de las cosas: AI responde llamadas, nubes y 5G Tame Big Data, vivienda y servicios p√∫blicos - L√≠der en innovaci√≥n</a></li>
<li><a href="../es495572/index.html">Hardware Ecosystem Community lanza podcast para todos en la industria electr√≥nica</a></li>
<li><a href="../es495576/index.html">Plataforma autopropulsada en el esp8266 MK con micropython</a></li>
<li><a href="../es495580/index.html">Pepino JVM - No solo BDD</a></li>
<li><a href="../es495592/index.html">C√≥mo usar diccionarios (y no solo)</a></li>
<li><a href="../es495594/index.html">Comience a ganar dinero con el software: creando mini-digital-business</a></li>
<li><a href="../es495596/index.html">Trabajo a distancia en la oficina. RDP, Port Knocking, Mikrotik: simple y seguro</a></li>
<li><a href="../es495602/index.html">¬°Comenzando con Core Data! Dif√≠cil en palabras simples [Parte 2]</a></li>
<li><a href="../es495604/index.html">Localizaci√≥n temporal en Symfony 4 + Twig</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>