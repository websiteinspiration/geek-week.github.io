<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚐 👩🏽‍🎓 🍖 [Teil 1/2] Anleitung zu FFmpeg und SDL oder Schreiben eines Videoplayers in weniger als 1000 Zeilen 🤟🏾 📆 ✔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Obwohl diese Informationen bereits veraltet sind, ist das Originalmaterial immer noch eine beliebte Inspirationsquelle für verschiedene nützliche Inha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>[Teil 1/2] Anleitung zu FFmpeg und SDL oder Schreiben eines Videoplayers in weniger als 1000 Zeilen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/500402/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><div style="text-align:center;"><img width="780" height="325" src="https://habrastorage.org/webt/8g/lm/9b/8glm9bxivqkvscmah31ojdjmzci.png"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl diese Informationen bereits veraltet sind, ist das Originalmaterial immer noch eine beliebte Inspirationsquelle für verschiedene nützliche Inhalte zum Thema FFmpeg. </font><font style="vertical-align: inherit;">Es gibt jedoch noch keine vollständige Übersetzung des Originals ins Russische. </font><font style="vertical-align: inherit;">Wir korrigieren das nervige Auslassen, denn es ist besser spät als nie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und obwohl wir es versucht haben, sind </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwierigkeiten bei der Übersetzung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in einem so umfangreichen Text unvermeidlich </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fehler melden (vorzugsweise in privaten Nachrichten) - gemeinsam werden wir es besser machen.</font></font><a name="menu"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhaltsverzeichnis</font></font></h3><div class="scrollable-table"><table>
<tbody><tr>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 1</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 2</font></font></th>
</tr>
<tr>
<td align="left"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorwort </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lektion 1: Erstellen von Screencaps </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lektion 2: Anzeigen der </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lektion 3: Abspielen von Sound </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lektion 4: Mehrere Themen </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lektion 5: Synchronisieren von Videos</font></font></a><br>
</td>
<td align="left"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 6:  </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 7: </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 1.  </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 2.  </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a></td>
</tr>
</tbody></table></div><a name="habracut"></a><a name="preamble"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="EDISON Software - Webentwicklung"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - Webentwicklung"></a><br clear="right">
     EDISON.<br>
<br>
        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">     </a>,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">      C  C++</a>.<br>
<br>
     ! ;-)</blockquote><br>
<h2> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Zum Inhaltsverzeichnis">⇑</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Lektion 1: Screencaps erstellen">→</a></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD: Dieser Leitfaden wurde ab Februar 2015 aktualisiert. </font></font></b><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFmpeg</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine großartige Bibliothek zum Erstellen von Videoanwendungen sowie allgemeinen Dienstprogrammen. FFmpeg kümmert sich um die gesamte Videoverarbeitungsroutine und führt alle Decodierungen, Codierungen, Multiplexe und Demultiplexe durch. Dies vereinfacht die Erstellung von Medienanwendungen erheblich. Alles ist ganz einfach und schnell, in C geschrieben, Sie können fast jeden heute verfügbaren Codec dekodieren sowie in einige andere Formate kodieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der einzige Haken ist, dass die Dokumentation meistens fehlt. Es gibt ein Tutorial ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Original befindet sich hier ein Link zu einer bereits nicht vorhandenen Webseite - Notizübersetzer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), das die Grundlagen von FFmpeg und die automatische Erzeugung von Sauerstoffdocks behandelt. Und nichts weiter. Aus diesem Grund habe ich mich entschlossen, unabhängig herauszufinden, wie FFmpeg zum Erstellen funktionierender digitaler Video- und Audioanwendungen verwendet werden kann, und gleichzeitig den Prozess zu dokumentieren und in Form eines Lehrbuchs darzustellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt ein FFplay-Programm, das mit FFmpeg geliefert wird. Es ist einfach, in C geschrieben, implementiert einen vollwertigen Videoplayer mit FFmpeg. Meine erste Lektion ist eine aktualisierte Version der Originalstunde von Martin Böhme ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Original ein Link zu einer bereits nicht mehr existierenden Webseite - eine Anmerkung des Übersetzers</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - ich habe einige Teile von dort gezogen. Außerdem werde ich in einer Reihe meiner Lektionen den Prozess der Erstellung eines funktionierenden Videoplayers auf der Basis von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ffplay.c zeigen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fabrice Bellard. In jeder Lektion wird eine neue Idee (oder sogar zwei) mit einer Erläuterung ihrer Umsetzung vorgestellt. Jedes Kapitel enthält eine C-Liste, die Sie selbst kompilieren und ausführen können. Die Quelldateien zeigen, wie dieses Programm funktioniert, wie seine einzelnen Teile funktionieren und zeigen kleinere technische Details, die in diesem Handbuch nicht behandelt werden. Wenn wir fertig sind, haben wir einen funktionierenden Videoplayer, der in weniger als 1000 Codezeilen geschrieben ist!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Erstellen des Players verwenden wir SDL, um Audio- und Videomediendateien auszugeben. SDL ist eine hervorragende plattformübergreifende Multimedia-Bibliothek, die in MPEG-Wiedergabeprogrammen, Emulatoren und vielen Videospielen verwendet wird. Sie müssen die SDL-Bibliotheken herunterladen und auf Ihrem System installieren, um die Programme aus diesem Handbuch zu kompilieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Tutorial richtet sich an Personen mit guter Programmiererfahrung. Zumindest müssen Sie C kennen und Konzepte wie Warteschlangen, Mutexe usw. verstehen. Es sollte ein gewisses Verständnis für Multimedia geben. Zum Beispiel Dinge wie Wellenformen und dergleichen. Es ist jedoch nicht notwendig, in diesen Angelegenheiten ein Guru zu sein, da viele Konzepte im Verlauf des Unterrichts erklärt werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte senden Sie mir Fehlermeldungen, Fragen, Kommentare, Ideen, Funktionen usw. an Dranger Doggy Gmail dot Com.</font></font><a name="screencaps"></a><br>
<br>
<hr><hr><hr><hr><hr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img align="right" width="420" height="125" src="https://habrastorage.org/webt/co/i3/m0/coi3m0tliby9r5uxtiydjoeaqkm.png"></a><br clear="left">
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie auch im Blog der </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Firma EDISON:</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFmpeg libav Handbuch</font></font></b></a><br>
<hr><hr><hr><hr><hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lektion 1: Erstellen von Screencaps </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Vorwort"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Zum Inhaltsverzeichnis"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Lektion 2: Anzeigen"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollständige Auflistung: tutorial01.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial01.c</span>
<span class="hljs-comment">// Code based on a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101 </span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span><font></font>
<font></font>
<span class="hljs-comment">// A small sample program that shows how to use libavformat and libavcodec to</span>
<span class="hljs-comment">// read video from a file.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial01 tutorial01.c -lavformat -lavcodec -lswscale -lz</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed</span>
<span class="hljs-comment">// your system).</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// tutorial01 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to write the first five frames from "myvideofile.mpg" to disk in PPM</span>
<span class="hljs-comment">// format.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SaveFrame</span><span class="hljs-params">(AVFrame *pFrame, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> iFrame)</span> </span>{<font></font>
  FILE *pFile;<font></font>
  <span class="hljs-keyword">char</span> szFilename[<span class="hljs-number">32</span>];
  <span class="hljs-keyword">int</span>  y;<font></font>
  <font></font>
  <span class="hljs-comment">// Open file</span>
  <span class="hljs-built_in">sprintf</span>(szFilename, <span class="hljs-string">"frame%d.ppm"</span>, iFrame);<font></font>
  pFile=fopen(szFilename, <span class="hljs-string">"wb"</span>);
  <span class="hljs-keyword">if</span>(pFile==<span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span>;<font></font>
  <font></font>
  <span class="hljs-comment">// Write header</span>
  <span class="hljs-built_in">fprintf</span>(pFile, <span class="hljs-string">"P6\n%d %d\n255\n"</span>, width, height);<font></font>
  <font></font>
  <span class="hljs-comment">// Write pixel data</span>
  <span class="hljs-keyword">for</span>(y=<span class="hljs-number">0</span>; y&lt;height; y++)<font></font>
    fwrite(pFrame-&gt;data[<span class="hljs-number">0</span>]+y*pFrame-&gt;linesize[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, width*<span class="hljs-number">3</span>, pFile);<font></font>
  <font></font>
  <span class="hljs-comment">// Close file</span><font></font>
  fclose(pFile);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{
  <span class="hljs-comment">// Initalizing these to NULL prevents segfaults!</span>
  AVFormatContext   *pFormatCtx = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">int</span>               i, videoStream;<font></font>
  AVCodecContext    *pCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodecContext    *pCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec           *pCodec = <span class="hljs-literal">NULL</span>;<font></font>
  AVFrame           *pFrame = <span class="hljs-literal">NULL</span>;<font></font>
  AVFrame           *pFrameRGB = <span class="hljs-literal">NULL</span>;<font></font>
  AVPacket          packet;<font></font>
  <span class="hljs-keyword">int</span>               frameFinished;
  <span class="hljs-keyword">int</span>               numBytes;
  <span class="hljs-keyword">uint8_t</span>           *buffer = <span class="hljs-literal">NULL</span>;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please provide a movie file\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span>
  videoStream=<span class="hljs-number">-1</span>;
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++)
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO) {<font></font>
      videoStream=i;<font></font>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  <span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span><font></font>
  <font></font>
  <span class="hljs-comment">// Get a pointer to the codec context for the video stream</span><font></font>
  pCodecCtxOrig=pFormatCtx-&gt;streams[videoStream]-&gt;codec;<font></font>
  <span class="hljs-comment">// Find the decoder for the video stream</span><font></font>
  pCodec=avcodec_find_decoder(pCodecCtxOrig-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(pCodec==<span class="hljs-literal">NULL</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Codec not found</span><font></font>
  }<font></font>
  <span class="hljs-comment">// Copy context</span><font></font>
  pCodecCtx = avcodec_alloc_context3(pCodec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(pCodecCtx, pCodecCtxOrig) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open codec</span>
  <span class="hljs-keyword">if</span>(avcodec_open2(pCodecCtx, pCodec, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Could not open codec</span><font></font>
  <font></font>
  <span class="hljs-comment">// Allocate video frame</span><font></font>
  pFrame=av_frame_alloc();<font></font>
  <font></font>
  <span class="hljs-comment">// Allocate an AVFrame structure</span><font></font>
  pFrameRGB=av_frame_alloc();<font></font>
  <span class="hljs-keyword">if</span>(pFrameRGB==<span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// Determine required buffer size and allocate buffer</span><font></font>
  numBytes=avpicture_get_size(PIX_FMT_RGB24, pCodecCtx-&gt;width,<font></font>
			      pCodecCtx-&gt;height);<font></font>
  buffer=(<span class="hljs-keyword">uint8_t</span> *)av_malloc(numBytes*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint8_t</span>));<font></font>
  <font></font>
  <span class="hljs-comment">// Assign appropriate parts of buffer to image planes in pFrameRGB</span>
  <span class="hljs-comment">// Note that pFrameRGB is an AVFrame, but AVFrame is a superset</span>
  <span class="hljs-comment">// of AVPicture</span><font></font>
  avpicture_fill((AVPicture *)pFrameRGB, buffer, PIX_FMT_RGB24,<font></font>
		 pCodecCtx-&gt;width, pCodecCtx-&gt;height);<font></font>
  <font></font>
  <span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
  sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   pCodecCtx-&gt;pix_fmt,<font></font>
			   pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   PIX_FMT_RGB24,<font></font>
			   SWS_BILINEAR,<font></font>
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span><font></font>
			   );<font></font>
<font></font>
  <span class="hljs-comment">// Read frames and save first five frames to disk</span>
  i=<span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
      <span class="hljs-comment">// Decode video frame</span><font></font>
      avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);<font></font>
      <font></font>
      <span class="hljs-comment">// Did we get a video frame?</span>
      <span class="hljs-keyword">if</span>(frameFinished) {
	<span class="hljs-comment">// Convert the image from its native format to RGB</span>
	sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
		  pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
		  pFrameRGB-&gt;data, pFrameRGB-&gt;linesize);<font></font>
	<font></font>
	<span class="hljs-comment">// Save the frame to disk</span>
	<span class="hljs-keyword">if</span>(++i&lt;=<span class="hljs-number">5</span>)<font></font>
	  SaveFrame(pFrameRGB, pCodecCtx-&gt;width, pCodecCtx-&gt;height, <font></font>
		    i);<font></font>
      }<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// Free the packet that was allocated by av_read_frame</span><font></font>
    av_free_packet(&amp;packet);<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-comment">// Free the RGB image</span><font></font>
  av_free(buffer);<font></font>
  av_frame_free(&amp;pFrameRGB);<font></font>
  <font></font>
  <span class="hljs-comment">// Free the YUV frame</span><font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the codecs</span><font></font>
  avcodec_close(pCodecCtx);<font></font>
  avcodec_close(pCodecCtxOrig);<font></font>
<font></font>
  <span class="hljs-comment">// Close the video file</span><font></font>
  avformat_close_input(&amp;pFormatCtx);<font></font>
  <font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überblick</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Filmdateien bestehen aus mehreren Hauptkomponenten. Zunächst wird die Datei selbst als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Container bezeichnet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und der Containertyp bestimmt, wie Daten in der Datei dargestellt werden. Beispiele für Container sind </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVI</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quicktime</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Darüber hinaus enthält die Datei mehrere Threads. Insbesondere gibt es normalerweise einen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Audiostream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und einen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Videostream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . ("Stream" ist ein lustiges Wort für "eine Folge von Datenelementen, die gemäß der Zeitachse verfügbar sind".) Datenelemente in einem Stream werden als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frames bezeichnet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jeder Stream wird von dem einen oder anderen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codec-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Typ codiert </font><font style="vertical-align: inherit;">. Der Codec bestimmt, wie die tatsächlichen Daten </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diruyutsya und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dezember</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geprüft - daher der Name des Codecs. </font><font style="vertical-align: inherit;">Beispiele für Codecs sind DivX und MP3. </font><font style="vertical-align: inherit;">Pakete werden dann aus dem Stream gelesen. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pakete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind </font><b><font style="vertical-align: inherit;">Datenstücke</font></b><font style="vertical-align: inherit;"> , die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenbits</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enthalten </font><b><font style="vertical-align: inherit;">können</font></b><font style="vertical-align: inherit;"> , die in Rohrahmen dekodiert werden, die wir schließlich in unserer Anwendung bearbeiten können. </font><font style="vertical-align: inherit;">Für unsere Zwecke enthält jedes Paket Vollbilder (oder mehrere Bilder, wenn es sich um Audio handelt). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Arbeiten mit Video- und Audiostreams ist selbst auf der einfachsten Ebene sehr einfach:</font></font><br>
<br>
<pre><code class="vbscript hljs"><span class="hljs-number">10</span> OPEN video_stream FROM video.avi
<span class="hljs-number">20</span> READ packet FROM video_stream INTO frame
<span class="hljs-number">30</span> <span class="hljs-keyword">IF</span> frame <span class="hljs-keyword">NOT</span> COMPLETE <span class="hljs-keyword">GOTO</span> <span class="hljs-number">20</span>
<span class="hljs-number">40</span> <span class="hljs-keyword">DO</span> SOMETHING <span class="hljs-keyword">WITH</span> frame
<span class="hljs-number">50</span> <span class="hljs-keyword">GOTO</span> <span class="hljs-number">20</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Arbeiten mit Multimedia mit FFmpeg ist fast so einfach wie in diesem Programm, obwohl in einigen Programmen der Schritt "MAKE [...]" sehr schwierig sein kann. </font><font style="vertical-align: inherit;">In diesem Tutorial öffnen wir die Datei, zählen den darin enthaltenen Videostream und unser "MAKE [...]" schreibt den Frame in die PPM-Datei.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datei öffnen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns zuerst sehen, was zuerst passiert, wenn Sie die Datei öffnen. </font><font style="vertical-align: inherit;">Mit FFmpeg initialisieren wir zuerst die gewünschte Bibliothek:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ffmpeg/swscale.h&gt;</span></span><font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, charg *argv[])</span> </span>{<font></font>
av_register_all();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dadurch werden alle verfügbaren Dateiformate und Codecs in der Bibliothek registriert, sodass sie beim Öffnen einer Datei mit dem entsprechenden Format / Codec automatisch verwendet werden. </font><font style="vertical-align: inherit;">Beachten Sie, dass Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_register_all</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () nur einmal </font><font style="vertical-align: inherit;">aufrufen </font><b><font style="vertical-align: inherit;">müssen</font></b><font style="vertical-align: inherit;"> , daher tun wir dies hier in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (). </font><font style="vertical-align: inherit;">Wenn Sie möchten, können Sie nur ausgewählte Dateiformate und Codecs registrieren. In der Regel gibt es jedoch keinen besonderen Grund dafür. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Öffnen Sie nun die Datei:</font></font><br>
<br>
<pre><code class="cpp hljs">AVFormatContext *pFormatCtx = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
<span class="hljs-comment">// Open video file</span>
<span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Holen Sie sich den Dateinamen aus dem ersten Argument. </font><font style="vertical-align: inherit;">Diese Funktion liest den Dateikopf und speichert die Dateiformatinformationen in der von </font><font style="vertical-align: inherit;">uns übergebenen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVFormatContext-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die letzten drei Argumente werden verwendet, um das Dateiformat, die Puffergröße und die Formatparameter anzugeben. </font><font style="vertical-align: inherit;">Wenn Sie sie auf NULL oder 0 setzen, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erkennt libavformat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alles automatisch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktion betrachtet nur den Header, daher müssen wir jetzt die Stream-Informationen in der Datei überprüfen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Retrieve stream information</span>
<span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktion übergibt </font><font style="vertical-align: inherit;">gültige Daten </font><font style="vertical-align: inherit;">an </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pFormatCtx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streams</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wir lernen eine praktische Debugging-Funktion kennen, die uns zeigt, was drin ist:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Dump information about file onto standard error</span>
av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt ist </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pFormatCtx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streams</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nur ein Array von Zeigern der Größe </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pFormatCtx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nb_streams</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wir werden es durchgehen, bis wir den Videostream finden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> i;<font></font>
AVCodecContext *pCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
AVCodecContext *pCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
<span class="hljs-comment">// Find the first video stream</span>
videoStream=<span class="hljs-number">-1</span>;
<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++)
  <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO) {<font></font>
    videoStream=i;<font></font>
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
<span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span><font></font>
<font></font>
<span class="hljs-comment">// Get a pointer to the codec context for the video stream</span>
pCodecCtx=pFormatCtx-&gt;streams[videoStream]-&gt;codec;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Informationen zum Codec im Stream befinden sich an einem Ort, der als " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codec-Kontext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " bezeichnet wird. </font><font style="vertical-align: inherit;">Es enthält alle Informationen über den Codec, den der Stream verwendet, und jetzt haben wir einen Zeiger darauf. </font><font style="vertical-align: inherit;">Aber wir müssen noch den richtigen Codec finden und öffnen:</font></font><br>
<br>
<pre><code class="cpp hljs">AVCodec *pCodec = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
<span class="hljs-comment">// Find the decoder for the video stream</span><font></font>
pCodec=avcodec_find_decoder(pCodecCtx-&gt;codec_id);<font></font>
<span class="hljs-keyword">if</span>(pCodec==<span class="hljs-literal">NULL</span>) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Codec not found</span><font></font>
}<font></font>
<span class="hljs-comment">// Copy context</span><font></font>
pCodecCtx = avcodec_alloc_context3(pCodec);<font></font>
<span class="hljs-keyword">if</span>(avcodec_copy_context(pCodecCtx, pCodecCtxOrig) != <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
}<font></font>
<span class="hljs-comment">// Open codec</span>
<span class="hljs-keyword">if</span>(avcodec_open2(pCodecCtx, pCodec)&lt;<span class="hljs-number">0</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Could not open codec</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVCodecContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht direkt </font><font style="vertical-align: inherit;">aus dem Videostream verwenden können! </font><font style="vertical-align: inherit;">Daher müssen Sie einen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vcodec_copy_context</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () verwenden, um den Kontext an einen neuen Speicherort zu kopieren (natürlich nachdem Speicher dafür zugewiesen wurde).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenspeicher</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt brauchen wir einen Platz zum Aufbewahren des Rahmens:</font></font><br>
<br>
<pre><code class="cpp hljs">AVFrame *pFrame = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
<span class="hljs-comment">// Allocate video frame</span>
pFrame=av_frame_alloc();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da wir PPM-Dateien ausgeben möchten, die in 24-Bit-RGB gespeichert sind, müssen wir unseren Frame von seinem eigenen Format in RGB konvertieren. </font><font style="vertical-align: inherit;">FFmpeg wird es für uns tun. </font><font style="vertical-align: inherit;">Für die meisten Projekte (einschließlich dieses) müssen Sie den Startrahmen in ein bestimmtes Format konvertieren. </font><font style="vertical-align: inherit;">Wählen Sie einen Frame für den konvertierten Frame aus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Allocate an AVFrame structure</span><font></font>
pFrameRGB=av_frame_alloc();<font></font>
<span class="hljs-keyword">if</span>(pFrameRGB==<span class="hljs-literal">NULL</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Tatsache, dass wir den Frame ausgewählt haben, benötigen wir beim Konvertieren noch einen Platz, an dem die Rohdaten untergebracht werden können. </font><font style="vertical-align: inherit;">Wir verwenden </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avpicture_get_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die richtigen Größen zu erhalten und den erforderlichen Speicherplatz manuell zuzuweisen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint8_t</span> *buffer = <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">int</span> numBytes;
<span class="hljs-comment">// Determine required buffer size and allocate buffer</span><font></font>
numBytes=avpicture_get_size(PIX_FMT_RGB24, pCodecCtx-&gt;width,<font></font>
                            pCodecCtx-&gt;height);<font></font>
buffer=(<span class="hljs-keyword">uint8_t</span> *)av_malloc(numBytes*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint8_t</span>));</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_malloc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein Analogon der C-Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von FFmpeg, einem einfachen Wrapper um </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der die Ausrichtung von Speicheradressen usw. ermöglicht. </font><font style="vertical-align: inherit;">Dies schützt übrigens nicht vor Speicherlecks, doppelter Freigabe oder anderen Problemen, die bei </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc auftreten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt verwenden wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avpicture_fill,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um den Frame unserem neu zugewiesenen Puffer zuzuordnen. </font><font style="vertical-align: inherit;">In Bezug auf </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPicture-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur </font><font style="vertical-align: inherit;">ist eine Teilmenge der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVFrame-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur </font><font style="vertical-align: inherit;">- der Anfang der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVFrame-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur </font><b><font style="vertical-align: inherit;">ist</font></b><font style="vertical-align: inherit;"> identisch mit der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPicture-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Assign appropriate parts of buffer to image planes in pFrameRGB</span>
<span class="hljs-comment">// Note that pFrameRGB is an AVFrame, but AVFrame is a superset</span>
<span class="hljs-comment">// of AVPicture</span><font></font>
avpicture_fill((AVPicture *)pFrameRGB, buffer, PIX_FMT_RGB24,<font></font>
                pCodecCtx-&gt;width, pCodecCtx-&gt;height);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sind schon am Ziel! </font><font style="vertical-align: inherit;">Jetzt können wir aus dem Stream lesen!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daten lesen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um nun den gesamten Videostream zu lesen, lesen wir das nächste Paket, entschlüsseln es in unserem Frame. Sobald die Entschlüsselung abgeschlossen ist, konvertieren wir den Frame und speichern ihn:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span>
<span class="hljs-keyword">int</span> frameFinished;<font></font>
AVPacket packet;<font></font>
<span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
    pCodecCtx-&gt;height,<font></font>
    pCodecCtx-&gt;pix_fmt,<font></font>
    pCodecCtx-&gt;width,<font></font>
    pCodecCtx-&gt;height,<font></font>
    PIX_FMT_RGB24,<font></font>
    SWS_BILINEAR,<font></font>
    <span class="hljs-literal">NULL</span>,
    <span class="hljs-literal">NULL</span>,
    <span class="hljs-literal">NULL</span><font></font>
    );<font></font>
<font></font>
i=<span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
  <span class="hljs-comment">// Is this a packet from the video stream?</span>
  <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
	<span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);<font></font>
    <font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {
    <span class="hljs-comment">// Convert the image from its native format to RGB</span>
        sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
		  pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
		  pFrameRGB-&gt;data, pFrameRGB-&gt;linesize);<font></font>
	<font></font>
        <span class="hljs-comment">// Save the frame to disk</span>
        <span class="hljs-keyword">if</span>(++i&lt;=<span class="hljs-number">5</span>)<font></font>
          SaveFrame(pFrameRGB, pCodecCtx-&gt;width, <font></font>
                    pCodecCtx-&gt;height, i);<font></font>
    }<font></font>
  }<font></font>
    <font></font>
  <span class="hljs-comment">// Free the packet that was allocated by av_read_frame</span><font></font>
  av_free_packet(&amp;packet);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nichts kompliziertes: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_read_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () liest das Paket und speichert es in der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacket-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur </font><font style="vertical-align: inherit;">. Bitte beachten Sie, dass wir nur die Struktur des Pakets verteilen - FFmpeg liefert uns die internen Daten, auf die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packet.data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verweist </font><font style="vertical-align: inherit;">. Dies gibt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_free_packet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () </font><font style="vertical-align: inherit;">etwas später frei </font><font style="vertical-align: inherit;">. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () konvertiert das Paket in einen Frame. Möglicherweise verfügen wir jedoch nicht über alle Informationen, die wir nach dem Decodieren des Pakets für den Frame benötigen. Daher setzt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frameFinished,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wenn wir den nächsten Frame haben. Schließlich verwenden wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sws_scale</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (), um aus unserem eigenen Format ( </font><nobr><b><font style="vertical-align: inherit;">pCodecCtx</font></b></nobr><nobr><font style="vertical-align: inherit;"> -&gt;</font></nobr><font style="vertical-align: inherit;"> ) zu konvertieren</font></font><nobr><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pix_fmt</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) in RGB. Denken Sie daran, dass Sie einen</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AVFrame-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeiger in einen</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AVPicture-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeiger</font><b><font style="vertical-align: inherit;"> umwandeln können</font></b><font style="vertical-align: inherit;"> . Schließlich übergeben wir die Informationen über den Rahmen, die Höhe und die Breite unserer</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SaveFrame-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion</font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apropos Pakete. Technisch gesehen kann ein Paket nur einen Teil eines Rahmens sowie andere Datenbits enthalten. Der FFmpeg-Parser garantiert jedoch, dass die empfangenen Pakete entweder einen vollständigen Frame oder sogar mehrere Frames enthalten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt müssen Sie nur noch die</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SaveFrame-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion verwenden</font><font style="vertical-align: inherit;">, um die RGB-Informationen in eine PPM-Datei zu schreiben. Obwohl wir uns oberflächlich mit dem PPM-Format selbst befassen; Glauben Sie mir, hier funktioniert alles:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SaveFrame</span><span class="hljs-params">(AVFrame *pFrame, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> iFrame)</span> </span>{<font></font>
  FILE *pFile;<font></font>
  <span class="hljs-keyword">char</span> szFilename[<span class="hljs-number">32</span>];
  <span class="hljs-keyword">int</span>  y;<font></font>
  <font></font>
  <span class="hljs-comment">// Open file</span>
  <span class="hljs-built_in">sprintf</span>(szFilename, <span class="hljs-string">"frame%d.ppm"</span>, iFrame);<font></font>
  pFile=fopen(szFilename, <span class="hljs-string">"wb"</span>);
  <span class="hljs-keyword">if</span>(pFile==<span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span>;<font></font>
  <font></font>
  <span class="hljs-comment">// Write header</span>
  <span class="hljs-built_in">fprintf</span>(pFile, <span class="hljs-string">"P6\n%d %d\n255\n"</span>, width, height);<font></font>
  <font></font>
  <span class="hljs-comment">// Write pixel data</span>
  <span class="hljs-keyword">for</span>(y=<span class="hljs-number">0</span>; y&lt;height; y++)<font></font>
    fwrite(pFrame-&gt;data[<span class="hljs-number">0</span>]+y*pFrame-&gt;linesize[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, width*<span class="hljs-number">3</span>, pFile);<font></font>
  <font></font>
  <span class="hljs-comment">// Close file</span><font></font>
  fclose(pFile);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir führen ein Öffnen einer Standarddatei usw. durch und zeichnen dann die RGB-Daten auf. Die Datei wird Zeile für Zeile geschrieben. Eine PPM-Datei ist einfach eine Datei, in der RGB-Informationen als lange Zeile dargestellt werden. Wenn Sie die Farben von HTML kennen, ist dies so, als würden Sie die Farben jedes Pixels vom ersten bis zum letzten Ende markieren, etwa </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"># ff0000 # ff0000 ....</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wie bei einem roten Bildschirm. (Tatsächlich wird es im Binärformat und ohne Trennzeichen gespeichert, aber ich hoffe, Sie verstehen die Idee.) Der Titel gibt an, wie breit und hoch das Bild ist, sowie die maximale Größe der RGB-Werte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun zurück zu unserer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () </font><font style="vertical-align: inherit;">Funktion </font><font style="vertical-align: inherit;">. Sobald wir mit dem Lesen aus dem Videostream fertig sind, müssen wir nur noch alles löschen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Free the RGB image</span><font></font>
av_free(buffer);<font></font>
av_free(pFrameRGB);<font></font>
<font></font>
<span class="hljs-comment">// Free the YUV frame</span><font></font>
av_free(pFrame);<font></font>
<font></font>
<span class="hljs-comment">// Close the codecs</span><font></font>
avcodec_close(pCodecCtx);<font></font>
avcodec_close(pCodecCtxOrig);<font></font>
<font></font>
<span class="hljs-comment">// Close the video file</span><font></font>
avformat_close_input(&amp;pFormatCtx);<font></font>
<font></font>
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, verwenden wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_free</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für den mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcode_alloc_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_malloc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zugewiesenen </font><b><font style="vertical-align: inherit;">Speicher</font></b><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist der ganze Code! </font><font style="vertical-align: inherit;">Wenn Sie nun Linux oder eine ähnliche Plattform verwenden, führen Sie Folgendes aus:</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial01 tutorial01.c -lavutil -lavformat -lavcodec -lz -lavutil -lm</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie eine ältere Version von FFmpeg haben, müssen Sie möglicherweise </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-lavutil</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entfernen </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial01 tutorial01.c -lavformat -lavcodec -lz -lm</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die meisten Grafikprogramme müssen das PPM-Format öffnen. </font><font style="vertical-align: inherit;">Schauen Sie sich einige Filmdateien an, deren Screencaps mit unserem Programm erstellt wurden.</font></font><a name="outputting"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lektion 2: Anzeigen des Bildschirms </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Lektion 1: Screencaps erstellen"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Zum Inhaltsverzeichnis"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Lektion 3: Sound abspielen"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollständige Auflistung: tutorial02.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial02.c</span>
<span class="hljs-comment">// A pedagogical video player that will stream through every video frame as fast as it can.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// gcc -o tutorial02 tutorial02.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial02 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
  AVFormatContext *pFormatCtx = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">int</span>             i, videoStream;<font></font>
  AVCodecContext  *pCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodecContext  *pCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec         *pCodec = <span class="hljs-literal">NULL</span>;<font></font>
  AVFrame         *pFrame = <span class="hljs-literal">NULL</span>;<font></font>
  AVPacket        packet;<font></font>
  <span class="hljs-keyword">int</span>             frameFinished;
  <span class="hljs-keyword">float</span>           aspect_ratio;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span><font></font>
<font></font>
  SDL_Overlay     *bmp;<font></font>
  SDL_Surface     *screen;<font></font>
  SDL_Rect        rect;<font></font>
  SDL_Event       event;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span>
  videoStream=<span class="hljs-number">-1</span>;
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++)
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO) {<font></font>
      videoStream=i;<font></font>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  <span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span><font></font>
  <font></font>
  <span class="hljs-comment">// Get a pointer to the codec context for the video stream</span><font></font>
  pCodecCtxOrig=pFormatCtx-&gt;streams[videoStream]-&gt;codec;<font></font>
  <span class="hljs-comment">// Find the decoder for the video stream</span><font></font>
  pCodec=avcodec_find_decoder(pCodecCtxOrig-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(pCodec==<span class="hljs-literal">NULL</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Codec not found</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Copy context</span><font></font>
  pCodecCtx = avcodec_alloc_context3(pCodec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(pCodecCtx, pCodecCtxOrig) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open codec</span>
  <span class="hljs-keyword">if</span>(avcodec_open2(pCodecCtx, pCodec, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Could not open codec</span><font></font>
  <font></font>
  <span class="hljs-comment">// Allocate video frame</span><font></font>
  pFrame=av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  bmp = SDL_CreateYUVOverlay(pCodecCtx-&gt;width,<font></font>
				 pCodecCtx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
<font></font>
  <span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
  sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   pCodecCtx-&gt;pix_fmt,<font></font>
			   pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   PIX_FMT_YUV420P,<font></font>
			   SWS_BILINEAR,<font></font>
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span><font></font>
			   );<font></font>
<font></font>
<font></font>
<font></font>
  <span class="hljs-comment">// Read frames and save first five frames to disk</span>
  i=<span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
      <span class="hljs-comment">// Decode video frame</span><font></font>
      avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);<font></font>
      <font></font>
      <span class="hljs-comment">// Did we get a video frame?</span>
      <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
	SDL_LockYUVOverlay(bmp);<font></font>
<font></font>
	AVPicture pict;<font></font>
	pict.data[<span class="hljs-number">0</span>] = bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
	pict.data[<span class="hljs-number">1</span>] = bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
	pict.data[<span class="hljs-number">2</span>] = bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
<font></font>
	pict.linesize[<span class="hljs-number">0</span>] = bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
	pict.linesize[<span class="hljs-number">1</span>] = bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
	pict.linesize[<span class="hljs-number">2</span>] = bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
<font></font>
	<span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
	sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
		  pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
		  pict.data, pict.linesize);<font></font>
<font></font>
	SDL_UnlockYUVOverlay(bmp);<font></font>
	<font></font>
	rect.x = <span class="hljs-number">0</span>;<font></font>
	rect.y = <span class="hljs-number">0</span>;<font></font>
	rect.w = pCodecCtx-&gt;width;<font></font>
	rect.h = pCodecCtx-&gt;height;<font></font>
	SDL_DisplayYUVOverlay(bmp, &amp;rect);<font></font>
      <font></font>
      }<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// Free the packet that was allocated by av_read_frame</span><font></font>
    av_free_packet(&amp;packet);<font></font>
    SDL_PollEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-comment">// Free the YUV frame</span><font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the codec</span><font></font>
  avcodec_close(pCodecCtx);<font></font>
  avcodec_close(pCodecCtxOrig);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the video file</span><font></font>
  avformat_close_input(&amp;pFormatCtx);<font></font>
  <font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL und Video</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Zeichnen auf dem Bildschirm verwenden wir SDL. SDL steht für </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simple Direct Layer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es ist eine hervorragende plattformübergreifende Multimedia-Bibliothek, die in vielen Projekten verwendet wird. Sie können die Bibliothek auf der offiziellen Website herunterladen oder gegebenenfalls das Entwicklerpaket für Ihr Betriebssystem herunterladen. Sie benötigen Bibliotheken, um den Code aus dieser Lektion zu kompilieren (alle anderen Lektionen gelten übrigens auch). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL bietet viele Methoden zum Zeichnen auf dem Bildschirm. Eine Möglichkeit, Filme anzuzeigen, ist das sogenannte </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV-Overlay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formal nicht einmal YUV, sondern </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YCbCr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Einige Leute werden übrigens sehr verbrannt, wenn "YCbCr" als "YUV" bezeichnet wird. Im Allgemeinen ist YUV ein analoges Format und YCbCr ist ein digitales Format. FFmpeg und SDL bezeichnen in ihrem Code und in Makros YCbCr als YUV, aber das ist. </font></font></i><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine Methode zum Speichern von Rohbilddaten wie RGB. Grob gesagt ist </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Komponente der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Helligkeit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind Komponenten der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbe</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (Dies ist komplizierter als RGB, da ein Teil der Farbinformationen verworfen wird und Sie nur 1 Messung von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für jeweils 2 Messungen von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y durchführen können.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV-Overlay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in SDL akzeptiert einen rohen YUV-Datensatz und zeigt ihn an. Es werden 4 verschiedene Arten von YUV-Formaten akzeptiert, aber </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YV12</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist das schnellste davon. Es gibt ein anderes YUV-Format namens </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das mit YV12 übereinstimmt, außer dass die Arrays von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vertauscht werden. 420 bedeutet, dass es in einem Verhältnis von 4: 2: 0 abgetastet wird, dh für jeweils 4 Helligkeitsmessungen gibt es 1 Farbmessung, sodass die Farbinformationen in Vierteln verteilt werden. Dies ist ein guter Weg, um Bandbreite zu sparen, da das menschliche Auge diese Änderungen immer noch nicht bemerkt. Der lateinische Buchstabe "P" im Namen zeigt an, dass das Format "planar" ist, was einfach bedeutet, dass die Komponenten </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind.</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> befinden sich in getrennten Arrays. </font><font style="vertical-align: inherit;">FFmpeg kann Bilder in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> konvertieren </font><font style="vertical-align: inherit;">, was sehr hilfreich ist, da viele Videostreams bereits in diesem Format gespeichert sind oder einfach in dieses konvertiert werden können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher ist es derzeit geplant, die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SaveFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () aus der vorherigen Lektion </font><font style="vertical-align: inherit;">zu ersetzen </font><font style="vertical-align: inherit;">und stattdessen unseren Frame anzuzeigen. </font><font style="vertical-align: inherit;">Zunächst müssen Sie sich jedoch mit den Grundfunktionen der SDL-Bibliothek vertraut machen. </font><font style="vertical-align: inherit;">Verbinden Sie zunächst die Bibliotheken und initialisieren Sie die SDL:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_Init</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () teilt der Bibliothek im Wesentlichen mit, welche Funktionen wir verwenden werden. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_GetError</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (), dies ist natürlich unsere praktische Funktion zum Debuggen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anzeigeerstellung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt brauchen wir einen Platz auf dem Bildschirm, um die Elemente anzuordnen. </font><font style="vertical-align: inherit;">Der Hauptbereich für die Anzeige von Bildern mit SDL wird als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oberfläche bezeichnet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Surface *screen;<font></font>
<font></font>
screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-keyword">if</span>(!screen) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also haben wir einen Bildschirm mit einer bestimmten Breite und Höhe eingerichtet. </font><font style="vertical-align: inherit;">Die nächste Option ist die Bittiefe des Bildschirms - 0 - dies ist ein spezieller Wert, der "dasselbe wie die aktuelle Anzeige" bedeutet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt erstellen wir ein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV-Overlay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf diesem Bildschirm, damit wir Videos darauf ausgeben können, und konfigurieren unseren </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SWSContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> so, dass Bilddaten in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420 konvertiert werden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Overlay     *bmp = <span class="hljs-literal">NULL</span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SWSContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span><font></font>
<font></font>
bmp = SDL_CreateYUVOverlay(pCodecCtx-&gt;width, pCodecCtx-&gt;height,<font></font>
                           SDL_YV12_OVERLAY, screen);<font></font>
<font></font>
<span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
                         pCodecCtx-&gt;height,<font></font>
			 pCodecCtx-&gt;pix_fmt,<font></font>
			 pCodecCtx-&gt;width,<font></font>
			 pCodecCtx-&gt;height,<font></font>
			 PIX_FMT_YUV420P,<font></font>
			 SWS_BILINEAR,<font></font>
			 <span class="hljs-literal">NULL</span>,
			 <span class="hljs-literal">NULL</span>,
			 <span class="hljs-literal">NULL</span>
			 );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits erwähnt, verwenden wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YV12</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um das Bild anzuzeigen und die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Daten </font><font style="vertical-align: inherit;">von FFmpeg </font><b><font style="vertical-align: inherit;">abzurufen</font></b><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bildschirm</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das war einfach genug! Jetzt müssen wir nur noch das Bild zeigen. Gehen wir den ganzen Weg zu dem Ort, an dem wir den fertigen Schuss hatten. Wir können alles loswerden, was wir für den RGB-Frame hatten, und wir werden </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SaveFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () durch unseren </font><b><font style="vertical-align: inherit;">Anzeigecode</font></b><font style="vertical-align: inherit;"> ersetzen </font><font style="vertical-align: inherit;">. Um das Bild anzuzeigen, erstellen wir eine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPicture-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur </font><font style="vertical-align: inherit;">und legen die Datenzeiger und die </font><b><font style="vertical-align: inherit;">Liniengröße</font></b><font style="vertical-align: inherit;"> für unser </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV-Overlay fest</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
    SDL_LockYUVOverlay(bmp);<font></font>
<font></font>
    AVPicture pict;<font></font>
    pict.data[<span class="hljs-number">0</span>] = bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
<font></font>
    pict.linesize[<span class="hljs-number">0</span>] = bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
<font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(bmp);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst blockieren wir das Overlay, weil wir vorhaben, darauf zu schreiben. Dies ist eine gute Angewohnheit, damit später keine Probleme auftreten. Die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPicture-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur hat </font><font style="vertical-align: inherit;">, wie oben gezeigt, einen Datenzeiger, der ein Array von 4 Zeigern ist. Da es sich hier um den </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420P handelt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , haben wir nur 3 Kanäle und damit nur 3 Datensätze. Andere Formate haben möglicherweise einen vierten Zeiger für den Alphakanal oder etwas anderes. Die Zeilengröße sieht so aus. Ähnliche Strukturen in unserer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV-Überlagerung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind Variablen für Pixel und Höhen. (Tonhöhen, Tonhöhen - wenn in SDL ausgedrückt, um die Breite einer bestimmten </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenzeile</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> anzugeben.) Wir geben also drei </font><b><font style="vertical-align: inherit;">Bilddaten-Arrays</font></b><font style="vertical-align: inherit;"> in unserer Überlagerung an, also wenn wir schreiben</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Bild nehmen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir tatsächlich in unserem Overlay auf, dem natürlich bereits der dafür erforderliche Speicherplatz zugewiesen ist. </font><font style="vertical-align: inherit;">Auf die gleiche Weise erhalten wir Informationen zur Zeilengröße direkt aus unserer Überlagerung. </font><font style="vertical-align: inherit;">Wir ändern das Konvertierungsformat in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PIX_FMT_YUV420P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und verwenden </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sws_scale</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wie zuvor.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bildzeichnung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir müssen jedoch noch die SDL angeben, damit sie wirklich die Daten anzeigt, die wir ihr zur Verfügung gestellt haben. </font><font style="vertical-align: inherit;">Wir übergeben dieser Funktion auch ein Rechteck, das angibt, wohin der Film gehen soll, auf welche Breite und Höhe er skaliert werden soll. </font><font style="vertical-align: inherit;">Daher skaliert die SDL für uns, und dies kann Ihrer GPU helfen, schneller zu skalieren:</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Rect rect;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(frameFinished) {
    <span class="hljs-comment">/* ... code ... */</span>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
              pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(bmp);<font></font>
	rect.x = <span class="hljs-number">0</span>;<font></font>
	rect.y = <span class="hljs-number">0</span>;<font></font>
	rect.w = pCodecCtx-&gt;width;<font></font>
	rect.h = pCodecCtx-&gt;height;<font></font>
	SDL_DisplayYUVOverlay(bmp, &amp;rect);<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt wird unser Video angezeigt! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns eine weitere Funktion von SDL zeigen: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Ereignissystem</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . SDL ist so konfiguriert, dass beim Eingeben oder Bewegen der Maus in der SDL-Anwendung oder beim Senden eines Signals ein Ereignis generiert wird. Ihr Programm prüft dann auf diese Ereignisse, ob es Benutzereingaben verarbeiten soll. Ihr Programm kann auch Ereignisse erstellen, um SDL-Ereignisse an das System zu senden. Dies ist besonders nützlich für die Multithread-Programmierung mit SDL, die wir in Lektion 4 sehen werden. In unserem Programm werden wir Ereignisse unmittelbar nach der Verarbeitung des Pakets überprüfen. Im Moment werden wir das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_QUIT-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ereignis behandeln, </font><b><font style="vertical-align: inherit;">damit</font></b><font style="vertical-align: inherit;"> wir </font><b><font style="vertical-align: inherit;">beenden</font></b><font style="vertical-align: inherit;"> können:</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Event       event;<font></font>
<font></font>
    av_free_packet(&amp;packet);<font></font>
    SDL_PollEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und so leben wir! Wir werden den ganzen alten Müll los und sind bereit zu kompilieren. Wenn Sie Linux oder ähnliches verwenden, können Sie am besten mit den SDL-Bibliotheken kompilieren:</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial02 tutorial02.c -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdl-config</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zeigt einfach die notwendigen Flags an, damit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gcc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die SDL-Bibliotheken korrekt aktiviert. </font><font style="vertical-align: inherit;">Möglicherweise müssen Sie etwas anderes tun, um diese Kompilierung auf Ihrem System durchzuführen. </font><font style="vertical-align: inherit;">Bitte überprüfen Sie die SDL-Dokumentation für Ihr System für jeden Feuerwehrmann. </font><font style="vertical-align: inherit;">Nach dem Kompilieren fortfahren und ausführen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was passiert, wenn Sie dieses Programm ausführen? </font><font style="vertical-align: inherit;">Das Video scheint verrückt zu werden! </font><font style="vertical-align: inherit;">Tatsächlich zeigen wir einfach alle Videobilder so schnell an, wie wir sie aus der Filmdatei extrahieren können. </font><font style="vertical-align: inherit;">Wir haben derzeit nicht den Code, um herauszufinden, wann wir das Video zeigen müssen. </font><font style="vertical-align: inherit;">Am Ende (in Lektion 5) werden wir beginnen, das Video zu synchronisieren. </font><font style="vertical-align: inherit;">Aber im Moment fehlt uns etwas ebenso Wichtiges: der Sound!</font></font><a name="sound"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lektion 3: Sound </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title=" "><font style="vertical-align: inherit;">abspielen </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Lektion 2: Anzeigen"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Zum Inhaltsverzeichnis"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Lektion 4: Mehrere Themen"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollständige Auflistung: tutorial03.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial03.c</span>
<span class="hljs-comment">// A pedagogical video player that will stream through every video frame as fast as it can</span>
<span class="hljs-comment">// and play audio (out of sync).</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial03 tutorial03.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial03 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
PacketQueue audioq;<font></font>
<font></font>
<span class="hljs-keyword">int</span> quit = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(AVCodecContext *aCodecCtx, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">static</span> AVPacket pkt;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> *audio_pkt_data = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> audio_pkt_size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">static</span> AVFrame frame;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(aCodecCtx, &amp;frame, &amp;got_frame, &amp;pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      audio_pkt_data += len1;<font></font>
      audio_pkt_size -= len1;<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       aCodecCtx-&gt;channels,<font></font>
					       frame.nb_samples,<font></font>
					       aCodecCtx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt.data)<font></font>
      av_free_packet(&amp;pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;audioq, &amp;pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    audio_pkt_data = pkt.data;<font></font>
    audio_pkt_size = pkt.size;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  AVCodecContext *aCodecCtx = (AVCodecContext *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;<font></font>
<font></font>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> audio_buf[(MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> audio_buf_size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> audio_buf_index = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(audio_buf_index &gt;= audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(aCodecCtx, audio_buf, <span class="hljs-keyword">sizeof</span>(audio_buf));
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	audio_buf_size = <span class="hljs-number">1024</span>; <span class="hljs-comment">// arbitrary?</span>
	<span class="hljs-built_in">memset</span>(audio_buf, <span class="hljs-number">0</span>, audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_buf_size = audio_size;<font></font>
      }<font></font>
      audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = audio_buf_size - audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)audio_buf + audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
  AVFormatContext *pFormatCtx = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">int</span>             i, videoStream, audioStream;<font></font>
  AVCodecContext  *pCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodecContext  *pCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec         *pCodec = <span class="hljs-literal">NULL</span>;<font></font>
  AVFrame         *pFrame = <span class="hljs-literal">NULL</span>;<font></font>
  AVPacket        packet;<font></font>
  <span class="hljs-keyword">int</span>             frameFinished;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span><font></font>
  <font></font>
  AVCodecContext  *aCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodecContext  *aCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec         *aCodec = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
  SDL_Overlay     *bmp;<font></font>
  SDL_Surface     *screen;<font></font>
  SDL_Rect        rect;<font></font>
  SDL_Event       event;<font></font>
  SDL_AudioSpec   wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<font></font>
    <font></font>
  <span class="hljs-comment">// Find the first video stream</span>
  videoStream=<span class="hljs-number">-1</span>;<font></font>
  audioStream=<span class="hljs-number">-1</span>;
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       videoStream &lt; <span class="hljs-number">0</span>) {<font></font>
      videoStream=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audioStream &lt; <span class="hljs-number">0</span>) {<font></font>
      audioStream=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span>
  <span class="hljs-keyword">if</span>(audioStream==<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
   <font></font>
  aCodecCtxOrig=pFormatCtx-&gt;streams[audioStream]-&gt;codec;<font></font>
  aCodec = avcodec_find_decoder(aCodecCtxOrig-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!aCodec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Copy context</span><font></font>
  aCodecCtx = avcodec_alloc_context3(aCodec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(aCodecCtx, aCodecCtxOrig) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
  wanted_spec.freq = aCodecCtx-&gt;sample_rate;<font></font>
  wanted_spec.format = AUDIO_S16SYS;<font></font>
  wanted_spec.channels = aCodecCtx-&gt;channels;<font></font>
  wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
  wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
  wanted_spec.callback = audio_callback;<font></font>
  wanted_spec.userdata = aCodecCtx;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  avcodec_open2(aCodecCtx, aCodec, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
  <span class="hljs-comment">// audio_st = pFormatCtx-&gt;streams[index]</span><font></font>
  packet_queue_init(&amp;audioq);<font></font>
  SDL_PauseAudio(<span class="hljs-number">0</span>);<font></font>
<font></font>
  <span class="hljs-comment">// Get a pointer to the codec context for the video stream</span><font></font>
  pCodecCtxOrig=pFormatCtx-&gt;streams[videoStream]-&gt;codec;<font></font>
  <font></font>
  <span class="hljs-comment">// Find the decoder for the video stream</span><font></font>
  pCodec=avcodec_find_decoder(pCodecCtxOrig-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(pCodec==<span class="hljs-literal">NULL</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Codec not found</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Copy context</span><font></font>
  pCodecCtx = avcodec_alloc_context3(pCodec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(pCodecCtx, pCodecCtxOrig) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open codec</span>
  <span class="hljs-keyword">if</span>(avcodec_open2(pCodecCtx, pCodec, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Could not open codec</span><font></font>
  <font></font>
  <span class="hljs-comment">// Allocate video frame</span><font></font>
  pFrame=av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  bmp = SDL_CreateYUVOverlay(pCodecCtx-&gt;width,<font></font>
				 pCodecCtx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
<font></font>
  <span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
  sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   pCodecCtx-&gt;pix_fmt,<font></font>
			   pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   PIX_FMT_YUV420P,<font></font>
			   SWS_BILINEAR,<font></font>
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span><font></font>
			   );<font></font>
<font></font>
  <span class="hljs-comment">// Read frames and save first five frames to disk</span>
  i=<span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
      <span class="hljs-comment">// Decode video frame</span><font></font>
      avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);<font></font>
      <font></font>
      <span class="hljs-comment">// Did we get a video frame?</span>
      <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
	SDL_LockYUVOverlay(bmp);<font></font>
<font></font>
	AVPicture pict;<font></font>
	pict.data[<span class="hljs-number">0</span>] = bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
	pict.data[<span class="hljs-number">1</span>] = bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
	pict.data[<span class="hljs-number">2</span>] = bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
<font></font>
	pict.linesize[<span class="hljs-number">0</span>] = bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
	pict.linesize[<span class="hljs-number">1</span>] = bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
	pict.linesize[<span class="hljs-number">2</span>] = bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
<font></font>
	<span class="hljs-comment">// Convert the image into YUV format that SDL uses	</span>
	sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
		  pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
		  pict.data, pict.linesize);<font></font>
	<font></font>
	SDL_UnlockYUVOverlay(bmp);<font></font>
	<font></font>
	rect.x = <span class="hljs-number">0</span>;<font></font>
	rect.y = <span class="hljs-number">0</span>;<font></font>
	rect.w = pCodecCtx-&gt;width;<font></font>
	rect.h = pCodecCtx-&gt;height;<font></font>
	SDL_DisplayYUVOverlay(bmp, &amp;rect);<font></font>
	av_free_packet(&amp;packet);<font></font>
      }<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet.stream_index==audioStream) {<font></font>
      packet_queue_put(&amp;audioq, &amp;packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(&amp;packet);<font></font>
    }<font></font>
    <span class="hljs-comment">// Free the packet that was allocated by av_read_frame</span><font></font>
    SDL_PollEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      quit = <span class="hljs-number">1</span>;<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Free the YUV frame</span><font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the codecs</span><font></font>
  avcodec_close(pCodecCtxOrig);<font></font>
  avcodec_close(pCodecCtx);<font></font>
  avcodec_close(aCodecCtxOrig);<font></font>
  avcodec_close(aCodecCtx);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the video file</span><font></font>
  avformat_close_input(&amp;pFormatCtx);<font></font>
  <font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Audio</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt möchten wir, dass der Sound in der Anwendung abgespielt wird. </font><font style="vertical-align: inherit;">SDL bietet uns auch Methoden zum Abspielen von Sound. </font><font style="vertical-align: inherit;">Mit der Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_OpenAudio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () </font><font style="vertical-align: inherit;">wird </font><font style="vertical-align: inherit;">das Audiogerät selbst geöffnet. </font><font style="vertical-align: inherit;">Als Argumente wird die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_AudioSpec-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur verwendet </font><font style="vertical-align: inherit;">, die alle Informationen zu dem Audio enthält, </font><font style="vertical-align: inherit;">das </font><b><font style="vertical-align: inherit;">abgespielt</font></b><font style="vertical-align: inherit;"> werden </font><font style="vertical-align: inherit;">soll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir zeigen, wie dies konfiguriert wird, erklären wir zunächst, wie der Computer Audio im Allgemeinen verarbeitet. </font><font style="vertical-align: inherit;">Digitales Audio besteht aus einem langen Strom von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Samples</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, von denen jede eine bestimmte Bedeutung einer Schallwelle darstellt. Sounds werden mit einer bestimmten Abtastrate aufgenommen, die lediglich angibt, wie schnell jedes Sample abgespielt wird, und anhand der Anzahl der Samples pro Sekunde gemessen. Die ungefähren Abtastfrequenzen betragen </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22.050</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">44.100</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abtastfrequenzen </font><font style="vertical-align: inherit;">pro Sekunde. </font><nobr><font style="vertical-align: inherit;">Dies</font></nobr><font style="vertical-align: inherit;"> sind die Geschwindigkeiten, die für Radio bzw. CD verwendet werden. Darüber hinaus können die meisten Audiodaten mehr als einen Kanal für Stereo- oder Surround-Sound haben. Wenn sich das Sample beispielsweise in Stereo befindet, werden zwei Samples gleichzeitig ausgegeben. Wenn wir die Daten aus der Filmdatei erhalten, wissen wir nicht, wie viele Samples wir erhalten werden, aber FFmpeg erzeugt keine defekten Samples - dies bedeutet auch, dass das Stereo-Sample nicht getrennt wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Methode zum Abspielen von Audio in SDL ist wie folgt. </font><font style="vertical-align: inherit;">Die Soundparameter sind konfiguriert: Abtastfrequenz, Anzahl der Kanäle usw. </font><font style="vertical-align: inherit;">Stellen Sie außerdem die Rückruffunktion und die Benutzerdaten ein. </font><font style="vertical-align: inherit;">Wenn wir mit der Tonwiedergabe beginnen, ruft die SDL diese Rückruffunktion ständig auf und fordert sie auf, den Audiopuffer mit einer bestimmten Anzahl von Bytes zu füllen. </font><font style="vertical-align: inherit;">Nachdem wir diese Informationen in die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_AudioSpec-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur </font><b><font style="vertical-align: inherit;">eingefügt</font></b><font style="vertical-align: inherit;"> haben </font><font style="vertical-align: inherit;">, rufen wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_OpenAudio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () auf, wodurch das Audiogerät geöffnet und eine weitere </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AudioSpec-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur zurückgegeben wird </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies sind die Eigenschaften, die wir tatsächlich verwenden werden - es gibt keine Garantie dafür, dass wir genau das bekommen, wonach wir gefragt haben!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Audioeinstellung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken Sie vorerst daran, denn wir haben noch keine Informationen zu Audio-Streams! </font><font style="vertical-align: inherit;">Kehren wir zu der Stelle in unserem Code zurück, an der wir den Videostream gefunden haben, und finden Sie heraus, welcher Stream der Audiostream ist:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Find the first video stream</span>
videoStream=<span class="hljs-number">-1</span>;<font></font>
audioStream=<span class="hljs-number">-1</span>;
<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++) {
  <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO<font></font>
     &amp;&amp;<font></font>
       videoStream &lt; <span class="hljs-number">0</span>) {<font></font>
    videoStream=i;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
     audioStream &lt; <span class="hljs-number">0</span>) {<font></font>
    audioStream=i;<font></font>
  }<font></font>
}<font></font>
<span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span>
<span class="hljs-keyword">if</span>(audioStream==<span class="hljs-number">-1</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier können wir alle gewünschten Informationen aus dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVCodecContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus dem Stream </font><b><font style="vertical-align: inherit;">abrufen</font></b><font style="vertical-align: inherit;"> , genau wie wir es mit dem Videostream getan haben:</font></font><br>
<br>
<pre><code class="cpp hljs">AVCodecContext *aCodecCtxOrig;<font></font>
AVCodecContext *aCodecCtx;<font></font>
<font></font>
aCodecCtxOrig=pFormatCtx-&gt;streams[audioStream]-&gt;codec;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich erinnern, müssen wir in früheren Lektionen den Audio-Codec selbst noch öffnen. </font><font style="vertical-align: inherit;">Das ist einfach:</font></font><br>
<br>
<pre><code class="cpp hljs">AVCodec         *aCodec;<font></font>
<font></font>
aCodec = avcodec_find_decoder(aCodecCtx-&gt;codec_id);<font></font>
<span class="hljs-keyword">if</span>(!aCodec) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
}<font></font>
<span class="hljs-comment">// Copy context</span><font></font>
aCodecCtx = avcodec_alloc_context3(aCodec);<font></font>
<span class="hljs-keyword">if</span>(avcodec_copy_context(aCodecCtx, aCodecCtxOrig) != <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
}<font></font>
<span class="hljs-comment">/* set up SDL Audio here */</span><font></font>
<font></font>
avcodec_open2(aCodecCtx, aCodec, <span class="hljs-literal">NULL</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Kontext des Codecs enthält alle Informationen, die zur Konfiguration unseres Audios erforderlich sind:</font></font><br>
<br>
<pre><code class="cpp hljs">wanted_spec.freq = aCodecCtx-&gt;sample_rate;<font></font>
wanted_spec.format = AUDIO_S16SYS;<font></font>
wanted_spec.channels = aCodecCtx-&gt;channels;<font></font>
wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
wanted_spec.callback = audio_callback;<font></font>
wanted_spec.userdata = aCodecCtx;<font></font>
<font></font>
<span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns jeden Punkt durchgehen:</font></font><br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frequenz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Frequenz): Abtastrate, wie zuvor erläutert.</font></font></li>
<li><b>format</b> ():  SDL ,      . «<b>S</b>»  «<b>S16SYS</b>»  «», <b>16</b> ,      16 ,  «<b>SYS</b>» ,       ,    .  ,   <b>avcodec_decode_audio2</b>   .</li>
<li><b>channels</b> ():  .</li>
<li><b>silence</b> ():  ,  .   0.</li>
<li><b>samples</b> ():    ,    ,  SDL  ,     .    -  512  8192; FFplay,  ,  1024.</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rückruf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Rückruf): Hier übergeben wir die eigentliche Rückruffunktion. </font><font style="vertical-align: inherit;">Wir werden später mehr über die Rückruffunktion sprechen.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benutzerdaten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die SDL gibt unserem Rückruf einen Nullzeiger auf alle gewünschten Benutzerdaten. </font><font style="vertical-align: inherit;">Wir möchten ihn über unseren Codec-Kontext informieren. </font><font style="vertical-align: inherit;">etwas tiefer wird klar sein warum.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Öffnen Sie zum Schluss das Audio mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_OpenAudio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warteschlangen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und es ist notwendig! Jetzt können wir Audioinformationen aus dem Stream extrahieren. Aber was tun mit diesen Informationen? Wir werden kontinuierlich Pakete aus der Filmdatei empfangen, aber gleichzeitig ruft die SDL die Rückruffunktion auf! Die Lösung wird darin bestehen, eine Art globale Struktur zu erstellen, in die wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Audiopakete</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einfügen können, damit unser </font><b><font style="vertical-align: inherit;">audio_callback</font></b><font style="vertical-align: inherit;"> etwas zum Empfangen von Audiodaten hat! Hier ist also, was wir tun werden, um die Paketwarteschlange zu erstellen. FFmpeg hat sogar eine Struktur, die dabei hilft: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacketList</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , eine verknüpfte Liste für Pakete. Hier ist unsere Warteschlangenstruktur:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst müssen wir angeben, dass </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nb_packets</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unterschiedlich groß ist - die Größe bezieht sich auf die Größe des Bytes, das wir von </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">package-&gt; size erhalten</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Beachten Sie, dass wir einen Mutex und eine Bedingungsvariable haben. </font><font style="vertical-align: inherit;">Dies liegt daran, dass die SDL den Audioprozess als separaten Stream ausführt. </font><font style="vertical-align: inherit;">Wenn wir die Warteschlange nicht richtig blockieren, können wir unsere Daten wirklich ruinieren. </font><font style="vertical-align: inherit;">Mal sehen, wie die Warteschlange implementiert wird. </font><font style="vertical-align: inherit;">Jeder Programmierer mit Selbstachtung sollte wissen, wie man Warteschlangen erstellt. Wir zeigen Ihnen jedoch auch, wie dies funktioniert, damit Sie die SDL-Funktionen leichter erlernen können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst erstellen wir eine Funktion zum Initialisieren der Warteschlange:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie dann eine Funktion, um Objekte in unsere Warteschlange zu stellen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_LockMutex</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () blockiert den Mutex in der Warteschlange, damit wir etwas hinzufügen können, und dann </font><font style="vertical-align: inherit;">sendet </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondSignal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () ein Signal an unsere </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">(falls erwartet) über unsere bedingte Variable, um ihr mitzuteilen, dass Daten vorhanden sind, und kann für weitere </font><b><font style="vertical-align: inherit;">Zwecke</font></b><font style="vertical-align: inherit;"> fortgesetzt werden Mutex entsperren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist die entsprechende </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">. Beachten Sie, wie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondWait</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () den Funktionsblock erstellt (d. H. Pausiert, bis wir die Daten erhalten), wenn wir ihn dazu auffordern:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> quit = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span> </span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, haben wir die Funktion in einen ewigen Zyklus eingeschlossen, sodass wir definitiv einige Daten erhalten, wenn wir sie blockieren möchten. </font><font style="vertical-align: inherit;">Mit der Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondWait</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () </font><font style="vertical-align: inherit;">vermeiden wir eine Schleife für immer </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Im Wesentlichen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wartet CondWait lediglich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf ein Signal von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondSignal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () (oder </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondBroadcast</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ()) und fährt dann fort. </font><font style="vertical-align: inherit;">Es sieht jedoch so aus, als hätten wir es in einem Mutex gefangen - wenn wir die Sperre gedrückt halten, kann unsere </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Put-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">nichts in die Warteschlange stellen! </font><font style="vertical-align: inherit;">Was </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondWait</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () jedoch auch für uns tut, ist, den Mutex, den wir ihm geben, zu entsperren und dann erneut zu versuchen, ihn zu sperren, sobald wir das Signal empfangen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für jeden Feuerwehrmann</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie sehen auch, dass wir eine globale </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beendigungsvariable haben</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">die wir überprüfen, um sicherzustellen, dass wir das Ausgangssignal nicht im Programm eingestellt haben (SDL verarbeitet automatisch </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TERM-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Signale </font><font style="vertical-align: inherit;">usw.). </font><font style="vertical-align: inherit;">Andernfalls wird der Thread für immer fortgesetzt und wir müssen das Programm mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kill -9 beenden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">  SDL_PollEvent(&amp;event);
  <span class="hljs-keyword">switch</span>(event.type) {
  <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
    quit = <span class="hljs-number">1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir setzen das Exit-Flag auf 1.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir füttern Pakete</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es bleibt nur die Konfiguration unserer Warteschlange:</font></font><br>
<br>
<pre><code class="cpp hljs">PacketQueue audioq;<font></font>
main() {<font></font>
...<font></font>
  avcodec_open2(aCodecCtx, aCodec, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
  packet_queue_init(&amp;audioq);<font></font>
  SDL_PauseAudio(<span class="hljs-number">0</span>);</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_PauseAudio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () startet schließlich die Audioeinheit. </font><font style="vertical-align: inherit;">Es reproduziert Stille, wenn es keine Daten empfängt. </font><font style="vertical-align: inherit;">Dies geschieht jedoch nicht sofort. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben also eine Warteschlange konfiguriert und können nun Pakete an sie senden. </font><font style="vertical-align: inherit;">Wir fahren mit unserem Paketlesezyklus fort:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
  <span class="hljs-comment">// Is this a packet from the video stream?</span>
  <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
    <span class="hljs-comment">// Decode video frame</span><font></font>
    ....<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet.stream_index==audioStream) {<font></font>
    packet_queue_put(&amp;audioq, &amp;packet);<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    av_free_packet(&amp;packet);<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass wir das Paket nach dem Einreihen nicht freigeben. </font><font style="vertical-align: inherit;">Wir werden es später veröffentlichen, wenn wir entschlüsseln.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pakete abrufen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns nun endlich unsere </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_callback-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><b><font style="vertical-align: inherit;">ausführen</font></b><font style="vertical-align: inherit;"> , um Pakete aus der Warteschlange abzurufen. </font><font style="vertical-align: inherit;">Der Rückruf sollte folgendermaßen aussehen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span></span></code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benutzerdaten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind der Zeiger, den wir der SDL gegeben haben, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der Puffer, in den Audiodaten geschrieben werden, und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die Größe dieses Puffers. </font><font style="vertical-align: inherit;">Hier ist der Code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  AVCodecContext *aCodecCtx = (AVCodecContext *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;<font></font>
<font></font>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> audio_buf_size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> audio_buf_index = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(audio_buf_index &gt;= audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span><font></font>
      audio_size = audio_decode_frame(aCodecCtx, audio_buf,<font></font>
                                      <span class="hljs-keyword">sizeof</span>(audio_buf));
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(audio_buf, <span class="hljs-number">0</span>, audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_buf_size = audio_size;<font></font>
      }<font></font>
      audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = audio_buf_size - audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)audio_buf + audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    audio_buf_index += len1;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich ist dies eine einfache Schleife, die Daten aus einer anderen von uns geschriebenen Funktion, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_decode_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () </font><font style="vertical-align: inherit;">, </font><b><font style="vertical-align: inherit;">extrahiert</font></b><font style="vertical-align: inherit;"> , das Ergebnis in einem Zwischenpuffer speichert, versucht, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bytes in den Stream </font><font style="vertical-align: inherit;">zu schreiben </font><font style="vertical-align: inherit;">und mehr Daten empfängt, wenn wir noch nicht genug haben oder sie für später speichern. wenn wir noch etwas übrig haben. </font><font style="vertical-align: inherit;">Die Größe von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_buf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist 1,5-mal so groß wie der größte Audio-Frame, den FFmpeg uns geben wird, was uns einen guten Spielraum gibt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endgültige Audio-Entschlüsselung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns die Innenseiten des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_decode_frame-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Decoders an </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(AVCodecContext *aCodecCtx, <span class="hljs-keyword">uint8_t</span> *audio_buf,
                       <span class="hljs-keyword">int</span> buf_size)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">static</span> AVPacket pkt;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> *audio_pkt_data = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> audio_pkt_size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">static</span> AVFrame frame;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(aCodecCtx, &amp;frame, &amp;got_frame, &amp;pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      audio_pkt_data += len1;<font></font>
      audio_pkt_size -= len1;<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       aCodecCtx-&gt;channels,<font></font>
					       frame.nb_samples,<font></font>
					       aCodecCtx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt.data)<font></font>
      av_free_packet(&amp;pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;audioq, &amp;pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    audio_pkt_data = pkt.data;<font></font>
    audio_pkt_size = pkt.size;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der gesamte Prozess beginnt tatsächlich gegen Ende der Funktion, wo wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packet_queue_get</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () </font><font style="vertical-align: inherit;">aufrufen </font><font style="vertical-align: inherit;">. Wir nehmen das Paket aus der Warteschlange und speichern die Informationen daraus. Wenn das Paket funktioniert, rufen wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_audio4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () auf, das der Schwesterfunktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () </font><font style="vertical-align: inherit;">sehr ähnlich ist </font><font style="vertical-align: inherit;">, außer dass das Paket in diesem Fall mehr als einen Frame haben kann. Daher müssen Sie es möglicherweise mehrmals aufrufen, um alle Daten aus dem Paket abzurufen. Nachdem wir den Frame erhalten haben, kopieren wir ihn einfach in unseren </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Audiopuffer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und stellen sicher, dass </font><b><font style="vertical-align: inherit;">data_size</font></b><font style="vertical-align: inherit;"> kleiner als unser </font><b><font style="vertical-align: inherit;">Audiopuffer ist</font></b><font style="vertical-align: inherit;"> . </font><b><font style="vertical-align: inherit;">Denken Sie</font></b><font style="vertical-align: inherit;"> auch an das Casting von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_buf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf den richtigen Typ, da SDL einen 8-Bit-Int-Puffer und FFmpeg Daten in einem 16-Bit-Int-Puffer liefert. Sie sollten auch den Unterschied zwischen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data_size berücksichtigen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die Größe des von uns verwendeten Pakets und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die Menge der zurückgegebenen Rohdaten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir Daten haben, kehren wir sofort zurück, um herauszufinden, ob wir mehr Daten aus der Warteschlange abrufen müssen oder ob wir fertig sind. Wenn wir das Paket noch bearbeiten müssen, bleiben Sie dabei. Wenn Sie das Paket fertiggestellt haben, geben Sie es schließlich frei. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und das ist alles! Wir haben Audio von der </font><b><font style="vertical-align: inherit;">Hauptleseschleife</font></b><font style="vertical-align: inherit;"> in die Warteschlange übertragen, die dann von der Funktion </font><b><font style="vertical-align: inherit;">audio_callback</font></b><font style="vertical-align: inherit;"> gelesen wird</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der diese Daten an die SDL und die SDL an Ihre Soundkarte überträgt. Gehen Sie voran und kompilieren Sie:</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial03 tutorial03.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gip-gip-Hurra! </font><font style="vertical-align: inherit;">Das Video wird immer noch mit maximaler Geschwindigkeit übertragen, aber der Ton wird bereits so abgespielt, wie er sollte. </font><font style="vertical-align: inherit;">Warum so? </font><font style="vertical-align: inherit;">Ja, da die Audioinformationen eine Abtastfrequenz haben - wir pumpen die Audioinformationen so schnell aus, wie sich herausstellt, aber das Audio wird in diesem Stream einfach entsprechend seiner Abtastfrequenz abgespielt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sind fast reif für die Video- und Audiosynchronisation, aber zuerst müssen wir eine kleine Neuorganisation des Programms durchführen. </font><font style="vertical-align: inherit;">Die Methode, Sound in die Warteschlange zu stellen und ihn mit einem separaten Stream abzuspielen, funktionierte sehr gut: Sie machte den Code übersichtlicher und modularer. </font><font style="vertical-align: inherit;">Bevor wir mit der Synchronisierung von Video und Audio beginnen, müssen wir den Code vereinfachen. </font><font style="vertical-align: inherit;">In der nächsten Serie werden wir Kontrollflüsse erzeugen!</font></font><a name="threads"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lektion 4: Mehrere Themen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Lektion 3: Sound abspielen"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Zum Inhaltsverzeichnis"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Lektion 5: Videosynchronisation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollständige Auflistung tutorial04.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial04.c</span>
<span class="hljs-comment">// A pedagogical video player that will stream through every video frame as fast as it can,</span>
<span class="hljs-comment">// and play audio (out of sync).</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial04 tutorial04.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial04 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_QUIT_EVENT (SDL_USEREVENT + 1)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_PICTURE_QUEUE_SIZE 1</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;<font></font>
} VideoPicture;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVFrame         audio_frame;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;<font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span>;</span><font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;<font></font>
<font></font>
SDL_Surface     *screen;<font></font>
SDL_mutex       *screen_mutex;<font></font>
<font></font>
<span class="hljs-comment">/* Since we only have one decoding thread, the Big Struct
   can be global in case we need it. */</span><font></font>
VideoState *global_video_state;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(global_video_state-&gt;quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
  AVPacket *pkt = &amp;is-&gt;audio_pkt;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(is-&gt;audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	is-&gt;audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       is-&gt;audio_ctx-&gt;channels,<font></font>
					       is-&gt;audio_frame.nb_samples,<font></font>
					       is-&gt;audio_ctx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, is-&gt;audio_frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      is-&gt;audio_pkt_data += len1;<font></font>
      is-&gt;audio_pkt_size -= len1;<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data)<font></font>
      av_free_packet(pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">/* next packet */</span>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_pkt_data = pkt-&gt;data;<font></font>
    is-&gt;audio_pkt_size = pkt-&gt;size;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf));
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	is-&gt;audio_buf_size = audio_size;<font></font>
      }<font></font>
      is-&gt;audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    is-&gt;audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_ctx-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_ctx-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_ctx-&gt;width / is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
      <span class="hljs-comment">/* Now, normally here goes a ton of code
	 about timing, etc. we're just going to
	 guess at a delay for now. You can
	 increase and decrease this value and hard code
	 the timing - but I don't suggest that ;)
	 We'll learn how to do it for real later.
      */</span>
      schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}<font></font>
      <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  vp-&gt;width = is-&gt;video_ctx-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_ctx-&gt;height;<font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_ctx-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_ctx-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_ctx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }      <font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec *codec = <span class="hljs-literal">NULL</span>;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    wanted_spec.format = AUDIO_S16SYS;<font></font>
    wanted_spec.channels = codecCtx-&gt;channels;<font></font>
    wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
    wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,<font></font>
				 is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> video_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> audio_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  is-&gt;videoStream=<span class="hljs-number">-1</span>;<font></font>
  is-&gt;audioStream=<span class="hljs-number">-1</span>;<font></font>
<font></font>
  global_video_state = is;<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
<font></font>
  is-&gt;pFormatCtx = pFormatCtx;<font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, is-&gt;filename, <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       video_index &lt; <span class="hljs-number">0</span>) {<font></font>
      video_index=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audio_index &lt; <span class="hljs-number">0</span>) {<font></font>
      audio_index=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(audio_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, audio_index);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(video_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, video_index);<font></font>
  }   <font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;videoStream &lt; <span class="hljs-number">0</span> || is-&gt;audioStream &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: could not open codecs\n"</span>, is-&gt;filename);
    <span class="hljs-keyword">goto</span> fail;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// main decode loop</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* all done - wait for it */</span>
  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  screen_mutex = SDL_CreateMutex();<font></font>
<font></font>
  av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
  is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
  is-&gt;pictq_cond = SDL_CreateCond();<font></font>
<font></font>
  schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
  is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
    av_free(is);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> FF_QUIT_EVENT:
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      is-&gt;quit = <span class="hljs-number">1</span>;<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
      video_refresh_timer(event.user.data1);<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
<font></font>
}</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überblick</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim letzten Mal haben wir Audio-Unterstützung mithilfe der SDL-Audiofunktionen hinzugefügt. </font><font style="vertical-align: inherit;">SDL hat einen Thread gestartet, der Rückrufe für die Funktion erstellt, die wir jedes Mal definiert haben, wenn ein Sound benötigt wurde. </font><font style="vertical-align: inherit;">Jetzt machen wir dasselbe mit der Videoanzeige. </font><font style="vertical-align: inherit;">Dies macht den Code modularer und einfacher zu bearbeiten - insbesondere, wenn Sie die Synchronisierung hinzufügen möchten. </font><font style="vertical-align: inherit;">Wo fangen wir an?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass unsere Hauptfunktion viel erledigt: Sie durchläuft die Ereignisschleife, liest Pakete und decodiert das Video. Was wir tun werden, ist, alles in Teile zu teilen: Wir werden einen Stream haben, der für das Decodieren von Paketen verantwortlich ist; Dann werden diese Pakete zur Warteschlange hinzugefügt und von den entsprechenden Audio- und Videostreams gelesen. Wir haben den Audiostream bereits nach Bedarf eingestellt. Mit einem Videostream wird es etwas schwieriger, da wir sicherstellen müssen, dass das Video selbst gezeigt wird. Wir werden den eigentlichen Anzeigecode zur Hauptschleife hinzufügen. Anstatt das Video jedes Mal anzuzeigen, wenn wir die Schleife ausführen, integrieren wir die Videoanzeige in die Ereignisschleife. Die Idee ist, das Video zu dekodieren, den empfangenen Frame in einer anderen Warteschlange zu speichern und dann ein eigenes Ereignis ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF_REFRESH_EVENT) zu erstellen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), die wir dem Ereignissystem hinzufügen. Wenn unsere Ereignisschleife dieses Ereignis sieht, wird der nächste Frame in der Warteschlange angezeigt. Hier ist eine praktische ASCII-Darstellung des Geschehens:</font></font><br>
<br>
<div style="text-align:center;"><img width="335" height="221" src="https://habrastorage.org/webt/nf/ej/gq/nfejgqoqpypds3quordh_x2qgwa.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Hauptgrund für das Verschieben der Videoanzeigesteuerung durch die Ereignisschleife besteht darin, dass </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">mit dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_Delay-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stream </font><font style="vertical-align: inherit;">genau steuern können, wann das nächste Videobild auf dem Bildschirm angezeigt wird. </font><font style="vertical-align: inherit;">Wenn wir das Video in der nächsten Lektion endlich synchronisieren, fügen Sie einfach einen Code hinzu, der das nächste Video-Update so plant, dass das richtige Bild zum richtigen Zeitpunkt auf dem Bildschirm angezeigt wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vereinfachen Sie den Code</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns den Code ein wenig löschen. Wir haben all diese Informationen über Audio- und Video-Codecs und werden Warteschlangen, Puffer und Gott weiß was noch hinzufügen. All diese Dinge sind für eine bestimmte logische Einheit, nämlich - für den Film. Wir beabsichtigen daher, eine große Struktur mit all diesen Informationen namens </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoState</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu erstellen </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;<font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sehen wir Hinweise darauf, was wir am Ende bekommen werden. Zunächst sehen wir die grundlegenden Informationen - den Kontext des Formats und die Indizes des Audio- und Videostreams sowie die entsprechenden </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVStream-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objekte </font><font style="vertical-align: inherit;">. Dann sehen wir, dass einige dieser Audiopuffer in diese Struktur verschoben werden. Sie ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_buf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_buf_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usw.) waren für Informationen zu Audio gedacht, das noch vorhanden war (oder fehlte). Wir haben eine weitere Warteschlange für Videos und einen Puffer (der als Warteschlange verwendet wird; dafür benötigen wir keine extravaganten Warteschlangen) für dekodierte Frames hinzugefügt (als Overlay gespeichert). </font><b><font style="vertical-align: inherit;">VideoPicture-</font></b><font style="vertical-align: inherit;"> Struktur</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dies ist unsere eigene Schöpfung (wir werden sehen, was darin sein wird, wenn wir dazu kommen). Sie können auch feststellen, dass wir Zeiger für zwei zusätzliche Streams zugewiesen haben, die wir erstellen werden, sowie ein Exit-Flag und einen Filmdateinamen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun kehren wir zur Hauptfunktion zurück, um zu sehen, wie dies unser Programm ändert. Lassen Sie uns unsere </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoState-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur </font><b><font style="vertical-align: inherit;">einrichten</font></b><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_mallocz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () ist eine gute Funktion, die Speicher für uns reserviert und auf Null setzt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann initialisieren wir unsere Sperren für den Anzeigepuffer ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pictq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), da die Anzeigeschleife </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vordecodierte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Frames aus </font><b><font style="vertical-align: inherit;">pictq </font></b><b><font style="vertical-align: inherit;">abruft</font></b><font style="vertical-align: inherit;"> , da die Ereignisschleife unsere Anzeigefunktion </font><b><font style="vertical-align: inherit;">aufruft</font></b><font style="vertical-align: inherit;"> . Gleichzeitig wird unser Videodecoder Informationen einfügen - wir wissen nicht, wer zuerst dort ankommt. Ich hoffe du verstehst, dass dies eine klassische Rennbedingung ist. Deshalb verteilen wir es jetzt, bevor wir mit Themen beginnen. Kopieren wir auch den Namen unseres Films in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoState</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
is-&gt;pictq_cond = SDL_CreateCond();</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_strlcpy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine Funktion von FFmpeg, die neben </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strncpy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einige zusätzliche </font><b><font style="vertical-align: inherit;">Randprüfungen</font></b><font style="vertical-align: inherit;"> durchführt </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser erster Thread</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns unsere Threads ausführen und etwas Reales tun:</font></font><br>
<br>
<pre><code class="cpp hljs">schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
<span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
  av_free(is);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schedule_Refresh</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine Funktion, die wir später definieren werden. Sie weist das System an, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF_REFRESH_EVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nach der angegebenen Anzahl von Millisekunden </font><font style="vertical-align: inherit;">zu erzeugen </font><font style="vertical-align: inherit;">. Dadurch wird die Videoaktualisierungsfunktion aufgerufen, wenn sie in der Ereigniswarteschlange angezeigt wird. Aber jetzt schauen wir uns </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CreateThread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () an. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CreateThread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () macht genau das - es erzeugt einen neuen Thread, der vollen Zugriff auf den gesamten Speicher des ursprünglichen Prozesses hat, und startet den Thread, der von der Funktion ausgeführt wird, die wir ihm geben. Diese Funktion überträgt auch benutzerdefinierte Daten. In diesem Fall rufen wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decode_thread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () auf und hängen unsere </font><b><font style="vertical-align: inherit;">VideoState-</font></b><font style="vertical-align: inherit;"> Struktur an</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In der ersten Hälfte der Funktion gibt es nichts Neues. Es öffnet lediglich die Datei und findet den Index der Audio- und Videostreams. Das einzige, was wir anders machen, ist, den Formatkontext in unserer großen Struktur beizubehalten. Nachdem wir unsere Stream-Indizes gefunden haben, rufen wir eine andere von uns definierte Funktion auf, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_component_open</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (). Dies ist eine ziemlich natürliche Art der Trennung. Da wir viele ähnliche Dinge tun, um den Video- und Audio-Codec einzurichten, verwenden wir einen Code wieder, wodurch er zu einer Funktion wird. </font><b><font style="vertical-align: inherit;">Stream_component_open-</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Funktion</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">() Ist der Ort, an dem wir unseren Codec-Decoder entdecken, die Soundparameter konfigurieren, wichtige Informationen in unserer großen Struktur speichern und unsere Audio- und Videostreams starten. Hier fügen wir auch andere Parameter ein, z. B. die erzwungene Verwendung des Codecs anstelle seiner automatischen Erkennung usw. So:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx;<font></font>
  AVCodec *codec;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    <span class="hljs-comment">/* ...etc... */</span><font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
    <font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_st-&gt;codec-&gt;width, is-&gt;video_st-&gt;codec-&gt;height,<font></font>
				 is-&gt;video_st-&gt;codec-&gt;pix_fmt, is-&gt;video_st-&gt;codec-&gt;width,<font></font>
				 is-&gt;video_st-&gt;codec-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist fast das gleiche wie der Code, den wir zuvor hatten, außer dass er jetzt für Audio und Video verallgemeinert ist. Beachten Sie, dass </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">anstelle von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aCodecCtx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unsere große Struktur als Benutzerdaten für unseren Audio-Rückruf konfiguriert haben. Wir haben die Streams auch selbst als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_st</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_st gespeichert</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wir haben auch unsere Video-Warteschlange hinzugefügt und genau wie unsere Audio-Warteschlange eingerichtet. Unter dem Strich werden Video- und Audio-Streams ausgeführt. Diese Bits tun dies:</font></font><br>
<br>
<pre><code class="cpp hljs">    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;<font></font>
<font></font>
<span class="hljs-comment">/* ...... */</span><font></font>
<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken Sie an </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_PauseAudio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () aus der letzten Lektion. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CreateThread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () wird auf die gleiche Weise verwendet. Zurück zu unserer Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_thread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (). </font><b><font style="vertical-align: inherit;">Kehren</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorher</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur zweiten Hälfte unserer Funktion </font><b><font style="vertical-align: inherit;">decode_thread</font></b><font style="vertical-align: inherit;"> () zurück. Im Wesentlichen ist es nur eine for-Schleife, die ein Paket liest und in die richtige Warteschlange stellt:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>((is-&gt;pFormatCtx-&gt;pb-&gt;error) == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier gibt es nichts wirklich Neues, außer dass wir jetzt eine maximale Größe für unsere Audio- und Video-Warteschlange haben und die Lesefehlerprüfung hinzugefügt haben. Der Formatkontext hat eine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ByteIOContext-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur </font><font style="vertical-align: inherit;">namens </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ByteIOContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine Struktur, in der im Wesentlichen alle Informationen zu Dateien auf niedriger Ebene gespeichert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach unserer for-Schleife haben wir den gesamten Code, um zu warten, bis der Rest des Programms abgeschlossen ist, oder um darüber zu informieren. Dieser Code ist aufschlussreich, da er zeigt, wie wir Ereignisse pushen - etwas, das wir später benötigen, um das Video anzuzeigen:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir erhalten Werte für benutzerdefinierte Ereignisse mit der SDL-Konstante </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Das erste Benutzerereignis muss auf </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das nächste </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usw. gesetzt sein. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF_QUIT_EVENT ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in unserem Programm als </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 definiert</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Bei Bedarf können wir auch Benutzerdaten übergeben, und hier übergeben wir unseren Zeiger auf eine große Struktur. Schließlich rufen wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_PushEvent</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () auf. In unserem Ereignisschleifenschalter haben wir dies einfach in den Abschnitt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_QUIT_EVENT eingefügt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das hatten wir vorher. </font><font style="vertical-align: inherit;">Wir werden unseren Zyklus der Ereignisse detaillierter sehen; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie </font><b><font style="vertical-align: inherit;">vorerst</font></b><font style="vertical-align: inherit;"> sicher, dass wir </font><b><font style="vertical-align: inherit;">FF_QUIT_EVENT</font></b><font style="vertical-align: inherit;"> später abfangen und das Exit-Flag wechseln.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bild empfangen: video_thread</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem Sie den Codec vorbereitet haben, können Sie den Videostream starten. </font><font style="vertical-align: inherit;">Dieser Stream liest Pakete aus der Video-Warteschlange, decodiert das Video in Frames und ruft dann die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queue_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf, um den verarbeiteten Frame in die </font><b><font style="vertical-align: inherit;">Bildwarteschlange</font></b><font style="vertical-align: inherit;"> zu stellen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_st-&gt;codec, pFrame, &amp;frameFinished, packet);<font></font>
<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_free(pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der größte Teil dieser Funktion sollte inzwischen verstanden werden. </font><font style="vertical-align: inherit;">Wir haben gerade die Funktion avcodec_decode_video2 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kopiert </font><font style="vertical-align: inherit;">und einfach einige Argumente ersetzt. </font><font style="vertical-align: inherit;">Zum Beispiel haben wir einen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVStream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in unserer großen Struktur gespeichert, sodass wir unseren Codec von dort erhalten. </font><font style="vertical-align: inherit;">Wir empfangen nur weiterhin Pakete aus unserer Video-Warteschlange, bis uns jemand zum Beenden auffordert oder wir einen Fehler finden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warteschlangenrahmen</font></font></h3><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Werfen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir </font><font style="vertical-align: inherit;">
einen Blick auf die Funktion, mit der unser dekodierter </font><b><font style="vertical-align: inherit;">pFrame</font></b><font style="vertical-align: inherit;"> in unserer </font><b><font style="vertical-align: inherit;">Bildwarteschlange gespeichert wird</font></b><font style="vertical-align: inherit;"> . Da es sich bei unserer Bildwarteschlange um eine Überlagerung von SDL handelt (vermutlich, damit die Videoanzeigefunktion so wenig Berechnungen wie möglich durchführen kann), müssen wir unseren Frame in diese konvertieren. Die Daten, die wir in der Bildwarteschlange speichern, sind die Struktur, die wir erstellt haben:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;<font></font>
} VideoPicture;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere große Struktur enthält einen Puffer dieser Dateien, in dem wir sie speichern können. </font><font style="vertical-align: inherit;">Wir müssen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_Overlay jedoch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> selbst </font><font style="vertical-align: inherit;">verteilen </font><font style="vertical-align: inherit;">(achten Sie auf das zugewiesene Flag, das anzeigt, ob wir es getan haben oder nicht). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diese Warteschlange zu verwenden, haben wir zwei Zeiger - den Schreibindex und den Leseindex. </font><font style="vertical-align: inherit;">Wir verfolgen auch, wie viele tatsächliche Bilder sich im Puffer befinden. </font><font style="vertical-align: inherit;">Um in die Warteschlange zu schreiben, warten wir zuerst, bis unser Puffer gelöscht ist, damit wir einen Platz zum Speichern unseres </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoPicture haben</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dann prüfen wir, ob wir das Overlay in unserem Datensatzindex festgelegt haben. </font><font style="vertical-align: inherit;">Wenn nicht, müssen Sie Speicher zuweisen. </font><font style="vertical-align: inherit;">Wir müssen auch den Puffer neu zuweisen, wenn sich die Fenstergröße geändert hat!</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_st-&gt;codec-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_st-&gt;codec-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alloc_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () an:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_st-&gt;codec-&gt;width,<font></font>
				 is-&gt;video_st-&gt;codec-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
  vp-&gt;width = is-&gt;video_st-&gt;codec-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_st-&gt;codec-&gt;height;  <font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie sollten die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CreateYUVOverlay erkennen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die wir von unserer Hauptschleife in diesen Abschnitt verschoben haben. Dieser Code sollte inzwischen einigermaßen klar sein. Jetzt haben wir jedoch eine Mutex-Sperre, da zwei Threads nicht gleichzeitig Informationen auf den Bildschirm schreiben können! Dadurch kann unsere Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alloc_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keine </font><b><font style="vertical-align: inherit;">andere</font></b><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">stören, die das Bild anzeigt. (Wir haben diese Sperre als globale Variable erstellt und in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () </font><font style="vertical-align: inherit;">initialisiert </font><font style="vertical-align: inherit;">. Siehe Code.) </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie, dass wir die Breite und Höhe in der </font><b><font style="vertical-align: inherit;">VideoPicture-</font></b><font style="vertical-align: inherit;"> Struktur </font><b><font style="vertical-align: inherit;">beibehalten</font></b><font style="vertical-align: inherit;"> , da wir sicherstellen müssen, dass sich die Größe unseres Videos aus irgendeinem Grund nicht ändert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ok, wir haben es geregelt und wir haben unser Overlay </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, engagiert und bereit, das Bild zu empfangen. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kehren</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir zu </font><b><font style="vertical-align: inherit;">queue_picture zurück</font></b><font style="vertical-align: inherit;"> und sehen uns den Code an, um den Frame in das Overlay zu kopieren. Dieser Teil sollte Ihnen vertraut sein:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame)</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">/* Allocate a frame if we need it... */</span>
  <span class="hljs-comment">/* ... */</span>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_st-&gt;codec-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist das meiste nur der Code, den wir zuvor verwendet haben, um das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Overlay mit </font><font style="vertical-align: inherit;">unserem Frame zu </font><b><font style="vertical-align: inherit;">füllen</font></b><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Das letzte Bit "fügt" einfach unseren Wert zur Warteschlange hinzu. </font><font style="vertical-align: inherit;">Die Warteschlange funktioniert, Werte werden hinzugefügt, bis sie voll ist, und das Lesen erfolgt, solange sich mindestens etwas darin befindet. </font><font style="vertical-align: inherit;">Daher hängt alles vom Wert von </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pictq_size ab</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , weshalb wir ihn blockieren müssen. </font><font style="vertical-align: inherit;">Also, was machen wir hier: Erhöhen Sie den Datensatzzeiger (und beginnen Sie gegebenenfalls von vorne), blockieren Sie dann die Warteschlange und vergrößern Sie sie. </font><font style="vertical-align: inherit;">Jetzt wird unser Leser wissen, dass es mehr Informationen über die Warteschlange gibt, und wenn dies unsere Warteschlange voll macht, wird unser Rekorder davon erfahren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Videoanzeige</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles für unseren Videothread! Jetzt haben wir alle freien Threads bis auf einen abgeschlossen - erinnern Sie sich, wie wir die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sched_refresh</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () vor </font><font style="vertical-align: inherit;">langer Zeit aufgerufen haben </font><font style="vertical-align: inherit;">? Schauen Sie sich an, was tatsächlich passiert ist:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_AddTimer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () ist eine SDL-Funktion, die nach einer bestimmten Anzahl von Millisekunden einfach einen Rückruf an eine benutzerdefinierte Funktion ausführt (und bei Bedarf einige benutzerdefinierte Daten überträgt). Wir werden diese Funktion verwenden, um Videoaktualisierungen zu planen. Jedes Mal, wenn wir sie aufrufen, wird ein Timer festgelegt, der ein Ereignis auslöst, wodurch unsere </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () - Funktion eine Funktion aufruft, die einen Frame aus unserem Warteschlangenbild extrahiert und anzeigt ihr! Puh! Drei "welche / welche / welche" in einem Satz! Lassen Sie uns also als Erstes dieses Ereignis auslösen. Dies schickt uns zu:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Veranstaltung wird von unserem alten Freund ins Leben gerufen. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF_REFRESH_EVENT ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hier als </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 definiert</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es ist zu beachten, dass die SDL den Timer stoppt, wenn wir 0 zurückgeben, sodass der Rückruf nicht erneut ausgeführt wird. </font><b><font style="vertical-align: inherit;">Nachdem</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF_REFRESH_EVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erneut aufgerufen </font><b><font style="vertical-align: inherit;">haben</font></b><font style="vertical-align: inherit;"> , müssen wir es in unserer Ereignisschleife verarbeiten:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span>(;;) {<font></font>
<font></font>
  SDL_WaitEvent(&amp;event);<font></font>
  <span class="hljs-keyword">switch</span>(event.type) {
  <span class="hljs-comment">/* ... */</span>
  <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
    video_refresh_timer(event.user.data1);<font></font>
    <span class="hljs-keyword">break</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was schickt uns hierher zu dieser Funktion, die tatsächlich Daten aus unserer Bildwarteschlange extrahiert:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
      <span class="hljs-comment">/* Timing code goes here */</span><font></font>
<font></font>
      schedule_refresh(is, <span class="hljs-number">80</span>);<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Moment ist diese Funktion ziemlich einfach: Sie verarbeitet die Warteschlange, während wir etwas haben, stellt einen Timer für die Anzeige des nächsten Videobilds ein, ruft </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_display</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf, um das Video tatsächlich auf dem Bildschirm anzuzeigen, erhöht dann den Zähler in der Warteschlange und verringert gleichzeitig seine Größe. Sie werden vielleicht bemerken, dass wir </font><font style="vertical-align: inherit;">in dieser Funktion </font><font style="vertical-align: inherit;">nicht wirklich etwas mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vp machen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und hier ist der Grund: Dies liegt vor uns. Aber etwas später. Wir werden es verwenden, um auf Zeitinformationen zuzugreifen, wenn wir beginnen, Video mit Audio zu synchronisieren. Schauen Sie sich hier die Stelle im Code an, an der der Kommentar „Timing-Code geht hierher“ geschrieben ist. In diesem Abschnitt werden wir , </font><font style="vertical-align: inherit;">wie schnell um herauszufinden wir den nächsten Video - </font><font style="vertical-align: inherit;">Frame anzeigen sollen, und dann diesen Wert in der Eingabe </font><b><font style="vertical-align: inherit;">schedule_refresh</font></b><font style="vertical-align: inherit;"> Funktion</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(). Im Moment geben wir nur einen fiktiven Wert von 80 ein. Technisch gesehen können Sie diesen Wert erraten und überprüfen und für jeden Film neu kompilieren, aber: 1) er wird nach einer Weile langsamer und 2) er ist ziemlich dumm. Obwohl wir in Zukunft auf diesen Punkt zurückkommen werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sind fast fertig. Es bleibt nur noch eines zu tun: Zeigen Sie das Video! Hier ist die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_display</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_st-&gt;codec-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_st-&gt;codec-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_st-&gt;codec-&gt;width / is-&gt;video_st-&gt;codec-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_st-&gt;codec-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_st-&gt;codec-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da der Bildschirm eine beliebige Größe haben kann (wir haben 640 x 480 installiert und es gibt Möglichkeiten, ihn so anzupassen, dass die Größe des Benutzers geändert wird), müssen Sie dynamisch bestimmen, wie groß der rechteckige Bereich für unseren Film sein soll. Zuerst müssen Sie das Seitenverhältnis unseres Films herausfinden, nur die Breite geteilt durch die Höhe. Einige Codecs haben ein ungerades Seitenverhältnis des Samples, dh einfach die Breite / Höhe eines Pixels oder Samples. Da die Höhen- und Breitenwerte in unserem Codec-Kontext in Pixel gemessen werden, entspricht das tatsächliche Seitenverhältnis dem Seitenverhältnis multipliziert mit dem Seitenverhältnis für die Stichprobe. Einige Codecs zeigen ein Seitenverhältnis von 0, was bedeutet, dass jedes Pixel einfach eine Größe von 1x1 hat. Dann skalieren wir den Film sodamit es so gut wie möglich auf den Bildschirm passt. Bitumkehr</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp; -3</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rundet den Wert einfach auf das nächste Vielfache von vier. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zentrieren Sie</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dann den Film und rufen Sie</font><b><font style="vertical-align: inherit;"> SDL_DisplayYUVOverlay</font></b><font style="vertical-align: inherit;"> () auf, um sicherzustellen, dass der Bildschirmmutex für den Zugriff verwendet wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und das ist alles? </font><font style="vertical-align: inherit;">Sind wir fertig? </font><font style="vertical-align: inherit;">Sie müssen den Audiocode noch neu schreiben, um das neue</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VideoStruct verwenden zu</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> können. Dies sind jedoch triviale Änderungen, die im Beispielcode zu sehen sind. </font><font style="vertical-align: inherit;">Als letztes müssen wir unseren Rückruf für die interne Exit-Rückruffunktion in FFmpeg ändern:</font></font><br>
<br>
<pre><code class="cpp hljs">VideoState *global_video_state;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_interrupt_cb</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
  <span class="hljs-keyword">return</span> (global_video_state &amp;&amp; global_video_state-&gt;quit);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setzen Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">global_video_state</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () </font><font style="vertical-align: inherit;">auf eine große Struktur </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, das war es! </font><font style="vertical-align: inherit;">Wir kompilieren:</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial04 tutorial04.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und genieße den Film ohne zu synchronisieren! </font><font style="vertical-align: inherit;">Im nächsten Schritt werden wir endlich einen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wirklich funktionierenden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Videoplayer </font><font style="vertical-align: inherit;">erstellen </font><font style="vertical-align: inherit;">!</font></font><a name="video"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lektion 5: </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title=" "><font style="vertical-align: inherit;">Videosynchronisation </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Lektion 4: Mehrere Themen"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Zum Inhaltsverzeichnis"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Lektion 5: Audiosynchronisation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollständige Auflistung tutorial05.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial05.c</span>
<span class="hljs-comment">// A pedagogical video player that really works!</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial05 tutorial05.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial04 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_SYNC_THRESHOLD 0.01</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_NOSYNC_THRESHOLD 10.0</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_QUIT_EVENT (SDL_USEREVENT + 1)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_PICTURE_QUEUE_SIZE 1</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;
  <span class="hljs-keyword">double</span> pts;<font></font>
} VideoPicture;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
<font></font>
  <span class="hljs-keyword">double</span>          audio_clock;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVFrame         audio_frame;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;
  <span class="hljs-keyword">int</span>             audio_hw_buf_size;  
  <span class="hljs-keyword">double</span>          frame_timer;
  <span class="hljs-keyword">double</span>          frame_last_pts;
  <span class="hljs-keyword">double</span>          frame_last_delay;
  <span class="hljs-keyword">double</span>          video_clock; <span class="hljs-comment">///&lt;pts of last decoded frame / predicted pts of next decoded frame</span><font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span>;</span><font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;<font></font>
<font></font>
SDL_Surface     *screen;<font></font>
SDL_mutex       *screen_mutex;<font></font>
<font></font>
<span class="hljs-comment">/* Since we only have one decoding thread, the Big Struct
   can be global in case we need it. */</span><font></font>
VideoState *global_video_state;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(global_video_state-&gt;quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_audio_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> hw_buf_size, bytes_per_sec, n;<font></font>
  <font></font>
  pts = is-&gt;audio_clock; <span class="hljs-comment">/* maintained in the audio thread */</span><font></font>
  hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
  bytes_per_sec = <span class="hljs-number">0</span>;<font></font>
  n = is-&gt;audio_ctx-&gt;channels * <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span>(is-&gt;audio_st) {<font></font>
    bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(bytes_per_sec) {<font></font>
    pts -= (<span class="hljs-keyword">double</span>)hw_buf_size / bytes_per_sec;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size, <span class="hljs-keyword">double</span> *pts_ptr)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
  AVPacket *pkt = &amp;is-&gt;audio_pkt;<font></font>
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> n;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(is-&gt;audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	is-&gt;audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       is-&gt;audio_ctx-&gt;channels,<font></font>
					       is-&gt;audio_frame.nb_samples,<font></font>
					       is-&gt;audio_ctx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, is-&gt;audio_frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      is-&gt;audio_pkt_data += len1;<font></font>
      is-&gt;audio_pkt_size -= len1;<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      pts = is-&gt;audio_clock;<font></font>
      *pts_ptr = pts;<font></font>
      n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
      is-&gt;audio_clock += (<span class="hljs-keyword">double</span>)data_size /<font></font>
	(<span class="hljs-keyword">double</span>)(n * is-&gt;audio_ctx-&gt;sample_rate);
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data)<font></font>
      av_free_packet(pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">/* next packet */</span>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_pkt_data = pkt-&gt;data;<font></font>
    is-&gt;audio_pkt_size = pkt-&gt;size;<font></font>
    <span class="hljs-comment">/* if update, update the audio clock w/pts */</span>
    <span class="hljs-keyword">if</span>(pkt-&gt;pts != AV_NOPTS_VALUE) {<font></font>
      is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	is-&gt;audio_buf_size = audio_size;<font></font>
      }<font></font>
      is-&gt;audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    is-&gt;audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_ctx-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_ctx-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_ctx-&gt;width / is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
<font></font>
      delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="hljs-comment">/* the pts from last time */</span>
      <span class="hljs-keyword">if</span>(delay &lt;= <span class="hljs-number">0</span> || delay &gt;= <span class="hljs-number">1.0</span>) {
	<span class="hljs-comment">/* if incorrect delay, use previous one */</span><font></font>
	delay = is-&gt;frame_last_delay;<font></font>
      }<font></font>
      <span class="hljs-comment">/* save for next time */</span><font></font>
      is-&gt;frame_last_delay = delay;<font></font>
      is-&gt;frame_last_pts = vp-&gt;pts;<font></font>
<font></font>
      <span class="hljs-comment">/* update delay to sync to audio */</span><font></font>
      ref_clock = get_audio_clock(is);<font></font>
      diff = vp-&gt;pts - ref_clock;<font></font>
<font></font>
      <span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
	 FFPlay still doesn't "know if this is the best guess." */</span><font></font>
      sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;<font></font>
      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
	<span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
	  delay = <span class="hljs-number">0</span>;<font></font>
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
	  delay = <span class="hljs-number">2</span> * delay;<font></font>
	}<font></font>
      }<font></font>
      is-&gt;frame_timer += delay;<font></font>
      <span class="hljs-comment">/* computer the REAL delay */</span>
      actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="hljs-number">1000000.0</span>);
      <span class="hljs-keyword">if</span>(actual_delay &lt; <span class="hljs-number">0.010</span>) {
	<span class="hljs-comment">/* Really it should skip the picture instead */</span>
	actual_delay = <span class="hljs-number">0.010</span>;<font></font>
      }<font></font>
      schedule_refresh(is, (<span class="hljs-keyword">int</span>)(actual_delay * <span class="hljs-number">1000</span> + <span class="hljs-number">0.5</span>));<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}<font></font>
      <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  vp-&gt;width = is-&gt;video_ctx-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_ctx-&gt;height;<font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_ctx-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_ctx-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    vp-&gt;pts = pts;<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_ctx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">synchronize_video</span><span class="hljs-params">(VideoState *is, AVFrame *src_frame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">double</span> frame_delay;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(pts != <span class="hljs-number">0</span>) {
    <span class="hljs-comment">/* if we have pts, set video clock to it */</span><font></font>
    is-&gt;video_clock = pts;<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* if we aren't given a pts, set it to the clock */</span><font></font>
    pts = is-&gt;video_clock;<font></font>
  }<font></font>
  <span class="hljs-comment">/* update the video clock */</span><font></font>
  frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base);<font></font>
  <span class="hljs-comment">/* if we are repeating a frame, adjust clock accordingly */</span>
  frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="hljs-number">0.5</span>);<font></font>
  is-&gt;video_clock += frame_delay;<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    pts = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>((pts = av_frame_get_best_effort_timestamp(pFrame)) == AV_NOPTS_VALUE) {<font></font>
      pts = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    pts *= av_q2d(is-&gt;video_st-&gt;time_base);<font></font>
<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
      pts = synchronize_video(is, pFrame, pts);<font></font>
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec *codec = <span class="hljs-literal">NULL</span>;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    wanted_spec.format = AUDIO_S16SYS;<font></font>
    wanted_spec.channels = codecCtx-&gt;channels;<font></font>
    wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
    wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_hw_buf_size = spec.size;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
<font></font>
    is-&gt;frame_timer = (<span class="hljs-keyword">double</span>)av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
    is-&gt;frame_last_delay = <span class="hljs-number">40e-3</span>;<font></font>
    <font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,<font></font>
				 is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> video_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> audio_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  is-&gt;videoStream=<span class="hljs-number">-1</span>;<font></font>
  is-&gt;audioStream=<span class="hljs-number">-1</span>;<font></font>
<font></font>
  global_video_state = is;<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
<font></font>
  is-&gt;pFormatCtx = pFormatCtx;<font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, is-&gt;filename, <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       video_index &lt; <span class="hljs-number">0</span>) {<font></font>
      video_index=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audio_index &lt; <span class="hljs-number">0</span>) {<font></font>
      audio_index=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(audio_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, audio_index);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(video_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, video_index);<font></font>
  }   <font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;videoStream &lt; <span class="hljs-number">0</span> || is-&gt;audioStream &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: could not open codecs\n"</span>, is-&gt;filename);
    <span class="hljs-keyword">goto</span> fail;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// main decode loop</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* all done - wait for it */</span>
  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  screen_mutex = SDL_CreateMutex();<font></font>
<font></font>
  av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
  is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
  is-&gt;pictq_cond = SDL_CreateCond();<font></font>
<font></font>
  schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
  is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
    av_free(is);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> FF_QUIT_EVENT:
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      is-&gt;quit = <span class="hljs-number">1</span>;<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
      video_refresh_timer(event.user.data1);<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
<font></font>
}<font></font>
</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WARNUNG</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als ich gerade dieses Handbuch geschrieben habe, wurde mein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gesamter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Synchronisationscode aus der damaligen Version von </font><b><font style="vertical-align: inherit;">ffplay.c übernommen</font></b><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Heute ist es ein völlig anderes Programm, und Aktualisierungen in den FFmpeg-Bibliotheken (und in ffplay.c selbst) haben zu grundlegenden Änderungen geführt. </font><font style="vertical-align: inherit;">Obwohl dieser Code immer noch funktioniert, ist er bereits veraltet und es gibt viele andere Verbesserungen, die in diesem Handbuch verwendet werden könnten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Video synchronisiert</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bis jetzt hatten wir einen fast nutzlosen Movie Player. </font><font style="vertical-align: inherit;">Ja, es wird Video abgespielt, und ja, es wird Audio abgespielt, aber das ist nicht ganz das, was wir einen Film nennen würden. </font><font style="vertical-align: inherit;">Was machen wir dann?</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTS und DTS</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Glücklicherweise enthalten Audio- und Videostreams Informationen darüber, wie schnell und zu welchen Zeitpunkten sie abgespielt werden sollen. Audio-Streams haben eine Abtastrate und Video-Streams haben Bilder pro Sekunde. Wenn wir das Video jedoch nur synchronisieren, indem wir die Anzahl der Bilder zählen und mit der Bildrate multiplizieren, besteht eine gute Chance, dass es nicht mit dem Ton synchronisiert wird. Deshalb werden wir den anderen Weg gehen. Pakete aus dem Strom können die sogenannten haben </font><i><font style="vertical-align: inherit;">Dekodierungszeitstempel</font></i><font style="vertical-align: inherit;"> ( </font><b><font style="vertical-align: inherit;">DTS</font></b><font style="vertical-align: inherit;"> - von </font><i><b><font style="vertical-align: inherit;">d</font></b></i><i><font style="vertical-align: inherit;"> ecoding </font></i><i><b><font style="vertical-align: inherit;">t</font></b></i><i><font style="vertical-align: inherit;"> ime </font></i><i><b><font style="vertical-align: inherit;">s</font></b></i><i><font style="vertical-align: inherit;"> Stampf</font></i><font style="vertical-align: inherit;"> ) und </font><b><font style="vertical-align: inherit;">Präsentationszeitstempel</font></b><font style="vertical-align: inherit;"> ( </font><b><font style="vertical-align: inherit;">PTS</font></b><font style="vertical-align: inherit;"> - aus </font><i><b><font style="vertical-align: inherit;">p</font></b></i><i><font style="vertical-align: inherit;"> RÄSENTATION </font></i><i><b><font style="vertical-align: inherit;">t</font></b></i><i><font style="vertical-align: inherit;"> ime </font></i><i><b><font style="vertical-align: inherit;">s</font></b></i></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><i><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><i><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Um diese beiden Bedeutungen zu verstehen, müssen Sie wissen, wie Filme gespeichert werden. Einige Formate, wie z. B. MPEG, verwenden sogenannte </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B-Frames</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bed and</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is bidirektional, England. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bidirektional</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Zwei andere Arten von Frames werden als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I-Frames</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P-Frames</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">intern</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nner</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mittel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorhergesagt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> redicted</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I-Frames</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enthalten das Vollbild. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P-Frames</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hängen von vorherigen I- und P-Frames ab und unterscheiden sich von vorherigen Frames, oder Sie können auch - Deltas benennen. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B-Frames</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ähneln P-Frames, hängen jedoch von den Informationen in vorherigen und nachfolgenden Frames ab! Die Tatsache, dass ein Frame möglicherweise nicht das Bild selbst enthält, sondern sich von anderen Frames unterscheidet, erklärt, warum wir nach dem Aufruf von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_video2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> möglicherweise keinen fertigen Frame </font><b><font style="vertical-align: inherit;">haben</font></b><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, wir haben einen Film mit 4 Bildern in dieser Reihenfolge: </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IBBP</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dann müssen wir die Informationen aus dem letzten P-Frame herausfinden, bevor wir einen der beiden vorherigen B-Frames anzeigen können. Aus diesem Grund können Frames in einer Reihenfolge gespeichert werden, die nicht der tatsächlichen Anzeigereihenfolge entspricht: </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IPBB</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dafür sind der Dekodierungszeitstempel und der Präsentationszeitstempel für jeden Frame vorgesehen. Der Dekodierungszeitstempel sagt uns, wann wir etwas dekodieren müssen, und der Präsentationszeitstempel sagt uns, wann wir etwas anzeigen müssen. In diesem Fall sieht unser Stream also möglicherweise folgendermaßen aus: </font></font><br>
<br>
&nbsp;&nbsp;&nbsp;<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTS:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 4 2 3 </font></font><br>
&nbsp;&nbsp;&nbsp;<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DTS:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 2 3 4 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stream:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IPBB </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Regel unterscheiden sich PTS und DTS nur, wenn der abgespielte Stream B-Frames enthält. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir ein Paket von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_read_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () erhalten, enthält es die PTS- und DTS-Werte für die Informationen, die sich im Paket befinden. Was wir aber wirklich brauchen, ist das PTS unseres neu dekodierten Rohrahmens. In diesem Fall wissen wir, wann es angezeigt werden muss.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Glücklicherweise liefert uns FFmpeg den „bestmöglichen Zeitstempel“, den wir mit der Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_frame_get_best_effort_timestamp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () erhalten </font><font style="vertical-align: inherit;">können </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronisation</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit Frames der Reihe nach angezeigt werden, ist es schön zu wissen, wann ein bestimmtes Videobild angezeigt werden soll. </font><font style="vertical-align: inherit;">Aber wie genau machen wir das? </font><font style="vertical-align: inherit;">Die Idee ist folgende: Nachdem wir den Rahmen gezeigt haben, finden wir heraus, wann der nächste Rahmen gezeigt werden soll. </font><font style="vertical-align: inherit;">Dann machen Sie einfach eine Pause, danach aktualisieren wir das Video nach dieser Zeit. </font><font style="vertical-align: inherit;">Wie erwartet überprüfen wir den PTS-Wert des nächsten Frames auf der Systemuhr, um festzustellen, wie lange unsere Wartezeit sein sollte. </font><font style="vertical-align: inherit;">Dieser Ansatz funktioniert, aber es gibt zwei Probleme, die angegangen werden müssen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst stellt sich die Frage, wann der nächste PTS sein wird. Sie werden sagen, dass Sie einfach die Videofrequenz zum aktuellen PTS hinzufügen können - und Sie haben im Prinzip Recht. Für einige Arten von Videos müssen jedoch Frames wiederholt werden. Dies bedeutet, dass Sie den aktuellen Frame einige Male wiederholen müssen. Dies kann dazu führen, dass das Programm das nächste Bild zu früh anzeigt. Dies muss berücksichtigt werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite Problem ist, dass in dem Programm, das wir gerade geschrieben haben, Video und Audio freudig vorwärts eilen, bis sie sich überhaupt die Mühe machen, sich zu synchronisieren. </font><font style="vertical-align: inherit;">Wir müssten uns keine Sorgen machen, wenn alles für sich perfekt funktionieren würde. </font><font style="vertical-align: inherit;">Ihr Computer ist jedoch nicht perfekt, ebenso wie viele Videodateien. </font><font style="vertical-align: inherit;">Daher haben wir drei Möglichkeiten: Audio mit Video synchronisieren, Video mit Audio synchronisieren oder Audio und Video mit einer externen Uhr synchronisieren (z. B. mit Ihrem Computer). </font><font style="vertical-align: inherit;">Jetzt werden wir das Video mit Audio synchronisieren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codierung: Empfang eines PTS-Frames</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt schreiben wir etwas direkt. Wir müssen unserer großen Struktur noch ein paar Teile hinzufügen, und wir werden es so machen, wie wir es brauchen. Schauen wir uns zunächst unseren Videothread an. Denken Sie daran, dass wir hier Pakete sammeln, die von unserem Dekodierungsstrom in die Warteschlange gestellt wurden? In diesem Teil des Codes müssen wir den PTS für den Frame </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abrufen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , den </font><b><font style="vertical-align: inherit;">avcodec_decode_video2 uns gegeben hat</font></b><font style="vertical-align: inherit;"> . Der erste Weg, über den wir gesprochen haben, besteht darin, die DTS des zuletzt verarbeiteten Pakets zu erhalten, was ziemlich einfach ist:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    pts = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// Decode video frame</span><font></font>
    len1 = avcodec_decode_video2(is-&gt;video_st-&gt;codec,<font></font>
                                pFrame, &amp;frameFinished, packet);<font></font>
    <span class="hljs-keyword">if</span>(packet-&gt;dts != AV_NOPTS_VALUE) {<font></font>
      pts = av_frame_get_best_effort_timestamp(pFrame);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      pts = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    pts *= av_q2d(is-&gt;video_st-&gt;time_base);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir setzen das PTS auf Null, wenn wir seinen Wert nicht bestimmen können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das war einfach. Technischer Hinweis: Wie Sie sehen, verwenden wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für PTS. Dies liegt daran, dass der PTS als Ganzzahl gespeichert ist. Dieser Wert ist ein Zeitstempel, der der Zeitdimension in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">timebb entspricht</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn der Stream beispielsweise 24 Frames pro Sekunde hat, gibt PTS von 42 an, dass der Frame dort verwendet werden soll, wo der 42. Frame sein soll, vorausgesetzt, wir haben Frames alle 1/24 Sekunde ersetzt (dies muss natürlich nicht so sein tatsächlich). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können diesen Wert in Sekunden umwandeln, indem wir ihn durch die Bildrate dividieren. </font><b><font style="vertical-align: inherit;">Time_base</font></b><font style="vertical-align: inherit;"> Wert</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Stream ist gleich 1 geteilt durch die Framerate (für Inhalte mit einer festen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Framerate)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Um den PTS in Sekunden zu erhalten, multiplizieren wir ihn mit </font><b><font style="vertical-align: inherit;">time_base</font></b><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code weiter: Synchronisation und Verwendung von PTS</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt haben wir also alle fertigen PTS. </font><font style="vertical-align: inherit;">Jetzt werden wir uns um die beiden Synchronisationsprobleme kümmern, die etwas höher diskutiert wurden. </font><font style="vertical-align: inherit;">Wir werden eine Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronize_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definieren </font><font style="vertical-align: inherit;">, die den PTS aktualisiert, um mit allem zu synchronisieren. </font><font style="vertical-align: inherit;">Diese Funktion behandelt schließlich auch Fälle, in denen wir den PTS-Wert für unseren Frame nicht erhalten. </font><font style="vertical-align: inherit;">Gleichzeitig müssen wir verfolgen, wann der nächste Frame erwartet wird, damit wir die Aktualisierungsrate korrekt einstellen können. </font><font style="vertical-align: inherit;">Wir können dies mit dem internen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_clock-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wert tun </font><font style="vertical-align: inherit;">, der verfolgt, wie viel Zeit für das Video vergangen ist. </font><font style="vertical-align: inherit;">Diesen Wert fügen wir unserer großen Struktur hinzu:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span>
  <span class="hljs-keyword">double</span>          video_clock; <span class="hljs-comment">// pts of last decoded frame / predicted pts of next decoded frame</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronize_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die ziemlich klar ist:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">synchronize_video</span><span class="hljs-params">(VideoState *is, AVFrame *src_frame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">double</span> frame_delay;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(pts != <span class="hljs-number">0</span>) {
    <span class="hljs-comment">/* if we have pts, set video clock to it */</span><font></font>
    is-&gt;video_clock = pts;<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* if we aren't given a pts, set it to the clock */</span><font></font>
    pts = is-&gt;video_clock;<font></font>
  }<font></font>
  <span class="hljs-comment">/* update the video clock */</span><font></font>
  frame_delay = av_q2d(is-&gt;video_st-&gt;codec-&gt;time_base);<font></font>
  <span class="hljs-comment">/* if we are repeating a frame, adjust clock accordingly */</span>
  frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="hljs-number">0.5</span>);<font></font>
  is-&gt;video_clock += frame_delay;<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, berücksichtigen wir in dieser Funktion wiederholte Frames. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt wollen wir unsere richtige PTS erhalten und den Rahmen Warteschlange mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queue_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> durch einen neuen Zusatz - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Punkte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Argument </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
      pts = synchronize_video(is, pFrame, pts);<font></font>
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das einzige , </font><font style="vertical-align: inherit;">was Veränderungen in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queue_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist , </font><font style="vertical-align: inherit;">dass wir diese speichern </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wert </font><font style="vertical-align: inherit;">im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Videobild</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur , </font><font style="vertical-align: inherit;">dass wir Warteschlange. </font><font style="vertical-align: inherit;">Daher müssen wir die Variable </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur Struktur hinzufügen und diese Codezeilen hinzufügen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  ...<font></font>
  <span class="hljs-keyword">double</span> pts;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
  ... stuff ...<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
    ... convert picture ...<font></font>
    vp-&gt;pts = pts;<font></font>
    ... alert <span class="hljs-built_in">queue</span> ...<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt haben wir die Bilder mit den richtigen PTS-Werten in die Warteschlange gestellt. Schauen wir uns also unsere Video-Update-Funktion an. Sie können sich aus der letzten Lektion daran erinnern, dass wir es einfach gefälscht und ein Update von 80 ms installiert haben. Nun werden wir herausfinden, was wirklich da sein sollte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere Strategie ist es </font><font style="vertical-align: inherit;">durch einfaches Messen der Zeit zwischen den aktuellen Zeit der nächsten PTS zur Vorhersage </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Punkte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die vorherigen. Gleichzeitig müssen wir das Video mit Audio synchronisieren. Wir werden eine Audiouhr machen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Ein interner Wert, der die Position des abgespielten Audios verfolgt. Es ist wie eine digitale Anzeige auf jedem MP3-Player. Da wir das Video mit dem Ton synchronisieren, verwendet der Videostream diesen Wert, um herauszufinden, ob er zu weit vorne oder zu weit hinten liegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden später zur Implementierung zurückkehren. </font><b><font style="vertical-align: inherit;">Nehmen</font></b><font style="vertical-align: inherit;"> wir nun an, wir haben die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_audio_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das gibt uns Zeit auf der Audio-Uhr. Was ist zu tun, wenn Video und Audio nicht synchronisiert sind, sobald wir diesen Wert erhalten? Es wäre dumm, nur zu versuchen, durch eine Suche oder etwas anderes zum richtigen Paket zu springen. Stattdessen passen wir einfach den Wert an, den wir für das nächste Update berechnet haben: Wenn der PTS zu weit hinter der Audiozeit liegt, verdoppeln wir unsere geschätzte Verzögerung. Wenn der PTS der Spielzeit zu weit voraus ist, aktualisieren wir ihn einfach so schnell wie möglich. Nachdem wir die konfigurierte Aktualisierungs- oder Verzögerungszeit haben, werden wir sie mit der Uhr unseres Computers vergleichen und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frame_timer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> laufen lassen </font><font style="vertical-align: inherit;">. Dieser Frame-Timer fasst alle geschätzten Verzögerungen während der Filmwiedergabe zusammen. Mit anderen Worten, dieser </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frame_timer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dies ist die Zeit, die angibt, wann das nächste Bild angezeigt werden soll. Wir fügen dem Frame-Timer einfach eine neue Verzögerung hinzu, vergleichen sie mit der Uhrzeit auf unserem Computer und verwenden diesen Wert, um das nächste Update zu planen. Dies kann etwas verwirrend sein. Lesen Sie den Code daher sorgfältig durch:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
<font></font>
      delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="hljs-comment">/* the pts from last time */</span>
      <span class="hljs-keyword">if</span>(delay &lt;= <span class="hljs-number">0</span> || delay &gt;= <span class="hljs-number">1.0</span>) {
	<span class="hljs-comment">/* if incorrect delay, use previous one */</span><font></font>
	delay = is-&gt;frame_last_delay;<font></font>
      }<font></font>
      <span class="hljs-comment">/* save for next time */</span><font></font>
      is-&gt;frame_last_delay = delay;<font></font>
      is-&gt;frame_last_pts = vp-&gt;pts;<font></font>
<font></font>
      <span class="hljs-comment">/* update delay to sync to audio */</span><font></font>
      ref_clock = get_audio_clock(is);<font></font>
      diff = vp-&gt;pts - ref_clock;<font></font>
<font></font>
      <span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
	 FFPlay still doesn't "know if this is the best guess." */</span><font></font>
      sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;<font></font>
      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
	<span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
	  delay = <span class="hljs-number">0</span>;<font></font>
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
	  delay = <span class="hljs-number">2</span> * delay;<font></font>
	}<font></font>
      }<font></font>
      is-&gt;frame_timer += delay;<font></font>
      <span class="hljs-comment">/* computer the REAL delay */</span>
      actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="hljs-number">1000000.0</span>);
      <span class="hljs-keyword">if</span>(actual_delay &lt; <span class="hljs-number">0.010</span>) {
	<span class="hljs-comment">/* Really it should skip the picture instead */</span>
	actual_delay = <span class="hljs-number">0.010</span>;<font></font>
      }<font></font>
      schedule_refresh(is, (<span class="hljs-keyword">int</span>)(actual_delay * <span class="hljs-number">1000</span> + <span class="hljs-number">0.5</span>));
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir führen mehrere Überprüfungen durch: Erstens stellen wir sicher, dass die Verzögerung zwischen dem aktuellen PTS und dem vorherigen PTS sinnvoll ist. Wenn keine Verzögerung erforderlich ist, stimmen Audio und Video zu diesem Zeitpunkt überein und verwenden nur die letzte Verzögerung. Dann stellen wir sicher, dass die Synchronisationsschwelle erfüllt ist, da eine perfekte Synchronisation niemals stattfindet. FFplay verwendet einen Wert von 0,01 für den Schwellenwert. Wir stellen auch sicher, dass der Synchronisationsschwellenwert niemals kleiner als die Intervalle zwischen den PTS-Werten ist. Stellen Sie schließlich den minimalen Aktualisierungswert auf 10 Millisekunden ein (tatsächlich sollten sie den Frame hier überspringen, aber machen wir uns darüber keine Sorgen).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben der großen Struktur eine Reihe von Variablen hinzugefügt. Vergessen Sie also nicht, den Code zu überprüfen. </font><font style="vertical-align: inherit;">Vergessen Sie auch nicht, den Frame-Timer und die anfängliche Verzögerung des vorherigen Frames in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_component_open zu initialisieren</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">    is-&gt;frame_timer = (<span class="hljs-keyword">double</span>)av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
    is-&gt;frame_last_delay = <span class="hljs-number">40e-3</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sync: Audiouhr</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist an der Zeit, die Audiouhr zu realisieren. </font><font style="vertical-align: inherit;">Wir können die Zeit in unserer Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_decode_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aktualisieren </font><font style="vertical-align: inherit;">, in der wir das Audio dekodieren. </font><font style="vertical-align: inherit;">Denken Sie jetzt daran, dass wir nicht jedes Mal, wenn wir diese Funktion aufrufen, ein neues Paket verarbeiten. Es gibt also zwei Bereiche, in denen Sie die Uhr aktualisieren müssen. </font><font style="vertical-align: inherit;">Als erstes erhalten wir das neue Paket: Installieren Sie einfach die Sound Clock auf dem PTS-Paket. </font><font style="vertical-align: inherit;">Wenn das Paket dann mehrere Frames enthält, sparen wir die Audiowiedergabezeit, indem wir die Anzahl der Samples zählen und diese mit einer bestimmten Sampling-Frequenz pro Sekunde multiplizieren. </font><font style="vertical-align: inherit;">Also, wenn wir das Paket haben:</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">/* if update, update the audio clock w/pts */</span>
    <span class="hljs-keyword">if</span>(pkt-&gt;pts != AV_NOPTS_VALUE) {<font></font>
      is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und sobald wir das Paket bearbeiten:</font></font><br>
<br>
<pre><code class="cpp hljs">      <span class="hljs-comment">/* Keep audio_clock up-to-date */</span><font></font>
      pts = is-&gt;audio_clock;<font></font>
      *pts_ptr = pts;<font></font>
      n = <span class="hljs-number">2</span> * is-&gt;audio_st-&gt;codec-&gt;channels;<font></font>
      is-&gt;audio_clock += (<span class="hljs-keyword">double</span>)data_size /<font></font>
	(<span class="hljs-keyword">double</span>)(n * is-&gt;audio_st-&gt;codec-&gt;sample_rate);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein paar kleine Nuancen: Die Funktionsvorlage wurde geändert und enthält jetzt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts_ptr.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ändern Sie sie daher </font><b><font style="vertical-align: inherit;">unbedingt</font></b><font style="vertical-align: inherit;"> . </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der Zeiger , </font><font style="vertical-align: inherit;">dass wir sagen , </font><font style="vertical-align: inherit;">verwenden </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die audio_callback</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Audiopaket </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies wird beim nächsten Mal verwendet, um Audio mit Video zu synchronisieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt können wir endlich unsere Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_audio_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementieren </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es ist nicht so einfach , </font><font style="vertical-align: inherit;">wie Sie </font><font style="vertical-align: inherit;">den Wert bekommen </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_clock</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wenn man darüber nachdenkt. </font><font style="vertical-align: inherit;">Bitte beachten Sie, dass wir PTS-Audio jedes Mal einstellen, wenn wir es verarbeiten, aber wenn Sie sich die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_callback ansehen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird einige Zeit dauern, bis alle Daten aus unserem Audiopaket in unseren Ausgabepuffer verschoben sind. </font><font style="vertical-align: inherit;">Dies bedeutet, dass der Wert in unserer Audiouhr möglicherweise zu weit voraus ist. </font><font style="vertical-align: inherit;">Daher müssen wir überprüfen, wie viel wir schreiben müssen. </font><font style="vertical-align: inherit;">Hier ist der vollständige Code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_audio_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> hw_buf_size, bytes_per_sec, n;<font></font>
  <font></font>
  pts = is-&gt;audio_clock; <span class="hljs-comment">/* maintained in the audio thread */</span><font></font>
  hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
  bytes_per_sec = <span class="hljs-number">0</span>;<font></font>
  n = is-&gt;audio_st-&gt;codec-&gt;channels * <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span>(is-&gt;audio_st) {<font></font>
    bytes_per_sec = is-&gt;audio_st-&gt;codec-&gt;sample_rate * n;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(bytes_per_sec) {<font></font>
    pts -= (<span class="hljs-keyword">double</span>)hw_buf_size / bytes_per_sec;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Du solltest jetzt verstehen, warum diese Funktion funktioniert;) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also, das war's! </font><font style="vertical-align: inherit;">Wir kompilieren:</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial05 tutorial05.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es passierte! </font><font style="vertical-align: inherit;">Sie können den Film auf einem selbst erstellten Player ansehen. </font><font style="vertical-align: inherit;">In der nächsten Lektion werden wir uns mit der Audiosynchronisation befassen und dann lernen, wie man sucht.</font></font><br>
<br>
<h3><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFmpeg- und SDL-Handbuch oder Schreiben eines Videoplayers in weniger als 1000 Zeilen - Teil 2</font></font></a></h3><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übersetzungen im Edison Blog:</font></font></h3><div class="scrollable-table"><table>
<tbody><tr>
<td align="center"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img width="360" height="180" src="https://habrastorage.org/webt/fr/yz/q7/fryzq72v0ik0irt2q4orchflxvs.jpeg"></a></td>
<td align="center"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img width="360" height="180" src="https://habrastorage.org/webt/jv/3k/-f/jv3k-f5vi9drztohsh-e0t-puru.jpeg"></a></td>
</tr>
<tr>
<th align="center"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Top 50 Gaming-Franchise-Unternehmen </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mit über einer Milliarde Einnahmen</font></font></a></th>
<th align="center"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wird Airbnb das Coronavirus überleben? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Spoiler: ja]</font></font></a></th>
</tr>
</tbody></table></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de500386/index.html">Anpassung Ihrer vorhandenen Geschäftslösung an SwiftUI. Teil 2</a></li>
<li><a href="../de500390/index.html">Aktuelle Modelle der sprachlichen Lokalisierung im Bereich IT und digitale Kommunikation. Teil 1</a></li>
<li><a href="../de500396/index.html">Probleme autonomer Zugangskontrollsysteme - wo sie nicht erwartet hatten</a></li>
<li><a href="../de500398/index.html">Remote Marathon Woche 3: Inoperative Prozesse</a></li>
<li><a href="../de500400/index.html">Trimmen von Threads: Migration von Puppet Enterprise zu Ansible Tower. Teil 1</a></li>
<li><a href="../de500404/index.html">Wie man Freunde findet Electron und Webix. Teil 2. Erstellen Sie eine Anwendung mit Ihrer Ansicht</a></li>
<li><a href="../de500406/index.html">Die Geschichte der ersten Lähmung des Internets: Der Fluch des Besetztzeichens</a></li>
<li><a href="../de500408/index.html">Glück in Armut</a></li>
<li><a href="../de500410/index.html">Spiel erstellen *</a></li>
<li><a href="../de500414/index.html">3D CNC Maschine oder alles ist schon vor uns erledigt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>