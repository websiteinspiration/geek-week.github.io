<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕸️ 👨‍🚒 📭 内置于1970年代AMD的Am2901多芯片分区微处理器 👨🏼‍✈️ 🧜🏽 🙅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在1970年代AMD Am2901多芯片分区微处理器中，
 
 您可能熟悉Advanced Micro Devices制造的高级处理器。但是，AMD在1975年首次推出其Am2901时就开始生产处理器。就是所谓的多芯片分段处理器：每个芯片处理4位，并且为了增加字长，同时使用了几个芯片。这种方法在19...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>内置于1970年代AMD的Am2901多芯片分区微处理器</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498568/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在1970年代AMD Am2901多芯片分区微处理器中，</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可能熟悉Advanced Micro Devices制造的高级处理器。但是，AMD在1975年首次推出其Am2901时就开始生产处理器。就是所谓的多芯片分段处理器：每个芯片处理4位，并且为了增加字长，同时使用了几个芯片。这种方法在1970年代和1980年代用于创建16、32或64位处理器（例如），因为他们无法将整个处理器放在一个快速芯片上。在同一芯片上有处理器，但是它们的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">晶体管工作较慢。随着时间的流逝，CMOS处理器变得比双极晶体管处理器更快，并且当它们的速度足够长时，几乎所有制造商都转向了它们。</font><i><font style="vertical-align: inherit;">带有Am2901芯片的晶体照片。芯片的金属层可见。硅在底部。在晶体的边缘，微小的导体将芯片与外部触点相连。</font></i></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/pu/kb/yt/pukbytzadj8mboqwhicko7mpdia.jpeg"></a><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am2901芯片获得了极大的欢迎，它被用于各种系统，从Battlezone视频游戏到VAX-11 / 730微型计算机，从Xerox Star工作站到F-16战斗机的机载Magic 372计算机。该处理器的更快版本Am2901C使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发射极耦合逻辑</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ESL）来提高性能。在本文中，我将剖析Am2901C，在显微镜下检查其晶体，并说明ESL电路如何实现算术逻辑单元（ALU）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顺便说一句，在Atari Battlezone的文档中没有提及Am2901芯片的特定型号，但是有一个零件编号137004-001的脚注，他们称为“晶体管阵列”。</font><font style="vertical-align: inherit;">此外，在给定的芯片引脚排列图中进行了故意的变形，并显示了20个地址引脚和8个数据引脚，使该芯片看起来像ROM（例如，与确切描述的7400系列芯片不同）。</font><font style="vertical-align: inherit;">Atari可能试图通过隐藏一些关键芯片的模型来防止其视频游戏的克隆。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在许多微型计算机中，Am2901的一种流行替代方案是</font><font style="vertical-align: inherit;">ALU </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">74181</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">芯片</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它提供了与Am2901相同的算术和逻辑功能，但没有提供其寄存器。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多芯片分段微处理器</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可能想知道几个处理器芯片如何协同工作并支持任意长度的字。最重要的是，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">微处理器部分</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（MS）是一块积木，而不是整个处理器，并且它需要单独的电路来解码指令和控制系统。 MS有寄存器，它们对数据进行算术和逻辑运算，控制芯片（例如Am2901）告诉MS怎么做。每条机器指令均分为较小的步骤，微指令存储在ROM微代码中。在这种情况下，指令集是由微码而不是Am2901确定的，因此</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几乎</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以支持</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">任何指令集</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于这样的处理器中的部分不是彼此完全独立的事实，因此在处理器的操作期间会出现某些困难。例如，在将两个数字相加时，必须将一个部分的传输转移到另一部分。而且，几个部分的联合工作需要诸如检查符号或检查零结果之类的操作。 Am2901芯片具有支持这些功能的特殊输出。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am2901是微处理器吗？从我的角度来看，Am2901只是处理器的一部分，但这完全取决于如何确定“微处理器”（我在</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">另一篇文章</font></a><font style="vertical-align: inherit;">中详细介绍了我的想法）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）有趣的是，在苏联，与美国相比，他们更倾向于分段微处理器。而且，在西方，“微处理器”一词通常是指单个芯片上的处理器，而在苏联，单个芯片上或从几个部分中的处理器</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常是无法区分的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多芯片分段微处理器（MSM）位于微处理器芯片和由简单</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">TTL</font></a><font style="vertical-align: inherit;">制成的计算机之间的中间位置</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">筹码。</font><font style="vertical-align: inherit;">当时，用TTL芯片组装计算机要比制造微处理器快得多，但这需要大量带有芯片的电路板。</font><font style="vertical-align: inherit;">MSM的使用可以保持速度优势，同时减少使用的芯片数量。</font><font style="vertical-align: inherit;">与微处理器相比，MSM还提供了更大的灵活性，从而使设计人员可以自定义指令集和其他体系结构功能。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水晶概述</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下图显示了Am2901晶体，并突出了关键的功能块。对于这张照片，我去除了金属层，以便可以看到硅和晶体管。芯片的最大功能块是中央的寄存器存储器。该芯片具有16个4位寄存器（您可以在存储阵列中看到16列和4行）。在存储块的左右两侧是用于控制写入和读取的存储驱动器电路。</font><i><font style="vertical-align: inherit;">光电晶体Am2901;标记了关键功能块。外部电路主要由在外部TTL和内部ESL之间转换信号的缓冲器组成。</font></i><i><font style="vertical-align: inherit;">Am2901完整流程图</font></i></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/yo/3q/wx/yo3qwxlpuizsyweaio3_r95owtm.jpeg"></a><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/dp/m4/x8/dpm4x8wwtf1uv6-_6-shxaqnpzk.jpeg"></a><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
芯片的算术逻辑器件（ALU）从事算术（加法和减法）和逻辑运算（AND，OR，不包括OR）。 ALU的第一部分在左下角是一个大块；由于它是4位ALU，因此它由四行组成。 ALU还具有生成进位输出以进行加法运算的逻辑，并使用一种称为“进位超前”的快速技术。然后，ALU使用传输的值并行生成总和。最后，输出电路处理并缓冲量，然后将其发送到输出触点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
带有预览的传输使用“生成”和“传播”信号来确定每个位置上的某个位是产生自己的传输还是传递传入的传输。例如，如果您添加0 + 0 + C（C是传输），则无论其大小如何，都无法从此加法中删除该传输。另一方面，如果添加1 + 1 + C，无论C是什么，无论如何都会出现转移。最后，在0 + 1 + C（或1 + 0 + C）的情况下，转移将进一步转移如果C为非零。结果，如果两个位都不等于1，则简单的逻辑门将为每个位生成G（生成）信号，如果两个位均不等于0，则简单逻辑门将为P（传播）信号。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
传输公式取决于位的位置。例如，考虑从位0到位1的传输。如果设置了P0标志（即，已经发生或正在传输），并且该传输已经出现在该位中，或者它是从其他位传来的，则将发生这种情况。然后C1 = P0 AND（Cin或G0）。在高阶连字中，选项的数量在增加，其复杂性也在不断增加。例如，考虑到第2位的传输。首先，必须将P1塞住，以便从第1位开始传输。此外，该传输是由第1位创建的，还是从第0位传输的。最后，第一个传输也必须来自某处接受它：它要么是来自位0的传输，要么是位1生成的传输。如果将所有这些都放到公式中，您将获得Am2901中使用的函数：C2 = P1 AND（G1 OR P0）AND（C0 OR G0 OR G1）。给出了不同转移的公式以及外部P和G</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规格</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，图 </font><font style="vertical-align: inherit;">9. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
芯片边缘的空白矩形是将芯片连接到外部世界的区域。</font><font style="vertical-align: inherit;">它们旁边是用于发送和接收信号的方案。</font><font style="vertical-align: inherit;">特别是，由于芯片使用TTL信号与外部电路通信，但内部使用ESL，因此这些电路在TTL和ESL电压之间转换。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该芯片具有两个移位寄存器，能够将字右移或左移一位。</font><font style="vertical-align: inherit;">寄存器Q-基于触发器的4位寄存器。</font><font style="vertical-align: inherit;">最后，参考电压电路会生成ESL操作所需的精确参考电压。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何看水晶</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要查看芯片内部，通常必须将其塑料外壳溶解在有害酸中。但是，我不是在塑料盒中购买Am2901芯片，而是在陶瓷盒中购买。我只是用凿子沿着芯片的接缝走，将两半断开，这使我得以进入内部的晶体。硅晶体是芯片中心的一个小矩形。细导体将晶体焊盘连接到引线框架，从而引出40个外部芯片触点。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/99c/129/fc7/99c129fc7bb08492909208f99eac8fea.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">断开陶瓷主体的两半后，Am2901</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
为了获得芯片的高分辨率照片，我使用了特殊的金相显微镜。在下面的照片中，您可以看到AMD徽标。上方是焊接到现场的导体。该芯片具有两个金属层，可形成一个电路，如右图所示。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a44/50c/7ed/a4450c7edec0f7da45e3ae37c0feedd6.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以看到芯片的特写照片-铭文4301X（可能是零件号）和“ 1983 AMD”。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
我从几张小显微镜图像中收集了一张高分辨率的大照片（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解有关创建水晶照片的更多信息</font><font style="vertical-align: inherit;">）。然后，我去除了金属层并拍摄了另一组硅照片。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下面的特写照片显示了四个晶体管和三个电阻器。有机硅的不同区域具有不同的杂质，赋予它们不同的性能，这些区域在显微镜下可见。该芯片基于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">双极性</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NPN晶体管不同于现代计算机的MOS晶体管。</font><font style="vertical-align: inherit;">基极晶体管（p型硅），发射极（n型硅）和集电极（n型硅）标在左侧晶体管[B，E，C]上。</font><font style="vertical-align: inherit;">浅矩形是硅和曾经位于顶部的金属层的接触点。</font><font style="vertical-align: inherit;">右边的两个晶体管有一个公共的大集电极。</font><font style="vertical-align: inherit;">在该芯片上，经常发现具有公共集电极的晶体管。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/93f/bb8/ea9/93fbb8ea97a759777c91b35f81cac472.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是三个电阻。</font><font style="vertical-align: inherit;">通过向硅添加杂质来增加电阻，从而获得电阻器。</font><font style="vertical-align: inherit;">IC中电阻器的精度通常很差。</font><font style="vertical-align: inherit;">它们也变得相对较大-在这里它们与晶体管的尺寸相同，而其他晶体管则更大。</font><font style="vertical-align: inherit;">因此，在设计IC时，它们会尽量减少电阻器的数量。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发射极相关逻辑</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以以非常不同的方式创建逻辑方案。几乎所有现代计算机都使用CMOS逻辑系统（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">互补的金属氧化物半导体结构</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），其中的阀门由MOS晶体管组成。在小型计算机时代，TTL非常流行。 ESL是一种更快但不常见的方案。 ESL的缺点是能耗大（1985年的Cray-2超级计算机使用ESL阀门来提高速度，但必须用液态氟利昂冷却）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESL在速度方面的大多数优势是由于晶体管没有完全导通的事实。这允许晶体管非常快速地改变电流路径。此外，值0和1的电压之间的差异很小（约为0.8 V），因此信号可以很快地来回切换。例如，在TTL阀中，电压差约为3.2 V（信号可以以每纳秒1 V左右的速度切换，因此，电压差较大时，会有几纳秒的延迟）。另一方面，小的电压差导致ESL对电噪声的敏感性增加。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am2901的第一个版本使用TTL，但1979年AMD推出了更快的版本Am2901C。 Am2901C内部使用ESL来提高速度，但在外部却保持TTL电压，因此易于在TTL计算机中使用。这篇文章介绍了Am2901C变体。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESL基于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">差分对</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系统</font><font style="vertical-align: inherit;">- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运算放大器的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工作方式类似</font><font style="vertical-align: inherit;">。差分对（见下文）的想法是，固定的感觉根据方案流动。如果左侧输入端的电压大于右侧输入端的电压，则左侧晶体管将导通，并且大部分电流将流经左侧分支。反之亦然（请注意，已连接晶体管发射极-因此，发射极耦合逻辑的名称。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6a8/0d4/cd6/6a80d4cd63452c64136a0eccfbd6f019.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">差分对。如果左输入（红色）上的电压较高，则大部分电流将沿着左路径流动，反之亦然。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
一些修改允许您将差分对转换为ESL阀。首先，一个分支中的电压是固定的，并在0和1级之间的间隔中的某个位置成为参考电压。然后，如果输入高于参考电压，则将其视为1，如果低于-则将其视为0。然后，将输出连接至分支晶体管（绿色），通过缓冲支路的电压提供输出信号。逆变器电路如下图所示，因为如果输入电压高，则流过左电阻器的电流会将输出拉低。为了提高性能，较低的电阻器被由晶体管和电阻器组成的漏极（品红色）代替。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，ESL阀底部的漏极提供了恒定的电流，该电流由输入电压V </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CS控制</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。该选项比简单的电阻器更好，因为流经电阻器的电流随电压和输入电压而变化。而且，这种电路节省了空间，因为它使用了较小的电阻器。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a50/362/b74/a50362b747b4d72ac7a32878ea505b38.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESL逆变器。右上电阻器可以省略，因为它没有连接到任何地方。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以通过添加更多输入来构建更复杂的ESL阀。在下图中，平行于第一个输入晶体管（1）添加了第二个输入晶体管（2）。如果输入A或B上有1，电流将流经电阻R1（即，电压将高于参考电压）。在这种情况下，输出被下拉，我们得到了NOR阀。使用其他配置，您可以制作AND，XOR阀或更复杂的电路。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c59/97e/883/c5997e883d922023dc92fc0984dfbb74.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESL NOR阀</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上图显示了NOR门-例如在芯片上实现的。下图显示了阀门的相应物理图。左侧是一个硅晶体层，其中可以看到晶体管和电阻器。右侧是芯片同一部分的金属走线。上方是接收输入信号的晶体管1和2。它们每个在顶部都有一个底座，在中间有一个发射器。晶体管具有一个公共的集电极-下方的白色矩形。电阻R1和R2是硅的矩形。中间的所有晶体管（包括3个和4个）都有一个公共集电极，两次连到正号（未编号的晶体管和电阻器属于其他阀）。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/838/b90/f81/838b90f8170aa8d5b1be9d84a55fa103.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于Am2901晶体的NOR阀</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从右边的导体可以看出，顶层提供了水平导体到正，参考电压，VCS漏极和负的连接（可以看到正和负的宽度变宽以支持大电流）。</font><font style="vertical-align: inherit;">下方是连接晶体管的导体。</font><font style="vertical-align: inherit;">从上方，输入A和B连接到晶体管的基极。</font><font style="vertical-align: inherit;">其余的布线更难追踪，因为它被顶层覆盖。</font><font style="vertical-align: inherit;">但是，例如，您可以看到晶体管4，晶体管1和2的集电极与R1之间的连接。</font><font style="vertical-align: inherit;">通过仔细研究晶体的照片，您可以了解所有布线并对芯片逻辑进行反向工程。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算术逻辑单元（ALU）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am2901芯片中的算术逻辑单元（ALU）执行4位算术或逻辑运算。它支持8种不同的运算：加，减和按位逻辑运算（它不涉及乘法和除法）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下面的框图显示了AL29 Am2901的结构。首先，选择器（多路复用器）从潜在源中选择两个输入。 D的值通常传输到芯片的数据触点，通常传输到处理器数据总线。 A-这是芯片寄存器文件中16个条目之一的值，由触点A0-A3选择； B以类似的方式工作。常数0可以输入ALU。最后，Q是Q寄存器（可选的单独寄存器）的内容。许多数据源使芯片具有更大的灵活性。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d9a/9aa/586/d9a9aa586257e3e6db1eae6c243ac345.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">芯片规格的ALU Am2901框图。 ALU在两个4位输入R和S上执行八种功能之一。右侧是芯片的各种输出：G，P，进位输出，符号，溢出，零测试。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
R和S这两个选定值被馈送到ALU，ALU执行选定的运算并将结果输出到F。此外，ALU接受进位量并传输进位值（CN + 4） ;这使您可以组合多个ALU来处理更长的单词。输出G和P用于预览传输，零的符号，溢出和测试可用作条件处理器代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从选择器开始简要描述ALU电路。选择器下面的前两个框（D和A）选择ALU的第一个参数，最后三个框（A，Q和B）选择第二个参数。每个选择器都实现“选择•（值⊕反转）”功能，其中“值”是潜在的输入值，“选择”为1以选择该值，“反转”为1以反转该值（因为ALU为4位，所以选择了4位；每个选择器都使用4个实现ESL阀）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过包括选择行之一来选择所需的值。如果它们都未打开，则到达ALU的值将为0。芯片通过相加后的值进行减法运算。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/323/a63/462/323a6346266c7a1116638ebd7e18f7fe.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ALU的第一部分由四个水平层组成，每位一个</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下图显示了ALU AM2901中使用的AND-XOR电路，该电路实现了运算A'•（B⊕C）。我将简要描述它的工作原理。如果输入A的电压高，则电流流过左晶体管，从而将输出拉低。如果B和C为高电压，则流过左晶体管B和C的电流将输出拉低。如果V和C上的电压较低，则流经晶体管V </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ref</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的电流</font><font style="vertical-align: inherit;">会将输出拉低。如果B和C的电压不同，则电流来自晶体管+，输出保持高电压。最重要的是，单个ESL阀可以实现复杂的功能。对于大多数逻辑门，XOR难以实现。就我个人而言，ESL逻辑类似于1920年代的继电器，因为它在两条电流路径之间切换，而不仅仅是打开和关闭。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3j/oq/iu/3joqiu-d6qnv7rewldbmxg0m000.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为ALU选择两个输入后，它将为每对输入位计算“传播”（P）和“生成”（G）位。这是用于快速添加的预览传输过程的一部分。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下图显示了ALU电路的其余部分（作为更改，该图具有金属层，这与以前的图不同，后者仅包含硅）。来自先前电路的信号P和G传递到两个传输计算模块中。下层传输单元通过几个芯片的预览来计算外部P，G和传输信号。这使您可以快速添加长字。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
具有预览功能的传输技术可以在多个芯片上实现，以快速添加大于4位的数字。每个芯片都会生成“生成”和“传播”信号，告诉它是生成传输还是传输传入的传输。这些信号与带有预览功能的传输生成器芯片（例如Am2902）组合在一起。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上层传输单元计算内部传输。 ``和''方案使用连字符和P和G的值计算每个位的总和。重要的是，由于存在连字符连字符，因此可以并行计算每个位的总和。最后，输出电路将内部ESL信号转换为TTL信号，并控制四个输出触点。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f4c/aff/c1f/f4caffc1fc927034efc1e722d61e98a2.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其余的ALU电路</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该芯片使用一些有趣的技术，使您可以使用加法器进行八次操作。前面描述的选择器电路可以选择补充其输入。这用于减法以及某些逻辑功能。在计算逻辑功能时（而不是加/减），传输计算被禁用。在逻辑运算期间，其他位不会受到影响。最终，通过将P信号增加到最大，加法器的XOR电路变成AND电路。因此，该芯片不使用八个不同的电路来执行八个ALU操作，而是使用一个经过精心选择的调整的单个电路。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
芯片使用P和G的值生成带有进位C的输入R和S的总和。总和（R⊕S⊕C）'计算为（（P'∨G）⊕C）'，其中P =R∨S，并且G = R•S。如果P等于1，则（P'∨G）减小为G等于R•S。事实证明，通过更改P，可以使用同一电路从R和S的输入值计算AND。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下表显示了ALU执行的8个操作。三位指令被馈送到芯片，并用于选择操作：I5，I4和I3。 “功能”列显示了根据文档的功能，“计算”列显示了如何计算每个位。请注意，所有运算最终都会简化为异或（⊕）或与（∧）。通过两个自变量和进位的按位XOR进行加法运算。减法通过参数的加法和随后的加法来进行。例如，加补码R（R'）与减R相同。位I3补R，位I4补S。异或运算（EXOR和EXNOR）使用与加法​​相同的元素，但与转移计算锁定。通过阻断信号G来执行与运算。最后，根据de Morgan律R'∧S'计算OR。=（R∨S）'。关键是Am2901不需要单独的元素进行加，减，AND，OR和EXOR-每个操作中都使用大多数元素。</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">符号表示法</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I5</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I4</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I3</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">功能</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计算方式</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R加s</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R⊕S⊕携带</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">苏比</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">减</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R'S⊕随身携带</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SUBS</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">负负</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R⊕S'⊕随身携带</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要么</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（R'∧S'）⊕1</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R和S</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">∧</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公告</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">兰德</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">∧</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXOR</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R EX或S</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R⊕S'⊕1</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异样</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R EX NOR S</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R'⊕S'⊕1</font></font></td>
</tr>
</tbody></table></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am2901C芯片作为高速ESL（一个相对罕见的逻辑系列）的示例而受到关注。</font><font style="vertical-align: inherit;">ALU芯片分布在该芯片的底部，实现八个不同的功能，并使用预览传输来加快工作速度。</font><font style="vertical-align: inherit;">尽管芯片非常复杂，但在显微镜下仔细检查有助于理解其工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1970年代和1980年代，微型计算机和许多其他系统中使用了Am2901等多芯片分段处理器。</font><font style="vertical-align: inherit;">但是，最后，CMOS技术的改进使快速处理器可以在单个芯片上实现，从而使该技术过时了。</font><font style="vertical-align: inherit;">虽然Am2901可能包含约一千个晶体管，并且运行在16 MHz，但今天AMD生产的处理器包含数十亿个晶体管，工作在4 GHz。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN498556/index.html">汉斯·彼得·伦（Hans Peter Lun）和哈希算法的诞生</a></li>
<li><a href="../zh-CN498560/index.html">实际项目中的Web组件</a></li>
<li><a href="../zh-CN498562/index.html">与隔离相反：我们如何将实习转换为远程格式</a></li>
<li><a href="../zh-CN498564/index.html">Mobile的渲染优化，第2部分。现代移动GPU的主要系列</a></li>
<li><a href="../zh-CN498566/index.html">弹性工程：REDeploy会议的笔记</a></li>
<li><a href="../zh-CN498572/index.html">折扣难得？过渡到udalenka之际的CRM供应商份额</a></li>
<li><a href="../zh-CN498574/index.html">为什么我决定开发游戏，还是怀旧之旅？</a></li>
<li><a href="../zh-CN498576/index.html">我们如何开发在Messenger（Gem4me）中输入新消息的领域</a></li>
<li><a href="../zh-CN498580/index.html">定量分析断层图像上的“碗效应”</a></li>
<li><a href="../zh-CN498582/index.html">在ExoPlayer中获取和切换WebVTT字幕</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>