<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✌️ 🧜🏻 👨🏿‍🎓 Warum gewinnt Flutter? 🔠 🕯️ 👩‍👦‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Letztes Jahr habe ich sowieso Flutter-Apps für iOS und Android geschrieben. Davor hatte und habe ich 5 Jahre Erfahrung mit Xamarin. Es waren wundervol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Warum gewinnt Flutter?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501340/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Letztes Jahr habe ich sowieso Flutter-Apps für iOS und Android geschrieben. </font><font style="vertical-align: inherit;">Davor hatte und habe ich 5 Jahre Erfahrung mit Xamarin. </font><font style="vertical-align: inherit;">Es waren wundervolle 5 Jahre. </font><font style="vertical-align: inherit;">Dank Xamarin und meiner Liebe zu diesem Framework bin ich im Prinzip in das Entwicklerlager gezogen. Mit diesem Tool konnte ich viel Geld und Wissen verdienen und wunderbare Kollegen finden. </font><font style="vertical-align: inherit;">Warum schreibe ich jetzt auf Flutter? </font><font style="vertical-align: inherit;">Kurze Antwort, denn Flutter deckt alle Anforderungen der plattformübergreifenden Entwicklung ab.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qo/ua/rw/qouarwd80cvkhylqpiukpop86n8.jpeg"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein bisschen Geschichte</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Korrigieren Sie mich, wenn ich falsch liege, aber 2009 war in vielerlei Hinsicht der Schlüssel für die mobile Entwicklung im Allgemeinen und die plattformübergreifende Entwicklung im Besonderen. Im Jahr 2009 wurde das iPhone 3gs veröffentlicht, mit dem Sie Anwendungen von Drittanbietern im AppStore ausführen können. Zum ersten Mal erschien diese Gelegenheit ein Jahr zuvor im iPhone 3g, aber 3gs ist zu einem wirklich massiven, „beliebten“ iPhone geworden. Ein Jahr zuvor, im September 2008, wurde Android erneut der Öffentlichkeit vorgestellt, und 2009 begannen viele Telefonhersteller, Android für ihre neuen Telefonmodelle auszuprobieren. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Frühjahr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2009 führte Nitobi PhoneGap ein, ein neues Framework zum Erstellen plattformübergreifender Anwendungen auf Basis von HTML5, CSS und JS. Im selben Jahr, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im September</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ximian hat MonoTouch veröffentlicht, mit dem Sie iOS-Anwendungen mit Mono und C # schreiben können. Im selben Jahr 2009, im Dezember, veröffentlichte Rovio Entertainment ein Spiel für iOS und für einen Moment für Maemo, das in vielerlei Hinsicht den Beginn der Handyspielbranche markierte - Angry Birds. Das letzte Beispiel hier ist nicht zufällig.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste plattformübergreifende Framework "für die Menschen" kann als PhoneGap betrachtet werden (Qt-Entwickler werfen keine Steine). Es war eine wunderbare und sehr offensichtliche Idee, das Web in die Welt der mobilen Entwicklung zu bringen. Bis 2009 gingen die Funktionen des Webs bereits über den Browser hinaus ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hallo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> node.js), während das Schreiben von Webanwendungen in JS ziemlich einfach war. Der zweite, nicht weniger wichtige Punkt ist das Rendern der Benutzeroberfläche. Die Art und Weise, wie das Rendern erfolgt, liegt bei der Browser-Engine, und alle diese Engines folgen mehr oder weniger den W3C-Standards für HTML, CSS und DOM. Jeder Webentwickler, der eine Website erstellt hat, erwartet, dass seine Website </font><s><font style="vertical-align: inherit;">fast</font></s><font style="vertical-align: inherit;"> so aussieht</font></font><s><font style="vertical-align: inherit;"></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">identisch in jedem Browser, auf jeder Plattform. Dies ist meiner Meinung nach der wichtigste Aspekt des Web als offene Plattform. Warum sollte ich für jede Plattform eine neue Sprache / ein neues Framework zum Zeichnen der Benutzeroberfläche lernen, wenn es seit langem einen Standard für die Modellierung der Benutzeroberfläche für verschiedene Browser gibt?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Danach drehte sich Cordova von PhoneGap und von Ionic ab. Es scheint, dass dies ein idealer Rahmen ist, aber es gab zwei Punkte: Leistung und Betriebssystemintegration. Eines der Hauptziele oder, wenn Sie möchten, Anwendungsbenchmarks, die für plattformübergreifende Lösungen geschrieben wurden, war ihre "Ursprünglichkeit". Jene. Im Idealfall sollten 100% der Benutzer berücksichtigen, dass Ihre plattformübergreifende Anwendung nativ ist. Und das bedeutet, dass es wie native aussehen sollte, wie native funktionieren und alle möglichen Integrationen mit dem Betriebssystem haben sollte. Am Anfang waren all diese Punkte für PhoneGap unerreichbar, die Kapazitäten von Smartphones vor 10 Jahren reichten für das Rendern der Benutzeroberfläche mit 60 fps nicht aus, die Integration in das Betriebssystem war minimal. Jetzt gibt es auf Ionic einige Anwendungen, die schwer von nativen zu unterscheiden sind, aber die Nachahmung einer nativen Anwendung ist immer noch eine Aufgabe.und nicht als solche gegeben. Lassen Sie uns ein wenig zusammenfassen. Das Schreiben von Webanwendungen bzw. Hybridanwendungen auf iOS und Android ist möglich und bequem. Dies ist praktisch, da der UI-Rendering-Mechanismus vollständig auf der WebView-Plattform liegt und es bereits eine geschulte Schicht von Programmierern gibt, die sich im Web gut auskennen.</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Hybridanwendungen können Leistung und Betriebssystemintegration jedoch lahm sein.</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Gleichzeitig mit PhoneGap wurde 2009 MonoTouch gestartet, das später in Xamarin.iOS umbenannt wurde. Im selben Jahr wurde auch Titan veröffentlicht, was wiederum das Schreiben von iOS-Anwendungen auf Javascript ermöglichte. Zunächst arbeitete Titanium genau nach dem gleichen Paradigma wie PhoneGap - basierend auf WebView. Aber dann haben sie den Xamarin-Ansatz gewählt. Was ist dieser Ansatz? Es kann als etwas in der Mitte gesehen werden. Der Ansatz von Xamarin / Titanium / React.Native besteht darin, dass das Framework nicht versucht, Ihr / vorhandenes UI-Rendering zu erstellen / zu migrieren, sondern einfach in das vorhandene native integriert wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anstatt ein Formular in HTML zu zeichnen, ruft Xamarin hierfür ein natives UI-Element auf (UITextField, TextEdit usw.). Warum das Rad neu erfinden? Alle erforderlichen UI-Elemente sind in nativen SDKs und Laufzeiten vorhanden. Sie müssen lediglich lernen, wie Sie von Ihren VMs (Mono, Version 8 usw.) mit ihnen kommunizieren. Gleichzeitig können Sie, wie Sie bereits vermutet haben, Ihr bevorzugtes C #, JS, TS, F #, Kotlin usw. verwenden, und gleichzeitig ist Code, der nicht direkt mit der Benutzeroberfläche interagiert, zu 100% plattformübergreifend. Sie können noch weiter gehen. Dasselbe UITextField und TextEdit sind konzeptionell identische Entitäten, sie haben einige ähnliche Eigenschaften und Interaktionsschnittstellen. Daher können Sie einen abstrakten Eintrag erstellen (Hallo Xamarin.Forms) und nur selten damit arbeiten ( </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht sehr)</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Ausnahme, die sich auf das Element der Plattform-Benutzeroberfläche bezieht. Ich erwähne nicht, dass, wenn Ihre VM nativ mit der Benutzeroberfläche arbeiten kann, Ihre VM höchstwahrscheinlich alle Plattform-APIs aufrufen kann. Dies scheint die perfekte Option zu sein. Native Benutzeroberfläche, native Leistung (hi Bridges in React.Native), 100% Betriebssystemintegration. Ist das wirklich perfekt? Höchstwahrscheinlich - nein, und das Problem ist, dass </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese Lösungen in Wirklichkeit das Problem der plattformübergreifenden Entwicklung nicht lösen - eine einzige Benutzeroberfläche. Sie verkleiden sie</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ich möchte einmal schreiben, überall laufen. Dies ist bei weitem nicht das beste Motto für alle Arten von Programmen und Problemen, passt aber gut zur Benutzeroberfläche. Ich möchte die Benutzeroberfläche für alle gleich schreiben, unabhängig von der Plattform. Warum kann sich ein Webentwickler erlauben, mit HTML und CSS eine Site zu schreiben, die dann in Safari unter iOS und Chrome unter Android auf dieselbe Weise angezeigt wird, aber kein nativer Entwickler?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich haben Programmierer seit langem eine leistungsstarke Benutzeroberfläche mit einer gemeinsamen Codebasis für iOS und Android geschrieben. Diese Programmierer werden Spieleentwickler genannt. Angry Birds wurde für die Cocos2d-x-Engine, Cuphead für Unity und Fortnite für Unreal Engine geschrieben. Wenn Game Engines atemberaubende Szenen auf Ihrem Handy anzeigen können, können Schaltflächen und Listen mit flüssiger Animation dies auf jeden Fall. Warum benutzt sie niemand in diesem Sinne? Die Antwort ist einfach und banal, sie sind nicht dafür gedacht. Wenn Sie das Spiel öffnen, hängt es absolut von der Taschenlampe ab, wie sehr die Benutzeroberfläche wie eine native aussieht. Sie müssen fast nie mit Geolokalisierung, Drucktasten, einer Videokamera usw. interagieren. Während Sie spielen, leben Sie ein anderes Leben in Ihrer kleinen Welt, das durch Canvas in Ihrem UIViewController / Ihrer Aktivität gerendert wird. deshalb</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game-Engines sind relativ schlecht in das Betriebssystem integriert</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , daher gibt es keine (oder ich habe nicht gesehen) Nachahmung der nativen UI-Top-Engine.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwischensummen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für ein ideales plattformübergreifendes Framework benötigen wir:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Native UI-Zuordnung </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Native UI-Leistung </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% ige Fähigkeit, jede Betriebssystem-API aufzurufen, als wäre es eine native Anwendung </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie denken jetzt, dass ich unter Flutter anfangen werde zu scheitern, aber ich höre bereits wütende Kommentare: „Wo ist Qt !? </font><font style="vertical-align: inherit;">Er kann das alles! “ </font><font style="vertical-align: inherit;">In der Tat entspricht Qt bis zu dem einen oder anderen Grad diesen Kriterien. </font><font style="vertical-align: inherit;">Obwohl ich den ersten stark bezweifle. </font><font style="vertical-align: inherit;">Das Hauptproblem von Qt ist jedoch nicht die Schwierigkeit, eine native Benutzeroberfläche zu schreiben. Das Hauptproblem ist C ++. </font><font style="vertical-align: inherit;">Dann wische ich mir schon das Gesicht von der Spucke der Labour-Encoder auf den Pluspunkten. </font><font style="vertical-align: inherit;">Pros ist ein Schweizer Messer gegen Anabolika, mit den Profis kann man alles machen. </font><font style="vertical-align: inherit;">Aber ich als Frontend-Entwickler brauche das alles nicht. </font><font style="vertical-align: inherit;">Ich brauche eine einfache und verständliche Sprache, die mit UI und I / O funktioniert. </font><font style="vertical-align: inherit;">Zu unseren drei obigen Punkten wurde also Folgendes hinzugefügt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leicht zu lernen und sehr ausdrucksstarke Sprache </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rantime, die gut in das Frontend-Entwicklungsparadigma passt </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, da wir einige Metriken eines guten plattformübergreifenden Tools für die Entwicklung mobiler Anwendungen hervorgehoben haben, können wir uns jedes einzelne davon ansehen und sehen, wie es in Flutter implementiert ist.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Native UI-Zuordnung</font></font></h4><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ir/oi/wf/iroiwftbrxuuh_35cjdasl7sgkc.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie wir zuvor herausgefunden haben, gibt es zwei entgegengesetzte Ansätze für die Arbeit mit der Benutzeroberfläche in plattformübergreifenden Frameworks. </font><font style="vertical-align: inherit;">Dies ist ein UI-Rendering mit WebView oder nativen UI-Elementaufrufen auf jeder Plattform. </font><font style="vertical-align: inherit;">Jeder Ansatz hat Vor- und Nachteile. </font><font style="vertical-align: inherit;">Sie decken jedoch nicht alle Entwickleranforderungen ab: Sie unterscheiden sich nicht von der nativen Benutzeroberfläche + der nativen Leistung. </font><font style="vertical-align: inherit;">Flutter deckt all diese Bedürfnisse mit einem Kopf ab. </font><font style="vertical-align: inherit;">Das Flutter-Team hat eine bestimmte Menge an Ressourcen für die Erstellung „nativer“ Elemente im Framework selbst aufgewendet. </font><font style="vertical-align: inherit;">Alle Widgets in Flutter sind in drei große Kategorien unterteilt:</font></font><br>
<br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cupertino Widgets</font></font></a> </li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Material Widgets</font></font></a> </li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere verallgemeinerte Widgets</font></font></a> </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie zum Abschnitt cupertino gehen, werden Sie feststellen, dass diese Widgets nicht von nativen iOS-Elementen zu unterscheiden sind. </font><font style="vertical-align: inherit;">Als Entwickler, der Flutter seit einiger Zeit verwendet, kann ich bestätigen, dass sie nicht zu unterscheiden sind. </font><font style="vertical-align: inherit;">Wenn Sie beispielsweise CupertinoDatePicker verwenden, werden Sie beim Scrollen genau das gleiche, nette Feedback von der Taptic / Haptic-Engine auf Ihrem iPhone erhalten, als wäre es ein natives Element der nativen Anwendung. </font><font style="vertical-align: inherit;">Ich werde mehr sagen, ich öffne regelmäßig die Anwendung der Website realtor.com auf meinem iPhone und hatte bis vor kurzem keine Ahnung, dass sie in Flutter (oder auf etwas nicht Native) geschrieben wurde.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Flutter können Sie nicht nur "native" Widgets für 2 Plattformen verwenden, sondern auch eigene erstellen, und das ist ganz einfach! Das ganze Paradigma ist, dass alles Widget funktioniert. Sie können in kurzer Zeit erstaunlich komplexe UI-Elemente und Animationen erstellen. Der Charme und die Weisheit des Ansatzes zur Arbeit mit der Benutzeroberfläche in Flutter wurden kürzlich in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Artikel über Habr beschrieben. Ich empfehle das Lesen. weil All dies funktioniert auf einer einzigen Grafik-Engine, die all dies für jede Plattform direkt wiedergibt (wir werden später darauf eingehen). Sie können sicher sein, dass alles wie geplant angezeigt wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer ziemlich erstaunlicher Punkt. </font><font style="vertical-align: inherit;">Flutter unterstützt Plattformen ab iOS 8 und Android API v16. </font><font style="vertical-align: inherit;">Aus Sicht der Benutzeroberfläche spielt Flutter keine Rolle, welche APIs auf einer bestimmten Plattform verfügbar sind. </font><font style="vertical-align: inherit;">Er hätte die Möglichkeit, mit Canvas und einer Art Interaktion mit dem Grafiksubsystem zu arbeiten. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir die neuesten UI-Elemente von AndroidX beispielsweise auf einem 8 Jahre alten Telefon zeichnen können. </font><font style="vertical-align: inherit;">Es gibt sicherlich eine Frage der Leistung dieses Ansatzes auf den ältesten unterstützten Plattformen, aber dies ist eine andere Frage.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Native UI-Leistung</font></font></h4><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/bs/as/ld/bsasld-hwweszsjqmucvaavtkyu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, ähnelt Flatters Ansatz beim Rendern der Benutzeroberfläche eher dem von Hybrid-Apps wie Ionic. </font><font style="vertical-align: inherit;">Wir haben eine einzige Engine zum Rendern der Benutzeroberfläche auf allen Plattformen. Dies ist die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skia-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grafikbibliothek. </font><font style="vertical-align: inherit;">Google hat Skia 2005 als Produkt gekauft und daraus ein Open Source-Projekt gemacht. </font><font style="vertical-align: inherit;">Dies deutet zumindest darauf hin, dass dies ein ziemlich ausgereiftes Produkt ist. </font><font style="vertical-align: inherit;">Einige Skia-Leistungsmerkmale:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Copy-on-Write</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für grafische Elemente und andere Datentypen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie nach Möglichkeit Stapelspeicher, um die Fragmentierung zu verringern </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gewindesicherheit für bessere Parallelisierung</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich fand keine überzeugenden Skia-Leistungstests im Vergleich zu ähnlichen Bibliotheken (siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kairo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), aber einige Tests zeigen einen durchschnittlichen Leistungszuwachs von 50%, außer in bestimmten Situationen. Ja, dies ist nicht besonders wichtig, da diese Tests auf der Verwendung von OpenGL auf Desktops basieren und ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skia kann mit vielen GPU-Backends interagieren. Seit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kurzem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter iOS verwendet Flutter seit Version 11 standardmäßig Metal als Backend-GPU. Unter Android ab API 24 - Vulkan. Für Versionen unten - OpenGL. All dies gibt uns einen offensichtlichen Produktivitätsgewinn. Auf anderen "Hardware" -Plattformen verwendet Skia / Flutter meines Wissens OpenGL, was uns im Prinzip nicht daran hindert, Anwendungen mit ausreichender Grafikleistung zu schreiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Web steht auseinander. Derzeit liegt das gesamte UI-Rendering noch auf dem Canvas / HTML-Bundle. Daher ist Skia in keiner Weise an diesem Prozess beteiligt. Außerdem interagiert die Dart-VM nicht direkt mit dem DOM. Zuerst kommt die Konvertierung in js. All dies wirkt sich nicht optimal auf die Produktivität aus und ist mit bloßem Auge direkt erkennbar. Doch </font><font style="vertical-align: inherit;">Arbeit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Gange zu implementieren </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CanvasKit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Flutter, wodurch Skia wiederum in Browsern über WebGL verwendet werden kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließlich verwenden C # -Programmierer SkiaSharp schon relativ lange - ein Wrapper über Skia für Mono / .Net x. </font><font style="vertical-align: inherit;">Und die Xamarin-Community verwendet diese Bibliothek, um benutzerdefinierte UI-Elemente zu zeichnen. Dies ist eine sehr beliebte Bibliothek. </font><font style="vertical-align: inherit;">Wenn dies kein Sieg ist, dann weiß ich nicht, was es ist.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% ige Fähigkeit, jedes API-Betriebssystem aufzurufen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Flutter gibt es zwei Prinzipien der Interaktion mit der "Außenwelt":</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plattformkanäle</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fremdfunktionsschnittstelle</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Plattformkanälen können Sie über ein Messaging-System mit der nativen Laufzeit / API interagieren. Aus architektonischer Sicht kann dies wie folgt gesehen werden. Optisch ist Flutter nur eine Leinwand, die im einzigen Activity / UIViewController Ihrer nativen Anwendung auf Vollbild ausgedehnt wird. Dies ist genau der gleiche Ansatz, den ich für Spieleentwickler (Game Engines) verwende. Jene. Sie können das iOS / Android-Projekt Ihrer Anwendung öffnen und Swift / Kotlin / etc. weitere Funktionen hinzufügen. Das Problem ist, dass die native Laufzeit und die Dart-VM nichts voneinander wissen (zusätzlich zu der Tatsache, dass die native Laufzeit weiß, dass die Anwendung über Canvas verfügt und dort etwas angezeigt wird). Wenn Sie beispielsweise die Datei MainActivity.kt Ihres Android-Projekts öffnen, wird Folgendes angezeigt:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span>: <span class="hljs-type">FlutterActivity</span></span>() {
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<font></font>
    GeneratedPluginRegistrant.registerWith(<span class="hljs-keyword">this</span>)<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haben Sie bemerkt, dass Ihre Aktivität von FlutterActivity erbt? Dies gibt uns die Möglichkeit, den Mechanismus zum direkten Senden von Nachrichten an Flutter / DartVM zu konfigurieren. Dazu müssen wir die </font><i><font style="vertical-align: inherit;">configureFlutterEngine-</font></i><font style="vertical-align: inherit;"> Methode überschreiben</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und es wird den Namen der aufgerufenen Methode und den Namen des Kanals zum Senden von asynchronen Nachrichten bestimmen. Alle. Dies ermöglicht es uns, jeden nativen Code zu schreiben und jede native API aufzurufen! Gleichzeitig gibt es bereits eine große Anzahl von Plugins (Paketen), die Sie vor dem Schreiben von nativem Code bewahren. Sie können nur Dart verwenden. Das ist einfach wunderbar! Sie schreiben die Benutzeroberfläche separat und einmal für jede Plattform, verwenden DartVM für die Arbeit mit Benutzeroberfläche, E / A und verwenden als Computerkomponente Plugins, die native Funktionen implementieren und 99% aller Funktionen abdecken. Und wenn dies nicht ausreicht, schreiben Sie nativ und kommunizieren über den Nachrichtenmechanismus. Geschichte.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite Mechanismus ist eine Fremdfunktionsschnittstelle oder FFI. Dies ist ein ziemlich gebräuchlicher Begriff für den Iteropenmechanismus bei anderen Sprachen, hauptsächlich C. In der .Net-Welt heißt dieser Mechanismus P / Invoke, für die JVM ist es JNI. Kurz gesagt, dies ist die Fähigkeit, mit in C / C ++ / usw. geschriebenen Bibliotheken zu interagieren. Zum Zeitpunkt des .Net Frameworks war beispielsweise keine Software in C # geschrieben, und die überwiegende Mehrheit der Software wurde in C / C ++ geschrieben. Daher war ein Mechanismus erforderlich, um mit diesen Bibliotheken arbeiten zu können. Gleiches gilt für JVM, Python, wie Sie es nennen. FFI wird auf die eine oder andere Weise in allen plattformübergreifenden mobilen Frameworks verwendet. In jüngerer Zeit unterstützt DartVM auch FFI für die Interaktion mit C und JavaScript! Diese Funktion befindet sich zwar in einem Beta-Zweig, steht jedoch bereits zur Verfügung (auf eigene Gefahr und Gefahr).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, decken Flutter und DartVM 100% der Möglichkeiten auf nativen Plattformen ab und noch mehr.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leicht zu lernen und sehr ausdrucksstarke Sprache</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich gebe ehrlich zu, während Dart für mich nicht die beste Sprache der Welt bleibt. Es gibt kein striktes Typsystem, es gibt keine funktionalen Brötchen, wie z. B. Musteranpassungs- oder Unveränderlichkeitsmerkmale (wie sie bald geliefert werden) usw. In Bezug auf das Typsystem wurde Dart ursprünglich als "ohne typische" Sprache konzipiert, ala JS, aber für die normale Unterstützung der AOT-Kompilierung war es dennoch notwendig, das Typsystem auf ein strengeres, wenn auch nicht vollständiges, würde ich sagen. Es ärgert mich immer noch, mit Methodensignaturen zu arbeiten, nämlich mit Argumenten. Alle diese Klammern sind </font></font><code>@required</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus irgendeinem Grund </font><font style="vertical-align: inherit;">wütend </font><font style="vertical-align: inherit;">. Aber Dart ist eine sehr leicht zu erlernende Sprache. In der Syntax ist dies für mich eine Kreuzung zwischen Java und JS. Dart vergibt viel, wie JS. Im Allgemeinen ist dies eine ziemlich leicht zu erlernende Sprache, ich habe keine wesentlichen Probleme festgestellt.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rantime, die gut in das Frontend-Entwicklungsparadigma passt</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns nun über Dart VM sprechen. </font><font style="vertical-align: inherit;">Im Allgemeinen enthält Dart VM viele Dinge, von GC bis Profiler und Observatory. </font><font style="vertical-align: inherit;">Hier möchte ich nur über GC und bedingte Laufzeit sprechen. </font><font style="vertical-align: inherit;">Sie können sich mit vertraut zu </font><font style="vertical-align: inherit;">machen , </font><font style="vertical-align: inherit;">wie die Laufzeit funktioniert und was es aus </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich bin kein Experte auf diesem Gebiet, aber für mich selbst habe ich einige der Vorteile von Dart VM festgestellt, die ich zu beschreiben versuchen werde. </font><font style="vertical-align: inherit;">Zuvor möchte ich darauf hinweisen, dass Dart und die entsprechende VM ursprünglich als Ersatz für JS entwickelt wurden, was sozusagen auf den Fokus auf die Frontend-Entwicklung hinweist. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isolate</font></font></b><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/_s/_n/kl/_s_nklwnaygqk8dey70z0yerdco.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dart VM hat das Isolate-Konzept. Isolieren ist eine Kombination aus einem Hauptthread, der direkt auf dem Dartcode ausgeführt wird, und dem isolierten Heap, in dem die Objekte aus dem Dartcode tatsächlich zugeordnet sind. Dies ist eine vereinfachte Struktur. Isolate hat auch Hilfs- / System-Threads, es gibt OS-Threads, die Isolate betreten und verlassen können usw. Der Stapel ist auch in Isolate vorhanden, aber Sie als Benutzer arbeiten nicht daran. Die Hauptsache, die hier hervorgehoben werden muss, ist, dass wenn Sie sich ein Isolat ansehen, dies eine Single-Thread-Umgebung ist. Standardmäßig verwendet Flutter ein Standardisolat. Ähnelt es etwas? Ja, das ist eine JS-Umgebung. Genau wie in JS können Dart-Programmierer nicht mit Multithreading arbeiten. Jemand könnte denken, dass dies ein Durcheinander, eine Vereinfachung und eine Verletzung der Rechte von echten Entwicklern ist, aber ich denke, dass bei der Arbeit mit der BenutzeroberflächeWenn Sie mit einem bedingten DOM arbeiten (und keine Polygone auf dem Bildschirm zeichnen), müssen Sie dies nicht tun. Es ist gefährlich, mit mehreren Threads zu arbeiten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier war ich natürlich schlau, wenn Sie wirklich wollen, dann können Sie das separat gestartete Isolate verwenden, um parallele Aufgaben auszuführen (Hallo WebWorker). </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> können Sie detailliert sehen, wie Sie mit zusätzlichem Isolate in Flutter arbeiten können. Im Allgemeinen wissen Isolate, wie der Name schon sagt, nichts voneinander, halten keine Verbindungen zueinander und kommunizieren über ein Nachrichtensystem.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich zum Single-Thread-Ansatz ist die Tatsache, dass jedem Isolat ein separater Heap zugewiesen wird, ohne dass der Stapel dieses Threads manipuliert werden kann, meiner Meinung nach ein sehr guter Ansatz. Wenn Sie eine Serveranwendung schreiben, die beispielsweise eine große Anzahl von Zeilen bearbeitet, und diese Zeilen in einem Heap gespeichert werden, in dem sie mit enormer Geschwindigkeit angezeigt und ausgeblendet werden, während der Speicher fragmentiert und GC-Jobs hinzugefügt werden, können Sie diese Zeilen oder zumindest einen Teil davon übertragen Heaps auf dem Stack sparen Ressourcen und verbessern die Leistung. Ein Beispiel ist so lala, aber du verstehst mich. Bei der Arbeit mit der Benutzeroberfläche, bei der möglicherweise eine ausreichende Anzahl von Benutzeroberflächenelementen vorhanden ist, die eine kurze Lebensdauer haben können (z. B. Animation), aber gleichzeitig nur ein Client und die Menge der verarbeiteten Daten im Vergleich zur Serveranwendung vernachlässigbar sind.Die Möglichkeit, direkt mit dem Stapel zu arbeiten, ist einfach nicht erforderlich. Ich spreche nicht von Boxen / Unboxen, was in diesem Fall sein könnte und was absolut sinnlos ist. Und es sollte beachtet werden, dass Objekte in Dart VM ziemlich oft zugewiesen werden. Selbst um den doppelten Betrag von der Dart-Methode auszugeben, weist die VM dem Heap separat ein Stück zu. Wie geht der GC mit dieser Last um? Lassen Sie uns einen Blick darauf werfen.</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Young Space Scavenger (und Parallel Mark Sweep)</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wie alle GCs hat auch der GC in der Dart VM Generationen. Außerdem kann der GC in der Dart-VM nach dem Arbeitsprinzip in zwei Komponenten unterteilt werden: Young Space Scavenger und Parallel Mark Sweep. Ich werde nicht auf das letzte Prinzip eingehen, dies ist ein ziemlich populäres Prinzip der Speicherbereinigung, das fast überall implementiert ist und Flutter keinen besonderen Vorteil verschafft. Wir interessieren uns für die erste. Das Arbeitsprinzip von Young Space Scavenger ist im folgenden Bild gut dargestellt:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d3/yq/ik/d3yqikji__3j3f9zehdkrm4-t0a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es zeigt deutlich die Vorteile dieses Ansatzes. Young Space Scavenger arbeitet für die neuesten Objekte im Speicher, wir können das für die erste / Null-Generation von Objekten sagen. Oft, und dies ist charakteristisch für die Flutter / Dart-VM, haben die meisten neuen Objekte eine kurze Lebensdauer. In einer Situation, in der Sie viele Objekte zuweisen, die nicht lange leben, kann der Speicher sehr fragmentiert sein. In diesem Fall müssen Sie entweder Speicher- oder Prozessorzeit bezahlen, um das Problem zu beheben (obwohl Sie das Problem mit solchen Methoden nicht beheben sollten). Young Space Scavenger löst dieses Problem. Wenn Sie sich das Bild oben ansehen, dann gibt es wirklich keinen 6-Schritt. Sie müssen den ersten Speicherblock nicht löschen. Standardmäßig denken wir, dass dieser Block nach dem Kopieren von Objekten in den zweiten leer ist. Nun, wenn Sie überlebende Objekte in den zweiten Block kopieren,Wir setzen sie natürlich einzeln, ohne Fragmentierung zu erzeugen. All dies ermöglicht es VM, viele neue Objekte zu einem relativ niedrigen Preis zuzuweisen.</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leerlaufzeit-GC</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wie Sie verstehen, arbeiten die Teams Flutter und Dart VM eng zusammen, und das Ergebnis dieser Zusammenarbeit kann als Leerlaufzeit-GC betrachtet werden. Wie der Name schon sagt, handelt es sich um eine Speicherbereinigung in dem Moment, in dem nichts passiert. Im Kontext von Flutter in dem Moment, in dem die Anwendung visuell nichts ändert. Es gibt keine Animation, kein Scrollen oder keine Benutzerinteraktion. In diesen Momenten sendet Flutter Nachrichten an die Dart-VM, die jetzt im Prinzip ein guter Zeitpunkt ist, um mit der Speicherbereinigung zu beginnen. Als nächstes entscheidet der Müllsammler, ob er mit seiner Arbeit beginnen soll. Diesbezüglich erfolgt die Speicherbereinigung natürlich für ältere Objekte, die über den Parallel Mark Sweep verwaltet werden. Dies ist an sich ein ziemlich teurer Prozess, und Idle Time GC ist in dieser Hinsicht ein sehr nützlicher Mechanismus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt andere Dinge wie</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleitverdichtung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">komprimierte Zeiger</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Der erste ist der Speicherdefragmentierungsmechanismus nach dem Ausführen von Parallel Mark Sweep. </font><font style="vertical-align: inherit;">Dies ist auch ein teurer Prozess und funktioniert nur, wenn Leerlaufzeit vorhanden ist. </font><font style="vertical-align: inherit;">Der zweite Ansatz, Compressed Pointers (Komprimierte Zeiger), komprimiert 64-Bit-Zeiger auf 32 Bit, wodurch Speicherplatz gespart wird (ich denke, dies ist in einer Serverumgebung viel nützlicher als in einer mobilen).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie bis zu dieser Zeile lesen, dann erstens Glückwunsch und zweitens muss ich sagen, dass ich keine Erfahrung mit dem Schreiben von Artikeln habe. Daher verstehe ich nicht ganz, ob ich es geschafft habe, meinen Standpunkt zu vermitteln. Und die Idee ist einfach: Wenn Sie eine mobile Anwendung mit Flutter schreiben, stellt sich heraus, dass sie nativ ist. Und in Form eines Bonus erhalten Sie eine sehr anständige Anwendungsentwicklungsgeschwindigkeit. Hot Reload / Restart ist in der Frontend-Entwicklung einfach unverzichtbar. Können Sie sich einen Schriftsetzer vorstellen, der beispielsweise bei jedem Farbwechsel einer Schaltfläche das gesamte Projekt für jeden Browser erstellen / kompilieren müsste? Natürlich nicht. Im Allgemeinen verdient Hot Reload / Restart einen separaten Artikel. Aber ich war abgelenkt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meine Erfahrung mit Flutter zeigt mir, dass dieser Rahmen in naher Zukunft dominieren wird. </font><font style="vertical-align: inherit;">In regelmäßigen Abständen führe ich Interviews für eine Position als Flutter-Entwickler durch, und in der Hälfte der Fälle haben Unternehmen, die einen Flutter-Entwickler suchen, Mitarbeiter mobiler nativer Entwickler. </font><font style="vertical-align: inherit;">Sie haben Flutter gerade bei Innen- / Nebenprojekten ausprobiert, waren zufrieden / begeistert und wechselten langsam zu Flutter. </font><font style="vertical-align: inherit;">Dies ist ein echter Sieg, scheint mir. </font><font style="vertical-align: inherit;">Was über Xamarin leider nicht gesagt werden kann. </font><font style="vertical-align: inherit;">Sehr oft ist die Entscheidung für Xamarin einfach darauf zurückzuführen, dass der Rest des Stapels in .Net geschrieben ist und dies eine rutschige Steigung ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusammenfassend möchte ich sagen, dass Sie sich Flutter ansehen sollten, wenn Sie überlegen, welche Seite Sie bei der Entwicklung Ihrer neuen mobilen Anwendung ansprechen sollten.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de501328/index.html">Einführung in Visual Studio-Codespaces: Cloud-Entwicklung, wo immer Sie sind</a></li>
<li><a href="../de501330/index.html">Microservices in C ++. Fiktion oder Realität?</a></li>
<li><a href="../de501332/index.html">Meetings sind einfach. Drei tägliche Übungstipps</a></li>
<li><a href="../de501336/index.html">FOSS News Nr. 15 - eine Überprüfung der kostenlosen und Open Source-Nachrichten für den 4. bis 10. Mai 2020</a></li>
<li><a href="../de501338/index.html">In der virtuellen Python-Maschine. Teil 1</a></li>
<li><a href="../de501342/index.html">Microsoft Online-Zertifizierung - Feldnotizen</a></li>
<li><a href="../de501346/index.html">Übersicht über die mechanische Tastatur Vortex Core RGB</a></li>
<li><a href="../de501352/index.html">Kafka schlägt zurück</a></li>
<li><a href="../de501354/index.html">Ein neuer Blick auf den Codestil</a></li>
<li><a href="../de501356/index.html">Rost für Java-Entwickler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>