<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏤 👨🏿‍🤝‍👨🏾 🚦 MVCC-6。クリーニング 🌙 🙋🏻 👩🏽‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="分離に関連する問題から始め、低レベルでのデータの整理について余談を述べ、次に行のバージョンと、バージョンからスナップショットを取得する方法について詳しく説明しました。
 
 前回、HOTの更新とインページクリーニングについて説明しました。今日は、よく知られた通常の掃除機である尋常性陰茎について見てい...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>MVCC-6。クリーニング</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452320/"><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分離</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">関連する問題から始め</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、低レベル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">での</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">データの整理</font></a><font style="vertical-align: inherit;">について余談を述べ</font><font style="vertical-align: inherit;">、次に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行のバージョン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、バージョンから</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スナップショット</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を取得する方法</font><font style="vertical-align: inherit;">について詳しく説明</font><font style="vertical-align: inherit;">しました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前回</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、HOTの更新とインページクリーニングについて説明しました。今日は、よく知られた通常の掃除機で</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ある尋常性陰茎について</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見ていきます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">はい、すでに彼女について多くのことが書かれているので、私は何も新しいことを言うことはできませんが、全体像を犠牲にする必要があります。</font><font style="vertical-align: inherit;">我慢して。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常のクリーニング（真空）</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クリーニングは何をしますか</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ページはめ込みのクリーニングは迅速ですが、スペースのほんの一部しか解放されません。同じ表形式ページ内で機能し、インデックスには影響しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインの「通常の」クリーニングはVACUUMコマンドによって実行されます。これを単にクリーニングと呼びます（自動クリーニングについては別途説明します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、クリーンアップはテーブルを完全に処理します。文字列の不要なバージョンだけでなく、すべてのインデックスからそれらへの参照も削除されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
処理は、システム内の他のアクティビティと並行して行われます。この場合、テーブルとインデックスは通常の方法で読み取りと変更の両方に使用できます（ただし、CREATE INDEX、ALTER TABLEなどのコマンドを同時に実行することはできません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何らかのアクティビティが発生したページのみがテーブルに表示されます。</font><font style="vertical-align: inherit;">このために、可視性マップが使用されます（すべてのデータスナップショットで確実に表示されることが保証されている、かなり古いバージョンの文字列のみを含むページがマークされていることを思い出します）。</font><font style="vertical-align: inherit;">マップ上でマークされていないページのみが処理され、マップ自体は更新されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロセスでは、ページに表示される空き領域を反映するように空き領域マップが更新されます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常どおり、テーブルを作成します。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> vac(<font></font>
  id <span class="hljs-type">serial</span>,<font></font>
  s <span class="hljs-type">char</span>(<span class="hljs-number">100</span>)<font></font>
) <span class="hljs-keyword">WITH</span> (autovacuum_enabled = <span class="hljs-keyword">off</span>);<font></font>
=&gt; <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> vac_s <span class="hljs-keyword">ON</span> vac(s);<font></font>
=&gt; <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> vac(s) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'A'</span>);<font></font>
=&gt; <span class="hljs-keyword">UPDATE</span> vac <span class="hljs-keyword">SET</span> s = <span class="hljs-string">'B'</span>;<font></font>
=&gt; <span class="hljs-keyword">UPDATE</span> vac <span class="hljs-keyword">SET</span> s = <span class="hljs-string">'C'</span>;
</code></pre><br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">autovacuum_enabled</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
パラメータを使用して、</font><font style="vertical-align: inherit;">自動クリーニングをオフにします。</font><font style="vertical-align: inherit;">次回はそれについて話しますが、今のところ-実験のために-手動でクリーニングを制御することが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テーブルには現在3つのバージョンの行があり、各リンクはインデックスからのものです。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">'vac'</span>,<span class="hljs-number">0</span>);
</code></pre><pre><code class="plaintext hljs"> ctid  | state  |   xmin   |   xmax   | hhu | hot | t_ctid <font></font>
-------+--------+----------+----------+-----+-----+--------<font></font>
 (0,1) | normal | 4000 (c) | 4001 (c) |     |     | (0,2)<font></font>
 (0,2) | normal | 4001 (c) | 4002     |     |     | (0,3)<font></font>
 (0,3) | normal | 4002     | 0 (a)    |     |     | (0,3)<font></font>
(3 rows)<font></font>
</code></pre><br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> index_page(<span class="hljs-string">'vac_s'</span>,<span class="hljs-number">1</span>);
</code></pre><pre><code class="plaintext hljs"> itemoffset | ctid  <font></font>
------------+-------<font></font>
          1 | (0,1)<font></font>
          2 | (0,2)<font></font>
          3 | (0,3)<font></font>
(3 rows)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クリーニング後、「デッド」バージョンは消え、関連するバージョンは1つだけ残ります。</font><font style="vertical-align: inherit;">また、インデックスには1つのリンクがあります。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">VACUUM</span> vac;<font></font>
=&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">'vac'</span>,<span class="hljs-number">0</span>);
</code></pre><pre><code class="plaintext hljs"> ctid  | state  |   xmin   | xmax  | hhu | hot | t_ctid <font></font>
-------+--------+----------+-------+-----+-----+--------<font></font>
 (0,1) | unused |          |       |     |     | <font></font>
 (0,2) | unused |          |       |     |     | <font></font>
 (0,3) | normal | 4002 (c) | 0 (a) |     |     | (0,3)<font></font>
(3 rows)<font></font>
</code></pre><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> index_page(<span class="hljs-string">'vac_s'</span>,<span class="hljs-number">1</span>);
</code></pre><pre><code class="plaintext hljs"> itemoffset | ctid  <font></font>
------------+-------<font></font>
          1 | (0,3)<font></font>
(1 row)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の2つのポインターは、ページ内クリーニングの場合と同様に、未使用のステータスを受け取り、デッドではないことに注意してください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして再びトランザクションの地平線について</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQLはどの行バージョンが「無効」と見なされるかをどのように決定しますか？</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スナップショット</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">について説明する</font></a><font style="vertical-align: inherit;">ときに、トランザクション期間の概念をすでに検討しました</font><font style="vertical-align: inherit;">が、これは非常に重要なトピックであるため、繰り返すのは罪ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前の体験をもう一度始めましょう。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">TRUNCATE</span> vac;<font></font>
=&gt; <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> vac(s) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'A'</span>);<font></font>
=&gt; <span class="hljs-keyword">UPDATE</span> vac <span class="hljs-keyword">SET</span> s = <span class="hljs-string">'B'</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、行を再度更新する前に、別のトランザクションを開始させます（終了させません）。</font><font style="vertical-align: inherit;">この例では、Read Committedレベルで機能しますが、実際の（非仮想）トランザクション番号を取得する必要があります。</font><font style="vertical-align: inherit;">たとえば、必ずしも空ではなく、任意のテーブルの一部の行を変更またはロックすることさえできます。</font></font><br>
<br>
<pre><code class="pgsql hljs">|  =&gt; <span class="hljs-keyword">BEGIN</span>;<font></font>
|  =&gt; <span class="hljs-keyword">SELECT</span> s <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;
</code></pre><pre><code class="plaintext hljs">|    s  <font></font>
|  -----<font></font>
|   FOO<font></font>
|   BAR<font></font>
|  (2 rows)<font></font>
</code></pre><br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">UPDATE</span> vac <span class="hljs-keyword">SET</span> s = <span class="hljs-string">'C'</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、テーブルには3つの行があり、インデックスには3つのリンクがあります。</font><font style="vertical-align: inherit;">クリーニング後はどうなりますか？</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">VACUUM</span> vac;<font></font>
=&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">'vac'</span>,<span class="hljs-number">0</span>);
</code></pre><pre><code class="plaintext hljs"> ctid  | state  |   xmin   |   xmax   | hhu | hot | t_ctid <font></font>
-------+--------+----------+----------+-----+-----+--------<font></font>
 (0,1) | unused |          |          |     |     | <font></font>
 (0,2) | normal | 4005 (c) | 4007 (c) |     |     | (0,3)<font></font>
 (0,3) | normal | 4007 (c) | 0 (a)    |     |     | (0,3)<font></font>
(3 rows)<font></font>
</code></pre><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> index_page(<span class="hljs-string">'vac_s'</span>,<span class="hljs-number">1</span>);
</code></pre><pre><code class="plaintext hljs"> itemoffset | ctid  <font></font>
------------+-------<font></font>
          1 | (0,2)<font></font>
          2 | (0,3)<font></font>
(2 rows)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
表に残っている行には2つのバージョンがあります。クリーンアップにより、バージョン（0.2）はまだ削除できないと判断されました。</font><font style="vertical-align: inherit;">もちろん、その理由は、データベーストランザクション期間にあります。この例では、不完全なトランザクションによって決定されます。</font></font><br>
<br>
<pre><code class="pgsql hljs">|  =&gt; <span class="hljs-keyword">SELECT</span> backend_xmin <span class="hljs-keyword">FROM</span> pg_stat_activity <span class="hljs-keyword">WHERE</span> pid = pg_backend_pid();
</code></pre><pre><code class="plaintext hljs">|   backend_xmin <font></font>
|  --------------<font></font>
|           4006<font></font>
|  (1 row)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは何が起こるかについて話すために掃除を求めることができます：</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">VACUUM</span> <span class="hljs-keyword">VERBOSE</span> vac;
</code></pre><pre><code class="plaintext hljs">INFO:  vacuuming "public.vac"<font></font>
INFO:  index "vac_s" now contains 2 row versions in 2 pages<font></font>
DETAIL:  0 index row versions were removed.<font></font>
0 index pages have been deleted, 0 are currently reusable.<font></font>
CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s.<font></font>
INFO:  "vac": found 0 removable, 2 nonremovable row versions in 1 out of 1 pages<font></font>
DETAIL:  1 dead row versions cannot be removed yet, oldest xmin: 4006<font></font>
There were 1 unused item pointers.<font></font>
Skipped 0 pages due to buffer pins, 0 frozen pages.<font></font>
0 pages are entirely empty.<font></font>
CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s.<font></font>
VACUUM<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つの削除不可能な行バージョン-削除できない2つのバージョンがテーブルで見つかりました、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのデッドローバージョンはまだ削除できません-1つの「デッド」を含め、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最も古いxminは現在の地平線を示します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論をもう一度繰り返します。データベースに存続期間の長いトランザクションが存在すると（完了していないか、実行時間が非常に長いため）、クリーンアップの実行頻度に関係なく、（膨張）テーブルが拡張される可能性があります。</font><font style="vertical-align: inherit;">したがって、PostgreSQLでは、OLTPとOLAPのワークロードが1つのデータベースにうまく結合されていません。何時間も実行されるレポートでは、頻繁に更新されるテーブルを時間どおりにクリアできません。</font><font style="vertical-align: inherit;">可能な解決策は、別個の「レポート」レプリカを作成することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開いているトランザクションの完了後、地平線がシフトし、状況が修正されます。</font></font><br>
<br>
<pre><code class="pgsql hljs">|  =&gt; <span class="hljs-keyword">COMMIT</span>;
</code></pre><br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">VACUUM</span> <span class="hljs-keyword">VERBOSE</span> vac;
</code></pre><pre><code class="plaintext hljs">INFO:  vacuuming "public.vac"<font></font>
INFO:  scanned index "vac_s" to remove 1 row versions<font></font>
DETAIL:  CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s<font></font>
INFO:  "vac": removed 1 row versions in 1 pages<font></font>
DETAIL:  CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s<font></font>
INFO:  index "vac_s" now contains 1 row versions in 2 pages<font></font>
DETAIL:  1 index row versions were removed.<font></font>
0 index pages have been deleted, 0 are currently reusable.<font></font>
CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s.<font></font>
INFO:  "vac": found 1 removable, 1 nonremovable row versions in 1 out of 1 pages<font></font>
DETAIL:  0 dead row versions cannot be removed yet, oldest xmin: 4008<font></font>
There were 1 unused item pointers.<font></font>
Skipped 0 pages due to buffer pins, 0 frozen pages.<font></font>
0 pages are entirely empty.<font></font>
CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s.<font></font>
VACUUM<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、ページには最新の最新バージョンの行のみが表示されます。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> heap_page(<span class="hljs-string">'vac'</span>,<span class="hljs-number">0</span>);
</code></pre><pre><code class="plaintext hljs"> ctid  | state  |   xmin   | xmax  | hhu | hot | t_ctid <font></font>
-------+--------+----------+-------+-----+-----+--------<font></font>
 (0,1) | unused |          |       |     |     | <font></font>
 (0,2) | unused |          |       |     |     | <font></font>
 (0,3) | normal | 4007 (c) | 0 (a) |     |     | (0,3)<font></font>
(3 rows)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、インデックスには1つのエントリしかありません。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> index_page(<span class="hljs-string">'vac_s'</span>,<span class="hljs-number">1</span>);
</code></pre><pre><code class="plaintext hljs"> itemoffset | ctid  <font></font>
------------+-------<font></font>
          1 | (0,3)<font></font>
(1 row)<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部で何が起こっているのか</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クリーニングでは、テーブルとインデックスの両方を同時に処理し、他のプロセスの操作を妨げないようにする必要があります。彼女はそれをどのように行うのですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべては</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テーブルスキャン</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から始まり</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">（既に説明したように、可視性マップを考慮に入れます）。読み込まれたページでは、不要なバージョンの文字列が決定され、それらの識別子（tid）が特別な配列に書き込まれます。アレイは、クリーニングプロセスのローカルメモリにあります。フラグメントは、サイズが</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maintenance_work_mem</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で割り当てられ</font><font style="vertical-align: inherit;">ます。このパラメーターのデフォルト値は64 MBです。このメモリは、必要に応じてではなく、すぐに完全に割り当てられることに注意してください。 True、テーブルが小さい場合、フラグメントの割り当ては少なくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、2つのいずれかが続きます。テーブルの最後に到達するか、配列に割り当てられたメモリが終了します。 2つのケースのいずれかで、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックスのクリーンアップフェーズ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が始まります</font><font style="vertical-align: inherit;">。これを行う</font><font style="vertical-align: inherit;">には、テーブルに作成された</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックスを</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全にスキャン</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して、記憶されているバージョンの行を参照するレコードを検索します。見つかったレコードはインデックスページから削除されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点で、次の図が表示されます。インデックスには、不要なバージョンの行へのリンクはありませんが、テーブルにはまだ存在しています。これは何も矛盾しません。クエリを実行するとき、行の無効なバージョンにまったくアクセスしないか（インデックスアクセスを使用）、または可視性をチェックするときに（テーブルをスキャンするときに）マークを付けます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後</font><strong><font style="vertical-align: inherit;">、テーブルのクリーニング段階</font></strong><font style="vertical-align: inherit;">が始まります。</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">テーブルが再度スキャンされ、必要なページが読み取られ、保存されているバージョンの行がページから消去され、ポインタが解放されます。</font><font style="vertical-align: inherit;">インデックスからのリンクがなくなったため、これを行うことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のパスでテーブルが完全に読み取られなかった場合は、配列がクリアされ、中断したところからすべてが繰り返されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法では：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テーブルは常に2回スキャンされます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クリーニング中に非常に多くのバージョンの文字列が削除され、すべての文字列が</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maintenance_work_mem</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリ</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">収まらない</font><font style="vertical-align: inherit;">場合、すべてのインデックスが必要な回数だけ完全にスキャンされます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大きなテーブルでは、これにかなりの時間がかかり、システムに大きな負荷がかかる可能性があります。</font><font style="vertical-align: inherit;">もちろん、リクエストはブロックされませんが、「余分な」I / Oも不快です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセスを高速化するには、より頻繁にクリーニングを要求するか（そのたびに非常に多くの行バージョンがクリアされないようにする）、またはより多くのメモリを割り当てる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
括弧内で、バージョン11以降では、PostgreSQL </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">絶対に必要でない場合は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">インデックススキャンをスキップできること</font></a><font style="vertical-align: inherit;">に注意してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これにより、行が追加されるだけで（変更はされない）大きなテーブルの所有者の作業が楽になります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モニタリング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クリーニングがワンパスでの作業に対応しないことをどのように理解しますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の方法はすでに見てきました。VERBOSEを指定してVACUUMコマンドを呼び出すことができます。</font><font style="vertical-align: inherit;">次に、作業のフェーズに関する情報がコンソールに表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、バージョン9.6以降、pg_stat_progress_vacuumビューがあり、必要な情報もすべて含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（メッセージログに情報を出力する3つ目の方法はまだありますが、これは</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動クリーニング</font><font style="vertical-align: inherit;">でのみ機能します。これについては、次に説明します。）</font><font style="vertical-align: inherit;">テーブルに行を追加して、クリーニングにかなりの時間がかかるようにし、すべての行を更新して、クリーニングで何かするようにします。 。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">TRUNCATE</span> vac;<font></font>
=&gt; <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> vac(s) <span class="hljs-keyword">SELECT</span> <span class="hljs-string">'A'</span> <span class="hljs-keyword">FROM</span> generate_series(<span class="hljs-number">1</span>,<span class="hljs-number">500000</span>);<font></font>
=&gt; <span class="hljs-keyword">UPDATE</span> vac <span class="hljs-keyword">SET</span> s  = <span class="hljs-string">'B'</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
識別子配列に割り当てられたメモリのサイズを減らします。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">SET</span> maintenance_work_mem = <span class="hljs-string">'1MB'</span>;<font></font>
=&gt; <span class="hljs-keyword">SELECT</span> pg_reload_conf();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クリーニングを開始し、正常に機能している間、pg_stat_progress_vacuumビューを数回表示します。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">VACUUM</span> <span class="hljs-keyword">VERBOSE</span> vac;
</code></pre><br>
<pre><code class="pgsql hljs">|  =&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> pg_stat_progress_vacuum \gx
</code></pre><pre><code class="plaintext hljs">|  -[ RECORD 1 ]------+------------------<font></font>
|  pid                | 6715<font></font>
|  datid              | 41493<font></font>
|  datname            | test<font></font>
|  relid              | 57383<font></font>
|  phase              | vacuuming indexes<font></font>
|  heap_blks_total    | 16667<font></font>
|  heap_blks_scanned  | 2908<font></font>
|  heap_blks_vacuumed | 0<font></font>
|  index_vacuum_count | 0<font></font>
|  max_dead_tuples    | 174762<font></font>
|  num_dead_tuples    | 174480<font></font>
</code></pre><br>
<pre><code class="pgsql hljs">|  =&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> pg_stat_progress_vacuum \gx
</code></pre><pre><code class="plaintext hljs">|  -[ RECORD 1 ]------+------------------<font></font>
|  pid                | 6715<font></font>
|  datid              | 41493<font></font>
|  datname            | test<font></font>
|  relid              | 57383<font></font>
|  phase              | vacuuming indexes<font></font>
|  heap_blks_total    | 16667<font></font>
|  heap_blks_scanned  | 5816<font></font>
|  heap_blks_vacuumed | 2907<font></font>
|  index_vacuum_count | 1<font></font>
|  max_dead_tuples    | 174762<font></font>
|  num_dead_tuples    | 174480<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは特に：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在のフェーズ（フェーズ）の名前-3つの主要なフェーズについて説明しましたが、通常は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さらに多くの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フェーズが</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">あり</font></a><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テーブルページの総数（heap_blks_total）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クロールされたページの数（heap_blks_scanned）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すでにクリアされたページ数（heap_blks_vacuumed）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックスによるパスの数（index_vacuum_count）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
全体的な進行状況はheap_blks_vacuumedとheap_blks_totalの比率によって決定されますが、この値はスムーズに変化せず、インデックススキャンにより「ぎくしゃく」変化することに注意してください。</font><font style="vertical-align: inherit;">ただし、主な注意はクリーニングサイクルの数に注意する必要があります。1より大きい値は、割り当てられたメモリが1回のパスでクリーニングを完了するのに十分ではなかったことを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点までに完了したVACUUM VERBOSEコマンドの出力は、全体像を示しています。</font></font><br>
<br>
<pre><code class="plaintext hljs">INFO:  vacuuming "public.vac"
</code></pre><pre><code class="plaintext hljs">INFO:  scanned index "vac_s" to remove 174480 row versions<font></font>
DETAIL:  CPU: user: 0.50 s, system: 0.07 s, elapsed: 1.36 s<font></font>
INFO:  "vac": removed 174480 row versions in 2908 pages<font></font>
DETAIL:  CPU: user: 0.02 s, system: 0.02 s, elapsed: 0.13 s<font></font>
</code></pre><pre><code class="plaintext hljs">INFO:  scanned index "vac_s" to remove 174480 row versions<font></font>
DETAIL:  CPU: user: 0.26 s, system: 0.07 s, elapsed: 0.81 s<font></font>
INFO:  "vac": removed 174480 row versions in 2908 pages<font></font>
DETAIL:  CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.10 s<font></font>
</code></pre><pre><code class="plaintext hljs">INFO:  scanned index "vac_s" to remove 151040 row versions<font></font>
DETAIL:  CPU: user: 0.13 s, system: 0.04 s, elapsed: 0.47 s<font></font>
INFO:  "vac": removed 151040 row versions in 2518 pages<font></font>
DETAIL:  CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.08 s<font></font>
</code></pre><pre><code class="plaintext hljs">INFO:  index "vac_s" now contains 500000 row versions in 17821 pages<font></font>
DETAIL:  500000 index row versions were removed.<font></font>
8778 index pages have been deleted, 0 are currently reusable.<font></font>
CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s.<font></font>
INFO:  "vac": found 500000 removable, 500000 nonremovable row versions in 16667 out of 16667 pages<font></font>
DETAIL:  0 dead row versions cannot be removed yet, oldest xmin: 4011<font></font>
There were 0 unused item pointers.<font></font>
0 pages are entirely empty.<font></font>
CPU: user: 1.10 s, system: 0.37 s, elapsed: 3.71 s.<font></font>
VACUUM<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、インデックスに合計3つのパスがあり、それぞれのパスで無効なバージョンの文字列への174,480のポインタがクリアされていることがわかります。</font><font style="vertical-align: inherit;">この数字はどこから来たのですか？</font><font style="vertical-align: inherit;">1つのリンク（tid）は6バイトかかり、1024 * 1024/6 = 174762はpg_stat_progress_vacuum.max_dead_tuplesに表示される数です。</font><font style="vertical-align: inherit;">実際、これは少しだけ使用できます。次のページを読み取るときに、「デッド」バージョンへのすべてのポインタがメモリに正確に収まることが保証されています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分析、つまりクエリプランナーの統計情報の収集は、正式にはクリーニングとは関係ありません。</font><font style="vertical-align: inherit;">それにもかかわらず、分析はANALYZEチームだけでなく、クリーニングと分析を組み合わせて実行することもできます：VACUUM ANALYZE。</font><font style="vertical-align: inherit;">この場合、最初にクリーニングが実行され、次に分析が行われます-節約は発生しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、後で説明するように、自動クリーニングと自動分析は1つのプロセスで実行され、同様の方法で管理されます。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フルクリーニング（真空フル）</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまで見てきたように、従来のクリーニングはページ内クリーニングよりも多くのスペースを解放しますが、それでも常に問題を完全に解決できるわけではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何らかの理由でテーブルまたはインデックスのサイズが大幅に増大した場合、定期的なクリーニングによって既存のページ内のスペースが解放されます。それらに「穴」が表示され、新しいバージョンの行の挿入に使用されます。</font><font style="vertical-align: inherit;">ただし、ページ数は変更されないため、オペレーティングシステムの観点から見ると、ファイルはクリーニング前とまったく同じ容量を占めます。</font><font style="vertical-align: inherit;">そしてこれは悪いです：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テーブル（またはインデックス）のフルスキャンが遅くなります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">より大きなバッファキャッシュが必要になる場合があります（ページが保存され、有用な情報の密度が低下するため）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「追加の」レベルがインデックスツリーに表示され、インデックスアクセスが遅くなります。</font></font></li>
<li>         .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（唯一の例外は、ファイルの最後にある完全にクリーンアップされたページです。このようなページは、ファイルから「食い込んで」オペレーティングシステムに戻ります。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイル内の有用な情報の割合が妥当な制限を下回った場合、管理者はテーブル全体のクリーンアップを実行できます。同時に、テーブルとそのすべてのインデックスは完全にゼロから再構築され、データは可能な限りコンパクトにパックされます（もちろん、fillfactorパラメーターを考慮に入れます）。再構築する場合、PostgreSQLは最初にテーブルを順に再構築し、次に各インデックスを再構築します。オブジェクトごとに新しいファイルが作成され、再構築の最後に古いファイルが削除されます。ディスクでの作業中に追加のスペースが必要になることに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
説明のために、テーブルにいくつかの行を再度挿入します。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">TRUNCATE</span> vac;<font></font>
=&gt; <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> vac(s) <span class="hljs-keyword">SELECT</span> <span class="hljs-string">'A'</span> <span class="hljs-keyword">FROM</span> generate_series(<span class="hljs-number">1</span>,<span class="hljs-number">500000</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
情報の密度を評価する方法は？</font><font style="vertical-align: inherit;">これを行うには、特別な拡張機能を使用すると便利です。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> pgstattuple;<font></font>
=&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> pgstattuple(<span class="hljs-string">'vac'</span>) \gx
</code></pre><pre><code class="plaintext hljs">-[ RECORD 1 ]------+---------<font></font>
table_len          | 68272128<font></font>
tuple_count        | 500000<font></font>
tuple_len          | 64500000<font></font>
tuple_percent      | 94.47<font></font>
dead_tuple_count   | 0<font></font>
dead_tuple_len     | 0<font></font>
dead_tuple_percent | 0<font></font>
free_space         | 38776<font></font>
free_percent       | 0.06<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数はテーブル全体を読み取り、ファイル内でどのデータが占有されているかに関する統計を表示します。</font><font style="vertical-align: inherit;">現在関心のある主な情報はtuple_percentフィールドです。これは、有用なデータが占める割合です。</font><font style="vertical-align: inherit;">ページ内のサービス情報のオーバーヘッドが避けられないため、100未満ですが、それでもかなり高くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インデックスについては、他の情報が表示されますが、avg_leaf_densityフィールドの意味は同じです。つまり、有用な情報の割合（リーフページ内）です。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> pgstatindex(<span class="hljs-string">'vac_s'</span>) \gx
</code></pre><pre><code class="plaintext hljs">-[ RECORD 1 ]------+---------<font></font>
version            | 3<font></font>
tree_level         | 3<font></font>
index_size         | 72802304<font></font>
root_block_no      | 2722<font></font>
internal_pages     | 241<font></font>
leaf_pages         | 8645<font></font>
empty_pages        | 0<font></font>
deleted_pages      | 0<font></font>
avg_leaf_density   | 83.77<font></font>
leaf_fragmentation | 64.25<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、テーブルとインデックスのサイズは次のとおりです。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> pg_size_pretty(pg_table_size(<span class="hljs-string">'vac'</span>)) table_size,<font></font>
  pg_size_pretty(pg_indexes_size(<span class="hljs-string">'vac'</span>)) index_size;
</code></pre><pre><code class="plaintext hljs"> table_size | index_size <font></font>
------------+------------<font></font>
 65 MB      | 69 MB<font></font>
(1 row)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての行の90％を削除します。</font><font style="vertical-align: inherit;">削除する行をランダムに選択するため、高い確率ですべてのページに少なくとも1つの行が残ります。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> vac <span class="hljs-keyword">WHERE</span> random() &lt; <span class="hljs-number">0.9</span>;
</code></pre><pre><code class="plaintext hljs">DELETE 450189
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のクリーニング後のオブジェクトのサイズは？</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">VACUUM</span> vac;<font></font>
=&gt; <span class="hljs-keyword">SELECT</span> pg_size_pretty(pg_table_size(<span class="hljs-string">'vac'</span>)) table_size,<font></font>
  pg_size_pretty(pg_indexes_size(<span class="hljs-string">'vac'</span>)) index_size;
</code></pre><pre><code class="plaintext hljs"> table_size | index_size <font></font>
------------+------------<font></font>
 65 MB      | 69 MB<font></font>
(1 row)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サイズは変更されていないことがわかります。通常のクリーニングではファイルのサイズを縮小できません。</font><font style="vertical-align: inherit;">情報の密度は明らかに約10倍減少していますが、</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> vac.tuple_percent, vac_s.avg_leaf_density
<span class="hljs-keyword">FROM</span> pgstattuple(<span class="hljs-string">'vac'</span>) vac, pgstatindex(<span class="hljs-string">'vac_s'</span>) vac_s;
</code></pre><pre><code class="plaintext hljs"> tuple_percent | avg_leaf_density <font></font>
---------------+------------------<font></font>
          9.41 |             9.73<font></font>
(1 row)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、完全なクリーニング後に何が起こるかを確認します。</font><font style="vertical-align: inherit;">以下は、テーブルとインデックスで現在使用されているファイルです。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> pg_relation_filepath(<span class="hljs-string">'vac'</span>), pg_relation_filepath(<span class="hljs-string">'vac_s'</span>);
</code></pre><pre><code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath <font></font>
----------------------+----------------------<font></font>
 base/41493/57392     | base/41493/57393<font></font>
(1 row)<font></font>
</code></pre><br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">VACUUM</span> <span class="hljs-keyword">FULL</span> vac;<font></font>
=&gt; <span class="hljs-keyword">SELECT</span> pg_relation_filepath(<span class="hljs-string">'vac'</span>), pg_relation_filepath(<span class="hljs-string">'vac_s'</span>);
</code></pre><pre><code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath <font></font>
----------------------+----------------------<font></font>
 base/41493/57404     | base/41493/57407<font></font>
(1 row)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これでファイルが新しいファイルに置き換えられました。</font><font style="vertical-align: inherit;">テーブルとインデックスのサイズが大幅に減少し、それに応じて情報の密度が増加しています。</font></font><br>
<br>
<pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> pg_size_pretty(pg_table_size(<span class="hljs-string">'vac'</span>)) table_size,<font></font>
  pg_size_pretty(pg_indexes_size(<span class="hljs-string">'vac'</span>)) index_size;
</code></pre><pre><code class="plaintext hljs"> table_size | index_size <font></font>
------------+------------<font></font>
 6648 kB    | 6480 kB<font></font>
(1 row)<font></font>
</code></pre><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword">SELECT</span> vac.tuple_percent, vac_s.avg_leaf_density
<span class="hljs-keyword">FROM</span> pgstattuple(<span class="hljs-string">'vac'</span>) vac, pgstatindex(<span class="hljs-string">'vac_s'</span>) vac_s;
</code></pre><pre><code class="plaintext hljs"> tuple_percent | avg_leaf_density <font></font>
---------------+------------------<font></font>
         94.39 |            91.08<font></font>
(1 row)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インデックス内の情報の密度は、元の情報と比較しても増加していることに注意してください。利用可能なデータからインデックス（Bツリー）を再作成すると、既存のインデックスに行ごとにデータを挿入するよりも収益性が高くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用した</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pgstattuple</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拡張関数</font><font style="vertical-align: inherit;">は、テーブル全体を読み取りました。テーブルが大きい場合、これは不便なため、可視性マップでマークされたページをスキップしておおよその数を表示する関数pgstattuple_approxがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに高速ですが、精度は低くなりますが、システムディレクトリ内のファイルサイズに対するデータボリュームの比率を推定します。このようなクエリのオプション</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はwikiにあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フルクリーンアップでは、テーブルのすべての作業（クエリを含む）がその作業の全期間にわたって完全にブロックされるため、通常の使用は必要ありません。</font><font style="vertical-align: inherit;">アクティブに使用されているシステムでは、これが受け入れられない場合があることは明らかです。</font><font style="vertical-align: inherit;">ロックは個別に考慮されますが、ここ</font><font style="vertical-align: inherit;">では、作業の終わりに短時間だけテーブルをロックする</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pg_repack</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拡張に言及することに限定し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同様のチーム</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テーブルとインデックスを完全に再構築するいくつかのコマンドがあり、これは完全なクリーンアップに似ています。それらのすべてがテーブルでの作業を完全にブロックし、すべてが古いデータファイルを削除して新しいファイルを作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CLUSTERコマンドは、すべての点でVACUUM FULLに似ていますが、さらに、使用可能なインデックスの1つに従って行バージョンを物理的に配置します。これにより、場合によってはスケジューラがインデックスアクセスをより効果的に使用できるようになります。ただし、クラスタリングはサポートされていないことを理解する必要があります。その後のテーブルの変更により、行バージョンの物理的な順序に違反します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
REINDEXコマンドは、テーブルの単一のインデックスを再構築します。実際、VACUUM FULLおよびCLUSTERはこのコマンドを使用してインデックスを再構築します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TRUNCATEコマンドは論理的にはDELETEと同じように機能し、すべてのテーブル行を削除します。</font><font style="vertical-align: inherit;">ただし、DELETEは、すでに説明したように、行のバージョンを削除済みとしてマークするだけであり、さらにクリーニングが必要です。</font><font style="vertical-align: inherit;">TRUNCATEは新しいクリーンなファイルを作成するだけです。</font><font style="vertical-align: inherit;">原則として、これはより高速に機能しますが、TRUNCATEは、トランザクションの終了までの時間全体にわたって、テーブルでの作業を完全にブロックすることに注意してください。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">続くこと</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja452306/index.html">フィンテックはどこへ行くのか、どのように単位経済を数えるのか、そしてなぜ国内起業家を育成するのか。ミタップ・ヤンデックス・マネー</a></li>
<li><a href="../ja452312/index.html">英国の通信は加入者に切断のための補償を支払います</a></li>
<li><a href="../ja452314/index.html">Cogmindの例に関するレベルとローグライクのデザイン</a></li>
<li><a href="../ja452316/index.html">Chang'e-4ミッション-第5太陰日の結果：Yutu-2ローバーの問題と新しい科学的発見</a></li>
<li><a href="../ja452318/index.html">Androidアプリケーションの画像ストレージとしてFirebaseを使用する</a></li>
<li><a href="../ja452322/index.html">Google Cloud Next '19の震源地から：CEOフィールドノート</a></li>
<li><a href="../ja452328/index.html">マトリョーシカC 層プログラム言語システム</a></li>
<li><a href="../ja452330/index.html">分散ペーパーレス四半期計画を実施し、それを台無しにしない方法は？</a></li>
<li><a href="../ja452332/index.html">オープンソースのプロジェクト管理者になるのは難しい</a></li>
<li><a href="../ja452334/index.html">インターネットで偽装する方法：サーバーと常駐プロキシを比較する</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>