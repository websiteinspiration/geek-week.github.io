<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Un poco sobre reubicaciones en el kernel de Linux   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Resolveremos un problema simple: seleccione un bloque de memoria en el espacio del kernel de Linux, coloque un c贸digo binario y ejec煤telo. Para hacer ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Un poco sobre reubicaciones en el kernel de Linux</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504442/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resolveremos un problema simple: seleccione un bloque de memoria en el espacio del kernel de Linux, coloque un c贸digo binario y ejec煤telo. </font><font style="vertical-align: inherit;">Para hacer esto, escribimos un m贸dulo kernel, en 茅l definimos la funci贸n foo, que desempe帽ar谩 el papel del c贸digo binario que necesitamos, luego, usando la funci贸n module_alloc, seleccione el bloque de memoria, copie toda esta funci贸n a trav茅s de memcpy y le damos el control. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As铆 es como se ve:</font></font><br>
<a name="habracut"></a><br>
<pre><code class="plaintext hljs">static noinline int foo(int ret)<font></font>
{<font></font>
	return (ret + 2);<font></font>
}<font></font>
<font></font>
static int exe_init(void)<font></font>
{<font></font>
	int ret = 0;<font></font>
	int (*new_foo)(int);<font></font>
<font></font>
	ret = foo(0);<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
<font></font>
	new_foo = module_alloc(PAGE_SIZE);<font></font>
	set_memory_x((unsigned long)new_foo, 1);<font></font>
<font></font>
	printk(KERN_INFO "foo=%lx new_foo=%lx\n",<font></font>
		(unsigned long)foo, (unsigned long)new_foo);<font></font>
<font></font>
	memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
<font></font>
	ret = new_foo(1);<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
<font></font>
	vfree(new_foo);<font></font>
	return 0;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se llama a la funci贸n exe_init cuando se carga el m贸dulo. </font><font style="vertical-align: inherit;">Observamos el resultado del trabajo en el registro del kernel:</font></font><br>
<br>
<pre><code class="plaintext hljs">[ 6972.522422] ret=2<font></font>
[ 6972.522443] foo=ffffffffc0000000 new_foo=ffffffffc0007000<font></font>
[ 6972.522457] ret=3<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo esta funcionando correctamente. </font><font style="vertical-align: inherit;">Y ahora agregamos la funci贸n printk a foo para mostrar el argumento:</font></font><br>
<br>
<pre><code class="plaintext hljs">static noinline int foo(int ret)<font></font>
{<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
	return (ret + 2);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
y volcar 25 bytes del contenido de la funci贸n new_foo () antes de pasarle el control:</font></font><br>
<br>
<pre><code class="plaintext hljs">	memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
	dump((unsigned long)new_foo);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
volcado se define como</font></font><br>
<br>
<pre><code class="plaintext hljs">static inline void dump(unsigned long x)<font></font>
{<font></font>
	int i;<font></font>
	for (i = 0; i &lt; 25; i++) \<font></font>
		pr_cont("%.2x ", *((unsigned char *)(x) + i) &amp; 0xFF); \<font></font>
	pr_cont("\n");<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cargamos el m贸dulo y tenemos un bloqueo con el siguiente mensaje en el registro:</font></font><br>
<br>
<pre><code class="plaintext hljs">[ 8482.806092] ret=0<font></font>
[ 8482.806092] ret=2<font></font>
[ 8482.806111] foo=ffffffffc0000000 new_foo=ffffffffc0007000<font></font>
[ 8482.806113] 53 89 fe 89 fb 48 c7 c7 24 10 00 c0 e8 e8 3d 0b c1 8d 43 02 5b c3 66 2e 0f <font></font>
[ 8482.806135] invalid opcode: 0000 [#1] SMP NOPTI<font></font>
[ 8482.806639] CPU: 0 PID: 5081 Comm: insmod Tainted: G           O      5.4.27 #12<font></font>
[ 8482.807669] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006<font></font>
[ 8482.808560] RIP: 0010:irq_create_direct_mapping+0x79/0x90<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De alguna manera, terminamos en la funci贸n irq_create_direct_mapping, aunque tuvimos que llamar a printk. </font><font style="vertical-align: inherit;">Averig眉emos qu茅 pas贸. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, eche un vistazo a la lista desmontada de la funci贸n foo. </font><font style="vertical-align: inherit;">Cons铆guelo con el comando objdump -d:</font></font><br>
<br>
<pre><code class="plaintext hljs">Disassembly of section .text:<font></font>
<font></font>
0000000000000000 &lt;foo&gt;:<font></font>
   0:	53                   	push   %rbx<font></font>
   1:	89 fe                	mov    %edi,%esi<font></font>
   3:	89 fb                	mov    %edi,%ebx<font></font>
   5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi<font></font>
   c:	e8 00 00 00 00       	callq  11 &lt;foo+0x11&gt;<font></font>
  11:	8d 43 02             	lea    0x2(%rbx),%eax<font></font>
  14:	5b                   	pop    %rbx<font></font>
  15:	c3                   	retq   <font></font>
  16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)<font></font>
  1d:	00 00 00 <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La funci贸n foo se encuentra al comienzo de la secci贸n de texto. En el desplazamiento 0xC, se encuentra el c贸digo de operaci贸n del comando de llamada cercana e8, ya que se ejecuta en el segmento de c贸digo actual, el valor del selector no cambia. Los siguientes 4 bytes son el desplazamiento relativo al valor en el registro RIP al cual se transferir谩 el control, es decir. RIP = RIP + offset, seg煤n la documentaci贸n de Intel (Intel 64 e IA-32 Architectures Software Developer's Manual, Instruction Reference Reference AZ):</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un desplazamiento relativo (rel16 o rel32) generalmente se especifica como una etiqueta en el c贸digo de ensamblaje. </font><font style="vertical-align: inherit;">Pero a nivel de c贸digo de m谩quina, se codifica como un valor inmediato firmado de 16 o 32 bits. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este valor se agrega al valor en el registro EIP (RIP). </font><font style="vertical-align: inherit;">En el modo de 64 bits, el desplazamiento relativo es siempre un valor inmediato de 32 bits que se extiende a 64 bits antes de agregarlo al valor en el registro RIP para el c谩lculo del objetivo.</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Conocemos la direcci贸n de la funci贸n foo, es 0xffffffffc0000000, entonces en RIP = 0xffffffffc0000000 + 0xc + 0x5 = 0xffffffffc00000011 (0xc es el desplazamiento de la instrucci贸n e8, 1 byte de la instrucci贸n y 4 bytes del desplazamiento). </font><font style="vertical-align: inherit;">Conocemos el desplazamiento, porque </font><font style="vertical-align: inherit;">funciones del cuerpo objeto de dumping. </font><font style="vertical-align: inherit;">Calculemos a d贸nde enviar谩 la llamada para enviarnos a la funci贸n foo:</font></font><br>
<br>
<pre><code class="plaintext hljs">0xffffffffc00000011 + 0xffffffffc10b3de8 = 0xffffffff810b3df9
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es la direcci贸n de la funci贸n printk:</font></font><br>
<pre><code class="plaintext hljs"># cat /proc/kallsyms | grep ffffffff810b3df9  <font></font>
ffffffff810b3df9 T printk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y ahora lo mismo ocurre con new_foo, cuya direcci贸n es 0xffffffffc0007000</font></font><br>
<br>
<pre><code class="plaintext hljs">0xffffffffc0007011 + 0xffffffffc10b3de8 = 0xffffffff810badf9
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No existe tal direcci贸n en kallsyms, pero hay 0xffffffff810badf9 - 0x79 = 0xffffffff810bad80</font></font><br>
<pre><code class="plaintext hljs"># cat /proc/kallsyms | grep ffffffff810bad80<font></font>
ffffffff810bad80 T irq_create_direct_mapping<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es la funci贸n en la que ocurri贸 el bloqueo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para evitar un bloqueo, simplemente recalcule el desplazamiento, conociendo la direcci贸n de la funci贸n new_foo:</font></font><br>
<br>
<pre><code class="plaintext hljs">memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
unsigned int delta = (unsigned long)printk - (unsigned long)new_foo - 0x11;<font></font>
*(unsigned int *)((void *)new_foo + 0xD) = delta;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu茅s de esta correcci贸n, no habr谩 bloqueo, la funci贸n new_foo se ejecutar谩 con 茅xito y devolver谩 el control. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema esta resuelto. </font><font style="vertical-align: inherit;">Solo queda entender por qu茅 en el desensamblador enumera el desplazamiento despu茅s de que el c贸digo de operaci贸n e8 es cero, pero no hay ninguna funci贸n en el volcado. </font><font style="vertical-align: inherit;">Para hacer esto, considere qu茅 son las reubicaciones y c贸mo funciona el n煤cleo con ellas. </font><font style="vertical-align: inherit;">Pero primero, un poco sobre el formato ELF.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ELF significa formato ejecutable y enlazable, el formato de archivos ejecutables y componibles. Un archivo ELF es una colecci贸n de secciones. La secci贸n almacena un conjunto de objetos necesarios para que el enlazador forme una imagen ejecutable: instrucciones, datos, tablas de s铆mbolos, registros de reubicaciones, etc. Cada secci贸n se describe mediante un encabezado. Todos los encabezados se recopilan en una tabla de encabezados y son esencialmente una matriz donde cada elemento tiene un 铆ndice. El encabezado de la secci贸n contiene un desplazamiento al comienzo de la secci贸n y otra informaci贸n general, como enlaces a otras secciones al especificar un 铆ndice en la tabla del encabezado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al armar nuestro caso de prueba, el compilador no conoce la direcci贸n de la funci贸n printk, por lo tanto, llena la ubicaci贸n de la llamada con un valor cero y, utilizando un registro de reubicaci贸n, le dice al n煤cleo que esta posici贸n debe llenarse con un valor v谩lido. Un registro de reubicaci贸n contiene un desplazamiento a la posici贸n en la que desea realizar cambios (posici贸n de reubicaci贸n), el tipo de reubicaci贸n y el 铆ndice del s铆mbolo en la tabla de s铆mbolos, cuya direcci贸n debe sustituirse en el desplazamiento especificado. 驴Para qu茅 es el tipo de reubicaci贸n? Considere a continuaci贸n. El encabezado de la secci贸n de registros de reubicaci贸n se refiere a trav茅s de 铆ndices a los encabezados de la secci贸n con una tabla de caracteres y secciones, en relaci贸n con el comienzo del cual se especifica un desplazamiento a la posici贸n de la reubicaci贸n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede ver el contenido de los registros de reubicaci贸n utilizando la utilidad objdump con el modificador -r.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De la lista desmontada, sabemos que en el desplazamiento 0xD es necesario escribir la direcci贸n de la funci贸n printk, por lo tanto, buscamos la salida objdump con la siguiente posici贸n:</font></font><br>
<br>
<pre><code class="plaintext hljs">000000000000000d R_X86_64_PC32     printk-0x0000000000000004
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, tenemos el registro de reubicaci贸n necesario que indica la posici贸n en el desplazamiento 0xD, y el nombre del s铆mbolo cuya direcci贸n debe escribirse en esta posici贸n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Valor (-4). </font><font style="vertical-align: inherit;">que se agrega a la direcci贸n de la funci贸n printk se denomina anexo y se tiene en cuenta al calcular el resultado final de la reubicaci贸n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora mira el s铆mbolo printk:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ objdump -t exe.ko | grep printk<font></font>
0000000000000000         *UND*	0000000000000000 printk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay un s铆mbolo, est谩 indefinido dentro del m贸dulo (indefinido), por lo que lo buscaremos en el n煤cleo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ser谩 m谩s informativo mirar los registros de reubicaci贸n y s铆mbolos en forma binaria. </font><font style="vertical-align: inherit;">Esto se puede hacer con wireshark, puede analizar el formato ELF. </font><font style="vertical-align: inherit;">Aqu铆 est谩 nuestra entrada de reubicaci贸n (copie y pegue de writeshark, LSB a la izquierda):</font></font><br>
<br>
<pre><code class="plaintext hljs">  0d 00 00 00 00 00 00 00  02 00 00 00 22 00 00 00  fc ff ff ff ff ff ff ff<font></font>
  |                     |  |          ||         |  |                     |<font></font>
  +----  -------+  +--  ---++---+  +---- addendum  ------+<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compare esta entrada con la definici贸n de la estructura correspondiente de &lt;linux / elf.h&gt;:</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct elf64_rela {<font></font>
  Elf64_Addr r_offset;	/* Location at which to apply the action */<font></font>
  Elf64_Xword r_info;	/* index and type of relocation */<font></font>
  Elf64_Sxword r_addend;	/* Constant addend used to compute value */<font></font>
} Elf64_Rela;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu铆 tenemos 8 bytes de desplazamiento 0x00000000d, 4 bytes tipo 0x00000002, 铆ndice de 4 bytes en la tabla de caracteres 0x00000022 (o 34 en decimal) y 8 bytes de adici贸n -4. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y aqu铆 est谩 la entrada de la tabla de s铆mbolos en el n煤mero 34:</font></font><br>
<br>
<pre><code class="plaintext hljs">  01 01 00 00 10 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
y estructura relacionada</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct elf64_sym {<font></font>
  Elf64_Word st_name;		/* Symbol name, index in string tbl */<font></font>
  unsigned char	st_info;	/* Type and binding attributes */<font></font>
  unsigned char	st_other;	/* No defined meaning, 0 */<font></font>
  Elf64_Half st_shndx;		/* Associated section index */<font></font>
  Elf64_Addr st_value;		/* Value of the symbol */<font></font>
  Elf64_Xword st_size;		/* Associated symbol size */<font></font>
} Elf64_Sym;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los primeros 4 bytes 0x00000101 es el 铆ndice en la tabla de cadenas .strtab al nombre de este car谩cter, es decir. printk. El campo st_info define el tipo de s铆mbolo, puede ser una funci贸n, un objeto de datos, etc. Consulte la especificaci贸n ELF para obtener m谩s detalles. Omitiremos el campo st_other, ahora no nos interesa y miraremos los 煤ltimos tres campos st_shndx, st_value y st_size. st_shndx: el 铆ndice del encabezado de la secci贸n en la que se define el car谩cter. Vemos aqu铆 un valor cero, porque el s铆mbolo no est谩 definido dentro del m贸dulo, no est谩 en las secciones disponibles. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En consecuencia, su valor st_value y su tama帽o st_size tambi茅n son cero. Estos campos ser谩n llenados por el n煤cleo al cargar el m贸dulo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comparar, mira el s铆mbolo foo, que est谩 claramente presente:</font></font><br>
<br>
<pre><code class="plaintext hljs">  08 00 00 00 02 00 02 00  00 00 00 00 00 00 00 00  16 00 00 00 00 00 00 00
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El s铆mbolo define una funci贸n que se encuentra en la secci贸n .text en la direcci贸n relativa al comienzo de la secci贸n 0x00000000, es decir. </font><font style="vertical-align: inherit;">Al principio de la secci贸n, como vimos en la lista desmontada, el tama帽o de la funci贸n es de 22 bytes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Objdump nos mostrar谩 la misma informaci贸n sobre esto:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ objdump -t exe.ko | grep foo<font></font>
0000000000000000 l     F .text	0000000000000016 foo<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando el n煤cleo carga el m贸dulo, encuentra todos los caracteres Indefinidos y llena los campos st_value y st_size con valores v谩lidos. </font><font style="vertical-align: inherit;">Esto se hace en la funci贸n simplify_symbols, archivo kernel / module.c:</font></font><br>
<br>
<pre><code class="plaintext hljs">/* Change all symbols so that st_value encodes the pointer directly. */<font></font>
static int simplify_symbols(struct module *mod, const struct load_info *info)<font></font>
{<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En los par谩metros de la funci贸n, se pasa la estructura load_info del siguiente formulario</font></font><br>
<br>
<pre><code class="plaintext hljs">struct load_info {<font></font>
	const char *name;<font></font>
	/* pointer to module in temporary copy, freed at end of load_module() */<font></font>
	struct module *mod;<font></font>
	Elf_Ehdr *hdr;<font></font>
	unsigned long len;<font></font>
	Elf_Shdr *sechdrs;<font></font>
	char *secstrings, *strtab;<font></font>
	unsigned long symoffs, stroffs, init_typeoffs, core_typeoffs;<font></font>
	struct _ddebug *debug;<font></font>
	unsigned int num_debug;<font></font>
	bool sig_ok;<font></font>
#ifdef CONFIG_KALLSYMS<font></font>
	unsigned long mod_kallsyms_init_off;<font></font>
#endif<font></font>
	struct {<font></font>
		unsigned int sym, str, mod, vers, info, pcpu;<font></font>
	} index;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los siguientes campos nos interesan: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - hdr - encabezado de archivo ELF </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - sechdrs - puntero a la tabla de encabezado de secci贸n </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - strtab - tabla de nombre de s铆mbolo - un conjunto de cadenas separadas por ceros </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - index.sym - 铆ndice del encabezado de secci贸n que contiene la tabla de s铆mbolo En </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
primer lugar, la funci贸n tendr谩 acceso a la secci贸n con la tabla de s铆mbolos. </font><font style="vertical-align: inherit;">La tabla de s铆mbolos es una matriz de elementos de tipo Elf64_Sym:</font></font><br>
<br>
<pre><code class="plaintext hljs">Elf64_Shdr *symsec = &amp;info-&gt;sechdrs[info-&gt;index.sym];<font></font>
Elf64_Sym *sym = (void *)symsec-&gt;sh_addr;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci贸n, en el bucle, revisamos todos los caracteres de la tabla, determinando para cada uno su nombre:</font></font><br>
<pre><code class="plaintext hljs">for (i = 1; i &lt; symsec-&gt;sh_size / sizeof(Elf_Sym); i++) {<font></font>
	const char *name = info-&gt;strtab + sym[i].st_name;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El campo st_shndx contiene el 铆ndice del encabezado de la secci贸n en la que se define este car谩cter. </font><font style="vertical-align: inherit;">Si hay un valor cero (nuestro caso), entonces este s铆mbolo no est谩 dentro del m贸dulo, debe buscarlo en el n煤cleo:</font></font><br>
<br>
<pre><code class="plaintext hljs">	switch (sym[i].st_shndx) {<font></font>
	.....<font></font>
	 case SHN_UNDEF: //  0<font></font>
	ksym = resolve_symbol_wait(mod, info, name);<font></font>
 	/* Ok if resolved.  */<font></font>
	if (ksym &amp;&amp; !IS_ERR(ksym)) {<font></font>
		sym[i].st_value = kernel_symbol_value(ksym);<font></font>
		break;<font></font>
	}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego viene la cola de reubicaci贸n en la funci贸n apply_relocations:</font></font><br>
<br>
<pre><code class="plaintext hljs">static int apply_relocations(struct module *mod, const struct load_info *info)<font></font>
{<font></font>
	unsigned int i;<font></font>
	int err = 0;<font></font>
<font></font>
	/* Now do relocations. */<font></font>
	for (i = 1; i &lt; info-&gt;hdr-&gt;e_shnum; i++) {<font></font>
	.....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el bucle, buscamos secciones de reubicaci贸n y procesamos los registros de cada secci贸n que se encuentra en la funci贸n apply_relocate_add:</font></font><br>
<br>
<pre><code class="plaintext hljs">if (info-&gt;sechdrs[i].sh_type == SHT_RELA) //   <font></font>
	err = apply_relocate_add(info-&gt;sechdrs, info-&gt;strtab,<font></font>
				info-&gt;index.sym, i, mod);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un puntero a una tabla de encabezado de secci贸n, un puntero a una tabla de nombre de s铆mbolo, un 铆ndice de encabezado de secci贸n con una tabla de s铆mbolos y un 铆ndice de encabezado de secci贸n de reubicaci贸n se pasan a apply_relocate_add:</font></font><br>
<br>
<pre><code class="plaintext hljs">int apply_relocate_add(Elf64_Shdr *sechdrs,<font></font>
	   const char *strtab,<font></font>
	   unsigned int symindex,<font></font>
	   unsigned int relsec,<font></font>
	   struct module *me)<font></font>
{<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero abordamos la secci贸n de reubicaciones:</font></font><br>
<br>
<pre><code class="plaintext hljs">Elf64_Rela *rel = (void *)sechdrs[relsec].sh_addr;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego, en un bucle, itere sobre la matriz de sus entradas:</font></font><br>
<br>
<pre><code class="plaintext hljs">for (i = 0; i &lt; sechdrs[relsec].sh_size / sizeof(*rel); i++) {
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encontramos la secci贸n para la reubicaci贸n y la posici贸n en ella, es decir. </font><font style="vertical-align: inherit;">donde necesitamos hacer cambios. </font><font style="vertical-align: inherit;">El campo sh_info del encabezado de la secci贸n de reubicaci贸n es el 铆ndice del encabezado de secci贸n para la reubicaci贸n, el campo r_offset del registro de reubicaci贸n es el desplazamiento a la posici贸n dentro de la secci贸n para la reubicaci贸n:</font></font><br>
<br>
<pre><code class="plaintext hljs">/* This is where to make the change */<font></font>
loc = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr + rel[i].r_offset;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La direcci贸n del personaje que se sustituir谩 en esta posici贸n, teniendo en cuenta la adici贸n. </font><font style="vertical-align: inherit;">El campo r_info de la entrada de reubicaci贸n contiene el 铆ndice de este s铆mbolo en la tabla de s铆mbolos:</font></font><br>
<br>
<pre><code class="plaintext hljs">	/* This is the symbol it is referring to.  Note that all<font></font>
	   undefined symbols have been resolved.  */<font></font>
	sym = (Elf64_Sym *)sechdrs[symindex].sh_addr<font></font>
		+ ELF64_R_SYM(rel[i].r_info);<font></font>
<font></font>
	val = sym-&gt;st_value + rel[i].r_addend;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El tipo de reubicaci贸n determina el resultado final de los c谩lculos, en nuestro ejemplo es R_X86_64_PLT32:</font></font><br>
<br>
<pre><code class="plaintext hljs">	switch (ELF64_R_TYPE(rel[i].r_info)) {<font></font>
	......<font></font>
	case R_X86_64_PLT32:	<font></font>
		if (*(u32 *)loc != 0)<font></font>
			goto invalid_relocation;<font></font>
		val -= (u64)loc;	//   <font></font>
		*(u32 *)loc = val;  //    <font></font>
		break;<font></font>
	.....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora podemos calcular el valor final nosotros mismos, sabiendo que sym-&gt; st_value es la direcci贸n de la funci贸n printk 0xffffffff810b3df9, r_addend es (-4), el desplazamiento a la posici贸n de reubicaci贸n es 0xd desde el comienzo de la secci贸n de texto del m贸dulo, o desde el comienzo de la funci贸n foo, es decir. </font><font style="vertical-align: inherit;">ser谩 ffffffffc000000d. </font><font style="vertical-align: inherit;">Sustituya todos estos valores y obtenga:</font></font><br>
<br>
<pre><code class="plaintext hljs">val = (u32)(0xffffffff810b3df9 - 0x4 - 0xffffffffc000000d) = 0xc10b3de8
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos el volcado de la funci贸n foo, que obtuvimos al principio:</font></font><br>
<br>
<pre><code class="plaintext hljs">53 89 fe 89 fb 48 c7 c7 24 10 00 c0 e8 e8 3d 0b c1 8d 43 02 5b c3 66 2e 0f
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el desplazamiento 0xD, se encuentra el valor 0xc10b3de8, que es id茅ntico al que calculamos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As铆 es como el n煤cleo procesa las reubicaciones y obtiene el desplazamiento necesario para el comando de cierre de llamada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al preparar el art铆culo, se utiliz贸 la versi贸n 5.4.27 del kernel de Linux.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es504414/index.html">C贸mo Microsoft mat贸 a AppGet</a></li>
<li><a href="../es504420/index.html">Escribir una arena PvP por turnos con movimientos simult谩neos</a></li>
<li><a href="../es504430/index.html">Everyday Life Tinkoff Security Operations Center: an谩lisis de cargador de arranque 煤nico</a></li>
<li><a href="../es504434/index.html">Programa educativo para padres: c贸mo proteger a los ni帽os del peligro en Internet</a></li>
<li><a href="../es504438/index.html">30 mitaps por semana. Abrimos la temporada de verano 2020</a></li>
<li><a href="../es504444/index.html">Usando docker multi-etapa para construir im谩genes de Windows</a></li>
<li><a href="../es504448/index.html">Gamers Generation II</a></li>
<li><a href="../es504450/index.html">JavaScript moderno: una vista lateral</a></li>
<li><a href="../es504452/index.html">Ontology lanza la capa 2, contribuyendo a una plataforma de cadena p煤blica m谩s integrada</a></li>
<li><a href="../es504454/index.html">Los mejores repositorios de GitHub para desarrolladores web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>