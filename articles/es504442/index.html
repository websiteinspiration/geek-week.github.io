<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍰 🎉 👐🏼 Un poco sobre reubicaciones en el kernel de Linux 🏇🏾 👛 🕕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Resolveremos un problema simple: seleccione un bloque de memoria en el espacio del kernel de Linux, coloque un código binario y ejecútelo. Para hacer ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Un poco sobre reubicaciones en el kernel de Linux</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504442/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resolveremos un problema simple: seleccione un bloque de memoria en el espacio del kernel de Linux, coloque un código binario y ejecútelo. </font><font style="vertical-align: inherit;">Para hacer esto, escribimos un módulo kernel, en él definimos la función foo, que desempeñará el papel del código binario que necesitamos, luego, usando la función module_alloc, seleccione el bloque de memoria, copie toda esta función a través de memcpy y le damos el control. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Así es como se ve:</font></font><br>
<a name="habracut"></a><br>
<pre><code class="plaintext hljs">static noinline int foo(int ret)<font></font>
{<font></font>
	return (ret + 2);<font></font>
}<font></font>
<font></font>
static int exe_init(void)<font></font>
{<font></font>
	int ret = 0;<font></font>
	int (*new_foo)(int);<font></font>
<font></font>
	ret = foo(0);<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
<font></font>
	new_foo = module_alloc(PAGE_SIZE);<font></font>
	set_memory_x((unsigned long)new_foo, 1);<font></font>
<font></font>
	printk(KERN_INFO "foo=%lx new_foo=%lx\n",<font></font>
		(unsigned long)foo, (unsigned long)new_foo);<font></font>
<font></font>
	memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
<font></font>
	ret = new_foo(1);<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
<font></font>
	vfree(new_foo);<font></font>
	return 0;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se llama a la función exe_init cuando se carga el módulo. </font><font style="vertical-align: inherit;">Observamos el resultado del trabajo en el registro del kernel:</font></font><br>
<br>
<pre><code class="plaintext hljs">[ 6972.522422] ret=2<font></font>
[ 6972.522443] foo=ffffffffc0000000 new_foo=ffffffffc0007000<font></font>
[ 6972.522457] ret=3<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo esta funcionando correctamente. </font><font style="vertical-align: inherit;">Y ahora agregamos la función printk a foo para mostrar el argumento:</font></font><br>
<br>
<pre><code class="plaintext hljs">static noinline int foo(int ret)<font></font>
{<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
	return (ret + 2);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
y volcar 25 bytes del contenido de la función new_foo () antes de pasarle el control:</font></font><br>
<br>
<pre><code class="plaintext hljs">	memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
	dump((unsigned long)new_foo);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
volcado se define como</font></font><br>
<br>
<pre><code class="plaintext hljs">static inline void dump(unsigned long x)<font></font>
{<font></font>
	int i;<font></font>
	for (i = 0; i &lt; 25; i++) \<font></font>
		pr_cont("%.2x ", *((unsigned char *)(x) + i) &amp; 0xFF); \<font></font>
	pr_cont("\n");<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cargamos el módulo y tenemos un bloqueo con el siguiente mensaje en el registro:</font></font><br>
<br>
<pre><code class="plaintext hljs">[ 8482.806092] ret=0<font></font>
[ 8482.806092] ret=2<font></font>
[ 8482.806111] foo=ffffffffc0000000 new_foo=ffffffffc0007000<font></font>
[ 8482.806113] 53 89 fe 89 fb 48 c7 c7 24 10 00 c0 e8 e8 3d 0b c1 8d 43 02 5b c3 66 2e 0f <font></font>
[ 8482.806135] invalid opcode: 0000 [#1] SMP NOPTI<font></font>
[ 8482.806639] CPU: 0 PID: 5081 Comm: insmod Tainted: G           O      5.4.27 #12<font></font>
[ 8482.807669] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006<font></font>
[ 8482.808560] RIP: 0010:irq_create_direct_mapping+0x79/0x90<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De alguna manera, terminamos en la función irq_create_direct_mapping, aunque tuvimos que llamar a printk. </font><font style="vertical-align: inherit;">Averigüemos qué pasó. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, eche un vistazo a la lista desmontada de la función foo. </font><font style="vertical-align: inherit;">Consíguelo con el comando objdump -d:</font></font><br>
<br>
<pre><code class="plaintext hljs">Disassembly of section .text:<font></font>
<font></font>
0000000000000000 &lt;foo&gt;:<font></font>
   0:	53                   	push   %rbx<font></font>
   1:	89 fe                	mov    %edi,%esi<font></font>
   3:	89 fb                	mov    %edi,%ebx<font></font>
   5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi<font></font>
   c:	e8 00 00 00 00       	callq  11 &lt;foo+0x11&gt;<font></font>
  11:	8d 43 02             	lea    0x2(%rbx),%eax<font></font>
  14:	5b                   	pop    %rbx<font></font>
  15:	c3                   	retq   <font></font>
  16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)<font></font>
  1d:	00 00 00 <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La función foo se encuentra al comienzo de la sección de texto. En el desplazamiento 0xC, se encuentra el código de operación del comando de llamada cercana e8, ya que se ejecuta en el segmento de código actual, el valor del selector no cambia. Los siguientes 4 bytes son el desplazamiento relativo al valor en el registro RIP al cual se transferirá el control, es decir. RIP = RIP + offset, según la documentación de Intel (Intel 64 e IA-32 Architectures Software Developer's Manual, Instruction Reference Reference AZ):</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un desplazamiento relativo (rel16 o rel32) generalmente se especifica como una etiqueta en el código de ensamblaje. </font><font style="vertical-align: inherit;">Pero a nivel de código de máquina, se codifica como un valor inmediato firmado de 16 o 32 bits. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este valor se agrega al valor en el registro EIP (RIP). </font><font style="vertical-align: inherit;">En el modo de 64 bits, el desplazamiento relativo es siempre un valor inmediato de 32 bits que se extiende a 64 bits antes de agregarlo al valor en el registro RIP para el cálculo del objetivo.</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Conocemos la dirección de la función foo, es 0xffffffffc0000000, entonces en RIP = 0xffffffffc0000000 + 0xc + 0x5 = 0xffffffffc00000011 (0xc es el desplazamiento de la instrucción e8, 1 byte de la instrucción y 4 bytes del desplazamiento). </font><font style="vertical-align: inherit;">Conocemos el desplazamiento, porque </font><font style="vertical-align: inherit;">funciones del cuerpo objeto de dumping. </font><font style="vertical-align: inherit;">Calculemos a dónde enviará la llamada para enviarnos a la función foo:</font></font><br>
<br>
<pre><code class="plaintext hljs">0xffffffffc00000011 + 0xffffffffc10b3de8 = 0xffffffff810b3df9
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es la dirección de la función printk:</font></font><br>
<pre><code class="plaintext hljs"># cat /proc/kallsyms | grep ffffffff810b3df9  <font></font>
ffffffff810b3df9 T printk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y ahora lo mismo ocurre con new_foo, cuya dirección es 0xffffffffc0007000</font></font><br>
<br>
<pre><code class="plaintext hljs">0xffffffffc0007011 + 0xffffffffc10b3de8 = 0xffffffff810badf9
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No existe tal dirección en kallsyms, pero hay 0xffffffff810badf9 - 0x79 = 0xffffffff810bad80</font></font><br>
<pre><code class="plaintext hljs"># cat /proc/kallsyms | grep ffffffff810bad80<font></font>
ffffffff810bad80 T irq_create_direct_mapping<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es la función en la que ocurrió el bloqueo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para evitar un bloqueo, simplemente recalcule el desplazamiento, conociendo la dirección de la función new_foo:</font></font><br>
<br>
<pre><code class="plaintext hljs">memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
unsigned int delta = (unsigned long)printk - (unsigned long)new_foo - 0x11;<font></font>
*(unsigned int *)((void *)new_foo + 0xD) = delta;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de esta corrección, no habrá bloqueo, la función new_foo se ejecutará con éxito y devolverá el control. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema esta resuelto. </font><font style="vertical-align: inherit;">Solo queda entender por qué en el desensamblador enumera el desplazamiento después de que el código de operación e8 es cero, pero no hay ninguna función en el volcado. </font><font style="vertical-align: inherit;">Para hacer esto, considere qué son las reubicaciones y cómo funciona el núcleo con ellas. </font><font style="vertical-align: inherit;">Pero primero, un poco sobre el formato ELF.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ELF significa formato ejecutable y enlazable, el formato de archivos ejecutables y componibles. Un archivo ELF es una colección de secciones. La sección almacena un conjunto de objetos necesarios para que el enlazador forme una imagen ejecutable: instrucciones, datos, tablas de símbolos, registros de reubicaciones, etc. Cada sección se describe mediante un encabezado. Todos los encabezados se recopilan en una tabla de encabezados y son esencialmente una matriz donde cada elemento tiene un índice. El encabezado de la sección contiene un desplazamiento al comienzo de la sección y otra información general, como enlaces a otras secciones al especificar un índice en la tabla del encabezado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al armar nuestro caso de prueba, el compilador no conoce la dirección de la función printk, por lo tanto, llena la ubicación de la llamada con un valor cero y, utilizando un registro de reubicación, le dice al núcleo que esta posición debe llenarse con un valor válido. Un registro de reubicación contiene un desplazamiento a la posición en la que desea realizar cambios (posición de reubicación), el tipo de reubicación y el índice del símbolo en la tabla de símbolos, cuya dirección debe sustituirse en el desplazamiento especificado. ¿Para qué es el tipo de reubicación? Considere a continuación. El encabezado de la sección de registros de reubicación se refiere a través de índices a los encabezados de la sección con una tabla de caracteres y secciones, en relación con el comienzo del cual se especifica un desplazamiento a la posición de la reubicación. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede ver el contenido de los registros de reubicación utilizando la utilidad objdump con el modificador -r.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De la lista desmontada, sabemos que en el desplazamiento 0xD es necesario escribir la dirección de la función printk, por lo tanto, buscamos la salida objdump con la siguiente posición:</font></font><br>
<br>
<pre><code class="plaintext hljs">000000000000000d R_X86_64_PC32     printk-0x0000000000000004
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, tenemos el registro de reubicación necesario que indica la posición en el desplazamiento 0xD, y el nombre del símbolo cuya dirección debe escribirse en esta posición. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Valor (-4). </font><font style="vertical-align: inherit;">que se agrega a la dirección de la función printk se denomina anexo y se tiene en cuenta al calcular el resultado final de la reubicación. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora mira el símbolo printk:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ objdump -t exe.ko | grep printk<font></font>
0000000000000000         *UND*	0000000000000000 printk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay un símbolo, está indefinido dentro del módulo (indefinido), por lo que lo buscaremos en el núcleo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Será más informativo mirar los registros de reubicación y símbolos en forma binaria. </font><font style="vertical-align: inherit;">Esto se puede hacer con wireshark, puede analizar el formato ELF. </font><font style="vertical-align: inherit;">Aquí está nuestra entrada de reubicación (copie y pegue de writeshark, LSB a la izquierda):</font></font><br>
<br>
<pre><code class="plaintext hljs">  0d 00 00 00 00 00 00 00  02 00 00 00 22 00 00 00  fc ff ff ff ff ff ff ff<font></font>
  |                     |  |          ||         |  |                     |<font></font>
  +----  -------+  +--  ---++---+  +---- addendum  ------+<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compare esta entrada con la definición de la estructura correspondiente de &lt;linux / elf.h&gt;:</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct elf64_rela {<font></font>
  Elf64_Addr r_offset;	/* Location at which to apply the action */<font></font>
  Elf64_Xword r_info;	/* index and type of relocation */<font></font>
  Elf64_Sxword r_addend;	/* Constant addend used to compute value */<font></font>
} Elf64_Rela;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí tenemos 8 bytes de desplazamiento 0x00000000d, 4 bytes tipo 0x00000002, índice de 4 bytes en la tabla de caracteres 0x00000022 (o 34 en decimal) y 8 bytes de adición -4. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y aquí está la entrada de la tabla de símbolos en el número 34:</font></font><br>
<br>
<pre><code class="plaintext hljs">  01 01 00 00 10 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
y estructura relacionada</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct elf64_sym {<font></font>
  Elf64_Word st_name;		/* Symbol name, index in string tbl */<font></font>
  unsigned char	st_info;	/* Type and binding attributes */<font></font>
  unsigned char	st_other;	/* No defined meaning, 0 */<font></font>
  Elf64_Half st_shndx;		/* Associated section index */<font></font>
  Elf64_Addr st_value;		/* Value of the symbol */<font></font>
  Elf64_Xword st_size;		/* Associated symbol size */<font></font>
} Elf64_Sym;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los primeros 4 bytes 0x00000101 es el índice en la tabla de cadenas .strtab al nombre de este carácter, es decir. printk. El campo st_info define el tipo de símbolo, puede ser una función, un objeto de datos, etc. Consulte la especificación ELF para obtener más detalles. Omitiremos el campo st_other, ahora no nos interesa y miraremos los últimos tres campos st_shndx, st_value y st_size. st_shndx: el índice del encabezado de la sección en la que se define el carácter. Vemos aquí un valor cero, porque el símbolo no está definido dentro del módulo, no está en las secciones disponibles. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En consecuencia, su valor st_value y su tamaño st_size también son cero. Estos campos serán llenados por el núcleo al cargar el módulo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comparar, mira el símbolo foo, que está claramente presente:</font></font><br>
<br>
<pre><code class="plaintext hljs">  08 00 00 00 02 00 02 00  00 00 00 00 00 00 00 00  16 00 00 00 00 00 00 00
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El símbolo define una función que se encuentra en la sección .text en la dirección relativa al comienzo de la sección 0x00000000, es decir. </font><font style="vertical-align: inherit;">Al principio de la sección, como vimos en la lista desmontada, el tamaño de la función es de 22 bytes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Objdump nos mostrará la misma información sobre esto:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ objdump -t exe.ko | grep foo<font></font>
0000000000000000 l     F .text	0000000000000016 foo<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando el núcleo carga el módulo, encuentra todos los caracteres Indefinidos y llena los campos st_value y st_size con valores válidos. </font><font style="vertical-align: inherit;">Esto se hace en la función simplify_symbols, archivo kernel / module.c:</font></font><br>
<br>
<pre><code class="plaintext hljs">/* Change all symbols so that st_value encodes the pointer directly. */<font></font>
static int simplify_symbols(struct module *mod, const struct load_info *info)<font></font>
{<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En los parámetros de la función, se pasa la estructura load_info del siguiente formulario</font></font><br>
<br>
<pre><code class="plaintext hljs">struct load_info {<font></font>
	const char *name;<font></font>
	/* pointer to module in temporary copy, freed at end of load_module() */<font></font>
	struct module *mod;<font></font>
	Elf_Ehdr *hdr;<font></font>
	unsigned long len;<font></font>
	Elf_Shdr *sechdrs;<font></font>
	char *secstrings, *strtab;<font></font>
	unsigned long symoffs, stroffs, init_typeoffs, core_typeoffs;<font></font>
	struct _ddebug *debug;<font></font>
	unsigned int num_debug;<font></font>
	bool sig_ok;<font></font>
#ifdef CONFIG_KALLSYMS<font></font>
	unsigned long mod_kallsyms_init_off;<font></font>
#endif<font></font>
	struct {<font></font>
		unsigned int sym, str, mod, vers, info, pcpu;<font></font>
	} index;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los siguientes campos nos interesan: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - hdr - encabezado de archivo ELF </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - sechdrs - puntero a la tabla de encabezado de sección </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - strtab - tabla de nombre de símbolo - un conjunto de cadenas separadas por ceros </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - index.sym - índice del encabezado de sección que contiene la tabla de símbolo En </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
primer lugar, la función tendrá acceso a la sección con la tabla de símbolos. </font><font style="vertical-align: inherit;">La tabla de símbolos es una matriz de elementos de tipo Elf64_Sym:</font></font><br>
<br>
<pre><code class="plaintext hljs">Elf64_Shdr *symsec = &amp;info-&gt;sechdrs[info-&gt;index.sym];<font></font>
Elf64_Sym *sym = (void *)symsec-&gt;sh_addr;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuación, en el bucle, revisamos todos los caracteres de la tabla, determinando para cada uno su nombre:</font></font><br>
<pre><code class="plaintext hljs">for (i = 1; i &lt; symsec-&gt;sh_size / sizeof(Elf_Sym); i++) {<font></font>
	const char *name = info-&gt;strtab + sym[i].st_name;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El campo st_shndx contiene el índice del encabezado de la sección en la que se define este carácter. </font><font style="vertical-align: inherit;">Si hay un valor cero (nuestro caso), entonces este símbolo no está dentro del módulo, debe buscarlo en el núcleo:</font></font><br>
<br>
<pre><code class="plaintext hljs">	switch (sym[i].st_shndx) {<font></font>
	.....<font></font>
	 case SHN_UNDEF: //  0<font></font>
	ksym = resolve_symbol_wait(mod, info, name);<font></font>
 	/* Ok if resolved.  */<font></font>
	if (ksym &amp;&amp; !IS_ERR(ksym)) {<font></font>
		sym[i].st_value = kernel_symbol_value(ksym);<font></font>
		break;<font></font>
	}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego viene la cola de reubicación en la función apply_relocations:</font></font><br>
<br>
<pre><code class="plaintext hljs">static int apply_relocations(struct module *mod, const struct load_info *info)<font></font>
{<font></font>
	unsigned int i;<font></font>
	int err = 0;<font></font>
<font></font>
	/* Now do relocations. */<font></font>
	for (i = 1; i &lt; info-&gt;hdr-&gt;e_shnum; i++) {<font></font>
	.....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el bucle, buscamos secciones de reubicación y procesamos los registros de cada sección que se encuentra en la función apply_relocate_add:</font></font><br>
<br>
<pre><code class="plaintext hljs">if (info-&gt;sechdrs[i].sh_type == SHT_RELA) //   <font></font>
	err = apply_relocate_add(info-&gt;sechdrs, info-&gt;strtab,<font></font>
				info-&gt;index.sym, i, mod);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un puntero a una tabla de encabezado de sección, un puntero a una tabla de nombre de símbolo, un índice de encabezado de sección con una tabla de símbolos y un índice de encabezado de sección de reubicación se pasan a apply_relocate_add:</font></font><br>
<br>
<pre><code class="plaintext hljs">int apply_relocate_add(Elf64_Shdr *sechdrs,<font></font>
	   const char *strtab,<font></font>
	   unsigned int symindex,<font></font>
	   unsigned int relsec,<font></font>
	   struct module *me)<font></font>
{<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero abordamos la sección de reubicaciones:</font></font><br>
<br>
<pre><code class="plaintext hljs">Elf64_Rela *rel = (void *)sechdrs[relsec].sh_addr;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego, en un bucle, itere sobre la matriz de sus entradas:</font></font><br>
<br>
<pre><code class="plaintext hljs">for (i = 0; i &lt; sechdrs[relsec].sh_size / sizeof(*rel); i++) {
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encontramos la sección para la reubicación y la posición en ella, es decir. </font><font style="vertical-align: inherit;">donde necesitamos hacer cambios. </font><font style="vertical-align: inherit;">El campo sh_info del encabezado de la sección de reubicación es el índice del encabezado de sección para la reubicación, el campo r_offset del registro de reubicación es el desplazamiento a la posición dentro de la sección para la reubicación:</font></font><br>
<br>
<pre><code class="plaintext hljs">/* This is where to make the change */<font></font>
loc = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr + rel[i].r_offset;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La dirección del personaje que se sustituirá en esta posición, teniendo en cuenta la adición. </font><font style="vertical-align: inherit;">El campo r_info de la entrada de reubicación contiene el índice de este símbolo en la tabla de símbolos:</font></font><br>
<br>
<pre><code class="plaintext hljs">	/* This is the symbol it is referring to.  Note that all<font></font>
	   undefined symbols have been resolved.  */<font></font>
	sym = (Elf64_Sym *)sechdrs[symindex].sh_addr<font></font>
		+ ELF64_R_SYM(rel[i].r_info);<font></font>
<font></font>
	val = sym-&gt;st_value + rel[i].r_addend;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El tipo de reubicación determina el resultado final de los cálculos, en nuestro ejemplo es R_X86_64_PLT32:</font></font><br>
<br>
<pre><code class="plaintext hljs">	switch (ELF64_R_TYPE(rel[i].r_info)) {<font></font>
	......<font></font>
	case R_X86_64_PLT32:	<font></font>
		if (*(u32 *)loc != 0)<font></font>
			goto invalid_relocation;<font></font>
		val -= (u64)loc;	//   <font></font>
		*(u32 *)loc = val;  //    <font></font>
		break;<font></font>
	.....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora podemos calcular el valor final nosotros mismos, sabiendo que sym-&gt; st_value es la dirección de la función printk 0xffffffff810b3df9, r_addend es (-4), el desplazamiento a la posición de reubicación es 0xd desde el comienzo de la sección de texto del módulo, o desde el comienzo de la función foo, es decir. </font><font style="vertical-align: inherit;">será ffffffffc000000d. </font><font style="vertical-align: inherit;">Sustituya todos estos valores y obtenga:</font></font><br>
<br>
<pre><code class="plaintext hljs">val = (u32)(0xffffffff810b3df9 - 0x4 - 0xffffffffc000000d) = 0xc10b3de8
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos el volcado de la función foo, que obtuvimos al principio:</font></font><br>
<br>
<pre><code class="plaintext hljs">53 89 fe 89 fb 48 c7 c7 24 10 00 c0 e8 e8 3d 0b c1 8d 43 02 5b c3 66 2e 0f
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el desplazamiento 0xD, se encuentra el valor 0xc10b3de8, que es idéntico al que calculamos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Así es como el núcleo procesa las reubicaciones y obtiene el desplazamiento necesario para el comando de cierre de llamada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al preparar el artículo, se utilizó la versión 5.4.27 del kernel de Linux.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es504414/index.html">Cómo Microsoft mató a AppGet</a></li>
<li><a href="../es504420/index.html">Escribir una arena PvP por turnos con movimientos simultáneos</a></li>
<li><a href="../es504430/index.html">Everyday Life Tinkoff Security Operations Center: análisis de cargador de arranque único</a></li>
<li><a href="../es504434/index.html">Programa educativo para padres: cómo proteger a los niños del peligro en Internet</a></li>
<li><a href="../es504438/index.html">30 mitaps por semana. Abrimos la temporada de verano 2020</a></li>
<li><a href="../es504444/index.html">Usando docker multi-etapa para construir imágenes de Windows</a></li>
<li><a href="../es504448/index.html">Gamers Generation II</a></li>
<li><a href="../es504450/index.html">JavaScript moderno: una vista lateral</a></li>
<li><a href="../es504452/index.html">Ontology lanza la capa 2, contribuyendo a una plataforma de cadena pública más integrada</a></li>
<li><a href="../es504454/index.html">Los mejores repositorios de GitHub para desarrolladores web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>