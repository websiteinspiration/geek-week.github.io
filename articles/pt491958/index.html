<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÄ üë®üèΩ‚Äçüíº üé£ Guia de compress√£o de anima√ß√£o de esqueleto üë©üèæ‚Äçü§ù‚Äçüë©üèª ‚úñÔ∏è ü§±üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo ser√° uma breve vis√£o geral de como implementar um esquema simples de compacta√ß√£o de anima√ß√£o e alguns conceitos relacionados. N√£o sou de f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Guia de compress√£o de anima√ß√£o de esqueleto</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491958/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/o1/6v/gp/o16vgpz4u-9_ntko92qweoxqzx0.png" height="50%" width="50%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este artigo ser√° uma breve vis√£o geral de como implementar um esquema simples de compacta√ß√£o de anima√ß√£o e alguns conceitos relacionados. </font><font style="vertical-align: inherit;">N√£o sou de forma alguma um especialista neste assunto, mas h√° muito pouca informa√ß√£o sobre esse assunto, e ela √© bastante fragmentada. </font><font style="vertical-align: inherit;">Se voc√™ quiser ler artigos mais detalhados sobre esse t√≥pico, recomendo que voc√™ acesse os seguintes links:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://nfrechette.github.io/2016/10/21/anim_compression_toc/</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://technology.riotgames.com/news/compressing-skeletal-animation-data</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://bitsquid.blogspot.com/2009/11/bitsquid-low-level-animation-system.html</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://bitsquid.blogspot.com/2011/10/low-level-animation-part-2.html</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de come√ßar, vale a pena dar uma breve introdu√ß√£o √† anima√ß√£o esquel√©tica e a alguns de seus conceitos b√°sicos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No√ß√µes b√°sicas de anima√ß√£o e compacta√ß√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anima√ß√£o esquel√©tica √© um t√≥pico bastante simples, se voc√™ se esquecer de esfolar. Temos o conceito de um esqueleto contendo transforma√ß√µes dos ossos de um personagem. Essas transforma√ß√µes √≥sseas s√£o armazenadas em um formato hier√°rquico; de fato, eles s√£o armazenados como um delta entre sua posi√ß√£o global e a posi√ß√£o dos pais. A terminologia aqui √© confusa, porque no mecanismo de jogo local √© freq√ºentemente chamado de espa√ßo de modelo / personagem e global √© o espa√ßo do mundo. Na terminologia da anima√ß√£o, local √© chamado de espa√ßo do pai do osso e global √© o espa√ßo do personagem ou o espa√ßo do mundo, dependendo se h√° movimento do osso da raiz; mas n√£o vamos nos preocupar com isso. O importante √© que as transforma√ß√µes √≥sseas sejam armazenadas localmente em rela√ß√£o aos pais. Isso tem muitas vantagens, especialmente quando se mistura (mistura):se a mistura das duas posi√ß√µes fosse global, elas seriam interpoladas linearmente na posi√ß√£o, o que levaria a um aumento e diminui√ß√£o dos ossos e √† deforma√ß√£o do personagem.</font></font><a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E se voc√™ usar deltas, a mistura ser√° realizada de uma diferen√ßa para outra; portanto, se a transforma√ß√£o delta de um osso entre duas poses for a mesma, o comprimento do osso permanecer√° constante. Eu acho que √© mais f√°cil (mas n√£o totalmente preciso) agir dessa maneira: o uso de deltas leva a um movimento "esf√©rico" das posi√ß√µes √≥sseas durante a mistura, e a mistura de transforma√ß√µes globais leva a um movimento linear das posi√ß√µes √≥sseas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A anima√ß√£o esquel√©tica √© apenas uma lista ordenada de quadros-chave com uma taxa de quadros (geralmente) constante. O quadro principal √© a pose do esqueleto. Se queremos fazer uma pose entre os quadros-chave, amostramos os dois quadros-chave e misturamos entre eles, usando a fra√ß√£o do tempo entre eles como o peso do mix. A imagem abaixo mostra uma anima√ß√£o criada a 30fps. A anima√ß√£o tem um total de 5 quadros e precisamos fazer a pose 0,52 s ap√≥s o in√≠cio. Portanto, precisamos amostrar a pose no quadro 1 e a pose no quadro 2 e, em seguida, misturar entre elas com um peso de mistura de aproximadamente 57%.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/733/f11/c43/733f11c43022b935901e6f20f8a70fab.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um exemplo de uma anima√ß√£o de 5 quadros e uma solicita√ß√£o de pose em um tempo intermedi√°rio.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Tendo as informa√ß√µes acima e acreditando que a mem√≥ria n√£o √© um problema para n√≥s, o salvamento seq√ºencial da pose seria a maneira ideal de armazenar a anima√ß√£o, como mostrado abaixo:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d28/7c5/f3c/d287c5f3cbfd9a8144d20432c3a258dc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Armazenamento simples de dados de anima√ß√£o</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que isso √© perfeito? A amostragem de qualquer quadro-chave se resume a uma opera√ß√£o simples de memcpy. A amostragem de uma pose intermedi√°ria requer duas opera√ß√µes com erro e uma opera√ß√£o de mistura. Do ponto de vista do cache, copiamos usando dois blocos de dados memcpy em ordem, ou seja, ap√≥s copiar o primeiro quadro, um dos caches j√° ter√° um segundo quadro. Voc√™ pode dizer: espere, quando fazemos a mistura, precisamos misturar todos os ossos; E se a maioria deles n√£o mudar entre os quadros? N√£o seria melhor armazenar ossos como registros e misturar apenas transforma√ß√µes alteradas? Bem, se isso for implementado, poder√° ocorrer um pouco mais de falha de cache ao ler registros individuais, e voc√™ precisar√° acompanhar quais convers√µes precisa misturar, e assim por diante ... A mixagem pode parecer um monte de trabalho,mas, em ess√™ncia, √© a aplica√ß√£o de uma instru√ß√£o a dois blocos de mem√≥ria que j√° est√£o no cache. Al√©m disso, o c√≥digo de mixagem √© relativamente simples, geralmente apenas um conjunto de instru√ß√µes SIMD sem ramifica√ß√£o, e um processador moderno as processa em quest√£o de momentos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O problema dessa abordagem √© que √© necess√°ria uma quantidade extremamente grande de mem√≥ria, especialmente em jogos em que as seguintes condi√ß√µes s√£o verdadeiras para 95% dos dados.</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os ossos t√™m um comprimento constante</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os personagens na maioria dos jogos n√£o esticam os ossos, portanto, dentro da mesma anima√ß√£o, os registros de transforma√ß√µes s√£o constantes.</font></font></li>
</ul></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geralmente n√£o escalamos os ossos.</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escala raramente √© usada em anima√ß√µes de jogos. </font><font style="vertical-align: inherit;">√â usado ativamente em filmes e efeitos visuais, mas muito pouco em jogos. </font><font style="vertical-align: inherit;">Mesmo quando usado, a mesma escala √© geralmente usada.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De fato, na maioria das anima√ß√µes que criei em tempo de execu√ß√£o, aproveitei esse fato e mantive toda a transforma√ß√£o √≥ssea em 8 vari√°veis ‚Äã‚Äãde flutua√ß√£o: 4 para girar o quaternion, 3 para mover e 1 para escalar. </font><font style="vertical-align: inherit;">Isso reduz significativamente o tamanho da pose no tempo de execu√ß√£o, proporcionando maior produtividade ao misturar e copiar.</font></font></li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com tudo isso em mente, se voc√™ observar o formato de dados original, poder√° ver como √© ineficiente gastar mem√≥ria. </font><font style="vertical-align: inherit;">Duplicamos os valores de deslocamento e escala de cada osso, mesmo que eles n√£o mudem. </font><font style="vertical-align: inherit;">E a situa√ß√£o est√° ficando rapidamente fora de controle. </font><font style="vertical-align: inherit;">Geralmente, os animadores criam anima√ß√µes com uma frequ√™ncia de 30 fps e, nos jogos no n√≠vel AAA, um personagem geralmente tem cerca de 100 ossos. </font><font style="vertical-align: inherit;">Com base nessa quantidade de informa√ß√µes e no formato de 8 flutuantes, precisamos de cerca de 3 KB por pose e 94 KB por segundo de anima√ß√£o como resultado. </font><font style="vertical-align: inherit;">Os valores se acumulam rapidamente e, em algumas plataformas, podem obstruir facilmente toda a mem√≥ria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, vamos falar sobre compress√£o; </font><font style="vertical-align: inherit;">Ao tentar compactar dados, h√° v√°rios aspectos a serem considerados:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taxa de compress√£o</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quanto conseguimos reduzir a quantidade de mem√≥ria ocupada</font></font></li>
</ul></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualidade</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quanta informa√ß√£o perdemos dos dados de origem</font></font></li>
</ul></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taxa de compress√£o</font></font></strong><ul>
<li>     </li>
</ul></li>
<li><strong> </strong><ul>
<li>           .</li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estou preocupado principalmente com qualidade e velocidade e menos com mem√≥ria. Al√©m disso, trabalho com anima√ß√µes de jogos e posso aproveitar o fato de que, de fato, para reduzir a carga na mem√≥ria, n√£o precisamos usar deslocamento e escala nos dados. Devido a isso, podemos evitar uma diminui√ß√£o na qualidade causada por uma diminui√ß√£o no n√∫mero de quadros e outras solu√ß√µes com perdas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tamb√©m √© extremamente importante observar que voc√™ n√£o deve subestimar o efeito da compacta√ß√£o de anima√ß√£o no desempenho: em um dos meus projetos anteriores, a taxa de amostragem diminuiu cerca de 35% e tamb√©m houve alguns problemas de qualidade. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando come√ßamos a trabalhar com a compacta√ß√£o de dados de anima√ß√£o, h√° duas √°reas importantes a serem consideradas:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com que rapidez podemos compactar elementos individuais de informa√ß√£o em um quadro-chave (quaternions, float etc.).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como podemos compactar a sequ√™ncia de quadros-chave para remover informa√ß√µes redundantes.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discretiza√ß√£o de dados</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quase toda esta se√ß√£o pode ser reduzida a um princ√≠pio: discretizar dados. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A discretiza√ß√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© uma maneira dif√≠cil de dizer que queremos converter um valor de um intervalo cont√≠nuo em um conjunto discreto de valores.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flutua√ß√£o de Discretiza√ß√£o</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando se trata de amostrar valores flutuantes, nos esfor√ßamos para pegar esse valor flutuante e represent√°-lo como um n√∫mero inteiro usando menos bits. O truque √© que um n√∫mero inteiro n√£o pode realmente representar um n√∫mero de origem, mas um valor em um intervalo discreto mapeado para um intervalo cont√≠nuo. Geralmente, √© usada uma abordagem muito simples. Para provar um valor, primeiro precisamos de um intervalo para o valor original; Ap√≥s receber esse intervalo, normalizamos o valor inicial para esse intervalo. Ent√£o esse valor normalizado √© multiplicado pelo valor m√°ximo poss√≠vel para o tamanho de sa√≠da especificado desejado em bits. Ou seja, para 16 bits multiplicamos o valor por 65535. Em seguida, o valor resultante √© arredondado para o n√∫mero inteiro mais pr√≥ximo e armazenado. Isso √© mostrado claramente na imagem:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e73/827/f7be73827067126fd51c0bf6f2396b10.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um exemplo de amostragem de um flutuador de 32 bits para um n√∫mero inteiro de 16 bits n√£o assinado.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Para obter o valor original novamente, simplesmente executamos as opera√ß√µes na ordem inversa. √â importante observar aqui que precisamos registrar em algum lugar o intervalo inicial do valor; caso contr√°rio, n√£o poderemos decodificar o valor amostrado. O n√∫mero de bits no valor amostrado determina o tamanho da etapa no intervalo normalizado e, portanto, o tamanho da etapa no intervalo original: o valor decodificado ser√° um m√∫ltiplo desse tamanho da etapa, o que nos permite calcular facilmente o erro m√°ximo que ocorre devido ao processo de amostragem, para que possamos determinar o n√∫mero de bits. necess√°rio para a nossa aplica√ß√£o.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o darei exemplos do c√≥digo fonte, porque existe uma biblioteca bastante conveniente e simples para executar opera√ß√µes b√°sicas de amostragem, o que √© uma boa fonte sobre este t√≥pico: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/r-lyeh-archived/quant</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (eu diria que voc√™ n√£o deve usar sua fun√ß√£o de discretiza√ß√£o de quaternion, mas mais sobre isso posteriormente).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compress√£o Quaternion</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A compress√£o do quaternion √© um t√≥pico bem estudado, por isso n√£o repetirei o que as outras pessoas explicaram melhor. </font><font style="vertical-align: inherit;">Aqui est√° um link para uma postagem de compacta√ß√£o de captura instant√¢nea que fornece a melhor descri√ß√£o sobre este t√≥pico: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://gafferongames.com/post/snapshot_compression/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, tenho algo a dizer sobre o assunto. </font><font style="vertical-align: inherit;">As mensagens de bitsquid, que falam sobre a compress√£o do quaternion, sugerem compactar o quaternion para 32 bits usando aproximadamente 10 bits de dados para cada componente do quaternion. </font><font style="vertical-align: inherit;">√â exatamente isso que a Quant faz, porque √© baseada em mensagens de bitsquid. </font><font style="vertical-align: inherit;">Na minha opini√£o, essa compress√£o √© muito grande e, nos meus testes, causou forte agita√ß√£o. </font><font style="vertical-align: inherit;">Talvez os autores tenham usado hierarquias menos profundas do personagem, mas se voc√™ multiplicar mais de 15 quaternions dos meus exemplos de anima√ß√£o, o erro combinado ser√° bastante s√©rio. </font><font style="vertical-align: inherit;">Na minha opini√£o, o </font><font style="vertical-align: inherit;">m√≠nimo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">absoluto</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de precis√£o √© de 48 bits por quaternion.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redu√ß√£o de tamanho devido √† amostragem</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de come√ßarmos a considerar os diferentes m√©todos de compacta√ß√£o e a organiza√ß√£o dos registros, vamos ver que tipo de compacta√ß√£o obteremos se simplesmente aplicarmos a discretiza√ß√£o no circuito original. Usaremos o mesmo exemplo de antes (um esqueleto de 100 ossos); portanto, se usarmos 48 bits (3 x 16 bits) por quaternion, 48 bits (3 √ó 16) para mover e 16 bits para escalar, ent√£o no total para convers√£o precisamos de 14 bytes em vez de 32 bytes. Isso representa 43,75% do tamanho original. Ou seja, por 1 segundo de anima√ß√£o com uma frequ√™ncia de 30FPS, reduzimos o volume de cerca de 94 KB para cerca de 41 KB.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso n√£o √© nada ruim, a discretiza√ß√£o √© uma opera√ß√£o de custo relativamente baixo, portanto isso n√£o afetar√° muito o tempo de descompacta√ß√£o. </font><font style="vertical-align: inherit;">Encontramos um bom ponto de partida para o in√≠cio e, em alguns casos, isso ser√° suficiente para implementar anima√ß√µes dentro do or√ßamento de recursos e garantir excelente qualidade e desempenho.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compress√£o de registro</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo se torna muito complicado aqui, especialmente quando os desenvolvedores come√ßam a tentar t√©cnicas como reduzir o quadro-chave, o ajuste de curvas, etc. </font><font style="vertical-align: inherit;">Tamb√©m nesta fase, estamos realmente come√ßando a reduzir a qualidade das anima√ß√µes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em quase todas essas decis√µes, sup√µe-se que as caracter√≠sticas de cada osso (rota√ß√£o, deslocamento e escala) sejam armazenadas como um registro separado. </font><font style="vertical-align: inherit;">Portanto, podemos inverter o circuito, como mostrei anteriormente:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f64/752/16a/f6475216adb6ac795e1737de30aef6af.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salvando dados de ossos como registros</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Aqui, simplesmente salvamos todos os registros seq√ºencialmente, mas tamb√©m podemos agrupar todos os registros de rota√ß√µes, deslocamentos e escalas. A id√©ia b√°sica √© que passamos do armazenamento de dados de cada pose para o armazenamento de registros.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Feito isso, podemos usar outras maneiras de reduzir ainda mais a mem√≥ria ocupada. O primeiro √© come√ßar a soltar quadros. Nota: isso n√£o requer um formato de registro e esse m√©todo pode ser aplicado no esquema anterior. Esse m√©todo funciona, mas leva √† perda de pequenos movimentos na anima√ß√£o, porque descartamos a maioria dos dados. Essa t√©cnica foi usada ativamente no PS3, e √†s vezes tivemos que descer para frequ√™ncias de amostragem incrivelmente baixas, por exemplo, at√© 7 quadros por segundo (geralmente para anima√ß√µes n√£o muito importantes). Tenho lembran√ßas ruins disso, como programador de anima√ß√£o vejo claramente os detalhes perdidos e a expressividade, mas se voc√™ olhar do ponto de vista do programador de sistemas, podemos dizer que a anima√ß√£o √© "quase" a mesma, porque em geral o movimento √© preservado, mas ao mesmo tempo economize muita mem√≥ria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos omitir essa abordagem (na minha opini√£o, √© muito destrutiva) e considerar outras op√ß√µes poss√≠veis. Outra abordagem popular √© criar uma curva para cada registro e realizar a redu√ß√£o dos quadros-chave na curva, ou seja, removendo quadros-chave duplicados. Do ponto de vista das anima√ß√µes de jogos, com essa abordagem, as grava√ß√µes de movimento e escala s√£o perfeitamente compactadas, √†s vezes sendo reduzidas a um quadro-chave. Essa solu√ß√£o √© n√£o destrutiva, mas requer descompacta√ß√£o, porque toda vez que precisamos obter a transforma√ß√£o, precisamos calcular a curva, porque n√£o podemos mais apenas acessar os dados na mem√≥ria. A situa√ß√£o pode ser melhorada um pouco se voc√™ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calcular anima√ß√µes em apenas uma dire√ß√£o.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e armazene o estado do amostrador de cada anima√ß√£o para cada osso (ou seja, de onde obter o c√°lculo da curva), mas voc√™ deve pagar por isso com um aumento na mem√≥ria e um aumento significativo na complexidade do c√≥digo. Nos sistemas modernos de anima√ß√£o, geralmente n√£o reproduzimos anima√ß√µes do come√ßo ao fim. Freq√ºentemente, em determinados per√≠odos de tempo, eles fazem transi√ß√µes para novas anima√ß√µes, gra√ßas a coisas como mistura sincronizada ou correspond√™ncia de fases. Frequentemente, mostramos poses individuais, mas n√£o consecutivas, para implementar coisas como misturar mira / olhar para um objeto, e muitas vezes as anima√ß√µes s√£o reproduzidas na ordem inversa. Portanto, eu n√£o recomendo usar essa solu√ß√£o, simplesmente n√£o vale o aborrecimento causado pela complexidade e poss√≠veis erros.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° tamb√©m o conceito de n√£o apenas excluir chaves id√™nticas nas curvas, mas tamb√©m especificar um limite no qual chaves semelhantes s√£o exclu√≠das; isso leva ao fato de que a anima√ß√£o fica mais desbotada, semelhante ao m√©todo de descartar quadros, porque o resultado final √© o mesmo em termos de dados. Os esquemas de compacta√ß√£o de anima√ß√£o s√£o freq√ºentemente usados, nos quais os par√¢metros de compacta√ß√£o s√£o definidos para cada registro, e os animadores s√£o constantemente atormentados com esses valores, tentando manter a qualidade e reduzir o tamanho ao mesmo tempo. Esse √© um fluxo de trabalho doloroso e estressante, mas √© necess√°rio se voc√™ trabalhar com a mem√≥ria limitada das gera√ß√µes mais antigas de consoles. Felizmente, hoje temos um grande or√ßamento de mem√≥ria e n√£o precisamos de coisas t√£o terr√≠veis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos esses aspectos s√£o divulgados nos posts da Riot / BitSquid e Nicholas (consulte os links no in√≠cio do meu artigo). N√£o vou falar sobre eles em detalhes. Em vez disso, falarei sobre o que decidi sobre compactar os registros ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eu ... decidi n√£o compactar os registros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de come√ßar a acenar, deixe-me explicar ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando salvo os dados nos registros, armazeno os dados de rota√ß√£o para todos os quadros. Quando se trata de movimento e escala, eu acompanho se o movimento e a escala s√£o est√°ticos durante a compacta√ß√£o e, nesse caso, salvo apenas um valor por registro. Ou seja, se o registro se mover ao longo de X, mas n√£o ao longo de Y e Z, salvarei todos os valores de mover o registro ao longo de X, mas apenas um valor de mover o registro ao longo de Y e Z.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa situa√ß√£o surge para a maioria dos ossos em cerca de 95% de nossas anima√ß√µes, portanto, no final, podemos reduzir significativamente a mem√≥ria ocupada, absolutamente sem perder a qualidade. Isso requer trabalho do ponto de vista da cria√ß√£o de conte√∫do (DCC): n√£o queremos que os ossos tenham leves movimentos e zooms no fluxo de trabalho de cria√ß√£o de anima√ß√£o, mas esse benef√≠cio vale o custo extra.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No nosso exemplo de anima√ß√£o, existem apenas dois registros com movimenta√ß√£o e n√£o h√° registros com escala. Em 1 segundo de anima√ß√£o, o volume de dados diminui de 41 KB para 18,6 KB (ou seja, at√© 20% do volume dos dados originais). A situa√ß√£o se torna ainda melhor com o aumento da dura√ß√£o da anima√ß√£o, gastamos recursos apenas em turnos de grava√ß√£o e movimentos din√¢micos, e o custo das grava√ß√µes est√°ticas permanece constante, o que economiza mais em anima√ß√µes longas. E n√£o precisamos experimentar perda de qualidade causada por amostragem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com todas essas informa√ß√µes em mente, meu esquema final de dados fica assim:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f5/347/eb0/9f5347eb09718967ebacbe89d443e992.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um exemplo de esquema de dados de anima√ß√£o compactada (3 quadros por registro)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Al√©m disso, salvei o deslocamento no bloco de dados para iniciar os dados de cada osso. </font><font style="vertical-align: inherit;">Isso √© necess√°rio porque, √†s vezes, precisamos coletar dados de apenas um osso sem ler a pose inteira. </font><font style="vertical-align: inherit;">Isso nos fornece uma maneira r√°pida de acessar diretamente os dados do registro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m dos dados de anima√ß√£o armazenados em um bloco de mem√≥ria, tamb√©m tenho op√ß√µes de compacta√ß√£o para cada registro:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d7/b3d/7a3/4d7b3d7a3f1362c0429d72591268dbce.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplo de par√¢metros de compacta√ß√£o para registros do meu mecanismo Kruger</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Esses par√¢metros armazenam todos os dados necess√°rios para decodificar os valores amostrados de cada registro. </font><font style="vertical-align: inherit;">Eles tamb√©m monitoram a est√°tica dos registros para que eu saiba como lidar com dados compactados quando me deparei com um registro est√°tico durante a amostragem.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ tamb√©m pode observar que a discretiza√ß√£o de cada registro √© individual: durante a compacta√ß√£o, acompanho os valores m√≠nimo e m√°ximo de cada caracter√≠stica (por exemplo, movendo-se ao longo do X) de cada registro para garantir que os dados sejam discretizados dentro do intervalo m√≠nimo / m√°ximo e mantenho a precis√£o m√°xima. </font><font style="vertical-align: inherit;">N√£o creio que seja geralmente poss√≠vel criar intervalos de amostragem globais sem destruir seus dados (quando os valores est√£o fora do intervalo) e sem cometer erros significativos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seja como for, aqui est√° um breve resumo das minhas tentativas est√∫pidas de implementar a compacta√ß√£o de anima√ß√£o: no final, quase uso a compacta√ß√£o.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt491942/index.html">Como usamos o item2vec para recomendar produtos semelhantes</a></li>
<li><a href="../pt491944/index.html">Como combinar duas plataformas em uma e n√£o ofender os usu√°rios. Experi√™ncia dos desenvolvedores do Yandex.Kew</a></li>
<li><a href="../pt491946/index.html">Leis de programa√ß√£o</a></li>
<li><a href="../pt491948/index.html">Os tokens de design podem fazer mais: criar uma √∫nica fonte de informa√ß√µes sobre os componentes da interface do usu√°rio</a></li>
<li><a href="../pt491956/index.html">Lan√ßamento do Rust 1.42.0: modelos de fatia e mensagens de p√¢nico mais convenientes</a></li>
<li><a href="../pt491960/index.html">Era quando √© dif√≠cil se perder</a></li>
<li><a href="../pt491962/index.html">Assassino de VPN. Acesso remoto adequado a servidores de batalha</a></li>
<li><a href="../pt491964/index.html">Execu√ß√£o remota de c√≥digo no SMB v3: CVE-2020-0796</a></li>
<li><a href="../pt491974/index.html">Coronav√≠rus: por que voc√™ precisa agir agora</a></li>
<li><a href="../pt491976/index.html">Transformamos a economia da UNIT em uma loja ou produ√ß√£o on-line</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>