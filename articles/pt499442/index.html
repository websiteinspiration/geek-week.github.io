<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍🏿 🏖️ 🤽🏼 Criando um jogo de corrida pseudo-3D: implementando as colinas e finalizando o jogo 🤟 👽 🙍🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parte 3. Colinas
 
 Na parte anterior, criamos um jogo de corrida pseudo-tridimensional simples, realizando estradas retas e curvas nele. 
 
 Desta ve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Criando um jogo de corrida pseudo-3D: implementando as colinas e finalizando o jogo</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499442/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 3. Colinas</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/892/231/4e8/8922314e8acebdd3ae14fba511d17294.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na parte anterior, criamos um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jogo de corrida</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pseudo-tridimensional </font><font style="vertical-align: inherit;">simples, realizando estradas retas e curvas nele. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desta vez, cuidaremos das colinas; </font><font style="vertical-align: inherit;">felizmente, será muito mais fácil do que criar estradas curvas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na primeira parte, usamos a lei de triângulos semelhantes para criar uma projeção em perspectiva tridimensional:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/949/0ab/47b/9490ab47bb570b61218e46e5913c18bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... o que nos levou a obter as equações para projetar as coordenadas do mundo 3d nas coordenadas da tela 2d.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/246/e18/edb246e187e7fe0eb027b53c58790c34.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... mas desde então trabalhamos apenas com estradas retas, as coordenadas do mundo precisavam apenas do componente </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , porque ambos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eram iguais a zero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso nos convém bem, porque para adicionar colinas, basta fornecer aos segmentos de estrada a coordenada diferente de zero </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , após o qual a função existente funcionará </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">magicamente.</font></font><a name="habracut"></a><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ede/dc6/295/ededc629516e6f0d2c7f1ca6b111e17d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sim, é o suficiente para subir as colinas. </font><font style="vertical-align: inherit;">Basta adicionar o componente </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> às coordenadas mundiais de cada segmento de estrada </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alterações na geometria da estrada</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Modificaremos o método existente </font></font><code>addSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que a função que o chama possa passar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2.world.y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1.world.y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> corresponda a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2.world.y do</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> segmento anterior:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params">curve, y</span>) </span>{
  <span class="hljs-keyword">var</span> n = segments.length;<font></font>
  segments.push({<font></font>
     <span class="hljs-attr">index</span>: n,
        <span class="hljs-attr">p1</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">y</span>: lastY(), <span class="hljs-attr">z</span>:  n   *segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
        <span class="hljs-attr">p2</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">y</span>: y,       <span class="hljs-attr">z</span>: (n+<span class="hljs-number">1</span>)*segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
     <span class="hljs-attr">curve</span>: curve,
     <span class="hljs-attr">color</span>: <span class="hljs-built_in">Math</span>.floor(n/rumbleLength)%<span class="hljs-number">2</span> ? COLORS.DARK : COLORS.LIGHT<font></font>
  });<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lastY</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (segments.length == <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : segments[segments.length<span class="hljs-number">-1</span>].p2.world.y;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adicione constantes para indicar </font><font style="vertical-align: inherit;">colinas </font><font style="vertical-align: inherit;">baixas ( </font></font><code>LOW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), médias ( </font></font><code>MEDIUM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) e altas ( </font></font><code>HIGH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> ROAD = {
  <span class="hljs-attr">LENGTH</span>: { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">SHORT</span>:  <span class="hljs-number">25</span>, <span class="hljs-attr">MEDIUM</span>:  <span class="hljs-number">50</span>, <span class="hljs-attr">LONG</span>:  <span class="hljs-number">100</span> },
  <span class="hljs-attr">HILL</span>:   { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">LOW</span>:    <span class="hljs-number">20</span>, <span class="hljs-attr">MEDIUM</span>:  <span class="hljs-number">40</span>, <span class="hljs-attr">HIGH</span>:   <span class="hljs-number">60</span> },
  <span class="hljs-attr">CURVE</span>:  { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">EASY</span>:    <span class="hljs-number">2</span>, <span class="hljs-attr">MEDIUM</span>:   <span class="hljs-number">4</span>, <span class="hljs-attr">HARD</span>:    <span class="hljs-number">6</span> }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Altere o método existente </font></font><code>addRoad()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que ele receba o argumento </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que será usado junto com as funções de suavidade para a subida e descida gradual da colina:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addRoad</span>(<span class="hljs-params">enter, hold, leave, curve, y</span>) </span>{
  <span class="hljs-keyword">var</span> startY   = lastY();
  <span class="hljs-keyword">var</span> endY     = startY + (Util.toInt(y, <span class="hljs-number">0</span>) * segmentLength);
  <span class="hljs-keyword">var</span> n, total = enter + hold + leave;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; enter ; n++)<font></font>
    addSegment(Util.easeIn(<span class="hljs-number">0</span>, curve, n/enter), Util.easeInOut(startY, endY, n/total));
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; hold  ; n++)<font></font>
    addSegment(curve, Util.easeInOut(startY, endY, (enter+n)/total));<font></font>
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; leave ; n++)<font></font>
    addSegment(Util.easeInOut(curve, <span class="hljs-number">0</span>, n/leave), Util.easeInOut(startY, endY, (enter+hold+n)/total));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, semelhante ao que fizemos na parte 2 s </font></font><code>addSCurves()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, podemos impor quaisquer métodos necessários para construir a geometria, por exemplo:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addLowRollingHills</span>(<span class="hljs-params">num, height</span>) </span>{<font></font>
  num    = num    || ROAD.LENGTH.SHORT;<font></font>
  height = height || ROAD.HILL.LOW;<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  height/<span class="hljs-number">2</span>);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>, -height);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  height);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  height/<span class="hljs-number">2</span>);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>);<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alterações no método de atualização</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No jogo de arcade que estamos criando, não tentaremos simular a realidade, de modo que as colinas não afetam o jogador ou o mundo do jogo de forma alguma, o que significa que </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mudanças não são necessárias </font><font style="vertical-align: inherit;">no método </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderização em colina</font></font></h2><br><font style="vertical-align: inherit;"></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Também não são necessárias alterações </font><font style="vertical-align: inherit;">
no método </font><font style="vertical-align: inherit;">, porque as equações de projeção foram originalmente escritas para projetar corretamente os segmentos da estrada com coordenadas </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diferentes de zero </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fundo de rolagem de paralaxe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além de adicionar coordenadas </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a todos os segmentos da estrada </font><font style="vertical-align: inherit;">, a única alteração será a implementação do deslocamento vertical das camadas de fundo junto com as colinas (assim como elas se movem horizontalmente junto com as curvas). </font><font style="vertical-align: inherit;">Implementamos isso com outro argumento para a função auxiliar </font></font><code>Render.background</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O mecanismo mais simples será o deslocamento de fundo usual em relação à posição </font></font><code>playerY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(que deve ser interpolada das posições mundiais </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y do</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> segmento de jogador atual). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse não é o comportamento mais realista, porque provavelmente vale a pena considerar a inclinação do segmento atual da estrada do jogador, mas esse efeito é simples e funciona muito bem para uma demonstração simples.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusão</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é tudo, agora podemos complementar as curvas falsas com colinas reais:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/892/231/4e8/8922314e8acebdd3ae14fba511d17294.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O trabalho realizado por nós na primeira parte, incluindo a infraestrutura para adicionar colinas 3D reais projetadas, eu apenas não falei sobre isso antes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na última parte do artigo, adicionaremos sprites, além de árvores e outdoors nas bordas da estrada. </font><font style="vertical-align: inherit;">Também adicionaremos outros carros contra os quais será possível competir, reconhecimento de colisões e fixação do "registro circular" do jogador.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 4. Versão Pronta</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/103/563/0d1/1035630d19106de2f85edebb24d0421f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesta parte, adicionaremos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outdoors e árvores</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outros carros</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reconhecimento de colisão</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IA rudimentar de carros</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interface com contador de voltas e registro de voltas</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... e isso nos proporcionará um nível suficiente de interatividade para finalmente chamar nosso projeto de "jogo".</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota sobre a estrutura do código</font></font></h2><br>
<blockquote><em>     ,            /,         Javascript.</em></blockquote><br>
<blockquote><em>                .     () ,             ...</em></blockquote><br>
<blockquote><em>…      ,       ,           ,  ,         .</em></blockquote><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6f/111/acc/f6f111accbba448459e25c6fe761ff05.png"></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na parte 1, antes do início do ciclo do jogo, fizemos o upload de uma folha de sprite contendo todos os carros, árvores e outdoors. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode criar manualmente uma folha de sprite em qualquer editor de imagens, mas é melhor confiar o armazenamento de imagens e o cálculo de coordenadas a uma ferramenta automatizada. </font><font style="vertical-align: inherit;">No meu caso, a folha de sprite foi gerada por uma pequena tarefa Rake usando a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fábrica de sprites Ruby Gem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta tarefa gera planilhas combinadas a partir de arquivos de imagem separados e também calcula as coordenadas x, y, w, h, que serão armazenadas em uma constante </font></font><code>SPRITES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> SPRITES = {
  <span class="hljs-attr">PALM_TREE</span>:   { <span class="hljs-attr">x</span>:    <span class="hljs-number">5</span>, <span class="hljs-attr">y</span>:    <span class="hljs-number">5</span>, <span class="hljs-attr">w</span>:  <span class="hljs-number">215</span>, <span class="hljs-attr">h</span>:  <span class="hljs-number">540</span> },
  <span class="hljs-attr">BILLBOARD08</span>: { <span class="hljs-attr">x</span>:  <span class="hljs-number">230</span>, <span class="hljs-attr">y</span>:    <span class="hljs-number">5</span>, <span class="hljs-attr">w</span>:  <span class="hljs-number">385</span>, <span class="hljs-attr">h</span>:  <span class="hljs-number">265</span> },<font></font>
<font></font>
  <span class="hljs-comment">// ... etc</span><font></font>
<font></font>
  <span class="hljs-attr">CAR04</span>:       { <span class="hljs-attr">x</span>: <span class="hljs-number">1383</span>, <span class="hljs-attr">y</span>:  <span class="hljs-number">894</span>, <span class="hljs-attr">w</span>:   <span class="hljs-number">80</span>, <span class="hljs-attr">h</span>:   <span class="hljs-number">57</span> },
  <span class="hljs-attr">CAR01</span>:       { <span class="hljs-attr">x</span>: <span class="hljs-number">1205</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1018</span>, <span class="hljs-attr">w</span>:   <span class="hljs-number">80</span>, <span class="hljs-attr">h</span>:   <span class="hljs-number">56</span> },<font></font>
};</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicionando outdoors e árvores</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adicione a cada segmento da estrada uma matriz que conterá sprites de objetos ao longo das margens da estrada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada sprite consiste no que </font></font><code>source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foi retirado da coleção </font></font><code>SPRITES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, juntamente com um deslocamento horizontal </font></font><code>offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que é normalizado para que -1 indique a borda esquerda da estrada e +1 significa a borda direita, o que nos permite não depender do valor </font></font><code>roadWidth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alguns sprites são colocados intencionalmente, outros são randomizados.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params"></span>) </span>{<font></font>
  segments.push({<font></font>
    ...<font></font>
    sprites: [],<font></font>
    ...<font></font>
  });<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSprite</span>(<span class="hljs-params">n, sprite, offset</span>) </span>{<font></font>
  segments[n].sprites.push({ <span class="hljs-attr">source</span>: sprite, <span class="hljs-attr">offset</span>: offset });<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetSprites</span>(<span class="hljs-params"></span>) </span>{<font></font>
<font></font>
  addSprite(<span class="hljs-number">20</span>,  SPRITES.BILLBOARD07, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">40</span>,  SPRITES.BILLBOARD06, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">60</span>,  SPRITES.BILLBOARD08, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">80</span>,  SPRITES.BILLBOARD09, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">100</span>, SPRITES.BILLBOARD01, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">120</span>, SPRITES.BILLBOARD02, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">140</span>, SPRITES.BILLBOARD03, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">160</span>, SPRITES.BILLBOARD04, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">180</span>, SPRITES.BILLBOARD05, <span class="hljs-number">-1</span>);<font></font>
<font></font>
  addSprite(<span class="hljs-number">240</span>, SPRITES.BILLBOARD07, <span class="hljs-number">-1.2</span>);<font></font>
  addSprite(<span class="hljs-number">240</span>, SPRITES.BILLBOARD06,  <span class="hljs-number">1.2</span>);<font></font>
<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">250</span> ; n &lt; <span class="hljs-number">1000</span> ; n += <span class="hljs-number">5</span>) {<font></font>
    addSprite(n, SPRITES.COLUMN, <span class="hljs-number">1.1</span>);<font></font>
    addSprite(n + Util.randomInt(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>), SPRITES.TREE1, <span class="hljs-number">-1</span> - (<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>));<font></font>
    addSprite(n + Util.randomInt(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>), SPRITES.TREE2, <span class="hljs-number">-1</span> - (<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>));<font></font>
  }<font></font>
<font></font>
  ...<font></font>
}</code></pre><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: se estivéssemos criando um jogo real, poderíamos escrever um editor de estradas para criar visualmente um mapa com colinas e curvas, além de adicionar um mecanismo para organizar sprites ao longo da estrada ... mas para nossas tarefas, podemos fazê-lo programaticamente </font></font><code>addSprite()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicionando máquinas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além de sprites de objetos nas margens da estrada, adicionaremos uma coleção de carros que ocuparão cada segmento, além de uma coleção separada de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todos os</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> carros na estrada.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> cars      = [];  <span class="hljs-comment">// array of cars on the road</span>
<span class="hljs-keyword">var</span> totalCars = <span class="hljs-number">200</span>; <span class="hljs-comment">// total number of cars on the road</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params"></span>) </span>{<font></font>
  segments.push({<font></font>
    ...<font></font>
    cars: [], <span class="hljs-comment">// array of cars within this segment</span><font></font>
    ...<font></font>
  });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O armazenamento de duas estruturas de dados de automóveis nos permite percorrer facilmente todos os carros de maneira iterativa </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, movendo-os de um segmento para outro, se necessário; </font><font style="vertical-align: inherit;">ao mesmo tempo, isso nos permite executar </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apenas máquinas em segmentos visíveis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada máquina recebe um deslocamento horizontal aleatório, posição z, fonte e velocidade do sprite:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetCars</span>(<span class="hljs-params"></span>) </span>{<font></font>
  cars = [];<font></font>
  <span class="hljs-keyword">var</span> n, car, segment, offset, z, sprite, speed;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span> ; n &lt; totalCars ; n++) {<font></font>
    offset = <span class="hljs-built_in">Math</span>.random() * Util.randomChoice([<span class="hljs-number">-0.8</span>, <span class="hljs-number">0.8</span>]);<font></font>
    z      = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * segments.length) * segmentLength;<font></font>
    sprite = Util.randomChoice(SPRITES.CARS);<font></font>
    speed  = maxSpeed/<span class="hljs-number">4</span> + <span class="hljs-built_in">Math</span>.random() * maxSpeed/(sprite == SPRITES.SEMI ? <span class="hljs-number">4</span> : <span class="hljs-number">2</span>);<font></font>
    car = { <span class="hljs-attr">offset</span>: offset, <span class="hljs-attr">z</span>: z, <span class="hljs-attr">sprite</span>: sprite, <span class="hljs-attr">speed</span>: speed };<font></font>
    segment = findSegment(car.z);<font></font>
    segment.cars.push(car);<font></font>
    cars.push(car);<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderização em subida (retorno)</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nas partes anteriores, eu falei sobre renderizar segmentos da estrada, incluindo curvas e colinas, mas havia algumas linhas de código nelas que eu não considerava. Eles diziam respeito a uma variável </font></font><code>maxy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">começando na parte inferior da tela, mas diminuindo ao renderizar cada segmento para determinar qual parte da tela já havia renderizado:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; drawDistance ; n++) {<font></font>
<font></font>
  ...<font></font>
<font></font>
  if ((segment.p1.camera.z &lt;= cameraDepth) || <span class="hljs-comment">// behind us</span>
      (segment.p2.screen.y &gt;= maxy))          <span class="hljs-comment">// clip by (already rendered) segment</span>
    <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
  ...<font></font>
<font></font>
  maxy = segment.p2.screen.y;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso nos permitirá cortar segmentos que serão cobertos por colinas já renderizadas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tradicional </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">do artista, a</font></a><font style="vertical-align: inherit;"> renderização geralmente acontece de trás para a frente, enquanto segmentos mais próximos se sobrepõem aos mais distantes. </font><font style="vertical-align: inherit;">No entanto, não podemos gastar tempo processando polígonos, que serão substituídos, portanto, fica mais fácil renderizar da frente para trás e cortar segmentos distantes cobertos por segmentos já renderizados próximos se as coordenadas projetadas forem menores </font></font><code>maxy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderização de outdoors, árvores e carros</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, o deslocamento iterativo de segmentos de estrada da frente para trás não funcionará ao renderizar sprites, porque eles geralmente se sobrepõem e, portanto, devem ser renderizados usando o algoritmo do artista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso complica nosso método </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e nos obriga a ignorar segmentos de estrada em dois estágios:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frente para trás para renderização de estradas</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retroceder para renderizar sprites</font></font></li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8db/7d3/347/8db7d3347ac49621e67b7bbe2028fc6e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além de sprites parcialmente sobrepostos, precisamos lidar com sprites que “se projetam levemente” devido ao horizonte no topo da colina. Se o sprite for alto o suficiente, devemos ver sua parte superior, mesmo que o segmento da estrada em que ele está localizado esteja na parte de trás da colina e, portanto, não seja renderizado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos resolver o último problema salvando o valor de </font></font><code>maxy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cada segmento como uma linha </font></font><code>clip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na etapa 1. Em seguida, podemos cortar os sprites desse segmento ao longo da linha </font></font><code>clip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na etapa 2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O restante da lógica de renderização determina como dimensionar e posicionar o sprite com base no coeficiente </font></font><code>scale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e nas coordenadas </font></font><code>screen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos segmentos de estrada (calculado em estágio 1), devido ao qual, no segundo estágio do método </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, temos o seguinte:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// back to front painters algorithm</span>
<span class="hljs-keyword">for</span>(n = (drawDistance<span class="hljs-number">-1</span>) ; n &gt; <span class="hljs-number">0</span> ; n--) {<font></font>
  segment = segments[(baseSegment.index + n) % segments.length];<font></font>
<font></font>
  <span class="hljs-comment">// render roadside sprites</span>
  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span> ; i &lt; segment.sprites.length ; i++) {<font></font>
    sprite      = segment.sprites[i];<font></font>
    spriteScale = segment.p1.screen.scale;<font></font>
    spriteX     = segment.p1.screen.x + (spriteScale * sprite.offset * roadWidth * width/<span class="hljs-number">2</span>);<font></font>
    spriteY     = segment.p1.screen.y;<font></font>
    Render.sprite(ctx, width, height, resolution, roadWidth, sprites, sprite.source, spriteScale, spriteX, spriteY, (sprite.offset &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, segment.clip);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// render other cars</span>
  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span> ; i &lt; segment.cars.length ; i++) {<font></font>
    car         = segment.cars[i];<font></font>
    sprite      = car.sprite;<font></font>
    spriteScale = Util.interpolate(segment.p1.screen.scale, segment.p2.screen.scale, car.percent);<font></font>
    spriteX     = Util.interpolate(segment.p1.screen.x,     segment.p2.screen.x,     car.percent) + (spriteScale * car.offset * roadWidth * width/<span class="hljs-number">2</span>);<font></font>
    spriteY     = Util.interpolate(segment.p1.screen.y,     segment.p2.screen.y,     car.percent);<font></font>
    Render.sprite(ctx, width, height, resolution, roadWidth, sprites, car.sprite, spriteScale, spriteX, spriteY, <span class="hljs-number">-0.5</span>, <span class="hljs-number">-1</span>, segment.clip);<font></font>
  }<font></font>
<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colisões com outdoors e árvores</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora que podemos adicionar e renderizar sprites de objetos ao longo das margens da estrada, precisamos alterar o método </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para determinar se o jogador encontrou algum desses sprites em seu segmento atual: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
usamos um método auxiliar </font></font><code>Util.overlap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para implementar o reconhecimento generalizado da interseção de retângulos. </font><font style="vertical-align: inherit;">Se um cruzamento for detectado, paramos o carro:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">if</span> ((playerX &lt; <span class="hljs-number">-1</span>) || (playerX &gt; <span class="hljs-number">1</span>)) {
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; playerSegment.sprites.length ; n++) {<font></font>
    sprite  = playerSegment.sprites[n];<font></font>
    spriteW = sprite.source.w * SPRITES.SCALE;<font></font>
    <span class="hljs-keyword">if</span> (Util.overlap(playerX, playerW, sprite.offset + spriteW/<span class="hljs-number">2</span> * (sprite.offset &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>), spriteW)) {
      <span class="hljs-comment">// stop the car</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: se você estudar o código real, verá que, na verdade, não estamos parando o carro, porque ele não poderá se mover de lado para evitar obstáculos; </font><font style="vertical-align: inherit;">como um simples hack, fixamos a posição deles e permitimos que o carro "escorregue" para os lados ao redor do sprite.</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colisões com carros</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além de colisões com sprites nas margens da estrada, precisamos reconhecer colisões com outros carros e, se um cruzamento for detectado, desaceleramos o jogador "empurrando" ele para trás do carro com o qual ele colidiu:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; playerSegment.cars.length ; n++) {<font></font>
  car  = playerSegment.cars[n];<font></font>
  carW = car.sprite.w * SPRITES.SCALE;<font></font>
  <span class="hljs-keyword">if</span> (speed &gt; car.speed) {
    <span class="hljs-keyword">if</span> (Util.overlap(playerX, playerW, car.offset, carW, <span class="hljs-number">0.8</span>)) {
      <span class="hljs-comment">// slow the car</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atualização da máquina</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que outros carros se movam pela estrada, daremos a eles a IA mais simples:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andar a uma velocidade constante</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">automaticamente percorrer o jogador ao ultrapassar</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">automaticamente circula em outros carros ao ultrapassar</font></font></li>
</ul><br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: não precisamos nos preocupar em virar outros carros ao longo de uma curva na estrada, porque as curvas não são reais. </font><font style="vertical-align: inherit;">Se fizermos os carros se moverem ao longo dos trechos da estrada, eles passarão automaticamente pelas curvas.</font></font></em></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo isso acontece durante o ciclo do jogo </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durante uma chamada </font></font><code>updateCars()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na qual movemos cada carro para frente a uma velocidade constante e mudamos de um segmento para o outro se eles tiverem se distanciado o suficiente durante esse quadro.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateCars</span>(<span class="hljs-params">dt, playerSegment, playerW</span>) </span>{
  <span class="hljs-keyword">var</span> n, car, oldSegment, newSegment;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; cars.length ; n++) {<font></font>
    car         = cars[n];<font></font>
    oldSegment  = findSegment(car.z);<font></font>
    car.offset  = car.offset + updateCarOffset(car, oldSegment, playerSegment, playerW);<font></font>
    car.z       = Util.increase(car.z, dt * car.speed, trackLength);<font></font>
    car.percent = Util.percentRemaining(car.z, segmentLength); <span class="hljs-comment">// useful for interpolation during rendering phase</span><font></font>
    newSegment  = findSegment(car.z);<font></font>
    <span class="hljs-keyword">if</span> (oldSegment != newSegment) {<font></font>
      index = oldSegment.cars.indexOf(car);<font></font>
      oldSegment.cars.splice(index, <span class="hljs-number">1</span>);<font></font>
      newSegment.cars.push(car);<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O método </font></font><code>updateCarOffset()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornece a implementação de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"inteligência artificial"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , permitindo que a máquina circule pelo player ou por outras máquinas. </font><font style="vertical-align: inherit;">Este é um dos métodos mais complexos na base de código e, em um jogo real, deve ser muito mais complexo, para que as máquinas pareçam muito mais realistas do que em uma demonstração simples. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em nosso projeto, usamos uma força bruta de IA ingênua, forçando cada máquina:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ansiosos para 20 segmentos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se ela encontrar um carro mais lento à sua frente que cruze seu caminho, então contorne</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vire à direita a partir de obstáculos no lado esquerdo da estrada</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vire à esquerda dos obstáculos no lado direito da estrada</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gire o suficiente para evitar obstáculos à frente na distância restante</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Também podemos trapacear com os carros que são invisíveis para o jogador, permitindo que eles simplesmente não circulem entre si e passem. </font><font style="vertical-align: inherit;">Eles devem parecer "inteligentes" apenas dentro da visibilidade do jogador.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateCarOffset</span>(<span class="hljs-params">car, carSegment, playerSegment, playerW</span>) </span>{<font></font>
<font></font>
  <span class="hljs-keyword">var</span> i, j, dir, segment, otherCar, otherCarW, lookahead = <span class="hljs-number">20</span>, carW = car.sprite.w * SPRITES.SCALE;<font></font>
<font></font>
  <span class="hljs-comment">// optimization, dont bother steering around other cars when 'out of sight' of the player</span>
  <span class="hljs-keyword">if</span> ((carSegment.index - playerSegment.index) &gt; drawDistance)
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span> ; i &lt; lookahead ; i++) {<font></font>
    segment = segments[(carSegment.index+i)%segments.length];<font></font>
<font></font>
    <span class="hljs-keyword">if</span> ((segment === playerSegment) &amp;&amp; (car.speed &gt; speed) &amp;&amp; (Util.overlap(playerX, playerW, car.offset, carW, <span class="hljs-number">1.2</span>))) {
      <span class="hljs-keyword">if</span> (playerX &gt; <span class="hljs-number">0.5</span>)<font></font>
        dir = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (playerX &lt; <span class="hljs-number">-0.5</span>)<font></font>
        dir = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">else</span>
        dir = (car.offset &gt; playerX) ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">return</span> dir * <span class="hljs-number">1</span>/i * (car.speed-speed)/maxSpeed; <span class="hljs-comment">// the closer the cars (smaller i) and the greater the speed ratio, the larger the offset</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span> ; j &lt; segment.cars.length ; j++) {<font></font>
      otherCar  = segment.cars[j];<font></font>
      otherCarW = otherCar.sprite.w * SPRITES.SCALE;<font></font>
      <span class="hljs-keyword">if</span> ((car.speed &gt; otherCar.speed) &amp;&amp; Util.overlap(car.offset, carW, otherCar.offset, otherCarW, <span class="hljs-number">1.2</span>)) {
        <span class="hljs-keyword">if</span> (otherCar.offset &gt; <span class="hljs-number">0.5</span>)<font></font>
          dir = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (otherCar.offset &lt; <span class="hljs-number">-0.5</span>)<font></font>
          dir = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span>
          dir = (car.offset &gt; otherCar.offset) ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">return</span> dir * <span class="hljs-number">1</span>/i * (car.speed-otherCar.speed)/maxSpeed;<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na maioria dos casos, esse algoritmo funciona muito bem, mas com uma grande multidão de carros na frente, podemos notar que os carros estão se movendo da esquerda para a direita e para trás, tentando se espremer no espaço entre as outras duas máquinas. </font><font style="vertical-align: inherit;">Existem muitas maneiras de melhorar a confiabilidade da IA, por exemplo, você pode permitir que os carros desacelerem se perceberem que não há espaço suficiente para evitar obstáculos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interface</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por fim, criaremos uma interface HTML rudimentar:</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;div id = "hud"&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id = "speed" class = "hud"&gt; &lt;span id = "speed_value" class = "value"&gt; 0 &lt;/span&gt; mph &lt;/span&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id = "current_lap_time" class = "hud"&gt; Horário: &lt;span id = "current_lap_time_value" class = "value"&gt; 0.0 &lt;/span&gt; &lt;/span&gt; </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id = "last_lap_time" class = "hud"&gt; Última volta: &lt;span id = "last_lap_time_value" class = "value"&gt; 0.0 &lt;/span&gt; &lt;/span&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id = "fast_lap_time" class = "hud"&gt; Volta mais rápida: &lt;span id = "fast_lap_time_value" class = "value"&gt; 0.0 &lt;/span&gt; &lt;/span&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&lt;/div&gt;</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... e adicione o estilo CSS a ele</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-id">#hud</span>                   { <span class="hljs-attribute">position</span>: absolute; <span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>; <span class="hljs-attribute">width</span>: <span class="hljs-number">640px</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span> <span class="hljs-number">0</span>; <span class="hljs-attribute">font-family</span>: Verdana, Geneva, sans-serif; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0.8em</span>; <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.4</span>); <span class="hljs-attribute">color</span>: black; <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">2px</span> solid black; <span class="hljs-attribute">box-sizing</span>: border-box; <span class="hljs-attribute">-moz-box-sizing</span>: border-box; <span class="hljs-attribute">-webkit-box-sizing</span>: border-box; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-class">.hud</span>              { <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0.6</span>); <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>; <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black; <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">5px</span>; <span class="hljs-attribute">transition-property</span>: background-color; <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">2s</span>; <span class="hljs-attribute">-webkit-transition-property</span>: background-color; <span class="hljs-attribute">-webkit-transition-duration</span>: <span class="hljs-number">2s</span>; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#speed</span>            { <span class="hljs-attribute">float</span>: right; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#current_lap_time</span> { <span class="hljs-attribute">float</span>: left;  }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#last_lap_time</span>    { <span class="hljs-attribute">float</span>: left; <span class="hljs-attribute">display</span>: none;  }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#fast_lap_time</span>    { <span class="hljs-attribute">display</span>: block; <span class="hljs-attribute">width</span>: <span class="hljs-number">12em</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto; <span class="hljs-attribute">text-align</span>: center; <span class="hljs-attribute">transition-property</span>: background-color; <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">2s</span>; <span class="hljs-attribute">-webkit-transition-property</span>: background-color; <span class="hljs-attribute">-webkit-transition-duration</span>: <span class="hljs-number">2s</span>; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-class">.value</span>            { <span class="hljs-attribute">color</span>: black; <span class="hljs-attribute">font-weight</span>: bold; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-class">.fastest</span>          { <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">215</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>); }</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... e executaremos sua atualização () durante o ciclo do jogo:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">if</span> (position &gt; playerZ) {
  <span class="hljs-keyword">if</span> (currentLapTime &amp;&amp; (startPosition &lt; playerZ)) {<font></font>
    lastLapTime    = currentLapTime;<font></font>
    currentLapTime = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (lastLapTime &lt;= Util.toFloat(Dom.storage.fast_lap_time)) {<font></font>
      Dom.storage.fast_lap_time = lastLapTime;<font></font>
      updateHud(<span class="hljs-string">'fast_lap_time'</span>, formatTime(lastLapTime));<font></font>
      Dom.addClassName(<span class="hljs-string">'fast_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
      Dom.addClassName(<span class="hljs-string">'last_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span> {<font></font>
      Dom.removeClassName(<span class="hljs-string">'fast_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
      Dom.removeClassName(<span class="hljs-string">'last_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
    }<font></font>
    updateHud(<span class="hljs-string">'last_lap_time'</span>, formatTime(lastLapTime));<font></font>
    Dom.show(<span class="hljs-string">'last_lap_time'</span>);<font></font>
  }<font></font>
  <span class="hljs-keyword">else</span> {<font></font>
    currentLapTime += dt;<font></font>
  }<font></font>
}<font></font>
<font></font>
updateHud(<span class="hljs-string">'speed'</span>,            <span class="hljs-number">5</span> * <span class="hljs-built_in">Math</span>.round(speed/<span class="hljs-number">500</span>));<font></font>
updateHud(<span class="hljs-string">'current_lap_time'</span>, formatTime(currentLapTime));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O método auxiliar </font></font><code>updateHud()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nos permite atualizar elementos DOM apenas quando os valores mudam, porque essa atualização pode ser um processo lento e não devemos fazê-lo a 60 fps se os valores em si não mudarem.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateHud</span>(<span class="hljs-params">key, value</span>) </span>{ <span class="hljs-comment">// accessing DOM can be slow, so only do it if value has changed</span>
  <span class="hljs-keyword">if</span> (hud[key].value !== value) {<font></font>
    hud[key].value = value;<font></font>
    Dom.set(hud[key].dom, value);<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusão</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/103/563/0d1/1035630d19106de2f85edebb24d0421f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fuh! </font><font style="vertical-align: inherit;">A última parte foi longa, mas ainda terminamos, e a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versão final</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chegou ao estágio em que pode ser chamada de jogo. </font><font style="vertical-align: inherit;">Ela ainda está longe do </font><font style="vertical-align: inherit;">jogo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terminado</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas ainda é um jogo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É incrível que nós realmente conseguimos criar um jogo, embora tão simples. </font><font style="vertical-align: inherit;">Não pretendo levar esse projeto a um estado completo. </font><font style="vertical-align: inherit;">Deve ser considerado simplesmente como uma </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introdução</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ao tópico dos jogos de corrida pseudo-tridimensionais. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O código </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é publicado pelo github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e você pode tentar transformá-lo em um jogo de corrida mais avançado. </font><font style="vertical-align: inherit;">Você também pode tentar:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adicionar efeitos sonoros aos carros</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melhorar a sincronização de música</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementar tela cheia</font></font></li>
<li>   (   , ,    ,  ..)</li>
<li>    </li>
<li>   (,   ..)</li>
<li>       </li>
<li> ,     </li>
<li> ,          -</li>
<li> ,     </li>
<li>   (   ,     ..)</li>
<li>    drawDistance</li>
<li>         x,y</li>
<li>     </li>
<li>      (   ,  )</li>
<li> </li>
<li> </li>
<li>     </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conexões de garfo e estrada</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a mudança da noite e do dia</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">condições do tempo</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">túneis, pontes, nuvens, paredes, edifícios</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cidade, deserto, oceano</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione Seattle e Space Needle aos fundos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Vilões" - adicione concorrentes para competir</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modos de jogo - a volta mais rápida, uma em uma corrida (pegando moedas?, atirando em vilões?)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toneladas de opções de personalização de jogabilidade</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etc.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então terminamos. </font><font style="vertical-align: inherit;">Outro “projeto de final de semana” que demorou muito mais que o esperado, mas no final o resultado foi muito bom.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referências</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Início de uma série de artigos, estradas retas e curvas</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Página Pseudo 3d de Lou</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonte</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Links para demos jogáveis:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demonstração de estrada reta</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demo com curvas</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demo de colinas</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versão finalizada</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt499432/index.html">Autonomia de testes de unidade no PHPUnit</a></li>
<li><a href="../pt499434/index.html">Como implementar a gestão do conhecimento: beneficie “malotes”, “multas de papagaio” e pensamento de clipe</a></li>
<li><a href="../pt499436/index.html">Enzima controlada remotamente acelerará o tratamento de derrames e lesões na coluna vertebral</a></li>
<li><a href="../pt499438/index.html">Transmita para testadores e não apenas</a></li>
<li><a href="../pt499440/index.html">Como escrevemos o piloto automático mais legal do mundo para uma locomotiva de manobra</a></li>
<li><a href="../pt499444/index.html">Postgres: bloat, pg_repack e restrições adiadas</a></li>
<li><a href="../pt499446/index.html">Testando gerenciadores de inicialização no formato STEP para VR</a></li>
<li><a href="../pt499448/index.html">Implementando o SOLID e a arquitetura em camadas no Node.js com TypeScript e InversifyJS</a></li>
<li><a href="../pt499450/index.html">Escolhendo o equipamento para um jogo persa usando genética / evolução em Python</a></li>
<li><a href="../pt499452/index.html">Cotidiano de um oftalmologista na clínica: quando os médicos não são suficientes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>