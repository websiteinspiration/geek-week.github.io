<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍⚖️ 🌩️ 👨🏾‍🎓 Flotter sous le capot 🤱🏽 ⛹🏼 🍖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous! Je m'appelle Mikhail Zotiev, je travaille en tant que développeur Flutter chez Surf. Moi, comme probablement la majorité des autres dé...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Flotter sous le capot</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/501862/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour à tous! Je m'appelle Mikhail Zotiev, je travaille en tant que développeur Flutter chez Surf. Moi, comme probablement la majorité des autres développeurs qui travaillent avec Flutter, j'aime surtout combien il est facile de créer des applications belles et pratiques avec son aide. Il faut très peu de temps pour entrer dans le développement de Flutter. J'ai récemment travaillé dans le développement de jeux, et maintenant je suis complètement passé au développement mobile multiplateforme sur Flutter.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelle est la simplicité? </font><font style="vertical-align: inherit;">Avec une douzaine de widgets de base, vous pouvez créer des interfaces utilisateur assez décentes. </font><font style="vertical-align: inherit;">Et au fil du temps, lorsque les bagages utilisés sont assez décents, il est peu probable qu'une tâche vous arrête: que ce soit un design inhabituel ou une animation sophistiquée. </font><font style="vertical-align: inherit;">Et le plus intéressant - très probablement vous pouvez l'utiliser sans même penser à la question: "Comment ça marche du tout?" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depuis Flutter a l'open source, j'ai décidé de comprendre ce qui est sous le capot (du côté Dart de la Force) et de le partager avec vous.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lg/ln/q6/lglnq6t8sbc8gq-emifhx1dxjwu.png"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons tous entendu plus d'une fois la phrase de l'équipe de développement du framework: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Tout dans Flutter est un widget</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><i><font style="vertical-align: inherit;">" </font></i><font style="vertical-align: inherit;">Voyons voir si c'est vraiment le cas. </font><font style="vertical-align: inherit;">Pour ce faire, nous nous tournons vers la classe </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ci-après - le widget) et commençons progressivement à nous familiariser avec le contenu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première chose que nous lirons dans la documentation de la classe:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Décrit la configuration d'un [élément].</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'avère que le widget lui-même n'est qu'une description d'un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">élément</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ci-après - l'élément).</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les widgets sont la hiérarchie centrale des classes dans le framework Flutter. </font><font style="vertical-align: inherit;">Un widget est une description immuable d'une partie d'une interface utilisateur. </font><font style="vertical-align: inherit;">Les widgets peuvent être gonflés en éléments, qui gèrent l'arborescence de rendu sous-jacente.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour résumer, l'expression </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Tout dans Flutter est un widget"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le niveau minimum de compréhension de la façon dont tout est organisé pour utiliser Flutter. </font><font style="vertical-align: inherit;">Le widget est la classe centrale de la hiérarchie Flutter. </font><font style="vertical-align: inherit;">En même temps, il existe de nombreux mécanismes supplémentaires qui aident le cadre à faire face à sa tâche. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons donc appris quelques faits supplémentaires:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">widget - une description immuable d'une partie de l'interface utilisateur;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le widget est associé à une vue avancée appelée élément; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un élément contrôle une entité de l'arbre de rendu.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous devez avoir remarqué une chose étrange. </font><font style="vertical-align: inherit;">L'interface utilisateur et l'immuabilité sont très mal liées, je dirais même que ce sont des concepts totalement incompatibles. </font><font style="vertical-align: inherit;">Mais nous y reviendrons quand une image plus complète de l'appareil du monde Flutter émergera, mais pour l'instant, nous continuerons à nous familiariser avec la documentation du widget.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les widgets eux-mêmes n'ont pas d'état mutable (tous leurs champs doivent être définitifs). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous souhaitez associer un état mutable à un widget, envisagez d'utiliser un [StatefulWidget], qui crée un objet [State] (via [StatefulWidget.createState]) chaque fois qu'il est gonflé dans un élément et incorporé dans l'arborescence.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce paragraphe complète un peu le premier paragraphe: si nous avons besoin d'une configuration mutable, nous utilisons l'entité spéciale </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">State</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ci-après dénommée l'état), qui décrit l'état actuel de ce widget. </font><font style="vertical-align: inherit;">Cependant, l'état n'est pas associé au widget, mais à sa représentation élémentaire.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un widget donné peut être inclus dans l'arbre zéro ou plusieurs fois. </font><font style="vertical-align: inherit;">En particulier, un widget donné peut être placé plusieurs fois dans l'arborescence. </font><font style="vertical-align: inherit;">Chaque fois qu'un widget est placé dans l'arbre, il est gonflé dans un [Element], ce qui signifie qu'un widget qui est incorporé plusieurs fois dans l'arbre sera gonflé plusieurs fois.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le même widget peut être inclus plusieurs fois dans l'arborescence des widgets, ou ne pas être inclus du tout. </font><font style="vertical-align: inherit;">Mais chaque fois qu'un widget est inclus dans l'arborescence des widgets, un élément lui est mappé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, à ce stade, les widgets sont presque terminés, résumons:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">widget - la classe centrale de la hiérarchie;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">widget est une configuration; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">widget - une description immuable d'une partie de l'interface utilisateur; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le widget est associé à un élément qui contrôle le rendu d'une manière ou d'une autre; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'état changeant du widget peut être décrit par une entité, mais il n'est pas connecté au widget, mais à l'élément qui représente ce widget.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Élément</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'après ce que nous avons appris, la question se pose: «Quels sont ces éléments qui régissent tout?» </font><font style="vertical-align: inherit;">Faites de même - ouvrez la documentation de la classe Element.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une instanciation d'un [Widget] à un emplacement particulier dans l'arborescence.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un élément est une représentation d'un widget à un endroit spécifique dans un arbre.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les widgets décrivent comment configurer un sous-arbre, mais le même widget peut être utilisé pour configurer plusieurs sous-arbres simultanément car les widgets sont immuables. </font><font style="vertical-align: inherit;">Un [Element] représente l'utilisation d'un widget pour configurer un emplacement spécifique dans l'arborescence. </font><font style="vertical-align: inherit;">Au fil du temps, le widget associé à un élément donné peut changer, par exemple, si le widget parent se reconstruit et crée un nouveau widget pour cet emplacement.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le widget décrit la configuration d'une partie de l'interface utilisateur, mais comme nous le savons déjà, le même widget peut être utilisé à différents endroits de l'arborescence. Chacun de ces lieux sera représenté par un élément correspondant. Mais au fil du temps, le widget associé à l'élément peut changer. Cela signifie que les éléments sont plus tenaces et continuent d'être utilisés, ne mettant à jour que leurs connexions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit d'une décision assez rationnelle. Comme nous l'avons déjà défini ci-dessus, les widgets sont une configuration immuable qui décrit simplement une partie spécifique de l'interface, ce qui signifie qu'ils doivent être très légers. Et les éléments dans le domaine desquels la gestion est beaucoup plus lourde, mais ils ne sont pas recréés inutilement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour comprendre comment cela se fait, considérez le cycle de vie d'un élément:</font></font><br>
<br>
<ul>
<li>     Widget.createElement    ,     .</li>
<li>   mount        .              .</li>
<li>       .</li>
<li>   ,    (,    ),     .       runtimeType  key,     .   ,     ,           .</li>
<li> ,       ,    ,             ,      (  deactivate).</li>
<li>   ,     .           ,       ,   (unmount),           .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous ré-incluez des éléments dans l'arborescence, par exemple, si l'élément ou ses ancêtres ont une clé globale, elle sera supprimée de la liste des éléments inactifs, la méthode activate sera appelée et l'objet rendu associé à cet élément sera à nouveau incorporé dans l'arborescence de rendu. </font><font style="vertical-align: inherit;">Cela signifie que l'élément devrait réapparaître à l'écran.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la déclaration de classe, nous voyons que l'élément implémente l'interface BuildContext. </font><font style="vertical-align: inherit;">Un BuildContext est quelque chose qui contrôle la position d'un widget dans une arborescence de widgets, comme suit dans sa documentation. </font><font style="vertical-align: inherit;">Correspond presque exactement à la description de l'article. </font><font style="vertical-align: inherit;">Cette interface est utilisée pour éviter la manipulation directe de l'élément, mais donne en même temps accès aux méthodes de contexte nécessaires. </font><font style="vertical-align: inherit;">Par exemple, findRenderObject, qui vous permet de trouver l'objet d'arbre de rendu correspondant à cet élément.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderderbject</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reste à traiter du dernier maillon de cette triade - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RenderObject</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Comme son nom l'indique, il s'agit d'un objet de l'arbre de visualisation. Il a un objet parent, ainsi qu'un champ de données que l'objet parent utilise pour stocker des informations spécifiques concernant cet objet lui-même, par exemple, sa position. Cet objet est responsable de l'implémentation des protocoles de rendu et de mise en page de base.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RenderObject ne limite pas le modèle d'utilisation des objets enfants: il peut n'y en avoir aucun, un ou plusieurs. </font><font style="vertical-align: inherit;">En outre, le système de positionnement n'est pas limité à: le système cartésien, les coordonnées polaires, tout cela et bien plus encore est disponible pour utilisation. </font><font style="vertical-align: inherit;">Il n'y a pas de restrictions sur l'utilisation des protocoles de localisation: ajuster la largeur ou la hauteur, limiter la taille, spécifier la taille et l'emplacement du parent ou, si nécessaire, utiliser les données de l'objet parent.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Image du monde Flutter</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayons de construire une vue d'ensemble de la façon dont tout fonctionne ensemble. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous l'avons déjà noté ci-dessus, le widget est une description immuable, mais l'interface utilisateur n'est pas du tout statique. </font><font style="vertical-align: inherit;">Cet écart est supprimé en divisant en 3 niveaux d'objets et la division des zones de responsabilité.</font></font><br>
<br>
<ul>
<li> ,          . </li>
<li> ,               . </li>
<li>  ,   — ,     .</li>
</ul><br>
<img src="https://habrastorage.org/webt/j_/n_/og/j_n_ogui1a0iawbuoq5vxclsnne.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons à quoi ces arbres ressemblent avec un exemple simple: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/u7/0o/wk/u70owkgirs6krcos85rwn-acli8.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dans ce cas, nous avons un StatelessWidget enveloppé dans un widget Padding et contenant du texte à l'intérieur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mettons-nous à la place de Flutter - on nous a donné cet arbre de widget. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Hey, Padding, j'ai besoin de votre élément"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Padding: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Bien sûr, maintenez SingleChildRenderObjectElement"</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/jj/u7/zn/jju7znfat7skocfex74adc4cu7o.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Element, voici votre place, installez-vous"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
SingleChildRenderObjectElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Les gars, tout va bien, mais j'ai besoin de RenderObject"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Padding, comme pour vous dessiner? "</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Rembourrage: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Tenez-le, RenderPadding"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
SingleChildRenderObjectElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Super,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mettez </font><i><font style="vertical-align: inherit;">-vous au travail"</font></i></font><br>
<br>
<img src="https://habrastorage.org/webt/zk/ty/se/zktyse7pgo6jdd6x7impyivfhy0.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter:</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Alors qui est le prochain?" StatelessWidget, maintenant vous laissez l'élément »</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
StatelessWidget: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">« Ici StatelessElement »</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">« StatelessElement, vous serez soumis à SingleChildRenderObjectElement, voici l'endroit, embarquant »</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
StatelessElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">« OK »</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/7w/tb/ke/7wtbkebtfn_xeq1ieqxqbarpkro.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">« le RichText, elementik Present, veuillez »</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
le RichText donne MultiChildRenderObjectElement </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«MultiChildRenderObjectElement, c'est parti, commencez»</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
MultiChildRenderObjectElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«J'ai besoin d'un rendu pour le travail»</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«RichText, nous avons besoin d'un objet de rendu»</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
RichText: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Voici un RenderParagraph»</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter:</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"RenderParagraph vous recevrez des instructions RenderPadding, et MultiChildRenderObjectElement vous contrôlera"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
MultiChildRenderObjectElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Maintenant tout va bien, je suis prêt"</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/s4/24/fn/s424fnivo4j2tb4sv9pcirmxov0.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Vous allez sûrement poser une question logique: "Où est l'objet de rendu pour StatelessWidget, pourquoi n'est-il pas là, nous avons décidé ci-dessus que les éléments lient les configurations avec écran? " </font><font style="vertical-align: inherit;">Prenons attention à l'implémentation de base de la méthode de montage, qui a été discutée dans cette section de la description du cycle de vie.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">void</span> mount(Element parent, dynamic newSlot) {<font></font>
    assert(_debugLifecycleState == _ElementLifecycle.initial);<font></font>
    assert(widget != <span class="hljs-literal">null</span>);<font></font>
    assert(_parent == <span class="hljs-literal">null</span>);<font></font>
    assert(parent == <span class="hljs-literal">null</span> || parent._debugLifecycleState == _ElementLifecycle.active);<font></font>
    assert(slot == <span class="hljs-literal">null</span>);<font></font>
    assert(depth == <span class="hljs-literal">null</span>);<font></font>
    assert(!_active);<font></font>
    _parent = parent;<font></font>
    _slot = newSlot;<font></font>
    _depth = _parent != <span class="hljs-literal">null</span> ? _parent.depth + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<font></font>
    _active = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>)<font></font>
        _owner = parent.owner;<font></font>
    <span class="hljs-keyword">if</span> (widget.key is GlobalKey) {<font></font>
        final GlobalKey key = widget.key;<font></font>
        key._register(<span class="hljs-keyword">this</span>);<font></font>
    }<font></font>
    _updateInheritance();<font></font>
    assert(() {<font></font>
        _debugLifecycleState = _ElementLifecycle.active;<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }());<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On n'y verra pas la création d'un objet de rendu. </font><font style="vertical-align: inherit;">Mais l'élément implémente un BuildContext, qui a une méthode de recherche d'objet de visualisation findRenderObject, qui nous mènera au getter suivant:</font></font><br>
<br>
<pre><code class="javascript hljs">RenderObject get renderObject {<font></font>
    RenderObject result;<font></font>
    <span class="hljs-keyword">void</span> visit(Element element) {<font></font>
        assert(result == <span class="hljs-literal">null</span>); 
        <span class="hljs-keyword">if</span> (element is RenderObjectElement)<font></font>
            result = element.renderObject;<font></font>
        <span class="hljs-keyword">else</span><font></font>
            element.visitChildren(visit);<font></font>
    }<font></font>
    visit(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> result;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cas de base, un élément ne peut pas créer un objet de rendu; seuls RenderObjectElement et ses descendants sont requis pour ce faire, cependant, dans ce cas, un élément à un certain niveau d'imbrication doit avoir un élément enfant qui a un objet de rendu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il semblerait pourquoi toutes ces difficultés. Jusqu'à 3 arbres, différents domaines de responsabilité, etc. La réponse est assez simple - c'est là que les performances de Flutter sont construites. Les widgets sont des configurations immuables, par conséquent, ils sont souvent recréés, mais en même temps, ils sont assez légers, ce qui n'affecte pas les performances. Mais Flutter essaie de réutiliser autant que possible les éléments lourds. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenons un exemple. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texte au milieu de l'écran. Dans ce cas, le code ressemblera à ceci:</font></font></i><br>
<br>
<pre><code class="javascript hljs">body: Center(<font></font>
    child: Text(“Hello world!”)<font></font>
),</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, l'arborescence des widgets ressemblera à ceci: Une </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lc/wt/fa/lcwtfazdhkpaprcu9tqvhssvck4.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
fois que Flutter a construit les 3 arbres, nous obtenons l'image suivante: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uc/vx/ph/ucvxphu5r2ds-6_kmoizgyoczo8.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que se passe-t-il si nous modifions le texte que nous allons afficher? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_u/8b/do/_u8bdowthfzx9jshpbprfnpj1ai.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons maintenant une nouvelle arborescence de widgets. Ci-dessus, nous avons parlé de la réutilisation maximale possible des éléments. Jetez un œil à la méthode de classe Widget, sous le nom parlant </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">canUpdate</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">static</span> bool canUpdate(Widget oldWidget, Widget newWidget) {
    <span class="hljs-keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType &amp;&amp; oldWidget.key == newWidget.key;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous vérifions le type du widget précédent et du nouveau, ainsi que leurs clés. S'ils sont identiques, il n'est pas nécessaire de modifier l'élément. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, avant la mise à niveau, le premier élément est Centre, après la mise à niveau, également Centre. Les deux n'ont pas de clés, une coïncidence complète. Nous pouvons mettre à jour le lien de l'élément vers un nouveau widget. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/he/tr/s4/hetrs4cgzrimhibqeilfoja5xzi.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais en plus du type et de la clé, le widget est une description et une configuration, et les valeurs des paramètres nécessaires à l'affichage peuvent changer. C'est pourquoi l'élément, après avoir mis à jour le lien vers le widget, doit lancer des mises à jour de l'objet de rendu. Dans le cas de Center, rien n'a changé et nous continuons de comparer davantage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encore une fois, le type et la clé nous indiquent qu'il est inutile de recréer l'élément. Le texte est un descendant de StatelessWidget; il n'a pas d'objet d'affichage direct.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dp/yy/6m/dpyy6mckv6cddryb0_yu5asy_uy.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Accédez à RichText. Le widget n'a pas non plus changé de type; il n'y a pas de divergence dans les clés. L'élément met à jour son association avec le nouveau widget. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hw/vh/95/hwvh952jekjwhudyj6czju3hq6a.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La connexion est mise à jour, il ne reste plus qu'à mettre à jour les propriétés. Par conséquent, RenderParagraph affichera la nouvelle valeur de texte. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lv/_p/g-/lv_pg-n6wlmcmlunokumb60nqw0.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et dès que le moment sera venu pour le prochain cadre de dessin, nous verrons le résultat que nous attendons. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grâce à ce type de travail, Flutter atteint des performances aussi élevées. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'exemple ci-dessus décrit le cas où la structure du widget elle-même n'a pas changé. Mais que se passe-t-il si la structure change? Flutter, bien sûr, continuera d'essayer de maximiser l'utilisation des objets existants, comme nous l'avons compris dans la description du cycle de vie, mais de nouveaux éléments seront créés pour tous les nouveaux widgets, et les anciens et les plus inutiles seront supprimés à la fin du cadre.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardons quelques exemples. </font><font style="vertical-align: inherit;">Et pour nous assurer de ce qui précède, nous utilisons l'outil Android Studio - Flutter Inspector.</font></font><br>
<br>
<pre><code class="javascript hljs">@override<font></font>
Wid<span class="hljs-keyword">get</span> <span class="hljs-title">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> Scaffold(<font></font>
        body: Center(<font></font>
            child: _isFirst ? first() : second(),<font></font>
        ),<font></font>
        <span class="hljs-attr">floatingActionButton</span>: FloatingActionButton(<font></font>
            child: Text(<span class="hljs-string">"Switch"</span>),
            <span class="hljs-attr">onPressed</span>: () {<font></font>
                setState(() {<font></font>
                    _isFirst = !_isFirst;<font></font>
                });<font></font>
            },<font></font>
        ),<font></font>
    );<font></font>
}<font></font>
<font></font>
Wid<span class="hljs-keyword">get</span> <span class="hljs-title">first</span>() =&gt; <span class="hljs-title">Row</span>(<span class="hljs-params">
    mainAxisAlignment: MainAxisAlignment.center,
    children: &lt;Widget&gt;[
        Text(
            <span class="hljs-string">"test"</span>,
            style: TextStyle(fontSize: <span class="hljs-number">25</span></span>),<font></font>
        ),<font></font>
        <span class="hljs-title">SizedBox</span>(<span class="hljs-params">
            width: <span class="hljs-number">5</span>,
        </span>),
        <span class="hljs-title">Icon</span>(<span class="hljs-params">
            Icons.error,
        </span>),<font></font>
    ],<font></font>
);<font></font>
<font></font>
<span class="hljs-title">Widget</span> <span class="hljs-title">second</span>() =&gt; <span class="hljs-title">Row</span>(<span class="hljs-params">
    mainAxisAlignment: MainAxisAlignment.center,
    children: &lt;Widget&gt;[
        Text(
            <span class="hljs-string">"one more test"</span>,
            style: TextStyle(fontSize: <span class="hljs-number">25</span></span>),<font></font>
        ),<font></font>
        <span class="hljs-title">Padding</span>(<span class="hljs-params">
            padding: EdgeInsets.only(left: <span class="hljs-number">5</span></span>),<font></font>
        ),<font></font>
        <span class="hljs-title">Icon</span>(<span class="hljs-params">
            Icons.error,
        </span>),<font></font>
    ],<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, en cliquant sur le bouton, l'un des widgets changera. </font><font style="vertical-align: inherit;">Voyons ce que l'inspecteur nous montre. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wi/vt/vt/wivtvtojhv4uq3l7ouoje3le-u0.png" alt="image"><br>
<br>
<img src="https://habrastorage.org/webt/f4/rb/0a/f4rb0avn7pombux2ct6pkap2edi.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme nous pouvons le voir, Flutter a recréé le rendu uniquement pour le remplissage, le reste vient d'être réutilisé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérez 1 option de plus dans laquelle la structure change d'une manière plus globale - nous changeons les niveaux d'imbrication.</font></font><br>
<br>
<pre><code class="javascript hljs">Wid<span class="hljs-keyword">get</span> <span class="hljs-title">second</span>() =&gt; <span class="hljs-title">Container</span>(<span class="hljs-params">child: first(</span>),);</code></pre><br>
<img src="https://habrastorage.org/webt/yt/8i/gs/yt8igsxt3r3b-ofhkrlcyjaqryc.png" alt="image"><br>
<br>
<img src="https://habrastorage.org/webt/j7/na/qw/j7naqwq6060sh-tw_atxna_umpa.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malgré le fait que l'arbre n'a pas changé du tout visuellement, les éléments et les objets de l'arbre de rendu ont été recréés. </font><font style="vertical-align: inherit;">Cela s'est produit parce que Flutter compare par niveau (dans ce cas, peu importe que la majeure partie de l'arbre n'ait pas changé), le filtrage de cette partie a eu lieu au moment de la comparaison du conteneur et de la ligne. </font><font style="vertical-align: inherit;">Cependant, on peut sortir de cette situation. </font><font style="vertical-align: inherit;">Cela nous aidera à GlobalKey. </font><font style="vertical-align: inherit;">Ajoutez une telle clé pour Row.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> _key = GlobalKey(debugLabel: <span class="hljs-string">"testLabel"</span>);<font></font>
<font></font>
Wid<span class="hljs-keyword">get</span> <span class="hljs-title">first</span>() =&gt; <span class="hljs-title">Row</span>(<span class="hljs-params">
    key: _key,
    …
</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/gg/jp/zj/ggjpzjlpox-ijhgtwxy-i6rvcsk.png" alt="image"><br>
<br>
<img src="https://habrastorage.org/webt/zy/br/zy/zybrzywy-_ixs_apl7j1fiqsrco.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dès que nous avons dit à Flutter que la pièce pouvait être réutilisée, il en a profité.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous nous sommes un peu plus familiarisés avec la magie Flutter et nous savons maintenant que ce n'est pas seulement dans les widgets. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutter est un mécanisme bien coordonné bien pensé avec sa propre hiérarchie, ses domaines de responsabilité, avec lesquels vous pouvez créer non seulement de belles, mais aussi des applications productives. </font><font style="vertical-align: inherit;">Bien sûr, nous n’avons examiné qu’une petite partie, quoique assez importante, de son dispositif, nous continuerons donc à analyser divers aspects du travail interne du cadre dans de futurs articles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'espère que les informations de cet article vous aideront à comprendre le fonctionnement interne de Flutter et vous aideront à trouver des solutions élégantes et productives pendant le développement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Merci pour l'attention!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ressources</font></font></h4><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flutter </font></font></i><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Comment Flutter rend les widgets" par Andrew Fitz Gibbon, Matt Sullivan</font></font></i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr501850/index.html">Nous démontons l'algorithme EM en petites briques</a></li>
<li><a href="../fr501854/index.html">Comment quitter la programmation et commencer à jouer</a></li>
<li><a href="../fr501856/index.html">Tarantool: Look Analyst</a></li>
<li><a href="../fr501858/index.html">Dotting tous les psi</a></li>
<li><a href="../fr501860/index.html">15 mai RU-Center peut vous ajouter un service payant sans votre participation</a></li>
<li><a href="../fr501864/index.html">Assistant ou inspecteur: pour qui le robot appelle-t-il?</a></li>
<li><a href="../fr501866/index.html">Combien d'emplois les robots vont détruire</a></li>
<li><a href="../fr501868/index.html">Comment ne pas laisser le comptable se jeter ou On transfère 1C vers le cloud. Instruction étape par étape</a></li>
<li><a href="../fr501870/index.html">Nombre maximal de valeurs dans la partie II de l'énumération</a></li>
<li><a href="../fr501872/index.html">Lieu d'étude dans les systèmes cybernétiques</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>