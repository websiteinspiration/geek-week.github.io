<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚óªÔ∏è üõï ü§¥ √úberpr√ºfung des Isomorphismus zweier Graphen und Suche nach isomorphen Teilgraphen: Ein Ansatz, der auf der NB-Pfadanalyse basiert ü¶ç ü•å üõÄüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo alle zusammen. 
 
 Es gibt eine solche Aufgabe - zu √ºberpr√ºfen, ob zwei Graphen zueinander isomorph sind. Das hei√üt, um es einfach auszudr√ºcken,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>√úberpr√ºfung des Isomorphismus zweier Graphen und Suche nach isomorphen Teilgraphen: Ein Ansatz, der auf der NB-Pfadanalyse basiert</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491846/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo alle zusammen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt eine solche Aufgabe - zu √ºberpr√ºfen, ob zwei Graphen zueinander isomorph sind. Das hei√üt, um es einfach auszudr√ºcken, um herauszufinden, ob diese beiden Diagramme ‚Äûdasselbe‚Äú Diagramm sind, jedoch mit unterschiedlichen Scheitelpunktnummern und, wenn Diagramme grafisch angegeben sind, mit unterschiedlichen r√§umlichen Positionen. Die L√∂sung f√ºr dieses Problem ist nicht so offensichtlich, wie es jemandem auf den ersten Blick erscheinen mag: Selbst bei kleinen Grafiken gibt ein Blick auf ihre grafische Darstellung nicht immer eine eindeutige Antwort. Siehe zum Beispiel eine Zeichnung im selben Wiki: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Graph_isomorphism#Example</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gut Offensichtlich?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt jedoch eine schwierigere Aufgabe: In einem ‚Äûgro√üen‚Äú Diagramm nach allen Teilgraphen zu suchen, die isomorph zu einem anderen ‚Äûkleineren‚Äú Diagramm sind. </font><font style="vertical-align: inherit;">Dies ist ein noch "dunklerer Wald". </font><font style="vertical-align: inherit;">Das ist nat√ºrlich nicht ganz dunkel, aber die Aufgabe ist nicht die einfachste. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was haben wir also?</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Warum ist das alles notwendig?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und obwohl das Problem der isomorphen (Sub-) Graphen, wie wir bereits erw√§hnt haben, kompliziert ist, ist es durchaus notwendig und n√ºtzlich. </font><font style="vertical-align: inherit;">Und warum? </font><font style="vertical-align: inherit;">Und dann zum Beispiel, um die Datenbank nach chemischen Verbindungen zu durchsuchen, die einem bestimmten Molek√ºl anhand seiner Strukturformel √§hnlich sind. </font><font style="vertical-align: inherit;">Man kann es sich doch als Grafik vorstellen, oder? </font><font style="vertical-align: inherit;">Die Chemoinformatik macht das - es gibt eine solche Wissenschaft. </font><font style="vertical-align: inherit;">Es gibt aber auch Vergleichsaufgaben mit der Stichprobe, verschiedene bioinformatische Aufgaben und viele andere interessante Dinge.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Wie kann dieses Problem gel√∂st werden?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der klassische Ansatz zur L√∂sung dieses Problems wurde 1976 von J. Ullman festgelegt [3], sp√§ter verbesserte er seinen Algorithmus erheblich [4]. Dieser Ansatz wurde auch in den Arbeiten vieler anderer Autoren weiterentwickelt, beispielsweise Cordella und Co-Autoren [2] (VF2-Algorithmus), Bonnitsi und Co-Autoren [1] (RI-Algorithmus) usw. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz gesagt, das Wesentliche dieses Ansatzes ist ‚Äûintelligent‚Äú Aufz√§hlen ‚Äúder m√∂glichen Entsprechungen der Eckpunkte des Beispielgraphen B und des Graphen A, in denen gesucht wird. Diese Suche macht es "klug", verschiedene Bedingungen und Einschr√§nkungen einzugeben, die es Ihnen erm√∂glichen, ungeeignete Optionen so fr√ºh wie m√∂glich auszuschlie√üen. Zu diesen Zwecken k√∂nnen auch verschiedene Vorverarbeitungen der Quelldaten durchgef√ºhrt werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden diese Werke hier nicht nacherz√§hlen, aber wir werden den Leser einladen, sie selbstst√§ndig kennenzulernen. </font><font style="vertical-align: inherit;">"Eine Show ist besser als eine Bestellung", und es sollte beachtet werden, dass es im Web gute grafische Beispiele und Erkl√§rungen f√ºr diese Algorithmen gibt. </font><font style="vertical-align: inherit;">Siehe zum Beispiel Folgendes: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coderoad.ru/17480142/Is-or-simple-example-for-explanation-algorithm-Ulman</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - eine sehr gute und klare Erkl√§rung mit einem Beispiel, </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">issue.life/questions/8176298</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Schritte des VF2-Algorithmus mit einem Beispiel . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellt sich jedoch die Frage: Gibt es andere M√∂glichkeiten und Ans√§tze zur L√∂sung dieses Problems, wenn auch f√ºr einige Sonderf√§lle? </font><font style="vertical-align: inherit;">Und ich m√∂chte Ihnen eine der m√∂glichen Antworten auf diese Frage vorstellen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Isomorphismus von Graphen und NB-Pfaden</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns sofort zustimmen: Unter NB-Pfaden (und nicht aus dem Englischen, sondern einfach, weil es so k√ºrzer ist) werden wir maximale nicht verzweigte Pfade nennen, d. H. </font><font style="vertical-align: inherit;">maximal lange unverzweigte Pfade eines Graphen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir also </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei zueinander isomorphe Graphen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> haben </font><font style="vertical-align: inherit;">, existiert f√ºr jede Darstellung des ersten Graphen als Folge von maximal erweiterten nicht verzweigten Pfaden (d. H. Diesen unserer NB-Pfade) immer eine entsprechende Darstellung des zweiten Graphen, der ihm entspricht, und gleichzeitig:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei gerichteten Graphen werden die einander entsprechenden Pfade ausgerichtet.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Grade der Eckpunkte, die f√ºr ungerichtete Diagramme (und f√ºr orientierte Diagramme die Anzahl der eingehenden bzw. ausgehenden Kanten) einander entsprechen, sind gleich</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir solche Darstellungen als Ergebnis "kombinieren", erhalten wir eine Entsprechung der Eckpunkte des ersten und zweiten Graphen.</font></font></li>
</ul><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Beispiel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Graph A = {1-&gt; 2, 1-&gt; 6, 4-&gt; 5, 5-&gt; 1, 3-&gt; 3}. </font><font style="vertical-align: inherit;">Graph B = {3-&gt; 4, 3-&gt; 5, 1-&gt; 2, 2-&gt; 3, 6-&gt; 6} </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pfade A ( </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maximale nicht verzweigte Pfade von A</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ): 1-&gt; 2, 1-&gt; 6, 4-&gt; 5-&gt; 1, 3-&gt; 3 </font><i><b><font style="vertical-align: inherit;">Pfade B</font></b></i></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
( </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maximale nicht verzweigte Pfade von B</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ): 3-&gt; 4, 3-&gt; 5, 1-&gt; 2-&gt; 3, 6-&gt; 6 </font><font style="vertical-align: inherit;">Vertex-Matching </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
: 1 ( A): 3 (B), 2 (A): 4 (B), 6 (A): 5 (B), 4 (A): 1 (B), 5 (A): 2 (B), 3 ( A): 6 (B).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit kann das Problem der √úberpr√ºfung des Isomorphismus zweier Graphen gel√∂st werden, indem solche Pfade gefunden werden, die einander entsprechen, und dann die Gleichheit der Adjazenzmatrizen √ºberpr√ºft wird, die auf der Grundlage ihrer Erhaltung der Reihenfolge der Scheitelpunkte in den erhaltenen Pfadsequenzen konstruiert wurden (jeder Scheitelpunkt wird der Sequenz einmal hinzugef√ºgt). erste "Erw√§hnung"). In unserem Beispiel werden die folgenden Scheitelpunktreihenfolgen verwendet, um Adjazenzmatrizen zu erstellen: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 1, 2, 6, 4, 5, 3 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 3, 4, 5, 1, 2, 6 </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adjazenzmatrix f√ºr A f√ºr eine gegebene Reihenfolge von Scheitelpunkten: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/px/ec/cx/pxeccxjhfchxn7rhafe3trgqsyw.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adjazenzmatrix f√ºr B f√ºr eine gegebene Ordnung von Eckpunkten: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nt/b8/_g/ntb8_gc0ap4hojnuzg4ddmrkky8.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Matrizen sind gleich, daher sind die Graphen A und B isomorph.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus ist dieser Ansatz (1) sowohl f√ºr orientierte als auch f√ºr nicht orientierte Graphen anwendbar, (2) er ist f√ºr Graphen anwendbar, die mehr als eine verbundene Komponente / starke Verbindung enthalten, (3) er ist jedoch f√ºr Graphen anwendbar, die mehrere (mehrere) Kanten und Schleifen enthalten (4) ber√ºcksichtigt keine Eckpunkte, f√ºr die keine Kanten auffallen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Nun, √ºberpr√ºfte den Isomorphismus von Graphen. </font><font style="vertical-align: inherit;">Aber was ist mit der Suche nach Untergraphen?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und hier ist offen gesagt alles viel komplizierter. Hier haben wir die folgende Einschr√§nkung: Basierend auf dem Wesen der Methode k√∂nnen Sie keine, sondern nur </font></font><u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"eingeschriebene" Untergraphen finden</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Und </font><font style="vertical-align: inherit;">wir werden den </font></font><u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"eingeschriebenen" Untergraphen von</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Graph A einen solchen Untergraphen nennen, der nur aufgrund von Kanten, die nur auf die Grenzscheitelpunkte seiner (Untergraph) nicht verzweigten Pfade maximaler L√§nge fallen, auf andere Teile von Graph A "geklebt" werden kann (au√üerdem kann Graph A enthalten andere angeschlossene Komponenten). Machen Sie sich keine Sorgen, unten finden Sie ein Beispiel, und alles wird klarer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus ist es bei der L√∂sung dieses Problems zus√§tzlich zur Suche nach der Entsprechung von NB-Pfaden der Graphen A und B in der L√§nge (wie dies beim obigen Isomorphismustest der Fall war) auch erforderlich, die folgenden m√∂glichen Entsprechungen zwischen ihnen separat zu suchen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entsprechung von NB-Pfaden - einfache Ketten von Graph B zu NB-Pfaden - einfache Ketten / einfache Zyklen von Graph A. Au√üerdem k√∂nnen anf√§nglich solche Pfade in Graph A l√§nger sein - in diesem Fall werden ihre Segmente genommen, deren L√§nge dem gew√ºnschten Pfad von B entspricht. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entsprechung der NB- "End" -Pfade von Graph B zu beliebigen NB-Pfaden von Graph A (in diesem Fall k√∂nnen die Pfade von Graph A auch l√§nger sein - in diesem Fall werden ihre Segmente genommen, deren L√§nge dem gew√ºnschten Pfad von Graph B entspricht).</font></font></li>
</ul><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns ein Beispiel an:</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/v7/gl/s8/v7gls8xyi1oef-3jmq-883v4ayw.png" alt="Bild"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Bei der Suche nach einem ‚Äûeingeschriebenen‚Äú isomorphen Teilgraphen von Graph B in Spalte A (siehe Abbildung oben) werden die folgenden Entsprechungen gefunden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">innerer Pfad 2-&gt; 3-&gt; 4 von Spalte B: innerer Pfad 2-&gt; 3-&gt; 4 von Spalte A, </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endpfade 1-&gt; 2 und 10-&gt; 2 von Spalte B: Endpfad 0-&gt; 2 von Spalte A und ein Fragment des Endpfades 7-&gt; 1-&gt; 2 von Spalte A, n√§mlich 1-&gt; 2,</font></font></li>
<li>  7-&gt;8  B:    9-&gt;10-&gt;11  A,   9-&gt;10  10-&gt;11,      12-&gt;13-&gt;14-&gt;12  A,   12-&gt;13, 13-&gt;14,  14-&gt;12.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als die "eingeschriebenen" Untergraphen von Graph A, die zu Graph B isomorph sind, k√∂nnen die folgenden 5 Optionen gefunden werden: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A1 = {0-&gt; 2, 1-&gt; 2, 2-&gt; 3, 3-&gt; 4, 4-&gt; 5, 4-&gt; 6, 9-&gt; 10} </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A2 = {0-&gt; 2, 1-&gt; 2, 2-&gt; 3, 3-&gt; 4, 4-&gt; 5, 4-&gt; 6, 10-&gt; 11} </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A3 = {0-&gt; 2, 1-&gt; 2, 2-&gt; 3, 3-&gt; 4, 4-&gt; 5, 4-&gt; 6, 12-&gt; 13} </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A4 = {0-&gt; 2, 1-&gt; 2, 2 -&gt; 3, 3-&gt; 4, 4-&gt; 5, 4-&gt; 6, 13-&gt; 14} </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A5 = {0-&gt; 2, 1-&gt; 2, 2-&gt; 3, 3-&gt; 4, 4-&gt; 5, 4-&gt; 6, 14-&gt; 12} </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir jedoch dem Graphen A eine zus√§tzliche Kante 3-&gt; 8 hinzuf√ºgen, erhalten wir den Graphen A '(unten in derselben Abbildung). Und in A 'gibt es keine "eingeschriebenen" Untergraphen mehr, die isomorph zum Graphen B sind. In der Tat: Die Kante 3-&gt; 8 "teilt" den Pfad 2-&gt; 3-&gt; 4 des Graphen A in zwei und daher Kandidatenpfade f√ºr den inneren Pfad 2 -&gt;3-&gt; 4 Spalten B werden nicht gefunden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Nun der Algorithmus selbst</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun k√∂nnen wir zu einer detaillierteren Betrachtung des Suchalgorithmus f√ºr die </font><font style="vertical-align: inherit;">in Spalte A </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äûeingeschriebenen‚Äú</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untergraphen </font><i><font style="vertical-align: inherit;">√ºbergehen</font></i><font style="vertical-align: inherit;"> , die zu einer Spalte B isomorph sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Algorithmus besteht also aus 4 Stufen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorverarbeitung</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matching</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verd√ºnnung,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></li>
</ul><br>
<i><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stufe I. Vorverarbeitung </font></font></h3></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu diesem Zeitpunkt finden wir alle NB-Pfade f√ºr jedes der Diagramme und bewerten die Faktoren, die den Auswahlraum w√§hrend der Aufz√§hlung einschr√§nken. </font><font style="vertical-align: inherit;">Jene. </font><font style="vertical-align: inherit;">Wir machen folgendes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir finden alle NB-Pfade in Spalte A und f√ºgen sie in ein dynamisches Array (in C ++ - in einen Vektor) PathsA ein</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir finden alle NB-Pfade in Spalte B und f√ºgen sie in ein dynamisches Array (Vektor) PathsB ein</font></font></li>
<li>        A  B.     II-IV    ,      1.           A-     B      B:    -     ,      B.</li>
<li>      A  B (          ).</li>
<li>          A   B:   DA  DB .</li>
<li>    ‚Äì   B00 ‚Äì   B   ,     ,     .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben also NB-Pfade in beiden Diagrammen und Grenzparameter ab S.P. </font><font style="vertical-align: inherit;">3-5.</font></font><br>
<br>
<i><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stufe II. </font><font style="vertical-align: inherit;">Kartierung</font></font></h3></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Stadium werden wir Kandidaten-NB-Pfade (im Folgenden einfach als "Kandidatenpfade" bezeichnet) aus Spalte A f√ºr jeden der NB-Pfade von Spalte B ausw√§hlen. Markieren jedes Kandidatenpfads aus Pfaden A f√ºr jeden i-ten Pfad Pfade B [i ] wird in ein zweidimensionales dynamisches Array (in C ++ - in einen Vektor von Vektoren) NPaths - bzw. in den i-ten Vektor (i-te Linie) - in Form eines geordneten Dreifaches von Zahlen geschrieben: die Nummer des entsprechenden Pfads in PathsA - die Nummer der Startposition darin - die L√§nge des Pfads . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel bedeutet PathsB [2] = {1, 0, 3, 3, 1, 3}, dass PathsB [2] -Pfade 2 Kandidatenpfaden von A zugeordnet sind: von PathsA [1] - den ersten 3 Pfadelementen beginnend bei Null ( initial) und von PathsA [3] - auch 3 Elemente beginnend mit dem ersten (neben dem initial). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gleichzeitig werden wir Kandidatenpfade in 4 Richtungen suchen (ausw√§hlen):</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suchen Sie nach Kandidatenpfaden f√ºr alle internen NB-Pfade von Graph B aus PathsB, d. H. </font><font style="vertical-align: inherit;">diejenigen, deren beide Grenzscheitelpunkte im Graphen B mit mindestens 2 anderen Scheitelpunkten verbunden sind (unabh√§ngig von der Richtung einer solchen Verbindung) und gleichzeitig ist dieser Pfad kein einfacher Zyklus (orientiert - f√ºr orientierte Graphen).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suchen Sie in PathsB nach Kandidatenpfaden f√ºr nachfolgende NB-Pfade. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suche nach Kandidatenpfaden f√ºr NB-Pfade - einfache Schleifen von PathsB. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suchen Sie nach Kandidatenpfaden f√ºr NB-Pfade - einfache Pfade aus PathsB. </font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Auswahl von Kandidatenpfaden f√ºr jeden i-ten Pfad aus Pfad B werden sie verglichen (hier sind einige der zuvor berechneten Begrenzerparameter n√ºtzlich): </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seine L√§nge und die L√§nge des Kandidatenpfads (sollte f√ºr die F√§lle 1 und 3 gleich sein, und f√ºr die F√§lle 2 und 4 kann der Kandidatenpfad von PathsA auch l√§nger sein),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Grade seiner Grenzscheitelpunkte und die entsprechenden Scheitelpunkte des Kandidatenpfads (f√ºr Scheitelpunkte aus dem Kandidatenpfad m√ºssen diese Werte mindestens der Pfad aus Pfad B sein).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn gem√§√ü den Ergebnissen von Stufe II f√ºr keinen der Pfade in Pfad B ein einziger Kandidatenpfad aus Pfad A gefunden wurde, wird angenommen, dass A keine "eingeschriebenen" Untergraphen enth√§lt, die isomorph zu Spalte B sind.</font></font><br>
<br>
<i><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verd√ºnnung</font></font></h4></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir nun, Grafik A zu ‚Äûquetschen‚Äú. Wir lassen nur die Kanten darin, die in die gefundenen Kandidatenpfade eingegangen sind. </font><font style="vertical-align: inherit;">Wenn gleichzeitig Graph A im Vergleich zu seinem Ausgangszustand mindestens eine Kante verloren hat, kehren wir zu Stufe I ‚ÄûVorverarbeitung‚Äú zur√ºck: Die Grade der Eckpunkte von Graph A und dementsprechend die Liste der Kandidatenpfade k√∂nnen reduziert werden, und dementsprechend kann der Suchraum reduziert werden.</font></font><br>
<br>
<i><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stufe III. </font><font style="vertical-align: inherit;">Ausd√ºnnen der Liste der Kandidatenpfade</font></font></h2></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Zweck dieses Schritts besteht darin, so viele Kandidaten wie m√∂glich unangemessen zu eliminieren. </font><font style="vertical-align: inherit;">Dazu f√ºhren wir folgende Schritte aus.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Ausschluss offensichtlich unangemessener Kandidatenpfade basierend auf den Mindestabst√§nden zwischen den Eckpunkten in Spalte B. Der Kandidatenpfad f√ºr jeden Pfad B [i], f√ºr den mindestens ein Pfad B [j] kein Kandidatenpfad f√ºr den k√ºrzesten gefunden wurde Der Abstand zwischen ihren Grenzscheitelpunkten in Spalte A war kleiner oder gleich dem k√ºrzesten Abstand zwischen den entsprechenden Grenzscheitelpunkten der Pfade Pfade B [i] und Pfade B [j] aus Graph B.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine Ausnahme f√ºr alle Zyklen von PathsB zu damit verbundenen nichtzyklischen Kandidatenpfaden und umgekehrt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Ausnahme von Kandidatenpfaden √§hnlich Abschnitt 1, jedoch nicht nach dem Kriterium des k√ºrzesten Abstands zwischen Grenzscheitelpunkten, sondern nach ihren (Grenzscheitelpunkten) zur gegenseitigen Gleichheit oder Ungleichheit. </font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel, wenn: </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Startelement von PathsB [i] ist nicht gleich dem Startelement von PathsB [j] und</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das letzte Element von PathsB [i] ist nicht gleich dem letzten Element von PathsB [j] und</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Startelement von PathsB [i] ist gleich dem Endelement von PathsB [j] und</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Startelement von PathsB [j] ist nicht gleich dem Endelement von PathsB [i], </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
der Kandidatenpfad entlang des Pfades B [i], f√ºr den mindestens ein Pfad B [j] keine Kandidatenpfade gefunden hat, die die obige Bedingung hinsichtlich der Gleichheit / Ungleichheit ihrer (Kandidatenpfade) Anfang und Ende erf√ºllen Spitzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das hei√üt, wir werfen grob gesagt die Kandidatenpfade weg, die offensichtlich nicht in den gew√ºnschten Untergraphen enthalten sind - basierend auf der Entfernung zu allen anderen Kandidatenpfaden (diese Pfade sind schrecklich weit von allen anderen entfernt), basierend auf ihrer Zyklizit√§t / Nichtzyklizit√§t und auch basierend auf der gebotenen Gleichheit / Ungleichheit ihrer Grenzscheitelpunkte mit Grenzscheitelpunkten anderer Kandidatenpfade.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn gem√§√ü den Ergebnissen der Stufe III mindestens 1 Kandidatenpfad aus Pfad A gel√∂scht wurde, wird - wieder - Spalte A aktualisiert - nur die Kanten, die in den verbleibenden Kandidatenpfaden enthalten sind, verbleiben darin. </font><font style="vertical-align: inherit;">Und wieder, wenn gleichzeitig Graph A um mindestens eine Kante ‚Äûan Gewicht verloren‚Äú hat, kehren wir wieder zu Stufe I ‚ÄûVorverarbeitung‚Äú zur√ºck: Die Grade der Eckpunkte von Graph A und dementsprechend die Liste der Kandidatenpfade k√∂nnen reduziert und dementsprechend reduziert werden Suchraum.</font></font><br>
<br>
<i><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stufe IV. </font><font style="vertical-align: inherit;">Fazit</font></font></h2></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jede m√∂gliche Kombination aller verbleibenden Kandidatenpfade definiert einen Teilgraphen der Spalte A. F√ºr jeden solchen Teilgraphen wird eine Adjazenzmatrix unter Ber√ºcksichtigung der Reihenfolge der Kandidatenpfade auf die gleiche Weise konstruiert, wie die Adjazenzmatrix B00 f√ºr Graph B konstruiert wurde, und dann werden diese Adjazenzmatrizen verglichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn sie gleich sind, werden die Multiplizit√§ten der Kanten verglichen (siehe Abschnitt 3 der Vorverarbeitung der Stufe I). </font><font style="vertical-align: inherit;">Wenn alle diese Bedingungen erf√ºllt sind, wird der gefundene Teilgraph als isomorph zu Graph B betrachtet und zu der Menge der gefundenen Ergebnisse hinzugef√ºgt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
W√§hrend der Stufe IV ‚ÄûSchlussfolgerung‚Äú k√∂nnen verschiedene zus√§tzliche √úberpr√ºfungen verwendet werden, um die Identifizierung und Ablehnung eines unangemessenen Teilgraphen zu beschleunigen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Wie alles verwirrt ist ... Betrachten Sie ein Beispiel des Algorithmus</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich wei√ü nichts √ºber dich, aber es w√§re f√ºr mich ohne ein Beispiel unverst√§ndlich. Schauen wir uns ein Beispiel an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Abb. Die folgenden Diagramme sind A = {1-&gt; 2, 2-&gt; 5, 5-&gt; 15, 16-&gt; 15, 5-&gt; 5, 5-&gt; 5, 5-&gt; 4, 5-&gt; 6, 7-&gt; 6 , 6-&gt; 8, 6-&gt; 6, 6-&gt; 9, 9-&gt; 10, 9-&gt; 11, 12-&gt; 0, 0-&gt; 12, 4-&gt; 13, 13-&gt; 14, 14-&gt; 4 } und B = {1-&gt; 1, 4-&gt; 5, 5-&gt; 1, 1-&gt; 3, 3-&gt; 3, 3-&gt; 2, 2-&gt; 7, 2-&gt; 8, 9-&gt; 10, 10-&gt; 9, 1-&gt; 6, 6-&gt; 11, 11-&gt; 12, 12-&gt; 6}. Unsere Aufgabe ist es, in Grafik A alle zu Grafik B isomorphen ‚Äûeingeschriebenen‚Äú Untergraphen zu finden. Das Ergebnis ist auch in der Abbildung dargestellt: Die gefundenen Eckpunkte und Kanten von Grafik A sind durch eine dicke Linie hervorgehoben, und die Nummern der entsprechenden Eckpunkte von Grafik B sind in Klammern angegeben (wenn mehrere Optionen vorhanden sind, werden sie durch angezeigt Fraktion). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/kj/w2/j8/kjw2j8ez-w-qiljh_rbzbki_xys.png" alt="Bild"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie das Suchproblem in Spalte A der "eingeschriebenen" Untergraphen l√∂sen, die isomorph zu Spalte B sind,Wir haben die folgenden Ergebnisse des Algorithmus. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stufe I.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Alle Aktionen und Berechnungen wurden gem√§√ü p.p. In den Schritten 1 bis 5 dieses Schritts sind die resultierenden Pfade A und Pfade B aufgef√ºhrt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pfade A: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1-&gt; 2-&gt; 5 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4-&gt; 13-&gt; 14 4 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5-&gt; 4 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5-&gt; 5 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5-&gt; 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5-&gt; 15 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6-&gt; 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6-&gt; 8 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6-&gt; 9 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7-&gt; 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9 -&gt; 10 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9-&gt; 11 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16-&gt; 15 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0-&gt; 12-&gt; 0 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pfade B: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1-&gt; 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1-&gt; 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1-&gt; 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2-&gt; 7 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2-&gt; 8 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3-&gt; 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3-&gt; 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4- &gt; 5-&gt; 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6-&gt; 11-&gt; 12-&gt; 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9-&gt; 10-&gt; 9 </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stufen II-III</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Der Vergleich zeigte, dass es f√ºr jeden Pfad von PathsA mindestens einen Kandidatenpfad von PathsB gibt und PathsA durch die Ergebnisse der vorl√§ufigen Ausd√ºnnung verk√ºrzt wurde. Im Stadium der Hauptverd√ºnnung (III) trat keine weitere Reduktion von PathsA auf. Infolgedessen hatten die Pfade A und Pfade B die Form: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pfade A: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1-&gt; 2-&gt; 5 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4-&gt; 13-&gt; 14-&gt; 4 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5-&gt; 4 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5-&gt; 5 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5-&gt; 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6-&gt; 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6-&gt; 9 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9-&gt; 10 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9-&gt; 11 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0-&gt; 12-&gt; 0 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pfade B: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1-&gt; 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1-&gt; 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1-&gt; 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2-&gt; 7 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2-&gt; 8 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3-&gt; 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3-&gt; 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4-&gt; 5-&gt; 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6 -&gt; 11-&gt; 12-&gt; 6 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9-&gt; 10-&gt;9 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der endg√ºltige Vergleich der NPaths lautet: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NPaths:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 0: 3 0 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 1: 4 0 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 2: 2 0 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 3: 7 0 2 8 0 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 4: 7 0 2 8 0 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 5: 6 0 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 6: 5 0 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 7: 0 0 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 8: 1 0 4 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
i = 9: 9 0 3 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist die Zeit, um sich daran zu erinnern, dass jedes geordnete Triplett von Zahlen in NPaths [i] den entsprechenden PathsB [i] -Kandidatenpfad definiert von A im Format: die Nummer des entsprechenden Pfades von PathsA - die Startposition des Segments von diesem Pfad - die L√§nge des Segments. Somit ist es leicht zu √ºberpr√ºfen, ob die Pfade B [0] = {1-&gt; 1} (i = 0: 3 0 2) dem einzigen Pfad von A entsprechen, n√§mlich dem Segment von Pfaden A [3], beginnend von Anfang an und mit einer L√§nge von 2. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stufe IV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Als Ergebnis wurde in Spalte A ein eindeutiger Teilgraph A1 gefunden, der isomorph zu B ist. A1 = {0-&gt; 12, 1-&gt; 2, 2-&gt; 5, 4-&gt; 13, 5-&gt; 4, 5-&gt; 5, 5- &gt; 6, 6-&gt; 6, 6-&gt; 9, 9-&gt; 10, 9-&gt; 11, 12-&gt; 0, 13-&gt; 14, 14-&gt; 4}.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Was kommt als n√§chstes?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und dann ist das im Prinzip alles. </font><font style="vertical-align: inherit;">Obwohl nicht ganz: Der Autor muss zugeben, dass der Algorithmus noch finalisiert und finalisiert werden kann. </font><font style="vertical-align: inherit;">Was gibt es hinzuzuf√ºgen?</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn zus√§tzliche Merkmale der Eckpunkte der Spalten A und B eingef√ºhrt werden (wenn beispielsweise die Verbindungen durch die Graphen chemischer Verbindungen gegeben sind, kann jedem Scheitelpunkt ein numerischer Code zugeordnet werden, der nur einem Atom (Isotop) entspricht), kann der Suchprozess aufgrund der h√∂heren Genauigkeit der Vergleiche gem√§√ü Stufe II beschleunigt werden: zus√§tzlich Die Bedingung f√ºr die Auswahl von Kandidatenpfaden ist die Entsprechung von Scheitelpunktbezeichnungen.</font></font></li>
<li>               .     ,   ¬´¬ª, ¬´¬ª     - B. </li>
<li>   ,         ,   , <b>¬´¬ª  </b>    : <br>
 (1)   ¬´¬ª ,  , <br>
 (2)     . <br>
 ¬´¬ª   ¬´ - ¬ª,         ,        ,       . </li>
<li> ,  -         <i><b>  </b></i>,     <i><b>   </b></i>    . </li>
</ol><br>
<h2></h2><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allgemein zu den Problemen:</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
1. Bonnici, V., Giugno, R., Pulvirenti, A. et al. Ein Subgraph-Isomorphismus-Algorithmus und seine Anwendung auf biochemische Daten. BMC Bioinformatics 14, S13 (2013). </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doi.org/10.1186/1471-2105-14-S7-S13</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Cordella L, Foggia P, Sansone C, Vento M: Ein (Sub-) Graph-Isomorphismus-Algorithmus zum Anpassen gro√üer Graphen. IEEE-Transaktionen zur Musteranalyse und Maschinenintelligenz. 2004, 26 (10): 1367 &amp; ndash; 1372. 10.1109 / TPAMI.2004.75. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. Ullmann Julian R .: Ein Algorithmus f√ºr den Subgraph-Isomorphismus. Zeitschrift der Association for Computing Machinery. 1976, 23: 31 &amp; ndash; 42. 10.1145 / 321921.321925. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4. Ullmann Julian R .: Bitvektoralgorithmen f√ºr die Erf√ºllung bin√§rer Bedingungen und den Subgraph-Isomorphismus. J Exp-Algorithmen. 2011, 15 (1,6): 1,1-1,6. 1,64</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der in einer offizielleren Sprache verfasste Preprint des Autors ist der am meisten auf NB-Pfaden basierende Algorithmus, der auch Informationen √ºber einen Versuch enth√§lt, ihn in C ++ zu implementieren:</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
5. Chernoukhov SA </font><font style="vertical-align: inherit;">2020. Preprints.RU. </font><font style="vertical-align: inherit;">√úberpr√ºfung des Isomorphismus zweier Graphen und Suche nach isomorphen "eingeschriebenen" Teilgraphen: Ein Ansatz, der auf der Analyse maximal erweiterter nicht verzweigter Pfade basiert, um das Problem des (Sub-) Graphenisomorphismus zu l√∂sen. </font><font style="vertical-align: inherit;">DOI: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx.doi.org/10.24108/preprints-3111977 </font></font></a><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√ºtzliche Internetquellen zum Thema:</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
6. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coderoad.ru/17480142/Is-li- einfaches Beispiel f√ºr Erkl√§rungsalgorithmus-Ulman</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
7. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">issue.life/questions / 8176298</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de491828/index.html">DataMatrix oder wie man Schuhe richtig etikettiert</a></li>
<li><a href="../de491832/index.html">8 Pluspunkte von Flutter im Vergleich zu React Native</a></li>
<li><a href="../de491838/index.html">MIPT startet einen offenen Online-Kurs zum Thema Sportprogrammierung</a></li>
<li><a href="../de491840/index.html">Visualisierung der Arbeit von Servicemitarbeitern</a></li>
<li><a href="../de491844/index.html">Automatische Visualisierung der Testabdeckung</a></li>
<li><a href="../de491848/index.html">Redux Toolkit wird nicht mehr ben√∂tigt?</a></li>
<li><a href="../de491852/index.html">Flask-DJ: Django (mvc) Struktur f√ºr ein Projekt auf Flask</a></li>
<li><a href="../de491854/index.html">Unternehmenstelefone f√ºr jeweils 31.000 Mitarbeiter</a></li>
<li><a href="../de491856/index.html">LinkedIn f√ºr Studenten und Absolventen: Erste Schritte</a></li>
<li><a href="../de491858/index.html">Versp√§teter Kater 8. M√§rz: Ein weiterer Artikel √ºber Habr√© √ºber Frauen in der IT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>