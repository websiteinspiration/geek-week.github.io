<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍⚕️ 👩🏾‍🤝‍👨🏽 🖇️ PEP 572 (Assignment Expressions in python 3.8) 🀄️ 🚎 ⛱️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr. This time we will look at PEP 572, which talks about assignment expressions. If you are still skeptical of the ": =" operator or do not f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PEP 572 (Assignment Expressions in python 3.8)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499666/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello, Habr. </font><font style="vertical-align: inherit;">This time we will look at PEP 572, which talks about assignment expressions. </font><font style="vertical-align: inherit;">If you are still skeptical of the ": =" operator or do not fully understand the rules for its use, then this article is for you. </font><font style="vertical-align: inherit;">Here you will find many examples and answers to the question: “Why is this so?” </font><font style="vertical-align: inherit;">This article turned out to be as complete as possible, and if you have little time, then look at the section I wrote. </font><font style="vertical-align: inherit;">At its beginning, the main “theses” are collected for comfortable work with assignment expressions. </font><font style="vertical-align: inherit;">Forgive me in advance if you find errors (write about them to me, I will fix it). </font><font style="vertical-align: inherit;">Let's start:</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PEP 572 - Assignment Expressions</font></font></h2><div class="scrollable-table"><table>
<tbody><tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pep</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">572</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Title:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assignment Expressions</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Authors:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris Angelico &lt;rosuav at gmail.com&gt;, Tim Peters &lt;tim.peters at gmail.com&gt;, Guido van Rossum &lt;guido at python.org&gt;</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discussion:</font></font></b></td>
<td><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doc-sig at python.org</font></font></a></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accepted</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A type:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Created:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28-Feb-2018</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python version:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.8</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Post story:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28-Feb-2018, 02-Mar-2018, 23-Mar-2018, 04-Apr-2018, 17-Apr-2018, 25-Apr-2018, 09-Jul-2018, 05-Aug-2019</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Permission to adopt the standard:</font></font></b></td>
<td><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mail.python.org/pipermail/python-dev/2018-July/154601.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (with VPN for a long time, but it loads)</font></font></td>
</tr>
</tbody></table></div><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Content</font></font></b><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">annotation</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Justification</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntax and semantics</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Specification changes during implementation</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examples</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rejected Alternatives</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frequent objections</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Style Recommendations</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appendix A: Tim Peters Conclusions</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appendix B: A Rough Code Interpreter for Generators</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appendix C: No Changes in Scope Semantics</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">References</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Copyright</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">My part</font></font></a></li>
</ul><br>
<a name="ann"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">annotation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This convention will talk about the possibility of assignment inside expressions, using the new notation NAME: = expr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As part of the innovations, the procedure for calculating dictionary generators (dictionary comprehension) has been updated. This ensures that the key expression is evaluated before the value expression (this allows you to bind the key to a variable and then reuse the created variable in the calculation of the value corresponding to the key). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
During a discussion of this PEP, this operator became unofficially known as the walrus operator. The formal name of the construct is “Assignment Expression” (according to the PEP: Assignment Expressions heading), but it may be referred to as “Named Expressions”. For example, the reference implementation in CPython uses this very name.</font></font><br>
<br>
<a name="oboc"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Justification</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Naming is an important part of programming that allows you to use a “descriptive” name instead of a longer expression, and also makes it easy to reuse values. </font><font style="vertical-align: inherit;">Currently, this can only be done in the form of instructions, which makes this operation unavailable when generating lists (list comprehension), as well as in other expressions.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, naming parts of a large expression can help with interactive debugging by providing tools for displaying prompts and intermediate results. </font><font style="vertical-align: inherit;">Without the ability to capture the results of nested expressions, you need to change the source code, but using the assignment expressions you just need to insert a few "markers" of the form "name: = expression". </font><font style="vertical-align: inherit;">This eliminates unnecessary refactoring, and therefore reduces the likelihood of unintentional code changes during debugging (a common cause of Heisenbugs is errors that change the properties of the code during debugging and may unexpectedly appear in production]), and this code will be more understandable to another to the programmer.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Importance of Real Code</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
During the development of this PEP, many people (both proponents and critics) were too focused on toy examples on the one hand, and overly complex examples on the other. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The danger of toy examples is twofold: they are often too abstract to make someone say “oh, this is irresistible”, and they are also easily rejected with the words “I would never write that”. The danger of overly complex examples is that they provide a convenient environment for critics suggesting that this functionality be removed (“This is too confusing,” such people say). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, there is good use for such examples: they help clarify the intended semantics. Therefore, we will give some of them below. However, to be </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convincing</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , examples must be based on</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">real</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> code that was written without thinking about this PEP. That is, the code that is part of a really useful application (no difference: whether it’s big or small). Tim Peters helped us a lot by looking at his personal repositories and choosing examples of the code he wrote, which (in his opinion) would be more understandable if they were rewritten (without fanaticism) using assignment expressions. His conclusion is this: the current changes would bring a modest but obvious improvement in a few bits of his code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another example of real code is the indirect observation of how programmers value compactness. Guido van Rossum checked the Dropbox codebase and found some evidence that programmers prefer to write fewer lines of code than using a few small expressions.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Case in point: Guido found several illustrative points when a programmer repeats a subexpression (thereby slowing down the program), but saves an extra line of code. </font><font style="vertical-align: inherit;">For example, instead of writing:</font></font><br>
<br>
<pre><code class="python hljs">match = re.match(data)<font></font>
group = match.group(<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> match <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Programmers preferred this option:</font></font><br>
<br>
<pre><code class="python hljs">group = re.match(data).group(<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> re.match(data) <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is another example showing that programmers are sometimes willing to do more work to maintain the “previous level” of indentation:</font></font><br>
<br>
<pre><code class="python hljs">match1 = pattern1.match(data)<font></font>
match2 = pattern2.match(data)<font></font>
<span class="hljs-keyword">if</span> match1:<font></font>
    result = match1.group(<span class="hljs-number">1</span>)
<span class="hljs-keyword">elif</span> match2:<font></font>
    result = match2.group(<span class="hljs-number">2</span>)
<span class="hljs-keyword">else</span>:<font></font>
    result = <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This code computes pattern2, even if pattern1 already matches (in this case, the second sub-condition will never be fulfilled). </font><font style="vertical-align: inherit;">Therefore, the following solution is more effective, but less attractive:</font></font><br>
<br>
<pre><code class="python hljs">match1 = pattern1.match(data)
<span class="hljs-keyword">if</span> match1:<font></font>
    result = match1.group(<span class="hljs-number">1</span>)
<span class="hljs-keyword">else</span>:<font></font>
    match2 = pattern2.match(data)<font></font>
    <span class="hljs-keyword">if</span> match2:<font></font>
        result = match2.group(<span class="hljs-number">2</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        result = <span class="hljs-literal">None</span></code></pre><br>
<a name="sint"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntax and semantics</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In most cases where Python uses arbitrary expressions, you can now use assignment expressions. </font><font style="vertical-align: inherit;">They have the form NAME: = expr, where expr is any valid Python expression, except for the unparenthesized tuple, and NAME is the identifier. </font><font style="vertical-align: inherit;">The value of such an expression coincides with the original, but an additional effect is the assignment of a value to the target object:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Handle a matched regex</span>
<span class="hljs-keyword">if</span> (match := pattern.search(data)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
    <span class="hljs-comment"># Do something with match</span><font></font>
<font></font>
<span class="hljs-comment"># A loop that can't be trivially rewritten using 2-arg iter()</span>
<span class="hljs-keyword">while</span> chunk := file.read(<span class="hljs-number">8192</span>):<font></font>
   process(chunk)<font></font>
<font></font>
<span class="hljs-comment"># Reuse a value that's expensive to compute</span>
[y := f(x), y**<span class="hljs-number">2</span>, y**<span class="hljs-number">3</span>]<font></font>
<font></font>
<span class="hljs-comment"># Share a subexpression between a comprehension filter clause and its output</span>
filtered_data = [y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data <span class="hljs-keyword">if</span> (y := f(x)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>]</code></pre><br>
<a name="iskluch"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exceptional Cases</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are several places where assignment expressions are not allowed in order to avoid ambiguity or confusion among users:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assignment expressions not enclosed in parentheses are prohibited at the “upper” level:</font></font><br>
<br>
<pre><code class="python hljs">y := f(x)  <span class="hljs-comment"># </span>
(y := f(x))  <span class="hljs-comment"># ,   </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This rule will make it easier for the programmer to choose between an assignment operator and an assignment expression - there will be no syntactic situation in which both options are equivalent.</font></font></li>
<li>           . :<br>
<br>
<pre><code class="python hljs">y0 = y1 := f(x)  <span class="hljs-comment"># </span>
y0 = (y1 := f(x))  <span class="hljs-comment"># ,   </span></code></pre><br>
             . :<br>
<br>
<pre><code class="python hljs">foo(x = y := f(x))  <span class="hljs-comment"># </span>
foo(x=(y := f(x)))  <span class="hljs-comment"># ,     </span></code></pre><br>
 ,               .</li>
<li>           . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer = p := <span class="hljs-number">42</span></span>):</span>  <span class="hljs-comment"># </span><font></font>
    ...<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer=(<span class="hljs-params">p := <span class="hljs-number">42</span></span>)</span>):</span>  <span class="hljs-comment"># Valid, though not great style</span>
    ...</code></pre><br>
        ,           (.    ,     «»     ).</li>
<li>           ,    . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer: p := <span class="hljs-number">42</span> = <span class="hljs-number">5</span></span>):</span>  <span class="hljs-comment"># </span><font></font>
    ...<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer: (<span class="hljs-params">p := <span class="hljs-number">42</span></span>) = <span class="hljs-number">5</span></span>):</span>  <span class="hljs-comment"># ,  </span>
    ...</code></pre><br>
       : ,     "="  ":="   .</li>
<li>        -. :<br>
<br>
<pre><code class="python hljs">(<span class="hljs-keyword">lambda</span>: x := <span class="hljs-number">1</span>) <span class="hljs-comment"># </span>
<span class="hljs-keyword">lambda</span>: (x := <span class="hljs-number">1</span>) <span class="hljs-comment"># ,  </span>
(x := <span class="hljs-keyword">lambda</span>: <span class="hljs-number">1</span>) <span class="hljs-comment"># </span>
<span class="hljs-keyword">lambda</span> line: (m := re.match(pattern, line)) <span class="hljs-keyword">and</span> m.group(<span class="hljs-number">1</span>) <span class="hljs-comment"># Valid</span></code></pre><br>
-    ,  ":=".       .  ,     ,    ()  ,         .</li>
<li>   f-  . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f'<span class="hljs-subst">{(x:=<span class="hljs-number">10</span>)}</span>'</span>  <span class="hljs-comment"># ,  </span>
<span class="hljs-string">'10'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>x = <span class="hljs-number">10</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f'<span class="hljs-subst">{x:=<span class="hljs-number">10</span>}</span>'</span>    <span class="hljs-comment"># ,  ,  '=10'</span>
<span class="hljs-string">'        10'</span></code></pre><br>
 ,    ,     f-,  .  f-   ":"    .    ,      f-      .     ,      .</li>
</ul><br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An assignment expression does not introduce a new scope. In most cases, the scope in which the variable will be created does not require explanation: it will be current. If the variable used the nonlocal or global keywords before, then the assignment expression will take this into account. Only lambda (being an anonymous definition of a function) is considered a separate scope for these purposes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is one special case: an assignment expression that occurs in generators of lists, sets, dictionaries, or in the “expressions of generators” themselves (hereinafter collectively referred to as “generators” (comprehensions)) binds the variable to the scope that the generator contains, observing the globab modifier or nonglobal, if one exists.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The rationale for this special case is twofold. </font><font style="vertical-align: inherit;">Firstly, it allows us to conveniently capture the “member” in the expressions any () and all (), for example:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> any((comment := line).startswith(<span class="hljs-string">'#'</span>) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"First comment:"</span>, comment)
<span class="hljs-keyword">else</span>:<font></font>
    print(<span class="hljs-string">"There are no comments"</span>)<font></font>
<font></font>
<span class="hljs-keyword">if</span> all((nonblank := line).strip() == <span class="hljs-string">''</span> <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"All lines are blank"</span>)
<span class="hljs-keyword">else</span>:<font></font>
    print(<span class="hljs-string">"First non-blank line:"</span>, nonblank)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secondly, it provides a compact way to update a variable from a generator, for example:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Compute partial sums in a list comprehension</span>
total = <span class="hljs-number">0</span>
partial_sums = [total := total + v <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> values]<font></font>
print(<span class="hljs-string">"Total:"</span>, total)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, the name of the variable from the assignment expression cannot match the name already used in generators by the for loop to iterate. </font><font style="vertical-align: inherit;">The last names are local to the generator in which they appear. </font><font style="vertical-align: inherit;">It would be inconsistent if the assignment expressions also referred to the scope within the generator. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, [i: = i + 1 for i in range (5)] is not valid: the for loop determines that i is local to the generator, but the “i: = i + 1” part insists that i is a variable from the external scope </font><font style="vertical-align: inherit;">For the same reason, the following examples will not work:</font></font><br>
<br>
<pre><code class="python hljs">
[[(j := j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># </span>
[i := <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff]                       <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (i := stuff)]                      <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although it is technically possible to assign consistent semantics for such cases, it’s difficult to determine if the way we understand this semantics will work in your real code. That is why the reference implementation ensures that such cases raise SyntaxError, rather than being executed with undefined behavior, depending on the particular hardware implementation. This restriction applies even if an assignment expression is never executed:</font></font><br>
<br>
<pre><code class="python hljs">[<span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> (i := <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff]     <span class="hljs-comment"># </span>
[i <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff <span class="hljs-keyword">if</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> (j := <span class="hljs-number">1</span>)]  <span class="hljs-comment"># </span><font></font>
<font></font>
<span class="hljs-comment"># [.  . - ""   </span>
<span class="hljs-comment"># ,       </span>
<span class="hljs-comment"># ,    ,   ]</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the generator body (the part before the first keyword “for”) and the filter expression (the part after the “if” and before any nested “for”) this restriction applies exclusively to variable names that are simultaneously used as iterative variables. As we have already said, Lambda expressions introduce a new explicit scope of the function and therefore can be used in expressions of generators without additional restrictions. [approx. again, except in such cases: [i for i in range (2, (lambda: (s: = 2) ()))]]</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Due to design limitations in the reference implementation (the symbol table analyzer cannot recognize whether the names from the left part of the generator are used in the remaining part where the iterable expression is located), therefore assignment expressions are completely forbidden as part of iterable (in the part after each “in” and before any subsequent keyword “if” or “for”). </font><font style="vertical-align: inherit;">That is, all these cases are unacceptable:</font></font><br>
<br>
<pre><code class="python hljs">[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (j := stuff)]                    <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> (k := stuff)]  <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [j <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> (k := stuff)]]       <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-keyword">lambda</span>: (j := stuff))()]        <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another exception occurs when an assignment expression is used in generators that are in the scope of a class. </font><font style="vertical-align: inherit;">If, when using the above rules, the creation of a class remeasured in the scope should occur, then such an assignment expression is invalid and will result in a SyntaxError:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span>:</span>
    [(j := i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]  <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(The reason for the last exception is the implicit scope of the function created by the generator - there is currently no runtime mechanism for functions to refer to a variable located in the scope of the class, and we don’t want to add such a mechanism. If this problem is ever solved, then this special case (possibly) will be removed from the specification of assignment expressions.Note that this problem will occur even if you created a variable earlier in the scope of the class and try to change it with an assignment expression from the generator.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
See Appendix B for examples of how assignment expressions found in generators are converted to equivalent code.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relative Priority: =</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The: = operator is grouped stronger than the comma in all syntactic positions where possible, but weaker than all other operators, including or, and, not, and conditional expressions (A if C else B). As follows from the “Exceptional Cases” section above, assignment expressions never work at the same “level” as the classic assignment =. If a different order of operations is required, use parentheses. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The operator: = can be used directly when calling the positional argument of a function. However, this will not work directly in the argument. Some examples clarifying what is technically permitted and what is not possible:</font></font><br>
<br>
<pre><code class="python hljs">x := <span class="hljs-number">0</span> <span class="hljs-comment"># </span><font></font>
<font></font>
(x := <span class="hljs-number">0</span>) <span class="hljs-comment">#  </span><font></font>
<font></font>
x = y := <span class="hljs-number">0</span> <span class="hljs-comment"># </span><font></font>
<font></font>
x = (y := <span class="hljs-number">0</span>) <span class="hljs-comment">#  </span><font></font>
<font></font>
len(lines := f.readlines()) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(x := <span class="hljs-number">3</span>, cat=<span class="hljs-string">'vector'</span>) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(cat=category := <span class="hljs-string">'vector'</span>) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(cat=(category := <span class="hljs-string">'vector'</span>)) <span class="hljs-comment">#  </span></code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Most of the above "valid" examples are not recommended for use in practice, as people who quickly scan your source code may not correctly understand its meaning. </font><font style="vertical-align: inherit;">But in simple cases this is allowed:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Valid</span>
<span class="hljs-keyword">if</span> any(len(longline := line) &gt;= <span class="hljs-number">100</span> <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"Extremely long line:"</span>, longline)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This PEP recommends that you </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">absolutely always</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> put spaces around: =, similar to the PEP 8 recommendation for = for classic assignment. </font><font style="vertical-align: inherit;">(The last recommendation is different in that it forbids spaces around =, which is used to pass key arguments to the function.)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Change the order of calculations.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to have well-defined semantics, this agreement requires that the evaluation procedure be clearly defined. </font><font style="vertical-align: inherit;">Technically, this is not a new requirement. </font><font style="vertical-align: inherit;">Python already has a rule that subexpressions are usually evaluated from left to right. </font><font style="vertical-align: inherit;">However, assignment expressions make these “side effects” more noticeable, and we propose one change in the current calculation order:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dictionary generators {X: Y for ...}, Y is currently evaluated before X. We suggest changing this so that X is calculated before Y. (In a classic dict such as {X: Y}, as well as in dict ((X, Y) for ...) this has already been implemented. Therefore, dictionary generators must comply with this mechanism)</font></font></li>
</ul><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Differences between assignment expressions and assignment instructions.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Most importantly, ": =" is an </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expression</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which means it can be used in cases where </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instructions are</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> not valid, including lambda functions and generators. </font><font style="vertical-align: inherit;">Conversely, </font><font style="vertical-align: inherit;">assignment </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expressions</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do not support the extended functionality that can be used in </font><font style="vertical-align: inherit;">assignment </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instructions</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cascading assignment is not supported directly</font></font><br>
<br>
<pre><code class="python hljs">x = y = z = <span class="hljs-number">0</span>  <span class="hljs-comment"># Equivalent: (z := (y := (x := 0)))</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separate "targets", except for the simple variable name NAME, are not supported:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># No equivalent</span><font></font>
a[i] = x<font></font>
self.rest = []</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Functionality and priority “around” commas differs:</font></font><br>
<br>
<pre><code class="python hljs">x = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>  <span class="hljs-comment"># Sets x to (1, 2)</span>
(x := <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># Sets x to 1</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unpacking and packing values ​​do not have “pure” equivalence or are not supported at all</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Equivalent needs extra parentheses</span>
loc = x, y  <span class="hljs-comment"># Use (loc := (x, y))</span>
info = name, phone, *rest  <span class="hljs-comment"># Use (info := (name, phone, *rest))</span><font></font>
<font></font>
<span class="hljs-comment"># No equivalent</span><font></font>
px, py, pz = position<font></font>
name, phone, email, *other_info = contact</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inline type annotations are not supported:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Closest equivalent is "p: Optional[int]" as a separate declaration</span>
p: Optional[int] = <span class="hljs-literal">None</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no shortened form of operations:</font></font><br>
<br>
<pre><code class="python hljs">total += tax  <span class="hljs-comment"># Equivalent: (total := total + tax)</span></code></pre></li>
</ul><br>
<a name="cpec"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Specification changes during implementation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The following changes were made based on our experience and additional analysis after the first writing of this PEP and before the release of Python 3.8:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To ensure consistency with other similar exceptions, and not to introduce a new name that may not be convenient for end users, the originally proposed subclass of TargetScopeError for SyntaxError has been removed and reduced to the usual SyntaxError. </font><font style="vertical-align: inherit;">[3]</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Due to limitations in parsing the CPython character table, the reference implementation of the assignment expression raises a SyntaxError for all uses within iterators. </font><font style="vertical-align: inherit;">Previously, this exception occurred only if the name of the variable being created coincided with that already used in the iterative expression. </font><font style="vertical-align: inherit;">This can be revised if there are sufficiently convincing examples, but the additional complexity seems inappropriate for purely “hypothetical” use cases.</font></font></li>
</ul><br>
<a name="prim"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examples</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python Standard Library Examples</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">site.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
env_base is used only in a condition, so the assignment can be placed in if, as the "header" of a logical block.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Current Code:</font></font><br>
<pre><code class="python hljs">env_base = os.environ.get(<span class="hljs-string">"PYTHONUSERBASE"</span>, <span class="hljs-literal">None</span>)
<span class="hljs-keyword">if</span> env_base:
    <span class="hljs-keyword">return</span> env_base</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Improved code:</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> env_base := os.environ.get(<span class="hljs-string">"PYTHONUSERBASE"</span>, <span class="hljs-literal">None</span>):
    <span class="hljs-keyword">return</span> env_base</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_pydecimal.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can avoid nested ifs, thereby removing one level of indentation.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Current Code:</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> self._is_special:<font></font>
    ans = self._check_nans(context=context)<font></font>
    <span class="hljs-keyword">if</span> ans:
        <span class="hljs-keyword">return</span> ans</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Improved code:</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> self._is_special <span class="hljs-keyword">and</span> (ans := self._check_nans(context=context)):
    <span class="hljs-keyword">return</span> ans</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copy.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The code looks more classic, and also avoids the multiple nesting of conditional statements. </font><font style="vertical-align: inherit;">(See Appendix A to learn more about the origin of this example.)</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Current Code:</font></font><br>
<pre><code class="python hljs">reductor = dispatch_table.get(cls)
<span class="hljs-keyword">if</span> reductor:<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">else</span>:<font></font>
    reductor = getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>)
    <span class="hljs-keyword">if</span> reductor:<font></font>
        rv = reductor(<span class="hljs-number">4</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        reductor = getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> reductor:<font></font>
            rv = reductor()<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Error(
                <span class="hljs-string">"un(deep)copyable object of type %s"</span> % cls)</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Improved code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> reductor := dispatch_table.get(cls):<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor(<span class="hljs-number">4</span>)
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor()<font></font>
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(deep)copyable object of type %s"</span> % cls)</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datetime.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tz is used only for s + = tz. </font><font style="vertical-align: inherit;">Moving it inward if helps to show its logical area of ​​use.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Current Code:</font></font><br>
<br>
<pre><code class="python hljs">s = _format_time(self._hour, self._minute,<font></font>
                 self._second, self._microsecond,<font></font>
                 timespec)<font></font>
tz = self._tzstr()<font></font>
<span class="hljs-keyword">if</span> tz:<font></font>
    s += tz<font></font>
<span class="hljs-keyword">return</span> s</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Improved code:</font></font><br>
<br>
<pre><code class="python hljs">s = _format_time(self._hour, self._minute,<font></font>
                 self._second, self._microsecond,<font></font>
                 timespec)<font></font>
<span class="hljs-keyword">if</span> tz := self._tzstr():<font></font>
    s += tz<font></font>
<span class="hljs-keyword">return</span> s</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sysconfig.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Calling fp.readline () as a “condition” in the while loop (as well as calling the .match () method) in the if condition makes the code more compact without complicating its understanding.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Current Code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    line = fp.readline()<font></font>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line:
        <span class="hljs-keyword">break</span><font></font>
    m = define_rx.match(line)<font></font>
    <span class="hljs-keyword">if</span> m:<font></font>
        n, v = m.group(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
        <span class="hljs-keyword">try</span>:<font></font>
            v = int(v)<font></font>
        <span class="hljs-keyword">except</span> ValueError:
            <span class="hljs-keyword">pass</span><font></font>
        vars[n] = v<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
        m = undef_rx.match(line)<font></font>
        <span class="hljs-keyword">if</span> m:<font></font>
            vars[m.group(<span class="hljs-number">1</span>)] = <span class="hljs-number">0</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Improved code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> line := fp.readline():
    <span class="hljs-keyword">if</span> m := define_rx.match(line):<font></font>
        n, v = m.group(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
        <span class="hljs-keyword">try</span>:<font></font>
            v = int(v)<font></font>
        <span class="hljs-keyword">except</span> ValueError:
            <span class="hljs-keyword">pass</span><font></font>
        vars[n] = v<font></font>
    <span class="hljs-keyword">elif</span> m := undef_rx.match(line):<font></font>
        vars[m.group(<span class="hljs-number">1</span>)] = <span class="hljs-number">0</span></code></pre></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplify List Generators</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now the list generator can be effectively filtered by "capturing" the condition:</font></font><br>
<br>
<pre><code class="python hljs">results = [(x, y, x/y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> input_data <span class="hljs-keyword">if</span> (y := f(x)) &gt; <span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After that, the variable can be reused in another expression:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [[y := f(x), x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Please note again that in both cases the variable </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is in the same scope as the variables result and stuff.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capture Values ​​in Conditions</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assignment expressions can be effectively used in the conditions of an if or while statement:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Loop-and-a-half</span>
<span class="hljs-keyword">while</span> (command := input(<span class="hljs-string">"&gt; "</span>)) != <span class="hljs-string">"quit"</span>:<font></font>
    print(<span class="hljs-string">"You entered:"</span>, command)<font></font>
<font></font>
<span class="hljs-comment"># Capturing regular expression match objects</span>
<span class="hljs-comment"># See, for instance, Lib/pydoc.py, which uses a multiline spelling</span>
<span class="hljs-comment"># of this effect</span>
<span class="hljs-keyword">if</span> match := re.search(pat, text):<font></font>
    print(<span class="hljs-string">"Found:"</span>, match.group(<span class="hljs-number">0</span>))
<span class="hljs-comment"># The same syntax chains nicely into 'elif' statements, unlike the</span>
<span class="hljs-comment"># equivalent using assignment statements.</span>
<span class="hljs-keyword">elif</span> match := re.search(otherpat, text):<font></font>
    print(<span class="hljs-string">"Alternate found:"</span>, match.group(<span class="hljs-number">0</span>))
<span class="hljs-keyword">elif</span> match := re.search(third, text):<font></font>
    print(<span class="hljs-string">"Fallback found:"</span>, match.group(<span class="hljs-number">0</span>))<font></font>
<font></font>
<span class="hljs-comment"># Reading socket data until an empty string is returned</span>
<span class="hljs-keyword">while</span> data := sock.recv(<span class="hljs-number">8192</span>):<font></font>
    print(<span class="hljs-string">"Received data:"</span>, data)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In particular, this approach can eliminate the need to create an infinite loop, assignment, and condition checking. </font><font style="vertical-align: inherit;">It also allows you to draw a smooth parallel between a cycle that uses a function call as its condition, as well as a cycle that not only checks the condition, but also uses the actual value returned by the function in the future.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fork</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An example from the low-level world of UNIX: [approx. </font><font style="vertical-align: inherit;">Fork () is a system call on Unix-like operating systems that creates a new sub-process relative to the parent.]</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> pid := os.fork():
    <span class="hljs-comment"># Parent code</span>
<span class="hljs-keyword">else</span>:
    <span class="hljs-comment"># Child code</span></code></pre><br>
<a name="otklon"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rejected Alternatives</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, similar suggestions are quite common in the python community. </font><font style="vertical-align: inherit;">Below are a number of alternative syntaxes for assignment expressions that are too specific to understand and have been rejected in favor of the above.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changing the scope for generators</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In a previous version of this PEP, it was proposed to make subtle changes to the scope rules for generators to make them more suitable for use in the scope of classes. </font><font style="vertical-align: inherit;">However, these proposals would lead to backward incompatibility and were therefore rejected. </font><font style="vertical-align: inherit;">Therefore, this PEP was able to fully focus only on assignment expressions.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternative spellings</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, the proposed assignment expressions have the same semantics, but are written differently.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPR as NAME:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [[f(x) <span class="hljs-keyword">as</span> y, x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
   EXPR as NAME       import, except  with,         (,       ).<br>
<br>
( ,  «with EXPR as VAR»     EXPR  VAR,   EXPR.__enter__()        VAR.)<br>
<br>
 ,   ":="   :<br>
<ul>
<li>  ,  <b>if f(x) as y</b>     ,    ​​   <b>if f x blah-blah</b>,        <b>if f(x) and y</b>.</li>
<li>   ,  <b>as</b> ,           ,     : <ul>
<li>import foo as bar</li>
<li>except Exc as var</li>
<li>with ctxmgr() as var</li>
</ul><br>
 , <b>as</b>     if  while     ,   <b>as</b>  « »   .</li>
<li>  «»  <ul>
<li>NAME = EXPR</li>
<li>if NAME := EXPR</li>
</ul><br>
     .</li>
</ul></li>
<li>EXPR -&gt; NAME<br>
<br>
<pre><code class="python hljs">stuff = [[f(x) -&gt; y, x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
     ,  R  Haskell,     . ( ,    - <b>y &lt; — f (x) </b>   Python,      -   .)       «as»   ,      import, except  with,      .             Python (    ),      ":=" (   Algol-58)     .</li>
<li>  «»    <br>
<br>
<pre><code class="python hljs">stuff = [[(f(x) <span class="hljs-keyword">as</span> .y), x/.y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># with "as"</span>
stuff = [[(.y := f(x)), x/.y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># with ":="</span></code></pre><br>
         .         Python,        ,   .</li>
<li> where:       :<br>
<br>
<pre><code class="python hljs">value = x**<span class="hljs-number">2</span> + <span class="hljs-number">2</span>*x where:<font></font>
    x = spam(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, q)</code></pre><br>
   (    ,     «»).      ,   «»  (  with:). . PEP 3150,      (    <i>given:</i> ).</li>
<li>TARGET from EXPR:<br>
<br>
<pre><code class="python hljs">stuff = [[y <span class="hljs-keyword">from</span> f(x), x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This syntax is less likely to conflict with others than </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (unless you count the raise Exc from Exc constructs), but otherwise be comparable to them. </font><font style="vertical-align: inherit;">Instead of a parallel with with expr as target: (which may be useful, but it can also be confusing), this option has no parallels with anything at all, but it is surprisingly better remembered.</font></font></li>
</ol><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Special cases in conditional statements</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the most common use cases for assignment expressions is the if and while statements. </font><font style="vertical-align: inherit;">Instead of a more general solution, using </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> improves the syntax of these two statements by adding a means of capturing the value to be compared:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> re.search(pat, text) <span class="hljs-keyword">as</span> match:<font></font>
    print(<span class="hljs-string">"Found:"</span>, match.group(<span class="hljs-number">0</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This works fine, but </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ONLY</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> when the desired condition is based on the "correctness" of the return value. </font><font style="vertical-align: inherit;">Thus, this method is effective for specific cases (checking for regular expressions, reading sockets, returning an empty string when execution ends), and is completely useless in more complex cases (for example, when the condition is f (x) &lt;0, and you want save the value of f (x)). </font><font style="vertical-align: inherit;">Also, this does not make sense in list generators. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advantages</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : No syntactic ambiguities. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disadvantages</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : even if you use it only in if / while statements, it only works well in some cases.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Special cases in generators</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another common use case for assignment expressions is generators (list / set / dict and genexps). </font><font style="vertical-align: inherit;">As above, suggestions were made for specific solutions.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where, let, or given:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) where y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]<font></font>
stuff = [(y, x/y) let y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]<font></font>
stuff = [(y, x/y) given y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This method results in a subexpression between the for loop and the main expression. </font><font style="vertical-align: inherit;">It also introduces an additional language keyword, which can create conflicts. </font><font style="vertical-align: inherit;">Of the three options, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the cleanest and most readable, but potential conflicts still exist (for example, SQLAlchemy and numpy have their where methods, as well as tkinter.dnd.Icon in the standard library).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with NAME = EXPR:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) <span class="hljs-keyword">with</span> y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
  ,     ,     <b>with</b>.         .   ,           «»  for.    C,         ,    .   : «  «with NAME = EXPR:»       ,   ?»</li>
<li>with EXPR as NAME:<br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) <span class="hljs-keyword">with</span> f(x) <span class="hljs-keyword">as</span> y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
   ,    <b>as</b>,    .       ,        for.      with          </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardless of the method chosen, a sharp semantic difference will be introduced between generators and their deployed versions through a for loop. </font><font style="vertical-align: inherit;">It would become impossible to wrap the cycle in a generator without processing the stage of creating the variables. </font><font style="vertical-align: inherit;">The only keyword that could be reoriented for this task is the word </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">But this will give it different semantics in different parts of the code, which means that you need to create a new keyword, but it involves a lot of costs.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lower operator priority</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The: = operator has two logical priorities. Or it should have as low priority as possible (on par with the assignment operator). Or it should take precedence greater than comparison operators. Placing its priority between comparison operators and arithmetic operations (to be precise: slightly lower than bitwise OR) will allow you to do without parentheses in most cases when and while using, since it is more likely that you want to keep the value of something before how the comparison will be performed on it:</font></font><br>
<br>
<pre><code class="python hljs">pos = <span class="hljs-number">-1</span>
<span class="hljs-keyword">while</span> pos := buffer.find(search_term, pos + <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>:<font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As soon as find () returns -1, the loop ends. </font><font style="vertical-align: inherit;">If: = binds the operands as freely as =, then the result of find () will first be “captured” into the comparison operator and will usually return True or False, which is less useful. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although this behavior would be convenient in practice in many situations, it would be more difficult to explain. </font><font style="vertical-align: inherit;">And so we can say that "the operator: = behaves the same as the usual assignment operator." </font><font style="vertical-align: inherit;">That is, the priority for: = was chosen as close as possible to the operator = (except that: = has priority higher than the comma).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You give commas on the right</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Some critics argue that assignment expressions should recognize tuples without the addition of brackets so that the two entries are equivalent:</font></font><br>
<br>
<pre><code class="python hljs">(point := (x, y))<font></font>
(point := x, y)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(In the current version of the standard, the last record will be equivalent to the expression ((point: = x), y).) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But it is logical that in this situation, when using the assignment expression in the function call, it would also have a lower priority than the comma, so we got would be the following confusing equivalence:</font></font><br>
<br>
<pre><code class="python hljs">foo (x: = <span class="hljs-number">1</span>, y)<font></font>
foo (x: = (<span class="hljs-number">1</span>, y))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And we get the only less confusing way out: make the: = operator a lower priority than the comma.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Always requiring brackets</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It has always been proposed to bracket the assignment expressions. </font><font style="vertical-align: inherit;">This would save us many ambiguities. </font><font style="vertical-align: inherit;">Indeed, parentheses will often be needed to extract the desired value. </font><font style="vertical-align: inherit;">But in the following cases, the presence of brackets clearly seemed to us superfluous:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Top level in if</span>
<span class="hljs-keyword">if</span> match := pattern.match(line):
    <span class="hljs-keyword">return</span> match.group(<span class="hljs-number">1</span>)<font></font>
<font></font>
<span class="hljs-comment"># Short call</span>
len(lines := f.readlines())</code></pre><br>
<a name="chast"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frequent objections</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why not just turn the assignment statements into expressions?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C and similar languages ​​define the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operator </font><font style="vertical-align: inherit;">as an expression, not an instruction, as Python does. </font><font style="vertical-align: inherit;">This allows for assignment in many situations, including places where variables are compared. </font><font style="vertical-align: inherit;">The syntactic similarities between if (x == y) and if (x = y) contradict their sharply different semantics. </font><font style="vertical-align: inherit;">Thus, this PEP introduces the operator: = to clarify their differences.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why bother with </font><font style="vertical-align: inherit;">assignment </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expressions</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if </font><font style="vertical-align: inherit;">assignment </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instructions</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> exist </font><font style="vertical-align: inherit;">?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These two forms have different flexibilities. </font><font style="vertical-align: inherit;">The operator: = can be used inside a larger expression, and in the = operator it can be used by the "family of mini-operators" of the type "+ =". </font><font style="vertical-align: inherit;">Also = allows you to assign values ​​by attributes and indexes.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why not use local scope and prevent namespace pollution?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Previous versions of this standard included a real local scope (limited to one statement) for assignment expressions, preventing name leakage and namespace pollution. </font><font style="vertical-align: inherit;">Despite the fact that in some situations this gave a certain advantage, in many others it complicates the task, and the benefits are not justified by the advantages of the existing approach. </font><font style="vertical-align: inherit;">This is done in the interest of the simplicity of the language. </font><font style="vertical-align: inherit;">You no longer need this variable? </font><font style="vertical-align: inherit;">There is a solution: delete the variable using the del keyword or add a lower underscore to its name. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(The author would like to thank Guido van Rossum and Christophe Groth for their suggestions to advance the PEP standard in this direction. [2])</font></font><br>
<br>
<a name="rekom"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Style Recommendations</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since assignment expressions can sometimes be used on a par with an assignment operator, the question arises, what is still preferred? .. In accordance with other style conventions (such as PEP 8), there are two recommendations:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you can use both assignment options, then give preference to operators. </font><font style="vertical-align: inherit;">They most clearly express your intentions.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the use of assignment expressions leads to ambiguity in the execution order, then rewrite the code using the classical operator.</font></font></li>
</ol><br>
<a name="blag"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The authors of this standard would like to thank Nick Coghlan and Steven D'Aprano for their significant contributions to this PEP, as well as Python Core Mentorship members for their help in implementing this.</font></font><br>
<br>
<a name="prilA"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appendix A: Tim Peters Conclusions</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is a short essay that Tim Peters wrote on this topic. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I don’t like the “confused” code, and also don’t like putting conceptually unrelated logic on one line. </font><font style="vertical-align: inherit;">So, for example, instead of:</font></font><br>
<br>
<pre><code class="python hljs">i = j = count = nerrors = <span class="hljs-number">0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I prefer to write:</font></font><br>
<br>
<pre><code class="python hljs">i = j = <span class="hljs-number">0</span>
count = <span class="hljs-number">0</span>
nerrors = <span class="hljs-number">0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, I think I will find several places where I want to use assignment expressions. </font><font style="vertical-align: inherit;">I don’t even want to talk about their use in expressions that are already stretched to half the screen. </font><font style="vertical-align: inherit;">In other cases, such behavior as:</font></font><br>
<br>
<pre><code class="python hljs">mylast = mylast[<span class="hljs-number">1</span>]
<span class="hljs-keyword">yield</span> mylast[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Significantly better than this:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">yield</span> (mylast := mylast[<span class="hljs-number">1</span>])[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These two codes have completely different concepts and mixing them would be crazy. </font><font style="vertical-align: inherit;">In other cases, combining logical expressions makes code more difficult to understand. </font><font style="vertical-align: inherit;">For example, rewriting:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    old = total<font></font>
    total += term<font></font>
    <span class="hljs-keyword">if</span> old == total:
        <span class="hljs-keyword">return</span> total<font></font>
    term *= mx2 / (i*(i+<span class="hljs-number">1</span>))<font></font>
    i += <span class="hljs-number">2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In a shorter form, we have lost “logic.” </font><font style="vertical-align: inherit;">You need to understand how this code works. </font><font style="vertical-align: inherit;">My brain does not want to do this:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> total != (total := total + term):<font></font>
    term *= mx2 / (i*(i+<span class="hljs-number">1</span>))<font></font>
    i += <span class="hljs-number">2</span>
<span class="hljs-keyword">return</span> total</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But such cases are rare. </font><font style="vertical-align: inherit;">The task of preserving the result is very common, and “sparse is better than dense” does not mean that “almost empty is better than sparse” [approx. </font><font style="vertical-align: inherit;">a reference to Zen Python]. </font><font style="vertical-align: inherit;">For example, I have many functions that return None or 0 to say "I have nothing useful, but since this happens often, I don’t want to bother you with exceptions." </font><font style="vertical-align: inherit;">In fact, this mechanism is also used in regular expressions that return None when there are no matches. </font><font style="vertical-align: inherit;">Therefore, in this example, a lot of code:</font></font><br>
<br>
<pre><code class="python hljs">result = solution(xs, n)
<span class="hljs-keyword">if</span> result:
    <span class="hljs-comment"># use result</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I find the following option more understandable, and of course more readable:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> result := solution(xs, n):
    <span class="hljs-comment"># use result</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At first I didn’t attach much importance to this, but such a short construction appeared so often that it soon began to annoy me that I could not use it. </font><font style="vertical-align: inherit;">It surprised me! </font><font style="vertical-align: inherit;">[approx. </font><font style="vertical-align: inherit;">apparently this was written before Python 3.8 was officially released.] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are other cases where assignment expressions really "shoot". </font><font style="vertical-align: inherit;">Instead of rummaging around in my code again, Kirill Balunov gave a fine example of the copy () function from the standard copy.py library:</font></font><br>
<br>
<pre><code class="python hljs">reductor = dispatch_table.get(cls)
<span class="hljs-keyword">if</span> reductor:<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">else</span>:<font></font>
    reductor = getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>)
    <span class="hljs-keyword">if</span> reductor:<font></font>
        rv = reductor(<span class="hljs-number">4</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        reductor = getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> reductor:<font></font>
            rv = reductor()<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(shallow)copyable object of type %s"</span> % cls)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The ever-increasing indentation is misleading: after all, the logic is flat: the first successful test “wins”:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> reductor := dispatch_table.get(cls):<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor(<span class="hljs-number">4</span>)
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor()<font></font>
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(shallow)copyable object of type %s"</span> % cls)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The simple use of assignment expressions allows the visual structure of the code to emphasize the “plane” of logic. </font><font style="vertical-align: inherit;">But the ever-increasing indentation makes it implicit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is another small example from my code, which made me very happy because it allowed me to put internally related logic on one line and remove the annoying “artificial” indentation level. </font><font style="vertical-align: inherit;">This is exactly what I want from the if statement and it makes reading easier. </font><font style="vertical-align: inherit;">The following code:</font></font><br>
<br>
<pre><code class="python hljs">diff = x - x_base
<span class="hljs-keyword">if</span> diff:<font></font>
    g = gcd(diff, n)<font></font>
    <span class="hljs-keyword">if</span> g &gt; <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> g</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Turned into:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> (diff := x - x_base) <span class="hljs-keyword">and</span> (g := gcd(diff, n)) &gt; <span class="hljs-number">1</span>:
    <span class="hljs-keyword">return</span> g</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, in most lines where variable assignment occurs, I would not use assignment expressions. </font><font style="vertical-align: inherit;">But this design is so frequent that there are still many places where I would take this opportunity. </font><font style="vertical-align: inherit;">In most recent cases, I won a little, as they often appeared. </font><font style="vertical-align: inherit;">In the remaining sub-part, this led to medium or large improvements. </font><font style="vertical-align: inherit;">Thus, I would use assignment expressions much more often than a triple if, but much less often than augmented assignment [approx. </font><font style="vertical-align: inherit;">short options: * =, / =, + =, etc.].</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numerical example</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I have another example that struck me earlier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If all the variables are positive integers, and the variable </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> greater than the nth root of x, then this algorithm returns the “lower” rounding of the nth root of x (and approximately doubles the number of exact bits per iteration):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> a &gt; (d := x // a**(n<span class="hljs-number">-1</span>)):<font></font>
    a = ((n<span class="hljs-number">-1</span>)*a + d) // n
<span class="hljs-keyword">return</span> a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is not clear why, but such a variant of the algorithm is less obvious than an infinite loop with a conditional branch break (loop and a half). It is also difficult to prove the correctness of this implementation without relying on a mathematical statement (“arithmetic mean - geometric mean inequality”) and not knowing some non-trivial things about how the nested rounding functions behave downward. But here the problem is already in mathematics, and not in programming. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And if you know all this, then the option using assignment expressions is read very easily, like a simple sentence: “Check the current“ guess ”and if it is too large, reduce it” and the condition allows you to immediately save the intermediate value from the loop condition. In my opinion, the classic form is harder to understand:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    d = x // a**(n<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">if</span> a &lt;= d:
        <span class="hljs-keyword">break</span>
    a = ((n<span class="hljs-number">-1</span>)*a + d) // n
<span class="hljs-keyword">return</span> a</code></pre><br>
<a name="prilB"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appendix B: A Rough Code Interpreter for Generators</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This appendix attempts to clarify (although not specify) the rules by which a variable should be created in generator expressions. </font><font style="vertical-align: inherit;">For a number of illustrative examples, we show the source code where the generator is replaced by an equivalent function in combination with some “scaffolding”. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since [x for ...] is equivalent to list (x for ...), the examples do not lose their generality. </font><font style="vertical-align: inherit;">And since these examples are intended only to clarify the general rules, they do not claim to be realistic.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note: generators are now implemented through the creation of nested generator functions (similar to those given in this appendix). </font><font style="vertical-align: inherit;">The examples show the new part, which adds the appropriate functionality for working with the scope of assignment expressions (such scope as if the assignment were performed in a block containing the most external generator). </font><font style="vertical-align: inherit;">To simplify the “type inference”, these illustrative examples do not take into account that assignment expressions are optional (but they take into account the scope of the variable created inside the generator). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's first recall what code is generated “under the hood” for generators without assignment expressions:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source code (EXPR most often uses the VAR variable):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The converted code (let's not worry about name conflicts):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:
            <span class="hljs-keyword">yield</span> EXPR<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's add a simple assignment expression.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Converted Code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:<font></font>
        TARGET = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Dead code to ensure TARGET is a local variable</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
            TARGET = EXPR<font></font>
            <span class="hljs-keyword">yield</span> TARGET<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's add the global TARGET statement to the declaration of the f () function.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">global</span> TARGET<font></font>
    a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Converted Code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">global</span> TARGET
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">global</span> TARGET
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
            TARGET = EXPR<font></font>
            <span class="hljs-keyword">yield</span> TARGET<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Or vice versa, let's add nonlocal TARGET to the declaration of the f () function.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span>():</span><font></font>
    TARGET = ...<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
        <span class="hljs-keyword">nonlocal</span> TARGET<font></font>
        a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Converted Code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span>():</span><font></font>
    TARGET = ...<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
            <span class="hljs-keyword">nonlocal</span> TARGET
            <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
                TARGET = EXPR<font></font>
                <span class="hljs-keyword">yield</span> TARGET<font></font>
        a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, let's put in two generators.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [[TARGET := i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>)]
    <span class="hljs-comment"># I.e., a = [[0, 1, 2], [0, 1, 2]]</span>
    print(TARGET)  <span class="hljs-comment"># prints 2</span>
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Converted Code:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:<font></font>
        TARGET = <span class="hljs-literal">None</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outer_genexpr</span>(<span class="hljs-params">outer_iterator</span>):</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner_generator</span>(<span class="hljs-params">inner_iterator</span>):</span>
            <span class="hljs-keyword">nonlocal</span> TARGET
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> inner_iterator:<font></font>
                TARGET = i<font></font>
                <span class="hljs-keyword">yield</span> i
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> outer_iterator:
            <span class="hljs-keyword">yield</span> list(inner_generator(range(<span class="hljs-number">3</span>)))<font></font>
    a = list(outer_genexpr(range(<span class="hljs-number">2</span>)))<font></font>
    print(TARGET)</code></pre></li>
</ul><br>
<a name="prilC"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appendix C: No Changes in Scope Semantics</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note that in Python the scope semantics have not changed. </font><font style="vertical-align: inherit;">The scope of local functions is still determined at compile time and have an indefinite time extent at runtime (closure). </font><font style="vertical-align: inherit;">Example:</font></font><br>
<br>
<pre><code class="python hljs">a = <span class="hljs-number">42</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-comment"># `a` is local to `f`, but remains unbound</span>
    <span class="hljs-comment"># until the caller executes this genexp:</span>
    <span class="hljs-keyword">yield</span> ((a := i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>))
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">lambda</span>: a + <span class="hljs-number">100</span>
    print(<span class="hljs-string">"done"</span>)
    <span class="hljs-keyword">try</span>:<font></font>
        print(<span class="hljs-string">f"`a` is bound to <span class="hljs-subst">{a}</span>"</span>)
        <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">except</span> UnboundLocalError:<font></font>
        print(<span class="hljs-string">"`a` is not yet bound"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span>results = list(f()) <span class="hljs-comment"># [genexp, lambda]</span><font></font>
done<font></font>
`a` <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> yet bound
<span class="hljs-comment"># The execution frame for f no longer exists in CPython,</span>
<span class="hljs-comment"># but f's locals live so long as they can still be referenced.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>list(map(type, results))<font></font>
[&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">generator</span>'&gt;, &lt;<span class="hljs-title">class</span> '<span class="hljs-title">function</span>'&gt;]
&gt;&gt;&gt; <span class="hljs-title">list</span>(<span class="hljs-params">results[<span class="hljs-number">0</span>]</span>)
[0, 1, 2]
&gt;&gt;&gt; <span class="hljs-title">results</span>[1]()
102
&gt;&gt;&gt; <span class="hljs-title">a</span>
42</span></code></pre><br>
<a name="ssilki"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">References</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proof of concept implementation</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discussion of the semantics of assignment expressions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (VPN is tight but loaded)</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discussion of TargetScopeError in PEP 572</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (loaded similarly to the previous one)</font></font></li>
</ol><br>
<a name="avtori"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Copyright</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This document has been made publicly available. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Source: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/python/peps/blob/master/pep-0572.rst</font></font></a><br>
<br>
<a name="my"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">My part</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To start, let's summarize:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So that </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">people don’t try</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to remove semantic duality, in many “classical” places where one could use both “=” and “: =” there are restrictions, therefore the operator:: = should be often enclosed in brackets. </font><font style="vertical-align: inherit;">These cases will have to be reviewed in the section </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">describing the basic use.</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The priority of assignment expressions is slightly higher than that of a comma. </font><font style="vertical-align: inherit;">Due to this, tuples are not formed during assignment. </font><font style="vertical-align: inherit;">It also makes it possible to use the: = operator when passing arguments to a function.</font></font></li>
<li> ,   ,    ,    .       .    lambda    ,    «»  .</li>
<li>        :   ,     </li>
<li>      ,   .</li>
<li>          /  .</li>
<li>   ,      .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the end, I want to say that I liked the new operator. </font><font style="vertical-align: inherit;">It allows you to write flatter code in conditions, “filter” lists, and also (finally) remove the “same”, lonely line before if. </font><font style="vertical-align: inherit;">If people use assignment expressions for their intended purpose, then this will be a very convenient tool that will increase the readability and beauty of the code (Although, this can be said about any functional language ....)</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en499654/index.html">How to implement CRM on a remote site and win?</a></li>
<li><a href="../en499656/index.html">PID temperature controller simulation</a></li>
<li><a href="../en499658/index.html">A man-laborer instead of a tester? Is it worth it to study Selenium in 2020?</a></li>
<li><a href="../en499662/index.html">Root-of-Trust for IoT and Other IoT Security Trends</a></li>
<li><a href="../en499664/index.html">Porting APIs to TypeScript as a Problem Solver</a></li>
<li><a href="../en499668/index.html">Road to Hell JavaScript Dependencies</a></li>
<li><a href="../en499670/index.html">Я перехожу на JavaScript</a></li>
<li><a href="../en499674/index.html">Another step to optical computers</a></li>
<li><a href="../en499676/index.html">90+ useful tools for Kubernetes: deployment, management, monitoring, security and more</a></li>
<li><a href="../en499680/index.html">Learning Kubernetes: Basic May 14-16, Advanced May 18-20</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>