<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ∑ üë©‚Äçüíª üé∞ Nuxt Server-Side Memory Leak Using SSR (Server Side Rendering) ü•á üõí üòü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! This article is a must-read for anyone who works with Vue SSR, in particular with Nuxt . This is about a memory leak when using axios .
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Nuxt Server-Side Memory Leak Using SSR (Server Side Rendering)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489838/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello, Habr! </font><font style="vertical-align: inherit;">This article is a must-read for anyone who works with Vue SSR, in particular with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuxt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This is about a memory leak when using </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">axios</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Background</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Half a year ago, I got on a project with a VueJS + Nuxt stack, its peculiarity was that the Nod servers (Nuxt) were constantly dying in the prod and new ones were rising in their place. </font><font style="vertical-align: inherit;">According to the graphs and logs, it was clear that the node process operative reached 100% and it fell with an out of memory error. </font><font style="vertical-align: inherit;">At this time, a new one was rising to the place of the killed process, which took about 30 seconds, this was enough for users to get a 502 error. </font><font style="vertical-align: inherit;">Obviously, somewhere in the code there was a memory leak that needed to be found.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I want to highlight the key points right away, since reading only part of this article may not answer all your questions:</font></font><br>
<br>
<ol>
<li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relevance of the topic </font></font></b> </li>
<li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Axios interceptors</font></font></b> </li>
<li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">runInNewContext</font></font></b> </li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Relevance of the topic</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first thing, as many of us would do, I started looking for a solution on the Internet, my queries looked something like this: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NodeJS memory leaks</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuxt memory leaks</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuxt memory leaks in production</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, none of the twenty issue on stackoverflow helped me, but I learned how to track memory usage through chrome: // inspect. </font><font style="vertical-align: inherit;">To my disappointment, I found that 90% of all memory that was not cleaned for some reason was some Vue's functions like renderComponent, renderElement, and others.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fa/oo/gn/faoognc9ndcq9h5lw7omfenjq78.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Axios Interceptors</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We quickly go through my torment in search of a problem and immediately proceed to the fact that </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">axios.interceptors</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are to blame for </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">everything</font></a><font style="vertical-align: inherit;"> (I'm sorry, Habr, for finding the guilty). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Immediately make a reservation that axios was created like this:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> baseAxios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> axios = baseAxios.create({
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span>,<font></font>
});<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> axios;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And attached to the application context like this: </font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'./index'</span>;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>{<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(!context.axios) {<font></font>
    context.axios = axios;<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After a long search for leaks, I found that if you disable all axios.interceptors, then the memory starts to be cleaned.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is the matter?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interceptor is a proxy that intercepts all response or request and allows you to execute any code with an answer (for example, handle errors) or add something before sending a request globally for all requests and in 1 place, convenient, isn't it? </font><font style="vertical-align: inherit;">Here is an example of how it looks (file 'plugins / axios / interceptor.js')</font></font></li>
</ul><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">{ axios }</span>) </span>{<font></font>
<font></font>
  <span class="hljs-keyword">const</span> interceptor = axios.interceptors.response.use( <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> response;<font></font>
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
    <span class="hljs-comment">//-   ,  </span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);<font></font>
  });<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And here the fun begins. </font><font style="vertical-align: inherit;">We add the function of adding an interceptor via plugins in nuxt.config.js</font></font><br>
<br>
<pre><code class="javascript hljs">  plugins: [<font></font>
    { <span class="hljs-attr">src</span>: <span class="hljs-string">'~/plugins/axios/bindContext'</span> },<font></font>
    { <span class="hljs-attr">src</span>: <span class="hljs-string">'~/plugins/axios/interceptor'</span> },<font></font>
  ]</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
and nuxt automatically for each new request performs all plugins functions, then does nuxtServerInit and then everything is as usual. That is, for the first user, we create an interceptor on the server side, somewhere in our components in asyncData or in fetch we make requests, and the interceptor works out as it should, then the second user enters and we create the second interceptor and the code inside the function will work 2 times! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For a better understanding of my words, I will draw a counter that increments with every call to the function and 5 times knock on index. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ly/en/uu/lyenuuid32whlgsdqja6nz8z6s8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We can notice that 15 calls have occurred, and this is 1 + 2 + 3 + 4 + 5, I additionally took the time to create the next interceptor to make sure that there are challenges of those that were created earlier.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From school, we all remember the formula of arithmetic progression well, and the sum from 1 to n can be written as n * (n + 1) / 2. It turns out that when the 1000th user comes in, our function will be called 1000 times, and in total this is already half a million calls, so if the load is medium or high, then do not be surprised if your server crashes.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solution to the problem </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UPD. </font><font style="vertical-align: inherit;">Solution # 0 - The comments describe good solutions to this problem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solution # 1 - Do not use axios.interceptors. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solution No. 2 - Everything is very simple, you need to clean the interceptor for yourself, guided by the axios documentation</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">{ axios }</span>) </span>{<font></font>
<font></font>
  <span class="hljs-keyword">const</span> interceptor = axios.interceptors.response.use( <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(process.server) {<font></font>
      axios.interceptors.response.eject(interceptor);<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> response;<font></font>
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
    <span class="hljs-keyword">if</span>(process.server) {<font></font>
      axios.interceptors.response.eject(interceptor);<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);<font></font>
  });<font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This needs to be done only on the server side, because otherwise on the client side, after successfully executing any first request, this interceptor will stop executing. </font><font style="vertical-align: inherit;">There is one more nuance with the fact that while we are still on the server and are processing the requests of the next user, but there may be several, but several requests, then with the eject of this interceptor, all requests except the first will not go through it, in this case to independently think about the moment at which you need to perform an eject, the easiest way to do this is through setTimeout, for example, after 10 seconds, then we can assume that on the server side we will manage to complete all requests for the current user and all of them will be executed during this time, when the interceptor will still be active.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> runInNewContext </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a very funny option, because of which this bug cannot be reproduced locally, but it is very easily reproduced in the build. </font><font style="vertical-align: inherit;">Read about it </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">When I was preparing to write this article, I created the starter-template nuxt project to reproduce this problem, and how I was surprised that for each regular user - interceptor was executed 1 time, and not n. </font><font style="vertical-align: inherit;">The thing is, when we write npm run dev - this option is true by default, and every time we perform functions from plugins on the server side, the context is new each time (obviously from the flag name), and it is automatically done in the build false for better performance in the prod, so I had to disable this option in nuxt.config.js</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-attr">render</span>: {
    <span class="hljs-attr">bundleRenderer</span>: {
      <span class="hljs-attr">runInNewContext</span>: <span class="hljs-literal">false</span>,<font></font>
    },<font></font>
  },<font></font>
</code></pre> <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As for me, this problem is very serious, and it is worth paying special attention to it. </font><font style="vertical-align: inherit;">Perhaps this problem concerns not only Vue ssr, but also others, and not only axios, but also any other HTTP clients that have proxies similar to interceptor. </font><font style="vertical-align: inherit;">If you have questions, you can write to me on Telegram </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@alexander_proydenko</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">All the code used in the article can be viewed on github </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en489826/index.html">About mutable methods of a Math object in JavaScript</a></li>
<li><a href="../en489828/index.html">Working with GeoJSON in Node.js: a practical introduction</a></li>
<li><a href="../en489832/index.html">Man-made atomic beads: manipulations with macrocycles</a></li>
<li><a href="../en489834/index.html">Embed your Smart Home device in the SmartThings ecosystem</a></li>
<li><a href="../en489836/index.html">Lidars of the future: 11,000 lasers instead of 128</a></li>
<li><a href="../en489840/index.html">Drive Anatomy: Hard Drives</a></li>
<li><a href="../en489844/index.html">Comparative analysis of some Java decompilers</a></li>
<li><a href="../en489848/index.html">Why do my colleagues / employees behave like @% ¬ß?</a></li>
<li><a href="../en489850/index.html">Security Week 09: who is responsible for Android security?</a></li>
<li><a href="../en489852/index.html">Transparent authentication in ASP.Net Core on Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>