<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳🏻 👨‍🌾 💐 関数型プログラミング：労働生産性を殺す風変わりなおもちゃ。パート1 😥 💩 👨🏻‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="いわゆる「関数型」プログラミングについてはすでに聞いたことがあるかもしれません。たぶん、どうにかして試してみるべきだと思っているかもしれません。
 
 決してこれを行わないでください！ 関数型プログラミングには欠陥がたくさんあり、実際のプロジェクトには適していません。その適用は労働生産性の急激な低下...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>関数型プログラミング：労働生産性を殺す風変わりなおもちゃ。パート1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/462483/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いわゆる「関数型」プログラミングについてはすでに聞いたことがあるかもしれません。</font><font style="vertical-align: inherit;">たぶん、どうにかして試してみるべきだと思っているかもしれません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
決してこれを行わないでください！</font><font style="vertical-align: inherit;">
関数型プログラミングには欠陥がたくさんあり、実際のプロジェクトには適していません。</font><font style="vertical-align: inherit;">その適用は労働生産性の急激な低下につながります。</font><font style="vertical-align: inherit;">これはなぜですか？</font><font style="vertical-align: inherit;">確認してみましょう。</font><font style="vertical-align: inherit;">
▍→ </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">パート2</font></a></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/wr/xh/7r/wrxh7rlj7pjiyzivyksens90mtu.png"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a> <br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数型プログラミングは多面的な企業要件を満たすことができない</font></font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0db/8f9/459/0db8f9459669fa14219558e618a30919.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際のエンタープライズクラスのソフトウェアを作成するには、ソフトウェアソリューションに組み込まれている抽象化の予想される数に関連する、厳格で拘束力のある一連の複雑な要件が必要です。オブジェクト指向プログラミングにより、開発者は組織のソフトウェアシステム要件を完全に満たすことができる多くの抽象化メカニズムを使用できます。</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
上記のテキストは特にはっきりとは見えません。しかし、すぐにすべてが定位置に収まります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いわゆる「関数型」プログラミングには、抽象化を作成するための通常のメカニズムがありません。事実は、それが数学的なルールに基づいているということです（これらのルールは非常に理解可能ですが、教育機関の壁の外の現実の世界では適用されません）。 OOPとは異なり、関数型プログラミングは、組織が作成する数多くの困難で複雑なソフトウェア要件をすべて満たそうとはしません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のコードスニペットは、関数型プログラミングが使用されている場合に広く発生する問題を示しています。</font></font><br>
<br>
<pre><code class="plaintext">import { filter, first, get } from 'lodash/fp';<font></font>
<font></font>
const filterByType = type =&gt;<font></font>
&nbsp;&nbsp;filter( x =&gt; x.type === type );<font></font>
<font></font>
const fruits = [<font></font>
&nbsp;&nbsp;{ type: 'apple', price: 1.99 },<font></font>
&nbsp;&nbsp;{ type: 'orange', price: 2.99 },<font></font>
&nbsp;&nbsp;{ type: 'grape', price: 44.95 }&nbsp;&nbsp;<font></font>
];<font></font>
<font></font>
const getFruitPrice = type =&gt; fruits =&gt;<font></font>
&nbsp;&nbsp;fruits<font></font>
&nbsp;&nbsp;|&gt; filterByType(type)<font></font>
&nbsp;&nbsp;|&gt; first<font></font>
&nbsp;&nbsp;|&gt; get('price');<font></font>
<font></font>
const getApplePrice = getFruitPrice('apple');<font></font>
<font></font>
console.log('apple price', getApplePrice(fruits));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このすべてがあなたに怒りを引き起こさないなら、あなたはこれに一人ではないことを知ってください！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数型プログラミングは、真面目な企業が通常必要とする機能を適切に抽象化してカプセル化しようとするものではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自尊心のあるプログラマーがそのようなコードを書くことは決してありません！</font><font style="vertical-align: inherit;">誰かがこれを行うと、通常の大企業ではすぐに解雇され、この会社の行動に害が及ばないようにします。</font><font style="vertical-align: inherit;">次のセクションでは、OOPスタイルで記述されたプログラムを見ていきます。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能的なソフトウェアソリューションは時間の試練に耐えられない</font></font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d0/435/2a3/8d04352a37510e72fa150cc310d9a13a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロフェッショナルで自尊心のあるプログラマーの主な仕事は、時間の経過とともに関連性を失わず、同時にビジネスの複雑な要件を満たすコードを記述することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の関数コードの不運な例とは対照的に、OOP方法論に従って記述されたプログラムの抜粋されたサンプルを見てみましょう。このコードは前のコードと同じですが、適切な抽象化を使用しています。さらに、彼は時間の経過とともに関連性を失うことはありません。</font></font><br>
<br>
<pre><code class="plaintext">class Fruit {<font></font>
&nbsp;&nbsp;constructor(type, price) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;this.type = type;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;this.price = price;<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
<font></font>
class AbstractFruitFactory {<font></font>
&nbsp;&nbsp;make(type, price) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;return new Fruit(type, price);<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
<font></font>
class AppleFactory extends AbstractFruitFactory {<font></font>
&nbsp;&nbsp;make(price) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;return super.make("apple", price);<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
<font></font>
class OrangeFactory extends AbstractFruitFactory {<font></font>
&nbsp;&nbsp;make(price) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;return super.make("orange", price);<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
<font></font>
class GrapeFactory extends AbstractFruitFactory {<font></font>
&nbsp;&nbsp;make(price) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;return super.make("grape", price);<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
<font></font>
class FruitRepository {<font></font>
&nbsp;&nbsp;constructor() {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;this.fruitList = [];<font></font>
&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;locate(strategy) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;return strategy.locate(this.fruitList);<font></font>
&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;put(fruit) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;this.fruitList.push(fruit);<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
<font></font>
class FruitLocationStrategy {<font></font>
&nbsp;&nbsp;constructor(fruitType) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;this.fruitType = fruitType;<font></font>
&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;locate(list) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;return list.find(x =&gt; x.type === this.fruitType);<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
<font></font>
class FruitPriceLocator {<font></font>
&nbsp;&nbsp;constructor(fruitRepository, locationStrategy) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;this.fruitRepository = fruitRepository;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;this.locationStrategy = locationStrategy;<font></font>
&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;locatePrice() {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;return this.fruitRepository.locate(this.locationStrategy).price;<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
<font></font>
const appleFactory = new AppleFactory();<font></font>
const orangeFactory = new OrangeFactory();<font></font>
const grapeFactory = new GrapeFactory();<font></font>
<font></font>
const fruitRepository = new FruitRepository();<font></font>
fruitRepository.put(appleFactory.make(1.99));<font></font>
fruitRepository.put(orangeFactory.make(2.99));<font></font>
fruitRepository.put(grapeFactory.make(44.95));<font></font>
<font></font>
const appleLocationStrategy = new FruitLocationStrategy("apple");<font></font>
<font></font>
const applePriceLocator = new FruitPriceLocator(<font></font>
&nbsp;&nbsp;fruitRepository,<font></font>
&nbsp;&nbsp;appleLocationStrategy<font></font>
);<font></font>
<font></font>
const applePrice = applePriceLocator.locatePrice();<font></font>
<font></font>
console.log("apple", applePrice);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、ここではすべての基本機能が質的に抽象化されています。</font><font style="vertical-align: inherit;">これはワンピースのコードです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純さが自分をだましてはいけません。</font><font style="vertical-align: inherit;">これは、深刻な大規模組織が通常提唱するビジネスコード要件を完全に満たします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この信頼できるソリューションは、時間のテストに完全に対応しています。</font><font style="vertical-align: inherit;">さらに、企業レベルで依存関係を実装するためのテクノロジーが適切に使用されています。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真面目な経営には真剣な機会が必要です。</font></font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/050/503/996/050503996d0e60dd359017794d54be1f.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点までに、開発チームがコードの抽象化に関連する複雑なビジネス要件を完了していることを願っています。プログラマーは、プロジェクトマネージャーが設定したプロジェクト機能の実装に注意を向ける必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
企業環境で作業している実際のプロジェクトマネージャーが知っているように、新しいアプリケーション機能だけがビジネスにとって真に価値があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラマは、ユニットテストやコードリファクタリングなどの無用なアクティビティにリソースを費やす必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、いわゆる「関数型」プログラミングには、この分野で大きな問題があります。リファクタリングや単体テストなどの不要なアクションの実装を不必要に簡略化します。これは、今度は開発チームの注意散漫になります。このチームのメンバーは、アプリケーションに新しい機能を装備する代わりに、これらの役に立たないアクティビティに誤って時間を費やす可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の例は、関数型プログラミングの劣悪さを明確に示しています。この方法論を使用すると、リファクタリングが大幅に簡略化されます。</font></font><br>
<br>
<pre><code class="plaintext">//  :<font></font>
<font></font>
// calculator.js:<font></font>
const isValidInput = text =&gt; true;<font></font>
<font></font>
const btnAddClick = (aText, bText) =&gt; {<font></font>
&nbsp;&nbsp;if (!isValidInput(aText) || !isValidInput(bText)) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;return;<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
<font></font>
<font></font>
//  :<font></font>
<font></font>
// inputValidator.js:<font></font>
export const isValidInput = text =&gt; true;<font></font>
<font></font>
// calculator.js:<font></font>
import { isValidInput } from './inputValidator';<font></font>
<font></font>
const btnAddClick = (aText, bText, _isValidInput = isValidInput) =&gt; {<font></font>
&nbsp;&nbsp;if (!_isValidInput(aText) || !_isValidInput(bText)) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;return;<font></font>
&nbsp;&nbsp;}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このリファクタリングの単純さに引き返された場合は、そのような感覚を経験するだけではないことに注意してください。</font><font style="vertical-align: inherit;">7行あった後、リファクタリングする前に6行のコードがありましたか？</font><font style="vertical-align: inherit;">冗談でしょ？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを、オブジェクト指向コードの通常のリファクタリングと比較してください。</font></font><br>
<br>
<pre><code class="plaintext">//  :<font></font>
public class CalculatorForm {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;private string aText, bText;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;private bool IsValidInput(string text) =&gt; true;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;private void btnAddClick(object sender, EventArgs e) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( !IsValidInput(bText) || !IsValidInput(aText) ) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
<font></font>
<font></font>
//  :<font></font>
public class CalculatorForm {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;private string aText, bText;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;private readonly IInputValidator _inputValidator;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;public CalculatorForm(IInputValidator inputValidator) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_inputValidator = inputValidator;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;private void btnAddClick(object sender, EventArgs e) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( !_inputValidator.IsValidInput(bText)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|| !_inputValidator.IsValidInput(aText) ) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
<font></font>
public interface IInputValidator {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;bool IsValidInput(string text);<font></font>
}<font></font>
<font></font>
public class InputValidator : IInputValidator {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;public bool IsValidInput(string text) =&gt; true;<font></font>
}<font></font>
<font></font>
public class InputValidatorFactory {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;public IInputValidator CreateInputValidator() =&gt; new InputValidator();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それが本当のプログラミングの様子です！</font><font style="vertical-align: inherit;">リファクタリング前のコードは9行あり、コードが22行になった後です。これを行うには、さらに多くの作業が必要です。</font><font style="vertical-align: inherit;">これは、会社のために働いているプログラマーがそのような冒険に着手する前に二度考えることを強いるでしょう。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宣言型プログラミングアプローチの有害な概念</font></font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c4/b17/8a1/3c4b178a1d7b3355bb83823df971112a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いわゆる「関数型」プログラマは、宣言型コードを記述しているため、不当に誇りを持っています。しかし、誇りに思うことは何もありません。そのようなコードは生産性の幻想を生み出すだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者の主な責任は、適切な厳格なオブジェクト指向の抽象化について考えることです（これには、深刻な大規模組織が必要です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
抽象化されたオブジェクト指向のコードを見てみましょう。</font></font><br>
<br>
<pre><code class="plaintext">class CountryUserSelectionStrategy {<font></font>
&nbsp;&nbsp;constructor(country) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;this.country = country;<font></font>
&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;isMatch(user) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;return user.country === this.country;<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
<font></font>
class UserSelector {<font></font>
&nbsp;&nbsp;constructor(repository, userSelectionStrategy) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;this.repository = repository;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;this.userSelectionStrategy = userSelectionStrategy;<font></font>
&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;selectUser() {&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;let user = null;<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;for (const u in users) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( this.userSelectionStrategy.isMatch(u) ) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user = u;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;return user;<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
<font></font>
const userRepository = new UserRepository();<font></font>
const userInitializer = new UserInitializer();<font></font>
userInitializer.initialize(userRepository);<font></font>
<font></font>
const americanSelectionStrategy = new CountryUserSelectionStrategy('USA');<font></font>
const americanUserSelector = new UserSelector(userRepository, americanSelectionStrategy);<font></font>
<font></font>
const american = americanUserSelector.selectUser();<font></font>
<font></font>
console.log('American', american);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
命令サイクルを詳しく見てみましょう</font></font><code>for (const u in users)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。実行中のタスクに関連付けられていない2次テンプレートオブジェクト指向コードには注意しないでください。この例を、コードに深刻な組織が課す抽象化の厳しい要件を満たすために、プログラムに含める必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、宣言型コードは具体的すぎるため、開発者はビジネスロジックなど、それほど重要でないものに集中する必要があります。上記の強力なエンタープライズレベルのソリューションを、欠陥のある「宣言型」コードの次の例と比較してください。</font></font><br>
<br>
<pre><code class="plaintext">SELECT * FROM Users WHERE Country=’USA’;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SQLコードを見るたびに、その宣言的な性質に本当にショックを受けています。</font><font style="vertical-align: inherit;">なぜSQLなのか？</font><font style="vertical-align: inherit;">プログラマが適切なエンタープライズクラスの抽象化を使用せず、通常のオブジェクト指向コードを作成しないのはなぜですか。</font><font style="vertical-align: inherit;">特に、彼らはすでに必要なものをすべて持っていることを考慮します。</font><font style="vertical-align: inherit;">これは単なる脳の爆発であり、別の言い方をすることはできません。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実世界モデリング</font></font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/755/3d4/644/7553d464454a1ca41e74e3ffda8ac717.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクト指向プログラミングは素晴らしいです。</font><font style="vertical-align: inherit;">「関数型」プログラミングとは異なり、実際のオブジェクトのモデリングに最適です。</font><font style="vertical-align: inherit;">OOPは継承、ポリモーフィズム、カプセル化などの高度なテクノロジーをサポートしているため、これが可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自尊心のあるプログラマは、継承を毎日使用して、高レベルのコード再利用を実現する必要があります。すでに述べたように、継承は実世界のモデリングに最適です。たとえば、猫は常に現実の世界の1つの抽象的な動物からその特性と行動を継承します。生命は数十億年前の海で生まれました。その結果、すべての哺乳類（猫を含む）は、いくつかの原始的な魚から特性を継承しました。たとえば、オブジェクト指向言語では、</font></font><code>garfield.fishHead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガーフィールドの猫の魚の頭を表すプロパティの</font><font style="vertical-align: inherit;">ようになります</font><font style="vertical-align: inherit;">。 OOPの用語では、</font></font><code>garfield.swim()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（水泳）</font></font><code> garfield.layCaviar()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（産卵）の</font><font style="vertical-align: inherit;">ように見える動作についても同じことが言え</font><font style="vertical-align: inherit;">ます。猫がそんなに愛していることに誰も驚かない。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入浴</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して泳ぐ！</font><font style="vertical-align: inherit;">人々は本質的に同じです。</font><font style="vertical-align: inherit;">人が望めば、簡単に産卵を開始できます！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのプログラムは、常にコード編成に対して同様の階層的アプローチに従う必要があります。</font><font style="vertical-align: inherit;">関数型プログラミングは、プログラマーに自然そのものから発想を得た優れたコード共有構造を不必要に奪います。</font><font style="vertical-align: inherit;">これは、特に深刻な複雑なエンタープライズアプリケーションに関しては、広範囲にわたる結果をもたらします。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数は常にオブジェクトにバインドする必要があります</font></font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b8/ba0/f2a/2b8ba0f2ae9fc6ab5ea99b4fb29f5639.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数は常にオブジェクトに関連付けられるべきであるという事実は、私たちに常識を伝えます。また、現実の世界で見られるものを完全に再現します。メモ帳には「書き込み」メソッドが組み込まれています。このメソッドは、ノートに何かを書き込むたびに呼び出されます。あなたはこれに気づいていないかもしれませんが、メソッドも持っています。たとえば、</font></font><code>.eat(veggies)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">野菜を食べさせたり、</font></font><code>.doHomework()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">学校で宿題をしたおかげです。これは単なる常識です。あなたが若い頃、お母さんは野菜を食べて宿題をやるのでしょうか？もちろん、彼女はあなたのこれらのメソッドを直接呼び出しました！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現実の世界では、専門のマネージャーがタスクを調整しなければ、単一のジョブを実行することはできません。オブジェクトとして表現できます</font></font><code>Manager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。若い人たちは、「Netflixを見てリラックスする」など、基本的な人間のニーズを満たすのに役立つマネージャーを必要とする場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結局のところ、この複雑なプロセスのすべてのコンポーネントを調整するのは誰ですか？そして、十分に賢い人々は、OOPが推奨するとおりに実行して、複数のマネージャーを雇うことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現実の世界では、新しく興味深いものを作成するには、さらに、オブジェクトとして表すことができる特別なファクトリが必要</font></font><code>Factory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。たとえば、レオナルドダヴィンチには絵画の製造工場があり</font></font><code>MonaLisaFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ドナルドトランプは秘密の工場を建設してい</font></font><code>WallFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数型プログラミングは実世界をシミュレートしようとしないため、これが「関数型」棺桶のもう1つの釘であることに気づくのは簡単です。</font><font style="vertical-align: inherit;">関数はオブジェクトとは別に存在できますが、これは単に間違っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数型プログラミングは、現実世界に焦点を当てた真剣な作業には明らかに適していません。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数型プログラミングは専門家として成長する機会を提供しない</font></font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ac/96e/fb4/0ac96efb416553480af43eeb54482a72.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者が注意すべき最初かつ最も重要なことは、彼らの継続的な自己改善と専門家の成長です。 OOPを完全にマスターするには、プログラマーは大量の知識を習得する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、プログラマーは、継承、抽象化、カプセル化、ポリモーフィズムなどの高度なOOP技術を学ぶ必要があります。次に、デザインパターン（シングルトンパターンなど）の闇をうまくマスターし、コードでそれらを使い始める必要があります。よく知っておく必要のある基本的なデザインパターンは約30あります。理想的には、パターンを学習するプロセスのどこかで、プログラマーはコードで企業レベルのさまざまな抽象概念を使用することから始めるべきです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のステップは、ドメイン駆動設計などのテクノロジーに慣れ、モノリシックソフトウェアプロジェクトをパーツに分割する方法を学ぶことです。また、オブジェクト指向コードのリファクタリングは簡単な作業ではないため、Resharperなどのコードリファクタリングに適したツールを検討することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PLOの分野でまともなレベルを達成するには、20〜30年かかります。ただし、30年の経験を持つほとんどの人でも、OOPの真のマスターとは見なされないことに注意してください。 OOP生の進路は難しく、不確実性に満ちています。その結果、オブジェクト指向の開発者は、生涯にわたる研究を待っています。すごくないですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
惨めな関数型プログラマについてはどうですか？</font><font style="vertical-align: inherit;">残念ながら、彼らはそれほど学ぶ必要はありません。</font><font style="vertical-align: inherit;">私自身、JavaScriptでいくつかのジュニア関数プログラミングを教えました。</font><font style="vertical-align: inherit;">彼らは約6か月後にかなり良くなり始めました。</font><font style="vertical-align: inherit;">彼らはいくつかの基本的な概念を理解する必要があるだけであり、その後、それらをすばやく適用する方法を学ぶ必要がありました。</font><font style="vertical-align: inherit;">生涯学習の携挙はどこですか？</font><font style="vertical-align: inherit;">私は彼らをうらやましくないでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きます... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">親愛なる読者へ！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数型プログラミングの最も嫌いな点は何ですか？</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja462473/index.html">マイクロサービスを使用するための環境を開発しています。パート1ベアメタルへのKubernetes HAのインストール（Debian）</a></li>
<li><a href="../ja462475/index.html">Алексей Савватеев: Как бороться с коррупцией при помощи математики (Нобелевская премия по экономике за 2016 год)</a></li>
<li><a href="../ja462477/index.html">科学者はAIを新しい特許の作成者であると主張し、特許法を変更しようとしています</a></li>
<li><a href="../ja462479/index.html">Steam Windowsクライアントローカル権限エスカレーション0day</a></li>
<li><a href="../ja462481/index.html">タイプシステムFAQ</a></li>
<li><a href="../ja462485/index.html">関数型プログラミング：労働生産性を殺す風変わりなおもちゃ。パート2</a></li>
<li><a href="../ja462487/index.html">Cython：30倍を超えるPythonコードアクセラレーション</a></li>
<li><a href="../ja462489/index.html">先週のフロントエンドの世界からの新鮮な食材のダイジェストNo.374（2019年7月29日〜8月4日）</a></li>
<li><a href="../ja462493/index.html">マルチモデルDBMS-現代の情報システムの基礎？</a></li>
<li><a href="../ja462495/index.html">8月5〜11日のモスクワでのデジタルイベント</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>