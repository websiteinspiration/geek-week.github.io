<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍❤️‍💋‍👨 ❎ 🤱 Jendela multi-warna: konstruktor virtual, CRTP, dan template rumit 👩‍⚕️ 👆🏽 🌅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk beberapa waktu, pola desain non-sepele telah diketahui ketika kelas turunan dilewatkan dalam parameter dasar:
 

template<class T> class Base { ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Jendela multi-warna: konstruktor virtual, CRTP, dan template rumit</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/507146/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk beberapa waktu, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pola desain non-sepele telah</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diketahui </font><font style="vertical-align: inherit;">ketika kelas turunan dilewatkan dalam parameter dasar:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">Base</span>
{</span><font></font>
	…<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base&lt;Derived&gt;<font></font>
{<font></font>
	…<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Templat ini memiliki nama sendiri - CRTP: Curiously Recurring Pattern Pattern, yang diterjemahkan sebagai "pola berulang yang aneh." Saya menambahkan lebih banyak keanehan pada konstruksi yang sudah aneh ini: Saya menggeneralisasikannya ke seluruh rangkaian warisan. Ya, itu benar-benar dapat dilakukan, tetapi untuk ini Anda harus </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memberi jiwa</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk membayar harga yang besar. Untuk mengetahui bagaimana saya melakukannya dan berapa harga yang harus saya bayar, saya mengundang Anda untuk membaca lebih lanjut artikel ini untuk detailnya.</font></font><a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini kita akan berurusan </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan penyimpangan yang mengerikan dengan</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berbagai metode aneh dan hal-hal buruk lainnya. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya ingin segera memperingatkan Anda: jangan menganggap materi yang dijelaskan di sini sebagai sesuatu yang serius. Saya yakin bahwa dalam 95-99% kasus semua ini tidak akan pernah berguna bagi Anda dalam praktik. Ini adalah semacam matematika yang menghibur, latihan untuk pikiran. Dalam praktiknya, sepertinya tidak akan berguna, tetapi menarik untuk mencurahkan waktu untuk ini. Hanya dalam kasus ini bahasa C ++ dan kemampuannya bertindak sebagai matematika. Saya memperingatkan Anda sebelumnya, karena Jika Anda mencari sesuatu yang serius dan berorientasi praktis di sini, Anda mungkin kecewa.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Segera dengarkan yang eksotis, seolah-olah Anda tiba-tiba menemukan diri Anda di negara di mana dua bulan, tiga matahari, dedaunan berwarna biru atau ungu, dan memang banyak hal yang biasa adalah jenis ... aneh dan tidak biasa ... Jika Anda terperosok dalam kehidupan sehari-hari yang abu-abu dan belum lama berselang baca sesuatu seperti itu, lalu kamu datang ke alamat ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jendela multi-warna</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu sudah lama sekali. </font><font style="vertical-align: inherit;">Hampir tiga tahun lalu. </font><font style="vertical-align: inherit;">Saya kemudian </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">duduk di rumput berat</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hanya memahami </font><font style="vertical-align: inherit;">dasar </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zen</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C ++ 11/14 dari buku Meyers S. - "C ++ yang efektif dan modern." </font><font style="vertical-align: inherit;">Itu juga menyebutkan pola ini. </font><font style="vertical-align: inherit;">Setelah itu, ketika saya merasa bahwa saya telah </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mencapai pencerahan</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , saya </font><s><font style="vertical-align: inherit;">telah</font></s><font style="vertical-align: inherit;"> menguasai dasar-dasar standar baru dan siap untuk melihat hal-hal lama dengan cara yang baru, saya mulai menyegarkan buku di Windows API: Schupak Y. - “Win32 API. </font><font style="vertical-align: inherit;">Pengembangan aplikasi yang efektif. " </font><font style="vertical-align: inherit;">Pada awalnya, ini menjelaskan program bahasa C minimal untuk membuat dan menampilkan jendela:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><font></font>
<font></font>
HWND hMainWnd;<font></font>
TCHAR szClassName[] = TEXT(<span class="hljs-string">"MyClass"</span>);<font></font>
MSG msg;<font></font>
WNDCLASSEX *wc;<font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>
</span>{<font></font>
	HDC hDC;<font></font>
	PAINTSTRUCT ps;<font></font>
	RECT rect;<font></font>
<font></font>
	<span class="hljs-keyword">switch</span>(uMsg)<font></font>
	{<font></font>
	<span class="hljs-keyword">case</span> WM_CREATE:<font></font>
		SetClassLongPtr(hWnd, <span class="hljs-number">-10</span>, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		hDC = BeginPaint(hWnd, &amp;ps);<font></font>
<font></font>
		GetClientRect(hWnd, &amp;rect);<font></font>
		DrawText(hDC, TEXT(<span class="hljs-string">"Hello, world!"</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<font></font>
<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_CLOSE:<font></font>
		DestroyWindow(hWnd);<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		PostQuitMessage(<span class="hljs-number">0</span>);
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="hljs-keyword">int</span> nCmdShow)</span>
</span>{	
	<span class="hljs-keyword">if</span>(!(wc = <span class="hljs-keyword">new</span> WNDCLASSEX))<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"  !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	wc-&gt;cbSize = <span class="hljs-keyword">sizeof</span>(WNDCLASSEX);<font></font>
	wc-&gt;style = CS_HREDRAW | CS_VREDRAW;<font></font>
	wc-&gt;lpfnWndProc = WndProc;<font></font>
	wc-&gt;cbClsExtra = <span class="hljs-number">0</span>;<font></font>
	wc-&gt;cbWndExtra = <span class="hljs-number">0</span>;<font></font>
	wc-&gt;hInstance = hInstance;<font></font>
	wc-&gt;hIcon = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
	wc-&gt;hCursor = LoadCursor(<span class="hljs-literal">NULL</span>, IDC_ARROW);<font></font>
	wc-&gt;hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);<font></font>
	wc-&gt;lpszMenuName = <span class="hljs-literal">NULL</span>;<font></font>
	wc-&gt;lpszClassName = szClassName;<font></font>
	wc-&gt;hIconSm = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	<span class="hljs-keyword">if</span>(!RegisterClassEx(wc))<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"     !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">delete</span> wc;<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	hMainWnd = CreateWindow(szClassName, TEXT(<span class="hljs-string">"A Hello1 Application"</span>), WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, <span class="hljs-number">0</span>, CW_USEDEFAULT, <span class="hljs-number">0</span>, (HWND)<span class="hljs-literal">NULL</span>, (HMENU)<span class="hljs-literal">NULL</span>, (HINSTANCE)hInstance, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
	<span class="hljs-keyword">if</span>(!hMainWnd)<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"   !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
	ShowWindow(hMainWnd, nCmdShow);<font></font>
	<span class="hljs-comment">//UpdateWindow(hMainWnd);</span><font></font>
<font></font>
	<span class="hljs-comment">//      </span>
	<span class="hljs-keyword">while</span>(GetMessage(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<font></font>
	{<font></font>
		TranslateMessage(&amp;msg);<font></font>
		DispatchMessage(&amp;msg);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//MessageBox(NULL, TEXT("Application is going to quit."), TEXT("Exit"), MB_OK);</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya sudah melakukan ini berkali-kali, menampilkan jendela berbeda pada model buku ini. </font><font style="vertical-align: inherit;">Dan tiba-tiba saya berpikir: Saya baru saja membaca tentang C ++ baru kemarin! </font><font style="vertical-align: inherit;">Saya dapat menulis kelas saya sendiri untuk menampilkan jendela ini! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak lebih cepat dikatakan daripada dilakukan:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClass</span>				//  <span class="hljs-title">Windows</span>
{</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;					<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List wndList;							<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">static</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">//  ( )</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span><font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">friend</span> List;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WindowClass&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClass();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Struktur kelasnya sepele: beberapa konstruktor dideklarasikan (dengan transfer parameter utama dan tautan ke struktur WNDCLASSEX yang lebih rinci), fungsi CreateWnd mendaftarkan kelas jendela itu sendiri dan membuat jendela, dipanggil dari konstruktor, serta seperangkat fungsi anggota virtual yang melakukan tindakan memproses setiap pesan Windows di dalam prosedur panggilan balik jendela. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anggota data kelas juga minimal: pegangan jendela hWnd; Struktur WNDCLASSEX digunakan untuk membuat kelas; dan bilah judul jendela.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prosedur panggilan balik jendela dinyatakan sebagai statis untuk menghindari secara tidak langsung melewatkan penunjuk ini ke objek kelas dan dengan demikian melanggar perjanjian pada jenis (tanda tangan) fungsi prosedur jendela yang diterima di Windows (ingat bahwa kami tidak akan memanggil fungsi ini sendiri, tetapi Windows, karena parameter dan tipe pengembalian fungsi ini ditentukan secara ketat).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prosedur jendela dan penunjuk ini</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal ini diketahui dari C ++: jika fungsi anggota didefinisikan sebagai statis, sebuah penunjuk ke objek kelas harus diteruskan ke sana secara eksplisit. Namun, kami tidak dapat meneruskan pointer ke objek kelas ke prosedur jendela statis, karena format fungsi ini tidak memungkinkan transfer ini. Dalam hal ini, masalah mendasar muncul: jika ada beberapa objek dari kelas WindowClass, lalu bagaimana satu-satunya prosedur jendela statis tahu dari objek kelas mana pesan itu berasal? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hanya ada satu jalan keluar: Anda harus membuat koneksi ini dengan satu atau lain cara.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows mengidentifikasi jendela dengan pegangan HWND hWnd-nya. Objek kelas yang sesuai dengan jendela ini dapat diidentifikasi oleh pointer ke objek ini. Oleh karena itu, Anda perlu membuat koneksi hWnd &lt;-&gt; pointer ke objek WindowClass. Misalnya, prosedur jendela, yang pada saat yang sama menjadi anggota kelas, dapat memiliki tautan atau penunjuk ke beberapa struktur data statis yang membuat sambungan antara hWnd dan penunjuk objek untuk setiap jendela dan diperbarui setiap kali objek kelas dibuat. Struktur data harus statis sehingga, pertama, dapat diakses dari dalam prosedur jendela statis tanpa pointer ke objek kelas apa pun, dan kedua, itu harus unik untuk semua objek kelas (yang secara logis mengikuti dari tujuannya ), dan ketiga,sehingga masih terikat ke kelas dengan tingkat akses yang sesuai, dan bukan variabel global eksternal.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, setelah mencari tahu bagaimana menggambarkan struktur ini dan mengapa itu diperlukan, tetap mencari tahu seperti apa struktur ini. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dua array dinamis dapat dideklarasikan: satu untuk pegangan jendela HWND, dan yang kedua untuk pointer ke objek WindowClass. Namun, ini bukan solusi terbaik: tidak jelas bagaimana memilih ukuran array, apa skenario untuk menggunakan windows, apakah array akan menjadi hampir kosong jika ukurannya tidak dipilih dengan benar, yang akan menyebabkan memori overrun. Atau, sebaliknya, ketika membuat jendela volumenya habis, perlu untuk meningkatkan ukurannya, dll. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusi yang lebih baik (dan bahkan saya akan mengatakan - ideal) dalam situasi ini adalah daftar ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">daftar!</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Daftar adalah struktur data dinamis yang terdiri dari satu set node yang terhubung secara berpasangan. Setiap node (dalam kasus daftar yang ditautkan ganda) memiliki pointer ke node sebelumnya dan berikutnya dari daftar, serta tambahan data yang disimpan. Dalam situasi kami, setiap simpul jendela sesuai dengan masing-masing jendela, dan data yang berguna adalah pegangan jendela dan penunjuk ke objek kelas WindowClass. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, setiap kali jendela baru dibuat, simpul daftar baru dibuat dan ditambahkan ke ujungnya (menjadi yang terakhir). Saat menutup, node dihapus, dan pointer dari node sebelumnya dan berikutnya disesuaikan satu sama lain untuk mengganti node jarak jauh. Pada saat yang sama, tidak ada memori yang dibanjiri - persis banyak node yang dibuat karena ada windows yang dibuat, dan mereka juga dihapus pada saat yang sama ketika jendela ditutup.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oleh karena itu, anggota statis baru juga harus ditambahkan ke kelas WindowClass:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> List wndList;	<span class="hljs-comment">// ,    </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dan menyatakan hak istimewa untuk memungkinkannya mengakses anggota WindowClass:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">friend</span> List;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Saya tidak akan di sini sekarang memberikan definisi kelas daftar dan kelas simpul, fungsinya, karena ini tidak berlaku langsung ke kelas WindowClass, dan logika implementasi dari kelas ini dikenal dan cukup sepele.) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, prosedur jendela ketika pesan baru tiba dalam kasus itu milik nomor yang diprosesnya, menurut deskriptor jendela hWnd diteruskan ke sana dari Windows, itu mengakses daftar, mencari node di dalamnya sesuai dengan hWnd yang ditentukan, dan, menemukannya, mendapatkan pointer yang diperlukan ke objek dari kelas WindowClass. Kemudian, dengan penunjuk, ia memanggil fungsi virtual yang sesuai dengan pesan yang sedang diproses: untuk kelas yang diganti, fungsi virtual dengan nama yang sama dapat melakukan tindakan lain.</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WindowClass::WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>
</span>{
	<span class="hljs-comment">// 	</span>
	ListElement * pListElem = <span class="hljs-literal">nullptr</span>;<font></font>
<font></font>
	<span class="hljs-keyword">switch</span> (uMsg)<font></font>
	{<font></font>
	<span class="hljs-keyword">case</span> WM_CREATE:<font></font>
		{<font></font>
			<span class="hljs-comment">//lParam      CREATESTRUCT,         WindowClass,  </span>
			<span class="hljs-comment">// (.  WindowClass::CreateWnd)</span>
			CREATESTRUCT *cs = <span class="hljs-keyword">reinterpret_cast</span>&lt;CREATESTRUCT *&gt;(lParam);<font></font>
			WindowClass *p_wndClass = <span class="hljs-keyword">reinterpret_cast</span>&lt;WindowClass *&gt;(cs-&gt;lpCreateParams);<font></font>
			p_wndClass-&gt;hWnd = hWnd;		<span class="hljs-comment">// hWnd   ,    </span>
			<span class="hljs-comment">//    </span><font></font>
			pListElem = wndList.add(p_wndClass);<font></font>
			<span class="hljs-keyword">if</span> (pListElem)<font></font>
				pListElem-&gt;p_wndClass-&gt;OnCreate(hWnd);			<span class="hljs-comment">//  ,   </span><font></font>
		}<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)	<font></font>
			pListElem-&gt;p_wndClass-&gt;OnPaint(hWnd);	<span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_CLOSE:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)<font></font>
			pListElem-&gt;p_wndClass-&gt;OnClose(hWnd);	<span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)<font></font>
			pListElem-&gt;p_wndClass-&gt;OnDestroy(hWnd);  <span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada satu titik halus di sini. Ini menyangkut inisialisasi kelas dan pemrosesan pesan WM_CREATE. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat membuat jendela dengan fungsi CreateWindow, pada saat pemanggilannya, pegangan jendela hWnd belum diketahui: jendela belum dibuat! Oleh karena itu, untuk dapat memanggil OnCreate virtual, Anda perlu mengetahui pointer ke objek kelas. Ini dilakukan dengan agak berisiko melewatkan pointer ini dari fungsi WindowClass :: CreateWnd ke fungsi CreateWindow melalui pointer lParam. Saat memproses WM_CREATE, prosedur jendela menerima pointer ini dari parameter, dengan bantuannya menginisialisasi anggota hWnd di dalam objek, dan kemudian membuat simpul daftar baru untuk jendela ini menggunakan pointer ke objek kelas. Kemudian ia memanggil OnCreate virtual dengan pointer.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk pesan yang tersisa, logika yang dijelaskan di atas dilakukan: mencari node daftar oleh pegangan jendela saat ini yang ditransfer dari Windows, dan kemudian memanggil fungsi virtual yang diinginkan oleh pointer ke objek kelas dari node daftar. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah menyusun program dan memastikan bahwa semuanya bekerja dengan benar, saya, menggosok tangan saya </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada perasaan keagungan saya sendiri</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari pekerjaan yang dilakukan, mulai membaca lebih lanjut. </font><font style="vertical-align: inherit;">Dan di sana di halaman berikutnya fungsi mengubah properti jendela ditunjukkan:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">DWORD <span class="hljs-title">SetClassLong</span><span class="hljs-params">(HWND hWnd, <span class="hljs-keyword">int</span> nIndex, LONG dwNewLong)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya segera memutuskan di tempat untuk membuat jendela baru berdasarkan yang lama:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClass		<span class="hljs-comment">//         </span><font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerived(WindowClassDerived&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas turunan berbeda dari kelas dasar dengan menambahkan penghitung jendela statis, serta mengubah OnCreate, OnPaint dan OnDestroy: fungsi OnCreate mengubah warna latar belakang jendela, OnPaint menampilkan pesan yang berbeda, dan OnDestroy mengurangi penghitung jendela statis. </font><font style="vertical-align: inherit;">Semuanya sangat sederhana dan jelas. </font><font style="vertical-align: inherit;">Dirakit dan diluncurkan. </font><font style="vertical-align: inherit;">Teks pesan menjadi berbeda ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... tetapi warna jendelanya tidak berubah.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstruktor virtual</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya kemudian menyadari bahwa saya telah menginjakkan kaki di atas es tipis. </font><font style="vertical-align: inherit;">Tidak semua nuansa dijelaskan dalam bahan dasar buku-buku utama. </font><font style="vertical-align: inherit;">Salah satunya adalah konstruktor virtual. </font><font style="vertical-align: inherit;">Saya berpikir bahwa memanggil fungsi virtual dari kelas turunan dari konstruktor persis sama dengan tempat lain di program. </font><font style="vertical-align: inherit;">Ternyata ini tidak bisa dilakukan.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalahnya adalah bahwa fungsi virtual yang dipanggil dari konstruktor disebut sebagai bukan virtual: hanya objek dari kelas dasar yang dibuat, dan kemudian tidak sampai akhir, dan objek turunan belum dibuat, dan tabel fungsi virtual belum dibuat. Dalam kasus kami, kami mendapatkan rantai: konstruktor turunan -&gt; konstruktor dasar -&gt; CreateWnd -&gt; CreateWindow -&gt; prosedur jendela -&gt; OnCreate, yaitu, OnCreate sebenarnya dipanggil dari konstruktor. Objek yang diturunkan belum dibuat, oleh karena itu, OnCreate dipanggil untuk kelas dasar! Redefinisi dalam turunannya, ternyata, tidak masuk akal! Apa yang harus dilakukan?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diketahui dari C ++ bahwa setiap fungsi yang di-override dapat dipanggil dengan nama lengkapnya: class_name :: function_name. Nama kelas bukan hanya nama: itu mengidentifikasi dirinya sendiri, pada kenyataannya, jenis objek. Juga diketahui dari C ++ bahwa kelas (dan fungsi) dapat dibuat templat (templat) dengan mengirimkannya (tipe) sebagai parameter. Oleh karena itu, jika Anda membuat templat fungsi prosedur jendela dan meneruskan tipe kelas turunannya dengan cara tertentu, Anda dapat memanggil fungsi yang ditimpa yang diinginkan secara langsung di konstruktor dari </font><font style="vertical-align: inherit;">kelas </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dasar</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berhenti, berhenti, berhenti !!! Anda tidak dapat melakukan hal yang sama !!! Kelas turunan belum dibuat, datanya belum diinisialisasi: fungsi apa yang akan Anda panggil di sini? </font></font><br>
<s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda tidak bisa, tetapi benar-benar ingin, maka Anda bisa.</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, saya tidak bertujuan untuk menarik seluruh kelas yang diturunkan. </font><font style="vertical-align: inherit;">Saya bermaksud memanggil </font><font style="vertical-align: inherit;">fungsi WinAPI </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pihak ketiga yang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sepenuhnya </font><font style="vertical-align: inherit;">, yang tidak ada hubungannya dengan kelas. </font><font style="vertical-align: inherit;">"Tapi ini bisa dilakukan dengan cara yang sangat berbeda, dan jauh lebih mudah!" </font><font style="vertical-align: inherit;">- kamu bilang. </font><font style="vertical-align: inherit;">Iya. </font><font style="vertical-align: inherit;">Bisa. </font><font style="vertical-align: inherit;">Dan saya akan menulis tentang itu di akhir artikel. </font><font style="vertical-align: inherit;">Tetapi pada saat itu saya membuang semua ini dan berkonsentrasi pada sisi teknis murni dari pertanyaan: tetapi masih, apakah mungkin, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada prinsipnya,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk memanggil sesuatu dari turunan dalam konstruktor kelas dasar? </font><font style="vertical-align: inherit;">Itu minat murni olahraga, jika Anda suka. </font><font style="vertical-align: inherit;">Saya tidak memikirkan sisi praktis apa pun pada saat itu. </font><font style="vertical-align: inherit;">Itu adalah tugas yang tidak sepele, dan saya bertanya-tanya apakah saya bisa menyelesaikannya.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas Templat Jendela - Metode 1</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, kesulitannya adalah: bagaimana cara meneruskan jenis kelas turunan ke prosedur jendela? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak ingin menjadikan seluruh kelas dasar WindowClass sebagai kelas templat sekaligus: untuk setiap kelas turunan, kelas dasarnya akan dihasilkan. Selain itu, karena WindowClass akan menjadi templat, baik daftar node dan daftar itu sendiri juga harus dibuat templat: mereka memiliki pointer ke objek kelas, dan untuk menggunakan pointer ini, mereka harus tahu tipenya, yaitu, WindowClass dan apa parameternya dengan . Pada saat mendefinisikan kelas daftar dan kelas simpul, ini tidak diketahui, oleh karena itu, tipe ini juga harus dilewatkan sebagai parameter (dari WindowClass). Oleh karena itu untuk setiap kelas turunan akan membuat daftar sendiri sesuai dengan </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kelas turunan ini</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dan hanya dia)! Dan sekarang Anda tidak dapat menempatkan pointer ke kelas dasar yang terkait dengan turunan yang berbeda ke dalam satu array: mereka memiliki tipe yang berbeda.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi saya mulai mencari cara untuk lulus jenis kelas turunan, tanpa parameterisasi seluruh kelas. Tipe dapat dikirimkan ke kelas dasar hanya melalui konstruktor: ini adalah satu-satunya fungsi yang diakses saat membuat objek. Oleh karena itu, harus boilerplate. Namun, ternyata dia jelas tidak bisa menentukan parameter template: itu akan terlihat seperti melewatkan parameter ke kelas template itu sendiri, dan bukan konstruktornya. Oleh karena itu, tipe hanya dapat disimpulkan dari parameter yang diteruskan ke konstruktor. Tetapi saya tidak ingin menambahkan parameter konstruktor khusus, yang hanya berfungsi untuk inferensi tipe: mengacaukan daftar argumen dengan parameter utilitas murni. Dan jika pengguna lupa untuk mentransfernya, misalnya,melalui setidaknya nolptr sepele (DerivedClass *)? Ini belum menakutkan - kompiler akan menampilkan pesan kesalahan bahwa kelas tidak dapat dipakai. Lebih buruk lagi, jika pengguna membuat hierarki kelas dan meneruskan pointer ke kelas turunan yang salah: semuanya akan benar dari sudut pandang kompilasi, namun, kami akan mendapatkan program yang salah bekerja dengan kesalahan yang tidak bisa dipahami.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Singkatnya, kesalahan perhitungan desain ini adalah solusi semacam itu. </font><font style="vertical-align: inherit;">Dengan demikian, tanggung jawab untuk instantiasi yang benar bahkan tidak ditransfer ke pencipta kelas turunan, tetapi kepada orang yang akan menggunakannya! </font><font style="vertical-align: inherit;">Dan dia bisa bukan mimpi, atau semangat tentang nuansa seperti itu dan dengan tulus tidak mengerti di mana kesalahannya. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada akhirnya, menyerah, saya memutuskan namun, tanpa mengubah parameter konstruktor, untuk membuat parameter WindowClass itu sendiri dan pada saat yang sama daftar dan daftar kelas simpul yang terkait. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas templat WindowClass:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndCls</span>&gt; <span class="hljs-title">struct</span> <span class="hljs-title">ListElement</span>				// 
{</span>
	<span class="hljs-comment">// </span>
	HWND hWnd;					<span class="hljs-comment">//  Windows</span>
	WindowClass&lt;WndCls&gt; *p_wndClass;	<span class="hljs-comment">//    WindowClass</span><font></font>
<font></font>
	ListElement *pNext;			<span class="hljs-comment">//    </span>
	ListElement *pPrev;			<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClass</span>				//  <span class="hljs-title">Windows</span>
{</span>
	<span class="hljs-keyword">using</span> WndProcCallback = LRESULT (*)(HWND, UINT, WPARAM, LPARAM);		<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:						<span class="hljs-comment">//   !</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;				<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List&lt;WndCls&gt; wndList;					<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//	</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span>
	<span class="hljs-function"><span class="hljs-keyword">static</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">//  ( )</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T, <span class="hljs-keyword">typename</span> </span>= T::OnCreate&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd, T *p_wndClass)</span>		<span class="hljs-comment">//! .  FirstWin32CPP_DerivedTemplate2</span>
	</span>{
		<span class="hljs-comment">//  OnCreate   WndCls,  OnCreate   </span><font></font>
		T::OnCreate(hWnd);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd, T *p_wndClass)</span>		<span class="hljs-comment">//  OnCreate         </span>
	</span>{<font></font>
		p_wndClass-&gt;OnCreate(hWnd);			<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">friend</span> List&lt;WndCls&gt;;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WindowClass&amp;);			<span class="hljs-comment">// </span><font></font>
	<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClass();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas turunan:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClass&lt;WindowClassDerived&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WindowClassDerived(WindowClassDerived&amp;);		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prosedur jendela, menjadi anggota templat dari kelas templat dan memiliki akses ke jenis lulus dari kelas turunan, memanggil OnCreate dari kelas turunan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi kita secara alami datang ke templat CRTP. Di sini ternyata dengan sendirinya. Baru kemudian saya mengetahui bahwa desain ini adalah template terkenal dengan nama yang sesuai. Tetapi kemudian saya tidak tahu ini, dan bagi saya sepertinya saya menerimanya untuk pertama kali.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya segera menyadari bahwa ini hanya setengah dari solusi. </font><font style="vertical-align: inherit;">Saya dapat dengan mudah ingin membuat kelas lain berdasarkan turunan ini. </font><font style="vertical-align: inherit;">Dan itu dia: itu bukan pelat baja dan tidak lagi menerima parameter apa pun. </font><font style="vertical-align: inherit;">Jadi saya datang dengan ide untuk meneruskan kelas turunan kedua melalui turunan pertama ke basis. </font><font style="vertical-align: inherit;">(Es tipis di bawah kakiku mulai retak ... Aku sudah pergi ke tempat di mana tidak ada kembali.) Tetapi jika aku melakukannya sekali, aku bisa melakukannya sebanyak yang aku suka: bahkan jika aku memiliki sepuluh kelas turunan, aku dapat mengambil kesepuluh berturut-turut ( yang paling terakhir) untuk meneruskan rantai ke basis, dan akan memanggil fungsi turunan terakhir ini yang saya butuhkan (dan, secara umum, yang intermediate, jika diinginkan). </font><font style="vertical-align: inherit;">Tugasnya jelas. </font><font style="vertical-align: inherit;">Yang tersisa hanyalah melakukannya.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jendela Kelas Parameter - Metode 2</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada run kedua, saya mengatur sendiri tiga tugas:</font></font><br>
<ul>
<li>-     ;</li>
<li>   ;</li>
<li>   ,   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, untuk memenuhi persyaratan ini, Anda masih harus membuat templat untuk perancang dan masih menambahkan parameter khusus untuknya. Namun, ini berarti pelanggaran terhadap persyaratan lain. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa solusinya di sini? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat membagi WindowClass kelas dasar asli menjadi dua komponen: WindowClass itu sendiri (sebut saja WindowClassBase sekarang), yang merupakan fondasi tak tergoyahkan tunggal, dan melengkapi kelas turunannya (yang masih bisa disebut WindowClass nama asli yang sama). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas komplementer bertanggung jawab atas implementasi OnCreate, dan, di samping itu, dapat diparameterisasi secara keseluruhan. Dan dia di konstruktornya akan meneruskan tipe yang diteruskan kepadanya melalui parameter khusus ke konstruktor dari kelas WindowClassBase.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimanapun, di WindowClassBase relatif terhadap sumber sekarang Anda harus membuat beberapa perubahan. Pertama, selain benar-benar menghapus OnCreate dari itu, Anda harus menambahkan anggota pointer ke kelas yang melengkapi itu (dan, di masa depan, turunan dari itu), serta fungsi panggilan yang memanggil OnCreate oleh pointer ini: kita tidak bisa memanggil pointer ke basis, karena OnCreate tidak lagi di dalamnya, dan OnCreate dari kelas-kelas yang saling melengkapi dan diturunkan darinya lebih baik menyebutnya dengan pointer yang benar ke kelas yang diinginkan, daripada mencoba sesuatu dengan pointer ini dari basis. Pada akhirnya, parameter khusus dari konstruktor WindowClassBase akan dibutuhkan tidak hanya untuk inferensi tipe, tetapi juga untuk menyimpan dan kemudian memanggil kelas yang diperlukan melalui OnCreate. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sayangnya, jenis pointer ini harus dibuat batal:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kelas bukan templat, dan Anda tidak bisa memberi tahu kompiler untuk membuat pointer dengan tipe yang tidak dikenal;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">banyak turunan diwarisi dari kelas dasar, mereka semua memiliki tipe yang berbeda - tipe pointer apa yang harus saya gunakan?</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada akhirnya, saya hanya menyatakannya dalam gaya C: dalam situasi aneh apa pun, gunakan pointer untuk membatalkan. </font><font style="vertical-align: inherit;">Pointer secara fisik disimpan sebagai tidak bertipe, tetapi pada saat panggilan, OnCreate dilemparkan ke jenis kelas yang dipanggil. </font><font style="vertical-align: inherit;">Ini dilakukan dalam fungsi panggilan templat khusus yang dimiliki oleh WindowClassBase dan yang jenis parameternya diketahui pada saat panggilan:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd)</span>
</span>{
	<span class="hljs-comment">//  OnCreate   WndCls,  OnCreate   </span>
	<span class="hljs-keyword">if</span> (p_drvWndCls)<font></font>
		(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;WndCls::OnCreate(hWnd);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Awalnya, std :: true_type atau std :: false_type digunakan sebagai parameter kedua untuk memilih opsi yang diinginkan untuk mengganti fungsi. Menggunakan metode SFINAE, dipastikan pada tahap kompilasi apakah kelas WndCls memiliki fungsi anggota OnCreate. Jika ya, maka versi fungsi di atas dipanggil. Jika tidak, maka panggilan ke OnCreate dibuat dalam bentuk:</font></font><br>
<pre><code class="cpp hljs">(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;OnCreate(hWnd);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian ternyata SFINAE tidak diperlukan: kelas yang melengkapi WindowClassBase, dalam hal apa pun, memiliki fungsi anggota OnCreate, oleh karena itu, bahkan jika kelas parameter WndCls yang disahkan tidak memiliki OnCreate yang ditentukan di dalamnya, ia berada di salah satu kelas dasar yang berkaitan dengan itu , dan memeriksa akan memberikan yang benar dalam semua kasus. Jika, dengan suatu keajaiban, kelas pelengkap diubah sehingga OnCreate dihapus darinya, dan itu juga tidak ada di semua kelas turunannya, maka tidak ada gunanya memohonnya dengan cara kedua: kode seperti itu tidak akan dikompilasi. Oleh karena itu, pada akhirnya, opsi di atas diberikan di sini.)</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Logika menerima dan menggunakan tipe kelas dasar di WindowClassBase cukup sederhana: tipe ini berasal dari pointer ke objek kelas turunan yang diteruskan ke konstruktor WindowClassBase, pointer ini disimpan dalam konstruktor ini, dan pointer ke prosedur jendela templat dipakai oleh tipe yang diteruskan, dan LaunchOnCreate di atas diakses . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, kelas WindowClassBase sekarang akan terlihat seperti ini:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassBase</span>				//  <span class="hljs-title">Windows</span>
{</span>
<span class="hljs-keyword">protected</span>:						<span class="hljs-comment">//   !</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;				<span class="hljs-comment">// </span>
	<span class="hljs-keyword">void</span> *p_drvWndCls;								<span class="hljs-comment">//   ,    (..  -  </span>
													<span class="hljs-comment">//,   ( )   , ..   void</span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List wndList;							<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span><font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd)</span>
	</span>{
		<span class="hljs-comment">//  OnCreate   WndCls</span>
		<span class="hljs-keyword">if</span> (p_drvWndCls)<font></font>
			(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;WndCls::OnCreate(hWnd);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">friend</span> List;
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">friend</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//     </span>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassBase(WindowClassBase&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassBase();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nah, ini kode untuk konstruktor terpendek:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase::WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle)</span>
</span>{
	<span class="hljs-comment">// ,   ,   wc</span>
	<span class="hljs-comment">// : p_wndClass -    ,        , wc -    </span>
	<span class="hljs-comment">//    Windows, szWndTitle -   </span><font></font>
<font></font>
	WindowClassBase::wc = wc;<font></font>
	WindowClassBase::wc.lpfnWndProc = WndProc&lt;WndCls&gt;;<font></font>
	WindowClassBase::szWndTitle = szWndTitle;<font></font>
<font></font>
	p_drvWndCls = p_wndClass;		<span class="hljs-comment">//    ,   OnCreate()      WM_CREATE</span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	CreateWnd(WindowClassBase::wc, <span class="hljs-literal">false</span>, szWndTitle);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di dalam prosedur jendela, panggilan ke LaunchOnCreate adalah sebagai berikut:</font></font><br>
<pre><code class="cpp hljs">p_wndClass-&gt;LaunchOnCreate&lt;WndCls&gt;(hWnd);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dia memutuskan untuk menghapus prosedur jendela itu sendiri dari kelas di luar, menyatakan itu istimewa di kelas WindowClassBase. Mungkin ini tidak masuk akal: apa bedanya, di mana menghasilkan instantiasinya - di luar atau di dalam kelas? Segmen kode adalah satu! Meskipun, saya akui, dari sudut pandang enkapsulasi yang sama, mungkin Anda masih harus membiarkannya statis di dalam kelas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masih mendefinisikan kelas komplementer:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClass</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase			<span class="hljs-comment">//,  WindowClassBase    </span><font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">this</span>, hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">this</span>, wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas memiliki konstruktor yang terlihat sama dengan WindowClass asli sebelum membelah, yaitu, tanpa parameter khusus, dan parameter khusus ini dihasilkan secara internal ketika konstruktor WindowClassBase diakses dengan melewati pointer ini. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WindowClass ini dalam bentuk ini hampir setara dengan WindowClass asli. </font><font style="vertical-align: inherit;">Dengan demikian, itu tidak mendukung warisan dengan penggantian OnCreate. </font><font style="vertical-align: inherit;">Namun, ini adalah titik awal untuk mendukung warisan (seperti yang akan ditunjukkan di bawah). </font><font style="vertical-align: inherit;">Dalam bentuk ini:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kelas dasar WindowClassBase bukan generik dalam dirinya sendiri, yang berarti bahwa itu akan menjadi satu-satunya untuk semua kelas turunan, apa pun itu; </font><font style="vertical-align: inherit;">Daftar untuk memastikan bahwa semua pesan Windows lainnya diproses dengan benar juga akan menjadi satu-satunya;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konstruktor WindowClass tidak memiliki parameter khusus tambahan.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, dua dari tiga persyaratan terpenuhi. </font><font style="vertical-align: inherit;">Masih berurusan dengan yang terakhir: dengan warisan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaining tipe kelas yang diturunkan di WindowClassBase, tipe kontrol</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memulainya, kita akan mempertimbangkan pewarisan satu kali, ketika logika inisialisasi WindowClass tidak cocok untuk kita, dan kita ingin mengubahnya melalui penciptaan kelas turunan (untuk saat ini setidaknya satu). </font><font style="vertical-align: inherit;">Apa yang perlu diubah di WindowClass untuk memastikan ini? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Varian baru dari kelas komplementer menjadi boilerplate. </font><font style="vertical-align: inherit;">Ini tidak menakutkan, karena sebenarnya tidak mengandung data apa pun, tetapi hanya fungsi dan konstruktor OnCreate:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerWndCls *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerWndCls *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas ini mengambil parameter tipe DerWndCls dan, dengan mengkonversi pointer ini, meneruskannya ke WindowClassBase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan static_cast. Ini penting karena konversi saya awalnya ditulis dalam gaya C seperti ini:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase((DerWndCls *)<span class="hljs-keyword">this</span>, hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase((DerWndCls *)<span class="hljs-keyword">this</span>, wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}	<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah saya menerjemahkannya di mana saja ke static_cast, setengah dari kode (lihat di bawah) tidak dikompilasi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini juga merupakan titik yang rumit: konversi dilakukan pada tahap kompilasi, tetapi kelas ini sendiri memiliki fungsi OnCreate, dan setelah konversi, DerWndCls dapat digunakan untuk memanggil OnCreate dari kelas DerWndCls. </font><font style="vertical-align: inherit;">Ini adalah perbedaan dari kasus konversi yang dijelaskan di atas di dalam WindowClassBase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, Anda dapat membuat kelas tertentu WindowClassDerived, menimpa OnCreate di dalamnya dan instantiate dengan WindowClassTemplate yang dijelaskan di atas, sekali lagi menerapkan templat pengulangan yang sama dan asli yang diindikasikan di awal artikel:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;WindowClassDerived&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerived(WindowClassDerived&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan OnCreate dari WindowClassDerived ini akan dipanggil di dalam WindowClassBase, sesuai kebutuhan!</font></font><br>
<pre><code class="cpp hljs">WindowClassDerived::WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle) : WindowClassTemplate(hInstance, szClassName, szWndTitle)<font></font>
{<font></font>
	usiWndNum++;		<span class="hljs-comment">//    </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi ini adalah warisan satu kali. </font><font style="vertical-align: inherit;">Dalam kasus multiple inheritance, alih-alih WindowClassDerived, pada gilirannya, Anda harus mendeklarasikan templat baru, berpotensi membawa kelas ke level yang lebih tinggi dalam hierarki dan meneruskannya ke WindowClassTemplate. </font><font style="vertical-align: inherit;">Saya secara khusus menyoroti dua poin utama:</font></font><br>
<ol>
<li><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas host </font><b><font style="vertical-align: inherit;">berpotensi</font></b><font style="vertical-align: inherit;"> naik dalam hirarki. </font><font style="vertical-align: inherit;">Ini berarti bahwa ia mungkin tidak menerima kelas apa pun, yaitu, itu sendiri adalah kelas paling atas dari hierarki sehingga suatu objek dapat dibuat dari itu.</font></font></li>
<li><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter </font><b><font style="vertical-align: inherit;">transmisi</font></b><font style="vertical-align: inherit;"> WindowClassTemplate. </font><font style="vertical-align: inherit;">Ini berarti bahwa argumen templat yang diterima harus diteruskan lebih jauh dari kelas ke kelas melalui seluruh rantai pewarisan ke bagian paling bawah, di WindowClassTemplate dan dari sana ke WindowClassBase.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yaitu, di satu sisi, kelas harus berupa templat dan mengambil kelas tertentu sebagai parameter. Di sisi lain, ia harus memantau situasi bahwa itu sendiri adalah kelas yang terbatas (pada saat instantiation), dan instantiate kelas dasar dengan sendirinya, dan bukan oleh tipe yang ditransfer. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan semua ini, saya ingin itu dilakukan secara otomatis oleh kompiler: mendefinisikan kelas baru berdasarkan yang sudah dibuat tidak akan memerlukan modifikasi yang terakhir - maka seluruh esensi warisan-polimorfisme hilang. Yaitu: Saya membuat kelas yang saat ini berada di puncak hierarki, tapi </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mungkin</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kelas baru akan dibuat berdasarkan ini, yang akan menggantikan yang sekarang tanpa mengubah definisinya. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana cara mengimplementasikan fungsi ini?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memecahkan masalah otomatisasi dan pengambilan keputusan yang cerdas, varian argumen default untuk templat menyarankan sendiri: jika kelas yang dibuat saat ini adalah yang teratas dan parameter templat tidak diteruskan ke sana, maka kita harus menetapkan parameter ini untuk itu. Ini dilakukan dengan menggunakan argumen default. Kemudian muncul pertanyaan-pertanyaan berikut: bagaimana memilihnya dan bagaimana menghubungkannya dengan situasi parameter yang diteruskan secara eksplisit, serta mentransfer sendiri jika parameter tersebut tidak dilewati? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sayangnya, Anda tidak dapat menulis kelas yang Anda tentukan sendiri sebagai parameter default. Kompiler tidak akan melewatkan kode formulir:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">WindowClassDerived</span>&lt;&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;DerWndCls&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dia melaporkan bahwa ketergantungan tipe rekursif terlalu kompleks. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita pergi ke sisi lain. </font><font style="vertical-align: inherit;">Mari kita perkenalkan kelas fiktif yang tidak melakukan apa-apa secara fungsional dan tidak menyimpan apa pun, memainkan peran hanya colokan tiruan dan memberi sinyal kepada kompiler bahwa dalam hal kemunculannya tidak ada yang akan ditransfer “dari atas”:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};	<span class="hljs-comment">//-,     </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan dalam argumen default, gantikan lelucon ini untuk diri kita sendiri:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;DerWndCls&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan opsi ini, dalam situasi dengan argumen default, kelas ini diteruskan ke WindowClassTemplate. </font><font style="vertical-align: inherit;">Kelas thisclass tidak memiliki fungsi anggota OnCreate, jadi opsi ini tidak bisa dikompilasi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita coba untuk memperkenalkan parameter kontrol bantu kedua, atas dasar itulah kita akan memutuskan tipe mana yang akan diteruskan. </font><font style="vertical-align: inherit;">Untuk melakukan ini, tentu saja, Anda perlu mengubah WindowClassTemplate, misalnya, seperti ini:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassControlBaseTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
	<span class="hljs-comment">//  ControlType == thisclass,      DerWndCls,    ,   WindowClassBase</span>
	<span class="hljs-comment">//  ControlType != thisclass,    ControlType,        ( </span>
	<span class="hljs-comment">//    ControlType     )</span>
	<span class="hljs-keyword">using</span> DerivedWndClassType = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;ControlType, thisclass&gt;::value, DerWndCls, ControlType&gt;;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassControlBaseTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassControlBaseTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}	<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak satu jenis ditransmisikan ke sana, tetapi dua. Berdasarkan kombinasi dari kedua jenis ini, tipe terakhir ditentukan dengan menggunakan alat &lt;type_traits&gt;: std :: conditional_t ​​dan std :: is_same. Tipe ini yang diteruskan ke WindowClassBase. Logika pemilihan dijelaskan dalam komentar: jika kelas ini diteruskan ke ControlType, maka kita pilih DerWndCls, jika tidak ControlType itu sendiri dipilih. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita membangun templat yang menggunakannya saat mewarisi:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndClsDerivedTemplateClass</span> :</span> <span class="hljs-keyword">public</span> WindowClassControlBaseTemplate&lt;WndClsDerivedTemplateClass&lt;DerWndCls&gt;, ControlType&gt;		<span class="hljs-comment">//      </span><font></font>
{<font></font>
<span class="hljs-keyword">protected</span>:
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;		<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WndClsDerivedTemplateClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WndClsDerivedTemplateClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WndClsDerivedTemplateClass(WndClsDerivedTemplateClass&amp;);	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WndClsDerivedTemplateClass() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parameter pertama diinisialisasi secara default melalui kelas ini, dan ControlType dihitung berdasarkan DerWndCls sendiri: jika DerWndCls = thisclass, maka ControlType: = thisclass, jika tidak ControlType: = DerWndCls (penugasan gaya Pascal yang ditentukan secara spesifik untuk membedakan dari perbandingan). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, kelas WndClsDerivedTemplateClass itu sendiri, diparameterisasi oleh DerWndCls, akan diteruskan bersama dengan tipe kontrol yang dikomputasi (pada tahap kompilasi).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita membuat objek kelas ini, yaitu, WndClsDerivedTemplateClass itu sendiri adalah puncak hierarki, maka DerWndCls = ControlType = thisclass, dan kemudian &lt;WndClsDerivedTemplateClass, thisclass&gt; berlalu. Fakta bahwa WndClsDerivedTemplateClass adalah parameterisasi oleh dummy tidak masalah - tipe ini, dan memang setiap DerWndCls yang dilewati, tidak digunakan di dalam kelas dengan cara apa pun: tidak ada objek yang dibuat darinya dan tidak ada fungsi yang dipanggil melaluinya. Oleh karena itu, secara resmi WndClsDerivedTemplateClass dapat dipakai secara harfiah dengan apa saja - tipe parameter hanya berfungsi untuk meneruskan lebih jauh di sepanjang garis warisan. Tapi di sini, alih-alih DerWndCls, WndClsDerivedTemplateClass &lt;thisclass atau jenis lainnya&gt; diteruskan, itu penting: WndClsDerivedTemplateClass memiliki fungsi OnCreate,yang akan dipanggil di dalam WindowClassBase.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan opsi ini, kelas ini datang ke WindowClassControlBaseTemplate di tempat ControlType, dan tipe terakhir ditampilkan sebagai DerWndCls = WndClsDerivedTemplateClass, yang memiliki fungsi OnCreate yang diperlukan. Itulah yang kita butuhkan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang pertimbangkan opsi ketika kelas baru dibangun berdasarkan WindowClassControlBaseTemplate (pewarisan lebih lanjut):</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal ini, di WndClsDerivedTemplateClass, sesuatu selain kelas ini menggantikan DerWndCls, dan ControlType, melihat perbedaan ini, mengambil nilai yang diteruskan ke DerWndCls. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian di WindowClassControlBaseTemplate opsi parameterisasi berikut berlaku: &lt;WndClsDerivedTemplateClass &lt;WindowClassDerivedTemplateNext&gt;, WindowClassDerivedTemplateNext&gt;. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di WindowClassControlBaseTemplate, pada gilirannya, karena ControlType! = Thisclass, ControlType itu sendiri digunakan, yang sama dengan WindowClassDerivedTemplateNext, yang merupakan kelas yang tepat untuk memilih OnCreate. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sepintas, dengan skema seperti itu, semuanya tampak baik. Tapi ini tidak benar. Kami membangun kelas lain berdasarkan yang terakhir:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext2</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedTemplateNext&lt;WindowClassDerivedTemplateNext2&lt;DerWndCls&gt;&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di WindowClassDerivedTemplateNext, WindowClassDerivedTemplateNext2 akan menggantikan DerWndCls. ControlType juga keluaran sebagai WindowClassDerivedTemplateNext2. Kemudian, WindowClassDerivedTemplateNext </font><font style="vertical-align: inherit;">&lt;WindowClassDerivedTemplateNext2&gt; </font><font style="vertical-align: inherit;">akan diteruskan ke </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WndClsDerivedTemplateClass</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan ControlType akan menampilkan WindowClassDerivedTemplateNext &lt;Berikutnya &lt;WindowClassDerivedTemplateNext2&gt; di dalamnya. Selanjutnya, nilai-nilai yang sama akan ditransfer ke WindowClassControlBaseTemplate, dan di sana, bukan WindowClassDerivedTemplateNext2 yang benar &lt;WindowClassDerivedTemplateNext&gt;, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassDerivedTemplateNext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;WindowClassDerivedTemplateNextTerplDefileTerverDiveTerverDefileTerverDefileDerverTimeText </font><font style="vertical-align: inherit;">digunakan </font><b><font style="vertical-align: inherit;">sebagai</font></b><font style="vertical-align: inherit;"> fungsi</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mengingatkan Anda bahwa dengan skema ini mewarisi dan melewati parameter, jenis </font><font style="vertical-align: inherit;">kelas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itu sendiri</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang datang ke WindowClassControlBaseTemplate sebagai hasilnya, adalah penting, dan bukan apa parameternya. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oleh karena itu, agar tipe yang memanggil OnCreate ditampilkan dengan benar, Anda perlu mengubah definisi kelas WindowClassDerivedTemplateNext:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;, ControlType&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal ini, maka dalam WndClsDerivedTemplateClass, nilai yang benar sama dengan WindowClassDerivedTemplateNext2 akan diteruskan ke ControlType alih-alih ditampilkan di sana dengan nilai yang salah. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, kelas terakhir yang kita bangun tidak boleh melewati ControlType, yang memungkinkan basis terdekat untuk mengeluarkannya secara independen, dan basis ini dan semua yang mendasarinya harus melewati ControlType secara eksplisit, melarang output otomatisnya ke nilai yang salah. Pendekatan ini menyiratkan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perubahan dalam</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definisi kelas dasar terdekat, yang hanya mungkin jika kita memiliki kode sumber yang tersedia atau kita membangunnya sendiri sebelumnya.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita lupa melakukan ini dan melanggar aturan ini, maka ketika menggunakan static_cast kita mendapatkan kesalahan kompilasi, dan jika kita mengonversi pointer gaya-C di dalam WindowClassControlBaseTemplate, kita mendapatkan program yang </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">salah</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bekerja. Misalnya, jika kita mencoba membuat objek untuk kelas</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;, ControlType&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
maka kompiler akan memberikan kesalahan: itu tidak akan dapat mengkonversi tipe pointer di dalam WindowClassControlBaseTemplate karena fakta bahwa jenis itu tidak benar dan tidak dapat dikonversi untuk (karena kita akan membuat objek kelas WindowClassDerivedTemplateNext, kita menganggap untuk itu kelas WindowClassDerivedTemplateNext itu sendiri, kita asumsikan kelas Window itu berada di atas kelas itu. hierarki, dan dalam hal ini, seperti yang ditunjukkan di atas, ControlType tidak boleh diteruskan). Tanpa static_cast, kode akan dikompilasi dan panggil OnCreate dari kelas yang salah. Namun, menghapus transmisi ControlType membuat program dikompilasi lagi.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada akhirnya, semua ini terlalu rumit, tidak dapat diandalkan, dan membutuhkan ketersediaan kode sumber dari semua kelas. </font><font style="vertical-align: inherit;">Selain itu, kita hanya bisa membuat objek dari kelas turunan terakhir, dan salah satu kelas dasar tidak dapat dibuat karena transfer ControlType (atau kita bisa jika pointer dilewatkan dalam gaya C, tetapi objek ini akan diinisialisasi secara tidak benar). </font><font style="vertical-align: inherit;">Kami membutuhkan solusi yang berbeda, lebih sederhana dan lebih dapat diandalkan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Template variabel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, varian di atas warisan templat dan meneruskan jenis objek yang dibuat ke kelas WindowClassBase, di mana jendela dibuat dan OnCreate disebut, memiliki kelemahan serius. Kami membutuhkan opsi lain yang lebih andal dan efisien. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 11 memperkenalkan jenis templat baru: templat dengan jumlah variabel argumen, atau templat variabel. Parameternya adalah urutan jenis yang sebelumnya tidak diketahui panjangnya. Alih-alih manipulasi berisiko dengan tipe kontrol dalam contoh sebelumnya, saya memutuskan untuk pergi ke arah lain: untuk menghindari situasi di mana kelas menengah dalam hierarki menggantikan kelas induk dalam hierarki melalui parameterisasi yang salah (dalam contoh di atas adalah </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassDerivedTemplateNext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;WindowClassDerivedTemplateNext2&gt;), Anda biasanya dapat menyingkirkan jenis parameterisasi ini dengan hanya menempatkan kelas-kelas ini secara berurutan di samping satu sama lain. Misalnya, dengan tiga pewarisan berturut-turut dalam parameter template, daftar berikut pada akhirnya akan dibentuk: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&lt;WndCls3 &lt;&gt;, WndCls2 &lt;&gt;, WndCls1 &lt;&gt;&gt; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memproses daftar ini, lebih tepatnya, salah satu elemen terakhirnya (tergantung pada bagaimana Anda menyusunnya), Anda dapat mengekstrak kelas yang diinginkan dalam hierarki dan bekerja dengannya. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus ini, alih-alih templat WindowClassTemplate dan WindowClassControlBaseTemplate yang dijelaskan sebelumnya, yang paling dekat dengan root WindowClassBase dan membentuk dasar untuk semua warisan lainnya, Anda harus menulis kelas templat variabel baru. Dalam versi yang paling sederhana, akan seperti ini:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,      </span>
<span class="hljs-keyword">template</span>&lt;class... Classes&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadicTemplate</span>;</span>		<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-comment">//,          </span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>, <span class="hljs-title">class</span>... <span class="hljs-title">OtherWindowClasses</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassVariadicTemplate</span>&lt;DerWndCls, OtherWindowClasses...&gt; :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
	<span class="hljs-comment">//      :    - DerWndCls</span>
	<span class="hljs-keyword">using</span> DerivedWndClassType = DerWndCls;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassVariadicTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassVariadicTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, uraian umum templat kelas tanpa isi dideklarasikan. Kemudian, spesialisasinya ditentukan, di mana jenis pertama dipisahkan dari yang lain. Dialah yang menarik bagi kita. Ini berlaku untuk kasus ketika setiap kelas berikutnya menempatkan dirinya </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di akhir</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> daftar parameter </font><font style="vertical-align: inherit;">ketika memindahkan rantai hierarki ke WindowClassBase </font><font style="vertical-align: inherit;">. Maka kelas yang kita butuhkan adalah di awal, dan sangat mudah untuk memisahkannya dari yang lain. Anda dapat melakukannya secara berbeda: setiap kelas baru akan menempatkan dirinya </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di awal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">daftar opsi templat. Maka kelas di puncak hierarki akan menjadi yang terakhir dalam daftar, dan mengekstraksi dari sana jauh lebih sulit. Dalam kasus khusus ini, kedua pendekatan ini benar-benar identik, tetapi yang pertama jauh lebih mudah untuk diterapkan (termasuk selama kompilasi - Anda tidak harus memproses seluruh daftar dengan mengekstraksi elemen terakhir dari itu), dan dialah yang diberikan di atas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Elemen pertama, yang merupakan kelas tertinggi dalam hierarki, diambil dari daftar dan diteruskan ke WindowClassBase. Jika OnCreate didefinisikan untuk itu, itu akan dipanggil. Kalau tidak, OnCreate dari kelas dasar terdekat akan dipanggil sehubungan dengan itu. Jika daftar parameter variabel kosong (kami mencoba membuat objek dari WindowClassVariadicTemplate), maka kompilasi akan gagal, membutuhkan setidaknya satu jenis dalam daftar parameter.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas pertama berdasarkan WindowClassVariadicTemplate akan seperti ini:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic1</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadicTemplate&lt;PrevWndClasses..., WindowClassVariadic1&lt;&gt;&gt;<font></font>
{<font></font>
<span class="hljs-keyword">protected</span>:
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassVariadic1(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassVariadicTemplate(hInstance, szClassName, szWndTitle)<font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassVariadic1(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassVariadicTemplate(wc, szWndTitle)<font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
	WindowClassVariadic1(WindowClassVariadic1&amp; wcObj) : WindowClassVariadicTemplate(wcObj)			<span class="hljs-comment">// </span><font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassVariadic1() <span class="hljs-keyword">override</span>		<span class="hljs-comment">// </span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (hWnd)
			<span class="hljs-keyword">this</span>-&gt;OnClose(hWnd);		<span class="hljs-comment">// ,    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_PAINT   </span>
	</span>{<font></font>
		...<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_DESTROY   </span>
	</span>{<font></font>
		...<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas ini, setelah menerima daftar parameter PrevWndClasses yang tidak ditentukan, meneruskannya lebih jauh ke kelas dasar, memasukkan dirinya di depannya sebagai elemen pertama dengan daftar parameter yang kosong. </font><font style="vertical-align: inherit;">Karena kelas ini WindowClassVariadic1 sendiri adalah variabel, WindowClassVariadic1 &lt;&gt; juga akan menjadi variabel, meskipun tanpa parameter, dan seluruh rangkaian kelas ini sebenarnya merupakan templat variabel, masing-masing elemen yang juga merupakan templat variabel. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas turunan berikut adalah:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic2</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadic1&lt;PrevWndClasses..., WindowClassVariadic2&lt;&gt;&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan pengecualian mengubah nama turunan dan basis, kelas memiliki bentuk yang persis sama dengan yang sebelumnya. </font><font style="vertical-align: inherit;">Kelas selanjutnya serupa:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic3</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadic2&lt;PrevWndClasses..., WindowClassVariadic3&lt;&gt;&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah arti dari pewarisan berganda polimorfik: mendeklarasikan kelas dengan cara ini, kami menjamin tidak hanya penciptaan objek dari tipe ini, tetapi juga semua objek dari semua kelas lain yang berasal darinya, tidak peduli berapa banyak dan apa pun mereka di masa depan. Dalam hal ini, OnCreate yang benar akan selalu dipanggil di WindowClassBase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, templat variabel ini adalah cara kerja pertama untuk menyelesaikan masalah memanggil OnCreate saat membuat jendela yang sepenuhnya memenuhi semua persyaratan yang ditetapkan sebelumnya.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ke depan, di mana metode terbaik dalam situasi yang diberikan pada akhirnya ditemukan, implementasi pewarisan melalui templat variabel memungkinkan Anda untuk menerapkan logika kompilasi yang lebih kompleks di WindowClassBase: memiliki akses ke semua jenis dimana pewarisan terjadi, Anda dapat secara fleksibel memilih di antara yang diperlukan atau kriteria dan panggil fungsi anggota yang ditentukan di dalamnya. </font><font style="vertical-align: inherit;">Tapi ini masih kasus yang sedikit berbeda.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas inisialisasi</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak menyadari reaksi dari static_cast untuk tipe turunan, saya terus mencari cara lain untuk mengimplementasikan transfer kelas vertex hierarki ke WindowClassBase. </font><font style="vertical-align: inherit;">Pada titik tertentu, saya berpikir untuk membawa implementasi OnCreate ke kelas yang terpisah, yang dibuat khusus untuknya:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassInit1</span>
{</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span>				<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas ini parameterkan kelas lain yang mengimplementasikan semua penggantian lainnya untuk fungsi virtual. </font><font style="vertical-align: inherit;">Ini berasal dari WindowClassTemplate yang sudah dijelaskan:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndClsInit</span> = <span class="hljs-title">WindowClassInit1</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedI1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;WndClsInit&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lewat sini:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pewarisan kelas terjadi seperti biasa untuk fungsi virtual;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya kelas inisialisasi yang ditentukan secara khusus untuk implementasi OnCreate yang ditransfer dari kelas ke kelas sesuai dengan rantai pewarisan.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kelas ini terletak di bagian atas hierarki, maka parameter WndClsInit akan menjadi sama dengan WindowClassInit1 - kelas inisialisasi yang ditentukan untuk kelas ini, dan akan dipindahkan lebih jauh di sepanjang rantai hierarki. Jika kelas ini adalah perantara dalam rantai, maka ia hanya akan menerima kelas yang diteruskan dan meneruskannya. Kemudian, bahwa opsi ini lebih baik dibandingkan dengan yang sebelumnya di mana templat tidak mentransfer sendiri, tetapi mentransfer beberapa kelas pihak ketiga, yang diimplementasikan (dan terlihat) jauh lebih mudah. Templat dalam formulir ini juga cocok tanpa perubahan untuk implementasi seluruh rantai pewarisan: hanya perubahan nama kelas yang akan terjadi.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, static_cast, tidak seperti konversi gaya-C, di dalam WindowClassTemplate tidak akan melewatkan bentuk pewarisan ini: ia tidak dapat mengkonversi ketika meneruskan ini dari (WindowClassTemplate *) ke (WindowClassInit1 *). </font><font style="vertical-align: inherit;">Dan ini logis: WindowClassInit1 sebenarnya adalah kelas asing, hanya disahkan sebagai tipe ke titik ini, itu tidak terhubung dengan cara apa pun dengan WindowClassTemplate dan seluruh rantai turunan darinya, oleh karena itu konversi pointer ke sana tidak dapat diterima.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaining tipe kelas yang diturunkan di WindowClassBase, transfer bersyarat</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan akhirnya, cara terbaik ditemukan untuk situasi ini untuk mentransfer jenis kelas turunan ke basis akar WindowClassBase melalui seluruh rantai pewarisan, tanpa kekurangan dari yang sebelumnya dan pada saat yang sama lebih sederhana daripada templat variabel. </font><font style="vertical-align: inherit;">Tetapkan kelas template berikut berdasarkan WindowClassTemplate:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative1&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassDerivedAlternative1(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassTemplate(hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerivedAlternative1(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassTemplate(wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerivedAlternative1() <span class="hljs-keyword">override</span>	<span class="hljs-comment">// </span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (hWnd)
			<span class="hljs-keyword">this</span>-&gt;OnClose(hWnd);	<span class="hljs-comment">// ,    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>			<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>	<span class="hljs-comment">//  WM_PAINT   </span>
	</span>{
		<span class="hljs-comment">//  WM_PAINT   </span><font></font>
		HDC hDC;<font></font>
		PAINTSTRUCT ps;<font></font>
		RECT rect;<font></font>
<font></font>
		hDC = BeginPaint(hWnd, &amp;ps);<font></font>
<font></font>
		GetClientRect(hWnd, &amp;rect);<font></font>
		DrawText(hDC, TEXT(<span class="hljs-string">"       ( )."</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<font></font>
<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas ini menerima DerWndCls sebagai parameter, yang secara default sama dengan kelas ini. </font><font style="vertical-align: inherit;">Selama transfer, DerWndCls dibandingkan dengan kelas ini: dalam hal kesetaraan (nilai default, yaitu, kelas yang diberikan berada di bagian atas hierarki), ia menyerahkan dirinya sendiri dengan daftar parameter yang kosong. </font><font style="vertical-align: inherit;">Kalau tidak, DerWndCls yang diterima diteruskan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya menganggap solusi ini sebagai yang terbaik dalam situasi ini dalam segala hal:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satu bentuk definisi kelas untuk seluruh rantai pewarisan;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">logika transfer kelas yang sederhana dan transparan di sepanjang rantai pewarisan;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak ada overhead karena templat variabel (dalam kasus tersebut, seperti pada ini, saat ini tidak diperlukan).</font></font></li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retribusi yang mengerikan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa artinya semua ini? </font><font style="vertical-align: inherit;">Ini berarti bahwa jika Anda ingin menggunakan bentuk warisan yang tidak konvensional seperti itu, Anda harus memformalkan semua kelas Anda dengan cara yang ditentukan secara ketat sehingga mereka memungkinkan transfer sendiri kemungkinan turunan baru. </font><font style="vertical-align: inherit;">Ini adalah persyaratan yang sangat mudah, dan jika diinginkan, mudah diikuti. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi ada pertanyaan lain yang jauh lebih sepele: hubungan antara tipe dan pointer. </font><font style="vertical-align: inherit;">Orang pintar menulis: jangan bermain dengan hal-hal seperti itu di konstruktor dan bertentangan dengan prinsip-prinsip bahasa dan logika kompiler. </font><font style="vertical-align: inherit;">Tetapi saya tidak patuh dan tetap melakukannya. </font><font style="vertical-align: inherit;">Sekarang tiba pembalasan alam. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, kami memiliki 4 kelas:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative1&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
…<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative2</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative2&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	…<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative3</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative2&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative3&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	…<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative4</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative3&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative4&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	…<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang saya tulis di atas, konten spesifik mereka dan logika kerja sama sekali tidak penting. </font><font style="vertical-align: inherit;">Satu-satunya hal yang penting adalah bahwa dalam judul definisi kelas. </font><font style="vertical-align: inherit;">Berdasarkan kelas-kelas ini, kami membuat 4 objek:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">WindowClassDerivedAlternative1&lt;&gt; <span class="hljs-title">w1</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative1"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative1"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative2&lt;&gt; <span class="hljs-title">w2</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative2"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative2"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative3&lt;&gt; <span class="hljs-title">w3</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative3"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative3"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative4&lt;&gt; <span class="hljs-title">w4</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative4"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative4"</span>))</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memperluas definisi tipe mereka yang tersembunyi di balik tanda kurung kosong menggunakan argumen default. Tipe w1 adalah WindowClassDerivedAlternative1. Tipe w2 adalah WindowClassDerivedAlternative2, dan kelas dasarnya adalah WindowClassDerivedAlternative1 &lt;WindowClassDerivedAlternative2&gt;. Tipe w3 adalah WindowClassDerivedAlternative3, kelas dasarnya adalah WindowClassDerivedAlternative2 &lt;WindowClassDerivedAlternative3&gt;, dan kelas dasarnya adalah WindowClassDerivedAlternative1 &lt;WindowClassDerivedAlternative3&gt;. Begitu pula untuk objek keempat. Lihatlah diagram berikut:</font></font><br>
<img src="https://habrastorage.org/webt/bu/b5/nn/bub5nnsttowpw1lhstypwm-3vfc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan membuat setiap kelas turunan baru berdasarkan kelas dasar tertentu yang didefinisikan dengan cara ini, Anda mendefinisikan bukan hanya kelas baru, tetapi pada saat yang sama seluruh rantai basisnya lagi. Ini akan sejajar dengan rantai kelas dasar sendiri. Kelas Anda akan memiliki kelas dasar sendiri, dan tidak satu pun dari mereka akan dapat mengarah ke salah satu kelas dasar asli, terlepas dari kenyataan bahwa kode generasi untuk semua kelas ini adalah sama! Tampaknya itu fantasi nyata, tetapi memang benar! Ini berarti bahwa semua cara biasa untuk memanipulasi kelas dan petunjuk yang diturunkan tidak akan berfungsi! Dalam arsitektur khusus ini, hanya WindowClassBase basis yang menyelamatkan situasi, jika tidak, juga tidak mungkin untuk membuat array dari kelas dasar (misalnya, berdasarkan WindowClassTemplate),karena semua kelas tersebut memiliki tipe yang berbeda.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, definisi bentuk yang dikenal dan dimengerti:</font></font><br>
<pre><code class="cpp hljs">WindowClassDerivedAlternative1&lt;&gt; *p2 = &amp;w2;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... akan berhenti mengkompilasi karena Anda mencoba membuat pointer tipe yang tidak kompatibel dengan tipe objek w2 meskipun faktanya setengah jam yang lalu Anda sendiri menulis kelas yang berasal dari kelas WindowClassDerivedAlternative1 &lt;&gt; dan berdasarkan di mana objek w2 dibuat.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika hukum kebiasaan berhenti bekerja, itu dapat menyebabkan kejutan. </font><font style="vertical-align: inherit;">Dan dengan semua ini, sebenarnya tidak ada hack compiler kotor, konversi tipe paksa, dan hal-hal buruk lainnya. </font><font style="vertical-align: inherit;">Semuanya sangat bersih dan legal: templat, parameter default, dan jenis alat pustaka. </font><font style="vertical-align: inherit;">Hanya metode penulisan kode yang akrab berhenti bekerja. </font><font style="vertical-align: inherit;">Menggunakan ini dalam proyek nyata berarti menyatakan ada zona bahaya, yang hanya dapat dimasuki oleh personel khusus yang memenuhi syarat dengan tindakan perlindungan yang tepat.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eksperimen Kode</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk membuatnya lebih mudah bagi semua orang yang tertarik untuk bereksperimen dan menghemat waktu dalam mengetik, saya memposting di GitHub semua proyek yang menjadi dasar untuk artikel ini: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/SkyCloud555/ECRTP</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Cukup pilih satu proyek sebagai proyek awal Anda, jika tidak, Anda akan tenggelam dalam lautan jendela berwarna-warni.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“Jika semua ini adalah lelucon, maka, mengingat upaya yang dikeluarkan, itu terlihat terlalu serius dan alami. </font><font style="vertical-align: inherit;">Dan jika bukan lelucon, maka tidak ada pengembang normal yang waras benar-benar akan menggunakan hal seperti itu. </font><font style="vertical-align: inherit;">Lagi pula, bung, tidakkah kau akan berakhir dengan omong kosong dan tidak pergi melakukan sesuatu </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang menghasilkan uang, itu</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berguna. " </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda benar jika Anda berpikir demikian. </font><font style="vertical-align: inherit;">Pada artikel ini, saya hanya menunjukkan bahwa C ++ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bisa</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pertanyaan penerapan praktis struktur ini tetap terbuka. Dan secara umum, ini lebih mungkin berlaku untuk generalisasi dan metaprogramming. Anda mungkin tidak perlu membuat objek apa pun dari kelas ini sama sekali, tetapi kelas itu sendiri mungkin diperlukan untuk beberapa alasan. Ya, dan Anda tidak pernah tahu solusi berguna apa yang dapat Anda buat atas dasar ini ... CRTP asli digunakan! Dan itu bahkan tidak digunakan di mana pun, tetapi tepat di perpustakaan standar! Siapa yang tidak percaya atau tidak ingat, google std :: en_shared_from_this. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kembali ke tugas semula dengan windows ... Terutama sekarang, dengan tenang </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan tanpa rumput</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> melihat kembali semua ini setelah tiga tahun ... Bahkan jika kita membuang fakta bahwa saya menyentuh topik dangkal yang telah melakukan perjalanan jutaan kali, dan ini sudah lama tidak menarik bagi siapa pun, karena </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebenarnya anak laki-laki</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">orang normal memiliki </font><font style="vertical-align: inherit;">QT </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MFC</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , saya hanya akan memastikan bahwa beberapa objek fungsional diteruskan ke kelas jendela. </font><font style="vertical-align: inherit;">Tidak sulit untuk memastikan transfernya melalui rantai pewarisan, tetapi ia akan melakukan segalanya dengan sederhana, jelas dan tanpa distorsi, dan Anda akan mendapatkan kelas yang dapat diprediksi sepenuhnya normal tanpa efek samping, yang dapat Anda temani dan kembangkan untuk siapa saja. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang terjadi dalam artikel ini hanyalah tugas non-sepele yang menarik, yang masih bisa saya selesaikan. </font><font style="vertical-align: inherit;">Saya harap ini juga menarik bagi Anda.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id507114/index.html">Ode Excel: 34 Tahun Sihir</a></li>
<li><a href="../id507116/index.html">"Udalenka". Catatan dari pengembang kantor kemarin. Bagian 2</a></li>
<li><a href="../id507124/index.html">PDB bukan hanya bulu yang berharga</a></li>
<li><a href="../id507132/index.html">Vladimir Kitov: "Tidak mungkin untuk memahami bagaimana para ilmuwan perintis meramalkan komputerisasi universal pada 1950-an!"</a></li>
<li><a href="../id507138/index.html">Geologi Abad 21 sebagai Ilmu Data Bumi</a></li>
<li><a href="../id507148/index.html">Kirim tautan ajaib menggunakan Node.js</a></li>
<li><a href="../id507150/index.html">Kami menggambar gambar interferensi dalam JavaScript</a></li>
<li><a href="../ja451092/index.html">ソーシャルプロジェクト「Remember Everyone」のソフトウェア実装をオープンソースにした経験</a></li>
<li><a href="../ja451098/index.html">プロジェクトのオーディオサンプルの入手先：9つのテーマ別リソースの選択</a></li>
<li><a href="../ja451104/index.html">記事を読むインテリジェントスピーカーブラウザー拡張機能：Microsoft Azureから追加された音声</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>