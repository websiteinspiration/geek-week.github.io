<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💷 🚟 🐂 JavaScriptの革新：Google I / O 2019の結果。パート1 👩🏿‍⚖️ 🌎 🔵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今日公開している翻訳の最初の部分である資料は、Google I / O 2019カンファレンスで議論された新しい標準のJavaScript機能に特化しています。特に、ここでは、正規表現、クラスフィールド、文字列の操作について説明します。
 
 
 
 正規表現チェック
 正規表現（正規表現、略してR...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>JavaScriptの革新：Google I / O 2019の結果。パート1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/464129/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今日公開している翻訳の最初の部分である資料は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google I / O 2019</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カンファレンスで議論された新しい標準のJavaScript機能に特化しています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">特に、ここでは、正規表現、クラスフィールド、文字列の操作について説明します。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/h9/k-/lh/h9k-lhwr73vkp2jrbj6onwpliay.jpeg"></a><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正規表現チェック</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正規表現（正規表現、略してRegExまたはRegExp）は、多くのプログラミング言語に実装されている強力な文字列処理テクノロジです。</font><font style="vertical-align: inherit;">正規表現は、たとえば、複雑なパターンで文字列のフラグメントを検索する必要がある場合に非常に役立ちます。</font><font style="vertical-align: inherit;">最近まで、正規表現のJavaScript実装には、ルックバックハインド以外のすべてがありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
遡及的チェックとは何かを理解するために、JavaScriptですでにサポートされている先読みについて話しましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">後編</font></font></a><br>
<a name="habracut"></a><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍事前チェック</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正規表現の先行チェックの構文により、他のフラグメントが右側にあることがわかっている場合に、ストリングのフラグメントを検索できます。</font><font style="vertical-align: inherit;">たとえば、文字列</font></font><code>MangoJuice, VanillaShake, GrapeJuice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を処理する場合、正の先行チェックの構文を使用して、直後にある単語を見つけることができます</font></font><code>Juice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私たちの場合、これらは単語</font></font><code>Mango</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>Grape</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
先行チェックには2つのタイプがあります。</font><font style="vertical-align: inherit;">これらは、ポジティブ先読みとネガティブ先読みです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポジティブリードチェック</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正の先行チェックを使用して、右側にある他の既知の行である行を検索します。</font><font style="vertical-align: inherit;">このチェックに使用される正規表現構文は次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs">/[a-zA-Z]+(?=Juice)/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このテンプレートを使用すると、小文字または大文字の後に単語が続く単語を選択できます</font></font><code>Juice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">先行チェックと遡及チェックを記述する構造をキャプチャグループと混同しないでください。</font><font style="vertical-align: inherit;">これらのチェックの条件は括弧内に記述されていますが、システムはそれらをキャプチャしません。</font><font style="vertical-align: inherit;">ポジティブリードチェックの例を見てみましょう。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> testString = <span class="hljs-string">"MangoJuice, VanillaShake, GrapeJuice"</span>;
<span class="hljs-keyword">const</span> testRegExp = <span class="hljs-regexp">/[a-zA-Z]+(?=Juice)/g</span>;
<span class="hljs-keyword">const</span> matches = testString.match( testRegExp );
<span class="hljs-built_in">console</span>.log( matches ); <span class="hljs-comment">// ["Mango", "Grape"]</span></code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネガティブリードチェック</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の行、否定的な先行チェックのアクションのメカニズムを使用して考えると、単語がない右側の単語を見つけることができることがわかります</font></font><code>Juice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">負の先行チェックの構文は、正のチェックの構文に似ています。</font><font style="vertical-align: inherit;">ただし、記号</font></font><code>=</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（等しい）が記号</font></font><code>!</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（感嘆符</font><font style="vertical-align: inherit;">）に変わるという</font><font style="vertical-align: inherit;">点に</font><font style="vertical-align: inherit;">1つの特殊性があり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これは次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs">/[a-zA-Z]+(?!Juice)/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この正規表現では、右側に単語がないすべての単語を選択できます</font></font><code>Juice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、このようなテンプレートを適用すると、行（</font></font><code>MangoJuice, VanillaShake, GrapeJuice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">内のすべての単語が選択され</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">実際のところ、システムによると、ここで終わるのは一言ではありません</font></font><code>Juice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">その結果、望ましい結果を得るには、正規表現を明確にし、次のように書き直す必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs">/(Mango|Vanilla|Grape)(?!Juice)/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このテンプレートを使用すると、単語</font></font><code>Mango</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「or」</font></font><code>Vanilla</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、「or </font></font><code>Grape</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」</font><font style="vertical-align: inherit;">、「or </font><font style="vertical-align: inherit;">」を選択できます</font></font><code>Juice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">その後、単語はありません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次に例を示します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> testString = <span class="hljs-string">"MangoJuice, VanillaShake, GrapeJuice"</span>;
<span class="hljs-keyword">const</span> testRegExp = <span class="hljs-regexp">/(Mango|Vanilla|Grape)(?!Juice)/g</span>;
<span class="hljs-keyword">const</span> matches = testString.match( testRegExp );
<span class="hljs-built_in">console</span>.log( matches ); <span class="hljs-comment">// ["Vanilla"]</span></code></pre><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍回顧チェック</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
先行チェックの構文と同様に、レトロスペクティブチェックの構文では、これらのシーケンスの左側が特定のパターンである場合にのみ、文字のシーケンスを選択できます。</font><font style="vertical-align: inherit;">たとえば、文字列を処理するときに</font></font><code>FrozenBananas, DriedApples, FrozenFish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、肯定的な遡及的チェックを使用して、左側に単語がある単語を見つけることができます</font></font><code>Frozen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私たちの場合、単語</font></font><code>Bananas</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">はこの条件に対応しています</font></font><code>Fish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
先行チェックの場合と同様に、ポジティブな遡及的チェック（ポジティブ後読み）とネガティブな遡及的チェック（ネガティブまたは否定後読み）があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">肯定的な回顧的レビュー</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポジティブな遡及的チェックは、左側に他のパターンがあるパターンを検索するために使用されます。</font><font style="vertical-align: inherit;">このようなチェックを記述するために使用される構文の例を次に示します。</font></font><br>
<br>
<pre><code class="javascript hljs">/(?&lt;=Frozen)[a-zA-Z]+/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは</font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、先行チェックの説明にない</font><font style="vertical-align: inherit;">記号が使用され</font><font style="vertical-align: inherit;">ています。</font><font style="vertical-align: inherit;">さらに、正規表現の条件は、対象のテンプレートの右側ではなく、左側にあります。</font><font style="vertical-align: inherit;">上記のテンプレートを使用すると、で始まるすべての単語を選択できます</font></font><code>Frozen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">例を考えてみましょう：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> testString = <span class="hljs-string">"FrozenBananas, DriedApples, FrozenFish"</span>;
<span class="hljs-keyword">const</span> testRegExp = <span class="hljs-regexp">/(?&lt;=Frozen)[a-zA-Z]+/g</span>;
<span class="hljs-keyword">const</span> matches = testString.match( testRegExp );
<span class="hljs-built_in">console</span>.log( matches ); <span class="hljs-comment">// ["Bananas", "Fish"]</span></code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">否定的な回顧的チェック</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
否定的な遡及チェックのメカニズムにより、指定されたパターンがない左側の行のパターンを検索できます。</font><font style="vertical-align: inherit;">たとえば、行</font></font><code>FrozenBananas, DriedApples, FrozenFish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でで始まらない単語</font><font style="vertical-align: inherit;">を選択する場合</font><font style="vertical-align: inherit;">は</font></font><code>Frozen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、次のような正規表現を使用できます。</font></font><br>
<br>
<pre><code class="javascript hljs">/(?&lt;!Frozen)[a-zA-Z]+/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、この構文を使用すると、文字列からすべての単語が選択されるため、いずれもで始まっていない</font></font><code>Frozen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため、正規表現を明確にする必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs">/(?&lt;!Frozen)(Bananas|Apples|Fish)/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に例を示します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> testString = <span class="hljs-string">"FrozenBananas, DriedApples, FrozenFish"</span>;
<span class="hljs-keyword">const</span> testRegExp = <span class="hljs-regexp">/(?&lt;!Frozen)(Bananas|Apples|Fish)/g</span>;
<span class="hljs-keyword">const</span> matches = testString.match( testRegExp );
<span class="hljs-built_in">console</span>.log( matches ); <span class="hljs-comment">// ["Apples"]</span></code></pre><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→サポート</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションおよび他の同様のセクションでは、ECMA InternationalでECMAScript仕様のサポートを担当する技術委員会39（技術委員会39、TC39）で説明されているJSの機能の調和の段階に関する情報を提供します。</font><font style="vertical-align: inherit;">このようなセクションでは、ChromeとNode.jsのバージョン（場合によってはFirefoxのバージョン）のデータも表示され、最初に対応する機能を使用できます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC39：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステージ4</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chrome：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">62以上</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノード：8.10.0以降</font></font></li>
</ul><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスフィールド</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスフィールドは、クラスコンストラクターの外部のクラスインスタンス（オブジェクト）のプロパティを定義するために使用される新しい構文構造です。</font><font style="vertical-align: inherit;">クラスフィールドには、パブリッククラスフィールドとプライベートクラスフィールドの2種類があります。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍パブリッククラスフィールド</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近まで、オブジェクトのプロパティはクラスコンストラクター内で定義する必要がありました。</font><font style="vertical-align: inherit;">これらのプロパティはパブリック（パブリック）でした。</font><font style="vertical-align: inherit;">これは、クラス（オブジェクト）のインスタンスを操作しているときにアクセスできることを意味します。</font><font style="vertical-align: inherit;">以下は、パブリックプロパティを宣言する例です。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.name = <span class="hljs-string">'Tommy'</span>;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定の親クラスを拡張するクラスを作成する必要がある場合</font></font><code>super()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、子クラスのコンストラクター</font><font style="vertical-align: inherit;">を呼び出す必要がありました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、独自のプロパティを子クラスに追加する前に行う必要があります。</font><font style="vertical-align: inherit;">これは次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">super</span>(); <span class="hljs-comment">//  super   `this`  </span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.sound = <span class="hljs-string">'Woof! Woof!'</span>;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;makeSound() {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.sound );<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-keyword">const</span> tommy = <span class="hljs-keyword">new</span> Dog();<font></font>
tommy.makeSound(); <span class="hljs-comment">// Woof! Woof!</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスのパブリックフィールドの構文の外観のおかげで、コンストラクターの外でクラスのフィールドを記述することが可能です。</font><font style="vertical-align: inherit;">システムは暗黙的な呼び出しを行います</font></font><code>super()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;sound = <span class="hljs-string">'Woof! Woof!'</span>; <span class="hljs-comment">//   </span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;makeSound() {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.sound );<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-keyword">const</span> tommy = <span class="hljs-keyword">new</span> Dog();<font></font>
tommy.makeSound(); <span class="hljs-comment">// Woof! Woof!</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
暗黙的な呼び出し</font></font><code>super()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が行われると、クラスインスタンスの作成時にユーザーによって提供されたすべての引数が渡されます（これは標準のJavaScriptの動作であり、プライベートクラスフィールドについて特別なことは何もありません）。</font><font style="vertical-align: inherit;">親クラスのコンストラクターが特別な方法で準備された引数を必要とする場合、それを</font></font><code>super()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自分で</font><font style="vertical-align: inherit;">呼び出す必要があり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">子クラスのインスタンスを作成するときに、親クラスの暗黙的なコンストラクター呼び出しの結果を見てみましょう。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>( ...args ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log( <span class="hljs-string">'Animal args:'</span>, args );<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;sound = <span class="hljs-string">'Woof! Woof!'</span>; <span class="hljs-comment">//   </span><font></font>
makeSound() {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.sound );<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-keyword">const</span> tommy = <span class="hljs-keyword">new</span> Dog( <span class="hljs-string">'Tommy'</span>, <span class="hljs-string">'Loves'</span>, <span class="hljs-string">'Toys!'</span> );<font></font>
tommy.makeSound(); <span class="hljs-comment">// Animal args: [ 'Tommy', 'Loves', 'Toys!' ]</span></code></pre><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍プライベートクラスフィールド</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご存知のように、JavaScriptでそこのようなクラスフィールドにはアクセス修飾子はありません</font></font><code>public</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><code>protected</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。オブジェクトのすべてのプロパティはデフォルトでパブリックです。これは、それらへのアクセスが無制限であることを意味します。オブジェクトのプロパティをプライベートプロパティに類似させる最も近い方法は、データ型を使用することです</font></font><code>Symbol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これにより、オブジェクトのプロパティを外界から隠すことができます。接頭辞</font></font><code>_</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（アンダースコア）が</font><font style="vertical-align: inherit;">付いたプロパティ名を使用し</font><font style="vertical-align: inherit;">て、対応するプロパティをオブジェクト内での使用のみを目的とする必要があることを示すことができます。ただし、これはオブジェクトを使用するユーザーへの通知にすぎません。これは、プロパティへのアクセスの実際の制限の問題を解決しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスのプライベートフィールドのメカニズムのおかげで、このクラス内でのみクラスプロパティにアクセスできるようにすることが可能です。</font><font style="vertical-align: inherit;">これは、外部からアクセスできず、クラス（オブジェクト）のインスタンスを操作できないという事実につながります。</font><font style="vertical-align: inherit;">前の例を見て、外部からクラスのプロパティにアクセスしてみてください</font></font><code>_</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">その宣言ではprefixを使用していました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;_sound = <span class="hljs-string">'Woof! Woof!'</span>; <span class="hljs-comment">//     </span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;makeSound() {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>._sound );<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-keyword">const</span> tommy = <span class="hljs-keyword">new</span> Dog();
<span class="hljs-built_in">console</span>.log( tommy._sound ); <span class="hljs-comment">// Woof! Woof!</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、接頭辞を使用し</font></font><code>_</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ても問題は解決しません。</font><font style="vertical-align: inherit;">クラスのプライベートフィールドは、パブリックフィールドと同じ方法で宣言できますが、アンダースコアの形式のプレフィックスの代わりに、シャープ記号（</font></font><code>#</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">形式のプレフィックスを名前に追加する必要があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この方法で宣言されたオブジェクトのプライベートプロパティに不正アクセスを試みると、次のエラーが発生します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">SyntaxError</span>: Undefined private field</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に例を示します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;#sound = <span class="hljs-string">'Woof! Woof!'</span>; <span class="hljs-comment">//  -  </span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;makeSound() {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.#sound );<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-keyword">const</span> tommy = <span class="hljs-keyword">new</span> Dog();<font></font>
tommy.makeSound() <span class="hljs-comment">// Woof! Woof!</span>
<span class="hljs-comment">//console.log( tommy.#sound ); // SyntaxError</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プライベートプロパティは、それらが宣言されているクラスからのみアクセスできることに注意してください。</font><font style="vertical-align: inherit;">その結果、子孫クラスは親クラスの同様のプロパティを直接使用できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プライベート（およびパブリック）フィールドは、特定の値をフィールドに書き込むことなく宣言できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;#name;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>( name ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.#name = name;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;showName() {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.#name );<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-keyword">const</span> tommy = <span class="hljs-keyword">new</span> Dog( <span class="hljs-string">'Tommy'</span> );<font></font>
tommy.showName(); <span class="hljs-comment">// Tommy</span></code></pre><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→サポート</font></font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC39：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステージ3</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chrome：74以上</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノード：12以上</font></font></li>
</ul><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文字列メソッド.matchAll（）</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ型プロトタイプに</font></font><code>String</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><code>.match()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、正規表現で指定された条件に一致する文字列フラグメントの配列を返す</font><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">があります。</font><font style="vertical-align: inherit;">このメソッドを使用した例を次に示します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> colors = <span class="hljs-string">"#EEE, #CCC, #FAFAFA, #F00, #000"</span>;
<span class="hljs-keyword">const</span> matchColorRegExp = <span class="hljs-regexp">/([A-Z0-9]+)/g</span>;
<span class="hljs-built_in">console</span>.log( colors.match( matchColorRegExp ) );
<span class="hljs-comment">// :</span>
[<span class="hljs-string">"EEE"</span>, <span class="hljs-string">"CCC"</span>, <span class="hljs-string">"FAFAFA"</span>, <span class="hljs-string">"F00"</span>, <span class="hljs-string">"000"</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、この方法を使用する場合、見つかった文字列のフラグメントに関する追加情報（インデックスなど）は提供されません。</font></font><code>g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font></font><code>.match()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">渡された正規表現から</font><font style="vertical-align: inherit;">フラグを削除すると</font><font style="vertical-align: inherit;">、検索結果に関する追加情報を含む配列が返されます。確かに、このアプローチでは、正規表現に一致する文字列の最初のフラグメントのみが見つかります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> colors = <span class="hljs-string">"#EEE, #CCC, #FAFAFA, #F00, #000"</span>;
<span class="hljs-keyword">const</span> matchColorRegExp = <span class="hljs-regexp">/#([A-Z0-9]+)/</span>;
<span class="hljs-built_in">console</span>.log( colors.match( matchColorRegExp ) );
<span class="hljs-comment">// : (       )</span>
[<span class="hljs-string">"#EEE"</span>, <span class="hljs-string">"EEE"</span>, <span class="hljs-attr">index</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">input</span>: <span class="hljs-string">"&lt;colors&gt;"</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
似たようなものを取得するために、すでに文字列のいくつかのフラグメントについては、正規表現メソッドを使用する必要があります</font></font><code>.exec()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これに必要な構成は、単一の文字列メソッドを使用して同様の結果を得る構成よりも複雑です。</font><font style="vertical-align: inherit;">特に、ここでは、</font><font style="vertical-align: inherit;">戻る</font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まで実行される</font><font style="vertical-align: inherit;">サイクル</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">必要</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">このアプローチを使用して、</font><font style="vertical-align: inherit;">イテレータが返さない</font><font style="vertical-align: inherit;">ものを検討してください</font><font style="vertical-align: inherit;">。</font></font><code>.exec()</code><font style="vertical-align: inherit;"></font><code>null</code><font style="vertical-align: inherit;"></font><code>.exec()</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> colors = <span class="hljs-string">"#EEE, #CCC, #FAFAFA, #F00, #000"</span>;
<span class="hljs-keyword">const</span> matchColorRegExp = <span class="hljs-regexp">/#([A-Z0-9]+)/g</span>;
<span class="hljs-comment">//        ,</span>
<span class="hljs-comment">// Uncaught ReferenceError: match is not defined</span>
<span class="hljs-keyword">while</span>( match = matchColorRegExp.exec( colors ) ) {
&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log( match );<font></font>
}<font></font>
<span class="hljs-comment">// : (       )</span>
[<span class="hljs-string">"#EEE"</span>, <span class="hljs-string">"EEE"</span>, <span class="hljs-attr">index</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">input</span>: <span class="hljs-string">"&lt;colors&gt;"</span>]<font></font>
[<span class="hljs-string">"#CCC"</span>, <span class="hljs-string">"CCC"</span>, <span class="hljs-attr">index</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">input</span>: <span class="hljs-string">"&lt;colors&gt;"</span>]<font></font>
[<span class="hljs-string">"#FAFAFA"</span>, <span class="hljs-string">"FAFAFA"</span>, <span class="hljs-attr">index</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">input</span>: <span class="hljs-string">"&lt;colors&gt;"</span>]<font></font>
[<span class="hljs-string">"#F00"</span>, <span class="hljs-string">"F00"</span>, <span class="hljs-attr">index</span>: <span class="hljs-number">21</span>, <span class="hljs-attr">input</span>: input: <span class="hljs-string">"&lt;colors&gt;"</span>]<font></font>
[<span class="hljs-string">"#000"</span>, <span class="hljs-string">"000"</span>, <span class="hljs-attr">index</span>: <span class="hljs-number">27</span>, <span class="hljs-attr">input</span>: input: <span class="hljs-string">"&lt;colors&gt;"</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような問題を解決するために</font></font><code>.matchAll()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、イテレータを返す</font><font style="vertical-align: inherit;">文字列メソッドを使用できるようになりました</font><font style="vertical-align: inherit;">。</font></font><code>.next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この反復子の</font><font style="vertical-align: inherit;">各メソッド呼び出しにより</font><font style="vertical-align: inherit;">、検索結果から次の要素が返されます。</font><font style="vertical-align: inherit;">その結果、上記の例は次のように書き直すことができます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> colors = <span class="hljs-string">"#EEE, #CCC, #FAFAFA, #F00, #000"</span>;
<span class="hljs-keyword">const</span> matchColorRegExp = <span class="hljs-regexp">/#([A-Z0-9]+)/g</span>;
<span class="hljs-built_in">console</span>.log( ...colors.matchAll( matchColorRegExp ) );
<span class="hljs-comment">// : (       )</span>
[<span class="hljs-string">"#EEE"</span>, <span class="hljs-string">"EEE"</span>, <span class="hljs-attr">index</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">input</span>: <span class="hljs-string">"&lt;colors&gt;"</span>]<font></font>
[<span class="hljs-string">"#CCC"</span>, <span class="hljs-string">"CCC"</span>, <span class="hljs-attr">index</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">input</span>: <span class="hljs-string">"&lt;colors&gt;"</span>]<font></font>
[<span class="hljs-string">"#FAFAFA"</span>, <span class="hljs-string">"FAFAFA"</span>, <span class="hljs-attr">index</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">input</span>: <span class="hljs-string">"&lt;colors&gt;"</span>]<font></font>
[<span class="hljs-string">"#F00"</span>, <span class="hljs-string">"F00"</span>, <span class="hljs-attr">index</span>: <span class="hljs-number">21</span>, <span class="hljs-attr">input</span>: input: <span class="hljs-string">"&lt;colors&gt;"</span>]<font></font>
[<span class="hljs-string">"#000"</span>, <span class="hljs-string">"000"</span>, <span class="hljs-attr">index</span>: <span class="hljs-number">27</span>, <span class="hljs-attr">input</span>: input: <span class="hljs-string">"&lt;colors&gt;"</span>]</code></pre><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→サポート</font></font></font></h3><br>
<ul>
<li>TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">stage 4</a></li>
<li>Chrome: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">73+</a></li>
<li>Node: 12+</li>
<li>Firefox: 67+</li>
</ul><br>
<h2><font color="#3AC1EF">    </font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptの正規表現メカニズムの実装におけるグループの概念は、他の言語での同様の概念の実装とは少し異なります。つまり、JavaScriptを使用してRegEx-templateを括弧内に配置すると（括弧を遡及的または詳細なチェックに使用する場合を除く）、テンプレートはグループになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グループによってキャプチャされた文字列のフラグメントは、正規表現を適用した結果に反映されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前の例では、検索結果を含む配列の最初の要素が正規表現全体に一致する要素であり、2番目の要素がグループに一致する要素であることがわかります。これがこの配列要素です：</font></font><br>
<br>
<pre><code class="javascript hljs">[<span class="hljs-string">"#EEE"</span>, <span class="hljs-string">"EEE"</span>, <span class="hljs-attr">index</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">input</span>: <span class="hljs-string">"&lt;colors&gt;"</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正規表現に複数のグループがある場合、それらは正規表現での説明の順序で文字列を処理した結果に分類されます。</font><font style="vertical-align: inherit;">例を考えてみましょう：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> str = <span class="hljs-string">"My name is John Doe."</span>;
<span class="hljs-keyword">const</span> matchRegExp = <span class="hljs-regexp">/My name is ([a-z]+) ([a-z]+)/i</span>;
<span class="hljs-keyword">const</span> result = str.match( matchRegExp );<span class="hljs-built_in">console</span>.log( result );
<span class="hljs-comment">//   result  null -  </span>
<span class="hljs-built_in">console</span>.log( { <span class="hljs-attr">firstName</span>: result[<span class="hljs-number">1</span>], <span class="hljs-attr">lastName</span>: result[<span class="hljs-number">2</span>] } );
<span class="hljs-comment">// :</span>
[<span class="hljs-string">"My name is John Doe"</span>, <span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>, <span class="hljs-attr">index</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">input</span>: <span class="hljs-string">"My name is John Doe."</span>, <span class="hljs-attr">groups</span>: <span class="hljs-literal">undefined</span>]<font></font>
{<span class="hljs-attr">firstName</span>: <span class="hljs-string">"John"</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Doe"</span>}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出力の最初の行が正規表現に対応する行全体であることがわかります。</font><font style="vertical-align: inherit;">2番目と3番目の要素は、グループによってキャプチャされたものを表します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
名前付きグループを使用すると</font></font><code>groups</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、プロパティ名がグループに割り当てられた名前に対応する</font><font style="vertical-align: inherit;">オブジェクト内でキャプチャしたグループを保存できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> str = <span class="hljs-string">"My name is John Doe."</span>;
<span class="hljs-keyword">const</span> matchRegExp = <span class="hljs-regexp">/My name is (?&lt;firstName&gt;[a-z]+) (?&lt;lastName&gt;[a-z]+)/i</span>;
<span class="hljs-keyword">const</span> result = str.match( matchRegExp );
<span class="hljs-built_in">console</span>.log( result );
<span class="hljs-built_in">console</span>.log( result.groups );
<span class="hljs-comment">// :</span>
[<span class="hljs-string">"My name is John Doe"</span>, <span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>, <span class="hljs-attr">index</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">input</span>: <span class="hljs-string">"My name is John Doe."</span>, <span class="hljs-attr">groups</span>: {<span class="hljs-attr">firstName</span>: <span class="hljs-string">"John"</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Doe"</span>}]<font></font>
{<span class="hljs-attr">firstName</span>: <span class="hljs-string">"John"</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">"Doe"</span>}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
名前付きグループはメソッドでうまく機能することに注意してください</font></font><code>.matchAll()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→サポート</font></font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC39：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステージ4</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chrome：64以上</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノード：10以上</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きます... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">親愛なる読者へ！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで説明したJavaScriptのイノベーションを使用しましたか？</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja464117/index.html">クリスカスペルスキーとして知られるニコライリハチェフの父ウラジミールリハチェフを訪問</a></li>
<li><a href="../ja464121/index.html">先週フロントエンドの世界からの新鮮な食材のダイジェストNo.376（2019年8月12日〜18日）</a></li>
<li><a href="../ja464123/index.html">RSトリガーへの別のアプローチ、TLA +</a></li>
<li><a href="../ja464125/index.html">Googleの4,000語のプライバシーポリシーにおける秘密のインターネットストーリー</a></li>
<li><a href="../ja464127/index.html">アニメーション化されたファビコンの開発</a></li>
<li><a href="../ja464131/index.html">JavaScriptの革新：Google I / O 2019の結果。パート2</a></li>
<li><a href="../ja464133/index.html">パフォーマンスは単なるCPUではありません：Python用の独自のプロファイラーを作成する</a></li>
<li><a href="../ja464137/index.html">テクニカルサポートMiran：仕組み</a></li>
<li><a href="../ja464141/index.html">Cでのメタクラスのファンタジー＃</a></li>
<li><a href="../ja464143/index.html">個人的ながんの治療法。患者の遺伝子が治療の成功に与える影響</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>