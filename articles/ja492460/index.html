<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌜 🛌 👳🏿 関数型プログラミングは、（おそらく）言われたことです。聞いたら 🚙 👸 ⏮️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="「学校、学校、親などで教えてもらっていたのですが、今では気づきました」というテーマの会話が好きです。幸運なことに、私が議論中の問題に少なくとも少し有能であると私が思う場合、そのような会話は通常、3つのオプションのうちの1つに帰着します。 （対談者が正しい場合）、「これはどこで得られたのですか？」 （...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>関数型プログラミングは、（おそらく）言われたことです。聞いたら</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492460/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「学校、学校、親などで教えてもらっていたのですが、今では気づきました」というテーマの会話が好きです。幸運なことに、私が議論中の問題に少なくとも少し有能であると私が思う場合、そのような会話は通常、3つのオプションのうちの1つに帰着します。 （対談者が正しい場合）、「これはどこで得られたのですか？」 （彼が間違っている場合）そして「あなたが正しい、これだけが以前に言われたことと矛盾しない」（ほとんどの場合）。私はこれらの会話が次の理由で好きです：通常、彼らの開始者は問題についての過度の予備知識を抱えていません。そして、そのような会話のトピックの1つは関数型プログラミングでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、FPについては多くのことが書かれており、その適用性、クールさ、パフォーマンスなどに関するすべての質問のように思われます。骨髄にかじった。それにもかかわらず、そのような質問は何度も繰り返され、あなたが誤解していることについて話したい人が常にいますが、実際にはそれはそうです。おそらく今日、私はこの恩知らずの役割を自分で試してみるでしょう。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">及び</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もう一度はAFがゴミであると、それを勉強するだけで、あなたの将来の専門家のカルマを台無しにすることを言います。その他（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）ははるかに適切です。それらの中で、著者はこれらすべてのラムダ、コンビネータ、カテゴリは目のほこりにすぎないことを説明することを目的としています。FP自体はシンプルで理解しやすく、楽しいものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは本当ですか？</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題の本質に移る前に、少し余談をして強調します。これらの投稿の最初の2つの内容は、読み書きができない...専門知識がないと思います。専門家は、指を広げて、彼が貴重な時間を少しも費やさなかったことについて話し合っています。コメンテーターの中の善良な人々は、これは単なる冗談にすぎないとすでに指摘しています。問題は、結局のところ、これらの翻訳のほとんどが生きているのを聞く必要があったため、これらの翻訳で提示された学位論文を冗談として理解できないことです。どうやら、あなたは脳を通過したナンセンスの過剰供給によって引き起こされる心理的トラウマの存在を診断することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の2つは、ポジティブな感情を呼び起こす可能性が高かった。なぜなら、著者は、FPの実践をOOP開発者が理解するタスクに適用するからである。タイトルに反映された最初の出版物の基本的なメッセージとの不一致、およびOOP指向の言語でのそのような明示的な形式でのモナド概念の実装の合理性に対する疑いにもかかわらず、著者は資料の詳細の欠如について非難することはできません。しかし、私には無視できない基本的な側面が1つあります。これは一種の関数型プログラミングの俗化であり、それをプログラム設計へのツールとアプローチの単純なセットと見なす試みです。私の意見では、これは完全に真実ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、この記事では、作者がコードで再現しようとしている関数型プログラムの特性が関数型プログラミングの基礎ではなく、Haskellの賢明な作成者と彼の同類の設計ソリューションによって規定されたものではなく、実際にそれらの概念とモデルの直接的な結果のいずれかであることを示す試みが行われていますその基盤、または奇妙なことに、これらの基盤が生成する欠点を補うための試みに置かれました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つまり、要点</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
科学では、多くの場合、次の変態を観察できます。まず、特定のプロセス/現象/理論の考慮の一部として、いくつかの重要で有用な特性を持つ特定のオブジェクトが表示されます。しかし、通常、その構造もかなり複雑になり、その実用性が制限されます。したがって、彼らはしばしばこのように行動します：それらは基礎として与えられたオブジェクトのプロパティを取り、これに基づいて新しい理論/モデル/説明を構築します。その中で、目的のオブジェクトは単純になるか、ささいなものになるか、必要な固有のプロパティがはるかに単純なオブジェクトに現れます。このようなものは、現代の高級言語で利用可能な「実際の」関数型プログラミングと「関数型プログラミングの要素」に関連しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現象を理解するためにその起源の歴史に慣れることは通常役立つので、私たちの質問にとって重要な計算とプログラミングの理論の歴史の瞬間を思い出してみましょう。 19世紀後半から20世紀初頭に、数理科学の基礎の重要な再編がありました。これは、数学と数学的証明があった当時のアイデアの核心に忍び込んだ多くの特定された問題と矛盾を解決しただけでなく、多くの新しい疑問を投げかけました。その1つは次のとおりです。アルゴリズムとは何ですか。または、同じこと、純粋に機械的に解決できる問題のクラス。この質問がなぜ重要であることが判明したのかについては詳しく説明しません。あまり狭くない分野で広く知られているアランチューリングが彼に与えた答えに直行したほうがよいでしょう。彼は論文を作成しました：「チューリングマシンを構築できる機能のみが計算可能です。」このステートメントは証明されていません。つまり、実際、チューリングは、計算可能な関数と見なされるものの厳密な正式な定義を単に与えただけであり、この概念に通常組み込まれている直感的な表現と一致しています。この定義は、無限のリボンがあってもマシンが何であるか、そしてそれがどのように機能するかをよく知っているので、出願人を満足させることができることが証明されました。しかし、多くの数学者にとって、この定義はあまり満足されていません。これらは通常、この概念に投資されます。無限のリボンがあっても、マシンとは何か、そしてそれがどのように機能するかをよく知っているので、このような定義は出願人を満足させることができました。しかし、多くの数学者にとって、この定義はあまり満足されていません。これらは通常、この概念に投資されます。無限のリボンがあっても、マシンとは何か、そしてそれがどのように機能するかをよく知っているので、このような定義は出願人を満足させることができました。しかし、多くの数学者にとって、この定義はあまり満足されていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どうやら、チューリングが操作した概念は不十分に見えた...抽象的。</font><font style="vertical-align: inherit;">この点で、彼らは、より大きなクラスの数学関数を網羅すると同時に、私たちの直感的なアイデアに対応する別の定義を与える試みを放棄しませんでした。</font><font style="vertical-align: inherit;">これらの試みは無益でした。</font><font style="vertical-align: inherit;">提案され、批判に耐えた各代替定義は、まったく同じクラスの数学関数を記述しているという意味で、チューリングの定義と同等であることが判明しました。</font><font style="vertical-align: inherit;">しかし、これらの研究は決して役に立たなかった。</font><font style="vertical-align: inherit;">研究の対象を別の視点から見ようとする試みは、通常、ほとんど役に立たないものです。</font><font style="vertical-align: inherit;">私たちの場合、これはいくつかの理論の出現につながりました、そのうちの1つはアロンゾ教会によって提案されたラムダ計算でした。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">怠惰は進歩のエンジンです</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ラムダ計算で何がそんなに便利で、なぜ誰もがそんなに大騒ぎしているのですか？すべてが簡単です。チューリングによって提案されたモデルでは、アルゴリズムは私たちがよく知っている一連の命令であり、これも通常の実行者が実行する必要があります。直感的です。しかし、教会の定義は異なります。この理論の枠組みにおける主要な（そして本質的に唯一の）構築メカニズムは、いわゆるラムダ項であり、現在の用語では（条件付きで）匿名関数と呼ぶことができます。この場合のプログラム（アルゴリズム）は、特定のルールに従って構築されたこれらの項の組み合わせであり、初期データはラムダ項の自由変数の値であり、計算プロセスはラムダ項（関数）の縮小（単純化）にすぎません。できるいくつかの自由変数が値を取得するとすぐに。次の事実は、ここでは予想外であることが判明しました。変数が値を受け取るとすぐに、つまり、初期データの一部をプログラムに提示するとすぐに、削減を実行できますが、1つではなく2つの方法で実行できます。前者の場合、計算プロセスは、チューリングマシンなどの一般的な機械式計算機で再現される計算プロセスと同等であることがわかります。ルールはそれに対応しています。関数自体の計算前に、関数の引数を計算する必要があります。しかし、別のオプションがあります-いわゆる部分計算です。この場合、引数の一部のみが計算される場合でも、これらの引数のみを使用する関数のその部分を計算（削減）できます。このアプローチは通常、コンピューティングの「遅延」モデルと呼ばれます。これとは対照的に、計算のチューリングモデルは「エネルギッシュ」または「貪欲」と呼ばれることがあり、それに基づいて構築されたプログラミング言語は命令型と呼ばれます。 「遅延」計算の重要な機能は、サブルーチンが3つの引数などの関数として記述されているが、実際には2つしか使用しない場合、関数の値を計算するためにこの3番目の引数を計算する必要がないことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これは私たちに興味深い実用的な可能性を与えます。</font><font style="vertical-align: inherit;">たとえば、無限シーケンスを処理する機能。</font><font style="vertical-align: inherit;">最初から</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n個の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィボナッチ数</font><font style="vertical-align: inherit;">を取得するこの方法を理解するには、関数型プログラミング全般、特にHaskell言語を使い始めた人なら誰でも簡単に理解でき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="haskell">fibonacci2 a b = a : (fibonacci2 b (a+b))<font></font>
fibonacci = fibonacci2 1 1<font></font>
<font></font>
nfibonacci n = take n fibonacci</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haskellを持つ見知らぬ人のための説明</font></font></b><div class="spoiler_text"><i>fibonacci2</i>      ,       ,         fibonacci2    b   (a+b).  ( !)     :<br>
<pre><code class="python">def fibonacci2(a, b) :<font></font>
    return [a] + fibonacci2(b, a+b)<font></font>
<font></font>
def fibonacci() :<font></font>
    return fibonacci2(1, 1)<font></font>
<font></font>
def nfibonacci(n) :<font></font>
    res = []<font></font>
    data = fibonacci()<font></font>
    for i in range(n) :<font></font>
      res.append( data[i] )<font></font>
    return res<font></font>
</code></pre><br>
   nfibonacci.<br>
</div></div><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fibonacci</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
関数</font><font style="vertical-align: inherit;">（これはまさに関数です）は、数の無限のリストを生成します。おなじみの計算モデルを使用した場合、nfibonacciが終了することは決してありません（これは完全に受け入れ可能であり、その「計算可能性」の概念に矛盾しません）。私たちは、計算の「怠惰な」モデルを使用している場合しかし、それはすぐにとすることを予告するのは容易である</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n個</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の値を取得するために、特定の値をとる</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nfibonacci</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能を</font><i><font style="vertical-align: inherit;">、</font></i><font style="vertical-align: inherit;">我々は結果であるリストの最初のn個の要素必要</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィボナッチ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能を</font><font style="vertical-align: inherit;">。この場合、次のように操作できます。リストアイテムを取得-削減を実行し、次の要素は別の削減ステップ、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-番目の引数-削減により、関数の値が取得されました。つまり、この場合、フィボナッチ数列のリストを作成する手順の「ループ」にもかかわらず、有限時間の結果が得られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、特に熱心な命令的志向のある読者は叫びます：「</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待って、率直な馬鹿だけがこの方法でフィボナッチ数のリストの構築を実装します！ループにつながらない明らかな解決策があります</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「そしてもちろん、彼は正しいでしょう。」「怠惰な」「計算からプログラムへの」「貪欲な」計算のモデルの実装を含むソリューションの愚かな転送は、実際には優れた知性の指標ではありません。この仕事を、彼の専門的な人生をずっと続けてきたプログラマーに提供するならたとえば、C言語に対する忠誠心は、カウンタと2つの状態変数を持つ1サイクルのバリアントを提供する可能性が高いでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、ポイントはフィボナッチ数自体ではありません。実際のところ、この例でシーケンスを作成するためのルールは、その要素を処理する方法から分離されています。そして、これは、処理されたシーケンスの要素がかなり複雑な方法で生成され、この場合のフィボナッチシーケンスのソリューションの「直接」の単純な転送が時間、メモリ、または単に効果がない場合に、より複雑なケースで再現できることが望ましい便利なプロパティです。コード、それを理解することは単なる人間にはアクセスできない。そのような願望は自然であり、たとえば、反復子または生成器の使用によって実現できます。たとえば、Pythonでは次のようにできます。</font></font><br>
<br>
<pre><code class="python">def fibonacci() :<font></font>
    a = 1<font></font>
    b = 1<font></font>
    yield a<font></font>
    yield b<font></font>
    while True :<font></font>
      c = a + b<font></font>
      yield c<font></font>
      a = b<font></font>
      b = c<font></font>
     <font></font>
def nfibonacci(n) :<font></font>
    return [e for e in itertools.islice(fibonacci(), n)]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fibonacci（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、要素ごとにシーケンスを作成するジェネレーターです。そしてこの場合、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィボナッチの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代わりに</font><font style="vertical-align: inherit;">、どんな複雑なジェネレーター関数</font><i><font style="vertical-align: inherit;">も存在</font></i><font style="vertical-align: inherit;">すること</font><i><font style="vertical-align: inherit;">が</font></i><font style="vertical-align: inherit;">できます。エンジンフードコードを含めて完全にコードを導入すると、非常に複雑で完全に命令型のソフトウェア設計になります。しかし、最終版はかなり「機能的」です。 C ++では、特別な</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィボナッチ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">とそのイテレータを</font><i><font style="vertical-align: inherit;">用意</font></i><font style="vertical-align: inherit;">することで、同様のトリックを実行できます</font><font style="vertical-align: inherit;">。決定はプログラミング言語の機能とプログラマーの好みによって異なりますが、目標は同じままです-プログラムの組織レベルで分割して、以前は未知の長さのシーケンスを構築する方法とその要素を処理する方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
違いは、機能的アプローチのフレームワーク内では、プログラムのこのような編成は自然であり、その実装方法そのものによって課せられるのに対し、命令のフレームワーク内では、追加の概念やデザインパターンの作成など、追加の創造的な作業が必要になることです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清潔は健康の鍵です</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らがプログラミングへの機能的アプローチについて語っている別の特性は、関数の「純度」です。</font><font style="vertical-align: inherit;">それは副作用がないことです。</font><font style="vertical-align: inherit;">つまり、同じ引数のセットを使用した関数呼び出しは、同じ結果をもたらすはずです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引用</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">された投稿</font><font style="vertical-align: inherit;">の著者は、</font><font style="vertical-align: inherit;">命令型スタイルで実行されるプログラムで、この特性が望ましい理由を十分に詳しく説明しました。</font><font style="vertical-align: inherit;">ただし、これは、使用される計算モデルの結果にすぎません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数型プログラムのすべての関数がクリーンでなければならない理由は簡単です。これらの非常に副作用があると仮定すると、関数の引数が値を取得する順序が、関数の結果に直接影響することがわかります。これは命令型アプローチのフレームワークにも当てはまると言えますが、計算の「怠惰」の場合、すべてがはるかに悪化します。関数の引数が任意の順序で互いに独立して計算できると仮定しても、「怠惰」とは（条件付きで）関数のすべてのコードが一度に実行されるわけではないことを意味します。実際には、条件付きコンパイラーが親切に提供する関数の構造と、関数に引数を提示する順序に応じて、部分的に実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数を最初に定義した場合、 </font></font><br>
<br>
<pre><code class="python">def f(x,y) :<font></font>
  ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして彼女の後 </font></font><br>
<pre><code class="python">def g(x, y) :<font></font>
  return f(y, x)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に呼び出した結果</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、G（b）は、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出しの結果に等しくなる</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F（B）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のいずれかの独立計算値に対して</font><font style="vertical-align: inherit;">及び</font><i><font style="vertical-align: inherit;">B</font></i><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">ただし、</font></i><i><i><font style="vertical-align: inherit;">f</font></i></i><i><font style="vertical-align: inherit;">に引数値の計算に影響を与える副作用がある場合、私たちの期待は残忍にだまされる可能性があります</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">たとえば、</font><i><font style="vertical-align: inherit;">bを</font></i><font style="vertical-align: inherit;">計算するとき</font><font style="vertical-align: inherit;">はファイルからの読み取りが行われ、</font><i><font style="vertical-align: inherit;">fを</font></i><font style="vertical-align: inherit;">計算するとき</font><font style="vertical-align: inherit;">は同じファイルからの読み取りも行われます。</font><font style="vertical-align: inherit;">「遅延」計算では、コードのどの部分（</font><i><font style="vertical-align: inherit;">b</font></i><font style="vertical-align: inherit;">または</font><i><font style="vertical-align: inherit;">f）</font></i><font style="vertical-align: inherit;">が事前にわからない</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）が最初に実行されます。つまり、読み取る必要があるファイルの内容がわかっていても、プログラムがどのような結果をもたらすかはわかりません。このような行動は原則として容認できないため、絶対に除外する必要があります。したがって、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「遅延」計算のモデルの枠組み</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内</font><i><font style="vertical-align: inherit;">では、関数の（制御されていない）副作用を禁止する必要があります</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
貪欲な計算順序を適用すると、副作用がはるかに予測しやすくなります。このため、このためにのみ、命令型プログラミングで許可されています。しかし、それらを悪用すると、機能はバグに変わります。したがって、それらを乱用しないでください。繰り返しになりますが、関数型プログラミングに自然な「純度」の概念は、命令型の世界で求められています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、論文</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数型プログラム-純粋な関数で構成されるプログラム </font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定義として見ると正しくありません。</font><font style="vertical-align: inherit;">はい、関数型プログラムは「純粋な」関数で構成されていますが、純粋な関数で構成されるプログラムは「関数型」である必要はありません。</font><font style="vertical-align: inherit;">これは彼女のプロパティですが、定義プロパティではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、問題があります。状態と平凡な入出力さえ保存する能力は、副作用に直接関連するものです。そして、彼らのいない人生は痛みと苦しみに満ちています。問題が発生します：副作用と「遅延」計算をどのように組み合わせるか？一般的な答えは方法ではありません。答えは正しいです。それぞれの場合において、満足のいく特定の解決策が求められるべきです。計算の「純度」の概念に違反せずに副作用を伴う計算を再現する多くの方法が、カテゴリー理論から借りたモナドの一般的な概念に適合していることがわかりました。それが何であり、何と一緒に食べられるのかを説明するためにもう一度試したいとは思いません。なぜなら、いずれにせよ、状態変数を具体的にどのように実装できるかについての説明が置き換えられない（そして私の経験ではそれが単純化されない）からです。「純粋な」関数型言語における例外および同様のもの。主な教訓は、命令型プログラミングは関数型だけでなく関数型にとってもインスピレーションの源であるということです。さらに、アイデアがフィルターなどの競合する概念を通過し、変更された形で戻って、新しいツールの出現につながる場合もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必須の世界ではモナドが必要ですか？私はこの問題について確立された意見はありません。著者で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、この</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">断食が必要なことを確認してください。関数型プログラムでのモナドの概念の使用は、通常、このモナドが隠す特定の副作用に関係なく、特定のアルゴリズムを定式化できるという事実に関連しているので、私はこのステートメントを疑う傾向があります。言い換えれば、ユーザー定義の（仮説であり、まだ人類によって作成されていない）データ型がモナドの要件を満たしている場合、そのために書かれたアルゴリズムは正しく動作します。これは主に理論的な研究で便利です。しかし、いくつかのニュアンスがあります。第一に、なぜラッパーの副作用を隠すのが自然現象である言語で効果的であるのかがはっきりしていません。第二に、特定のデータタイプと特定のターゲットアーキテクチャで特定のプログラムを作成する場合、そのような一般化されたアルゴリズムは、生産性を向上させるために再構築を余儀なくされることがよくあります。命令型のモナドを使用して一般化されたアルゴリズムを書くことは可能ですが、このアプローチの適切さは私の疑問を引き起こします。 std ::型の一部の多分類似体:: C ++からのオプションがモナドとして宣言されるという事実は、何らかの形でその使用の実践に影響を与える可能性は低いです。</font></font><br>
<br>
<h3>   ?</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高階関数は関数型プログラムで非常に広く使用されているツールであるため、一部のプログラミング言語で類似のものをサポートするという事実は、一部の奇妙な個人がこの言語を関数型として認識するのに十分です。 「高次関数」とは何ですか？これは、引数として他の関数を操作したり、結果として関数を返したりする関数です。ここで議論を引き起こす可能性があると思われますか？多くのことがわかります。まず、「機能」という用語で一般的に理解されていること。プログラマは通常、単純に推論します。何かを関数として呼び出すことができる場合、それは関数と見なすことができます。命令型アプローチのフレームワークでは、これは理にかなっています。直感的には、関数は、与えられた引数のセットに対して特定の結果をもたらすということです。副作用の存在を認める場合、実際的な意味では、言語の「通常の」関数と、たとえば、オーバーロードされた演算子（）を持つクラスのオブジェクトとの間に違いはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、関数型プログラミングでは、このような関数の定義は、この関数自体の部分的な計算の概念を解釈することができないため、十分に構成的ではありません。関数型プログラミングでは、関数はプログラムの構造要素の「1つ」ではありませんが、ある意味では反対です。すべてのプログラム要素は関数です。したがって、実際には、これは「関数型プログラミング」です。さらに、すべてが関数である場合、つまり、任意の関数の引数が関数である場合、引数を持つ関数はすべて高次関数です。したがって、高階関数は関数型プログラムの自然な要素です。別のクラスに割り当てても意味がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より高次の関数として、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マップ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font><i><font style="vertical-align: inherit;">フォールドが</font></i><font style="vertical-align: inherit;">通常与えられます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。しかし</font><font style="vertical-align: inherit;">、2つの引数</font><i><font style="vertical-align: inherit;">f（x、y）の</font></i><font style="vertical-align: inherit;">より自明な- </font><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考え</font><font style="vertical-align: inherit;">ます。 「遅延」計算のモデルの枠組みの中で、この関数の引数は、本当に必要な場合にのみ計算されます。最初の引数が</font><i><font style="vertical-align: inherit;">xであるとし</font></i><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">
この引数を計算し、その値</font><i><font style="vertical-align: inherit;">f</font></i><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">提供し</font><font style="vertical-align: inherit;">、さらに引数</font><i><font style="vertical-align: inherit;">yの</font></i><font style="vertical-align: inherit;">値を使用せずに計算できるすべてのものを計算します</font><font style="vertical-align: inherit;">。その後、残りの計算は</font><font style="vertical-align: inherit;">、たとえば</font><i><font style="vertical-align: inherit;">g（y）の</font></i><font style="vertical-align: inherit;">ように、すでに</font><i><font style="vertical-align: inherit;">x</font></i><font style="vertical-align: inherit;">に依存しない</font><font style="vertical-align: inherit;">新しい関数として表すことができます</font><font style="vertical-align: inherit;">。しかし、この場合、</font><i><font style="vertical-align: inherit;">f</font></i><font style="vertical-align: inherit;">を2つの引数の関数としてではなく、1つの引数の関数として</font><font style="vertical-align: inherit;">正式に</font><font style="vertical-align: inherit;">表す</font><font style="vertical-align: inherit;">ことを妨げるもの</font><font style="vertical-align: inherit;">はありません。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f（x）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その結果は別の関数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g（y）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。つまり、関数型アプローチのフレームワーク内で</font><font style="vertical-align: inherit;">は、引数が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N&gt; 1の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数は</font><font style="vertical-align: inherit;">高次関数です。これは、1つの引数の関数として解釈でき、その結果は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-1個の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引数の</font><font style="vertical-align: inherit;">関数になり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この動作を命令型アプローチの一部として実装できますか？もちろん、我々はできます。 Pythonでは、次のように記述します。</font></font><br>
<br>
<pre><code class="python">def partial(f, x) :<font></font>
	def g(*args) :<font></font>
		return f(x, *args)<font></font>
	return g<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の引数が</font><i><font style="vertical-align: inherit;">N個の</font></i><font style="vertical-align: inherit;">引数</font><font style="vertical-align: inherit;">の関数で</font><font style="vertical-align: inherit;">あり、2番目が最初の引数の値で</font><font style="vertical-align: inherit;">
ある</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を呼び出すことにより、</font><font style="vertical-align: inherit;">引数の関数</font><i><font style="vertical-align: inherit;">N-1</font></i><font style="vertical-align: inherit;">を取得</font><i><font style="vertical-align: inherit;">し</font></i><font style="vertical-align: inherit;">ます。これで、</font><i><font style="vertical-align: inherit;">N-1</font></i><font style="vertical-align: inherit;">引数</font><font style="vertical-align: inherit;">関数を使用できる場所ならどこでも新しい関数を使用できます</font><font style="vertical-align: inherit;">。つまり、関数型プログラムと同じものを取得しました。そう？いいえ、これは好きではありません。本当に機能的なプログラムを扱っている場合は、</font><i><font style="vertical-align: inherit;">partial</font></i><font style="vertical-align: inherit;">を呼び出すと</font><font style="vertical-align: inherit;">、最初の引数の値の一部を計算します。場合によって</font><font style="vertical-align: inherit;">は、</font><i><font style="vertical-align: inherit;">g</font></i><font style="vertical-align: inherit;">が定数値であることがわかる場合もあります。命令型アナログには何がありますか？引数</font><i><font style="vertical-align: inherit;">x</font></i><font style="vertical-align: inherit;">の渡された値</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">覚えているだけです（関数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテキストに追加されます</font><font style="vertical-align: inherit;">）。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を呼び出すと</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の値が</font><font style="vertical-align: inherit;">ビンから取り出され、単純に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代入され</font><font style="vertical-align: inherit;">ます。つまり、形式に違いはありませんが、内容には違いがあります-重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数から関数を使用すると、多くの重要なアルゴリズムを自然に記述できるので便利です。それで、彼らは命令型プログラミング言語で現れることを義務付けられました。そして彼らは現れた。しかし、彼らは異なる計算モデルを使用しているため、新しいコンセプトの開発が必要でした。そしてそれらは開発されました。たとえば、上記のクロージャ。つまり、命令型言語の高次の関数は、関数型言語で外部からのみ観察できることに対応しています。しかし、内容は完全に異なります。これはプログラマにとって重要ですか？おそらくそうではありませんが、彼が好きなプログラミング言語で同様の機能を実装するメカニズムがどのように機能するかをよく理解している場合に限ります。それ以外の場合は、たとえば、「部分的なアプリケーション」を実装し、新しい関数を作成するときに閉じることができます（まあ、またはあなたの場合、関数のように見えますか）値の代わりにリンクして、興味深いプログラムの動作を取得します。そしてその後、機能的アプローチの劣等性について叫びます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">だれがだれをだましていたのですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレゼンテーションのこの段階では、セミコロンを付けてメインの質問に戻ることがかなり可能です。</font><font style="vertical-align: inherit;">これで、次のステートメントを作成できます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数型プログラミングと命令型プログラミングの主な違いは、関数の純粋性、無名関数の存在、高次関数、モナド、パラメトリック多態性などではありません。</font><font style="vertical-align: inherit;">主な違いは、異なる計算モデルの使用です。</font><font style="vertical-align: inherit;">それ以外はすべて結果にすぎません。</font></font></li>
<li>,         ,       .    .     ,      «»  «» .    ,                  .  .</li>
<li>  ,      ,        ,           .        .   — .</li>
<li>      ,      .       ,        «» ;   ,       .           ,      -     ,   -      .    .</li>
<li>   ,                 .     ,        . , ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  </a>    ,                           .          .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数型プログラミングは、あなたが（おそらく）言われたことです。これらは、ベータ削減、固定小数点コンビネーター、モナド、Hindley-Milnerタイピングなどです。ラッパーとコンテンツを混同しないでください。 FPは最も単純な数学に基づいていないため、お茶を1杯飲みながら2週間は習得できません。差し迫った問題やプロジェクトに直接投影されることはまずありません。この知識から保証された迅速な利益を得ることはできません。しかし、機能的アプローチにあるものの多くの要素が借りられ、処理され、最終的には大規模プロジェクトの開発に向けられたプログラミング言語で実装されます。はい、それらは機能的な祖先とは異なる方法で配置されていますが、これによってそれらの有用性が低下するわけではありません。臨床馬鹿だけがHaskellが悪い言葉であるという深刻なメッセージを放送します、どんな種類の会計用のプログラムも書くのが難しいからです。専門的な活動の観点からも、理論の複雑さに深く没頭することなく知性の存在に苦しむ人は、コードを改善するために採用すべき関数型プログラミングの実践を正確に理解できます。説得力のあるデモンストレーションに感謝の意を表します</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイハスト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数型プログラミングを学びます。</font><font style="vertical-align: inherit;">自分の名の下に。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja492448/index.html">先週のフロントエンドの世界からの新鮮な食材のダイジェストNo.406（2020年3月9日〜15日）</a></li>
<li><a href="../ja492450/index.html">03.31に更新。コロナウイルスは空気中を伝染しますか？現在知られていること</a></li>
<li><a href="../ja492454/index.html">アーキテクチャリファクタリングをクライアントに販売するか、開発者の問題は何か</a></li>
<li><a href="../ja492456/index.html">（地球物理学）モデルを視覚化してアニメーション化する方法。生データを表示</a></li>
<li><a href="../ja492458/index.html">M5Stack（Arduino）のシンプルなGUI</a></li>
<li><a href="../ja492462/index.html">真実の情報源：アナリストがマネージャーと開発者に協力する方法を教える方法</a></li>
<li><a href="../ja492464/index.html">DBA：同期とインポートを適切に整理する</a></li>
<li><a href="../ja492466/index.html">わずか5つのステップで、cPanelを使用するホストプロバイダーからRusonixのPleskに移行する方法</a></li>
<li><a href="../ja492468/index.html">レノボThinkserver SE350：周辺からのヒーロー</a></li>
<li><a href="../ja492474/index.html">Androidボックスの情報を構造化し、通常の接頭辞で何ができるかを分析します。</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>