<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳 🙌🏿 🐧 Unityのシンプルなゾンビシューター 👨🏿‍🤝‍👨🏾 🐽 👫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="みなさん、こんにちは！まもなく、Unity Games Developerコースの最初のグループでクラスが始まります。コースの開始を期待して、Unityでゾンビシューターを作成するオープンレッスンが開催されました。このウェビナーは、Rovio Entertainment Corporationのシニ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Unityのシンプルなゾンビシューター</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/485210/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">みなさん、こんにちは！まもなく、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity Games Developer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コースの最初のグループでクラスが始まります</font><font style="vertical-align: inherit;">。コースの開始を期待して、</font><font style="vertical-align: inherit;">Unityでゾンビシューターを作成</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するオープンレッスン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が開催されました。このウェビナーは</font><font style="vertical-align: inherit;">、Rovio Entertainment Corporationのシニアゲームデベロッパーである</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nikolai Zapolnov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が主催しました</font><font style="vertical-align: inherit;">。彼はまた、詳細な記事を書いた。</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/z6/pk/iv/z6pkiv4cismrguzozecv51foouk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この記事では、Unityでゲームを作成するのがいかに簡単かを示したいと思います。基本的なプログラミングの知識があれば、このエンジンですぐに作業を開始して、最初のゲームを作成できます。</font></font><br>
<br>
<hr><br>
<i> №1:     .      Unity,      .</i><br>
<br>
<i> №2:       -   .  ,  «»  «»    .</i><br>
<br>
<b>,   !</b><br>
<a name="habracut"></a><br>
<h2>  </h2><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unityエディターに慣れている場合は、概要をスキップして、「ゲームワールドの作成」セクションに直接進むことができます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Unityの基本的な構造単位は「シーン」です。通常、シーンはゲームの1つのレベルですが、1つのシーンに一度に複数のレベルがある場合や、逆に、1つの大きなレベルを動的に読み込まれる複数のシーンに分割することもできます。シーンはゲームオブジェクトで満たされ、順番にコンポーネントで満たされます。さまざまなゲーム機能を実装するコンポーネントです：オブジェクトの描画、アニメーション、物理など。このモデルでは、Legoコンストラクターのおもちゃのような単純なブロックから機能を組み立てることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C＃プログラミング言語を使用して、コンポーネントを自分で作成できます。これがゲームロジックの書き方です。以下でこれがどのように行われるかを見ていきますが、ここではエンジン自体を見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンジンを起動して新しいプロジェクトを作成すると、4つの主要な要素を選択できるウィンドウが表示され</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5m/0o/9j/5m0o9jxwps3qwz3pbmvlchxveau.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。スクリーンショットの左上隅に、「階層」ウィンドウがあります。ここでは、現在開いているシーンのゲームオブジェクトの階層を確認できます。 Unityは2つのゲームオブジェクトを作成しました。プレイヤーがゲームの世界を見ることができるカメラ（「メインカメラ」）と、シーンを照らす「指向性ライト」です。それがないと、黒い四角形しか見えません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中央にはシーン編集ウィンドウ（「シーン」）があります。これでレベルが表示され、視覚的に編集できます。オブジェクトをマウスで移動および回転して、何が起こるかを確認します。近くには、現在アクティブでない「ゲーム」タブが表示されます。これに切り替えると、カメラからゲームがどのように見えるかを確認できます。 （ツールバーの再生アイコンのボタンを使用して）ゲームを開始すると、Unityはこのタブに切り替わり、起動したゲームを再生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
右上の部分は「インスペクタ」ウィンドウです。このウィンドウで、Unityは選択されたオブジェクトのパラメーターを表示し、それらを編集できます。特に、選択したカメラには2つのコンポーネントがあることがわかります。「変換」はゲームの世界でのカメラの位置を設定し、実際には「カメラ」はカメラの機能を実装しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、Transformコンポーネントは、Unityのすべてのゲームオブジェクトで何らかの形になっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に、下部にある「プロジェクト」タブには、プロジェクトにあるいわゆるアセットがすべて表示されます。アセットは、テクスチャ、スプライト、3Dモデル、アニメーション、サウンドと音楽、設定ファイルなどのデータファイルです。つまり、レベルまたはユーザーインターフェイスの作成に使用できるデータです。 Unityは多数の標準形式（たとえば、画像の場合はpngとjpg、3dモデルの場合はfbx）を理解するため、プロジェクトへのデータの読み込みに問題はありません。そして、私のように、描く方法がわからない場合は、Unity Asset Storeからアセットをダウンロードできます。UnityAsset Storeには、あらゆる種類のリソースの膨大なコレクションが含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「プロジェクト」タブの右側に、非アクティブな「コンソール」タブが表示されます。</font><font style="vertical-align: inherit;">Unityは警告とエラーメッセージをコンソールに書き込むため、定期的に確認してください。</font><font style="vertical-align: inherit;">特に何かがうまくいかない場合-ほとんどの場合、コンソールは問題の原因を示唆します。</font><font style="vertical-align: inherit;">また、コンソールはゲームコードからのメッセージを表示してデバッグできます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームの世界を作成する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はプログラマーであり、鶏の足よりも描写が悪いので、グラフィックのために、Unity Asset Storeからいくつかの無料のアセットを取得しました。これらのリンクは、この記事の最後にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのアセットから、私たちが操作する簡単なレベルを集めました：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/07/y-/cr/07y-crxk0zc6zywqh8vga90qg-s.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
魔法はありません、好きなオブジェクトをプロジェクトウィンドウからドラッグし、マウスを使って好きなように配置しました：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ll/xb/ca/llxbca3cdunouswhcy2b4jgpgha.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、Unityではワンクリックで標準オブジェクトをシーンに追加できます、立方体、球、平面など。これを行うには、階層ウィンドウを右クリックして、たとえば3DオブジェクトD平面を選択します。そのため、私のレベルのアスファルトは、一連のアセットからテクスチャを「プル」した一連のプレーンから組み立てられています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注：スケール値が大きいプレーンではなく、なぜ多くのプレーンを使用したのか疑問に思っている場合、答えは非常に簡単です。スケールが大きい1つのプレーンは、テクスチャが大きく拡大され、シーン内の他のオブジェクトに対して不自然に見えます（これはパラメーターで修正できます）素材ですが、できるだけシンプルにしようとしていますよね？）</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">道を求めてゾンビ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だから、私たちはゲームレベルを持っていますが、まだ何も起こっていません。私たちのゲームでは、ゾンビがプレイヤーを追いかけて攻撃します。このため、ゾンビはプレイヤーに向かって移動し、障害物を回避できる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを実装するには、「ナビゲーションメッシュ」ツールを使用します。このツールは、シーンデータに基づいて、移動可能な領域を計算し、ゲーム中にレベル内の任意のポイントから他のポイントへの最適ルートを検索できる一連のデータを形成します。このデータはアセットに保存され、将来変更することはできません。このプロセスは「ベイク」と呼ばれます。動的に変化する障害物が必要な場合は、NavMeshObstacleコンポーネントを使用できますが、これはゲームでは必要ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要なポイント：Unityがどのオブジェクトを計算に含める必要があるかを知るために、各オブジェクトのインスペクター（[階層]ウィンドウですべてを一度に選択できます）で、[静的]オプションの横にある下矢印をクリックし、[ナビゲーション静的]をオンにします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d9/us/wk/d9uswkd5hafxmqqxlr3ujr0ed_u.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、残りのアイテムUnityがシーンのレンダリングを最適化するのにも役立ちます。今日はそれらについて詳しく説明しませんが、エンジンの基本を学習し終えたら、他のパラメーターを扱うことを強くお勧めします。 1つのチェックマークでフレームレートが大幅に増加する場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、メニュー項目Window⇨AI⇨Navigationを使用し、開いたウィンドウで[Bake]タブを選択します。ここでUnityは、キャラクターの高さと半径、歩くことができる地球の最大傾斜角、階段の最大高さなどのパラメーターを設定するように提案します。まだ何も変更せず、「ベイク」ボタンを押すだけです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zs/my/uo/zsmyuoqaopw11zon8bua6arf9aa.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unityが必要な計算を行い、結果を表示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3q/lg/t6/3qlgt6ze2hkj5sv8npdlr6ohkk8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、青</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">あなたが歩くことができる領域を</font><font style="vertical-align: inherit;">示して</font><font style="vertical-align: inherit;">います。ご覧のように、Unityは障害物の周りに小さな側面を残しました-この側面の幅はキャラクターの半径に依存します。したがって、キャラクターの中心がブルーゾーンにある場合、障害物に「落ち込む」ことはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
計算されたナビゲーショングリッドがあるので、NavMeshAgentコンポーネントを使用して、移動ルートを検索し、ゲームオブジェクトの移動をレベルで制御できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「ゾンビ」ゲームオブジェクトを作成して、アセットからのゾンビの3DモデルとNavMeshAgentコンポーネントを追加してみましょう</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ij/jy/cb/ijjycbpwk8kjyyhkhter8jrbu7g.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。今すぐゲームを開始しても、何も起こりません。 NavMeshAgentコンポーネントに移動先を通知する必要があります。これを行うには、C＃で最初のコンポーネントを作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトウィンドウで、ルートディレクトリ（「アセット」と呼ばれます）を選択し、ファイルのリストで右クリックして「スクリプト」ディレクトリを作成します。すべてのスクリプトをそこに格納して、プロジェクトに秩序があるようにします。次に、「スクリプト」内で「ゾンビ」スクリプトを作成して、ゾンビゲームオブジェクトに追加します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dz/_d/a1/dz_da1d0ybbvslw1g3tvkq8vgau.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スクリプトをダブルクリックすると、エディターでスクリプトが開きます。</font><font style="vertical-align: inherit;">Unityが私たちのために作成したものを見てみましょう。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Zombie</span> : <span class="hljs-title">MonoBehaviour</span><font></font>
{<font></font>
    <span class="hljs-comment">// Start is called before the first frame update</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// Update is called once per frame</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはコンポーネントの標準在庫です。</font><font style="vertical-align: inherit;">ご覧のように、UnityはSystem.CollectionsライブラリとSystem.Collections.Genericライブラリを接続しました（これらは現在必要ではありませんが、Unityゲームコードで必要になることが多いため、標準テンプレートに含まれています）、およびすべてを含むUnityEngineライブラリコアエンジンAPI。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、UnityがZombieクラスを作成しました（名前はファイル名と一致します。これは重要です：それらが一致しない場合、Unityはスクリプトをシーン内のコンポーネントと一致させることができません）。</font><font style="vertical-align: inherit;">クラスはMonoBehaviourから継承されます-これはユーザーが作成したコンポーネントの基本クラスです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスの中で、UnityはStartとUpdateの2つのメソッドを作成しました。エンジンはこれらのメソッド自体を呼び出します。開始-シーンが読み込まれた直後、更新-すべてのフレーム。実際、エンジンによって呼び出されるそのような関数はたくさんありますが、それらのほとんどは今日必要ありません。完全なリストとその呼び出しのシーケンスは、常にドキュメントにあります：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">//docs.unity3d.com/Manual/ExecutionOrder.html</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ゾンビをマップ上で動かしてみましょう！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開始するには、UnityEngine.AIライブラリを接続する必要があります。 NavMeshAgentクラスと、ナビゲーショングリッドに関連する他のクラスが含まれています。これを行うには、使用するUnityEngine.AIディレクティブをファイルの先頭に追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、NavMeshAgentコンポーネントにアクセスする必要があります。</font><font style="vertical-align: inherit;">これを行うには、標準のGetComponentメソッドを使用できます。</font><font style="vertical-align: inherit;">これにより、このメソッドを呼び出すコンポーネントが配置されている同じゲームオブジェクト内の任意のコンポーネントへのリンクを取得できます（この場合は、「ゾンビ」ゲームオブジェクトです）。</font><font style="vertical-align: inherit;">クラスのNavMeshAgent navMeshAgentフィールドを取得してみましょう。StartメソッドでNavMeshAgentへのリンクを取得し、ポイント（0、0、0）に移動するように要求します。</font><font style="vertical-align: inherit;">次のスクリプトを取得する必要があります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> UnityEngine.AI;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Zombie</span> : <span class="hljs-title">MonoBehaviour</span><font></font>
{<font></font>
    NavMeshAgent navMeshAgent;<font></font>
<font></font>
    <span class="hljs-comment">// Start is called before the first frame update</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();<font></font>
        navMeshAgent.SetDestination(Vector3.zero);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// Update is called once per frame</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームを開始すると、ゾンビがマップの中心に移動する方法がわかります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dx/uz/u1/dxuzu157nhtqaj85o0afxbm_s7k.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゾンビが被害者を追いかけている</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すごい。しかし、ゾンビは退屈で孤独</font><font style="vertical-align: inherit;">です。プレーヤーの</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">犠牲者</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をゲームに追加し</font><s><font style="vertical-align: inherit;">て</font></s><font style="vertical-align: inherit;">みましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゾンビとの類推により、「プレーヤー」ゲームオブジェクトを作成します（今回は警官の3Dモデルを選択します）。また、NavMeshAgentコンポーネントと新しく作成したプレーヤースクリプトを追加します。プレーヤースクリプトの内容にはまだ触れませんが、ゾンビスクリプトに変更を加える必要があります。また、NavMeshAgentコンポーネントでプレーヤーのPriorityプロパティ値を10に設定することをお勧めします（または標準の50未満のその他の値、つまりプレーヤーに高い優先順位を与えます）。この場合、プレイヤーとゾンビがマップ上で出会うと、ゾンビはプレイヤーを動かすことができなくなり、プレイヤーはゾンビを押し出すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレイヤーを追跡するには、ゾンビは自分の位置を知る必要があります。</font><font style="vertical-align: inherit;">そのためには、標準のFindObjectOfTypeメソッドを使用して、Zombieクラスでそれにリンクを取得する必要があります。</font><font style="vertical-align: inherit;">リンクを覚えているので、プレーヤーの変換コンポーネントに移動して、位置の値を尋ねることができます。</font><font style="vertical-align: inherit;">また、ゾンビがゲームの開始時だけでなく、常にプレーヤーを追跡するために、UpdateメソッドでNavMeshAgentの目標を設定します。</font><font style="vertical-align: inherit;">次のスクリプトを取得します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> UnityEngine.AI;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Zombie</span> : <span class="hljs-title">MonoBehaviour</span><font></font>
{<font></font>
    NavMeshAgent navMeshAgent;<font></font>
    Player player;<font></font>
<font></font>
    <span class="hljs-comment">// Start is called before the first frame update</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();<font></font>
        player = FindObjectOfType&lt;Player&gt;();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// Update is called once per frame</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        navMeshAgent.SetDestination(player.transform.position);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームを実行し、ゾンビが犠牲者を見つけたことを確認します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/j3/lv/vc/j3lvvcaltksjiu44tzh-rijewi4.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エスケープエスケープ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのプレーヤーはアイドルのようにまだそこに立っています。これは明らかに、彼がそのような攻撃的な世界で生き残るのに役立つわけではないので、マップ内を移動するように彼に教える必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、Unityから押されたキーに関する情報を受け取る必要があります。標準入力クラスのGetKeyメソッドは、そのような情報を提供するだけです！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意：一般に、この入力方法は完全に標準的なものではありません。 Input.GetAxisを使用し、プロジェクト設定⇨入力マネージャーを介してバインドすることをお勧めします。さらに良いのは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい入力システム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。しかし、この記事は長すぎることがわかったので、もっと簡単にしましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Playerスクリプトを開き、次のように変更します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> UnityEngine.AI;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> : <span class="hljs-title">MonoBehaviour</span><font></font>
{<font></font>
    NavMeshAgent navMeshAgent;<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> moveSpeed;<font></font>
<font></font>
    <span class="hljs-comment">// Start is called before the first frame update</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// Update is called once per frame</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        Vector3 dir = Vector3.zero;<font></font>
        <span class="hljs-keyword">if</span> (Input.GetKey(KeyCode.LeftArrow))<font></font>
            dir.z = <span class="hljs-number">-1.0f</span>;
        <span class="hljs-keyword">if</span> (Input.GetKey(KeyCode.RightArrow))<font></font>
            dir.z = <span class="hljs-number">1.0f</span>;
        <span class="hljs-keyword">if</span> (Input.GetKey(KeyCode.UpArrow))<font></font>
            dir.x = <span class="hljs-number">-1.0f</span>;
        <span class="hljs-keyword">if</span> (Input.GetKey(KeyCode.DownArrow))<font></font>
            dir.x = <span class="hljs-number">1.0f</span>;<font></font>
        navMeshAgent.velocity = dir.normalized * moveSpeed;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゾンビの場合と同様に、StartメソッドでプレーヤーのNavMeshAgentコンポーネントへのリンクを取得し、それをクラスフィールドに格納します。しかし、今ではmoveSpeedフィールドも追加しました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このフィールドはパブリックであるため、その値はUnityのインスペクターで直接編集できます。チームにゲームデザイナーがいる場合は、プレーヤーのパラメーターを編集するためにコードにアクセスする必要がないことを非常に喜んでいます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
速度として10を設定し</font></font><br>
<br>
<img src="https://habrastorage.org/webt/o9/ro/cx/o9rocx0w0v3djxjgdt35ca59aug.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。Updateメソッドでは、Input.GetKeyを使用して、キーボードの矢印が押されているかどうかを確認し、プレーヤーの方向ベクトルを形成します。ここではX座標とZ座標を使用していますが、これはUnityでY軸が空を見上げ、地球がXZ平面にあるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モーションdirの方向の方向ベクトルを形成した後、それを正規化します（そうしないと、プレーヤーが斜めに移動したい場合、ベクトルは単一のベクトルよりも少し長くなり、この移動は直接移動するよりも速くなります）、所定の移動速度を掛けます。結果はnavMeshAgent.velocityに渡され、エージェントが残りを実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームを起動することで、ようやくゾンビから安全な場所に逃げることができ</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mn/gv/7w/mngv7wimzjqsdlfja2ghro-ovn8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。カメラがプレイヤーと一緒に動くように、別の簡単なスクリプトを書いてみましょう。それを「PlayerCamera」と呼びましょう：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerCamera</span> : <span class="hljs-title">MonoBehaviour</span><font></font>
{<font></font>
    Player player;<font></font>
    Vector3 offset;<font></font>
<font></font>
    <span class="hljs-comment">// Start is called before the first frame update</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        player = FindObjectOfType&lt;Player&gt;();<font></font>
        offset = transform.position - player.transform.position;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// Update is called once per frame</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LateUpdate</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        transform.position = player.transform.position + offset;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このスクリプトの意味は、大まかに理解する必要があります。</font><font style="vertical-align: inherit;">機能から-ここでは更新の代わりにLateUpdateを使用します。</font><font style="vertical-align: inherit;">このメソッドはUpdateに似ていますが、常にシーン内のすべてのスクリプトのUpdateが完了した後に厳密に呼び出されます。</font><font style="vertical-align: inherit;">この場合、LateUpdateを使用します。カメラを移動する前に、NavMeshAgentがプレーヤーの新しい位置を計算することが重要であるためです。</font><font style="vertical-align: inherit;">そうしないと、不快な「ジャーク」効果が発生する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコンポーネントを「メインカメラ」ゲームオブジェクトにアタッチしてゲームを開始すると、プレーヤーのキャラクターは常にスポットライトを浴びます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アニメーションの瞬間</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少しの間、ゾンビの黙示録の状況での生存の問題から抜け出し、永遠について-アートについて考えます。私たちのキャラクターは、未知の力（おそらくアスファルトの下の磁石）によって動くアニメーションの彫像のように見えます。そして、私は彼らに現実の（そしてそれほど多くはない）人々のように見えることを望みます-彼らは腕と脚を動かしました。これには、AnimatorコンポーネントとAnimator Controllerというツールが役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Animator Controllerは有限ステートマシン（ステートマシン）であり、特定の状態（キャラクターが立っている、キャラクターがオンになっている、キャラクターが死んでいるなど）を設定し、それらにアニメーションをアタッチして、ある状態から別の状態への遷移のルールを設定します。 Unityは、対応するルールが機能するとすぐに、あるアニメーションから別のアニメーションに自動的に切り替えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゾンビ用のアニメーターコントローラーを作成しましょう。これを行うには、プロジェクトにAnimationsディレクトリを作成し（プロジェクトの順序を覚えておいてください）、その中に-右ボタンを使用して-Animator Controllerを作成します。そして、彼を「ゾンビ」と呼びましょう。ダブルクリックすると、エディタが表示されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t1/54/ak/t154aknnrk7f0lwdlcmvj69uxqo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでのところ、状態はありませんが、2つのエントリポイント（「Entry」と「Any State」）と1つの出口ポイント（「Exit」）があります。アセットからいくつかのアニメーションをドラッグし</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xg/cx/gw/xgcxgwkbtqsbqux7cj9y5qnwnk0.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます</font><font style="vertical-align: inherit;">：</font><font style="vertical-align: inherit;">ご覧のとおり、最初のアニメーションをドラッグするとすぐに、Unityはそれを自動的にエントリーエントリーポイントにバインドしました。これは、いわゆるデフォルトのアニメーションです。レベル開始直後に再生されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の状態に切り替える（および別のアニメーションを再生する）には、遷移ルール​​を作成する必要があります。そのためには、まず、アニメーションを管理するためのコードから設定するパラメーターを追加する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エディタウィンドウの左上隅に「レイヤー」と「パラメータ」の2つのボタンがあります。デフォルトでは「レイヤー」タブが選択されていますが、「パラメーター」に切り替える必要があります。ここで、「+」ボタンを使用して、float型の新しいパラメーターを追加できます。それを「速度」と呼びましょう：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/po/is/nj/poisnjmj39qel2ofz_meiyginsw.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、速度が0より大きい場合はアニメーション「Z_run」を再生し、速度がゼロの場合は「Z_idle_A」を再生するようにUnityに指示する必要があります。これを行うには、2つの遷移を作成する必要があります。1つは「Z_idle_A」から「Z_run」へ、もう1つは反対方向です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アイドルから実行への移行から始めましょう。長方形「Z_idle_A」を右クリックし、「Make Transition」を選択します。矢印が表示され、クリックしてパラメーターを設定できます。まず、「終了時間あり」のチェックを外す必要があります。これを行わないと、アニメーションは私たちの状態に従ってではなく、前のアニメーションの再生が終了したときに切り替わります。これはまったく必要ないので、チェックを外します。次に、以下の条件リスト（「条件」）で「+」をクリックする必要があります。Unityによって条件が追加されます。この場合のデフォルト値はまさに私たちが必要とするものです。アイドルから実行に切り替えるには、「速度」パラメーターがゼロより大きくなければなりません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vt/rw/qy/vtrwqy-jyfhgrai9ruymphu_mwi.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
類推により、反対方向に遷移を作成しますが、条件として、0.0001未満の「速度」を指定します。 float型のパラメーターの等価性チェックはありません。比較できるのは、多かれ少なかれのみ</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vz/ki/bu/vzkibunzaoxqfdfysekucvcqepa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
です。コントローラーをゲームオブジェクトにバインドする必要があります。シーン内のゾンビの3Dモデル（これは「ゾンビ」オブジェクトの子です）を選択し、マウスをAnimatorコンポーネントの対応するフィールドにドラッグします。あと</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lr/pv/pq/lrpvpqbl__neecouj3uyxdepqka.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
は、速度パラメーターを制御するスクリプトを記述するだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の内容のMovementAnimatorスクリプトを作成します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> UnityEngine.AI;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MovementAnimator</span> : <span class="hljs-title">MonoBehaviour</span><font></font>
{<font></font>
    NavMeshAgent navMeshAgent;<font></font>
    Animator animator;<font></font>
<font></font>
    <span class="hljs-comment">// Start is called before the first frame update</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        navMeshAgent = GetComponent&lt;NavMeshAgent&gt;();<font></font>
        animator = GetComponentInChildren&lt;Animator&gt;();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// Update is called once per frame</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        animator.SetFloat(<span class="hljs-string">"speed"</span>, navMeshAgent.velocity.magnitude);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、他のスクリプトと同様に、StartメソッドでNavMeshAgentにアクセスします。また、Animatorコンポーネントにもアクセスできますが、MovementAnimatorコンポーネントは「ゾンビ」ゲームオブジェクトにアタッチされ、AnimatorはGetComponentではなく子オブジェクトにあるため、標準のGetComponentInChildrenメソッドを使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Updateメソッドでは、NavMeshAgentに速度ベクトルを要求し、その長さを計算して、速度パラメータとしてアニメータに渡します。魔法はありません、すべてが科学です！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、MovementAnimatorコンポーネントをZombieゲームオブジェクトに追加します。ゲームが開始すると、ゾンビがアニメーション化されていることがわかります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uz/da/yt/uzdaytgsxzstqj8rnzx11rfa8ti.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アニメーターコントロールコードを別のMovementAnimationコンポーネントに配置したため、プレーヤーに簡単に追加できることに注意してください。</font><font style="vertical-align: inherit;">コントローラーを最初から作成する必要はありません。ゾンビコントローラーをコピーし（「ゾンビ」ファイルを選択してCtrl + Dキーを押すことで実行できます）、状態の四角形のアニメーションを「m_idle_」と「m_run」に置き換えることができます。</font><font style="vertical-align: inherit;">それ以外はゾンビのようなものです。</font><font style="vertical-align: inherit;">これは演習として残しておきます（まあ、または記事の最後にあるコードをダウンロードしてください）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
便利な小さな追加の1つは、次の行をZombieクラスに追加することです。Start </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッド内：</font></font><br>
<br>
<pre><code class="cs hljs">navMeshAgent.updateRotation = <span class="hljs-literal">false</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Updateメソッドで：</font></font><br>
<br>
<pre><code class="cs hljs">transform.rotation = Quaternion.LookRotation(navMeshAgent.velocity.normalized);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1行目は、NavMeshAgentにキャラクターの回転を制御してはいけないことを伝えます。 2行目は、キャラクターの動きを指示する方向と同じ方向にキャラクターの回転を設定します。 NavMeshAgentはデフォルトでキャラクターの回転角度を補間しますが、これはあまり見栄えがよくありません（ゾンビの回転方向は移動方向の変更よりも遅くなります）。これらの行を追加すると、この効果がなくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NB回転を設定するには、四元数を使用します。</font><font style="vertical-align: inherit;">3次元グラフィックスでは、オブジェクトの回転を指定する主な方法は、オイラー角、回転行列、および四元数です。</font><font style="vertical-align: inherit;">最初の2つは常に使いやすいとは限らず、「ジンバルロック」などの不快な影響も受けます。</font><font style="vertical-align: inherit;">クォータニオンにはこの欠点がなく、現在はほぼ普遍的に使用されています。</font><font style="vertical-align: inherit;">Unityは、クォータニオン（および行列とオイラー角）を操作するための便利なツールを提供します。これにより、この数学的装置のデバイスの詳細に入る必要がなくなります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目標が見える</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、ゾンビから脱出できるようになりました。しかし、これは十分ではなく、遅かれ早かれ2番目のゾンビが表示され、次に3番目、5番目、10番目のゾンビが表示されます。しかし、群集から逃げることはできません。生き残るには、殺さなければなりません。さらに、プレイヤーはすでに銃を手に持っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレーヤーが射撃できるように、ターゲットを選択する機会を彼に与える必要があります。これを行うには、マウスで制御するカーソルを地面に置きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画面上で、マウスカーソルは2次元空間（モニターの表面）を移動します。同時に、ゲームシーンは3次元です。観察者は彼の目を通してシーンを見る。そこではすべての光線が一点に集まる。これらすべての光線を組み合わせると、可視性のピラミッドが得られます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hl/bg/p5/hlbgp55snbpv2cxacycfmxbd_hw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
観察者の目は、このピラミッドに該当するものだけを見ます。さらに、エンジンはこのピラミッドを特に2つの側面から切り捨てます。最初に、観察者の側から、いわゆる「ニアプレーン」と呼ばれるモニター画面があります（図では黄色に塗られています）。モニターはオブジェクトを画面より近くに物理的に表示できないため、エンジンがオブジェクトを遮断します。第2に、コンピューターのリソースは有限であるため、エンジンは光線を無限に拡張することはできません（たとえば、深度バッファーに特定の範囲の可能な値を設定する必要があります。さらに、深度バッファーの幅が広いほど、精度が低くなります）。ピラミッドは、いわゆる「ファープレーン」。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マウスカーソルが近くの平面に沿って移動するため、シーンの奥深くにあるポイントから光線を解放できます。それが交差する最初のオブジェクトは、観察者の視点からマウスカーソルが指すオブジェクトになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rd/xf/kn/rdxfkn9vevlzr8qz5qtronl05vi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなレイを作成し、シーン内のオブジェクトとの交差を見つけるには、Physicsクラスの標準のレイキャストメソッドを使用できます。しかし、この方法を使用すると、シーン内のすべてのオブジェクト（地球、壁、ゾンビ）との交差が検出されます。ただし、カーソルを地面にのみ移動させたいので、交差の検索は制限する必要があることをUnityに説明する必要があります。指定されたオブジェクトのセット（この場合、地球の平面のみ）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シーンでゲームオブジェクトを選択すると、インスペクターの上部にドロップダウンリスト「レイヤー」が表示されます。デフォルトでは、「デフォルト」の値があります。ドロップダウンリストを開くと、「レイヤーの追加...」アイテムが表示され、レイヤーエディターウィンドウが開きます。エディターで、新しいレイヤーを追加する必要があります（「グラウンド」と呼びましょう）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3w/5g/pc/3w5gpczarjjyhhtombqxbxq68wk.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、シーン内のすべてのグラウンドプレーンを選択し、このドロップダウンリストを使用してグラウンドレイヤーを割り当てることができます。これにより、スクリプトでPhysics.Raycastメソッドに、これらのオブジェクトとのみビームの交差をチェックする必要があることを示すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、カーソルスプライトをアセットからシーンにドラッグします（私はSpagsAssets⇨Textures⇨Demo⇨white_hip⇨white_hip_14を使用しています）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ha/mw/aa/hamwaarhcaodn7q-y-e5qkps5kc.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カーソルがX軸を中心に90度回転して地面に水平になるように追加し、スケールが0.25に設定されてそれほど大きくならないようにし、Y座標を0.01に設定しました。後者は「Zファイティング」と呼ばれる効果がないように重要です。ビデオカードは、浮動小数点計算を使用して、カメラに近いオブジェクトを特定します。カーソルを0（つまり、地表のそれと同じ）に設定した場合、これらの計算のエラーにより、一部のピクセルでは、ビデオカードはカーソルが近くにあると判断し、その他の場合は地球に近いと判断します。さらに、フレームが異なれば、ピクセルのセットも異なります。これにより、カーソルの一部が地面を照らし、カーソルが動くときに「ちらつく」という不快な効果が生じます。 0.01の値は、ビデオカードの計算におけるエラーを相殺するのに十分な大きさですが、それほど大きくはありません。目がカーソルが宙に浮いていることに気付くでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ゲームオブジェクトの名前をCursorに変更し、同じ名前で次の内容のスクリプトを作成します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Cursor</span> : <span class="hljs-title">MonoBehaviour</span><font></font>
{<font></font>
    SpriteRenderer spriteRenderer;<font></font>
    <span class="hljs-keyword">int</span> layerMask;<font></font>
<font></font>
    <span class="hljs-comment">// Start is called before the first frame update</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        spriteRenderer = GetComponent&lt;SpriteRenderer&gt;();<font></font>
        layerMask = LayerMask.GetMask(<span class="hljs-string">"Ground"</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// Update is called once per frame</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);<font></font>
<font></font>
        RaycastHit hit;<font></font>
        <span class="hljs-keyword">if</span> (!Physics.Raycast(ray, <span class="hljs-keyword">out</span> hit, <span class="hljs-number">1000</span>, layerMask))<font></font>
            spriteRenderer.enabled = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">else</span> {<font></font>
            transform.position = <span class="hljs-keyword">new</span> Vector3(hit.point.x, transform.position.y, hit.point.z);<font></font>
            spriteRenderer.enabled = <span class="hljs-literal">true</span>;<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カーソルはスプライト（2次元の描画）であるため、UnityはSpriteRendererコンポーネントを使用してレンダリングします。</font><font style="vertical-align: inherit;">必要に応じてオン/オフできるようにするために、Startメソッドでこのコンポーネントへのリンクを取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、Startメソッドでは、以前に作成した「Ground」レイヤーの名前をビットマスクに変換します。</font><font style="vertical-align: inherit;">Unityは、交差ごとにオブジェクトをフィルタリングするためにビット単位の演算を使用し、LayerMask.GetMaskメソッドは指定されたレイヤーに対応するビットマスクを返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Updateメソッドでは、Camera.mainを使用してシーンのメインカメラにアクセスし、（Input.mousePositionを使用して取得した）2次元のマウス座標を3次元のレイに再計算するように要求します。次に、このビームをPhysics.Raycastメソッドに渡し、シーン内のオブジェクトと交差するかどうかを確認します。 1000の値は最大距離です。数学では、光線は無限ですが、コンピュータの計算リソースとメモリは無限です。したがって、Unityは妥当な最大距離を決定するように求めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
交差がない場合は、SpriteRendererをオフにすると、カーソルイメージが画面から消えます。</font><font style="vertical-align: inherit;">交点が見つかった場合は、カーソルを交点に移動します。</font><font style="vertical-align: inherit;">Y座標は変更しないことに注意してください。これは、レイと地面の交点でYがゼロになり、それをカーソルに割り当てると、Zファイティング効果が得られるため、上記を削除しようとしたことです。</font><font style="vertical-align: inherit;">したがって、交点からX座標とZ座標のみを取得し、Yは同じままです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CursorコンポーネントをCursorゲームオブジェクトに追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、Playerスクリプトを完成させましょう。最初に、カーソルカーソルフィールドを追加します。</font><font style="vertical-align: inherit;">次に、Startメソッドで、次の行を追加します。</font></font><br>
<br>
<pre><code class="cs hljs">cursor = FindObjectOfType&lt;Cursor&gt;();<font></font>
navMeshAgent.updateRotation = <span class="hljs-literal">false</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、プレーヤーが常にカーソルの方を向くように、Updateメソッドで次の行を追加します。</font></font><br>
<br>
<pre><code class="cs hljs">Vector3 forward = cursor.transform.position - transform.position;<font></font>
transform.rotation = Quaternion.LookRotation(<span class="hljs-keyword">new</span> Vector3(forward.x, <span class="hljs-number">0</span>, forward.z));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでも、Y座標は考慮されていません。 </font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生き残るために撃つ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カーソルの方を向いているだけの事実は、ゾンビから私たちを保護するのではなく、プレイヤーのキャラクターを驚きの影響から守るだけです。彼が私たちのゲームの厳しい現実で本当に生き残ることができるように、あなたは彼に撃つ方法を教える必要があります。そしてそれが見えない場合、それはどのようなショットですか？誰でも、立派な射手は常に追跡弾を発射することを知っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Shotゲームオブジェクトを作成し、それに標準のLineRendererコンポーネントを追加します。エディターの「幅」フィールドを使用して、0.04などの小さな幅に設定します。ご覧のように、Unityは明るい紫色でペイントします。これにより、マテリアルのないオブジェクトが強調表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マテリアルは、あらゆる3次元エンジンの重要な要素です。マテリアルの使用は、オブジェクトの外観を説明します。すべてのライティングパラメータ、テクスチャ、シェーダ-これはすべてマテリアルによって記述されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトにマテリアルディレクトリを作成し、その中にマテリアルを作成して、黄色と呼びましょう。シェーダーとして、Unlit / Colorを選択します。この標準シェーダーは照明を考慮していないため、暗闇でも弾丸が表示されます。黄色を選択し</font></font><br>
<br>
<img src="https://habrastorage.org/webt/en/pt/im/enptimmi5wn6-9f5ssbqzh2fxko.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。マテリアルが作成されたので、それをLineRendererに割り当て</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ow/qr/31/owqr314ai0hyyfx-hswunci5lzs.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。ショットスクリプトを作成します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shot</span> : <span class="hljs-title">MonoBehaviour</span><font></font>
{<font></font>
    LineRenderer lineRenderer;<font></font>
    <span class="hljs-keyword">bool</span> visible;<font></font>
<font></font>
    <span class="hljs-comment">// Start is called before the first frame update</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        lineRenderer = GetComponent&lt;LineRenderer&gt;();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// Update is called once per frame</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">if</span> (visible)<font></font>
            visible = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">else</span>
            gameObject.SetActive(<span class="hljs-literal">false</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span>(<span class="hljs-params">Vector3 <span class="hljs-keyword">from</span>, Vector3 to</span>)</span><font></font>
    {<font></font>
        lineRenderer.SetPositions(<span class="hljs-keyword">new</span> Vector3[]{ <span class="hljs-keyword">from</span>, to });<font></font>
        visible = <span class="hljs-literal">true</span>;<font></font>
        gameObject.SetActive(<span class="hljs-literal">true</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このスクリプトは、おそらくご想像のとおり、Shotゲームオブジェクトに追加する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、小さなトリックを使用して、最小限のコードで正確に1フレームのショットを画面に表示しました。まず、UpdateではなくFixedUpdateを使用します。 FixedUpdateメソッドは、実際のフレームレートが不安定な場合でも、指定された頻度（デフォルトでは1秒あたり60フレーム）で呼び出されます。次に、変数visibleを開始し、ショットを画面に表示するときにtrueに設定しました。次のFixedUpdateでfalseにリセットし、次のフレームでのみショットのゲームオブジェクトをオフにします。基本的に、私は1から0までのカウンターとしてブール変数を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
gameObject.SetActiveメソッドは、コンポーネントが配置されているゲームオブジェクト全体をオンまたはオフにします。オフにしたゲームオブジェクトは画面に描画されず、それらのコンポーネントはUpdate、FixedUpdateメソッドなどを呼び出しません。この方法を使用すると、プレーヤーが撮影していないときにショットを非表示にすることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、スクリプトにはpublic Showメソッドがあり、これをPlayerスクリプトで使用して、発砲時に実際に弾丸を表示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、最初にショットが正しい穴から来るように砲身の座標を取得できる必要があります。</font><font style="vertical-align: inherit;">これを行うには、プレーヤーの3DモデルでBip001⇨Bip001骨盤⇨Bip001脊椎⇨Bip001R鎖骨⇨Bip001RUpperArm⇨Bip001R前腕⇨Bip001RHand⇨R_hand_container⇨w_handgunオブジェクトを探し、それにGunBarrel子オブジェクトを追加します。</font><font style="vertical-align: inherit;">砲身のすぐ隣になるように配置し</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kc/qc/ix/kcqcixwjeh_nf2qxqa6c7iriekk.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次に、Playerスクリプトでフィールドを追加します。</font></font><br>
<br>
<pre><code class="cs hljs">Shot shot;
<span class="hljs-keyword">public</span> Transform gunBarrel;</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレーヤースクリプトのStartメソッドで、次を追加します。</font></font><br>
<br>
<pre><code class="cs hljs">shot = FindObjectOfType&lt;Shot&gt;();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、Updateメソッドで：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">if</span> (Input.GetMouseButtonDown(<span class="hljs-number">0</span>)) {
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">from</span> = gunBarrel.position;
    <span class="hljs-keyword">var</span> target = cursor.transform.position;
    <span class="hljs-keyword">var</span> to = <span class="hljs-keyword">new</span> Vector3(target.x, <span class="hljs-keyword">from</span>.y, target.z);<font></font>
    shot.Show(<span class="hljs-keyword">from</span>, to);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご想像のとおり、追加されたgunBarrelパブリックフィールド（moveSpeedなど）はインスペクターで利用できます。作成した実際のゲームオブジェクトを割り当てましょう。ゲーム</font></font><br>
<br>
<img src="https://habrastorage.org/webt/r2/3p/6g/r23p6g9wgzes9qh_fg8l41txjqs.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
を開始したら、ようやくゾンビを撃つことができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gj/ek/sx/gjeksxqnsbieryc_qrv07cyqm44.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここは何かがおかしい！ショットはゾンビを殺すのではなく、単にそれを飛ぶようです！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、ショットコードを見ると、ショットが敵に当たったかどうかは追跡していません。カーソルに線を引くだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは簡単に修正できます。 Playerクラスのマウスクリックを処理するコードで、var to = ...行の後、shot.Show（...）行の前に、次の行を追加します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> direction = (to - <span class="hljs-keyword">from</span>).normalized;<font></font>
<font></font>
RaycastHit hit;<font></font>
<span class="hljs-keyword">if</span> (Physics.Raycast(<span class="hljs-keyword">from</span>, to - <span class="hljs-keyword">from</span>, <span class="hljs-keyword">out</span> hit, <span class="hljs-number">100</span>))<font></font>
    to = <span class="hljs-keyword">new</span> Vector3(hit.point.x, <span class="hljs-keyword">from</span>.y, hit.point.z);
<span class="hljs-keyword">else</span>
    to = <span class="hljs-keyword">from</span> + direction * <span class="hljs-number">100</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、おなじみのPhysics.Raycastを使用して、ビームを銃身の外に出し、それがゲームオブジェクトと交差するかどうかを判断します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、ここでは注意点が1つあります。弾丸はゾンビを飛ぶことになります。事実は、アセットの作成者がレベルのオブジェクト（建物、ボックスなど）にコライダーを追加したことです。そして、キャラクターを持つアセットの作者はしませんでした。この迷惑な誤解を修正しましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コライダーは、物理エンジンがオブジェクト間の衝突を決定するコンポーネントです。</font><font style="vertical-align: inherit;">通常、単純な幾何学的形状がコライダーとして使用されます-立方体、球など。</font><font style="vertical-align: inherit;">この方法では衝突の精度は低くなりますが、そのようなオブジェクト間の交差式は非常に単純で、大きな計算リソースを必要としません。</font><font style="vertical-align: inherit;">もちろん、最大限の精度が必要な場合は、常にパフォーマンスを犠牲にしてMeshColliderを使用できます。</font><font style="vertical-align: inherit;">ただし、高い精度は必要ないため、CapsuleColliderコンポーネントを使用します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wp/t3/qo/wpt3qo9lebty_w7hlawpe11le9u.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、弾丸がゾンビを飛ぶことはありません。</font><font style="vertical-align: inherit;">しかし、ゾンビはまだ不滅です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゾンビ-ゾンビ死！</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、ゾンビアニメーションコントローラーに死のアニメーションを追加しましょう。</font><font style="vertical-align: inherit;">そのためには、AssetPacks⇨ToonyTinyPeople⇨TT_demo⇨animation⇨zombie⇨Z_death_Aアニメーションをドラッグします。</font><font style="vertical-align: inherit;">これをアクティブにするには、トリガータイプで停止した新しいパラメーターを作成します。</font><font style="vertical-align: inherit;">他のパラメーター（ブール、フロートなど）とは異なり、トリガーはその状態を記憶せず、関数呼び出しに似ています。トリガーをアクティブ化しました-遷移が機能し、トリガーがリセットされました。</font><font style="vertical-align: inherit;">また、ゾンビはどの状態でも死ぬ可能性があるため、静止状態で実行中の場合は、Any State状態からの遷移を</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-a/je/6j/-aje6jc9oteg-glqdrtckbjhv1o.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
追加します。以下のフィールドをゾンビスクリプトに追加します。</font></font><br>
<br>
<pre><code class="cs hljs">CapsuleCollider capsuleCollider;<font></font>
Animator animator;<font></font>
MovementAnimator movementAnimator;<font></font>
<span class="hljs-keyword">bool</span> dead;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZombieクラスのStartメソッドに、以下を挿入します。</font></font><br>
<br>
<pre><code class="cs hljs">capsuleCollider = GetComponent&lt;CapsuleCollider&gt;();<font></font>
animator = GetComponentInChildren&lt;Animator&gt;();<font></font>
movementAnimator = GetComponent&lt;MovementAnimator&gt;();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Updateメソッドの最初に、チェックを追加する必要があります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">if</span> (dead)
    <span class="hljs-keyword">return</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に、Kill publicメソッドをZombieクラスに追加します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Kill</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">if</span> (!dead) {<font></font>
        dead = <span class="hljs-literal">true</span>;<font></font>
        Destroy(capsuleCollider);<font></font>
        Destroy(movementAnimator);<font></font>
        Destroy(navMeshAgent);<font></font>
        animator.SetTrigger(<span class="hljs-string">"died"</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいフィールドの割り当ては非常に明白だと思います。 Killメソッドについては、ゾンビの死亡フラグを設定し、ゲームオブジェクトからCapsuleCollider、MovementAnimator、NavMeshAgentコンポーネントを削除します。その後、アニメーションコントローラーからの死亡アニメーションの再生をアクティブにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントを削除する理由そのため、ゾンビが死ぬとすぐに、彼はマップの周りを移動するのをやめ、もはや弾丸の障害にはなりません。良いことに、死のアニメーションが再生された後も、なんとか美しい方法で体を取り除く必要があります。そうしないと、死んだゾンビがリソースを食べ続け、死体が多すぎると、ゲームが著しく遅くなります。最も簡単な方法は、Destroy呼び出し（gameObject、3）をここに追加することです。これにより、Unityはこの呼び出しの3秒後にこのゲームオブジェクトを削除します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これをすべて機能させるには、最後の仕上げが残ります。 PlayerクラスのPhysics.Raycastを呼び出すUpdateメソッドで、交差が見つかった場合のブランチにチェックを追加します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">if</span> (hit.transform != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">var</span> zombie = hit.transform.GetComponent&lt;Zombie&gt;();
    <span class="hljs-keyword">if</span> (zombie != <span class="hljs-literal">null</span>)<font></font>
        zombie.Kill();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Physics.Raycastは、ヒット変数の交差情報を呼び出します。特に、transformフィールドには、光線が交差するゲームオブジェクトのTransformコンポーネントへのリンクがあります。このゲームオブジェクトにゾンビコンポーネントがある場合、それはゾンビであり、それを殺します。初級！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、敵の死が壮観に見えるように、ゾンビに単純なパーティクルシステムを追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーティクルシステムでは、物理法則または数式に従って多数の小さなオブジェクト（通常はスプライト）を制御できます。</font><font style="vertical-align: inherit;">たとえば、それらを離れて飛ばしたり、特定の速度でまっすぐ飛んだりすることができます。</font><font style="vertical-align: inherit;">ゲーム内のパーティクルシステムを利用して、火、煙、火花、雨、雪、車輪の下からの汚れなど、あらゆる種類のエフェクトが作成されます。</font><font style="vertical-align: inherit;">パーティクルシステムを使用して、死亡時にゾンビから血が散るようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゾンビゲームオブジェクトにパーティクルシステムを追加します（オブジェクトを右クリックして、エフェクト⇨パーティクルシステムを選択します）：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のオプションを提案します：</font></font><br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変換：</font></font></u><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位置：Y 0.5</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回転：X -90</font></font></li>
</ul><br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パーティクルシステム</font></font></u><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">期間：0.2</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ループ：false</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライフタイムの開始：0.8</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開始サイズ：0.5</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開始色：緑</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重力修飾子：1</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目を覚まして遊ぶ：false</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">排出：</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間の経過による評価：100</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形状：</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">半径：0.25</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nk/rz/mj/nkrzmjt9wu6gyqt6twhgfkldivo.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゾンビクラスのKillメソッドでアクティブにするため</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">残っています。</font></font><br>
<br>
<pre><code class="cs hljs">GetComponentInChildren&lt;ParticleSystem&gt;().Play();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして今、まったく別の問題です！</font></font><br>
<br>
<img src="https://habrastorage.org/webt/av/sl/mf/avslmfkniyguq6m4hxma0j4sqek.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゾンビが群れを攻撃する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、単一のゾンビとの戦いは退屈です。</font><font style="vertical-align: inherit;">あなたは彼を殺しました、そしてそれだけです。</font><font style="vertical-align: inherit;">ドラマはどこですか？</font><font style="vertical-align: inherit;">若くして死ぬことへの恐れはどこにありますか？</font><font style="vertical-align: inherit;">黙示録と絶望の真の雰囲気を作り出すには、たくさんのゾンビがいるに違いありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸い、これは非常に簡単です。</font><font style="vertical-align: inherit;">ご想像のとおり、別のスクリプトが必要です。</font><font style="vertical-align: inherit;">それをEnemySpawnerと呼び、次の内容を入力します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EnemySpawner</span> : <span class="hljs-title">MonoBehaviour</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> Period;
    <span class="hljs-keyword">public</span> GameObject Enemy;
    <span class="hljs-keyword">float</span> TimeUntilNextSpawn;<font></font>
<font></font>
    <span class="hljs-comment">// Start is called before the first frame update</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        TimeUntilNextSpawn = Random.Range(<span class="hljs-number">0</span>, Period);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// Update is called once per frame</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        TimeUntilNextSpawn -= Time.deltaTime;<font></font>
        <span class="hljs-keyword">if</span> (TimeUntilNextSpawn &lt;= <span class="hljs-number">0.0f</span>) {<font></font>
            TimeUntilNextSpawn = Period;<font></font>
            Instantiate(Enemy, transform.position, transform.rotation);<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
期間パブリックフィールドを使用して、ゲームデザイナーは新しい敵を作成する必要がある頻度をインスペクターで設定できます。 Enemyフィールドでは、作成する敵を指定します（これまでのところ、敵は1人だけですが、将来はさらに追加することができます）。さて、それではすべてが簡単です。TimeUntilNextSpawnを使用して、敵が次に出現するまでの残り時間をカウントし、時間が来たらすぐに、標準のInstantiateメソッドを使用して新しいゾンビをシーンに追加します。ああ、はい、Startメソッドで、TimeUntilNextSpawnフィールドにランダムな値を割り当てます。これにより、レベルに同じ遅延を持つ複数のスポーナーがいる場合、ゾンビが同時に追加されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
質問が1つ残っています-敵フィールドで敵にどのように尋ねるか？これを行うには、「プレハブ」などのUnityツールを使用します。実際、プレハブは別のファイルに保存されたシーンの一部です。次に、このファイルを他のシーン（または同じシーン）に貼り付けることができます。毎回ピースからファイルを収集する必要はありません。たとえば、壁、床、天井、窓、ドアなどのオブジェクトから美しい家を集め、プレハブとして保存しました。手首を振るだけで、この家を他のカードに挿入できます。同時に、プレハブファイルを編集する（たとえば、家にバックドアを追加する）と、オブジェクトはすべてのシーンで変化します。時にはそれは非常に便利です。また、プレハブをInstantiateのテンプレートとして使用することもできます。今はこの機会を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレハブを作成するには、ゲームオブジェクトを階層ウィンドウからプロジェクトウィンドウにドラッグするだけで、あとはUnityが行います。</font><font style="vertical-align: inherit;">ゾンビからプレハブを作成して、敵のスポーナーをシーン</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4i/ka/kx/4ikakx3ollmpndbgcqco8341e8y.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
に追加して</font><font style="vertical-align: inherit;">みましょう。</font><font style="vertical-align: inherit;">変更のために、プロジェクトに3つのスポーナーを追加しました（つまり、4つのスポーナーがあります）。</font><font style="vertical-align: inherit;">そして、何が起こったのか：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6h/0p/_f/6h0p_fo52j6zqydyml6z9aqlcu0.gif"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ！</font><font style="vertical-align: inherit;">それはすでにゾンビの黙示録のように見えます！</font></font></b><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、これは完全なゲームからはほど遠いです。</font><font style="vertical-align: inherit;">ユーザーインターフェイスの作成、サウンド、プレイヤーの死、生死など、多くの問題は考慮していませんでした。これらはすべて、この記事の範囲外です。</font><font style="vertical-align: inherit;">しかし、この記事は、このツールに慣れていない人にとっては、Unityの価値ある紹介になると思います。</font><font style="vertical-align: inherit;">それとも経験豊富な誰かがそこからいくつかのトリックを学ぶことができるでしょうか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、友人、私の記事を楽しんでいただければ幸いです。</font><font style="vertical-align: inherit;">コメント欄に質問を書いて、回答してみます。</font><font style="vertical-align: inherit;">プロジェクトのソースコードはgithub：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">//github.com/zapolnov/otus_zombiesから</font></a><font style="vertical-align: inherit;">ダウンロードでき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Unity 2019.3.0f3以降が必要です</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">公式サイト</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://store.unity.com/download</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からSMSなしで完全に無料でダウンロードでき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事で使用されているアセットへのリンク：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">https://assetstore.unity.com/packages/3d/environments/industrial/rpg-fps-game-assets-for-pc-mobile-industrial-set-v2-0-86679</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">https://assetstore.unity.com/packages/3d/characters/toony-tiny-people-demo-113188</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">https://assetstore.unity.com/packages/2d/gui/icons/crosshairs-plus-139902</a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja485200/index.html">混乱の始まり：iOSアプリケーションの起動速度に関する検死</a></li>
<li><a href="../ja485202/index.html">抑制システム</a></li>
<li><a href="../ja485204/index.html">トップに戻る：Amazonの資本金がまもなく1兆ドルを超える理由</a></li>
<li><a href="../ja485206/index.html">Typescriptはどのように私をがっかりさせましたか？</a></li>
<li><a href="../ja485208/index.html">フォールトトレラントITインフラストラクチャの作成。パート2. oVirt 4.3クラスターのインストールと構成</a></li>
<li><a href="../ja485214/index.html">CLRium＃7：実用的。ワークショップ、確認付きの宿題、メンタリング</a></li>
<li><a href="../ja485216/index.html">Apple Lightningビデオアダプタのcheckm8</a></li>
<li><a href="../ja485218/index.html">Cでの定数とGitフックの予約＃</a></li>
<li><a href="../ja485220/index.html">Webアプリケーションファイアウォールの進化：ファイアウォールから機械学習のクラウドベースのセキュリティへ</a></li>
<li><a href="../ja485222/index.html">中国のオピニオンリーダーと連携するには 5つの実用的なヒント</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>