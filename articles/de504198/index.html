<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õ¥Ô∏è ü§≠ ü¶â SwiftUI in den Regalen: Animation. Teil 1 üêë üë©üèΩ‚Äçüîß üëΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="K√ºrzlich bin ich auf einen neuen Artikel gesto√üen, in dem die Jungs versucht haben, mit SwiftUI ein interessantes Konzept zu reproduzieren. Folgendes ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SwiftUI in den Regalen: Animation. Teil 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504198/"><img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
K√ºrzlich bin ich auf einen neuen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gesto√üen, in dem die Jungs versucht haben, mit SwiftUI ein interessantes Konzept zu reproduzieren. Folgendes haben sie getan: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7a7/cbf/7a0/7a7cbf7a05561123ceff4be47fff5ed6.gif" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe ihren Code mit Interesse studiert, aber einige Frustrationen erfahren. Nein, nicht in dem Sinne, dass sie etwas falsch gemacht haben, √ºberhaupt nicht. Es ist nur so, dass ich nichts Neues aus ihrem Code gelernt habe. Bei ihrer Implementierung geht es mehr um Kombinieren als um Animation. Und ich habe beschlossen </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, meinen Lunopark</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu </font><s><font style="vertical-align: inherit;">erstellen</font></s><font style="vertical-align: inherit;"> , um meinen Artikel √ºber Animation in </font><s><font style="vertical-align: inherit;">SwiftUI</font></s><font style="vertical-align: inherit;"> zu schreiben. Dabei wurde ungef√§hr das gleiche Konzept implementiert, aber 100% der Funktionen der integrierten Animation genutzt, auch wenn diese nicht sehr effektiv ist. Lernen - bis zum Ende. Experimentieren - also mit einem Augenzwinkern :) Folgendes </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
habe ich:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr eine vollst√§ndige Offenlegung des Themas musste ich jedoch ausf√ºhrlich √ºber die Grundlagen sprechen. Der Text erwies sich als umfangreich, und deshalb habe ich ihn in zwei Artikel aufgeteilt. Hier ist der erste Teil davon - eher ein Tutorial zur Animation im Allgemeinen, das nicht direkt mit der Regenbogenanimation zusammenh√§ngt, auf das ich im n√§chsten Artikel ausf√ºhrlich eingehen werde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel werde ich auf die Grundlagen eingehen, ohne die Sie in komplexeren Beispielen leicht verwirrt werden k√∂nnen. Vieles, wor√ºber ich in der einen oder anderen Form sprechen werde, wurde bereits in englischsprachigen Artikeln wie dieser Reihe ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4) beschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Andererseits konzentrierte ich mich weniger auf die Aufz√§hlung der Arbeitsweisen als vielmehr auf die Beschreibung, wie genau dies funktioniert. </font><font style="vertical-align: inherit;">Und wie immer habe ich viel experimentiert, also beeile ich mich, die interessantesten Ergebnisse zu teilen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warnung: Unter der Katze gibt es viele Bilder und Gif-Animationen.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLDR</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Projekt ist auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verf√ºgbar </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie k√∂nnen das aktuelle Ergebnis mit Regenbogenanimation in TransitionRainbowView () sehen, aber ich w√ºrde mich nicht an Ihre Stelle beeilen, sondern auf den n√§chsten Artikel warten. </font><font style="vertical-align: inherit;">Au√üerdem k√§mme ich bei der Vorbereitung den Code ein wenig. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel werden nur die Grundlagen erl√§utert und nur der Inhalt des Ordners "Basen" beeinflusst.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einf√ºhrung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich gebe zu, ich wollte diesen Artikel jetzt nicht schreiben. Ich hatte einen Plan, nach dem ein Artikel √ºber Animation der dritte oder sogar der vierte in Folge sein sollte. Ich konnte jedoch nicht widerstehen, ich wollte wirklich einen alternativen Standpunkt bieten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich m√∂chte sofort reservieren. Ich glaube nicht, dass im genannten Artikel Fehler gemacht wurden oder dass der darin verwendete Ansatz falsch ist. Ganz und gar nicht. Es erstellt ein Objektmodell des Prozesses (Animation), das als Reaktion auf das empfangene Signal etwas zu tun beginnt. F√ºr mich zeigt dieser Artikel jedoch h√∂chstwahrscheinlich die Arbeit mit dem Combine-Framework. Ja, dieses Framework ist ein wichtiger Bestandteil von SwiftUI, aber es geht mehr um reaktions√§hnlichen Stil im Allgemeinen als um Animation.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meine Option ist sicherlich nicht eleganter, schneller und einfacher zu warten. Es zeigt jedoch viel besser, was sich unter der Haube von SwiftUI befindet, und tats√§chlich war dies der Zweck des Artikels - es zuerst herauszufinden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie ich in einem </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">vorherigen Artikel</font></a><font style="vertical-align: inherit;"> sagte</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit SwiftUI begann ich sofort mit SwiftUI meinen Einstieg in die Welt der mobilen Entwicklung und ignorierte UIKit. Das hat nat√ºrlich einen Preis, aber es gibt Vorteile. Ich versuche nicht, gem√§√ü der alten Charta in einem neuen Kloster zu leben. Ehrlich gesagt kenne ich noch keine Chartas, daher habe ich keine Ablehnung der neuen. Aus diesem Grund kann dieser Artikel meines Erachtens nicht nur f√ºr Anf√§nger wie mich von Wert sein, sondern auch f√ºr diejenigen, die SwiftUI studieren und bereits Hintergrundinformationen in Form von UIKit-Entwicklungen haben. Es scheint mir, dass vielen Menschen ein frisches Aussehen fehlt. Tun Sie nicht dasselbe und versuchen Sie, ein neues Werkzeug in die alten Zeichnungen einzubauen, sondern √§ndern Sie Ihre Vision entsprechend den neuen M√∂glichkeiten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir 1c-Nicks haben dies mit ‚Äûkontrollierten Formen‚Äú durchgemacht. Dies ist eine Art SwiftUI in der Welt der Einsen, die vor mehr als 10 Jahren passiert ist. Tats√§chlich ist die Analogie ziemlich genau, da verwaltete Formulare nur eine neue M√∂glichkeit sind, eine Schnittstelle zu zeichnen. Er hat jedoch die Client-Server-Interaktion der gesamten Anwendung und insbesondere das Bild der Welt in den K√∂pfen der Entwickler grundlegend ver√§ndert. Das war nicht einfach, ich selbst wollte es ungef√§hr 5 Jahre lang nicht studieren, weil Ich dachte, dass viele der M√∂glichkeiten, die dort abgeschnitten wurden, einfach f√ºr mich notwendig waren. Wie die Praxis gezeigt hat, ist die Codierung auf verwalteten Formularen jedoch nicht nur m√∂glich, sondern nur erforderlich.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sprechen wir jedoch nicht mehr dar√ºber. </font><font style="vertical-align: inherit;">Ich habe einen detaillierten, unabh√§ngigen Leitfaden erhalten, der keine Referenzen oder andere Links zu dem genannten Artikel oder der 1. Vergangenheit enth√§lt. </font><font style="vertical-align: inherit;">Schritt f√ºr Schritt werden wir uns mit den Details, Merkmalen, Prinzipien und Einschr√§nkungen befassen. </font><font style="vertical-align: inherit;">Gehen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animierende Form</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Animation im Allgemeinen funktioniert</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hauptidee der Animation ist also die Umwandlung einer bestimmten, diskreten √Ñnderung in einen kontinuierlichen Prozess. Zum Beispiel war der Radius des Kreises 100 Einheiten, wurde 50 Einheiten. Ohne Animation erfolgt die √Ñnderung sofort, mit Animation - reibungslos. Wie es funktioniert? Sehr einfach. F√ºr reibungslose √Ñnderungen m√ºssen wir mehrere Werte innerhalb des Segments "Es war ... Es ist geworden" interpolieren. Im Fall des Radius m√ºssen wir mehrere Zwischenkreise mit einem Radius von 98 Einheiten, 95 Einheiten, 90 Einheiten ... 53 Einheiten und schlie√ülich 50 Einheiten zeichnen. SwiftUI kann dies einfach und nat√ºrlich tun. Schlie√üen Sie einfach den Code, der diese √Ñnderung vornimmt, in withAnimation {...} ein. Es scheint magisch ... Bis Sie etwas etwas komplizierteres als "Hallo Welt" implementieren m√∂chten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kommen wir zu den Beispielen. Das einfachste und verst√§ndlichste Objekt f√ºr die Animation ist die Animation von Formularen. Shape (ich werde die Struktur weiterhin als Formformprotokoll bezeichnen) in SwiftUI ist eine Struktur mit Parametern, die sich in diese Grenzen einf√ºgen k√∂nnen. Jene. Es ist eine Struktur mit dem Funktionsk√∂rper (in rect: CGRect) -&gt; Path. Alles, was die Laufzeit zum Zeichnen dieses Formulars ben√∂tigt, ist das Anfordern seines Umrisses (das Ergebnis der Funktion ist ein Objekt vom Typ Pfad, tats√§chlich ist es eine Bezier-Kurve) f√ºr die erforderliche Gr√∂√üe (angegeben als Funktionsparameter, ein Rechteck vom Typ CGRect).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Form ist eine gespeicherte Struktur. Durch die Initialisierung speichern Sie in den Parametern alles, was Sie zum Zeichnen des Umrisses ben√∂tigen. Die Gr√∂√üe der Auswahl f√ºr dieses Formular kann sich √§ndern. Dann m√ºssen Sie lediglich einen neuen Pfadwert f√ºr den neuen CGRect-Frame und voila abrufen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir bereits mit dem Codieren:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">Circle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.green)<font></font>
            .frame(height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habra"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.gray)<font></font>
                )<font></font>
<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)<font></font>
            .frame(width: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>, height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habr"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.green)<font></font>
                )<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleTestView</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">50</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">CircleView</span>(radius: radius)<font></font>
               .frame(height: <span class="hljs-number">200</span>)
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$radius, <span class="hljs-keyword">in</span>: <span class="hljs-number">42</span>...<span class="hljs-number">100</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.radius = <span class="hljs-number">50</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set default radius"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/pf/3j/eo/pf3jeo651jcwbhazddldv-rgxhy.gif"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben also einen Kreis (Circle ()), dessen Radius wir mit dem Schieberegler √§ndern k√∂nnen. Dies geschieht reibungslos, wie Der Schieberegler gibt uns alle Zwischenwerte. Wenn Sie jedoch auf die Schaltfl√§che ‚ÄûStandardradius festlegen‚Äú klicken, erfolgt die √Ñnderung jedoch nicht sofort, sondern gem√§√ü der Anweisung withAnimation (.linear (Dauer: 1)). Linear, ohne Beschleunigung, 1 Sekunde lang gedehnt. Klasse! Wir haben die Animation gemeistert! Wir sind uns nicht einig :) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber was ist, wenn wir unsere eigene Form implementieren und ihre √Ñnderungen animieren wollen? Ist es schwer das zu tun? Lass uns nachsehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe eine Kopie von Circle wie folgt erstellt:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span></span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{
        <span class="hljs-keyword">let</span> radius = <span class="hljs-built_in">min</span>(rect.width, rect.height) / <span class="hljs-number">2</span>
        <span class="hljs-keyword">let</span> center = <span class="hljs-type">CGPoint</span>(x: rect.width / <span class="hljs-number">2</span>, y: rect.height / <span class="hljs-number">2</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-type">Path</span>(){path <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">if</span> rect.width &gt; rect.height{<font></font>
                path.move(to: <span class="hljs-type">CGPoint</span>(x: center.x, y: <span class="hljs-number">0</span>))
                <span class="hljs-keyword">let</span> startAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>)<font></font>
                path.addArc(center: center, radius: radius, startAngle: startAngle, endAngle:  startAngle + <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>), clockwise: <span class="hljs-literal">false</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                path.move(to: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: center.y))
                <span class="hljs-keyword">let</span> startAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)<font></font>
                path.addArc(center: center, radius: radius, startAngle: startAngle, endAngle:  startAngle + <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>), clockwise: <span class="hljs-literal">false</span>)<font></font>
            }<font></font>
            path.closeSubpath()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Radius des Kreises wird als halb so klein wie die Breite und H√∂he des Randes des uns zugewiesenen Bildschirmbereichs berechnet. </font><font style="vertical-align: inherit;">Wenn die Breite gr√∂√üer als die H√∂he ist, beginnen wir in der Mitte des oberen Randes (Anmerkung 1), beschreiben den vollen Kreis im Uhrzeigersinn (Anmerkung 2) und schlie√üen hier unseren Umriss. </font><font style="vertical-align: inherit;">Wenn die H√∂he gr√∂√üer als die Breite ist, beginnen wir in der Mitte des rechten Randes, beschreiben auch den vollen Kreis im Uhrzeigersinn und schlie√üen die Kontur.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anmerkung 1</font></font></b>
                        <div class="spoiler_text">Apple     (  )  .  ,      (0, 0),         (x, y),  x ‚Äî  ,  y ‚Äî  . ..        y.   y ‚Äî   .  ,        .  90    , 180  ‚Äî , 270  ‚Äî .</div>
                    </div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anmerkung 2</font></font></b>
                        <div class="spoiler_text">   1   ,   ‚Äú ‚Äù  ‚Äú ‚Äù         .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"></a>  Core Graphics (SwiftUI      ):<br>
<blockquote>In a flipped coordinate system (the default for UIView drawing methods in iOS), specifying a clockwise arc results in a counterclockwise arc after the transformation is applied.</blockquote></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns √ºberpr√ºfen, wie unser neuer Kreis auf √Ñnderungen im withAnimation-Block reagiert:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)<font></font>
            .frame(width: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>, height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habr"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.green)<font></font>
                )<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleTestView</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">50</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
                <span class="hljs-type">HStack</span>{
                <span class="hljs-type">CircleView</span>(radius: radius)<font></font>
                    .frame(height: <span class="hljs-number">200</span>)
                <span class="hljs-type">CustomCircleView</span>(radius: radius)<font></font>
                    .frame(height: <span class="hljs-number">200</span>)<font></font>
            }<font></font>
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$radius, <span class="hljs-keyword">in</span>: <span class="hljs-number">42</span>...<span class="hljs-number">100</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.radius = <span class="hljs-number">50</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set default radius"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/ba/qp/5obaqpgty5ckwvic5uxzscqtix4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beeindruckend! </font><font style="vertical-align: inherit;">Wir haben gelernt, wie wir unsere eigenen Freiformbilder machen und sie animieren k√∂nnen! </font><font style="vertical-align: inherit;">Es ist so? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nicht wirklich. </font><font style="vertical-align: inherit;">Alle Arbeiten hier werden vom Modifikator .frame ausgef√ºhrt (Breite: self.radius * 2, H√∂he: self.radius * 2). </font><font style="vertical-align: inherit;">Innerhalb des withAnimation-Blocks {...} √§ndern wir uns</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zustand</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Variable sendet sie ein Signal, um CustomCircleView () mit einem neuen Radiuswert neu zu initialisieren. Dieser neue Wert f√§llt in den Modifikator .frame (), und dieser Modifikator kann bereits Parameter√§nderungen animieren. Unser CustomCircle () -Formular reagiert darauf mit einer Animation, da es nur von der Gr√∂√üe des daf√ºr ausgew√§hlten Bereichs abh√§ngt. Das √Ñndern des Bereichs erfolgt mit der Animation (d. H. Allm√§hliches Interpolieren der Zwischenwerte zwischen den Animationen), daher wird unser Kreis mit derselben Animation gezeichnet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns unsere Form ein wenig vereinfachen (oder noch komplizieren?). Wir werden den Radius nicht basierend auf der Gr√∂√üe der verf√ºgbaren Fl√§che berechnen, sondern den Radius in der fertigen Form √ºbertragen, d. H. Machen Sie es zu einem gespeicherten Strukturparameter.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{
        <span class="hljs-comment">//let radius = min(rect.width, rect.height) / 2</span><font></font>
...<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>(radius: radius)<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)
            <span class="hljs-comment">//.frame(height: self.radius * 2)</span><font></font>
...<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/g9/ju/pp/g9juppbsuti7iazguvffuy02fiu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, Magie ist unwiederbringlich verloren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben den Modifikator frame () aus unserem CustomCircleView () ausgeschlossen und die Verantwortung f√ºr die Gr√∂√üe des Kreises auf die Form selbst verlagert. Die Animation ist verschwunden. </font><font style="vertical-align: inherit;">Es spielt jedoch keine Rolle, eine Form zu lehren, um √Ñnderungen in ihren Parametern zu animieren, ist nicht allzu schwierig. </font><font style="vertical-align: inherit;">Dazu m√ºssen Sie die Anforderungen des Animatable-Protokolls implementieren:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span>, <span class="hljs-title">Animatable</span></span>{
    <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span>{
         <span class="hljs-keyword">get</span>{<font></font>
             radius<font></font>
         }<font></font>
         <span class="hljs-keyword">set</span>{
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"new radius is \(newValue)"</span>)<font></font>
            radius = newValue<font></font>
         }<font></font>
     }<font></font>
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{<font></font>
	...<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/f1/1-/xs/f11-xshpugfdigdwhnle4nupbek.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voila! </font><font style="vertical-align: inherit;">Die Magie ist wieder da! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt k√∂nnen wir sicher sagen, dass unser Formular wirklich animiert ist - es kann √Ñnderungen in seinen Parametern mit Animation widerspiegeln. </font><font style="vertical-align: inherit;">Wir haben dem System ein Fenster gegeben, in dem es die f√ºr die Animation ben√∂tigten interpolierten Werte √ºberf√ºllen kann. </font><font style="vertical-align: inherit;">Wenn es ein solches Fenster gibt, werden die √Ñnderungen animiert. </font><font style="vertical-align: inherit;">Wenn dies nicht der Fall ist, finden die √Ñnderungen ohne Animation statt, d.h. </font><font style="vertical-align: inherit;">sofort. </font><font style="vertical-align: inherit;">Nichts kompliziertes, oder?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AnimatableModifier</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So animieren Sie √Ñnderungen in einer Ansicht</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber gehen wir direkt zu Ansicht. </font><font style="vertical-align: inherit;">Angenommen, wir m√∂chten die Position eines Elements in einem Container animieren. </font><font style="vertical-align: inherit;">In unserem Fall handelt es sich um ein einfaches Rechteck mit gr√ºner Farbe und einer Breite von 10 Einheiten. </font><font style="vertical-align: inherit;">Wir werden seine horizontale Position animieren.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SimpleView</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">ZStack</span>{
                <span class="hljs-type">Rectangle</span>()<font></font>
                    .fill(<span class="hljs-type">Color</span>.gray)
                <span class="hljs-type">BorderView</span>(position: position)<font></font>
            }<font></font>
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$position, <span class="hljs-keyword">in</span>: <span class="hljs-number">0</span>...<span class="hljs-number">1</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.position = <span class="hljs-number">0</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set to 0"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderView</span>: <span class="hljs-title">View</span>,  <span class="hljs-title">Animatable</span></span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Reding position: \(position)"</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.position<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>.position = newValue
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"setting position: \(position)"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">let</span> borderWidth: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">init</span>(position: <span class="hljs-type">CGFloat</span>, borderWidth: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">10</span>){
        <span class="hljs-keyword">self</span>.position = position
        <span class="hljs-keyword">self</span>.borderWidth = borderWidth
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"BorderView init"</span>)<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span>
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-keyword">self</span>.borderWidth)<font></font>
                .offset(x: <span class="hljs-keyword">self</span>.getXOffset(inSize: geometry.size), y: <span class="hljs-number">0</span>)
                <span class="hljs-comment">// .borderIn(position: position)</span><font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getXOffset</span><span class="hljs-params">(inSize: CGSize)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"calculating position: \(position)"</span>)
        <span class="hljs-keyword">return</span> -inSize.width / <span class="hljs-number">2</span> + inSize.width * position<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/7l/b-/pr/7lb-pry2ta71tvntbemngt8duts.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Klasse! </font><font style="vertical-align: inherit;">Funktioniert! </font><font style="vertical-align: inherit;">Jetzt wissen wir alles √ºber Animation! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nicht wirklich. </font><font style="vertical-align: inherit;">Wenn Sie sich die Konsole ansehen, sehen wir Folgendes:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BorderView Init- </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berechnungsposition: 0.4595176577568054 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BorderView Init- </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berechnungsposition: 0.468130886554718 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BorderView Init- </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berechnungsposition: 0.0</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens bewirkt jede √Ñnderung des Positionswerts mithilfe des Schiebereglers, dass BorderView mit dem neuen Wert neu initialisiert wird. Aus diesem Grund sehen wir eine sanfte Bewegung der gr√ºnen Linie nach dem Schieberegler. Der Schieberegler meldet einfach sehr oft eine √Ñnderung der Variablen und sieht aus wie eine Animation, ist es aber nicht. Die Verwendung des Schiebereglers ist sehr praktisch, wenn Sie Animationen debuggen. Sie k√∂nnen es verwenden, um einige √úbergangszust√§nde zu verfolgen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens sehen wir, dass die Berechnungsposition einfach gleich 0 wurde und keine Zwischenprotokolle, wie dies bei der korrekten Animation des Kreises der Fall war. Warum?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Sache ist, wie im vorherigen Beispiel, im Modifikator. </font><font style="vertical-align: inherit;">Dieses Mal erh√§lt der Modifikator .offset () den neuen Einr√ºckungswert und animiert die √Ñnderung selbst. </font><font style="vertical-align: inherit;">Jene. </font><font style="vertical-align: inherit;">Tats√§chlich ist es nicht die √Ñnderung des Positionsparameters, die animiert werden soll, sondern die horizontale √Ñnderung des Einzugs im davon abgeleiteten Modifikator .offset (). </font><font style="vertical-align: inherit;">In diesem Fall ist dies ein harmloser Ersatz, das Ergebnis ist das gleiche. </font><font style="vertical-align: inherit;">Aber da sie gekommen sind, wollen wir tiefer graben. </font><font style="vertical-align: inherit;">Lassen Sie uns unseren eigenen Modifikator erstellen, der die Position (von 0 bis 1) am Eingang erh√§lt, die Gr√∂√üe des verf√ºgbaren Bereichs empf√§ngt und den Einzug berechnet.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderPosition</span>: <span class="hljs-title">ViewModifier</span></span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span><font></font>
            content<font></font>
            .offset(x: <span class="hljs-keyword">self</span>.getXOffset(inSize: geometry.size), y: <span class="hljs-number">0</span>)<font></font>
            .animation(<span class="hljs-literal">nil</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getXOffset</span><span class="hljs-params">(inSize: CGSize)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-keyword">let</span> offset = -inSize.width / <span class="hljs-number">2</span> + inSize.width * position
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"at position  \(position) offset is \(offset)"</span>)
        <span class="hljs-keyword">return</span> offset<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">borderIn</span><span class="hljs-params">(position: CGFloat)</span></span> -&gt; some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">BorderPosition</span>(position: position))<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der urspr√ºnglichen BorderView wird der GeometryReader nicht mehr ben√∂tigt, ebenso wie die Funktion zum Berechnen des Einzugs:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderView</span>: <span class="hljs-title">View</span>,  <span class="hljs-title">Animatable</span></span>{<font></font>
    ...<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-keyword">self</span>.borderWidth)<font></font>
                .borderIn(position: position)<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hd/3i/r0/hd3ir0e-_jji7qwiasacdwpnpx4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ja, wir verwenden immer noch den Modifikator .offset () in unserem Modifikator, aber danach haben wir den Modifikator .animation (nil) hinzugef√ºgt, der unsere eigene Offset-Animation blockiert. </font><font style="vertical-align: inherit;">Ich verstehe, dass Sie zu diesem Zeitpunkt entscheiden k√∂nnen, dass es ausreicht, dieses Schloss zu entfernen, aber dann werden wir der Wahrheit nicht auf den Grund gehen. </font><font style="vertical-align: inherit;">Und die Wahrheit ist, dass unser Trick mit animatableData f√ºr BorderView nicht funktioniert. </font><font style="vertical-align: inherit;">Wenn Sie sich die Dokumentation zum </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animatable-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Protokoll </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ansehen</font></a><font style="vertical-align: inherit;"> , werden Sie feststellen, dass die Implementierung dieses Protokolls nur f√ºr AnimatableModifier, GeometryEffect und Shape unterst√ºtzt wird. </font><font style="vertical-align: inherit;">Ansicht ist nicht unter ihnen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der richtige Ansatz besteht darin, √Ñnderungen zu animieren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Ansatz selbst war falsch, als wir View aufforderten, einige √Ñnderungen zu animieren. </font><font style="vertical-align: inherit;">F√ºr die Ansicht k√∂nnen Sie nicht denselben Ansatz wie f√ºr Formulare verwenden. </font><font style="vertical-align: inherit;">Stattdessen muss die Animation in jeden Modifikator eingebettet werden. </font><font style="vertical-align: inherit;">Die meisten integrierten Modifikatoren unterst√ºtzen bereits sofort einsatzbereite Animationen. </font><font style="vertical-align: inherit;">Wenn Sie eine Animation f√ºr Ihre eigenen Modifikatoren w√ºnschen, k√∂nnen Sie das AnimatableModifier-Protokoll anstelle von ViewModifier verwenden. </font><font style="vertical-align: inherit;">Und dort k√∂nnen Sie das Gleiche wie beim Animieren von Form√§nderungen implementieren, wie wir es oben getan haben.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderPosition</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">let</span> startDate: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"reading position: \(position) at time \(Date().timeIntervalSince(startDate))"</span>)
            <span class="hljs-keyword">return</span> position<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {<font></font>
            position = newValue<font></font>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"setting position: \(position) at time \(Date().timeIntervalSince(startDate))"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
...<font></font>
    }<font></font>
    ...<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/p2/l3/ys/p2l3yslis_hirenud-lpkt8xaoa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt ist alles richtig. </font><font style="vertical-align: inherit;">Nachrichten in der Konsole helfen zu verstehen, dass unsere Animation wirklich funktioniert, und .animation (nil) im Modifikator st√∂rt sie √ºberhaupt nicht. </font><font style="vertical-align: inherit;">Aber lassen Sie uns trotzdem genau herausfinden, wie es funktioniert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zun√§chst m√ºssen Sie verstehen, was ein Modifikator ist.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier haben wir einen Blick. Wie ich im vorherigen Teil sagte, ist dies eine Struktur mit gespeicherten Parametern und Montageanweisungen. Diese Anweisung enth√§lt im Gro√üen und Ganzen keine Abfolge von Aktionen. Dies ist der √ºbliche Code, den wir in einem nicht deklarativen Stil schreiben, sondern eine einfache Liste. Es listet die andere Ansicht, die auf sie angewendeten Modifikatoren und die Container auf, in denen sie enthalten sind. Wir sind noch nicht an Containern interessiert, aber lassen Sie uns mehr √ºber Modifikatoren sprechen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Modifikator ist wiederum eine Struktur mit gespeicherten Parametern und Anweisungen zur Ansichtsverarbeitung. </font><font style="vertical-align: inherit;">Dies ist eigentlich die gleiche Anweisung wie in der Ansicht - wir k√∂nnen andere Modifikatoren, Container (zum Beispiel habe ich den GeometryReader etwas h√∂her verwendet) und sogar andere Ansichten verwenden. </font><font style="vertical-align: inherit;">Wir haben jedoch nur eingehende Inhalte und m√ºssen diese mithilfe dieser Anweisung irgendwie √§ndern. </font><font style="vertical-align: inherit;">Modifikatorparameter sind Teil der Anweisung. </font><font style="vertical-align: inherit;">Am interessantesten ist jedoch, dass sie gespeichert werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einem fr√ºheren Artikel habe ich gesagt, dass die Anweisung selbst nicht gespeichert ist und jedes Mal ausgel√∂st wird, nachdem die Ansicht aktualisiert wurde. </font><font style="vertical-align: inherit;">Alles ist so, aber es gibt eine Nuance. </font><font style="vertical-align: inherit;">Als Ergebnis der Arbeit dieser Anweisung erhalten wir, wie ich bereits sagte, kein Bild - es war eine Vereinfachung. </font><font style="vertical-align: inherit;">Modifikatoren verschwinden nach der Ausf√ºhrung dieser Anweisung nicht. </font><font style="vertical-align: inherit;">Sie bleiben so, solange die √ºbergeordnete Ansicht vorhanden ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige primitive Analogien</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie w√ºrden wir eine Tabelle deklarativ beschreiben? </font><font style="vertical-align: inherit;">Nun, wir w√ºrden 4 Beine und eine Arbeitsplatte auflisten. </font><font style="vertical-align: inherit;">Sie w√ºrden sie zu einer Art Beh√§lter kombinieren und mit Hilfe einiger Modifikatoren vorschreiben, wie sie aneinander befestigt werden. </font><font style="vertical-align: inherit;">Zum Beispiel w√ºrde jedes Bein die Ausrichtung in Bezug auf die Arbeitsplatte und die Position angeben - welches Bein an welcher Ecke befestigt ist. </font><font style="vertical-align: inherit;">Ja, wir k√∂nnen die Anweisungen nach dem Zusammenbau wegwerfen, aber die N√§gel bleiben im Tisch. </font><font style="vertical-align: inherit;">So sind die Modifikatoren. </font><font style="vertical-align: inherit;">Am Ausgang der K√∂rperfunktion haben wir keinen Tisch. </font><font style="vertical-align: inherit;">Mit body erstellen wir Tabellenelemente (Ansicht) und Verbindungselemente (Modifikatoren) und legen alles in Schubladen an. </font><font style="vertical-align: inherit;">Der Tisch selbst wird von einem Roboter zusammengebaut. </font><font style="vertical-align: inherit;">Welche Befestigungselemente Sie in eine Schachtel an jedem Bein stecken, erhalten Sie einen solchen Tisch.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion .modifier (BorderPosition (position: position)), mit der wir die BorderPosition-Struktur in einen Modifier umgewandelt haben, setzt nur eine zus√§tzliche Schraube in der Schublade am Tischbein. Die BorderPosition-Struktur ist diese Schraube. Das Rendern nimmt zum Zeitpunkt des Renderns dieses Feld, nimmt ein Bein heraus (in unserem Fall Rectangle ()) und ruft nacheinander alle Modifikatoren aus der Liste mit den darin gespeicherten Werten ab. Die K√∂rperfunktion jedes Modifikators ist eine Anweisung, wie ein Bein mit dieser Schraube an eine Tischplatte geschraubt wird, und die Struktur selbst mit gespeicherten Eigenschaften, dies ist diese Schraube. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum ist es wichtig, dies im Kontext der Animation zu verstehen? Mit der Animation k√∂nnen Sie die Parameter eines Modifikators √§ndern, ohne die anderen zu beeinflussen, und das Bild dann erneut rendern. Wenn Sie dasselbe tun, indem Sie einige √§ndern</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter - Dies f√ºhrt zu einer Neuinitialisierung der verschachtelten Ansicht, der Modifikatorstrukturen usw. entlang der gesamten Kette. Aber die Animation ist nicht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir den Wert der Position √§ndern, wenn wir eine Taste dr√ºcken, √§ndert sich dies tats√§chlich. Bis zum Ende. In der Variablen selbst sind keine Zwischenzust√§nde gespeichert, was √ºber den Modifikator nicht gesagt werden kann. F√ºr jedes neue Bild √§ndern sich die Werte der Modifikatorparameter entsprechend dem Fortschritt der aktuellen Animation. Wenn die Animation 1 Sekunde dauert, √§ndert sich alle 1/60 Sekunde (das iPhone zeigt genau die Anzahl der Bilder pro Sekunde) der animatableData-Wert im Modifikator und wird vom Rendering zum Rendern gelesen. Nach einer weiteren 1/60 Sekunde wird er angezeigt erneut ge√§ndert und vom Render erneut gelesen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was charakteristisch ist, wir erhalten zuerst den Endzustand der gesamten Ansicht, merken uns das und erst dann beginnt der Animationsmechanismus, die interpolierten Positionswerte in den Modifikator zu √ºbertragen. Der Ausgangszustand wird nirgendwo gespeichert. Irgendwo im Darm von SwiftUI wird nur der Unterschied zwischen dem Anfangs- und dem Endzustand gespeichert. Diese Differenz wird jedes Mal mit dem Bruchteil der verstrichenen Zeit multipliziert. Auf diese Weise wird der interpolierte Wert berechnet, der anschlie√üend in animatableData eingesetzt wird. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Differenz = </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stahl </font></font><br><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">- war </font></i><i><font style="vertical-align: inherit;">aktueller Wert = Stahl - Differenz * (1 - verstrichene Zeit) verstrichene </font></i><i><font style="vertical-align: inherit;">
Zeit = Zeit ab StartAnimationen / DauerAnimationen Der</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
aktuelle Wert muss so oft berechnet werden, wie die Anzahl der Frames </font><i><font style="vertical-align: inherit;">angezeigt</font></i><font style="vertical-align: inherit;"> werden muss.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum wird es nicht explizit verwendet? Tatsache ist, dass SwiftUI den Ausgangszustand nicht speichert. Es wird nur der Unterschied gespeichert: Im Falle eines Fehlers k√∂nnen Sie die Animation einfach ausschalten und zum aktuellen Status ‚ÄûWerden‚Äú wechseln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit diesem Ansatz k√∂nnen Sie die Animation reversibel machen. Angenommen, irgendwo in der Mitte einer Animation hat der Benutzer erneut eine Taste gedr√ºckt, und wir haben den Wert derselben Variablen erneut ge√§ndert. In diesem Fall m√ºssen wir nur "Aktuell" in der Animation zum Zeitpunkt der neuen √Ñnderung als "Es" nehmen, sich an den neuen Unterschied erinnern und eine neue Animation basierend auf dem neuen "Wurde" und dem neuen "Unterschied" starten. . Ja, tats√§chlich sind diese √úberg√§nge von einer Animation zur anderen etwas schwieriger zu simulieren, aber die Bedeutung ist meines Erachtens verst√§ndlich.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Interessant ist, dass die Animation in jedem Frame nach dem aktuellen Wert im Modifikator fragt (mithilfe eines Getters). Dies ist, wie Sie den Serviceaufzeichnungen im Protokoll entnehmen k√∂nnen, f√ºr den Status ‚ÄûStahl‚Äú verantwortlich. Dann setzen wir mit dem Setter den neuen Status, der f√ºr diesen Frame aktuell ist. Danach wird f√ºr den n√§chsten Frame erneut der aktuelle Wert vom Modifikator angefordert - und er wird wieder "geworden", d. H. Der endg√ºltige Wert, zu dem sich die Animation bewegt. Es ist wahrscheinlich, dass Kopien von Modifikatorstrukturen f√ºr die Animation verwendet werden und ein Getter einer Struktur (ein realer Modifikator der tats√§chlichen Ansicht) verwendet wird, um den Wert ‚ÄûStahl‚Äú zu erhalten, und ein Setter einer anderen (ein tempor√§rer Modifikator, der f√ºr die Animation verwendet wird). Ich habe mir keine M√∂glichkeit ausgedacht, dies sicherzustellen, aber durch indirekte Angaben sieht alles einfach so aus. So oder so,√Ñnderungen innerhalb der Animation wirken sich nicht auf den gespeicherten Wert der Modifikatorstruktur der aktuellen Ansicht aus. Wenn Sie Ideen haben, wie Sie genau herausfinden k√∂nnen, was genau mit dem Getter und Setter passiert, schreiben Sie dar√ºber in den Kommentaren. Ich werde den Artikel aktualisieren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehrere Parameter</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bis zu diesem Moment hatten wir nur einen Parameter f√ºr die Animation. </font><font style="vertical-align: inherit;">Die Frage kann sich stellen, aber was ist, wenn mehr als ein Parameter an den Modifikator √ºbergeben wird? </font><font style="vertical-align: inherit;">Und wenn beide gleichzeitig animiert werden m√ºssen? </font><font style="vertical-align: inherit;">So geht es zum Beispiel mit dem Frame-Modifikator (Breite: H√∂he :). </font><font style="vertical-align: inherit;">Schlie√ülich k√∂nnen wir gleichzeitig sowohl die Breite als auch die H√∂he dieser Ansicht √§ndern, und wir m√∂chten, dass die √Ñnderung in einer Animation erfolgt. Wie geht das? </font><font style="vertical-align: inherit;">Immerhin ist der AnimatableData-Parameter einer. Was soll er ersetzen?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie schauen, hat Apple nur eine Anforderung f√ºr animatableData. Der Datentyp, den Sie ersetzen, muss dem VectorArithmetic-Protokoll entsprechen. F√ºr dieses Protokoll muss das Objekt die minimalen arithmetischen Operationen sicherstellen, die erforderlich sind, um ein Segment mit zwei Werten bilden zu k√∂nnen, und die Punkte innerhalb dieses Segments interpolieren. Die daf√ºr notwendigen Operationen sind Addition, Subtraktion und Multiplikation. Die Schwierigkeit besteht darin, dass wir diese Operationen mit einem einzelnen Objekt ausf√ºhren m√ºssen, in dem mehrere Parameter gespeichert sind. Jene. Wir m√ºssen die gesamte Liste unserer Parameter in einen Container packen, der ein Vektor sein wird. Apple bietet ein solches Objekt sofort an und bietet uns an, eine schl√ºsselfertige L√∂sung f√ºr nicht sehr schwierige F√§lle zu verwenden. Es hei√üt AnimatablePair.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns die Aufgabe ein wenig √§ndern. </font><font style="vertical-align: inherit;">Wir brauchen einen neuen Modifikator, der nicht nur den gr√ºnen Balken verschiebt, sondern auch seine H√∂he √§ndert. </font><font style="vertical-align: inherit;">Dies sind zwei unabh√§ngige Modifikatorparameter. </font><font style="vertical-align: inherit;">Ich werde nicht den vollst√§ndigen Code aller √Ñnderungen angeben, die vorgenommen werden m√ºssen. Sie k√∂nnen ihn auf dem Github in der SimpleBorderMove-Datei sehen. </font><font style="vertical-align: inherit;">Ich werde nur den Modifikator selbst zeigen:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TwoParameterBorder</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> height: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">let</span> startDate: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">AnimatablePair</span>&lt;<span class="hljs-type">CGFloat</span>, <span class="hljs-type">CGFloat</span>&gt; {
        <span class="hljs-keyword">get</span> {
           <span class="hljs-built_in">print</span>(<span class="hljs-string">"animation read position: \(position), height: \(height)"</span>)
           <span class="hljs-keyword">return</span> <span class="hljs-type">AnimatablePair</span>(position, height)<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>.position = newValue.first
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"animating position at \(position)"</span>)
            <span class="hljs-keyword">self</span>.height = newValue.second
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"animating height at \(height)"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">init</span>(position: <span class="hljs-type">CGFloat</span>, height: <span class="hljs-type">CGFloat</span>){
        <span class="hljs-keyword">self</span>.position = position
        <span class="hljs-keyword">self</span>.height = height<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span><font></font>
            content<font></font>
                .animation(<span class="hljs-literal">nil</span>)<font></font>
                .offset(x: -geometry.size.width / <span class="hljs-number">2</span> + geometry.size.width * <span class="hljs-keyword">self</span>.position, y: <span class="hljs-number">0</span>)<font></font>
                .frame(height: <span class="hljs-keyword">self</span>.height * (geometry.size.height - <span class="hljs-number">20</span>) + <span class="hljs-number">20</span>)<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vn/0q/mi/vn0qmirl31w63mzgjvijsw-f-ps.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe einen weiteren Schieberegler und eine Schaltfl√§che zum zuf√§lligen √Ñndern beider Parameter in der √ºbergeordneten Ansicht von SimpleView hinzugef√ºgt, aber es gibt nichts Interessantes. F√ºr den vollst√§ndigen Code sind Sie also im Github willkommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles funktioniert, wir erhalten wirklich eine konsistente √Ñnderung der Parameterpaare, die im AnimatablePair-Tupel enthalten sind. </font><font style="vertical-align: inherit;">Nicht schlecht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nichts verwirrt an dieser Implementierung? </font><font style="vertical-align: inherit;">Pers√∂nlich habe ich mich angespannt, als ich diesen Entwurf sah:</font></font><br>
<br>
<pre><code class="swift hljs">        
<span class="hljs-keyword">self</span>.position = newValue.first
<span class="hljs-keyword">self</span>.height = newValue.second
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe nirgendwo angegeben, welcher dieser Parameter zuerst und welcher an zweiter Stelle stehen soll. Wie entscheidet SwiftUI, welcher Wert zuerst und welcher Wert an zweiter Stelle eingegeben werden soll? Stimmen die Namen der Funktionsparameter nicht mit den Namen der Strukturattribute √ºberein?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erste Idee war die Reihenfolge der Attribute in den Parametern der Funktion und deren Typen, wie dies bei @EnvironmentObject der Fall ist. Dort geben wir einfach die Werte in das Feld ein, ohne ihnen Beschriftungen zuzuweisen, und holen sie dann heraus, auch ohne Beschriftungen anzugeben. Dort ist der Typ wichtig und innerhalb eines Typs die Reihenfolge. In welcher Reihenfolge sie in die Schachtel legen, auf die gleiche Weise und bekommen es. Ich versuchte eine andere Reihenfolge der Argumente der Funktion, die Reihenfolge der Argumente zum Initialisieren der Struktur, die Reihenfolge der Attribute der Struktur selbst, schlug meinen Kopf im Allgemeinen gegen die Wand, konnte SwiftUI jedoch nicht verwirren, so dass es begann, die Position mit H√∂henwerten zu animieren und umgekehrt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann d√§mmerte es mir. Ich selbst gebe an, welcher Parameter der erste und welcher zweite im Getter sein wird. SwiftUI muss nicht genau wissen, wie wir diese Struktur initialisieren. Es kann den animatableData-Wert vor der √Ñnderung abrufen, ihn nach der √Ñnderung abrufen, die Differenz zwischen ihnen berechnen und dieselbe Differenz, skaliert proportional zum verstrichenen Zeitintervall, an unseren Setter zur√ºckgeben. Im Allgemeinen muss nichts √ºber den Wert selbst in AnimatableData bekannt sein. Und wenn Sie die Reihenfolge der Variablen in zwei benachbarten Zeilen nicht verwechseln, ist alles in Ordnung, egal wie kompliziert die Struktur des restlichen Codes ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber lass es uns √ºberpr√ºfen. Schlie√ülich k√∂nnen wir unseren eigenen Container-Vektor erstellen (oh, ich liebe es, unsere eigene Implementierung vorhandener Objekte zu erstellen, das haben Sie vielleicht aus einem fr√ºheren Artikel bemerkt).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ao/v4/an/aov4an8tjqou27syes6klcckwy0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir beschreiben die Elementarstruktur, deklarieren die Unterst√ºtzung f√ºr das VectorArithmetic-Protokoll, √∂ffnen den Fehler, dass das Protokoll nicht konform ist, klicken auf Fix und erhalten die Deklaration aller erforderlichen Funktionen und berechneten Parameter. </font><font style="vertical-align: inherit;">Es bleibt nur, um sie zu f√ºllen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf die gleiche Weise f√ºllen wir unser Objekt mit den erforderlichen Methoden f√ºr das AdditiveArithmetic-Protokoll (VectorArithmetic enth√§lt dessen Unterst√ºtzung).</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyAnimatableVector</span>: <span class="hljs-title">VectorArithmetic</span></span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> - <span class="hljs-params">(lhs: MyAnimatableVector, rhs: MyAnimatableVector)</span></span> -&gt; <span class="hljs-type">MyAnimatableVector</span> {
        <span class="hljs-type">MyAnimatableVector</span>(position: lhs.position - rhs.position, height: lhs.height - rhs.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> + <span class="hljs-params">(lhs: MyAnimatableVector, rhs: MyAnimatableVector)</span></span> -&gt; <span class="hljs-type">MyAnimatableVector</span> {
        <span class="hljs-type">MyAnimatableVector</span>(position: lhs.position + rhs.position, height: lhs.height + rhs.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scale</span><span class="hljs-params">(by rhs: Double)</span></span> {
        <span class="hljs-keyword">self</span>.position = <span class="hljs-keyword">self</span>.position * <span class="hljs-type">CGFloat</span>(rhs)
        <span class="hljs-keyword">self</span>.height = <span class="hljs-keyword">self</span>.height * <span class="hljs-type">CGFloat</span>(rhs)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> magnitudeSquared: <span class="hljs-type">Double</span>{
         <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.position * <span class="hljs-keyword">self</span>.position) + <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.height * <span class="hljs-keyword">self</span>.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> zero: <span class="hljs-type">MyAnimatableVector</span>{
        <span class="hljs-type">MyAnimatableVector</span>(position: <span class="hljs-number">0</span>, height: <span class="hljs-number">0</span>)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> height: <span class="hljs-type">CGFloat</span>
}</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich denke warum wir + und - offensichtlich brauchen. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skalierung ist eine Funktion der Skalierung. </font><font style="vertical-align: inherit;">Wir nehmen den Unterschied ‚ÄûEs war - es ist geworden‚Äú und multiplizieren ihn mit der aktuellen Stufe der Animation (von 0 bis 1). </font><font style="vertical-align: inherit;">"Es wurde + Differenz * (1 - Stufe)" und es wird einen aktuellen Wert geben, den wir in animatableData ablegen sollten</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Null wird wahrscheinlich ben√∂tigt, um neue Objekte zu initialisieren, deren Werte f√ºr die Animation verwendet werden. </font><font style="vertical-align: inherit;">Die Animation verwendet zu Beginn .zero, aber ich konnte nicht genau herausfinden, wie. </font><font style="vertical-align: inherit;">Ich halte dies jedoch nicht f√ºr wichtig.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MagnitudeSquared ist ein Skalarprodukt eines bestimmten Vektors mit sich selbst. </font><font style="vertical-align: inherit;">F√ºr den zweidimensionalen Raum bedeutet dies die L√§nge des Vektors im Quadrat. </font><font style="vertical-align: inherit;">Dies wird wahrscheinlich verwendet, um zwei Objekte nicht elementweise, sondern als Ganzes miteinander vergleichen zu k√∂nnen. </font><font style="vertical-align: inherit;">Es scheint nicht f√ºr Animationszwecke verwendet zu werden.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen sind die Funktionen "- =" "+ =" ebenfalls in der Protokollunterst√ºtzung enthalten, k√∂nnen jedoch f√ºr die Struktur automatisch in dieser Form generiert werden</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> -= <span class="hljs-params">(lhs: <span class="hljs-keyword">inout</span> MyAnimatableVector, rhs: MyAnimatableVector)</span></span> {<font></font>
        lhs = lhs - rhs<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> += <span class="hljs-params">(lhs: <span class="hljs-keyword">inout</span> MyAnimatableVector, rhs: MyAnimatableVector)</span></span> {<font></font>
        lhs = lhs + rhs<font></font>
    }<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Klarheit halber habe ich all diese Logik in Form eines Diagramms dargestellt. </font><font style="vertical-align: inherit;">
Das Bild ist anklickbar. </font><font style="vertical-align: inherit;">
Was wir w√§hrend der Animation erhalten, wird rot hervorgehoben - bei jedem n√§chsten Tick (1/60 Sekunde) gibt der Timer einen neuen Wert von t an, und wir erhalten im Setter unseres Modifikators einen neuen Wert von animatableData. </font><font style="vertical-align: inherit;">So funktioniert Animation unter der Haube. </font><font style="vertical-align: inherit;">Gleichzeitig ist es wichtig zu verstehen, dass ein Modifikator eine gespeicherte Struktur ist und eine Kopie des aktuellen Modifikators mit einem neuen, aktuellen Status zum Anzeigen der Animation verwendet wird.</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/zl/ag/q4/zlagq42atcapum-br2sj00ikubu.png"></a><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum AnimatableData nur eine Struktur sein kann</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt noch einen Punkt. Sie k√∂nnen Klassen nicht als AnimatableData-Objekt verwenden. Formal k√∂nnen Sie f√ºr eine Klasse alle erforderlichen Methoden des entsprechenden Protokolls beschreiben, dies wird jedoch nicht erfolgreich sein, und hier ist der Grund daf√ºr. Wie Sie wissen, ist eine Klasse ein Referenzdatentyp und eine Struktur ein wertebasierter Datentyp. Wenn Sie eine Variable basierend auf einer anderen erstellen, kopieren Sie im Fall einer Klasse einen Link zu diesem Objekt, und im Fall einer Struktur erstellen Sie ein neues Objekt basierend auf den Werten der vorhandenen. Hier ist ein kleines Beispiel, das diesen Unterschied veranschaulicht:</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TestStruct</span></span>{
        <span class="hljs-keyword">var</span> value: <span class="hljs-type">CGFloat</span>
        <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scaled</span><span class="hljs-params">(by: CGFloat)</span></span>{
            <span class="hljs-keyword">self</span>.value = <span class="hljs-keyword">self</span>.value * by<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span></span>{
        <span class="hljs-keyword">var</span> value: <span class="hljs-type">CGFloat</span>
        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scaled</span><span class="hljs-params">(by: CGFloat)</span></span>{
             <span class="hljs-keyword">self</span>.value = <span class="hljs-keyword">self</span>.value * by<font></font>
        }<font></font>
        <span class="hljs-keyword">init</span>(value: <span class="hljs-type">CGFloat</span>){
            <span class="hljs-keyword">self</span>.value = value<font></font>
        }<font></font>
    }<font></font>
        <span class="hljs-keyword">var</span> stA = <span class="hljs-type">TestStruct</span>(value: <span class="hljs-number">5</span>)
        <span class="hljs-keyword">var</span> stB = stA<font></font>
        stB.scaled(by: <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"structs: a = \(stA.value), b = \(stB.value))"</span>) <span class="hljs-comment">//structs: a = 5.0, b = 10.0)</span>
        <span class="hljs-keyword">var</span> clA = <span class="hljs-type">TestClass</span>(value: <span class="hljs-number">5</span>)
        <span class="hljs-keyword">var</span> clB = clA<font></font>
        clB.scaled(by: <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"classes: a = \(clA.value), b = \(clB.value))"</span>) <span class="hljs-comment">//classes: a = 10.0, b = 10.0)</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Animation passiert genau das Gleiche. Wir haben ein AnimatableData-Objekt, das den Unterschied zwischen "war" und "wurde" darstellt. Wir m√ºssen einen Teil dieser Differenz berechnen, um sie auf dem Bildschirm wiederzugeben. Dazu m√ºssen wir diesen Unterschied kopieren und mit einer Zahl multiplizieren, die die aktuelle Stufe der Animation darstellt. Im Fall der Struktur wirkt sich dies nicht auf den Unterschied selbst aus, im Fall der Klasse jedoch. Der erste Rahmen, den wir zeichnen, ist der Zustand ‚Äûwar‚Äú. Dazu m√ºssen wir Stahl + Differenz * Aktuelle Stufe - Differenz berechnen. Im Fall der Klasse multiplizieren wir im ersten Rahmen die Differenz mit 0, setzen sie auf Null, und alle nachfolgenden Rahmen werden so gezeichnet, dass die Differenz = 0 ist, d.h. Die Animation scheint korrekt gezeichnet zu sein, aber tats√§chlich sehen wir einen sofortigen √úbergang von einem Zustand in einen anderen, als ob es keine Animation g√§be.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen wahrscheinlich eine Art Low-Level-Code schreiben, der neue Speicheradressen f√ºr das Multiplikationsergebnis erstellt - aber warum? </font><font style="vertical-align: inherit;">Sie k√∂nnen einfach Strukturen verwenden - sie werden daf√ºr erstellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr diejenigen, die genau verstehen m√∂chten, wie SwiftUI Zwischenwerte berechnet, durch welche Vorg√§nge und zu welchem ‚Äã‚ÄãZeitpunkt </font><font style="vertical-align: inherit;">Nachrichten in die Konsole </font><font style="vertical-align: inherit;">des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projekts √ºbertragen werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Au√üerdem habe ich dort 0,1 Sekunden Schlaf eingef√ºgt, um ressourcenintensive Berechnungen in die Animation zu simulieren. Viel Spa√ü :)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bildschirmanimation: .transition ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bis zu diesem Punkt haben wir dar√ºber gesprochen, eine √Ñnderung eines Werts zu animieren, der an einen Modifikator oder ein Formular √ºbergeben wurde. Dies sind ziemlich m√§chtige Werkzeuge. Es gibt jedoch noch ein anderes Tool, das ebenfalls Animationen verwendet - dies ist die Animation des Auftretens und Verschwindens der Ansicht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im letzten Artikel haben wir dar√ºber gesprochen, dass dies im deklarativen Stil von if-else √ºberhaupt keine Kontrolle √ºber den Codefluss zur Laufzeit ist, sondern eine Ansicht von Schr√∂dinger. Dies ist ein Container, der zwei Ansichten gleichzeitig enth√§lt und entscheidet, welche gem√§√ü einer bestimmten Bedingung angezeigt werden soll. Wenn Sie den else-Block verpassen, wird anstelle der zweiten Ansicht EmptyView angezeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Umschalten zwischen den beiden Ansichten kann auch animiert werden. Hierf√ºr wird der Modifikator .transition () verwendet.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TransitionView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">let</span> views: [<span class="hljs-type">AnyView</span>] = [<span class="hljs-type">AnyView</span>(<span class="hljs-type">CustomCircleTestView</span>()), <span class="hljs-type">AnyView</span>(<span class="hljs-type">SimpleBorderMove</span>())]<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> currentViewInd = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">ZStack</span>{
                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                        }<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-type">HStack</span>{
                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">10</span>)<font></font>
                        .fill(ind == <span class="hljs-keyword">self</span>.currentViewInd ? <span class="hljs-type">Color</span>.green : <span class="hljs-type">Color</span>.gray)<font></font>
                        .overlay(<font></font>
                            <span class="hljs-type">Text</span>(<span class="hljs-string">"\(ind + Int(1))"</span>))<font></font>
                        .onTapGesture{<font></font>
                            withAnimation{<font></font>
                                <span class="hljs-keyword">self</span>.currentViewInd = ind<font></font>
                            }<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
                .frame(height: <span class="hljs-number">50</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie es funktioniert. Zun√§chst haben wir bereits in der Initialisierungsphase der √ºbergeordneten Ansicht mehrere Ansichten erstellt und im Array platziert. Das Array ist vom Typ AnyView, da die Elemente des Arrays denselben Typ haben m√ºssen, andernfalls k√∂nnen sie in ForEach nicht verwendet werden. Undurchsichtiger Ergebnistyp aus dem vorherigen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , erinnerst du dich? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als n√§chstes haben wir die Aufz√§hlung der Indizes dieses Arrays vorgeschrieben und f√ºr jeden von ihnen die Ansicht anhand dieses Index angezeigt. Wir sind gezwungen, dies zu tun und nicht sofort √ºber View zu iterieren, da wir f√ºr die Arbeit mit ForEach jedem Element einen internen Bezeichner zuweisen m√ºssen, damit SwiftUI den Inhalt der Sammlung durchlaufen kann. Alternativ m√ºssten wir in jeder Ansicht eine Proxy-ID erstellen, aber warum, wenn Indizes verwendet werden k√∂nnen?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir verpacken jede Ansicht aus der Sammlung in einen Zustand und zeigen sie nur an, wenn sie aktiv ist. Das if-else-Konstrukt kann hier jedoch nicht existieren. Der Compiler √ºbernimmt es zur Steuerung des Flusses. Daher schlie√üen wir dies alles in Group ein, damit der Compiler genau versteht, was es ist. View, genauer gesagt, Anweisungen f√ºr ViewBuilder zum Erstellen eines optionalen Containers ConditionalContent &lt;View1, View2&gt;. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie nun den Wert von currentViewInd √§ndern, blendet SwiftUI die vorherige aktive Ansicht aus und zeigt die aktuelle an. Wie gef√§llt Ihnen diese Navigation in der Anwendung?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ua/kr/gd/uakrgd2tzwv9hik_egmn1fglsfw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles, was noch getan werden muss, ist, die aktuelle ViewInd-√Ñnderung in den withAnimation-Wrapper einzuf√ºgen, und das Wechseln zwischen Fenstern wird reibungslos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºgen Sie den Modifikator .transition hinzu und geben Sie als Parameter .scale an. </font><font style="vertical-align: inherit;">Dadurch wird die Animation des Erscheinungsbilds und Verschwindens jeder dieser Ansichten unterschiedlich - wobei die Skalierung anstelle der von der Standard-SwiftUI verwendeten Transparenz verwendet wird.</font></font><br>
<br>
<pre><code class="swift hljs">                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                                .transition(.scale)<font></font>
                        }<font></font>
                    }<font></font>
                }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/l5/ib/d-/l5ibd-y7m986miqinbv56qaslfc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass die Ansicht mit derselben Animation angezeigt und ausgeblendet wird. Nur das Verschwinden wird in umgekehrter Reihenfolge gescrollt. </font><font style="vertical-align: inherit;">Tats√§chlich k√∂nnen wir Animationen sowohl f√ºr das Erscheinungsbild als auch f√ºr das Verschwinden einer Ansicht individuell zuweisen. </font><font style="vertical-align: inherit;">Hierf√ºr wird ein asymmetrischer √úbergang verwendet.</font></font><br>
<br>
<pre><code class="swift hljs">                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                               .transition(.asymmetric(<font></font>
                                    insertion: insertion: <span class="hljs-type">AnyTransition</span>.scale(scale: <span class="hljs-number">0.1</span>, anchor: .leading).combined(with: .opacity),<font></font>
                                    removal: .move(edge: .trailing)))<font></font>
                        }<font></font>
                    }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mq/xg/ji/mqxgji1ton95qn6ywl23xhl2mzm.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die gleiche .scale-Animation wird auf dem Bildschirm angezeigt, aber jetzt haben wir die Parameter f√ºr ihre Verwendung angegeben. Es beginnt nicht mit einer Gr√∂√üe von Null (Punkt), sondern mit einer Gr√∂√üe von 0,1 gegen√ºber der √ºblichen. Die Startposition des kleinen Fensters befindet sich nicht in der Mitte des Bildschirms, sondern ist zum linken Rand verschoben. Dar√ºber hinaus ist nicht ein √úbergang f√ºr das Erscheinungsbild verantwortlich, sondern zwei. Sie k√∂nnen mit .combined (mit :) kombiniert werden. In diesem Fall haben wir Transparenz hinzugef√ºgt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Verschwinden der Ansicht wird jetzt durch eine andere Animation gerendert - √ºber den rechten Bildschirmrand. Ich habe die Animation etwas langsamer gemacht, damit Sie sie sich ansehen k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wie immer kann ich es kaum erwarten, meine eigene Version der Transitanimation zu schreiben. Dies ist noch einfacher als animierte Formulare oder Modifikatoren.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SpinTransitionModifier</span>: <span class="hljs-title">ViewModifier</span> </span>{
    <span class="hljs-keyword">let</span> angle: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> anchor: <span class="hljs-type">UnitPoint</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        content<font></font>
            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle), anchor: anchor)<font></font>
            .clipped()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">AnyTransition</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinIn</span><span class="hljs-params">(anchor: UnitPoint)</span></span> -&gt; <span class="hljs-type">AnyTransition</span> {<font></font>
        .modifier(<font></font>
            active: <span class="hljs-type">SpinTransitionModifier</span>(angle: -<span class="hljs-number">90</span>, anchor: anchor),<font></font>
            identity: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">0</span>, anchor: anchor))<font></font>
    }<font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinOut</span><span class="hljs-params">(anchor: UnitPoint)</span></span> -&gt; <span class="hljs-type">AnyTransition</span> {<font></font>
        .modifier(<font></font>
            active: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">90</span>, anchor: anchor),<font></font>
            identity: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">0</span>, anchor: anchor))<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/k-/mu/eck-muqydvucs1o59dkbnzpnw6e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst schreiben wir den √ºblichen Modifikator, in dem wir eine bestimmte Zahl √ºbertragen - den Drehwinkel in Grad sowie den Punkt, zu dem diese Drehung erfolgt. Anschlie√üend erweitern wir den AnyTransition-Typ um zwei Funktionen. Es h√§tte einer sein k√∂nnen, aber es schien mir bequemer. Ich fand es einfacher, jedem von ihnen sprechende Namen zuzuweisen, als die Rotationsgrade direkt in der Ansicht selbst zu steuern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der AnyTransition-Typ verf√ºgt √ºber eine statische Modifikatormethode, an die wir zwei Modifikatoren √ºbergeben, und wir erhalten ein AnyTransition-Objekt, das einen reibungslosen √úbergang von einem Zustand in einen anderen beschreibt. Identit√§t ist der normale Statusmodifikator der animierten Ansicht. Aktiv ist der Zustand des Beginns der Animation f√ºr das Erscheinen der Ansicht oder das Ende der Animation f√ºr das Verschwinden, d. H. das andere Ende des Segments, die Zust√§nde, innerhalb derer interpoliert wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SpinIn impliziert also, dass ich es verwenden werde, um die Ansicht von au√üerhalb des Bildschirms (oder des f√ºr die Ansicht zugewiesenen Bereichs) anzuzeigen, indem ich sie im Uhrzeigersinn um den angegebenen Punkt drehe. spinOut bedeutet, dass die Ansicht auf dieselbe Weise verschwindet und sich um denselben Punkt dreht, auch im Uhrzeigersinn. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie nach meiner Idee denselben Punkt f√ºr das Erscheinen und Verschwinden der Ansicht verwenden, wird der gesamte Bildschirm um diesen Punkt gedreht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Animationen basieren auf der Standardmodifikatormechanik. Wenn Sie einen vollst√§ndig benutzerdefinierten Modifikator schreiben, m√ºssen Sie die Anforderungen des AnimatableModifier-Protokolls implementieren, wie wir es zuvor mit TwoParameterBorder getan haben, oder die darin enthaltenen integrierten Modifikatoren verwenden, die ihre eigene Standardanimation bereitstellen. In diesem Fall habe ich mich auf die integrierte Animation .rotationEffect () in meinem Modifikator SpinTransitionModifier verlassen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Modifikator .transition () verdeutlicht nur, was als Start- und Endpunkt der Animation zu betrachten ist. Wenn Sie den AnimatableData-Status vor dem Starten der Animation anfordern m√ºssen, um den AnimatableData-Modifikator des aktuellen Status anzufordern, die Differenz zu berechnen und dann die Abnahme von 1 auf 0 zu animieren, √§ndert .transition () nur die Originaldaten. Sie sind nicht an den Status Ihrer Ansicht gebunden, sondern basieren nicht darauf. Sie geben den Anfangs- und Endzustand explizit selbst an, von diesen erhalten Sie AnimatableData, berechnen die Differenz und animieren sie. Am Ende der Animation tritt dann Ihre aktuelle Ansicht in den Vordergrund.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Identit√§t ist √ºbrigens ein Modifikator, der am Ende der Animation auf Ihre Ansicht angewendet wird. Andernfalls w√ºrde ein Fehler hier zu Spr√ºngen am Ende der Erscheinungsanimation und am Anfang der Verschwindenanimation f√ºhren. Der √úbergang kann also als ‚Äûzwei in einem‚Äú betrachtet werden. Dabei wird ein bestimmter Modifikator direkt auf Ansicht + angewendet, um die √Ñnderungen zu animieren, wenn die Ansicht angezeigt und ausgeblendet wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ehrlich gesagt scheint mir dieser Animationssteuerungsmechanismus sehr stark zu sein, und es tut mir ein wenig leid, dass wir ihn f√ºr keine Animation verwenden k√∂nnen. Ich w√ºrde dies nicht ablehnen, um endlose geschlossene Animationen zu erstellen. Wir werden jedoch im n√§chsten Artikel dar√ºber sprechen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um besser zu sehen, wie die √Ñnderung selbst erfolgt, habe ich unsere Testansicht durch elementare Quadrate ersetzt, die mit Zahlen signiert und gerahmt sind.</font></font><br>
<br>
<pre><code class="swift hljs">                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-comment">//self.views[ind]</span>
                            <span class="hljs-type">Rectangle</span>()<font></font>
                                .fill(<span class="hljs-type">Color</span>.gray)<font></font>
                                .frame(width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)<font></font>
                                .border(<span class="hljs-type">Color</span>.black, width: <span class="hljs-number">2</span>)<font></font>
                                .overlay(<span class="hljs-type">Text</span>(<span class="hljs-string">"\(ind + 1)"</span>))<font></font>
                              .transition(.asymmetric(<font></font>
                                  insertion: .spinIn(anchor: .bottomTrailing),<font></font>
                                  removal: .spinOut(anchor: .bottomTrailing)))<font></font>
                        }<font></font>
                    }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vx/4s/u9/vx4su9aoaqzuqzi2wq8uctpxe7c.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und um diese Bewegung noch besser zu machen, habe ich .clipped () aus dem SpinTransitionModifier-Modifikator entfernt:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SpinTransitionModifier</span>: <span class="hljs-title">ViewModifier</span> </span>{
    <span class="hljs-keyword">let</span> angle: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> anchor: <span class="hljs-type">UnitPoint</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        content<font></font>
            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle), anchor: anchor)
            <span class="hljs-comment">//.clipped()</span><font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ih/ml/0i/ihml0id6hnttwuhbjuv5s28jhaa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úbrigens brauchen wir jetzt SpinTransitionModifier in unserem eigenen Modifikator. </font><font style="vertical-align: inherit;">Es wurde nur erstellt, um die beiden Modifikatoren RotationEffect und Clipped () zu einem zu kombinieren, damit die Rotationsanimation nicht √ºber den f√ºr unsere Ansicht ausgew√§hlten Bereich hinausgeht. </font><font style="vertical-align: inherit;">Jetzt k√∂nnen wir .rotationEffect () direkt in .modifier () verwenden. Wir ben√∂tigen keinen Vermittler in Form von SpinTransitionModifier.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Ansicht stirbt</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein interessanter Punkt ist der View-Lebenszyklus, wenn er in einem if-else platziert wird. </font><font style="vertical-align: inherit;">Die Ansicht wird zwar initiiert und als Array-Element aufgezeichnet, jedoch nicht im Speicher gespeichert. </font><font style="vertical-align: inherit;">All ihre</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zustand</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Parameter werden beim n√§chsten Erscheinen auf dem Bildschirm auf die Standardeinstellungen zur√ºckgesetzt. Dies entspricht fast der Initialisierung. Trotz der Tatsache, dass die Objektstruktur selbst noch existiert, hat der Render sie aus ihrem Sichtfeld entfernt, f√ºr sie ist es nicht. Dies reduziert zum einen die Speichernutzung. Wenn das Array eine gro√üe Anzahl komplexer Ansichten enth√§lt, muss das Rendering diese st√§ndig zeichnen und auf √Ñnderungen reagieren. Dies wirkt sich negativ auf die Leistung aus. Wenn ich mich nicht irre, war dies vor dem Xcode 11.3-Update der Fall. Inaktive Ansichten werden jetzt aus dem Renderspeicher entladen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der anderen Seite m√ºssen wir alle wichtigen Zust√§nde √ºber den Rahmen dieser Ansicht hinaus verschieben. Verwenden Sie dazu am besten @EnvironmentObject-Variablen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur√ºck zum Lebenszyklus sollte auch beachtet werden, dass der Modifikator .onAppear {}, falls einer in dieser Ansicht registriert ist, unmittelbar nach dem √Ñndern des Zustands und des Erscheinungsbilds der Ansicht auf dem Bildschirm funktioniert, noch bevor die Animation beginnt. </font><font style="vertical-align: inherit;">Dementsprechend wird onDisappear {} nach dem Ende der Verschwinden-Animation ausgel√∂st. </font><font style="vertical-align: inherit;">Denken Sie daran, wenn Sie sie mit √úbergangsanimationen verwenden m√∂chten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was weiter? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puh </font><font style="vertical-align: inherit;">Es stellte sich ziemlich umfangreich heraus, aber im Detail und, wie ich hoffe, verst√§ndlich. </font><font style="vertical-align: inherit;">Ehrlich gesagt hatte ich gehofft, als Teil eines Artikels √ºber Regenbogenanimation sprechen zu k√∂nnen, aber ich konnte nicht rechtzeitig mit den Details aufh√∂ren. </font><font style="vertical-align: inherit;">Warten Sie also auf die Fortsetzung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der folgende Teil erwartet uns:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendung von Verl√§ufen: linear, kreisf√∂rmig und eckig - alles wird n√ºtzlich sein</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbe ist √ºberhaupt keine Farbe: W√§hlen Sie mit Bedacht aus.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loop-Animation: Wie man startet und wie man stoppt und wie man sofort stoppt (ohne Animation, √Ñndern der Animation - ja, es gibt auch eine)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktuelle Stream-Animation: Priorit√§ten, √úberschreibungen, unterschiedliche Animationen f√ºr unterschiedliche Objekte</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Details zu Animations-Timings: Wir werden Timings sowohl im Schwanz als auch in der M√§hne fahren, bis hin zu unserer eigenen Implementierung von TimingCurve (oh, halte mich sieben :))</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie man den aktuellen Moment der abgespielten Animation herausfindet</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn SwiftUI nicht ausreicht</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde dies alles am Beispiel der Erstellung einer Regenbogenanimation wie im Bild ausf√ºhrlich besprechen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich ging nicht den einfachen Weg, sondern sammelte alle Rechen, die ich erreichen konnte, und verk√∂rperte diese Animation nach den oben beschriebenen Prinzipien. </font><font style="vertical-align: inherit;">Die Geschichte dar√ºber sollte sich als sehr informativ herausstellen und reich an Tricks und allerlei Hacks sein, √ºber die es nur wenige Berichte gab und die f√ºr diejenigen n√ºtzlich sein werden, die sich entscheiden, ein Pionier in SwiftUI zu werden. </font><font style="vertical-align: inherit;">Es wird ungef√§hr in ein oder zwei Wochen erscheinen. </font><font style="vertical-align: inherit;">√úbrigens k√∂nnen Sie abonnieren, um nicht zu verpassen. </font><font style="vertical-align: inherit;">Dies jedoch nat√ºrlich nur, wenn Ihnen das Material n√ºtzlich erscheint und die Pr√§sentationsmethode genehmigt ist. </font><font style="vertical-align: inherit;">Dann hilft Ihr Abonnement dabei, neue Artikel schnell an die Spitze zu bringen und sie fr√ºhzeitig einem breiteren Publikum zug√§nglich zu machen. </font><font style="vertical-align: inherit;">Andernfalls schreiben Sie in die Kommentare, was falsch ist.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de504186/index.html">Paul Graham: Wie man n√ºtzliche Texte schreibt (vollst√§ndig)</a></li>
<li><a href="../de504188/index.html">Quarant√§ne, Online-Systeme und Datenwissenschaft. Wer denkt an Kundenbindung?</a></li>
<li><a href="../de504190/index.html">MVCC als eine M√∂glichkeit, die Transaktionsisolation sicherzustellen</a></li>
<li><a href="../de504194/index.html">Das Ergebnis einer Umfrage unter Entwicklern zu Stack Overflow 2020 (+ Habraopros)</a></li>
<li><a href="../de504196/index.html">NFC: Analyse der Nahfeldkommunikationstechnologie</a></li>
<li><a href="../de504204/index.html">IBM Workshops: Quarkus (ultraschnelles Java f√ºr Microservices), Jakarta EE und OpenShift</a></li>
<li><a href="../de504208/index.html">So automatisieren Sie ein Shared Service Center</a></li>
<li><a href="../de504210/index.html">Was ist Deno und wird es Node.js ersetzen?</a></li>
<li><a href="../de504214/index.html">Die Entwicklung von DATA VAULT und der √úbergang zu BUSINESS DATA VAULT</a></li>
<li><a href="../de504216/index.html">Wie alt ist dieses Haus? Wie ich eine Karte des Zeitalters der H√§user in St. Petersburg gemacht habe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>