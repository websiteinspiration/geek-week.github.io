<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏴󠁧󠁢󠁷󠁬󠁳󠁿 🧝🏾 🎊 ジェネリックモデルとメタプログラミングモデル：Go、Rust、Swift、Dなど 🙃 👵🏼 💷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="プログラミングの一部の領域では、通常、さまざまなタイプの要素を処理できるデータ構造またはアルゴリズムを作成する必要があります。たとえば、ジェネリックのリストや、比較関数のみが必要な並べ替えアルゴリズムなどです。さまざまな言語で、この問題を解決するさまざまな方法が提供されています。適切な共通関数（C、...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ジェネリックモデルとメタプログラミングモデル：Go、Rust、Swift、Dなど</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/461321/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cs/o5/zc/cso5zcp78nxxi31mspfvdat89w4.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラミングの一部の領域では、通常、さまざまなタイプの要素を処理できるデータ構造またはアルゴリズムを作成する必要があります。たとえば、ジェネリックのリストや、比較関数のみが必要な並べ替えアルゴリズムなどです。さまざまな言語で、この問題を解決するさまざまな方法が提供されています。適切な共通関数（C、Go）を指摘するだけでなく、プログラマーからチューリング完全になるような強力な汎用システム（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rust</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）まで。この記事では、さまざまな言語の汎用システムとその実装について説明します。私は同様のシステム（Cなど）がない言語で問題を解決することから始め、次に、拡張機能を段階的に追加することで他の言語のシステムにどのようにつながるかを示します。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネリックスは、一般的なメタプログラミングタスクの単純な特殊なケースなので、興味深いオプションであると思います。他のプログラムのクラスを生成できるプログラムを書くことです。</font><font style="vertical-align: inherit;">証明として、3つの異なる絶対的に一般的なメタプログラミング手法が、一般的なシステムの領域で多方向拡張と見なされる方法を示します。Pythonのような動的言語、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Template Haskelの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ような手続き型マクロシステム</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zig</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terraの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ような段階的コンパイル</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概観</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事で説明されているすべてのシステムのブロック図を描いて、その内容とこれらのシステムがどのように相互接続されているかを示します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5fa/259/577/5fa259577cd99685d90ab7912710e348.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主なアイデア</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
汎用システムのない言語で書いていて、あらゆるタイプのデータを処理できる汎用スタックデータ構造のデータ構造を作成したいとします。問題は、各関数と型の定義が同じサイズのデータ​​でのみ機能し、一方向にコピーされ、一般に同様に機能することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを回避するには、2つの方法があります。すべてのデータ型が構造内で同じように機能することを確認するか、わずかな変更を加えてデータ構造のコピーを多数作成し、各データ型で正しく機能するようにします。これらのアイデアは、ジェネリックとの2つの大規模なソリューショングループの基礎を形成しました。ボクシングと単形化です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パッケージ化とは、同じように機能する統一された「ボックス」にすべてを並べることを意味します。これは通常、次のように行われます。データはヒープに配置され、そのデータへのポインタがデータ構造に配置されます。同じように機能するすべての型へのポインターを作成できるため、同じコードがどの型のデータでも機能します。ただし、これにより、メモリ消費、動的検索、およびキャッシュミスが増加します。 Cでは、これは、データ構造がポインター</font></font><code>void*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">格納し、データ</font><font style="vertical-align: inherit;">を単にキャッシュする</font></font><code>void*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（データがヒープ上にない場合はそこに配置する）ことを</font><font style="vertical-align: inherit;">意味します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モノモーフィゼーションとは、格納するさまざまなタイプのデータのコードを繰り返しコピーすることを意味します。次に、各コードインスタンスは、動的検索なしで動作するサイズとデータメソッドを直接使用できます。このアプローチでは、コードは最も高速に実行されますが、同じコードを小さな変更で繰り返しコンパイルするため、サイズとコンパイル時間が増加します。 Cでは、これ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はマクロとしてのデータ構造全体</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">定義に</font></a><font style="vertical-align: inherit;">対応し</font><font style="vertical-align: inherit;">、その後に各データ型の呼び出しが続きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、コンパイル時のコードのコンパイル速度は速くなりますが、実行中にパフォーマンスが低下する可能性があります。一方、モノモーフィングの場合は高速なコードが生成されますが、コードのすべてのインスタンスをコンパイルして最適化するには時間がかかります。もう1つの違いは、拡張機能をパッケージ化すると、実行可能コードの動作をより動的にできることと、モノモーフィケーションによって、汎用コードの異なるインスタンスをより柔軟に分離できることです。また、一部の大規模なプログラムでは、生成されたコードからの追加の命令のキャッシュでのミスにより、単形化の利点が相殺される可能性があることにも注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネリックを使用するための説明された各スキームは、より多くの機能またはセキュリティが必要で、さまざまな言語の作成者が非常に興味深い解決策を考え出した場合、さまざまな方向に拡張できます。</font><font style="vertical-align: inherit;">たとえば、どちらのアプローチもRustとC＃で使用できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goの基本的なパッケージングの例から始めましょう。</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> Stack <span class="hljs-keyword">struct</span> {<font></font>
  values []<span class="hljs-keyword">interface</span>{}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Stack)</span> <span class="hljs-title">Push</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>{})</span></span> {<font></font>
  this.values = <span class="hljs-built_in">append</span>(this.values, value)<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Stack)</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>{} {<font></font>
  x := this.values[<span class="hljs-built_in">len</span>(this.values)<span class="hljs-number">-1</span>]<font></font>
  this.values = this.values[:<span class="hljs-built_in">len</span>(this.values)<span class="hljs-number">-1</span>]
  <span class="hljs-keyword">return</span> x<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、パッケージ化はC（</font></font><code>void*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、Go（</font></font><code>interface{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、前汎用Java（</font></font><code>Object</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、および前汎用Objective-C（</font></font><code>id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）で使用されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マッシング型のパックされたジェネリック</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主なパッケージ方法には欠点があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">言語によっては、データ構造の読み取りまたは書き込みを行うたびに、正しい型との間で値をキャストしなければならないことがよくあります。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード実行中にクラッシュのように見えるバグを引き起こす可能性がある、構造に異なるタイプの要素を配置することを妨げるものは何もありません。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どちらの問題も、システムに一般的なタイプの機能を追加することで解決できますが、コードの実行中に以前と同じようにメインのパッケージ方法を使用します。</font><font style="vertical-align: inherit;">一般的なシステムの型は「上書き」され、内部で1つの型（のような</font></font><code>Object</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）に</font><font style="vertical-align: inherit;">なるため、このアプローチはしばしば型の消去と呼ばれます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaとObjective-Cは、通常のパッケージ化から始まり、互換性のために、型のマッシングを使用したジェネリックの言語ツールを後で取得しました。以前と同じコレクション型を使用していますが、ジェネリック型のオプションのパラメーターを使用しています。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javaのジェネリック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">についてのWikipediaの例を考えてみましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="java hljs">List v = <span class="hljs-keyword">new</span> ArrayList();<font></font>
v.add(<span class="hljs-string">"test"</span>); <span class="hljs-comment">// A String that cannot be cast to an Integer</span>
Integer i = (Integer)v.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// Run time error</span><font></font>
<font></font>
List&lt;String&gt; v = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<font></font>
v.add(<span class="hljs-string">"test"</span>);<font></font>
Integer i = v.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// (type error) compilation-time error</span>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">統一されたパフォーマンスを持つ派生パッケージジェネリック</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OCamlは、統一されたビューのアイデアをさらに発展させます。 （それがどのように追加のパッケージの配置を必要とする何のプリミティブ型はありません</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でに有効にしてください</font></font><code>Integer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に入るために</font></font><code>ArrayList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてがすでに整数値によってポインタのサイズを詰めたり表現されているため、Javaの）、である、すべてのフィットは、1つの機械語に。ただし、ガベージコレクターはジェネリックの構造に格納されているデータを見るとき、ポインターを数値と区別する必要があるため、数値は1ビットでマークされ、正しく整列されたポインターが1ビットを持たない場所に配置され、31または63ビットの範囲しか残されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OCamlには型推論システムもあります。そのため、関数を記述でき、注釈を付けない場合、コンパイラーは最も適切なジェネリック型を出力します。そのため、関数は動的に型付けされた言語のように見えます。</font></font><br>
<br>
<pre><code class="plaintext hljs">let first (head :: tail) = head<font></font>
(* inferred type: 'a list -&gt; 'a *)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与えられた型は、「型要素のリストから型</font></font><code>'a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を持つ何かへの</font><font style="vertical-align: inherit;">関数」と呼ぶことができます</font></font><code>'a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">つまり、戻り値の型はリストの型と同じになり、どの型でもかまいません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェース</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
従来のパッケージのもう1つの制限は、パッケージタイプが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不透明であることです。</font><font style="vertical-align: inherit;">これはスタックのようなデータ構造の問題ではありませんが、ジェネリック関数のソートなどのツールには、型固有の比較関数などの追加機能が必要です。</font><font style="vertical-align: inherit;">これを実行時に実装し、言語に反映する方法は数多くあります。技術的にはこれらの方向は異なり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、同じ言語をいくつかの類似したアプローチで実装</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、さまざまな言語の機能はそれらの実装に影響し、拡張機能のみが選択された実装の強みを強化します。</font><font style="vertical-align: inherit;">これは、ランタイムへのさまざまなアプローチに基づいた2つの言語ファミリがあることを意味します。仮想メソッドテーブル（vtables）と辞書転送です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェイスメソッドテーブル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプ固有の関数を提供したい場合は、すべてを統合して作業するためのパッケージ戦略に準拠する場合、オブジェクトから取得する必要のある類似の関数を見つけるための統一された方法があれば十分です。この方法は「仮想メソッドテーブル」（vtables、仮想メソッドテーブル）と呼ばれますが、フルネームを使用する人はいません。これは次のように実装されます。各ジェネリック構造体オブジェクトのゼロオフセットには、一貫した回路を持つ関数ポインターのテーブルへのポインターがあります。これらの表では、汎用コードは、特定のポインターに固定オフセットでインデックスを付けることにより、型固有の関数へのポインターを探します。</font><font style="vertical-align: inherit;">Go </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプ</font></font><code>interface</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とオブジェクトが</font><font style="vertical-align: inherit;">実装されています</font></font><code>dyn trait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラストで。</font><font style="vertical-align: inherit;">型を実装する型のインターフェイス型にキャストすると、ソースオブジェクトへのポインターと型固有の関数のvtableへのポインターを含むインターフェイスのラッパーが作成されます。</font><font style="vertical-align: inherit;">ただし、これには、ポインタの間接アドレッシングの追加レベルと別のスキームが必要です。</font><font style="vertical-align: inherit;">したがって、Goでの並べ替えで</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、Swapメソッドを使用したコンテナー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">インターフェイスが</font></a><font style="vertical-align: inherit;">使用され</font><font style="vertical-align: inherit;">、Comparableインターフェイスのスライスは使用されません。これは、元のスライスの代わりに並べ替えられる完全に新しいインターフェイス型のスライスをメモリに配置する必要があるためです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクト指向プログラミング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOPは、仮想型テーブルの機能をうまく利用する言語プロパティです。</font><font style="vertical-align: inherit;">vtableを持つ個別のインターフェースオブジェクトの代わりに、JavaのようなOOP言語は、各オブジェクトの先頭に仮想型のテーブルへのポインターを挿入するだけです。</font><font style="vertical-align: inherit;">Javaのような言語には、これらの仮想型オブジェクトテーブルを使用して完全に実装できる継承システムとインターフェースがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
追加機能を提供することに加えて、各オブジェクトにvtableを埋め込むと、間接アドレス指定（間接）を使用して新しいインターフェイスタイプを構築する必要があるという問題が解決されます。</font><font style="vertical-align: inherit;">Goとは異なり、Java </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では、sort関数</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><code>Comparable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装する型に</font><font style="vertical-align: inherit;">インターフェース</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">適用できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反射</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想タイプのテーブルがある場合、コンパイラーに、フィールドの名前、タイプ、場所など、他のタイプの情報のテーブルを強制的に生成させることは難しくありません。</font><font style="vertical-align: inherit;">これにより、他のタイプのすべてのデータを表示できるコードを使用して、このタイプのすべてのデータにアクセスできます。</font><font style="vertical-align: inherit;">この動作は、言語に「リフレクション」を追加するために使用できます。これにより、シリアル化と任意のタイプの美しい表示が可能になります。</font><font style="vertical-align: inherit;">パッケージ化パラダイムの拡張としてのリフレクションには欠点があります。コードのコピーは1つで十分ですが、多くの動的検索を実行する必要があるため、シリアル化の速度が低下します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シリアル化やその他の関数にリフレクションを使用する言語：Java、C＃、Go。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的に型付けされた言語</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リフレクションは、さまざまなメタプログラミングタスクの束を解決できる非常に強力なツールです。ただし、新しいタイプを作成したり、既存の値のタイプに関する情報を編集したりすることはできません。この機能を追加して、データアクセスと変更構文にデフォルトでリフレクションを使用させると、動的に型付けされた言語が得られます。 PythonやRubyなどの言語でのメタプログラミングの驚くべき柔軟性は、問題の解決に使用される効果的で強力なリフレクションシステムのおかげで生まれました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のように言うことができます：「しかし、動的言語はそのように機能せず、ハッシュテーブルを使用してすべてを実装するだけです！」</font><font style="vertical-align: inherit;">ハッシュテーブルは、型情報を含む編集可能なテーブルを作成するための優れたデータ構造です。</font><font style="vertical-align: inherit;">さらに、CPythonなどの一部のインタープリターはこのように動作します。</font><font style="vertical-align: inherit;">高性能JIT、たとえばV8 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には、多くの仮想型テーブルと</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リフレクション情報があります。</font><font style="vertical-align: inherit;">V8では、非表示のクラス（vtablesとリフレクション情報）とオブジェクトの構造はJava VMで表示されるものと似ており、実行時にオブジェクトを新しい仮想型テーブルに置き換えることができます。</font><font style="vertical-align: inherit;">偶然がないため、これは偶然ではありません。V8の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作成者は、</font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高性能Java VMで作業していた</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">辞書転送</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
動的インターフェイスを実装するもう1つの方法は、必要な関数ポインターを含むテーブルを、それらを必要とするジェネリック関数に転送することです。</font><font style="vertical-align: inherit;">これは、呼び出しの場所でGo型のインターフェイスオブジェクトを作成するのと多少似ていますが、この場合のみ、テーブルは非表示の引数として渡され、既存の引数の1つとしてバンドルにパックされません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haskellの型クラスで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用され</font><font style="vertical-align: inherit;">ますが、GHCではインライン化と特殊化を使用して、ある種のモノモーフィゼーションを実行できます。</font><font style="vertical-align: inherit;">OCamlは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ファーストクラスモジュールの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形式</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">で</font></a><font style="vertical-align: inherit;">明示的な引数を持つディクショナリ転送を使用し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">が</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、パラメーターを暗黙的にする機能を追加する</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことがすでに提案されてい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swiftのウィットネステーブル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Swiftの作成者は興味深いソリューションを適用しました：辞書を転送し、データをタイプサイズに移動し、それらをテーブルに移動、コピー、および解放する方法を提供することで、あらゆるタイプの統合作業に必要なすべての情報を、それらをパックすることなく提供できます。したがって、Swiftは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのエンティティの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">統一された表現で、モノモーフィングやメモリへの配置なしで</font></a><font style="vertical-align: inherit;">ジェネリック</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">を</font></a><font style="vertical-align: inherit;">実装できます</font><font style="vertical-align: inherit;">。はい、パッケージングを使用するファミリ全体の特徴である動的検索の料金を支払う必要がありますが、メモリの配置、その消費、およびキャッシュの不整合のためのリソースは節約されます。 Swiftコンパイラーは</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、@ inlinableと注釈された</font></a><font style="vertical-align: inherit;">関数を使用することもでき</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上記のコストを回避するために、モジュール内またはモジュール間で特殊化（モノモルフィズ）およびインラインジェネリック </font><font style="vertical-align: inherit;">おそらく、コードサイズへの影響のヒューリスティックな評価が使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、Swiftが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ABIの安定性</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">実装</font></a><font style="vertical-align: inherit;">する方法を説明</font><font style="vertical-align: inherit;">し、構造にフィールドを追加および再配布できるようにします。ただし、作成者は、</font></font><code>@frozen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンスを向上させるために動的検索を拒否する</font><font style="vertical-align: inherit;">属性</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">提供します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内包型分析</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パッケージ型のインターフェースを実装する別の方法があります。 vtableへのポインターの例に従って、オブジェクトの特定の部分に型識別子を追加し、次に</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、このメソッドを実装するすべての型の</font><font style="vertical-align: inherit;">大きな式</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">持つ各インターフェイスメソッドの関数を生成</font><font style="vertical-align: inherit;">し、その型に固有の正しいメソッドに渡します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチを使用する言語の使用については警告しませんが、C ++コンパイラとJava仮想マシンは同様に機能します。プロファイルに基づく最適化を使用すると、ジェネリックを呼び出す特定の場所が特定のタイプのオブジェクトでほとんど機能することがわかります。</font><font style="vertical-align: inherit;">コンパイラーとVMは、呼び出し場所を通常のタイプごとのチェックに置き換え、通常の動的ディスパッチを使用して、これらのタイプをフォールバックとして静的にディスパッチします。</font><font style="vertical-align: inherit;">したがって、分岐予測アルゴリズムは、コードが進む分岐を予測し、静的呼び出しを使用して命令をディスパッチし続けることができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単形化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはパッケージ化の代替手段です。</font><font style="vertical-align: inherit;">モノモーフィゼーションでは、使用するタイプごとにコードの複数のバージョンを生成する方法を見つける必要があります。</font><font style="vertical-align: inherit;">コンパイラーには、コードが通過するいくつかのプレゼンテーション段階があり、理論的にはこれらの段階のいずれかにコピーできます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコード生成</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モノモーフィングする最も簡単な方法は、最初のプレゼンテーション段階でコピーすることです。ソースコードをコピーします。</font><font style="vertical-align: inherit;">その場合、コンパイラーはジェネリックをサポートする必要さえありません。これは、CやGo言語のユーザーによって行われることがあります。そのコンパイラーでは、そのようなサポートはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cでは、プリプロセッサを使用して、異なる構造で繰り返し挿入することにより、マクロまたはヘッダーでデータ構造を定義できます</font></font><code>#define</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Goには</font><font style="vertical-align: inherit;">、コード生成を容易にする</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gennyの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ようなスクリプト</font><font style="vertical-align: inherit;">があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソースコードを複製することの短所は、言語によっては、多くの問題やエッジケースに対処する必要があり、さらに、コンパイラーが事実上同じコードの型を何度も解析してチェックすることです。</font><font style="vertical-align: inherit;">繰り返しになりますが、言語とツールによっては、これらのメソッドのジェネリックを記述して使用するのが難しい場合があります。Cマクロ内では、各行がバックスラッシュで終わり、衝突を避けるために関数のすべてのタイプと名前を手動で識別子に接着する必要があるかのようです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dの文字列ミックスイン</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、コード生成には、本格的なプログラミング言語を使用してコードを生成できるだけでなく、ユーザーが使い慣れたビューを使用できるなどの利点があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネリックが異なる方法で実装されている一部の言語では、シリアル化など、ジェネリックシステムでは考慮されていないより一般的なメタプログラミングの場合にコードを生成することもできます。</font><font style="vertical-align: inherit;">最も理解しやすい例は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dの文字列ミックスイン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。これにより、言語のすべての機能を使用して、コンパイルの途中で文字列値の形式でDコードをコンパイルできます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">錆びた手続きマクロ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様の例で、コンパイラーでの表現は1ステージのみです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rust手続き型マクロ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はトークンストリームを入力および出力として使用し、これらのストリームを文字列に、またはその逆に変換するユーティリティを提供します。このアプローチの利点は、トークンストリームがソースコードからの位置情報を格納できることです。ユーザーが記述したコードであるマクロは、入力から週末に直接トークンとして挿入できます。そして、このコードがmacosの出力でコンパイルエラーを引き起こす場合、コンパイラーはメッセージを表示し、コードの壊れた部分のファイル、行、および列を正確に指し示します。ただし、マクロが壊れたコードを生成する場合、エラーメッセージはマクロ呼び出しを示します。たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マクロがロギング呼び出しで関数をラップし、ラップされた関数</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の実装に誤りがある場合、エラーメッセージは、マクロによって生成されたコードではなく、ファイル内のエラーを直接指します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構文ツリーマクロ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部の言語はさらに進んで、マクロでさまざまなタイプの抽象構文ツリー（抽象構文ツリー、AST）を使用および作成するためのツールを提供します。例としては、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テンプレートHaskell</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nimマクロ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OCaml PPX、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">およびほとんどすべての</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lispがあり</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ASTマクロの欠点は、基本的な言語だけでなく、ASTタイプを構築するための一連の関数をユーザーに学習させたくないということです。 Lispファミリの言語では、これはASTの構文と構造の間の強力な単純化と最大の対応の助けを借りて解決されますが、構造の作成は必ずしも容易ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、私が言及したすべての言語では、言語でコードの一部を与える方法が1つまたは別のプリミティブな「引用」があり、構文ツリーを返します。これらのプリミティブは、文字列補間の類似性を使用して構文ツリーの値をマージできます。テンプレートHaskellの例を以下に示します。</font></font><br>
<br>
<pre><code class="haskell hljs"><span class="hljs-comment">-- using AST construction functions</span>
<span class="hljs-title">genFn</span> :: <span class="hljs-type">Name</span> -&gt; <span class="hljs-type">Q</span> <span class="hljs-type">Exp</span>
<span class="hljs-title">genFn</span> f = <span class="hljs-keyword">do</span>
  x &lt;- newName <span class="hljs-string">"x"</span><font></font>
  lamE [varP x] (appE (varE f) (varE x))<font></font>
<font></font>
<span class="hljs-comment">-- using quotation with $() for splicing</span>
<span class="hljs-title">genFn'</span> :: <span class="hljs-type">Name</span> -&gt; <span class="hljs-type">Q</span> <span class="hljs-type">Exp</span>
<span class="hljs-title">genFn'</span> f = [| \x -&gt; $(varE f) x |]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トークンのレベルではなく、構文ツリーのレベルで手続き型マクロを作成することの1つの欠点は、新しい言語プロパティが追加されると、構文ツリーのタイプがしばしば変更されることです。</font><font style="vertical-align: inherit;">そして、トークンのタイプは互換性を保つかもしれません。</font><font style="vertical-align: inherit;">たとえば、OCamlのPPXシステムには</font><font style="vertical-align: inherit;">、マクロで使用される言語バージョンとの間で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構文解析ツリー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">移行するための特別なインフラストラクチャ</font></a><font style="vertical-align: inherit;">が必要</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">Rustには、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構文解析</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーティリティ</font><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引用</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーティリティを追加するライブラリがある</font><font style="vertical-align: inherit;">ため、構文ツリー構文マクロと同じスタイルで手続き型マクロを記述できます。</font><font style="vertical-align: inherit;">また、Rustには、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リフレクションによって提供されるインターフェースを複製しようと</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">実験的なライブラリ</font></a><font style="vertical-align: inherit;">もあり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターン</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のタイプのジェネリックスは、コンパイラでコードを生成するプロセスを少し発展させたものです。 C ++およびDのテンプレートは、型と関数の「テンプレートパラメータ」を指定できる汎用の実装です。また、特定のタイプのテンプレートのインスタンスを作成すると、このタイプが関数に代入され、関数はタイプチェックに合格します。つまり、組み合わせが有効であることを確認できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; <span class="hljs-title">T</span> <span class="hljs-title">myMax</span>(<span class="hljs-title">T</span> <span class="hljs-title">a</span>, <span class="hljs-title">T</span> <span class="hljs-title">b</span>) {</span>
  <span class="hljs-keyword">return</span> (a&gt;b?a:b);<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; <span class="hljs-title">struct</span> <span class="hljs-title">Pair</span> {</span>
  T values[<span class="hljs-number">2</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<font></font>
  myMax(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<font></font>
  Pair&lt;<span class="hljs-keyword">int</span>&gt; p { {<span class="hljs-number">5</span>,<span class="hljs-number">6</span>} };
  <span class="hljs-comment">// This would give us a compile error inside myMax</span>
  <span class="hljs-comment">// about Pair being an invalid operand to `&gt;`:</span>
  <span class="hljs-comment">// myMax(p, p);</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テンプレートシステムの問題の1つは、テンプレート関数をライブラリに追加し、ユーザーが間違ったタイプのインスタンスを作成した場合、ライブラリで不可解なコンパイルエラーが発生する可能性があることです。これは、ユーザーが間違った型を渡したときに動的に型付けされた言語のライブラリで発生する可能性のあることとよく似ています。では</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、補助関数によって使用されるタイプの妥当性を検証し、彼らは下失敗した場合にエラーメッセージがこれを明確に示していますと同様のこの問題に対する興味深いソリューションは、動的言語で人気のライブラリを作っています。 Dの例を次に示します。</font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">署名のより便利な構文に</font><font style="vertical-align: inherit;">注意して</font><font style="vertical-align: inherit;">ください（</font></font><code>!</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テンプレートパラメータを提供するために使用されます）：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// We're going to use the isNumeric function in std.traits</span>
<span class="hljs-keyword">import</span> <span class="hljs-built_in">std</span>.traits;<font></font>
<font></font>
<span class="hljs-comment">// The `if` is optional (without it you'll get an error inside like C++)</span>
<span class="hljs-comment">// The `if` is also included in docs and participates in overloading!</span>
<span class="hljs-function">T <span class="hljs-title">myMax</span><span class="hljs-params">(T)</span><span class="hljs-params">(T a, T b)</span> <span class="hljs-title">if</span><span class="hljs-params">(isNumeric!T)</span> </span>{
    <span class="hljs-keyword">return</span> (a&gt;b?a:b);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">struct <span class="hljs-title">Pair</span><span class="hljs-params">(T)</span> </span>{<font></font>
  T[<span class="hljs-number">2</span>] values;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<font></font>
  myMax(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<font></font>
  Pair!<span class="hljs-keyword">int</span> p = {[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]};
  <span class="hljs-comment">// This would give a compile error saying that `(Pair!int, Pair!int)`</span>
  <span class="hljs-comment">// doesn't match the available instance `myMax(T a, T b) if(isNumeric!T)`:</span>
  <span class="hljs-comment">// myMax(p, p);</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 20には、「概念」である</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数のインターフェースと制限の種類の定義のように、同じ目的のために使用されているが、そのアーキテクチャのルックス。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイルステップ関数</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dのテンプレートには、コンパイル時に関数評価（コンパイル時関数評価）を使用できるようにする拡張機能がいくつかあります。</font></font><code>static if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際、テンプレートは、コンパイル段階でパラメーターのセットを受け取り、非汎用ランタイム関数を返す関数として機能します。</font><font style="vertical-align: inherit;">これにより、テンプレートはすべての機能を備えたメタプログラミングシステムに変わります。私が理解しているように、C ++の最新のテンプレートは同じ機能を備えていますが、メカニズムは明確ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「コンパイル段階の関数としてのジェネリック」の概念をさらに発展させる言語があります。</font><font style="vertical-align: inherit;">たとえば、ジグ：</font></font><br>
<br>
<pre><code class="plaintext hljs">fn Stack(comptime T: type) type {<font></font>
    return struct {<font></font>
        items: []T,<font></font>
        len: usize,<font></font>
<font></font>
        const Self = @This();<font></font>
        pub fn push(self: Self, item: T) {<font></font>
            // ...<font></font>
        }<font></font>
    };<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zigは、コンパイルおよび実行時に同じ言語を使用し、マークされたパラメーターに基づいて関数を分離します</font></font><code>comptime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">メタレベル</font><font style="vertical-align: inherit;">での</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terra</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の言語で</font><font style="vertical-align: inherit;">は、別個の、しかし類似した言語。 TerraはLuaの方言です。ここでは、低レベルのC字型の関数のインラインを作成し、Lua APIを使用してそれらをメタレベルで操作したり、引用符やスプライシングプリミティブを操作したりできます。</font></font><br>
<br>
<pre><code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MakeStack</span><span class="hljs-params">(T)</span></span>
    <span class="hljs-keyword">local</span> struct Stack {<font></font>
        items : &amp;T; <span class="hljs-comment">-- &amp;T is a pointer to T</span>
        <span class="hljs-built_in">len</span> : int;<font></font>
    }<font></font>
    terra Stack:push(item : T)<font></font>
        <span class="hljs-comment">-- ...</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> Stack
<span class="hljs-keyword">end</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terraの異常なレベルのメタプログラミングにより</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ドメイン固有の言語向けの最適化コンパイラーを単純な関数として</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装したり、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェースとオブジェクトシステム</font><font style="vertical-align: inherit;">を少量のコードでライブラリーに</font><font style="vertical-align: inherit;">実装したりでき</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">そしてTerraでは、実行時に生成されたコードを、依存関係を含まないオブジェクトファイルとして保存できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rustのジェネリック</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のタイプのモノモーフィングされたジェネリックスは、型チェックの後、コンパイラコードの生成をさらに進めます。 C ++で発生する可能性があるライブラリ内エラーのタイプは、動的に型付けされた言語のエラーに似ていると述べました。これは、テンプレートパラメータには、動的言語のように、実際には1つの型タイプしかないという事実の結果です。したがって、メタレベルに型システムを追加し、静的チェックを使用して多くの型の型を適用して、使用する操作をサポートすることで、問題を解決できます。これは、Rustでジェネリックが機能する方法であり、SwiftとHaskellの言語レベルでも機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rustでは、型パラメーターは「特性の境界」として宣言する必要があります。</font></font><code>Trait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-他の言語のインターフェースのようであり、タイプによって提供される一連の機能を宣言します。 Rustコンパイラーは、総称関数の本体が属性の境界と一致する任意の型で機能するかどうかをチェックし、これらの境界内で宣言されていない型の機能を使用できないようにします。したがって、Rustのジェネリック関数のユーザーは、</font><font style="vertical-align: inherit;">ライブラリ関数をインスタンス化するときにコンパイルエラーを受け取る</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことはありませ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ん。さらに、コンパイラーは、ジェネリック関数ごとに1回だけ型チェックを実行する必要があります。</font></font><br>
<br>
<pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">my_max</span></span>&lt;T: <span class="hljs-built_in">PartialOrd</span>&gt;(a: T, b: T) -&gt; T {
    <span class="hljs-keyword">if</span> a &gt; b { a } <span class="hljs-keyword">else</span> { b }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pair</span></span>&lt;T&gt; {<font></font>
    values: [T; <span class="hljs-number">2</span>],<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {<font></font>
    my_max(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);
    <span class="hljs-keyword">let</span> p: Pair&lt;<span class="hljs-built_in">i32</span>&gt; = Pair { values: [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>] };
    <span class="hljs-comment">// Would give a compile error saying that</span>
    <span class="hljs-comment">// PartialOrd is not implemented for Pair&lt;i32&gt;:</span>
    <span class="hljs-comment">// my_max(p,p);</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語レベルでは、これは、ジェネリックパッケージを使用してインターフェイスをサポートするジェネリックを実装するために必要な型システムの種類と非常に似ています。</font><font style="vertical-align: inherit;">したがって、Rustは同じシステム内で両方のオプションをサポートします。</font><font style="vertical-align: inherit;">Rust 2018では、パラメーター</font></font><code>v: &amp;impl SomeTrait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がモノモーフィングされ、パラメーター</font></font><code>v: &amp;dyn SomeTrait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がパッケージ</font><font style="vertical-align: inherit;">化を</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">する統合構文も導入されました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このプロパティにより、SwiftやHaskellのGHCなどのコンパイラーは、デフォルトでパッケージ化を使用していても、最適化としてモノモーフィゼーションを使用できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機械コードの単形化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モノモーフィングされたジェネリックスのモデルにおける次の論理的なステップは、それらをコンパイラーでバックエンドのさらに後のステージに転送することです。</font><font style="vertical-align: inherit;">ジェネリック型のプレースホルダーで注釈が付けられたソースコードテンプレートをコピーするときに、特定の型の部分のスタブを持つマシンコードを生成することもできます。</font><font style="vertical-align: inherit;">そして、これらのパターンを非常にすばやくスタンプできます</font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンカーのようないくつかのパッチ！</font><font style="vertical-align: inherit;">短所は、モノモーフィングされたコピーを個別に最適化できないことです。</font><font style="vertical-align: inherit;">ただし、最適化が重複していないため、コンパイルははるかに速くなります。</font><font style="vertical-align: inherit;">コードジェネレーターを小さなJITに変換することもできます。これはバイナリーに挿入され、実行中にファイルのサイズが大きくならないようにモノモーフィングされたコピーを生成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、このように機能する単一の言語はわかりません。それは、このタクソノミーの自然な延長として、記事の執筆中に思いついたアイデアにすぎません。この演習のおかげで期待していました！</font><font style="vertical-align: inherit;">この記事を読んで、さまざまな言語の汎用システムと、それらが単一の分類法にどのように適合するかを明確に説明してください。</font><font style="vertical-align: inherit;">また、このテキストが、アイデアの空間の枠組みの中で、新しいクールなプログラミング言語を見つけることができる方向について考えるように促してくれることを願っています。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja461307/index.html">VKハッカソン2019にご招待します。今年の賞金プールは200万ルーブルです。</a></li>
<li><a href="../ja461309/index.html">Kotlinを除くすべて：Andrei BreslavがIT、感情などの性別バランスについて</a></li>
<li><a href="../ja461313/index.html">Zimbra 8.8.15 LTSがリリースされました</a></li>
<li><a href="../ja461317/index.html">高品質のiOSアプリケーションを作成するための9つの原則</a></li>
<li><a href="../ja461319/index.html">ゲームデザイナーは何をしますか？</a></li>
<li><a href="../ja461323/index.html">波動関数崩壊アルゴリズムの手頃な説明</a></li>
<li><a href="../ja461325/index.html">PHDays 9での勝利。3つのパートでライフハックを共有します。パート3</a></li>
<li><a href="../ja461327/index.html">フロントエンドの危機？</a></li>
<li><a href="../ja461333/index.html">ITX5 mitap：ライブJAVA、Kotlinマジック、トマトティンダー</a></li>
<li><a href="../ja461339/index.html">データ駆動型にする方法。最初から</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>