<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👩🏼 ⚗️ 👤 Flutter. BlOC, provedor, assíncrono - arquitetura de prateleira 🧜 💪🏻 👩🏻‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introdução
 Quando você tenta escrever um aplicativo, a primeira coisa que você encontra é como organizar a arquitetura do aplicativo. E quando se tra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Flutter. BlOC, provedor, assíncrono - arquitetura de prateleira</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489512/"><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introdução</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando você tenta escrever um aplicativo, a primeira coisa que você encontra é como organizar a arquitetura do aplicativo. </font><font style="vertical-align: inherit;">E quando se trata de Flutter, a cabeça pode dar uma olhada completa no que o Google fornece - Vanilla, Scoped Model, BLoC, MVP, MVC, MVVM, MVI, etc. </font><font style="vertical-align: inherit;">Suponha que você decida seguir da maneira mais elegante (a que o Google aconselhou em 2018) e usar o BLOC. </font><font style="vertical-align: inherit;">O que é isso? </font><font style="vertical-align: inherit;">Como usá-lo? </font><font style="vertical-align: inherit;">Ou talvez Redux ou RxDart? </font><font style="vertical-align: inherit;">- embora a parada seja sobre o "outro" ... Mas ainda assim, o que vem a seguir? </font><font style="vertical-align: inherit;">Quais bibliotecas conectar? </font><font style="vertical-align: inherit;">Bloc, Flutter_bloc, bloc_pattern, etc.? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse número de opções e ferramentas de arquitetura para sua implementação pode realmente atrasar o estágio de seleção por um longo tempo.</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para quem o artigo</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O artigo será útil principalmente para aqueles que estão começando a aprender o Flutter e não sabem por onde começar. </font><font style="vertical-align: inherit;">Vou mostrar uma das opções para implementar o aplicativo no Flutter. </font><font style="vertical-align: inherit;">Isso permitirá que você "sinta" o Flutter e, em seguida, decida por si mesmo como e com o qual você escreverá seus aplicativos.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Padrões e ferramentas. </font><font style="vertical-align: inherit;">Breve e simples</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então, vamos começar. A primeira coisa que vale a pena notar é que existe uma arquitetura de aplicativo (padrão, modelo, algum conceito de construção) - é exatamente o mesmo: BLoC, MVP, MVC, MVC, MVVM, MVI etc. Muitas dessas arquiteturas são usadas não apenas no Flutter, mas também em outras linguagens de programação. Pergunta - o que escolher? Na minha opinião, você precisa escolher o que conhece bem, mas apenas se isso implicar reatividade e uma separação estrita da lógica de negócios da interface (sim, sim - “um carro pode ter qualquer cor se for preto”). Quanto à separação entre interface e lógica de negócios, acho que não há necessidade de explicar, mas quanto à reatividade - tente, se você ainda não experimentou - no final, é realmente muito conveniente e "bonito". Se você não pode escolher, deixe-nos permitir que não seja o mais estúpido do Google - BLOC. Nós descobrimos a arquitetura.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora as ferramentas - existem bibliotecas prontas - Bloc, Flutter_bloc, bloc_pattern - qual é melhor? Eu não sei - todo mundo é bom. Você pode escolher e comparar por um longo tempo, mas aqui novamente, como no exército - é melhor tomar uma decisão errada por enquanto do que não tomar nenhuma. E, por enquanto, sugiro voltar na sequência do mod e usar o Provider (o que os mesmos caras recomendam usar em 2019).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo isso nos permitirá criar um bloco global e um bloco local, conforme necessário. </font><font style="vertical-align: inherit;">Muito foi escrito sobre a arquitetura do BLoC (ou seja, um padrão, não bibliotecas), acho que você não deve insistir nela novamente em detalhes. </font><font style="vertical-align: inherit;">Observo apenas um ponto neste artigo: não será utilizado o BLoC clássico, mas ligeiramente modificado - as ações (eventos) do BLoC não serão transmitidas por meio de Sinks, mas as funções do BLoC serão chamadas. </font><font style="vertical-align: inherit;">Simplesmente, no momento, não vejo os benefícios de usar Pias - e como elas não estão lá, por que complicar sua vida?</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assincronia e computação paralela no Dart</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Também vale a pena esclarecer um pouco o conceito de assincronia em Dart, já que estamos falando de reatividade. Muitas vezes, nos primeiros estágios do conhecimento de Dart, o significado de funções assíncronas (assíncronas) não é entendido corretamente. Você deve sempre lembrar que “por padrão” o programa é executado em um thread, e a assincronia apenas permite alterar a sequência de comandos, em vez de executá-los em paralelo. Ou seja, se você simplesmente executar a função com grandes cálculos apenas marcando-a como assíncrona, a interface será bloqueada. O Async NÃO inicia um novo thread. Como assíncrono e aguardam o trabalho, há muitas informações na Internet, então também não vou me debruçar sobre isso.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você precisar fazer alguns cálculos grandes e, ao mesmo tempo, não bloquear a interface, precisará usar a função de computação (para hardcore especial, você pode usar isolados). </font><font style="vertical-align: inherit;">Isso realmente iniciará um thread de execução separado, que também terá sua própria área de memória separada (que é muito triste e triste). </font><font style="vertical-align: inherit;">Você pode se comunicar com esses fluxos apenas através de mensagens que podem conter tipos de dados simples, suas listas.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos começar a praticar</font></font></h1><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formulação do problema</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos tentar escrever a aplicação mais simples - seja algum tipo de lista telefônica. </font><font style="vertical-align: inherit;">Usaremos o Firebase como armazenamento - isso nos permitirá criar um aplicativo "em nuvem". </font><font style="vertical-align: inherit;">Vou pular como conectar o Firebase ao projeto (mais de um artigo foi escrito sobre esse tópico e não vejo o sentido de repetir. Observação: o Cloud Firestore é usado neste projeto.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deve ser assim:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xy/yj/js/xyyjjsknqbe1owqlc1vnbnec-pu.gif"><br>
<br>
<h1> <br>
</h1><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descrição da aplicação</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nossa aplicação conterá externamente:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Janela de autorização do Firebase (a lógica desta janela estará contida no MainBloc).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Janela de informações - exibirá informações sobre o usuário sob o qual o programa está autorizado (a lógica desta janela também estará contida no MainBloc).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Janela Diretório na forma de uma lista de telefones (a lógica desta janela estará contida em um PhonebookBloc separado).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu do aplicativo que alternará as telas.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O aplicativo interno será construído da seguinte maneira: cada tela conterá um arquivo com widgets de tela, um arquivo de bloco (com a classe de bloco correspondente), um arquivo de ações (contém classes simples que descrevem eventos que afetam o estado do bloco), um arquivo de estados (contém classes simples que refletem o estado do bloco) ), o arquivo data_model que contém a classe do repositório (responsável pelo recebimento de dados) e a classe de dados (armazena dados da lógica de negócios do bloco).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O aplicativo funcionará assim - quando a tela é aberta, o bloco correspondente é inicializado com o valor do estado inicial e, se necessário, alguma ação inicial é chamada no construtor do bloco. </font><font style="vertical-align: inherit;">A tela é construída / reconstruída com base no estado, que retorna o bloco. </font><font style="vertical-align: inherit;">O usuário executa algumas ações no aplicativo que possuem ações correspondentes. </font><font style="vertical-align: inherit;">As ações são passadas para a classe de bloco, onde são processadas na função mapEventToState e o bloco retorna o novo estado de volta à tela, com base no qual a tela é reconstruída.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estrutura de arquivo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de tudo, criamos um projeto Flutter vazio e criamos a estrutura desse tipo (note que no projeto demo alguns arquivos permanecerão vazios):</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h8/r5/5j/h8r55j-7shyieywjwqkpkj-lwxi.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Janela de autorização. </font><font style="vertical-align: inherit;">Mainbloc</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora você precisa implementar a autorização no Firebase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos começar criando classes de eventos (é conveniente transferir dados através de eventos no bloco) e estados para o bloco principal: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
file MainBloc \ actions</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainBlocAction</span></span>{<font></font>
  String get password =&gt; <span class="hljs-keyword">null</span>;<font></font>
  String get email =&gt; <span class="hljs-keyword">null</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
arquivo MainBloc \ states</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainBlocState</span></span>{<font></font>
  bool busy;<font></font>
  MainBlocState({<span class="hljs-keyword">this</span>.busy = <span class="hljs-keyword">false</span>});<font></font>
  copy(bool busy) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O sinalizador de ocupado na classe state é usado para exibir progress_hud na interface e excluir leituras desnecessárias de dados do banco de dados ao rolar pela lista. </font><font style="vertical-align: inherit;">Antes do início de todas as operações no bloco, um novo estado do tipo antigo com o sinalizador de ocupado definido é emitido para o fluxo de saída - dessa forma, a interface recebe uma notificação de que a operação foi iniciada. </font><font style="vertical-align: inherit;">No final da operação, um novo estado é enviado ao fluxo com o sinalizador de ocupado limpo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os herdeiros da classe MainBlocState descrevem o estado do aplicativo principal Bloc. </font><font style="vertical-align: inherit;">Os herdeiros do MainBlocAction descrevem os eventos que ocorrem nele.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A classe MainBloc contém 4 elementos principais - a função de "converter" eventos em estados (Future mapEventToState), o estado do Bloc é _blocState, o repositório do estado do bloco é o repositório e o fluxo de estado "output" (que os elementos da interface controlam) é blocStream. Basicamente, esses são todos os elementos que fornecem a funcionalidade de bloco a. Às vezes, é aconselhável usar 2 fluxos de saída em um bloco - esse exemplo será menor. Não vou listá-lo aqui - você pode vê-lo baixando o projeto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A classe de repositório de blocos contém a lógica para trabalhar com o Firebase e um objeto (dados) que armazena os dados necessários para a lógica de negócios implementada por este bloco. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arquivo MainBloc \ data_model</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainRepo</span></span>{<font></font>
<font></font>
  <span class="hljs-keyword">final</span> MainData data = MainData();<font></font>
<font></font>
  FirebaseAuth get firebaseInst =&gt; MainData.firebaseInst;<font></font>
<font></font>
  FirebaseUser _currentUser;<font></font>
<font></font>
  <span class="hljs-function">Future&lt;bool&gt; <span class="hljs-title">createUserWithEmailAndPassword</span><span class="hljs-params">(
      String email, String password)</span> async </span>{
    <span class="hljs-keyword">var</span> dataUser;
      <span class="hljs-keyword">try</span> {<font></font>
        dataUser =<font></font>
            (await firebaseInst.createUserWithEmailAndPassword(<font></font>
                email: email, password: password))<font></font>
                .user;<font></font>
      } <span class="hljs-keyword">catch</span> (e) {<font></font>
        print(Error.safeToString(e));<font></font>
        print(e.code);<font></font>
        print(e.message);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span> (dataUser == <span class="hljs-keyword">null</span>){<font></font>
        data.setState(IsNotLogged());<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<font></font>
      }<font></font>
<font></font>
      _currentUser = dataUser;<font></font>
      data.setState(IsLogged(),<font></font>
          uid: _currentUser.uid,<font></font>
          email: _currentUser.email);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<font></font>
  }<font></font>
<font></font>
  ...}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainData</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> firebaseInst = FirebaseAuth.instance;
  <span class="hljs-keyword">static</span> MainBlocState _authState = IsNotLogged();
  <span class="hljs-keyword">static</span> MainBlocState get authState =&gt; _authState;
  <span class="hljs-keyword">static</span> String _uid;
  <span class="hljs-keyword">static</span> String get uid =&gt; _uid;
  <span class="hljs-keyword">static</span> String _email;
  <span class="hljs-keyword">static</span> String get email =&gt; _email;<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(MainBlocState newState,
      {String uid = <span class="hljs-string">''</span>, String email = <span class="hljs-string">''</span>})</span> </span>{<font></font>
    _authState = newState;<font></font>
    _uid = uid;<font></font>
    _email = email;<font></font>
  }<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A classe MainData também armazena o estado, mas o estado de autorização no Firebase, e não o estado do Bloc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Escrevemos a lógica do bloco principal, agora podemos começar a implementar a tela de autorização / registro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MainBloc é inicializado no arquivo principal: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O arquivo principal</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-comment">// This widget is the root of your application.</span>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">return</span> Provider(<font></font>
        create: (context) =&gt; MainBloc(),<font></font>
        dispose: (context, value) =&gt; value.dispose(),<font></font>
        child: MaterialApp(<font></font>
          routes: menuRoutes,<font></font>
        ));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É hora de fazer uma pequena digressão sobre o StreamBuilder, Provider, StreamProvider, Consumer e Selector.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retiro sobre fornecedores</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fornecedor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - apenas transfere o valor armazenado para baixo da árvore. E você pode acessá-lo somente após a criação da criança, ou seja, você precisa construir um sub widget. Não nos responsabilizamos pela atualização de widgets. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamBuilder</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - um widget que monitora o fluxo e é completamente reconstruído quando </font><b><font style="vertical-align: inherit;">recebe um</font></b><font style="vertical-align: inherit;"> novo objeto do fluxo. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamProvider</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - um widget que monitora o fluxo e, quando um novo objeto é recebido, sinaliza que os widgets filhos (aqueles que são declarados como uma classe separada com o método de compilação) devem ser reconstruídos. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consumidor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seletor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> são "açúcar sintático", ou seja, este é realmente um "invólucro" que contém a construção e oculta o widget abaixo. No Seletor-e, você pode fazer uma filtragem adicional de atualizações.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, quando você precisar reconstruir a maior parte da tela em cada evento, poderá usar a opção com Provider e StreamBuilder. </font><font style="vertical-align: inherit;">Quando é necessário reconstruir partes da árvore de widgets próximas às folhas, é recomendável usar o StreamProvider em combinação com Consumer e Selector para excluir reconstruções desnecessárias da árvore.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autorização </font><font style="vertical-align: inherit;">Continuação</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao entrar no aplicativo, o usuário deve acessar a janela de autorização / registro e, nesse momento, o menu do aplicativo ainda não deve estar disponível. O segundo ponto - atualizar parcialmente essa tela não faz muito sentido; portanto, podemos usar o StreamBuilder para criar a interface. E o terceiro ponto do projeto é usar o Navegador para navegar entre as telas. Após o recebimento de um evento de autorização bem-sucedida, é necessário chamar a transição para a tela de informações. Mas apenas dentro da construção do StreamBuilder, isso não funcionará - haverá um erro. Para contornar isso, você pode usar a classe auxiliar wrapper StreamBuilderWithListener (Eugene Brusov - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stackoverflow.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora a listagem dessa tela é o próprio auth_screen (darei aqui em parte): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arquivo auth_screen</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
  <span class="hljs-keyword">var</span> bloc = Provider.of&lt;MainBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
  <span class="hljs-keyword">return</span> StreamBuilderWithListener&lt;MainBlocState&gt;(<font></font>
      stream: bloc.blocStream.stream,<font></font>
      listener: (value) {<font></font>
        <span class="hljs-comment">//not allowed call navigator push in build</span>
        <span class="hljs-keyword">if</span> (value is IsLogged) {<font></font>
          Navigator.of(context).pushReplacementNamed(InfoScreen.nameMenuItem);<font></font>
        }<font></font>
      },<font></font>
      initialData: bloc.state,<font></font>
      builder: (context, snappShot) {<font></font>
        <span class="hljs-keyword">if</span> (snappShot.data is IsLoggedOnStart) {
          <span class="hljs-keyword">return</span> LoggedWidget();<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (snappShot.data is IsLogged) {
          <span class="hljs-comment">//not allowed call navigator push in build</span>
          <span class="hljs-keyword">return</span> ModalProgressHUD(<font></font>
              inAsyncCall: <span class="hljs-keyword">true</span>,<font></font>
          child: Text(<span class="hljs-string">''</span>),);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (snappShot.data is IsNotLogged) {
          <span class="hljs-keyword">return</span> SignInAndSignUpWidget();<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> Scaffold(body: Text(<span class="hljs-string">"                Unknown event"</span>));<font></font>
      });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, um StreamBuilderWithListener é criado para ouvir o fluxo do bloco. </font><font style="vertical-align: inherit;">E com base no estado atual, é chamado o widget LoggedWidget (se o usuário já estiver autorizado) ou SignInAndSignUpWidget (se o usuário ainda não estiver autorizado). </font><font style="vertical-align: inherit;">Se o bloco retornar o estado IsLogged, a mudança para uma nova tela usando o Navigator não ocorrerá no construtor (o que levaria a um erro), mas no ouvinte. </font><font style="vertical-align: inherit;">Nos widgets subjacentes, a interface é construída com base nos dados retornados aqui. </font><font style="vertical-align: inherit;">Aqui, o pacote Provider + StreamBuilder é realmente usado, porque </font><font style="vertical-align: inherit;">quando o estado do bloco muda, praticamente toda a interface muda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para transferir dados para o bloco, TextEditingController e parâmetros de ação são usados: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
arquivo auth_screen</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SignUpWidgetWidgetState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span> </span>{<font></font>
  String _email, _password;<font></font>
<font></font>
  <span class="hljs-keyword">final</span> TextEditingController _emailController = TextEditingController();
  <span class="hljs-keyword">final</span> TextEditingController _passwordController = TextEditingController();<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.initState();<font></font>
    _emailController.addListener(_onEmailChanged);<font></font>
    _passwordController.addListener(_onPasswordChanged);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">return</span> Column(<font></font>
      children: &lt;Widget&gt;[<font></font>
        TextFormField(<font></font>
          controller: _emailController,<font></font>
          decoration: InputDecoration(<font></font>
              labelText: <span class="hljs-string">'email'</span>),<font></font>
        ),<font></font>
        TextFormField(<font></font>
          controller: _passwordController,<font></font>
          obscureText: <span class="hljs-keyword">true</span>,<font></font>
          decoration: InputDecoration(<font></font>
              labelText: <span class="hljs-string">'password'</span>),<font></font>
        ),<font></font>
        RaisedButton(<font></font>
            child: Text(<span class="hljs-string">'sign up'</span>),<font></font>
            onPressed: () {<font></font>
              Provider.of&lt;MainBloc&gt;(context, listen: <span class="hljs-keyword">false</span>).mapEventToState(<font></font>
                  Registration(_email, _password));<font></font>
            })<font></font>
      ],<font></font>
    );<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>{<font></font>
    _emailController.dispose();<font></font>
    _passwordController.dispose();<font></font>
    <span class="hljs-keyword">super</span>.dispose();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_onEmailChanged</span><span class="hljs-params">()</span> </span>{<font></font>
    _email = _emailController.text;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_onPasswordChanged</span><span class="hljs-params">()</span> </span>{<font></font>
    _password = _passwordController.text;<font></font>
  }<font></font>
}<font></font>
 <font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Janela da tela do telefone</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E agora vamos falar um pouco sobre a nossa janela PhoneBookScreen. Esta é a janela mais interessante - aqui a interface é construída com base em 2 fluxos do bloco, e também há uma lista com rolagem e paginação (paginação). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PhonebookScreen \ screen Arquivo</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhonebookTopPart</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{<font></font>
<font></font>
  <span class="hljs-function">StatefulWidget <span class="hljs-title">caseWidget</span><span class="hljs-params">(PhonebookState state)</span> </span>{
    <span class="hljs-keyword">if</span> (state is PhonebookListOpened) {
      <span class="hljs-keyword">return</span> PhonebookList();
    <span class="hljs-comment">//} else if (data is PhonebookCardToViewOpened) {</span>
    }<span class="hljs-keyword">else</span> ModalProgressHUD(<font></font>
      inAsyncCall: <span class="hljs-keyword">true</span>,<font></font>
      child: Text(<span class="hljs-string">''</span>),);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">var</span> bloc = Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">return</span> StreamProvider&lt;PhonebookState&gt;(<font></font>
        create: (context) =&gt; bloc.blocStream.stream,<font></font>
        initialData: bloc.state,<font></font>
        child: Selector&lt;PhonebookState,PhonebookState&gt;(<font></font>
            selector: (_,state)=&gt;state,<font></font>
            shouldRebuild: (previous, next){<span class="hljs-keyword">return</span> (previous.runtimeType!=next.runtimeType);},<font></font>
            builder: (_, state, __) { <span class="hljs-keyword">return</span> ModalProgressHUD(<font></font>
                inAsyncCall: state.busy,<font></font>
                child: Scaffold(<font></font>
                  appBar: AppBar(<font></font>
                    title: Text(<span class="hljs-string">"Phones list"</span>),<font></font>
                  ),<font></font>
                  drawer: MenuWidget(),<font></font>
                  body: caseWidget(state),<font></font>
                ));}<font></font>
        ));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O primeiro StreamProvider é necessário para alternar entre diferentes telas do diretório - lista, cartão de contato, cartão de contato para edição, etc. O widget da tela é selecionado na função caseWidget (mas neste exemplo apenas a visualização da lista é implementada - você pode tentar implementar a visualização do cartão de contato - isso é muito simples e não será um mau começo). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesta tela, um monte de StreamProvider + Selector / Consumer já está sendo usado, porque existe um pergaminho da lista e não é aconselhável reconstruir a tela inteira com ele (ou seja, a reconstrução de widgets vem do Seletor / Consumidor correspondente e mais abaixo na árvore). </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E aqui está a implementação da própria lista: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PhonebookScreen \ arquivo de tela</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_PhonebookListState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">PhonebookList</span>&gt; </span>{<font></font>
  ScrollController _scrollController = ScrollController();<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.initState();<font></font>
    _scrollController.addListener(_scrollListener);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">var</span> bloc = Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">var</span> list = bloc.repo.data.list;
    <span class="hljs-keyword">return</span> Container(<font></font>
        child: StreamProvider&lt;PhonebookState&gt;(<font></font>
            create: (context) =&gt; bloc.scrollStream.stream,<font></font>
            initialData: bloc.scrollState,<font></font>
            child: Consumer&lt;PhonebookState&gt;(<font></font>
              builder: (_, state, __) {<font></font>
                <span class="hljs-keyword">return</span> ListView.builder(<font></font>
                    controller: _scrollController,<font></font>
                    itemCount: list.length,<font></font>
                    itemBuilder: (BuildContext context, <span class="hljs-keyword">int</span> index) {
                      <span class="hljs-keyword">return</span> ListTile(<font></font>
                        title: Text(list[index].data[<span class="hljs-string">'name'</span>]),<font></font>
                        subtitle: Text(list[index].data[<span class="hljs-string">'phone'</span>]),<font></font>
                      );<font></font>
                    });<font></font>
              },<font></font>
            )));<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_scrollListener</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">double</span> delta = MediaQuery<font></font>
        .of(context)<font></font>
        .size<font></font>
        .height * <span class="hljs-number">3</span>;
    <span class="hljs-keyword">double</span> maxScroll = _scrollController.position.maxScrollExtent;
    <span class="hljs-keyword">double</span> currentScroll = _scrollController.position.pixels;
    <span class="hljs-keyword">if</span> (maxScroll - currentScroll &lt;= delta) {<font></font>
      Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>)<font></font>
          .mapEventToState(ScrollPhonebook());<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>{<font></font>
    _scrollController.removeListener(_scrollListener);<font></font>
    <span class="hljs-keyword">super</span>.dispose();<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui vemos o segundo StreamProvider, que monitora o segundo fluxo do bloco, responsável pela rolagem. A paginação é organizada como padrão via _scrollListener (controller: _scrollController). Embora a janela seja interessante, mas dada a descrição detalhada da primeira janela, não há mais nada a dizer aqui. Portanto, isso é tudo hoje.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O objetivo deste artigo não era mostrar o código perfeito, ou seja, aqui você pode encontrar muitos pontos para otimização - "dividir" corretamente em arquivos, usar instância, mixins e afins em algum lugar. </font><font style="vertical-align: inherit;">Além disso, o que "implora" o próximo passo - você pode fazer um cartão de contato. </font><font style="vertical-align: inherit;">A principal tarefa era estruturar o conhecimento, definir um determinado vetor para a construção da aplicação, dar explicações sobre alguns dos momentos de criação de uma aplicação no Flutter que não eram muito óbvios nos primeiros estágios do conhecimento. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O projeto pode ser baixado em</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (para registro, você pode usar qualquer correio com uma senha de pelo menos 6 caracteres. Ao autorizar novamente, a senha deve ser a mesma que a usada durante o registro).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt489496/index.html">Busca de funcionários e procura de emprego: minha visão de dentro e de fora</a></li>
<li><a href="../pt489500/index.html">Avaliação de tarefas em pontos da história</a></li>
<li><a href="../pt489502/index.html">Selênio + AutoIT. Automação de Teste do Windows</a></li>
<li><a href="../pt489504/index.html">Como começar a criar um mapa no UE4</a></li>
<li><a href="../pt489510/index.html">Tentando resolver o problema de escolher bilhetes antes das férias # 2</a></li>
<li><a href="../pt489514/index.html">Baixe e armazene arquivos de qualquer tamanho no Google Drive gratuitamente. Bug ou recurso?</a></li>
<li><a href="../pt489516/index.html">Amigos reagem nativo e Fastlane</a></li>
<li><a href="../pt489518/index.html">Troca de membros com troca de baixo custo aparece nos EUA</a></li>
<li><a href="../pt489528/index.html">Você não assiste anúncios durante o desenvolvimento? Transtorno</a></li>
<li><a href="../pt489530/index.html">O que torna um sistema reativo bom?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>