<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌓 💇🏾 〰️ Navigasi otonom dari robot seluler ↔️ 👨🏽‍🤝‍👨🏼 💃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada banyak cara di mana robot dapat menerima informasi dari dunia luar untuk berinteraksi dengannya. Juga, tergantung pada tugas yang diberikan kepada...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Navigasi otonom dari robot seluler</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/497302/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada banyak cara di mana robot dapat menerima informasi dari dunia luar untuk berinteraksi dengannya. </font><font style="vertical-align: inherit;">Juga, tergantung pada tugas yang diberikan kepadanya, metode pemrosesan informasi ini berbeda. </font><font style="vertical-align: inherit;">Dalam artikel ini saya akan menjelaskan tahapan utama pekerjaan yang dilakukan sebagai bagian dari proyek sekolah, yang tujuannya adalah untuk mensistematisasikan informasi tentang berbagai metode navigasi robot otonom dan menerapkan pengetahuan yang diperoleh dalam proses pembuatan robot untuk kompetisi "RTK Cup".</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/xw/dw/qbxwdwc_cwrypc3c8dthahudzmk.jpeg"><br>
<a name="habracut"></a><br>
<h2><font color="#4d7f95"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengantar</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di kompetisi "RTK Cup" ada satu blok tugas yang harus diselesaikan tanpa campur tangan operator. </font><font style="vertical-align: inherit;">Saya percaya bahwa banyak peserta yang secara tidak adil menghindari tugas-tugas ini, karena tampaknya kerumitan membuat desain robot dan menulis sebuah program menyembunyikan sebagian besar tugas yang disederhanakan dari disiplin ilmu kompetitif lainnya, digabungkan dalam satu tempat pelatihan. </font><font style="vertical-align: inherit;">Dengan proyek saya, saya ingin menunjukkan solusi yang mungkin untuk masalah seperti itu, dengan mempertimbangkan sebagai contoh berikut ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mencapai tujuan proyek, tugas perantara berikut dirumuskan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aturan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kompetisi "RTK Cup"</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisis algoritma yang ada untuk orientasi otonom robot seluler</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembuatan perangkat lunak</font></font></li>
</ul><br>
<h2><font color="#4d7f95"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisis aturan kompetisi "RTK Cup"</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada kompetisi "RTK Cup", peserta diberikan tempat pelatihan di mana bagian-bagian dengan berbagai kompleksitas dimodelkan. </font><font style="vertical-align: inherit;">Kompetisi ini bertujuan untuk merangsang robot muda untuk menciptakan perangkat yang dapat bekerja dalam kondisi ekstrem, mengatasi hambatan, di bawah kendali manusia, atau secara mandiri.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6a/sr/6w/6asr6wzvlhnqgkmz0b8dfyf2h9o.jpeg"><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">secara singkat tentang unsur-unsur yang membentuk poligon</font></font></b><div class="spoiler_text"> «»          ,    .    ,       ,     (), ,      (),   ..<br>
<br>
:<br>
<br>
<img src="https://habrastorage.org/webt/mk/ks/d3/mkksd313rprmlsilxcrq5xdytg4.png" width="300"><br>
<br>
:<br>
<br>
<img src="https://habrastorage.org/webt/rv/fp/cu/rvfpcu-6qtvdfrclsqjzlr2xok4.jpeg" width="300"><br>
<br>
  –  ,     «»  ( )  ,        . ,         ,    ,      ,         .<br>
<br>
     .    ,       ,     ,   ,     ,    ,    .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompetisi dibagi menjadi dua yang secara fundamental berbeda dari masing-masing nominasi lainnya: "Seeker" dan "Extreme". Ini untuk memastikan bahwa kompetisi diadakan antara peserta dengan perbedaan usia minimum dan pengalaman dalam mengembangkan sistem robot: Pencari untuk tingkat yang lebih muda, dan Ekstrim untuk peserta dari usia 14 tahun ke atas. Dalam nominasi "Pencari", operator dapat dengan bebas bergerak di sekitar tempat pelatihan dan melakukan kontak mata langsung dengan mesin, sedangkan nominasi "Ekstrim" mengasumsikan bahwa robot memiliki sistem komunikasi video dan / atau visi komputer, karena operator harus menavigasi dalam labirin, hanya mengandalkan labirin. kamera dan sensor dibangun ke dalam robot, sambil berada di belakang layar khusus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk lolos dalam kompetisi, robot harus melewati tugas untuk kendali jarak jauh dari manipulator, atau melakukan salah satu elemen otonomi. </font><font style="vertical-align: inherit;">Dalam kerangka proyek, tugas ditetapkan untuk memenuhi tugas otonomi, karena mereka memberikan poin terbanyak dengan biaya terendah dari operator. </font><font style="vertical-align: inherit;">Unsur-unsur otonomi meliputi:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berkendara di sepanjang garis dengan sensor cahaya sekitar atau sistem garis pandang</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengambilan suar mandiri menggunakan sensor jarak atau sistem penglihatan</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gerakan di sepanjang lintasan yang kompleks (misalnya, naik / turun tangga) di sepanjang garis menggunakan kompas, giroskop, akselerometer, sistem penglihatan, atau metode gabungan</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juga, poin untuk mengatasi rintangan digandakan jika robot melewatinya secara mandiri.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kerangka kerja proyek ini, solusi untuk yang pertama dari tugas akan dipertimbangkan - pergerakan sepanjang garis. Metode yang paling umum digunakan saat bergerak di sepanjang garis adalah sensor cahaya dan kamera. Kelebihan dari sensor termasuk kesederhanaan membuat program - banyak dari mereka dilengkapi dengan tuning resistor, sehingga dengan mengatur sensor untuk pencahayaan latar belakang, itu akan memberikan 0 atau 1, tergantung pada apakah itu di telepon atau tidak. Untuk alasan yang sama, sensor cahaya tidak menuntut kekuatan pemrosesan dari pengontrol yang digunakan. Selain itu, karena ini, menyelesaikan masalah dengan bantuan sensor cahaya adalah yang paling murah - biaya sensor paling sederhana adalah 35 rubel, dan untuk pengendaraan yang relatif stabil di sepanjang jalur, tiga sensor sudah cukup (satu dipasang pada garis, dan dua di sisi). Namun,Salah satu kelemahan utama dari sensor tersebut adalah pembatasan pemasangan. Idealnya, sensor harus dipasang tepat di tengah, pada jarak kecil dari lantai, jika tidak maka akan memberikan nilai yang salah. Ini bukan masalah dalam kompetisi khusus, di mana robot harus mengemudi secepat mungkin di sepanjang lintasan, tetapi, dalam kondisi kompetisi "RTK Cup", semua kekurangan sensor yang disebutkan di atas dapat menjadi sangat penting - pemasangannya terutama membutuhkan kehadiran komponen mekanis tambahan pada robot yang menaikkan dan menurunkan sensor, dan ini membutuhkan ruang tambahan pada robot, mesin terpisah menggerakkan sensor, dan juga merupakan tempat kerusakan potensial dan meningkatkan massa robot.jika tidak maka akan memberikan nilai yang salah. Ini bukan masalah dalam kompetisi khusus di mana robot harus mengemudi secepat mungkin di sepanjang lintasan, tetapi, dalam kondisi kompetisi "RTK Cup", semua kekurangan sensor yang disebutkan di atas dapat menjadi sangat penting - pemasangannya terutama membutuhkan kehadiran komponen mekanis tambahan pada robot yang menaikkan dan menurunkan sensor, dan ini membutuhkan ruang tambahan pada robot, mesin terpisah menggerakkan sensor, dan juga merupakan tempat kerusakan potensial dan meningkatkan massa robot.jika tidak maka akan memberikan nilai yang salah. Ini bukan masalah dalam kompetisi khusus di mana robot harus mengemudi secepat mungkin di sepanjang lintasan, tetapi, dalam kondisi kompetisi "RTK Cup", semua kekurangan sensor yang disebutkan di atas dapat menjadi sangat penting - pemasangannya terutama membutuhkan kehadiran komponen mekanis tambahan pada robot yang menaikkan dan menurunkan sensor, dan ini membutuhkan ruang tambahan pada robot, mesin terpisah menggerakkan sensor, dan juga merupakan tempat kerusakan potensial dan meningkatkan massa robot.semua kekurangan sensor yang disebutkan di atas dapat menjadi kritis - pemasangannya terutama membutuhkan kehadiran bagian mekanik tambahan pada robot yang menaikkan dan menurunkan sensor, dan ini membutuhkan ruang tambahan pada robot, motor terpisah yang menggerakkan sensor, dan juga merupakan tempat kerusakan potensial dan meningkatkan massa robot .semua kekurangan sensor yang disebutkan di atas dapat menjadi sangat penting - pemasangannya terutama membutuhkan kehadiran robot pada bagian mekanik tambahan yang menaikkan dan menurunkan sensor, dan ini membutuhkan ruang tambahan pada robot, motor terpisah yang menggerakkan sensor, dan juga merupakan tempat kerusakan potensial dan meningkatkan massa robot .</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/_g/pt/zz/_gptzzip0rdk6ocgg67ttumux2k.jpeg" width="300" align="right"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kamera, pada gilirannya, memiliki keuntungan sebagai berikut: ia memiliki jari-jari pengukuran praktis yang tidak terbatas (dibandingkan dengan sensor), yaitu hanya satu modul kamera yang dapat secara bersamaan melihat garis, baik secara langsung di bawah robot, dan pada jarak yang cukup dari itu, yang memungkinkan, misalnya, untuk mengevaluasi kelengkungannya dan memilih tindakan kontrol proporsional. Pada saat yang sama, modul kamera tidak mengganggu kemajuan robot di bagian lain dari TPA yang tidak memerlukan otonomi, karena kamera diperbaiki pada jarak dari lantai. Kerugian utama dari kamera adalah bahwa pemrosesan video membutuhkan kompleks komputasi yang kuat di papan robot, dan perangkat lunak yang dikembangkan membutuhkan penyetelan yang lebih baik, karena kamera menerima urutan informasi lebih besar dari dunia luar daripada tiga sensor cahaya, sementara kamera dan komputermampu memproses informasi yang diterima berkali-kali lebih dari tiga sensor dan "arduins".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagi saya pribadi jawabannya jelas bagi saya - dalam nominasi "ekstrem" robot harus memiliki kamera pengarah, yang dengannya operator akan menavigasi. </font><font style="vertical-align: inherit;">Jika Anda menggunakan solusi FPV siap pakai, maka total biaya "sensor" bisa lebih tinggi, sementara itu membutuhkan instalasi perangkat tambahan. </font><font style="vertical-align: inherit;">Selain itu, robot dengan raspberry pi dan kamera memiliki potensi lebih besar untuk pengembangan gerakan otonom, karena kamera dapat memecahkan berbagai masalah dan dapat digunakan tidak hanya dalam gerakan garis, sementara tidak terlalu menyulitkan desain.</font></font><br>
<br>
<h2><font color="#4d7f95"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisis algoritma visi komputer yang ada</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visi komputer adalah teori tentang menciptakan perangkat yang dapat menerima gambar dari objek dunia nyata, memproses dan menggunakan data yang diperoleh untuk memecahkan berbagai macam masalah yang diterapkan tanpa campur tangan manusia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sistem visi komputer terdiri dari:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satu atau lebih kamera </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">komplek komputer </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perangkat lunak yang menyediakan alat pengolah gambar</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saluran komunikasi untuk mengirimkan target dan informasi telemetri. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang ditulis sebelumnya, ada banyak cara untuk mengidentifikasi objek yang menarik bagi kita. Dalam hal mengemudi sepanjang garis, perlu untuk memisahkan garis itu sendiri dari latar belakang yang kontras (garis hitam pada latar belakang putih atau garis putih pada latar belakang hitam untuk garis terbalik). Algoritma yang menggunakan sistem visi komputer dapat dibagi menjadi beberapa "langkah" untuk memproses gambar asli: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengambilan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gambar: </font><b><font style="vertical-align: inherit;">gambar</font></b><font style="vertical-align: inherit;"> digital diperoleh langsung dari kamera, dari aliran video yang dikirim ke perangkat, atau sebagai gambar terpisah. Nilai piksel biasanya sesuai dengan intensitas cahaya (warna atau gambar skala abu-abu), tetapi dapat dikaitkan dengan berbagai pengukuran fisik, seperti, misalnya, suhu dari kamera pencitraan termal. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemrosesan awal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Sebelum metode visi komputer dapat diterapkan ke data video, pra-pemrosesan diperlukan untuk memperkenalkan kondisi tertentu, tergantung pada metode yang digunakan. </font><font style="vertical-align: inherit;">Contohnya adalah:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menghapus kebisingan atau distorsi yang disebabkan oleh sensor yang digunakan</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar buram digunakan untuk menghilangkan artefak kecil yang terjadi selama operasi kamera, elemen dekompresi, noise, dll.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memperbaiki kontras sehingga informasi yang tepat dapat dideteksi lebih mungkin</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubah eksposur ke bayangan tanaman atau sorotan</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penskalaan atau pemangkasan untuk membedakan lebih baik antara struktur dalam gambar.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengubah gambar menjadi monokrom atau mengubah resolusinya untuk kinerja sistem yang lebih cepat</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menyoroti detail</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">detail</font></b><font style="vertical-align: inherit;"> gambar dari berbagai tingkat kesulitan diekstraksi dari data video. </font><font style="vertical-align: inherit;">Contoh tipikal dari detail tersebut adalah garis, batas, tepi, titik individual, area yang merupakan karakteristik untuk fitur apa pun. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deteksi</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : pada tahap tertentu pekerjaan program, informasi yang relevan dengan program dipisahkan dari gambar lainnya. </font><font style="vertical-align: inherit;">Contohnya adalah:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemilihan satu set tertentu tempat menarik dalam warna, jumlah piksel terisolasi yang serupa dalam beberapa cara (kelengkungan gambar, warna, kecerahan, dll.)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segmentasi satu atau beberapa bagian gambar yang berisi objek karakteristik.</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemrosesan tingkat tinggi</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : pada langkah ini, kelimpahan informasi dari gambar dikurangi menjadi ukuran yang dapat dengan mudah diproses, misalnya, sekumpulan piksel tertentu atau koordinat bagian gambar di mana objek yang diinginkan seharusnya berada. </font><font style="vertical-align: inherit;">Contohnya adalah:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memfilter nilai berdasarkan kriteria apa pun</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evaluasi parameter seperti dimensi fisik objek, bentuk, lokasinya dalam bingkai atau relatif terhadap objek karakteristik lainnya</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klasifikasi</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, perlu memilih perpustakaan berdasarkan program yang akan dibuat. </font><font style="vertical-align: inherit;">Faktor kunci dalam pilihan saya adalah:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dukungan perpustakaan untuk antarmuka Python karena kemudahan relatif dalam mempelajari bahasa ini oleh seorang pemula, adalah sintaksis sederhana, yang memiliki efek menguntungkan pada keterbacaan program.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portabilitas, mis. </font><font style="vertical-align: inherit;">kemampuan untuk menjalankan program menggunakan perpustakaan ini pada raspberry pi3.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prevalensi perpustakaan, yang menjamin komunitas programmer yang berkembang dengan baik yang mungkin telah mengalami masalah yang mungkin timbul selama pekerjaan Anda.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di antara opsi yang saya periksa, saya menyoroti OpenCV open computer vision library, karena mendukung Python, memiliki dokumentasi online yang luas. </font><font style="vertical-align: inherit;">Ada banyak artikel dan instruksi di Internet yang menjelaskan semua seluk-beluk bekerja dengan perpustakaan ini. </font><font style="vertical-align: inherit;">Ada forum resmi dari pengembang tempat siapa pun dapat mengajukan pertanyaan tentangnya. </font><font style="vertical-align: inherit;">Juga, perpustakaan ini diimplementasikan dalam bahasa C / C ++, yang menjamin kinerja sistem, dan strukturnya mendukung berbagai modul yang dapat dinonaktifkan untuk meningkatkan kinerja.</font></font><br>
<br>
<h2><font color="#4d7f95"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengembangan perangkat lunak</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah menginstal OS dan konfigurasi awal Raspberry pi, tetapi sebelum Anda mulai membuat program, Anda harus menginstal semua paket yang diperlukan untuk itu. </font><font style="vertical-align: inherit;">Sebagian besar paket ini, pada gilirannya, diinstal menggunakan manajer paket pip (dalam kasus Python 3, pip3)</font></font><br>
<br>
<pre><code class="bash hljs">$ sudo apt install python3-pip</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pustaka berikut diinstal, seperti:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">picamera - perpustakaan untuk bekerja dengan kamera raspberry pi</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">numpy - perpustakaan untuk bekerja dengan array data multidimensi, sebagai gambar</font></font></li>
</ul><br>
<pre><code class="bash hljs">$ sudo pip3 install picamera<font></font>
$ sudo pip3 install numpy<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cmake - Utilitas untuk membangun program secara otomatis dari kode sumber </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cmake-curses-gui - Paket GUI (antarmuka grafis) untuk cmake</font></font><br>
<br>
<pre><code class="bash hljs">$ sudo apt-get install cmake cmake-curses-gui libgtk2.0-dev<font></font>
$ sudo apt-get install cmake cmake-curses-gui libgtk2.0-dev<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
perpustakaan untuk bekerja dengan berbagai format gambar dan video dan banyak lagi</font></font><br>
<br>
<pre><code class="bash hljs">$ sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev libx264-dev libxvidcore-dev<font></font>
$ sudo apt-get install libjpeg-dev libpng12-dev libtiff5-dev libjasper-dev<font></font>
$ sudo apt-get install gfortran libatlas-base-dev<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengirimkan data video dari robot ke komputer, GStreamer akan digunakan - kerangka kerja yang dirancang untuk menerima, memproses dan mengirimkan data multimedia:</font></font><br>
<br>
<pre><code class="bash hljs">$ sudo apt install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa gstreamer1.0-gl gstreamer1.0-gtk3 gstreamer1.0-qt5 gstreamer1.0-pulseaudio
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Langkah selanjutnya adalah menginstal perpustakaan openCV itu sendiri dari sumber, mengkonfigurasi dan membangunnya. </font><font style="vertical-align: inherit;">Untuk melakukan ini, folder kerja terbuka dibuat.</font></font><br>
<br>
<pre><code class="bash hljs">$ mkdir opencv<font></font>
$ <span class="hljs-built_in">cd</span> opencv
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengunduh versi terbaru perpustakaan, wget digunakan - program konsol untuk mengunduh file dari jaringan. </font><font style="vertical-align: inherit;">Pada saat pembuatan program, versi stabil openCV terbaru adalah 4.1.0, jadi unduh dan bongkar sumbernya:</font></font><br>
<br>
<pre><code class="bash hljs">$ wget https://github.com/opencv/opencv/archive/4.1.0.zip -O opencv_source.zip<font></font>
$ unzip opencv_source.zip<font></font>
$ wget https://github.com/opencv/opencv_contrib/archive/4.1.0.zip -O opencv_contrib.zip<font></font>
$ unzip opencv_contrib.zip<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah proses pembongkaran selesai, arsip sumber dapat dihapus.</font></font><br>
<br>
<pre><code class="bash hljs">$ rm opencv_source.zip<font></font>
$ rm opencv_contrib.zip<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Direktori dibuat untuk perakitan dan konfigurasi.</font></font><br>
<br>
<pre><code class="bash hljs">$ <span class="hljs-built_in">cd</span> /home/pi/opencv/opencv-4.1.0<font></font>
$ mkdir build<font></font>
$ <span class="hljs-built_in">cd</span> build
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parameter build dikonfigurasikan menggunakan utilitas cmake. </font><font style="vertical-align: inherit;">Untuk melakukan ini, semua parameter signifikan dilewatkan sebagai variabel utilitas, bersama dengan nilai yang diberikan:</font></font><br>
<br>
<pre><code class="cmake hljs">cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D INSTALL_PYTHON_EXAMPLES=<span class="hljs-keyword">ON</span> -D INSTALL_C_EXAMPLES=<span class="hljs-keyword">OFF</span> -D BUILD_opencv_python2=<span class="hljs-keyword">OFF</span> -D WITH_GSTREAMER=<span class="hljs-keyword">ON</span> -D BUILD_EXAMPLES=<span class="hljs-keyword">ON</span> -DENABLE_VFPV3=<span class="hljs-keyword">ON</span> -DENABLE_NEON=<span class="hljs-keyword">ON</span> -DCPU_BASELINE=NEON ..
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah mengatur konfigurasi, utilitas akan menampilkan semua parameter. Selanjutnya, Anda perlu mengkompilasi perpustakaan. Untuk melakukan ini, gunakan perintah console make –jN, di mana N adalah jumlah core yang akan terlibat dalam proses kompilasi. Untuk raspberry pi 3, jumlah core adalah 4, tetapi Anda pasti dapat mengetahui nomor ini dengan menuliskan perintah nproc di konsol.</font></font><br>
<br>
<pre><code class="bash hljs">$ make –j4</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena sumber daya raspberry yang terbatas, kompilasi dapat memakan waktu cukup lama. </font><font style="vertical-align: inherit;">Dalam beberapa kasus, raspberry bahkan dapat membeku, tetapi jika Anda kemudian masuk ke folder build dan mendaftar ulang make, pekerjaan akan dilanjutkan. </font><font style="vertical-align: inherit;">Jika ini terjadi, ada baiknya mengurangi jumlah core yang terlibat, namun kompilasi saya berjalan tanpa masalah. </font><font style="vertical-align: inherit;">Juga, pada tahap ini, ada baiknya memikirkan pendinginan aktif raspberry, karena meskipun dengan itu suhu prosesor mencapai sekitar 75 derajat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika kompilasi berhasil, perpustakaan perlu diinstal. </font><font style="vertical-align: inherit;">Ini juga dilakukan dengan menggunakan utilitas make. </font><font style="vertical-align: inherit;">Kemudian kita akan membentuk semua koneksi yang diperlukan dengan utilitas ldconfig:</font></font><br>
<br>
<pre><code class="bash hljs">$ sudo make install<font></font>
$ sudo ldconfig<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memverifikasi instalasi dengan menulis perintah berikut dalam mode interaktif python:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> cv2<font></font>
print(cv2.getBuildInformation())<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kesimpulan program berikut akan menjadi bukti pemasangan yang benar. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/np/vi/ng/npving2rmncveg11-8qxvhvco1q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlu dicatat bahwa prosedur kompilasi perpustakaan di atas harus dilakukan baik pada robot dan pada PC dari yang direncanakan untuk mengendalikan robot dan dari mana siaran dari robot akan diterima. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Membuat skema distribusi video</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum Anda mulai menulis kode, Anda perlu mengembangkan skema yang sesuai dengan algoritma akan berfungsi. Dalam hal ini, pengembangan perangkat lunak robot yang dibuat untuk berpartisipasi dalam kompetisi Piala RTK dalam nominasi Ekstrim, seluruh program akan dibagi menjadi dua bagian: robot dan remote control, yang akan dimainkan oleh komputer dengan OS Linux yang diinstal. Salah satu tugas paling penting di sini adalah membuat skema perkiraan tentang bagaimana data video akan dikirimkan antara berbagai bagian algoritma. Wi-Fi akan digunakan sebagai saluran komunikasi antara kedua perangkat. Paket data yang menyediakan kontrol robot dan data umpan balik akan dikirim dari satu perangkat ke perangkat lain menggunakan protokol UDP yang diimplementasikan dalam menggunakan perpustakaan soket. Data videokarena keterbatasan ukuran paket UDP akan dikirim menggunakan GStreamer. Untuk kenyamanan debugging, dua stream video akan diterapkan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aliran video utama - mentransfer data video langsung dari kamera robot ke komputer untuk memastikan penundaan kontrol minimal.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aliran video tambahan - mentransfer data video yang diproses oleh robot, yang diperlukan untuk mengatur dan men-debug program yang mengimplementasikan visi komputer.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dua aliran video akan secara bersamaan aktif pada robot, dan komputer akan menampilkan gambar yang diinginkan tergantung pada mode drive yang diaktifkan. </font><font style="vertical-align: inherit;">Robot, pada gilirannya, tergantung pada apakah mode otonomi dihidupkan atau dimatikan, akan menggunakan data kontrol yang diterima dari komputer atau yang dihasilkan oleh prosesor gambar. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zw/0l/uw/zw0luwrmjjesbm1ygsra6gxtkm4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remote control robot akan dilakukan karena pekerjaan dua aliran paralel pada robot dan di komputer:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Konsol" dalam satu siklus mensurvei semua perangkat input yang tersedia dan membentuk paket data kontrol yang terdiri dari data itu sendiri dan checksum (pada saat membuat perubahan akhir pada artikel, saya menolak untuk membuat checksum untuk mengurangi keterlambatan, tetapi dalam sumber, yang saya diletakkan di bagian akhir kode ini dibiarkan) - dari nilai tertentu yang dihitung dari data yang ditetapkan oleh operasi beberapa algoritma yang digunakan untuk menentukan integritas data selama transmisi</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Robot - Menunggu akses data dari komputer. </font><font style="vertical-align: inherit;">Membuka paket data, menghitung ulang checksum dan membandingkannya dengan yang dikirim dan dihitung di sisi komputer. </font><font style="vertical-align: inherit;">Jika checksum cocok, data ditransfer ke program utama.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum parsing algoritma deteksi garis, saya sarankan Anda membiasakan diri dengan fitur desain robot:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tentang robot</font></font></b><div class="spoiler_text">          .<br>
<br>
<img src="https://habrastorage.org/webt/vw/ao/ex/vwaoexwehb49titxcgdis_ryonc.jpeg" width="200" align="right"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"></a> —       .      (3  )        .                 ,      .      6 ,        .           .      .          .     ,    -  .     «»   rasberry pi 3 b —      .<br>
<br>
<img src="https://habrastorage.org/webt/ho/zw/bi/hozwbiptp_fihoiqncxq2zsbpim.png" width="200" align="left"> ,       ,   ,   ,   Solidworks    petg .    ,     raspberry        .<br>
<br>
<img src="https://habrastorage.org/webt/mh/po/bd/mhpobduedmyoxzrdbhhac2ewdpq.png" width="200" align="left">          ubiquiti bullet M5 hp.     (   )      ,          .   ,   «»  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"> </a> . <br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ti/h_/7l/tih_7l74vjx8leso89cwynfpb3o.jpeg" width="400"></div><br>
:     «»     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">  thingiverse</a>.    ,  ,   ,      ,          .<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/df/q_/wddfq_nyi7-xcqmdiil5glkybqe.gif" width="300"></div><br>
   ,     ,   .       ,     .              ,  ,        ,     ,    .     ,       ,        ,     .<br>
<br>
<img src="https://habrastorage.org/webt/sl/ju/f9/sljuf9jwaqm2kdadelgsgubyf5o.gif" width="450"><br>
<br>
<img src="https://habrastorage.org/webt/sg/xk/_k/sgxk_kt1f0xdxkg4igwgzmbudk0.png" width="250"><br>
<br>
-     (   -  200 )    ,       ,     90       70   (     ),          ,     « ». ,            VL53L0X        ,      .<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jq/wh/hc/jqwhhc7et4crpin64qkaw6txgk0.png" width="250"></div><br>
 «»     ,     ,    (<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">rds3115</a>).    — ,     ,  ,     ,     .<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/4p/ot/ic/4poticuqt_itsiasls1of3927ma.jpeg" width="250"></div><br>
      ,      ,    ,   :<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qc/w5/ol/qcw5olk3klaxq75typuz41hdt18.png" width="250"></div><br>
- ,       ,          ,      .           . <img src="https://habrastorage.org/webt/he/4o/kp/he4okpaqyd5pof9x1cjwc1aalwi.jpeg" width="200" align="left">        raspberry,      ,     .       ,      .<br>
<br>
     ,   USB.            ,            ,     .<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rq/wv/yr/rqwvyr8kv5dtvpgz6x7rahoyfho.gif" width="200"></div><br>
<i>        </i><br>
</div></div><br>
<h3><font color="#4d7f95"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembuatan algoritma deteksi garis menggunakan metode pustaka OpenCV</font></font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I. Memperoleh data</font></font></b> <br>
<br>
<img src="https://habrastorage.org/webt/ua/q7/zo/uaq7zojtflqtezqkiq2meem5mam.png" width="300" align="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karena fakta bahwa pemroses gambar tidak menerima data video langsung dari kamera, tetapi dari arus utama, perlu untuk memindahkannya dari format yang digunakan untuk terjemahan ke format yang digunakan untuk pemrosesan gambar, yaitu, array numpy yang terdiri dari nilai merah , hijau dan biru untuk masing-masing piksel. </font><font style="vertical-align: inherit;">Untuk melakukan ini, Anda memerlukan data awal - bingkai yang diterima dari modul kamera raspberry pi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cara termudah untuk mendapatkan bingkai dari kamera c untuk diproses lebih lanjut adalah dengan menggunakan perpustakaan picamera. </font><font style="vertical-align: inherit;">Sebelum Anda mulai, Anda harus mengizinkan akses ke kamera melalui raspi-config -&gt; interfacing options camera -&gt; pilih yes.</font></font><br>
<br>
<pre><code class="bash hljs">sudo raspi-config</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bagian kode selanjutnya dihubungkan ke kamera raspberry dan dalam satu siklus dengan frekuensi yang diterima menerima bingkai dalam bentuk array yang siap digunakan oleh pustaka pembuka.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> picamera.array <span class="hljs-keyword">import</span> PiRGBArray
<span class="hljs-keyword">from</span> picamera <span class="hljs-keyword">import</span> PiCamera
<span class="hljs-keyword">import</span> cv2
<span class="hljs-comment">#   </span><font></font>
camera = PiCamera()<font></font>
camera.resolution = (<span class="hljs-number">640</span>, <span class="hljs-number">480</span>) <font></font>
camera.framerate = <span class="hljs-number">30</span>
cap = PiRGBArray(camera, size=(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>))<font></font>
<font></font>
<span class="hljs-keyword">for</span> frame <span class="hljs-keyword">in</span> camera.capture_continuous(cap , format=<span class="hljs-string">"bgr"</span>, use_video_port=<span class="hljs-literal">True</span>):<font></font>
	new_frame = frame.array<font></font>
	cap.truncate(<span class="hljs-number">0</span>)
	<span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>: <span class="hljs-comment">#   -   </span>
		<span class="hljs-keyword">break</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penting juga dicatat bahwa metode ini menangkap bingkai, meskipun ini adalah yang paling sederhana, tetapi memiliki kelemahan serius: itu tidak terlalu efektif jika Anda perlu menyiarkan frame melalui GStreamer, karena ini membutuhkan beberapa kali untuk menyandikan ulang video, yang mengurangi kecepatan program. </font><font style="vertical-align: inherit;">Cara yang jauh lebih cepat untuk mendapatkan gambar adalah dengan menghasilkan bingkai dari aliran video atas permintaan prosesor gambar, namun, tahapan lebih lanjut dari pemrosesan gambar tidak akan tergantung pada metode yang digunakan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh gambar dari kamera robot tanpa pemrosesan:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/bo/yi/ez/boyiezf6vfa1nqrlcdllhwbmsgg.png" width="350"></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II Pra-pemrosesan</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Saat mengemudi di jalur, akan sangat mudah untuk memisahkan area titik yang paling kontras dengan warna latar belakang. Metode ini cocok untuk kompetisi Piala RTK, karena menggunakan garis hitam pada latar belakang putih (atau garis putih pada latar belakang hitam untuk bagian terbalik). Untuk mengurangi jumlah informasi yang perlu diproses, Anda dapat menerapkan algoritma binarisasi untuknya, yaitu, mengonversi gambar ke format monokrom, di mana hanya ada dua jenis piksel - gelap dan terang. Sebelum ini, gambar harus diterjemahkan ke dalam skala abu-abu, dan juga mengaburkannya untuk memotong cacat kecil dan noise yang tak terhindarkan muncul selama pengoperasian kamera. Untuk mengaburkan gambar, filter Gaussian digunakan.</font></font><br>
<br>
<pre><code class="python hljs">gray = cv2.cvtColor(self._frame, cv2.COLOR_RGB2GRAY)<font></font>
blur = cv2.GaussianBlur(gray, (ksize, ksize), <span class="hljs-number">0</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
di mana ksize adalah ukuran inti Gaussian, yang meningkat, Anda dapat meningkatkan tingkat blur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh gambar setelah terjemahan dalam skala abu-abu dan kabur:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ye/5h/_d/ye5h_d7dqttbxo_af3hhkxnllce.png" width="350"></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AKU AKU AKU. </font><font style="vertical-align: inherit;">Memilih detail</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Setelah gambar diterjemahkan dalam skala abu-abu, perlu untuk membuat binarize pada batas yang ditentukan. </font><font style="vertical-align: inherit;">Tindakan ini memungkinkan Anda untuk lebih mengurangi jumlah data. Nilai ambang ini akan disesuaikan sebelum setiap keberangkatan robot di tempat baru, atau ketika kondisi pencahayaan berubah. </font><font style="vertical-align: inherit;">Idealnya, tugas kalibrasi adalah untuk memastikan bahwa garis garis didefinisikan pada gambar, tetapi pada saat yang sama, tidak boleh ada detail lain pada gambar yang bukan garis:</font></font><br>
<br>
<pre><code class="python hljs">thresh = cv2.threshold(blur, self._limit, <span class="hljs-number">255</span>, cv2.THRESH_BINARY_INV)[<span class="hljs-number">1</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini, semua piksel lebih gelap dari nilai ambang (self._limit) diganti dengan 0 (hitam), lebih terang - oleh 255 (putih). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah diproses, gambar tampak sebagai berikut:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ne/rq/tl/nerqtlzt7p-k0q-4quw6nhsbfau.png" width="350"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, program telah mengidentifikasi beberapa bagian gambar yang paling gelap. </font><font style="vertical-align: inherit;">Namun, setelah mengkalibrasi nilai ambang untuk benar-benar "menangkap" headphone, elemen putih lainnya muncul di layar di samping mereka. </font><font style="vertical-align: inherit;">Tentu saja, Anda dapat menyempurnakan ambang, dan di tempat latihan kompetitif kamera akan melihat ke bawah, tidak membiarkan elemen yang tidak perlu ke dalam bingkai, tetapi saya menganggap perlu bagi saya untuk memisahkan garis dari yang lainnya. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IV.Deteksi</font></font></b> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada gambar yang dipasangkan, saya menerapkan algoritma pencarian perbatasan. </font><font style="vertical-align: inherit;">Dibutuhkan untuk menentukan tempat berdiri bebas dan mengubahnya menjadi array nyaman nilai koordinat titik yang membentuk perbatasan. </font><font style="vertical-align: inherit;">Dalam kasus opencv, seperti yang tertulis dalam dokumentasi, algoritma standar untuk menemukan loop menggunakan algoritma Suzuki85 (saya tidak dapat menemukan referensi ke algoritma dengan nama ini di mana pun kecuali untuk dokumentasi opencv, tetapi saya akan berasumsi bahwa ini adalah algoritma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suzuki-Abe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<pre><code class="python hljs">contours = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan inilah bingkai yang diperoleh pada tahap ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ex/3r/gx/ex3rgxc7bmefqdwhetn5wfxrtko.png" width="350"></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V. Pemrosesan Tingkat Tinggi</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah menemukan semua kontur dalam bingkai, kontur dengan area terbesar dipilih dan diambil sebagai kontur garis. Mengetahui koordinat semua titik kontur ini, koordinat pusatnya ditemukan. Untuk ini, apa yang disebut "momen gambar" digunakan. Momen adalah karakteristik total kontur, dihitung dengan menjumlahkan koordinat semua piksel kontur. Ada beberapa jenis momen - hingga urutan ketiga. Untuk masalah ini, hanya momen orde nol (m00) yang diperlukan - jumlah semua titik yang membentuk kontur (perimeter kontur), momen orde pertama (m10), yang merupakan jumlah koordinat X dari semua titik, dan m01 adalah jumlah koordinat Y dari semua titik. Dengan membagi jumlah koordinat titik di sepanjang salah satu sumbu dengan jumlah mereka, rata-rata aritmatika diperoleh - koordinat perkiraan pusat kontur. Selanjutnya, penyimpangan robot dari kursus dihitung:Tentu saja "langsung" sesuai dengan koordinat titik pusat sepanjang X dekat dengan lebar bingkai dibagi dua. Jika koordinat pusat garis dekat dengan pusat bingkai, maka tindakan kontrol minimal, dan, karenanya, robot mempertahankan jalurnya saat ini. Jika robot menyimpang dari salah satu sisi, maka tindakan kontrol yang sebanding dengan penyimpangan akan diperkenalkan sampai kembali.</font></font><br>
<br>
<pre><code class="python hljs">mainContour = max(contours, key = cv2.contourArea)<font></font>
M = cv2.moments(mainContour)<font></font>
<span class="hljs-keyword">if</span> M[<span class="hljs-string">'m00'</span>] != <span class="hljs-number">0</span>:<span class="hljs-comment">#     (..   -  )</span>
    cx = int(M[<span class="hljs-string">'m10'</span>]/M[<span class="hljs-string">'m00'</span>])<font></font>
    cy = int(M[<span class="hljs-string">'m01'</span>]/M[<span class="hljs-string">'m00'</span>])
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di bawah ini adalah gambar skematis dari posisi robot relatif terhadap garis dan bingkai, dengan hasil program ditumpangkan pada mereka: kontur "utama", garis-garis yang melewati pusat kontur, dan juga titik yang terletak di pusat untuk memperkirakan penyimpangan. </font><font style="vertical-align: inherit;">Elemen-elemen ini ditambahkan menggunakan kode berikut:</font></font><br>
<br>
<pre><code class="python hljs">cv2.line(frame, (cx, <span class="hljs-number">0</span>), (cx, self.height), (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>)    <span class="hljs-comment">#    </span>
cv2.line(frame, (<span class="hljs-number">0</span>, cy), (self.width, cy), (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>)                  <font></font>
cv2.circle(frame, (self.width//<span class="hljs-number">2</span>, self.height//<span class="hljs-number">2</span>), <span class="hljs-number">3</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">-1</span>) <span class="hljs-comment">#  </span>
cv2.drawContours(frame, mainContour, <span class="hljs-number">-1</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>, cv2.FILLED) <span class="hljs-comment">#   </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk kenyamanan debugging, semua elemen yang dijelaskan sebelumnya ditambahkan ke bingkai mentah: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/f4/fl/os/f4flos522ouvlu-vi2b9rr_17lg.png" width="350"><br>
<br>
<img src="https://habrastorage.org/webt/uc/r1/vx/ucr1vxcecjqdv5qdswcbjsltw9w.png" width="350"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, setelah mendorong frame melalui algoritma pemrosesan, kami mendapat koordinat X dan Y dari pusat objek yang menarik bagi kami, serta gambar debug. </font><font style="vertical-align: inherit;">Selanjutnya, posisi robot relatif terhadap garis ditampilkan secara skematis, serta gambar yang telah melewati algoritma pemrosesan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/4r/co/fy/4rcofyknawjnesluhuvoyp9zomu.jpeg" width="500"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Langkah selanjutnya dalam program ini adalah mengubah informasi yang diperoleh pada langkah sebelumnya menjadi nilai daya dua motor. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/io/s3/gn/ios3gnw-mt2xsmvh_hsfrpsdkdu.jpeg" width="250" align="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara termudah untuk mengkonversi perbedaan antara pergeseran pusat titik warna relatif ke tengah bingkai adalah regulator proporsional (Ada juga regulator relai, tetapi, karena fitur operasinya, tidak cocok untuk mengemudi di sepanjang garis). Prinsip operasi dari algoritma semacam itu adalah bahwa pengontrol menghasilkan aksi kontrol pada objek secara proporsional dengan besarnya kesalahan. Selain pengontrol proporsional, ada juga yang integral, di mana seiring waktu komponen integral "menumpuk" kesalahan dan yang diferensial, prinsip yang didasarkan pada penerapan pengaruh peraturan hanya dengan perubahan yang cukup dalam variabel yang dikendalikan. Dalam praktiknya, pengontrol P, I, D yang paling sederhana ini digabungkan menjadi pengontrol dari tipe PI, PD, PID.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlu disebutkan bahwa pada robot saya, saya mencoba "memulai" kontroler PID, tetapi penggunaannya tidak memberikan keuntungan serius dibandingkan dengan kontroler proporsional yang biasa. Saya akui bahwa saya tidak dapat mengatur regulator dengan benar, tetapi ada juga kemungkinan bahwa keuntungannya tidak begitu jelas terlihat dalam kasus robot berat yang tidak dapat secara fisik mengembangkan kecepatan tinggi. Dalam versi terbaru dari program pada saat penulisan, regulator proporsional sederhana digunakan, tetapi dengan fitur kecil yang memungkinkan Anda untuk menggunakan lebih banyak informasi dari kamera: ketika menghasilkan nilai kesalahan, tidak hanya posisi horizontal dari titik tengah tempat diperhitungkan, tetapi juga secara vertikal, yang memungkinkan berbagai cara menanggapi elemen garisterletak "di kejauhan" dan langsung di depan atau di bawah robot (kamera robot memiliki sudut pandang yang besar, jadi dengan memutarnya hanya 45 derajat ke bawah, Anda sudah dapat melihat bagian penting dari bidang di bawah robot).</font></font><br>
<br>
<pre><code class="python hljs">error= cx / (self.width/<span class="hljs-number">2</span>) - <span class="hljs-number">1</span>  
<span class="hljs-comment">#  ( 0   )  [-1; 1]</span>
error*= cy / self.height + self.gain <span class="hljs-comment">#</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Paling sering, dalam kondisi kompetisi "RTK Cup", peserta menggunakan apa yang disebut "sirkuit tangki" - satu atau lebih mesin mengendalikan satu sisi robot, dan bekerja baik dengan trek maupun roda. Dengan menggunakan skema ini, Anda dapat menyingkirkan elemen transmisi kompleks yang meningkatkan kemungkinan kerusakan (diferensial atau poros cardan), dapatkan radius putar sekecil mungkin, yang memberikan keuntungan dalam poligon terbatas. Skema ini melibatkan kontrol paralel dari dua "sisi" untuk gerakan di sepanjang jalur yang kompleks. Untuk melakukan ini, program ini menggunakan dua variabel - kekuatan motor kanan dan kiri. Kekuatan ini tergantung pada kecepatan dasar (BASE_SPEED), bervariasi dalam kisaran dari 0 hingga 100.Kesalahan (kesalahan) - perbedaan antara pusat frame dan koordinat tengah garis dan koefisien efek proporsional (self._koof), yang dikalibrasi oleh operator. Nilai absolutnya mempengaruhi seberapa cepat robot akan mencoba menyelaraskan dirinya dengan garis. Karena kenyataan bahwa pada satu mesin aksi kontrol dikurangi dari kecepatan dasar, dan pada yang lain - ditambahkan, giliran dilakukan ketika menyimpang dari jalur. Arah di mana pembalikan akan dilakukan dapat disesuaikan dengan mengubah tanda variabel self._koof. Juga, Anda mungkin memperhatikan bahwa sebagai akibat dari bagian kode berikutnya, nilai daya mungkin muncul lebih dari 100, tetapi dalam program saya, kasus tersebut diproses lebih lanjut nanti.Nilai absolutnya mempengaruhi seberapa cepat robot akan mencoba menyelaraskan dirinya dengan garis. Karena kenyataan bahwa pada satu mesin aksi kontrol dikurangi dari kecepatan dasar, dan pada yang lain - ditambahkan, giliran dilakukan ketika menyimpang dari jalur. Arah di mana pembalikan akan dilakukan dapat disesuaikan dengan mengubah tanda variabel self._koof. Juga, Anda mungkin memperhatikan bahwa sebagai hasil dari bagian kode berikutnya, nilai daya mungkin muncul lebih dari 100, tetapi dalam program saya kasus-kasus semacam itu juga diproses lebih lanjut.Nilai absolutnya mempengaruhi seberapa cepat robot akan mencoba menyelaraskan dirinya dengan garis. Karena kenyataan bahwa pada satu mesin aksi kontrol dikurangi dari kecepatan dasar, dan pada yang lain - ditambahkan, giliran dilakukan ketika menyimpang dari jalur. Arah di mana pembalikan akan dilakukan dapat disesuaikan dengan mengubah tanda variabel self._koof. Juga, Anda mungkin memperhatikan bahwa sebagai hasil dari bagian kode berikutnya, nilai daya mungkin muncul lebih dari 100, tetapi dalam program saya kasus-kasus semacam itu juga diproses lebih lanjut.di mana pembalikan akan dilakukan, Anda dapat menyesuaikan dengan mengubah tanda variabel self._koof. Juga, Anda mungkin memperhatikan bahwa sebagai hasil dari bagian kode berikutnya, nilai daya mungkin muncul lebih dari 100, tetapi dalam program saya kasus-kasus semacam itu juga diproses lebih lanjut.di mana pembalikan akan dilakukan, Anda dapat menyesuaikan dengan mengubah tanda variabel self._koof. Juga, Anda mungkin memperhatikan bahwa sebagai hasil dari bagian kode berikutnya, nilai daya mungkin muncul lebih dari 100, tetapi dalam program saya kasus-kasus semacam itu juga diproses lebih lanjut.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#if lineFound:</span><font></font>
leftSpeed = round(self.base_speed + error*self.koof)<font></font>
rightSpeed = round(self.base_speed - error*self.koof)<font></font>
</code></pre><br>
<h2><font color="#4d7f95"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah menguji program yang dihasilkan, saya dapat mengatakan bahwa momen sulit utama dalam mengatur program adalah kalibrasi algoritma ke fitur pencahayaan. </font><font style="vertical-align: inherit;">Karena tahap pembuatan artikel bertepatan dengan isolasi diri yang dinyatakan, saya harus membuat video dengan demonstrasi pekerjaan di sebuah ruangan kecil. </font><font style="vertical-align: inherit;">Ini membuat saya kesulitan:</font></font><br>
<br>
<ul>
<li> -,    ,    (   ,     ),        .        ,    ,         ,      .      ,     , ,            ,              </li>
<li> -,       —    ,   ,         </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terlepas dari kenyataan bahwa kedua masalah ini tidak ada dalam kondisi kompetisi nyata, saya akan mengambil langkah-langkah untuk memastikan bahwa pekerjaan program minimal tergantung pada faktor-faktor eksternal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juga, di masa depan, direncanakan untuk terus bekerja pada implementasi algoritma menggunakan metode visi komputer, menciptakan perangkat lunak yang mampu melewati elemen-elemen otonomi yang tersisa yang dijelaskan di bagian pertama artikel (penangkapan suar otonom, pergerakan sepanjang jalur yang kompleks). Direncanakan untuk memperluas fungsionalitas robot dengan menambahkan sensor tambahan: pengintai, giroskop-accelerometer, kompas. Terlepas dari kenyataan bahwa penerbitan artikel ini akan mengakhiri pekerjaan saya pada proyek sebagai mata pelajaran wajib sekolah, saya berencana untuk terus menggambarkan di sini tahap pengembangan selanjutnya. Karena itu, saya ingin menerima komentar tentang karya ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah menerapkan semua langkah yang ditujukan untuk menyelesaikan masalah proyek, aman untuk mengatakan bahwa penggunaan algoritma visi komputer, dengan semua kompleksitas relatifnya dalam pemrograman dan debugging, memberikan keuntungan terbesar pada tahap kompetisi itu sendiri. Dengan dimensi kamera yang kecil, kamera ini memiliki potensi yang sangat besar dalam hal pengembangan perangkat lunak, karena kamera memungkinkan Anda mengganti beberapa sensor "tradisional" sekaligus, sambil menerima lebih banyak informasi dari dunia luar. Dimungkinkan untuk mewujudkan tujuan proyek - untuk membuat program yang menggunakan visi komputer untuk menyelesaikan masalah navigasi otonom robot dalam kondisi kompetisi "RTK Cup", serta menggambarkan proses pembuatan program dan tahapan utama dalam pemrosesan gambar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang saya katakan sebelumnya, tidak mungkin untuk membuat ulang lintasan kompleks garis rumah, dan contoh ini menunjukkan bagaimana algoritma memenuhi putaran. </font><font style="vertical-align: inherit;">Ketebalan garis di sini sesuai dengan yang sesuai dengan peraturan, dan kurva paling lilitan kira-kira mencerminkan kelengkungan rotasi sebesar 90 derajat pada poligon:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/YmHk3f-qQ5E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat melihat kode program, serta memantau pekerjaan lebih lanjut pada proyek, pada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github saya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau di sini, jika saya melanjutkan.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id497286/index.html">Ludum Dare: daftar periksa seminggu sebelum memulai</a></li>
<li><a href="../id497288/index.html">Lampu langit-langit dekoratif Feron AL5000</a></li>
<li><a href="../id497290/index.html">Meningkatkan kinerja menggunakan cache uop di Sandy Bridge +</a></li>
<li><a href="../id497292/index.html">Game Stack Shiro Teknologi</a></li>
<li><a href="../id497296/index.html">Kesalahan populer dalam bahasa Inggris di kalangan profesional TI. Bagian 2: Pengucapan</a></li>
<li><a href="../id497304/index.html">Intercepter-NG 2.5 dirilis untuk Android</a></li>
<li><a href="../id497306/index.html">DLL spoofing (pembajakan DLL)</a></li>
<li><a href="../id497308/index.html">Bisakah kecerdasan buatan melakukan seni?</a></li>
<li><a href="../id497310/index.html">Jaringan morfologi bipolar: neuron tanpa multiplikasi</a></li>
<li><a href="../id497312/index.html">Pertanyaan tentang CAN FD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>