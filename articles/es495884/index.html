<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüè≠ üêä üöÇ Predicci√≥n de series de tiempo usando redes neuronales recurrentes üò§ üñáÔ∏è üîé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El modo remoto de operaci√≥n en el contexto del autoaislamiento universal puede tener muy malas consecuencias. Y agotamiento emocional: todav√≠a est√° do...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Predicci√≥n de series de tiempo usando redes neuronales recurrentes</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495884/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El modo remoto de operaci√≥n en el contexto del autoaislamiento universal puede tener muy malas consecuencias. Y agotamiento emocional: todav√≠a est√° donde sea que vaya: despu√©s de todo, no est√° lejos del techo. En este sentido, como muchos, trat√≥ de "calmarse" asignando tiempo para otras clases, y comenz√≥ a traducir los art√≠culos m√°s interesantes del ingl√©s al ruso: "¬°Le das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aprendizaje autom√°tico</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a las masas!".) Debemos rendir homenaje: es una gran distracci√≥n. Si tiene sugerencias para el contenido sem√°ntico y la traducci√≥n de este texto para un lector de habla rusa, √∫nase a la discusi√≥n.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3d7/fe4/946/3d7fe49466cad76814b37e73ec1bc49a.jpg" alt="imagen"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, aqu√≠ hay una traducci√≥n de la p√°gina de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pron√≥stico de series temporales</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la secci√≥n del manual de tensorflow: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlace</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mis adiciones, junto con las ilustraciones para la traducci√≥n, est√°n destinadas a ayudar a comprender las ideas b√°sicas en una de las √°reas m√°s interesantes de LA y la econometr√≠a en general: predicci√≥n de series de tiempo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una peque√±a introducci√≥n antes de la traducci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El manual es una descripci√≥n de la predicci√≥n de la temperatura del aire basada en series de tiempo unidimensionales </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(series de tiempo univariadas)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y series de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiempo multivariadas (</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> series de </font><i><font style="vertical-align: inherit;">tiempo multivariadas)</font></i><font style="vertical-align: inherit;"> . Para cada parte, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ingrese datos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debe estar preparado en consecuencia. Teniendo en cuenta el conjunto de datos meteorol√≥gicos considerado en este manual, la separaci√≥n es la siguiente: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8fa/31a/a75/8fa31aa7531d8589dcee2ae93454a430.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
para preguntas sobre qu√© tomar para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y qu√© para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , es decir, c√≥mo preparar datos para la clase de entrenamiento supervisado, quedar√° claro a partir de las siguientes ilustraciones. Solo noto que la formaci√≥n del vector objetivo (Y) para trabajar con series de tiempo unidimensionales y multidimensionales es la misma: el vector objetivo se compila sobre la base del signo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T (degC)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(temperatura del aire). La diferencia entre ellos est√° "enterrada" en la formaci√≥n de un conjunto de caracter√≠sticas que se alimentan a la entrada del modelo: en el caso de una serie de tiempo unidimensional para predecir la temperatura en el futuro, el vector de entrada (X) consta de una caracter√≠stica: de hecho, temperatura del aire; y para multidimensional: m√°s de uno: adem√°s de la temperatura del aire, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p (mbar)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (presi√≥n atmosf√©rica) y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rho (g / m ** 3)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (humedad) </font><font style="vertical-align: inherit;">se utilizan en el ejemplo del manual en cuesti√≥n </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al principio, muy superficial, una mirada a un ejemplo con pron√≥stico de temperatura parece poco convincente desde el punto de vista del uso de una entrada multidimensional: para pronosticar la temperatura, el signo m√°s relevante ser√° la temperatura. Sin embargo, este no es el caso en absoluto: para desarrollar un pron√≥stico cualitativo de la temperatura del aire, se deben tener en cuenta muchos factores, hasta la fricci√≥n del aire en la superficie de la tierra, etc. Adem√°s, en la pr√°ctica, algunas cosas est√°n lejos de ser obvias, y el vector objetivo puede tener la forma de ese batiburrillo (o borsch). En este sentido, el an√°lisis exploratorio de datos con la selecci√≥n de las caracter√≠sticas m√°s relevantes para la posterior formaci√≥n de una entrada multidimensional es la √∫nica decisi√≥n correcta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, la traducci√≥n del manual se presenta a continuaci√≥n. El texto adicional estar√° </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en cursiva</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Predicci√≥n de series de tiempo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta gu√≠a es una introducci√≥n a la predicci√≥n de series de tiempo utilizando redes neuronales recurrentes (RNS, de la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Red neuronal recurrente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inglesa </font><i><font style="vertical-align: inherit;">, RNN</font></i><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Consta de dos partes: la primera describe la predicci√≥n de la temperatura del aire basada en una serie de tiempo unidimensional, y la segunda, basada en una serie de tiempo multidimensional.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<font></font>
<font></font>
<span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<font></font>
<font></font>
mpl.rcParams[<span class="hljs-string">'figure.figsize'</span>] = (<span class="hljs-number">8</span>, <span class="hljs-number">6</span>)<font></font>
mpl.rcParams[<span class="hljs-string">'axes.grid'</span>] = <span class="hljs-literal">False</span>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un conjunto de datos meteorol√≥gicos</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Todos los ejemplos del manual utilizan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">secuencias de tiempo de datos meteorol√≥gicos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> registrados en una estaci√≥n hidrometeorol√≥gica en el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instituto de Biogeoqu√≠mica con el nombre de </font><font style="vertical-align: inherit;">Max Planck</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este conjunto de datos incluye mediciones de 14 indicadores meteorol√≥gicos diferentes (como temperatura del aire, presi√≥n atmosf√©rica, humedad), que se realizan cada 10 minutos desde 2003. </font><font style="vertical-align: inherit;">Para ahorrar tiempo y uso de memoria, el manual utilizar√° datos que cubren el per√≠odo de 2009 a 2016. </font><font style="vertical-align: inherit;">Esta secci√≥n del conjunto de datos fue preparada por Fran√ßois Chollet para su libro, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deep Learning with Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="python hljs">zip_path = tf.keras.utils.get_file(<font></font>
    origin=<span class="hljs-string">'https://storage.googleapis.com/tensorflow/tf-keras-datasets/jena_climate_2009_2016.csv.zip'</span>,<font></font>
    fname=<span class="hljs-string">'jena_climate_2009_2016.csv.zip'</span>,<font></font>
    extract=<span class="hljs-literal">True</span>)<font></font>
csv_path, _ = os.path.splitext(zip_path)<font></font>
</code></pre><br>
<pre><code class="python hljs">df = pd.read_csv(csv_path)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos que tenemos.</font></font><br>
<br>
<pre><code class="python hljs">df.head()
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/d5d/bfa/539/d5dbfa539de3da5ca04103b2db380a70.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La tabla anterior puede verificar el hecho de que el per√≠odo de registro de observaci√≥n es de 10 minutos. Por lo tanto, en una hora tendr√°s 6 observaciones. A su vez, se acumulan 144 (6x24) observaciones por d√≠a. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos que desea predecir la temperatura, que ser√° en 6 horas en el futuro. Realiza este pron√≥stico en funci√≥n de los datos que tiene para un per√≠odo determinado: por ejemplo, decide utilizar 5 d√≠as de observaci√≥n. Por lo tanto, para entrenar el modelo, debe crear un intervalo de tiempo que contenga las √∫ltimas 720 (5x144) observaciones (dado que son posibles diferentes configuraciones, este conjunto de datos es una buena base para los experimentos). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La siguiente funci√≥n devuelve los intervalos de tiempo anteriores para entrenar el modelo. Argumento</font></font><code>history_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- este es el tama√±o del √∫ltimo intervalo de tiempo, </font></font><code>target_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- un argumento que determina qu√© tan lejos en el futuro el modelo debe aprender a predecir. </font><font style="vertical-align: inherit;">En otras palabras, </font></font><code>target_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es el vector objetivo que debe predecirse.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">univariate_data</span>(<span class="hljs-params">dataset, start_index, end_index, history_size, target_size</span>):</span><font></font>
  data = []<font></font>
  labels = []<font></font>
<font></font>
  start_index = start_index + history_size<font></font>
  <span class="hljs-keyword">if</span> end_index <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
    end_index = len(dataset) - target_size<font></font>
<font></font>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start_index, end_index):<font></font>
    indices = range(i-history_size, i)<font></font>
    <span class="hljs-comment"># Reshape data from (history_size,) to (history_size, 1)</span>
    data.append(np.reshape(dataset[indices], (history_size, <span class="hljs-number">1</span>)))<font></font>
    labels.append(dataset[i+target_size])<font></font>
  <span class="hljs-keyword">return</span> np.array(data), np.array(labels)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En ambas partes del manual, las primeras 300,000 filas de datos se usar√°n para entrenar el modelo, las restantes para validarlo (validarlo). </font><font style="vertical-align: inherit;">En este caso, la cantidad de datos de entrenamiento es de aproximadamente 2100 d√≠as.</font></font><br>
<br>
<pre><code class="python hljs">TRAIN_SPLIT = <span class="hljs-number">300000</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para garantizar resultados reproducibles, se establece la funci√≥n semilla.</font></font><br>
<br>
<pre><code class="python hljs">tf.random.set_seed(<span class="hljs-number">13</span>)
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 1. Pron√≥stico basado en una serie de tiempo unidimensional</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la primera parte, entrenar√° el modelo utilizando solo un atributo: temperatura; </font><font style="vertical-align: inherit;">El modelo entrenado se utilizar√° para predecir las temperaturas futuras. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comenzar, extraemos solo la temperatura del conjunto de datos.</font></font><br>
<br>
<pre><code class="python hljs">uni_data = df[<span class="hljs-string">'T (degC)'</span>]<font></font>
uni_data.index = df[<span class="hljs-string">'Date Time'</span>]<font></font>
uni_data.head()<font></font>
</code></pre><br>
<code>Date Time<br>
01.01.2009 00:10:00 -8.02<br>
01.01.2009 00:20:00 -8.41<br>
01.01.2009 00:30:00 -8.51<br>
01.01.2009 00:40:00 -8.31<br>
01.01.2009 00:50:00 -8.27<br>
Name: T (degC), dtype: float64<br>
</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y veamos c√≥mo cambian estos datos con el tiempo.</font></font><br>
<br>
<pre><code class="python hljs">uni_data.plot(subplots=<span class="hljs-literal">True</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/208/b35/242/208b35242d3ce1ed30bd25d12d956703.jpg" alt="imagen"><br>
<br>
<pre><code class="python hljs">uni_data = uni_data.values
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de entrenar una red neuronal artificial (en adelante, ANN), un paso importante es el escalado de datos. </font><font style="vertical-align: inherit;">Una de las formas comunes de realizar la escala es la estandarizaci√≥n ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estandarizaci√≥n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), realizada restando la media y dividiendo por la desviaci√≥n est√°ndar para cada caracter√≠stica. </font><font style="vertical-align: inherit;">Tambi√©n puede usar un m√©todo </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">tf.keras.utils.normalize</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que escala los valores al rango [0,1]. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : la estandarizaci√≥n solo debe llevarse a cabo utilizando datos de capacitaci√≥n.</font></font><br>
<br>
<pre><code class="python hljs">uni_train_mean = uni_data[:TRAIN_SPLIT].mean()<font></font>
uni_train_std = uni_data[:TRAIN_SPLIT].std()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Realizamos estandarizaci√≥n de datos.</font></font><br>
<br>
<pre><code class="python hljs">uni_data = (uni_data-uni_train_mean)/uni_train_std
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci√≥n, prepararemos los datos para el modelo con una entrada unidimensional. </font><font style="vertical-align: inherit;">Las √∫ltimas 20 observaciones registradas de la temperatura se enviar√°n a la entrada del modelo, y el modelo debe estar entrenado para predecir la temperatura en el siguiente paso.</font></font><br>
<br>
<pre><code class="python hljs">univariate_past_history = <span class="hljs-number">20</span>
univariate_future_target = <span class="hljs-number">0</span><font></font>
<font></font>
x_train_uni, y_train_uni = univariate_data(uni_data, <span class="hljs-number">0</span>, TRAIN_SPLIT,<font></font>
                                           univariate_past_history,<font></font>
                                           univariate_future_target)<font></font>
x_val_uni, y_val_uni = univariate_data(uni_data, TRAIN_SPLIT, <span class="hljs-literal">None</span>,<font></font>
                                       univariate_past_history,<font></font>
                                       univariate_future_target)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los resultados de aplicar la funci√≥n </font></font><code>univariate_data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history'</span>)
<span class="hljs-keyword">print</span> (x_train_uni[<span class="hljs-number">0</span>])
<span class="hljs-keyword">print</span> (<span class="hljs-string">'\n Target temperature to predict'</span>)
<span class="hljs-keyword">print</span> (y_train_uni[<span class="hljs-number">0</span>])
</code></pre><br>
<code>Single window of past history<br>
[[-1.99766294]<br>
 [-2.04281897]<br>
 [-2.05439744]<br>
 [-2.0312405 ]<br>
 [-2.02660912]<br>
 [-2.00113649]<br>
 [-1.95134907]<br>
 [-1.95134907]<br>
 [-1.98492663]<br>
 [-2.04513467]<br>
 [-2.08334362]<br>
 [-2.09723778]<br>
 [-2.09376424]<br>
 [-2.09144854]<br>
 [-2.07176515]<br>
 [-2.07176515]<br>
 [-2.07639653]<br>
 [-2.08913285]<br>
 [-2.09260639]<br>
 [-2.10418486]]<br>
<br>
Target temperature to predict<br>
-2.1041848598100876<br>
</code><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s: la preparaci√≥n de datos para un modelo con una entrada unidimensional se muestra esquem√°ticamente en la siguiente figura (por conveniencia, en esta y en las figuras posteriores, los datos se presentan en forma "sin procesar", antes de la estandarizaci√≥n, y tambi√©n sin el atributo 'Fecha y hora' como √≠ndice):</font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/fa0/d0f/530/fa0d0f530b3496324425eeb5e52baff7.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ahora que los datos adecuadamente preparado, considere un ejemplo concreto. </font><font style="vertical-align: inherit;">La informaci√≥n transmitida al ANN se resalta en azul, una cruz roja indica el valor futuro que el ANN debe predecir.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_time_steps</span>(<span class="hljs-params">length</span>):</span>
  <span class="hljs-keyword">return</span> list(range(-length, <span class="hljs-number">0</span>))
</code></pre><br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_plot</span>(<span class="hljs-params">plot_data, delta, title</span>):</span>
  labels = [<span class="hljs-string">'History'</span>, <span class="hljs-string">'True Future'</span>, <span class="hljs-string">'Model Prediction'</span>]<font></font>
  marker = [<span class="hljs-string">'.-'</span>, <span class="hljs-string">'rx'</span>, <span class="hljs-string">'go'</span>]<font></font>
  time_steps = create_time_steps(plot_data[<span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>])
  <span class="hljs-keyword">if</span> delta:<font></font>
    future = delta<font></font>
  <span class="hljs-keyword">else</span>:<font></font>
    future = <span class="hljs-number">0</span><font></font>
<font></font>
  plt.title(title)<font></font>
  <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> enumerate(plot_data):
    <span class="hljs-keyword">if</span> i:<font></font>
      plt.plot(future, plot_data[i], marker[i], markersize=<span class="hljs-number">10</span>,<font></font>
               label=labels[i])<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
      plt.plot(time_steps, plot_data[i].flatten(), marker[i], label=labels[i])<font></font>
  plt.legend()<font></font>
  plt.xlim([time_steps[<span class="hljs-number">0</span>], (future+<span class="hljs-number">5</span>)*<span class="hljs-number">2</span>])<font></font>
  plt.xlabel(<span class="hljs-string">'Time-Step'</span>)
  <span class="hljs-keyword">return</span> plt
</code></pre><br>
<pre><code class="python hljs">show_plot([x_train_uni[<span class="hljs-number">0</span>], y_train_uni[<span class="hljs-number">0</span>]], <span class="hljs-number">0</span>, <span class="hljs-string">'Sample Example'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/589/38c/574/58938c5740abfb08ed0074a1233f512f.jpg" alt="imagen"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soluci√≥n b√°sica (sin involucrar el aprendizaje autom√°tico)</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Antes de comenzar la capacitaci√≥n modelo, instalaremos una soluci√≥n b√°sica simple ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l√≠nea de base</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Consiste en lo siguiente: para un vector de entrada dado, el m√©todo de soluci√≥n b√°sica "escanea" todo el historial y predice el siguiente valor como el promedio de las √∫ltimas 20 observaciones.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">baseline</span>(<span class="hljs-params">history</span>):</span>
  <span class="hljs-keyword">return</span> np.mean(history)
</code></pre><br>
<pre><code class="python hljs">show_plot([x_train_uni[<span class="hljs-number">0</span>], y_train_uni[<span class="hljs-number">0</span>], baseline(x_train_uni[<span class="hljs-number">0</span>])], <span class="hljs-number">0</span>,
           <span class="hljs-string">'Baseline Prediction Example'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/bed/941/0ef/bed9410ef6b96ad25ab68a0a3ebac05a.jpg" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos si podemos superar el resultado de "promediar" usando una red neuronal recurrente. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Red</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
neuronal recurrente </font><b><font style="vertical-align: inherit;">Una</font></b><font style="vertical-align: inherit;"> red neuronal recurrente (RNS) es un tipo de ANN que es muy adecuada para resolver problemas de series temporales. RNS paso a paso procesa la secuencia de tiempo de los datos, ordenando sus elementos y preservando el estado interno obtenido al procesar los elementos anteriores. Puede encontrar m√°s informaci√≥n sobre RNS en la siguiente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gu√≠a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esta gu√≠a utilizar√° una capa especializada de RNC llamada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memoria a largo plazo ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LSTM</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uso adicional</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">tf.data</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realizar barajado, lote y cach√© del conjunto de datos. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adici√≥n: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
M√°s informaci√≥n sobre los m√©todos de barajado, lote y cach√© en la p√°gina de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tensorflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font></i><br>
<br>
<pre><code class="python hljs">BATCH_SIZE = <span class="hljs-number">256</span>
BUFFER_SIZE = <span class="hljs-number">10000</span><font></font>
<font></font>
train_univariate = tf.data.Dataset.from_tensor_slices((x_train_uni, y_train_uni))<font></font>
train_univariate = train_univariate.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_univariate = tf.data.Dataset.from_tensor_slices((x_val_uni, y_val_uni))<font></font>
val_univariate = val_univariate.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La siguiente visualizaci√≥n deber√≠a ayudarlo a comprender c√≥mo se ven los datos despu√©s del procesamiento por lotes. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/002/e4b/3ed/002e4b3ed48fa5d17f34ccee2cbfc40d.jpg" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se puede ver que LSTM requiere una cierta forma de entrada de datos, que se le proporciona.</font></font><br>
<br>
<pre><code class="python hljs">simple_lstm_model = tf.keras.models.Sequential([<font></font>
    tf.keras.layers.LSTM(<span class="hljs-number">8</span>, input_shape=x_train_uni.shape[<span class="hljs-number">-2</span>:]),<font></font>
    tf.keras.layers.Dense(<span class="hljs-number">1</span>)<font></font>
])<font></font>
<font></font>
simple_lstm_model.compile(optimizer=<span class="hljs-string">'adam'</span>, loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verifique el resultado del modelo.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_univariate.take(<span class="hljs-number">1</span>):<font></font>
    print(simple_lstm_model.predict(x).shape)<font></font>
</code></pre><br>
<code>(256, 1)<br>
</code><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adici√≥n: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
en t√©rminos generales, los RNS funcionan con secuencias. </font><font style="vertical-align: inherit;">Esto significa que los datos suministrados a la entrada del modelo deben tener la siguiente forma: </font></font><br>
<br>
<code>[,  , - ]</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La forma de los datos de entrenamiento para el modelo con una entrada unidimensional tiene la siguiente forma:</font></font></i><br>
<br>
<code>print(x_train_uni.shape)<br>
(299980, 20, 1)</code><br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci√≥n, estudiaremos el modelo. </font><font style="vertical-align: inherit;">Debido al gran tama√±o del conjunto de datos y para ahorrar tiempo, cada √©poca pasar√° por solo 200 pasos ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">steps_per_epoch = 200</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) en lugar de los datos de entrenamiento completos, como generalmente se hace.</font></font><br>
<br>
<pre><code class="python hljs">EVALUATION_INTERVAL = <span class="hljs-number">200</span>
EPOCHS = <span class="hljs-number">10</span><font></font>
<font></font>
simple_lstm_model.fit(train_univariate, epochs=EPOCHS,<font></font>
                      steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                      validation_data=val_univariate, validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 2s 11ms/step - loss: 0.4075 - val_loss: 0.1351<br>
Epoch 2/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.1118 - val_loss: 0.0360<br>
Epoch 3/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0490 - val_loss: 0.0289<br>
Epoch 4/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0444 - val_loss: 0.0257<br>
Epoch 5/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0299 - val_loss: 0.0235<br>
Epoch 6/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0317 - val_loss: 0.0224<br>
Epoch 7/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0287 - val_loss: 0.0206<br>
Epoch 8/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0263 - val_loss: 0.0200<br>
Epoch 9/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0254 - val_loss: 0.0182<br>
Epoch 10/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0228 - val_loss: 0.0174<br>
</code><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Predicci√≥n usando un modelo LSTM simple</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Despu√©s de completar la preparaci√≥n de un modelo LSTM simple, haremos varias predicciones.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_univariate.take(<span class="hljs-number">3</span>):<font></font>
  plot = show_plot([x[<span class="hljs-number">0</span>].numpy(), y[<span class="hljs-number">0</span>].numpy(),<font></font>
                    simple_lstm_model.predict(x)[<span class="hljs-number">0</span>]], <span class="hljs-number">0</span>, <span class="hljs-string">'Simple LSTM model'</span>)<font></font>
  plot.show()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/cf8/0f6/810/cf80f681038da62889884ae5de86722d.jpg" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se ve mejor que el nivel base. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora que se ha familiarizado con los conceptos b√°sicos, pasemos a la segunda parte, que describe el trabajo con una serie de tiempo multidimensional.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 2: Predicci√≥n de series de tiempo multidimensionales</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como se indic√≥, el conjunto de datos original contiene 14 indicadores meteorol√≥gicos diferentes. </font><font style="vertical-align: inherit;">Por simplicidad y conveniencia, en la segunda parte solo se consideran tres de ellos: temperatura del aire, presi√≥n atmosf√©rica y densidad del aire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para utilizar m√°s caracter√≠sticas, sus nombres deben ser a√±adidos a la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">feature_considered</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lista </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs">features_considered = [<span class="hljs-string">'p (mbar)'</span>, <span class="hljs-string">'T (degC)'</span>, <span class="hljs-string">'rho (g/m**3)'</span>]
</code></pre><br>
<pre><code class="python hljs">features = df[features_considered]<font></font>
features.index = df[<span class="hljs-string">'Date Time'</span>]<font></font>
features.head()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/1f8/589/b51/1f8589b51d64dcd9ba10e5f072df503e.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos c√≥mo cambian estos indicadores con el tiempo.</font></font><br>
<br>
<pre><code class="python hljs">features.plot(subplots=<span class="hljs-literal">True</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/7be/266/b59/7be266b59f38be1e4c365ee8562dffcd.jpg" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como antes, el primer paso ser√° estandarizar el conjunto de datos con el c√°lculo del valor promedio y la desviaci√≥n est√°ndar de los datos de entrenamiento.</font></font><br>
<br>
<pre><code class="python hljs">dataset = features.values<font></font>
data_mean = dataset[:TRAIN_SPLIT].mean(axis=<span class="hljs-number">0</span>)<font></font>
data_std = dataset[:TRAIN_SPLIT].std(axis=<span class="hljs-number">0</span>)
</code></pre><br>
<pre><code class="python hljs">dataset = (dataset-data_mean)/data_std
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adici√≥n: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
m√°s adelante en el manual hablaremos sobre el pron√≥stico de punto e intervalo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La conclusi√≥n es la siguiente. Si necesita que el modelo prediga un valor en el futuro (por ejemplo, el valor de la temperatura despu√©s de 12 horas) (modelo de un paso / paso √∫nico), entonces debe entrenar el modelo para que prediga solo un valor en el futuro. Si la tarea es predecir el rango de valores en el futuro (por ejemplo, temperaturas por hora durante las pr√≥ximas 12 horas) (modelo de varios pasos), entonces el modelo tambi√©n debe estar capacitado para predecir el rango de valores en el futuro. </font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/906/953/08e/90695308e69c21c37e772d98553209a4.png" alt="imagen"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Predicci√≥n de puntos</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
En este caso, el modelo est√° entrenado para predecir un valor en el futuro basado en un historial disponible.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La siguiente funci√≥n realiza la misma tarea de organizar intervalos de tiempo solo con la diferencia de que aqu√≠ selecciona las √∫ltimas observaciones en funci√≥n de un tama√±o de paso dado.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">multivariate_data</span>(<span class="hljs-params">dataset, target, start_index, end_index, history_size,
                      target_size, step, single_step=False</span>):</span><font></font>
  data = []<font></font>
  labels = []<font></font>
<font></font>
  start_index = start_index + history_size<font></font>
  <span class="hljs-keyword">if</span> end_index <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
    end_index = len(dataset) - target_size<font></font>
<font></font>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start_index, end_index):<font></font>
    indices = range(i-history_size, i, step)<font></font>
    data.append(dataset[indices])<font></font>
<font></font>
    <span class="hljs-keyword">if</span> single_step:<font></font>
      labels.append(target[i+target_size])<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
      labels.append(target[i:i+target_size])<font></font>
<font></font>
  <span class="hljs-keyword">return</span> np.array(data), np.array(labels)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En esta gu√≠a, el ANN opera con datos de los √∫ltimos cinco (5) d√≠as, es decir, 720 observaciones (6x24x5). </font><font style="vertical-align: inherit;">Suponga que la selecci√≥n de datos se lleva a cabo no cada 10 minutos, sino cada hora: dentro de los 60 minutos, no se esperan cambios bruscos. </font><font style="vertical-align: inherit;">Por lo tanto, la historia de los √∫ltimos cinco d√≠as consta de 120 observaciones (720/6). </font><font style="vertical-align: inherit;">Para un modelo que realiza predicciones puntuales, el objetivo es leer la temperatura despu√©s de 12 horas en el futuro. </font><font style="vertical-align: inherit;">En este caso, el vector objetivo ser√° la temperatura despu√©s de 72 observaciones (12x6) ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ver la siguiente adici√≥n. - Traductor aprox.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<pre><code class="python hljs">past_history = <span class="hljs-number">720</span>
future_target = <span class="hljs-number">72</span>
STEP = <span class="hljs-number">6</span><font></font>
<font></font>
x_train_single, y_train_single = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>], <span class="hljs-number">0</span>,<font></font>
                                                   TRAIN_SPLIT, past_history,<font></font>
                                                   future_target, STEP,<font></font>
                                                   single_step=<span class="hljs-literal">True</span>)<font></font>
x_val_single, y_val_single = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>],<font></font>
                                               TRAIN_SPLIT, <span class="hljs-literal">None</span>, past_history,<font></font>
                                               future_target, STEP,<font></font>
                                               single_step=<span class="hljs-literal">True</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verifique el intervalo de tiempo.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history : {}'</span>.format(x_train_single[<span class="hljs-number">0</span>].shape))
</code></pre><br>
<code>Single window of past history : (120, 3)<br>
</code><br>
<pre><code class="python hljs">train_data_single = tf.data.Dataset.from_tensor_slices((x_train_single, y_train_single))<font></font>
train_data_single = train_data_single.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_data_single = tf.data.Dataset.from_tensor_slices((x_val_single, y_val_single))<font></font>
val_data_single = val_data_single.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br>
<pre><code class="python hljs">single_step_model = tf.keras.models.Sequential()<font></font>
single_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">32</span>,<font></font>
                                           input_shape=x_train_single.shape[<span class="hljs-number">-2</span>:]))<font></font>
single_step_model.add(tf.keras.layers.Dense(<span class="hljs-number">1</span>))<font></font>
<font></font>
single_step_model.compile(optimizer=tf.keras.optimizers.RMSprop(), loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verificaremos nuestra muestra y derivaremos las curvas de p√©rdida en las etapas de capacitaci√≥n y verificaci√≥n.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_single.take(<span class="hljs-number">1</span>):<font></font>
  print(single_step_model.predict(x).shape)<font></font>
</code></pre><br>
<code>(256, 1)<br>
</code><br>
<pre><code class="python hljs">single_step_history = single_step_model.fit(train_data_single, epochs=EPOCHS,<font></font>
                                            steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                                            validation_data=val_data_single,<font></font>
                                            validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 4s 18ms/step - loss: 0.3090 - val_loss: 0.2646<br>
Epoch 2/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2624 - val_loss: 0.2435<br>
Epoch 3/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2616 - val_loss: 0.2472<br>
Epoch 4/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2567 - val_loss: 0.2442<br>
Epoch 5/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2263 - val_loss: 0.2346<br>
Epoch 6/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2416 - val_loss: 0.2643<br>
Epoch 7/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2411 - val_loss: 0.2577<br>
Epoch 8/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2410 - val_loss: 0.2388<br>
Epoch 9/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2447 - val_loss: 0.2485<br>
Epoch 10/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2388 - val_loss: 0.2422<br>
</code><br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_train_history</span>(<span class="hljs-params">history, title</span>):</span>
  loss = history.history[<span class="hljs-string">'loss'</span>]<font></font>
  val_loss = history.history[<span class="hljs-string">'val_loss'</span>]<font></font>
<font></font>
  epochs = range(len(loss))<font></font>
<font></font>
  plt.figure()<font></font>
<font></font>
  plt.plot(epochs, loss, <span class="hljs-string">'b'</span>, label=<span class="hljs-string">'Training loss'</span>)<font></font>
  plt.plot(epochs, val_loss, <span class="hljs-string">'r'</span>, label=<span class="hljs-string">'Validation loss'</span>)<font></font>
  plt.title(title)<font></font>
  plt.legend()<font></font>
<font></font>
  plt.show()<font></font>
</code></pre><br>
<pre><code class="python hljs">plot_train_history(single_step_history,
                   <span class="hljs-string">'Single Step Training and validation loss'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/baa/481/4df/baa4814df5d278c7be5a4daf629ec8e0.jpg" alt="imagen"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adici√≥n: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La preparaci√≥n de datos para un modelo con una entrada multidimensional que realiza predicci√≥n de puntos se muestra esquem√°ticamente en la siguiente figura. </font><font style="vertical-align: inherit;">Por conveniencia y para una representaci√≥n m√°s visual de la preparaci√≥n de datos, el argumento </font></font><code>STEP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es 1. Tenga en cuenta que en las funciones de generador dadas, el </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">argumento est√° </font></font><code>STEP </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">destinado solo a la formaci√≥n del historial</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y no al vector objetivo. </font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bfd/c0b/ef1/bfdc0bef1203da6840adcb4311455645.png" alt="imagen"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este caso, </font></font><code>x_train_single</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiene la forma </font></font><code>(299280, 720, 3)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cu√°ndo </font></font><code>STEP=6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la forma tomar√° la siguiente forma: </font></font><code>(299280, 120, 3)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la velocidad de la funci√≥n aumentar√° significativamente. </font><font style="vertical-align: inherit;">En general, debe dar cr√©dito al programador: los generadores presentados en el manual son muy voraces en t√©rminos de consumo de memoria. </font></font></i><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Realizar una predicci√≥n puntual</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora que el modelo est√° entrenado, realizaremos varias predicciones de prueba. El historial de observaciones de 3 signos para los √∫ltimos cinco d√≠as, seleccionados cada hora (intervalo de tiempo = 120), se alimenta a la entrada del modelo. Dado que nuestro objetivo es pronosticar solo la temperatura, los valores de temperatura pasados ‚Äã‚Äã( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">historial</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) se </font><font style="vertical-align: inherit;">muestran en azul en el gr√°fico </font><font style="vertical-align: inherit;">. El pron√≥stico se realiz√≥ medio d√≠a en el futuro (de ah√≠ la brecha entre la historia y el valor predicho).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_single.take(<span class="hljs-number">3</span>):<font></font>
  plot = show_plot([x[<span class="hljs-number">0</span>][:, <span class="hljs-number">1</span>].numpy(), y[<span class="hljs-number">0</span>].numpy(),<font></font>
                    single_step_model.predict(x)[<span class="hljs-number">0</span>]], <span class="hljs-number">12</span>,
                   <span class="hljs-string">'Single Step Prediction'</span>)<font></font>
  plot.show()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/6ac/a5b/ce3/6aca5bce3fef9de56f1fac299da5527c.jpg" alt="imagen"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Predicci√≥n de intervalos</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
En este caso, sobre la base de algunos antecedentes disponibles, el modelo est√° entrenado para predecir el intervalo de valores futuros. </font><font style="vertical-align: inherit;">Por lo tanto, en contraste con un modelo que predice un solo valor en el futuro, este modelo predice una secuencia de valores en el futuro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos, como en el caso del modelo que realiza la predicci√≥n de puntos, para el modelo que realiza la predicci√≥n de intervalo, los datos de entrenamiento son las mediciones por hora de los √∫ltimos cinco d√≠as (720/6). </font><font style="vertical-align: inherit;">Sin embargo, en este caso, el modelo debe estar entrenado para predecir la temperatura durante las pr√≥ximas 12 horas. </font><font style="vertical-align: inherit;">Dado que las observaciones se registran cada 10 minutos, la salida del modelo debe consistir en 72 predicciones. </font><font style="vertical-align: inherit;">Para completar esta tarea, es necesario preparar nuevamente el conjunto de datos, pero con un intervalo objetivo diferente.</font></font><br>
<br>
<pre><code class="python hljs">future_target = <span class="hljs-number">72</span>
x_train_multi, y_train_multi = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>], <span class="hljs-number">0</span>,<font></font>
                                                 TRAIN_SPLIT, past_history,<font></font>
                                                 future_target, STEP)<font></font>
x_val_multi, y_val_multi = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>],<font></font>
                                             TRAIN_SPLIT, <span class="hljs-literal">None</span>, past_history,<font></font>
                                             future_target, STEP)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verifica la selecci√≥n.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history : {}'</span>.format(x_train_multi[<span class="hljs-number">0</span>].shape))
<span class="hljs-keyword">print</span> (<span class="hljs-string">'\n Target temperature to predict : {}'</span>.format(y_train_multi[<span class="hljs-number">0</span>].shape))
</code></pre><br>
<code>Single window of past history : (120, 3)<br>
<br>
Target temperature to predict : (72,)<br>
</code><br>
<pre><code class="python hljs">train_data_multi = tf.data.Dataset.from_tensor_slices((x_train_multi, y_train_multi))<font></font>
train_data_multi = train_data_multi.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_data_multi = tf.data.Dataset.from_tensor_slices((x_val_multi, y_val_multi))<font></font>
val_data_multi = val_data_multi.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s: la diferencia en la formaci√≥n del vector objetivo para el "modelo de intervalo" del "modelo de puntos" se ve en la siguiente figura. </font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/190/5c6/845/1905c6845d2746a1f0bc6ae88f913b99.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos a preparar la visualizaci√≥n.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">multi_step_plot</span>(<span class="hljs-params">history, true_future, prediction</span>):</span>
  plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))<font></font>
  num_in = create_time_steps(len(history))<font></font>
  num_out = len(true_future)<font></font>
<font></font>
  plt.plot(num_in, np.array(history[:, <span class="hljs-number">1</span>]), label=<span class="hljs-string">'History'</span>)<font></font>
  plt.plot(np.arange(num_out)/STEP, np.array(true_future), <span class="hljs-string">'bo'</span>,<font></font>
           label=<span class="hljs-string">'True Future'</span>)
  <span class="hljs-keyword">if</span> prediction.any():<font></font>
    plt.plot(np.arange(num_out)/STEP, np.array(prediction), <span class="hljs-string">'ro'</span>,<font></font>
             label=<span class="hljs-string">'Predicted Future'</span>)<font></font>
  plt.legend(loc=<span class="hljs-string">'upper left'</span>)<font></font>
  plt.show()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este y en cuadros similares posteriores, el historial y los datos futuros son por hora.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> train_data_multi.take(<span class="hljs-number">1</span>):<font></font>
  multi_step_plot(x[<span class="hljs-number">0</span>], y[<span class="hljs-number">0</span>], np.array([<span class="hljs-number">0</span>]))
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/245/beb/236/245beb236bc1f87f2d611ce8d2c0bc81.jpg" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que esta tarea es un poco m√°s complicada que la anterior, el modelo constar√° de dos capas LSTM. </font><font style="vertical-align: inherit;">Finalmente, dado que se realizan 72 predicciones, la capa de salida tiene 72 neuronas.</font></font><br>
<br>
<pre><code class="python hljs">multi_step_model = tf.keras.models.Sequential()<font></font>
multi_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">32</span>,<font></font>
                                          return_sequences=<span class="hljs-literal">True</span>,<font></font>
                                          input_shape=x_train_multi.shape[<span class="hljs-number">-2</span>:]))<font></font>
multi_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">16</span>, activation=<span class="hljs-string">'relu'</span>))<font></font>
multi_step_model.add(tf.keras.layers.Dense(<span class="hljs-number">72</span>))<font></font>
<font></font>
multi_step_model.compile(optimizer=tf.keras.optimizers.RMSprop(clipvalue=<span class="hljs-number">1.0</span>), loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verificaremos nuestra muestra y derivaremos las curvas de p√©rdida en las etapas de capacitaci√≥n y verificaci√≥n.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_multi.take(<span class="hljs-number">1</span>):
  <span class="hljs-keyword">print</span> (multi_step_model.predict(x).shape)
</code></pre><br>
<code>(256, 72)<br>
</code><br>
<pre><code class="python hljs">multi_step_history = multi_step_model.fit(train_data_multi, epochs=EPOCHS,<font></font>
                                          steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                                          validation_data=val_data_multi,<font></font>
                                          validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 21s 103ms/step - loss: 0.4952 - val_loss: 0.3008<br>
Epoch 2/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.3474 - val_loss: 0.2898<br>
Epoch 3/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.3325 - val_loss: 0.2541<br>
Epoch 4/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.2425 - val_loss: 0.2066<br>
Epoch 5/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.1963 - val_loss: 0.1995<br>
Epoch 6/10<br>
200/200 [==============================] - 18s 90ms/step - loss: 0.2056 - val_loss: 0.2119<br>
Epoch 7/10<br>
200/200 [==============================] - 18s 91ms/step - loss: 0.1978 - val_loss: 0.2079<br>
Epoch 8/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.1957 - val_loss: 0.2033<br>
Epoch 9/10<br>
200/200 [==============================] - 18s 90ms/step - loss: 0.1977 - val_loss: 0.1860<br>
Epoch 10/10<br>
200/200 [==============================] - 18s 88ms/step - loss: 0.1904 - val_loss: 0.1863<br>
</code><br>
<pre><code class="python hljs">plot_train_history(multi_step_history, <span class="hljs-string">'Multi-Step Training and validation loss'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/479/600/430/4796004305bd5b839ead7c35120ddc69.png" alt="imagen"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Realizaci√≥n de una predicci√≥n de intervalo</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Entonces, descubramos cu√°n exitosamente un ANN capacitado hace frente a los pron√≥sticos de valores de temperatura futuros.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_multi.take(<span class="hljs-number">3</span>):<font></font>
  multi_step_plot(x[<span class="hljs-number">0</span>], y[<span class="hljs-number">0</span>], multi_step_model.predict(x)[<span class="hljs-number">0</span>])
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/a3a/2fa/3cd/a3a2fa3cd17ec79c04d9ab44a3d3ad2c.jpg" alt="imagen"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pr√≥ximos pasos</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta gu√≠a es una breve introducci√≥n al pron√≥stico de series de tiempo usando RNS. Ahora puede intentar predecir el mercado de valores y convertirse en multimillonario </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(en el original, as√≠ como as√≠ :). - Nota traductor)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, puede escribir su propio generador para preparar datos en lugar de la funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uni / multivariate_data</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para hacer un uso m√°s eficiente de la memoria. Tambi√©n puede familiarizarse con el trabajo de " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ventanas de series temporales</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " y aportar sus ideas a esta gu√≠a. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para una mayor comprensi√≥n, se recomienda que lea el Cap√≠tulo 15 del libro </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Aprendizaje autom√°tico aplicado con Scikit-Learn, Keras y TensorFlow"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Aurelien Geron, 2¬™ edici√≥n) y el Cap√≠tulo 6 del libro</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Aprendizaje profundo en Python"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Francois Scholl). </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adici√≥n final </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mientras est√© en casa, cuide no solo su salud, sino que tambi√©n se compadezca de la computadora ejecutando ejemplos del manual en un conjunto de datos truncado. </font><font style="vertical-align: inherit;">Por ejemplo, teniendo en cuenta la proporci√≥n de 70x30 (entrenamiento / prueba), puede limitarlo de la siguiente manera:</font></font></i><br>
<br>
<pre><code class="python hljs">dataset = features[<span class="hljs-number">300000</span>:].values<font></font>
TRAIN_SPLIT = <span class="hljs-number">85000</span></code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es495854/index.html">¬øC√≥mo escapar de Covid y de la vigilancia?</a></li>
<li><a href="../es495856/index.html">Intel DevCloud para oneAPI: un servicio en la nube para desarrolladores que se sientan en casa</a></li>
<li><a href="../es495858/index.html">Remoto y autoaislamiento: experiencia espacial para ayudar a los terr√≠colas</a></li>
<li><a href="../es495870/index.html">Consejos y trucos para trabajar con Ceph en proyectos ocupados</a></li>
<li><a href="../es495880/index.html">El libro "Cabeza primero. Learning Go ¬ª</a></li>
<li><a href="../es495888/index.html">PyCon Russia ha abierto CFP para futuros oradores. Formularios de participaci√≥n y temas esperados</a></li>
<li><a href="../es495890/index.html">Configuraci√≥n de paquetes Nginx / LetsEncrypt en Docker Swarm</a></li>
<li><a href="../es495892/index.html">¬øRealmente sabes qu√© son las matrices?</a></li>
<li><a href="../es495894/index.html">Medici√≥n del rendimiento de Javascript</a></li>
<li><a href="../es495896/index.html">Paquete de uso de sonido: efectos de sonido en aplicaciones de reacci√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>