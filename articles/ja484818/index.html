<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍰 😤 🤞🏽 本「C ++。マルチスレッドプログラミングの実践」 ✍🏾 👈🏾 🧛🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、habrozhiteli！本当に超高速のアプリケーションを作成する必要がある場合は、C ++言語が選択されます。そして、高品質の競争力のある処理は、それらをさらに速くします。 C ++ 17の新機能を使用すると、マルチスレッドプログラミングの全機能を使用して、グラフィック処理や機械学習な...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>本「C ++。マルチスレッドプログラミングの実践」</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/484818/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/cr/ym/3u/crym3urkeecjcfe-nsvq0nrw59y.jpeg" align="left" alt="画像"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、habrozhiteli！本当に超高速のアプリケーションを作成する必要がある場合は、C ++言語が選択されます。そして、高品質の競争力のある処理は、それらをさらに速くします。 C ++ 17の新機能を使用すると、マルチスレッドプログラミングの全機能を使用して、グラフィック処理や機械学習などの問題を簡単に解決できます。競合処理のエキスパートであるAnthony Williamsは、例を検討し、実践的なタスクを説明するだけでなく、すべての人に役立つ秘密を共有します。最も経験豊富な開発者を含みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本の中•C ++ 17の機能の完全な概要。 •起動とフロー制御。 •競合するオペレーションの同期。 •競争力のあるコードの開発。 •マルチスレッドアプリケーションのデバッグ。この本は、CおよびC ++を使用する中級レベルの開発者に適しています。競争力のあるプログラミングの経験は必要ありません。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">競争力のあるコード開発</font></font></h3><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.1。</font><font style="vertical-align: inherit;">スレッド間で作業を分散する方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
家を建てる必要があると想像してみてください。</font><font style="vertical-align: inherit;">これを行うには、基礎穴を掘り、基礎自体を埋め、壁を直立させ、パイプと電気配線を敷設する必要があります。理論的には、十分なスキルがあれば、すべてを個別に実行できますが、多くの場合、時間がかかり、1つのジョブから次のジョブに切り替える必要があります。別のもの。</font><font style="vertical-align: inherit;">しかし、あなたはアシスタントを雇うことができます。</font><font style="vertical-align: inherit;">次に、雇うアシスタントの数を選択し、何ができるようにするかを決定する必要があります。</font><font style="vertical-align: inherit;">たとえば、2人の労働者を雇い、一緒に働くことができます。</font><font style="vertical-align: inherit;">その後、ある作品から別の作品に切り替える必要がありますが、アーティストの数が増えるため、状況はより速くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のオプションを選択できます-煉瓦工、大工、電気技師、配管工などの専門家チームを雇います。それぞれが自分の専門分野で作業するので、配管工が作業現場になるまで、彼はアイドル状態になります。それでも、労働者の数が増えるため、物事は以前よりも速く進み、電気技師がキッチンで配線を行う間、配管工はバスルームに行くことができます。ただし、特定のスペシャリストの仕事がない場合は、より多くのダウンタイムが発生します。ただし、ダウンタイムを考慮に入れても、労働者のチームよりも専門家が作業するほうが作業が速くなることに注意してください。スペシャリストは常にツールを交換する必要はありません。確かに、各スタッフが作業員よりも早く作業を実行できます。これが実際にそうなるかどうかは、特定の状況に依存します。すべては実際に学習されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたが専門家を巻き込んだとしても、さまざまな専門の異なる数の労働者を選ぶ必要があります。おそらく、たとえば電気技師よりも多くの石工を雇うことは理にかなっています。さらに、一度に複数の家を建てなければならない場合、チームの構成とその作業の全体的な効果が変わる可能性があります。一戸建てで配管工の仕事が少ない場合でも、一度に複数の家を建てる場合は、一日中かかる可能性があります。さらに、ダウンタイムに対してスペシャリストに支払う必要がない場合は、同時に作業する人数が変わらなくても、より大きなチームを採用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、建設について話すのをやめてください。これはすべてスレッドと何の関係があるのでしょうか？また、同様の考慮事項をそれらに適用できます。使用するスレッドの数と実行するタスクを決定する必要があります。特定の瞬間に必要な作業を行うためにユニバーサルスレッドが必要ですか、それとも、1つのことにうまく適応しているスペシャリストフローですか？または、両方を組み合わせる価値はありますか？これらの決定は、プログラムの並列化の理由に関係なく行う必要があり、コードのパフォーマンスと明確さは、それらがどれだけ成功するかに大きく依存します。したがって、アプリケーション構造を開発する際に適切な決定を下すためには、どのようなオプションが利用できるかを想像することが非常に重要です。このセクションでは、スレッド間でのデータの分散から他の作業の実行まで、タスクを分散するためのいくつかの方法を検討します。</font></font><br>
<br>
<h3>8.1.1.       </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並列化が最も簡単なのは、std :: for_eachなどの単純なアルゴリズムで、データセットの各要素に対して操作を実行します。このアルゴリズムを並列化するには、各要素を処理スレッドの1つに割り当てます。将来的には、パフォーマンスの問題を考慮すると、最適なパフォーマンスを実現するための最適な分散オプションがデータ構造の特性に依存することが明らかになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データを分配するとき、最初のN個の要素が1つのストリームに割り当てられ、次のN個の要素が別のストリームに割り当てられる場合などに、最も単純なオプションが考慮されます（図8.1）。データ分散の方法に関係なく、各スレッドは、割り当てられた要素のみを処理し、処理が完了するまで他のスレッドと対話しません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ie/ex/rm/ieexrmf49u6qerfqmuhtcgpbgpe.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この構造は、メッセージパッシングインターフェース（MPI、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.mpi-forum.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）またはOpenMP（http://www.openmp.org/）</font><font style="vertical-align: inherit;">でプログラミングを扱ってきたすべての人に馴染みがあるはず</font><font style="vertical-align: inherit;">です。タスクは、並行して実行される多くのタスクに分割されます。ワークフローはそれらを互いに独立して実行し、結果は情報の最終段階で収集されます。このアプローチは、セクション2.4のaccumulate関数を使用した例で使用されました。並列タスクとリダクションステージの両方が累積されます。単純なfor_eachアルゴリズムの場合、削減するものが何もないため、最後のステップが欠落しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ミックスが最終ステージのエッセンスとして定義されているという事実は非常に重要な役割を果たします。リスト2.9に示すような基本的な実装は、このミックスを最終的な順次ステージとして実行します。しかし、多くの場合、このステージは並列化されます。累積はリダクション操作であるため、たとえば、スレッドの数がスレッドによって処理される要素の最小数より大きい場合、リスト2.9のコードを変更して同じコードの再帰呼び出しを取得できます。また、毎回新しいスレッドを開始するのではなく、ワークフローが強制的にロールアップ手順を実行するように強制することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのすべての有効性のために、この手法は多目的ではありません。</font><font style="vertical-align: inherit;">各パーツの構成は処理中にしかわからないため、事前にデータを正確に分割できない場合があります。</font><font style="vertical-align: inherit;">特に、これはQuicksortなどの再帰的アルゴリズムを使用する場合に明らかであるため、別のアプローチが必要です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.1.2。</font><font style="vertical-align: inherit;">再帰的なデータ配布</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クイックソートアルゴリズムには2つの主要な段階があります。データを2つの部分に分割します-要素（参照）の1つまでのすべてと、その後の最終的なソート順のすべてと、これら2つの半分の再帰的ソートです。要素の処理中にデータがどの「半分」に該当するかを判断することしかできないため、データを事前に分割して並列化することは不可能です。このアルゴリズムを並列化する場合は、再帰の本質を使用する必要があります。再帰の各レベルでは、参照よりも大きいものとそれよりも小さいものの両方をソートする必要があるため、quick_sort関数の呼び出しがますます多く実行されます。これらの再帰呼び出しは、要素の個別のセットを参照するため、互いに独立しています。このため、彼らは競争力の最初の候補です。この再帰的分布を図6に示します。 8.2。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この実装は第4章ですでに満たされています。大きい半分と小さい半分に対して2つの再帰呼び出しを行う代わりに、各ステップで小さい半分の非同期タスクを実行するstd :: async（）関数を使用しました。 std :: async（）を使用しているため、C ++スレッドライブラリは、タスクを新しいスレッドで開始するタイミングと、同期モードのタイミングを決定する必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要な状況が1つあります。大きなデータセットをソートする場合、再帰ごとに新しいスレッドを開始すると、スレッド数が急激に増加します。パフォーマンスの問題を調べると、スレッドが多すぎるとアプリケーションの速度が低下する可能性があることがわかります。さらに、大量のデータフローでは、単に十分ではない場合があります。このような再帰モードでタスク全体を分割するというアイデアは非常に成功しているように見えます。スレッド数を注意深く監視するだけで済みます。単純なケースでは、std :: async（）関数がこれを処理しますが、他のオプションがあります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rz/ji/l3/rzjil3fye0-nfj2quxo75cvxon4.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらの1つは、std :: thread :: hardware_concurrency（）関数を使用して、スレッドの数を選択することです（リスト2.9のaccumulate（）関数の並列バージョンで行われたように）。次に、再帰呼び出しごとに新しいスレッドを開始する代わりに、フラグメントをソートして、スレッドセーフスタックに配置できます（たとえば、第6章と第7章で説明）。スレッドが何もしない場合、またはスレッドがすべてのフラグメントの処理を完了した場合、またはフラグメントのソートを待機している場合、スタックからフラグメントを取り出してソートします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リスト8.1は、このテクノロジーの簡単な実装を示しています。他のほとんどの例と同様に、これは意図を示すだけであり、実際に使用できるコードではありません。 C ++ 17コンパイラを使用していて、ライブラリがそれをサポートしている場合は、第10章の説明に従って、標準ライブラリが提供する並列アルゴリズムを使用する必要があります</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。並べ替えを待機しているフラグメントのスタックを使用する並列Quicksortアルゴリズム。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ko/nb/h6/konbh6b_q40lp0uz-gxyunwws3g.png" alt="画像"><br>
<img src="https://habrastorage.org/webt/5s/md/52/5smd5279wgwzktq4thil54lidqy.png" alt="画像"><br>
<img src="https://habrastorage.org/webt/ro/js/kt/rojsktncuxgmls2wtndzt9ywhqy.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、parallel_quick_sort </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（19）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数は、機能責任の大部分をソーター</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">割り当て</font><font style="vertical-align: inherit;">ます。これ</font><font style="vertical-align: inherit;">により、</font><font style="vertical-align: inherit;">並べ替え</font><font style="vertical-align: inherit;">られて</font><font style="vertical-align: inherit;">いないフラグメント</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（2）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と複数のスレッド</font><b><font style="vertical-align: inherit;">（3）の</font></b><font style="vertical-align: inherit;">スタックを簡単にグループ化できます。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。主な作業は</font><font style="vertical-align: inherit;">、通常のデータ分割</font><b><font style="vertical-align: inherit;">（10）</font></b><font style="vertical-align: inherit;">によって占有される</font><font style="vertical-align: inherit;">do_sortコンポーネント関数</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（9）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で実行され</font><font style="vertical-align: inherit;">ます。今回は、フラグメントごとに新しいスレッドを開始する代わりに、このフラグメントをスタックにプッシュし（11）、空きプロセッサリソースがある場合にのみ新しいスレッドを開始します（12）。参照のものよりも小さい値のフラグメントは別のストリームで処理できるため、準備ができるまで待つ必要があります</font><b><font style="vertical-align: inherit;">（13）</font></b><font style="vertical-align: inherit;">。時間を無駄にしないようにするため（単一のスレッドがある場合、または他のすべてのスレッドがすでに占有されている場合）、この待機期間の間、スタックからのフラグメントを処理しようとします</font><b><font style="vertical-align: inherit;">（14）</font></b><font style="vertical-align: inherit;">。 try_sort_chunk関数はスタックからフラグメントを取得します</font><b><font style="vertical-align: inherit;">（7）</font></b></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それをソートし</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（8）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、結果をpromise promiseに保存します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これにより、このフラグメントをスタックに置くストリームを受信できます</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（15）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、起動されたスレッドはループになり</font><font style="vertical-align: inherit;">、end_of_data </font><b><font style="vertical-align: inherit;">（16）</font></b><font style="vertical-align: inherit;">フラグが設定されていない場合は</font><font style="vertical-align: inherit;">、スタック</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（17）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からフラグメントをソートしようとします</font><font style="vertical-align: inherit;">。チェックの合間には、他のスレッドにコンピューティングリソースをあきらめるため、スタックに追加の作業を行うことができます。これらのスレッドの順序付けに関するコードの操作は、ソーター</font><b><font style="vertical-align: inherit;">（4）</font></b><font style="vertical-align: inherit;">クラスのデストラクタによって異なります</font><font style="vertical-align: inherit;">。すべてのデータがソートされると、do_sort関数は制御を返し（ワーカースレッドのアクティビティを維持している間も）、メインスレッドはparallel_quick_sort </font><b><font style="vertical-align: inherit;">（20）</font></b><font style="vertical-align: inherit;">から戻ります。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソーターオブジェクトを破棄します。 end_of_dataフラグを設定し</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（5）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、スレッドが機能</font><font style="vertical-align: inherit;">するのを待つ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（6）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラグを設定すると、スレッド関数のループが停止します（16）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチでは、新しいスレッドを起動したspawn_task関数に固有の無制限のスレッド数の問題がなくなり、std :: async（）を使用する場合のように、スレッド数を選択するC ++スレッドライブラリへの依存がなくなります。代わりに、タスクが頻繁に切り替わらないようにするために、スレッド数はstd :: thread :: hardware_concurrency（）関数によって返される値によって制限されます。しかし、別の問題が発生します。これらのストリームを管理し、それらの間でデータを交換すると、コードが非常に複雑になります。さらに、スレッドは個々のデータ要素を処理するという事実にもかかわらず、それらはすべてスタックにアクセスし、新しいフラグメントを追加して、処理のためにフラグメントを取得します。このような激しい競争は、ロックフリー（つまり、非ブロッキング）スタックが使用されている場合でも、パフォーマンスを低下させる可能性があります。そして、その理由はすぐに検討されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは、特別なバージョンのスレッドプールです。それぞれが遅延ジョブのリストから作業を受け取り、それを実行してから、新しいジョブのリストに切り替えます。スレッドプールに固有のいくつかの潜在的な問題（作品のリストにアクセスするときの競合を含む）とそれらを解決する方法については、第9章で説明します。作成したアプリケーションをスケーリングして、複数のプロセッサで実行できるようにする方法については、この章の後半で詳しく説明します（「 8.2.1項）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
処理前と再帰モードの両方でデータを配布する場合は、事前に固定されているものとし、配布の検索を行っています。</font><font style="vertical-align: inherit;">ただし、これが常に発生するわけではありません。データが動的モードで作成された場合、または外部ソースから取得された場合、このアプローチは機能しません。</font><font style="vertical-align: inherit;">この場合、データ自体に基づくのではなく、タスクのタイプに応じて作業を分散する方が賢明です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.1.3。</font><font style="vertical-align: inherit;">タスクタイプごとの作業の分散</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッドごとに（データ処理中に事前にまたは再帰的に）異なるデータを割り当てることによるスレッド間の作業の分散は、どのような場合でも、スレッドが各部分に対して同じ作業を行うことを前提としています。代替の作業の分配は、配管工と電気技師が家を建てるときにさまざまなタスクを実行するときに、それぞれが個別のタスクを実行するフローの特殊化です。ストリームは異なるデータまたは同じデータを処理できますが、後者の場合、異なる目的で処理します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この特異な労働の分割は、競合の助けを借りてタスクを分離した結果として発生します。各スレッドには個別のタスクがあり、他のフローとは独立して実行されます。</font><font style="vertical-align: inherit;">他のスレッドがデータをストリームに配信したり、応答する必要のあるイベントを生成したりすることがありますが、通常、各ストリームは単一のタスクの品質に集中します。</font><font style="vertical-align: inherit;">これは優れた基本設計であり、コードの各部分が1つのことに責任を持つ必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">責任を共有するためのタスクの種類ごとの作業の分散</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シングルスレッドアプリケーションは、特定の時間に継続して実行する必要があるいくつかのタスクがある場合、またはアプリケーションがタイムリーに着信イベントの処理に対応する必要がある場合（たとえば、ユーザーがキーを押すか、データがネットワーク経由で送信される場合）、単一責任の原則に関連する競合に対処する必要があります。他の未完了のタスクの存在下で。シングルスレッドコンピューティング環境では、タスクAの一部、タスクBの一部を実行するコードを個別に作成し、キーが押され、ネットワークパケットがないかどうかを確認してから、タスクAの次の部分にサイクルバックする必要があります。これにより、実行するコードが複雑になります。タスクAその状態を維持し、定期的に制御をメインループに戻す必要があるため。サイクルに追加するタスクが多すぎると、作業が大幅に遅くなる可能性があり、ユーザーはキーストロークに対する反応が遅いことに気づく可能性があります。特定のアプリケーションで同様の状況の極端な兆候を誰もが観察したと確信しています。アプリケーションのタスクを設定し、完了するまでインターフェイスは何にも反応しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで流れがステージに入ります。各タスクを個別のスレッドで実行する場合、オペレーティングシステムはユーザーの代わりにこれを実行できます。タスクAのコードでは、状態を維持してメインループに戻ることや、これが発生するまでの時間を気にすることなく、タスクの完了に集中できます。つまり、オペレーティングシステムは自動的に状態を保存し、適切なタイミングでタスクBまたはCに切り替えます。プログラムが実行されるシステムに複数のコアまたはプロセッサがある場合、タスクAとBを同時に実行できます。キーストロークまたはレシートを処理するためのコードネットワークパケットをタイムリーに実行できるようになり、すべての人にメリットがあります。ユーザーは適切なプログラム応答を受け取り、開発者は簡単なコードを受け取ります。なぜなら、各ストリームは、制御ストリームやユーザーとの相互作用と混合することなく、その職務に直接関連する操作を実行するように指示されるからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理想的な写真が浮上しています。しかし、それはすべてそのように判明するのでしょうか？いつものように、それはすべて特定の状況に依存します。完全な独立性が尊重され、フローが互いにデータを交換する必要がない場合は、まさにそれが起こります。残念ながら、同様の状況はほとんど発生しません。多くの場合、ユーザーに必要なアクションは便利なバックグラウンドタスクの形式であり、ユーザーにタスクについて通知し、何らかの方法でユーザーインターフェイスを更新する必要があります。または、ユーザーがタスクを停止する必要がある場合があるため、ユーザーインターフェイスはなんらかの理由でメッセージをバックグラウンドタスクに送信して、タスクの実行を停止する必要があります。どちらの場合も、慎重な設計と適切な同期が必要です。ただし、実行されるタスクは断片化されたままになります。ユーザーインターフェイススレッドは引き続きこのインターフェイスを制御しますが、他のスレッドからの要求に応じて更新を実行するように割り当てることができます。バックグラウンドタスクを実装するスレッドは、それを完了するために必要な操作に集中します。また、バックグラウンドスレッドの1つがタスクが他のスレッドを停止できるようにすることも起こります。どちらの場合も、フローはリクエストがどこから来たのかを気にせず、フローが意図されており、その責任に直接関係しているという事実のみを気にします。バックグラウンドスレッドの1つが、タスクが別のスレッドを停止できるようにする。どちらの場合も、フローはリクエストがどこから来たのかを気にせず、フローが意図されており、その責任に直接関係しているという事実のみを気にします。バックグラウンドスレッドの1つが、タスクが別のスレッドを停止できるようにする。どちらの場合も、フローはリクエストがどこから来たのかを気にせず、フローが意図されており、その責任に直接関係しているという事実のみを気にします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のスレッド間で責任を共有することには、2つの重大な危険があります。まず、不適切な責任が分散していることが判明する場合があります。この兆候は、ストリームによって共有されているデータが多すぎるか、または異なるストリームがお互いに待たなければならないという事実です。どちらの場合も、ストリーム間のデータ交換が多すぎます。この交換の理由に対処する必要があります。それが同じ理由で発生した場合、これらのスレッドが行うすべてのことは1つのスレッドの主な責任であり、以前に占有されていたすべてのスレッドは解放されるべきです。 2つのストリーム間で集中的なデータ交換があり、他のストリーム間でのストレスがはるかに少ない場合は、おそらくこれら2つのストリームを1つに結合する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクのタイプに基づいてスレッド間で作業を分割する場合、完全に分離されたオプションに限定するべきではありません。</font><font style="vertical-align: inherit;">複数の入力データのセットが適用される操作の同じシーケンスを必要とする場合、各スレッドが共通のシーケンスから1つのステージを実行するように作業を分散できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッド間のタスクシーケンスの分散</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクの本質が多くの独立したデータ要素に同じ一連の操作を適用することである場合、パイプラインを使用して、システムで使用可能な競合ツールを使用できます。実際のパイプラインとの類似点があります。一方の端に到着したデータは一連の操作を通過し、もう一方の端を離れます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この作業の分散により、パイプラインステージごとに個別のスレッドが作成されます-シーケンス内の操作ごとに1つのスレッド。操作が完了すると、データ項目はキューに入れられ、そこから次のスレッドがそれを取得します。これにより、シーケンスの最初の操作を実行するスレッドが次のデータ要素の処理を開始し、2番目のパイプラインストリームが最初の要素を処理します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8.1.1項で説明した、フロー間のデータ分散の代替バリアントは、操作の開始時に入力データについて何も知られていない場合に適しています。たとえば、データがネットワーク経由で送信される場合や、シーケンスの最初の操作が、処理中のファイルを特定するためのファイルシステムスキャンである場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パイプラインは、シーケンスの各操作に時間がかかる状況にうまく対応します。データではなく、タスクフロー間の分散により、パフォーマンスプロファイルを変更できます。 4つのコアで処理するために20のデータ要素があり、各データ要素に4つの処理ステップが必要で、それぞれに3秒かかると仮定します。 4つのストリームにデータを分散する場合、それぞれに5つの処理された要素があります。タイミングに影響を与える可能性のある他の処理がないと想定した場合、12秒後に4つの要素が処理され、24秒後に8つの要素が処理されます。20要素すべてが1分で処理されます。そして、コンベヤでは、すべてが異なる方法で行われます。利用可能な4つのステップのそれぞれをプロセッシングコアに割り当てることができます。これで、最初の要素は各コアで処理されます。したがって、以前と同様に、12秒ほどかかります。 12秒後には1つの要素のみが処理されることがわかりました。これは、データ分散オプションからのインジケーターの点で遅れています。しかし、パイプラインがいっぱいになるとすぐに状況が変化します。最初のコアは最初の要素を処理し、2番目の要素の処理に進みます。したがって、最後のコアが最初の要素を処理するとすぐに、2番目の要素の処理段階を実行できます。これで、各要素は12秒ごとに4つのバッチで要素を処理するのではなく、3秒ごとに処理されます。したがって、最後のコアが最初の要素を処理するとすぐに、2番目の要素の処理段階を実行できます。これで、各要素は12秒ごとに4つのバッチで要素を処理するのではなく、3秒ごとに処理されます。したがって、最後のコアが最初の要素を処理するとすぐに、2番目の要素の処理段階を実行できます。これで、各要素は12秒ごとに4つのバッチで要素を処理するのではなく、3秒ごとに処理されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後のコアが最初の要素の処理を開始するまでに9秒かかるため、パケット全体の合計処理時間は増加します。ただし、特定の状況下では、よりスムーズで測定された処理よりも望ましい場合があります。たとえば、高解像度のデジタルビデオ表示システムについて考えてみます。快適なビデオ表示のためには、通常、少なくとも毎秒25フレーム、理想的にはそれ以上のデモを行う必要があります。さらに、ユーザーが連続的な動きのように見せるためには、すべてが均等に行われる必要があります。1秒あたり100フレームをデコードできるアプリケーションは、1秒間停止してから100フレームを表示し、さらに1秒間停止して次の100フレームを表示すると役に立たなくなります。 。同時に、視聴者は動画を見る前に2秒間の休止を気にしないでしょう。この場合、一定のペースでフレームを生成するコンベヤを使用して並列化することはもちろん好ましい。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッド間で作業を分散するさまざまな方法を検討したので、マルチスレッドシステムのパフォーマンスに影響を与える要因と、メソッドを選択するときにそれらをどのように考慮するかについて話しましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.2。</font><font style="vertical-align: inherit;">競合するコードのパフォーマンスに影響を与える要因</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のプロセッサを搭載したシステムで競争力を使用してコードのパフォーマンスを向上させる場合は、パフォーマンスに影響を与える可能性のある要因に注意する必要があります。</font><font style="vertical-align: inherit;">複数のスレッドを使用して責任を共有する場合でも、これがパフォーマンスに影響しないことを確認する必要があります。</font><font style="vertical-align: inherit;">古いシングルコアコンピューターよりも16コアの素晴らしいマシンでアプリケーションの実行速度が遅くても、消費者は感謝しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すぐに示されるように、マルチスレッドコードのパフォーマンスには多くの要因が影響します。各スレッドによって処理されるデータ要素を再配置するなどの単純なもの（他はすべて変更されないまま）でも、パフォーマンスが大幅に低下する可能性があります。</font><font style="vertical-align: inherit;">そして今、長い前書きなしで、最も明白なものから始めて、これらの要因のいくつかを考えてみましょう：ターゲットシステム上にはいくつのプロセッサがありますか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.2.1。</font><font style="vertical-align: inherit;">また、プロセッサはいくつありますか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセッサの数（および構造）は、マルチスレッドアプリケーションのパフォーマンスに影響を与え、非常に重要な役割を果たす最初の重要な要素です。ターゲット機器がどうなるかが正確にわかっている場合があり、この情報を考慮して開発を行い、ターゲットシステムまたはその正確なコピーの実際の測定値を取得できます。この場合、あなたは幸運ですが、通常は運が通り過ぎます。開発は同様のシステムで行うことができますが、その違いは大きくなる可能性があります。たとえば、プログラムは2つまたは4つのコアを持つシステムで開発されますが、コンシューマーシステムは1つのマルチコアプロセッサー（コア数は任意）または複数のシングルコアまたはマルチコアプロセッサーを持つことができます。競争的に設計されたプログラムの動作とパフォーマンスの特性、さまざまな状況下では、状況が大きく異なる可能性があるため、考えられる影響について真剣に検討し、可能であればすべてをテストする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の概算では、1つの16コアプロセッサは4つのクアッドコアプロセッサまたは16のシングルコアプロセッサに似ています。いずれの場合も、システム内で同時に16スレッドを起動できます。これを使用する必要がある場合、アプリケーションには少なくとも16のスレッドが必要です。それらの数が少ない場合、システムが同時に別のアプリケーションを起動しない限り、計算能力は要求されないままになります（今はこの可能性を無視します）。同時に、イベントの発生を待機してブロックされていない16個を超える作業準備の整ったスレッドがある場合、アプリケーションは、第1章で説明したように、スレッド間のCPU時間の切り替えを浪費します。この状況はオーバーサブスクリプションと呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションがアクティブスレッドの数を既存の機器で同時に起動できるスレッドの数に調整できるように、標準スレッドライブラリC ++ 11（標準スレッドライブラリ）は関数std :: thread :: hardware_concurrency（）を提供します。すでに、それを使用して、機器の機能に応じてスレッド数をスケーリングできることを示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
std :: thread :: hardware_concurrency（）関数を直接使用する場合は注意が必要です。この情報を明示的に共有するまで、システムで実行されている他のスレッドはコードを考慮しません。最悪のシナリオでは、複数のスレッドがstd :: thread :: hardware_concurrency（）を使用して関数を同時に呼び出してスケーリングすると、コンピューティング機能の再評価が発生する可能性があります。ライブラリはすべての呼び出しを認識しており、スケジューリングを処理できるため、std :: async（）関数はこの問題を回避します。スレッドプールを適切に使用することによって、問題を取り除くこともできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、アプリケーションで実行されているすべてのスレッドを考慮しても、同時に動作している他のアプリケーションの影響は残ります。シングルユーザーシステムで集中的に消費するいくつかのCPUリソースを同時に使用することは、かなりまれなケースですが、これが通常よりも頻繁に発生する領域がいくつかあります。このシナリオ用に設計されたシステムは通常、各アプリケーションが適切な数のスレッドを選択できるメカニズムを提供しますが、そのようなメカニズムはC ++標準の範囲に適合しません。 std :: async（）のような関数のオプションの1つは、スレッド数を選択するときにすべてのアプリケーションによって起動される非同期タスクの総数を考慮することです。別のオプションは、コアの数を制限することです特定のアプリケーションで使用できます。この制限はstd :: thread :: hardware_concurrency（）関数によってそのようなプラットフォームで返される値に反映されることが期待されますが、そのような結果は保証されません。このシナリオに対処する必要がある場合は、システムのドキュメントを参照して、これらのオプションが利用可能かどうかを確認してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状況の別のニュアンスは、この問題を解決するための理想的なアルゴリズムが、計算ユニットの数と比較してその規模に依存する可能性があることです。多くのコンピューティングユニットを備えた強力な並列システムがある場合、一般に、より多くの演算を実行するアルゴリズムは、より少ない演算を実装するアルゴリズムよりも速くタスクに対処できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセッサの数が増えると、別の問題がパフォーマンスに影響を与える可能性も高くなります-複数のプロセッサによる同じデータへのアクセスの試み。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
»本の詳細については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版社のウェブサイトをご覧ください</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目次</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抜粋</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Khabrozhiteleyの場合、クーポンの25％割引</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-C ++</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
本の紙のバージョンの支払い時に、電子本が電子メールで送信されます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja484806/index.html">cPanelとPlesk Obsidianの違い</a></li>
<li><a href="../ja484808/index.html">10年間オンコール。何を学びましたか？（レビューとビデオレポート）</a></li>
<li><a href="../ja484812/index.html">Pleskでの私の経験</a></li>
<li><a href="../ja484814/index.html">6. Fortinet Getting Started v6.0。Webフィルタリングとアプリケーション制御</a></li>
<li><a href="../ja484816/index.html">オンザフライでmacOSのファイルをバックアップするための操作フックの使用</a></li>
<li><a href="../ja484820/index.html">FAQ.Net-デザインが更新されたWindows用の無料のメモ作成プログラム</a></li>
<li><a href="../ja484822/index.html">Blazor：コンポーネントが病気にならないようにする方法またはマークアップからコードを分離する2つのアプローチ</a></li>
<li><a href="../ja484824/index.html">電気を消すための戦争</a></li>
<li><a href="../ja484826/index.html">人工知能は悪い薬をさらに悪化させる</a></li>
<li><a href="../ja484834/index.html">トレーニングと開発のための企業戦略を構築する方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>