<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìú üì∫ üèÆ Cartesian tree sorting üéπ üë≥ üè∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A fresh look at traditional concepts. Today there will be such a ‚ÄúCartesian" which the school did not pass.
 
 
 The essence of the algorithm is that ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Cartesian tree sorting</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/505744/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A fresh look at traditional concepts. </font><font style="vertical-align: inherit;">Today there will be such a ‚ÄúCartesian" which the school did not pass.</font></font></i><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><div style="text-align:center;"><img width="700" height="525" src="https://habrastorage.org/webt/hx/f6/fp/hxf6fphv_nedheqxyqyom6qugw4.jpeg"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The essence of the algorithm is that on the basis of the array the so-called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cartesian tree is built</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">And from the constructed Cartesian tree it is very easy to get all the elements in ascending or descending order.</font></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" title="EDISON Software - web-development"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - web-development"></a><br clear="right">
 EDISON     .<br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img align="right" width="340" height="227" src="https://habrastorage.org/webt/84/rh/rr/84rhrrsxgdeqa8xxpf5b2dub_wk.png"></a><br clear="left">
     ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">   Vivaldi</a>,             .<br>
<br>
    , , ! ;-)<div style="text-align:center;"><img width="770" height="1" src="https://habrastorage.org/webt/mw/wy/cu/mwwycuqpta7m96dxifyx9if7mu8.gif"></div></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the framework of this article, I decided to refrain from a detailed theory and will not explain what a Cartesian tree is, how to build it, and what operations are possible with it. This has already been done perfectly well before me - there is excellent material on Habr√©, where all these moments have been successfully and thoroughly covered - at the end of this lecture there is a section "Links" where you can go to these harastrastam. In the future, I will cover some points that are characteristic of this structure, but it is understood that you understand its specifics or, if interested, are ready to study it using the links below. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A Cartesian tree is a hybrid structure that combines the properties of a heap and a binary search tree. There are synonyms for this tree that will be used in the article: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deramide</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revaux + feast </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bromide</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trip</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">treap</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ee + h </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eap</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
and even </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Duch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erevo + to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">teaching</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's take this array as an example: </font></font><br>
<br>
<img width="421" height="42" src="https://habrastorage.org/webt/qe/8j/nq/qe8jnql9ux0yjhtgddkd5zg35ts.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
and take a look at what the binary search tree, heap and deramide look like for it.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binary search tree</font></font></h3><br>
<img width="421" height="42" src="https://habrastorage.org/webt/qe/8j/nq/qe8jnql9ux0yjhtgddkd5zg35ts.png"><br>
<img align="left" width="211" height="414" src="https://habrastorage.org/webt/tq/o9/k0/tqo9k0oscidinobj1inalmaelea.png"><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The appearance of the tree greatly depends on how the elements of the array are initially located. Based on random data, a tree with a high degree of probability will turn out to be unbalanced, with a much larger number of levels compared to the optimal one. In our example, 7 levels formed. If the elements of the array were arranged, for example, in this order: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
25, 28, 29, 23, 30, 27, 24, 22, 21, 26 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
, the search tree would be balanced, with the minimum possible number of levels (= 4). Sorting using a balanced tree would have time complexity: </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . But in the case of an unbalanced tree, it can degrade to </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the previous habrastatia, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sorting by a binary search tree was</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> considered </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">, as well as its interesting modification</font></a><font style="vertical-align: inherit;"> , which allows guaranteed sorting with time complexity of </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The more unbalanced the search tree is, the more costly it will be to traverse it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the other hand, storing data in the search tree is very convenient from an organizational point of view, it allows you to do a lot of operations with this data, including sorting. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A parent in a binary search tree is not necessarily more than a child. But at the same time, the left child is always smaller than the parent, the right child is always larger than the parent (or equal to it).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The maximum element of the array when building the search tree falls somewhere in the right subtree. </font><font style="vertical-align: inherit;">To extract this maximum, the search tree must be completely circumvented.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binary heap</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In an ordinary heap, parent-child relationships are very simply organized; they are tied to the element indices themselves. </font></font><br>
<br>
<div style="text-align:center;"><img width="589" height="270" src="https://habrastorage.org/webt/e1/tw/um/e1twumtre1o-wzh5etq-qpkun10.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The figure is actually not a bunch yet, since such a tree, originally built on a random array, is not yet sorting. </font><font style="vertical-align: inherit;">You need to go around each element and make a sift for it. </font><font style="vertical-align: inherit;">As a result, the elements in the array are rebuilt so that each parent will be larger than its descendant:</font></font><br>
<br>
<div style="text-align:center;"><img width="589" height="270" src="https://habrastorage.org/webt/qb/p3/tt/qbp3ttzf2za1g0xqvznq9azoxzm.png"></div> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The maximum element is at the root of the tree. </font><font style="vertical-align: inherit;">Its location is known, you do not need to look for it. </font><font style="vertical-align: inherit;">On the other hand, if you extract the maximum from the heap (and instead you have to put some other element of the array in the root of the tree), the heap ceases to be a sorting tree, it needs to be sifted again.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cartesian tree</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And finally, the Cartesian tree. </font><font style="vertical-align: inherit;">Relationships are set up in such a way that, on the one hand, it is a bunch if you look at the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">values ‚Äã‚Äãof the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elements. </font><font style="vertical-align: inherit;">All parents are more than their descendants:</font></font><br>
<br>
<div style="text-align:center;"><img width="421" height="290" src="https://habrastorage.org/webt/cq/f9/xr/cqf9xrcsibbvwoxs3ygawzrrszk.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the other hand, a structure is a binary search tree when you look at the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indices of</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elements. </font><font style="vertical-align: inherit;">For clarity, the values ‚Äã‚Äãof the elements in the nodes were removed from the image in the tree, only indexes were left. </font><font style="vertical-align: inherit;">Each left descendant is smaller than the parent, each right descendant is larger than the parent:</font></font><br>
<br>
<div style="text-align:center;"><img width="421" height="280" src="https://habrastorage.org/webt/in/rk/fq/inrkfq0kqfx6ha3b1q8r276xlpm.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the one hand, we have quick access to the maximum element. Since this is a bunch, the maximum is at the root. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the other hand, you can easily remove the maximum from the structure and work with the remaining data further. Since this is a binary search tree, removing the root is not expensive. Relatively small changes occur in the parent-child relationships, a new maximum hits the root of the Cartesian tree, and you can continue to work. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each element is characterized by two numbers - the value of the element and the index of the element in the array. The index can be considered as the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordinate </font><font style="vertical-align: inherit;">, the value as </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and the element itself </font><font style="vertical-align: inherit;">can be </font><font style="vertical-align: inherit;">interpreted as a point on the coordinate plane. If parents and descendants are connected by arrows, then we get something like this:</font></font><br>
<br>
<div style="text-align:center;"><img width="435" height="404" src="https://habrastorage.org/webt/bh/rg/pv/bhrgpviw4kai2rkn_hfysb_kwv8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The figure on the graph is completely isomorphic to the Cartesian tree just above.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cartesian tree sort :: Cartesian tree sort</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The final algorithm:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I. Based on an unsorted array, we construct a Cartesian tree:</font></font></b><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I.1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterate over the elements of the array from left to right.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I.1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If this is the first element of the array, then it is simply the very first node of the Cartesian tree.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I.2. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If this is not the first element of the array, consider this to be a Cartesian tree consisting of one element. </font><font style="vertical-align: inherit;">We </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perform the Merge</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operation of </font><font style="vertical-align: inherit;">this tree with the tree that is built from the previous elements.</font></font></li>
</ul></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II. </font><font style="vertical-align: inherit;">We delete the current maximum element from the tree, after which we restore the Cartesian tree.</font></font></b><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The current maximum element is the root of the tree.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.2. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We remove the root from the tree, we transfer the maximum element to an additional array.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.3. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After removing the root, the structure split into two Cartesian trees.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.4. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For these two trees, we perform the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merge</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operation </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The new current maximum is one of the roots of the joined trees.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.5. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For a new high, repeat steps II.1-II.4 again.</font></font></li>
</ul></li>
</ul><br>
<br>
<div style="text-align:center;"><img width="759" height="406" src="https://habrastorage.org/webt/wu/ev/zx/wuevzx7thmypyyovaldixw5xxa0.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implementation in C ++:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/*
 * c++ 11 code to construct a Cartesian tree. The method cartesianTreeSort
 * will sort the contents of the array.
 */</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>{</span>
    <span class="hljs-keyword">int</span> value;<font></font>
    Node *left, *right;<font></font>
    Node *parent;<font></font>
<font></font>
    Node(){<font></font>
        value = <span class="hljs-number">0</span>;<font></font>
        parent = <span class="hljs-literal">NULL</span>;<font></font>
        left = <span class="hljs-literal">NULL</span>;<font></font>
        right = <span class="hljs-literal">NULL</span>;<font></font>
    }<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// Used by priority queue</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">compare</span>{</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Node *left, Node *right)</span></span>{
        <span class="hljs-keyword">return</span> left-&gt;value &gt; right-&gt;value;<font></font>
    }<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartesianTree</span>{</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">// last pointer to keep track of last node added</span><font></font>
    Node *root, *last;<font></font>
<font></font>
    <span class="hljs-function">Node * <span class="hljs-title">findLowestNode</span><span class="hljs-params">(Node *node, <span class="hljs-keyword">int</span> x)</span></span>{
        <span class="hljs-keyword">if</span>(node-&gt;value &lt; x)
            <span class="hljs-keyword">return</span> node;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(node-&gt;parent != <span class="hljs-literal">NULL</span>)
            <span class="hljs-keyword">return</span> findLowestNode(node-&gt;parent, x);
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
    }<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Node * <span class="hljs-title">getRoot</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">return</span> root;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>{<font></font>
        Node *new_node = <span class="hljs-keyword">new</span> Node;<font></font>
        new_node-&gt;value = x;<font></font>
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>){<font></font>
            last = new_node;<font></font>
            root = new_node;<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        Node *z = findLowestNode(last, x);<font></font>
        <span class="hljs-keyword">if</span>(z == <span class="hljs-literal">NULL</span>){<font></font>
            new_node-&gt;left = root;<font></font>
            root-&gt;parent = new_node;<font></font>
            root = new_node;<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span>{<font></font>
            new_node-&gt;left = z-&gt;right;<font></font>
            z-&gt;right = new_node;<font></font>
            new_node-&gt;parent = z;<font></font>
        }<font></font>
        last = new_node;<font></font>
    }<font></font>
<font></font>
    CartesianTree(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ar){<font></font>
        root = <span class="hljs-literal">NULL</span>;<font></font>
        last = <span class="hljs-literal">NULL</span>;
        <span class="hljs-comment">// Call addNode function for each element of the array</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : ar){<font></font>
            addNode(x);<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InorderTraversal</span><span class="hljs-params">(Node *node)</span></span>{
        <span class="hljs-comment">// To print inorder traversal of the tree</span>
        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">NULL</span>)
            <span class="hljs-keyword">return</span>;<font></font>
        InorderTraversal(node-&gt;left);<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; node-&gt;value &lt;&lt; <span class="hljs-string">' '</span>;<font></font>
        InorderTraversal(node-&gt;right);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// Function to sort and store values in array</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cartesianTreeSort</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;sorted_ar)</span></span>{
        <span class="hljs-comment">// Initialize input array</span>
        sorted_ar.assign(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Initialize priority queue</span>
        <span class="hljs-built_in">std</span>::priority_queue&lt;Node *, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Node *&gt;, compare&gt; p_queue;<font></font>
        p_queue.push(root);<font></font>
        Node *temp = <span class="hljs-literal">NULL</span>;
        <span class="hljs-keyword">while</span>(!p_queue.empty()){<font></font>
            temp = p_queue.top();<font></font>
            p_queue.pop();<font></font>
            sorted_ar.push_back(temp-&gt;value);<font></font>
            <span class="hljs-keyword">if</span>(temp-&gt;left){<font></font>
                p_queue.push(temp-&gt;left);<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span>(temp-&gt;right){<font></font>
                p_queue.push(temp-&gt;right);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ar = {<span class="hljs-number">1</span>, <span class="hljs-number">14</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>};<font></font>
<font></font>
    <span class="hljs-function">CartesianTree <span class="hljs-title">tree</span><span class="hljs-params">(ar)</span></span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Inorder Traversal\n"</span>;<font></font>
    tree.InorderTraversal(tree.getRoot());<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">'\n'</span>;<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sorted;<font></font>
    tree.cartesianTreeSort(sorted);<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Sorted array is\n"</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : sorted)
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">' '</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">'\n'</span>;<font></font>
}</code></pre><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complexity</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A Cartesian tree with minimal costs processes the sorted and almost sorted (and it does not matter, in ascending or descending) sections of the array. </font><font style="vertical-align: inherit;">Here, for example, is the process for a reverse-ordered array:</font></font><br>
<br>
<div style="text-align:center;"><img width="594" height="521" src="https://habrastorage.org/webt/_6/7a/tt/_67attvixuawod4utn7wblzpzey.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The most expensive part of the algorithm is the Merge operation, which </font><font style="vertical-align: inherit;">has to be done twice </font><font style="vertical-align: inherit;">for each of the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elements - first when building the deramide and then when it is disassembled. On random data, a one-time Merge operation costs </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but for elements located in ordered regions of the array, the cost of the O (1) operation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, the average and worst time complexity of sorting is </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and the best is O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
According to additional memory, things are worse - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">If the Cartesian tree was just a kind of heap, then the cost would be O (1). </font><font style="vertical-align: inherit;">But the cartesian tree is also a binary search tree, which is why for all </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elements it is necessary to separately store the parent-child relationships. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, the implementation in this form means that it is an external sorting - the sorted elements are collected in a separate array. </font><font style="vertical-align: inherit;">And this is O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) for additional memory.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">References</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cartesian </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/jw/w-/qu/jww-queszzqnwmoa2hm-kfwu-9o.png"> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cartesian Tree: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part 1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part 2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part 3</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Series Articles:</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excel application AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exchange Sorts</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insertion Sorts</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sort by selection</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: N-Pyramids</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Leonardo Numbers</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap sort: weak heap</font></font></a></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bunch Sorts: Cartesian Tree</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Other heap sortings: mirror heap, mini-heap, sifting bottom-up</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Jung Heap</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merge Sorts</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sort by distribution</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hybrid Sorting</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Today‚Äôs Cartesian tree sorting has been added to the AlgoLab application, who uses it - update the excel file with macros. </font><font style="vertical-align: inherit;">I recommend taking arrays with a small spread in the values ‚Äã‚Äãof the elements - otherwise the Cartesian plane will not fit on the screen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en505710/index.html">WebSockets and Spring WebFlux</a></li>
<li><a href="../en505720/index.html">Spring Boot + Apache Kafka and SSL in the Docker container</a></li>
<li><a href="../en505724/index.html">Russian fair use: where is the copyright border?</a></li>
<li><a href="../en505736/index.html">Run, PHPUnit, run: how I optimized test execution time</a></li>
<li><a href="../en505738/index.html">A bit about periodograms of time series</a></li>
<li><a href="../en505746/index.html">The digest of fresh materials from the world of the front-end for the last week No. 418 (June 1 - 7, 2020)</a></li>
<li><a href="../en505752/index.html">Comments on the accuracy of information in the database of Rosreestr and FSIS USRN</a></li>
<li><a href="../es486176/index.html">Memo de correspondencia de correo electr√≥nico corporativo</a></li>
<li><a href="../es486178/index.html">FOSS News No. 1 - revisi√≥n de noticias gratuitas y de c√≥digo abierto del 27 de enero al 2 de febrero de 2020</a></li>
<li><a href="../es486180/index.html">Consejos y fuentes para crear aplicaciones sin servidor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>