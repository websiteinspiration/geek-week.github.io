<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🎤 👗 👗 Membuat roguelike di Unity dari awal 😒 🤒 👨🏻‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tidak banyak tutorial tentang cara membuat roguelike di Unity, jadi saya memutuskan untuk menulisnya. Bukan untuk menyombongkan diri, tetapi untuk ber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Membuat roguelike di Unity dari awal</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490828/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad4/093/6ab/ad40936ab0dff25fd3214571faf9aa61.png" alt="gambar"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak banyak tutorial tentang cara membuat roguelike di Unity, jadi saya memutuskan untuk menulisnya. Bukan untuk menyombongkan diri, tetapi untuk berbagi pengetahuan dengan mereka yang berada pada tahap di mana saya sudah cukup lama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Catatan: Saya tidak mengatakan bahwa ini adalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><i><font style="vertical-align: inherit;">satunya</font></i><font style="vertical-align: inherit;"> cara untuk membuat roguelike di Unity. Dia hanya </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mungkin bukan yang terbaik dan paling efektif, saya belajar melalui coba-coba. Dan saya akan belajar beberapa hal dengan benar dalam proses membuat tutorial. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita asumsikan bahwa Anda </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tahu setidaknya dasar-dasar Persatuan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, misalnya, cara membuat cetakan atau skrip, dan sejenisnya. </font><font style="vertical-align: inherit;">Jangan berharap saya mengajari Anda cara membuat sprite sheet, ada banyak tutorial bagus tentang ini. </font><font style="vertical-align: inherit;">Saya akan fokus bukan pada mempelajari engine, tetapi pada bagaimana mengimplementasikan game yang akan kita buat bersama. </font><font style="vertical-align: inherit;">Jika Anda mengalami kesulitan, pergilah ke salah satu komunitas hebat Discord dan minta bantuan: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komunitas Pengembang Unity </font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roguelikes</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Jadi, mari kita mulai!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tahap 0 - perencanaan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya itu betul. Hal pertama yang harus dibuat adalah rencana. Ini akan baik bagi Anda untuk merencanakan permainan, dan bagi saya - untuk merencanakan tutorial sehingga setelah beberapa saat kami tidak akan terganggu dari topik. Sangat mudah untuk bingung dalam fungsi-fungsi gim, seperti di ruang bawah tanah roguelike. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan menulis roguelike. Kami terutama akan mengikuti saran bijaksana pengembang Cogmind Josh Ge di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ikuti tautannya, baca posnya atau tonton videonya, lalu kembali.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa tujuan dari tutorial ini? Dapatkan dasar roguelike sederhana yang solid, yang dengannya Anda dapat bereksperimen. Seharusnya memiliki generasi penjara bawah tanah, pemain yang bergerak di peta, kabut visibilitas, musuh dan objek. Hanya yang paling penting. Jadi, pemain harus bisa turun tangga beberapa lantai. Katakanlah, pada usia lima tahun, tingkatkan level Anda, tingkatkan, dan pada akhirnya bertarunglah dengan bos dan kalahkan dia. Atau mati. Faktanya, itu saja.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengikuti saran Josh Ge, kami akan membangun fungsi-fungsi permainan sehingga mereka membawa kami ke tujuan. </font><font style="vertical-align: inherit;">Jadi kami mendapatkan kerangka kerja seperti roguelike, yang dapat dikembangkan lebih lanjut, tambahkan chip Anda sendiri, menciptakan keunikan. </font><font style="vertical-align: inherit;">Atau lempar semua yang ada di keranjang, manfaatkan pengalaman yang didapat dan mulailah dari awal. </font><font style="vertical-align: inherit;">Lagipula itu akan luar biasa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak akan memberi Anda sumber daya grafis apa pun. </font><font style="vertical-align: inherit;">Gambar sendiri atau gunakan tileset gratis, yang dapat diunduh di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau dengan mencari di Google. </font><font style="vertical-align: inherit;">Hanya saja, jangan lupa menyebutkan penulis grafis dalam game. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita daftar semua fungsi yang akan ada di roguelike kami sesuai dengan urutan implementasinya:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembuatan Peta Bawah Tanah</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karakter pemain dan gerakannya</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Area visibilitas</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Musuh</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cari cara</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berjuang, Kesehatan, dan Kematian</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tingkat Pemain</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Item (senjata dan ramuan)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cheat konsol (untuk pengujian)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lantai penjara</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menyimpan dan memuat</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bos terakhir</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah menerapkan semua ini, kami akan memiliki roguelike yang kuat, dan Anda akan sangat meningkatkan keterampilan pengembangan game Anda. </font><font style="vertical-align: inherit;">Sebenarnya, itu adalah </font><font style="vertical-align: inherit;">cara </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saya</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk meningkatkan keterampilan </font><em><font style="vertical-align: inherit;">saya</font></em><font style="vertical-align: inherit;"> : membuat kode dan mengimplementasikan fungsi. </font><font style="vertical-align: inherit;">Karena itu, saya yakin Anda dapat menangani ini juga.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tahap 1 - Kelas MapManager</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah skrip pertama yang akan kita buat dan itu akan menjadi tulang punggung game kita. </font><font style="vertical-align: inherit;">Ini sederhana, tetapi berisi sebagian besar informasi penting untuk permainan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, buat skrip .cs bernama MapManager dan buka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hapus ": MonoBehaviour" karena tidak akan mewarisinya dan tidak akan dilampirkan ke GameObject apa pun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hapus fungsi Mulai () dan Perbarui (). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di akhir kelas MapManager, buat kelas publik baru yang disebut Tile.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/431/54e/4c2/43154e4c2708a580bc3838b1fbee573b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas Tile akan berisi semua informasi dari satu ubin. </font><font style="vertical-align: inherit;">Sejauh ini, kita tidak perlu banyak, hanya posisi x dan y, serta objek permainan yang terletak di posisi peta ini.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/405/21e/cd9/40521ecd9e1292e813391181e523b6dc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, kami memiliki informasi ubin dasar. </font><font style="vertical-align: inherit;">Mari kita buat peta dari ubin ini. </font><font style="vertical-align: inherit;">Sederhana saja, kita hanya perlu array dua dimensi dari objek Tile. </font><font style="vertical-align: inherit;">Kedengarannya rumit, tetapi tidak ada yang istimewa tentang itu. </font><font style="vertical-align: inherit;">Cukup tambahkan variabel Tile [,] ke kelas MapManager:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/2e8/806/f442e88061e77cbbb4c1aa904c73bdfd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voila! </font><font style="vertical-align: inherit;">Kami punya peta! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya itu kosong. </font><font style="vertical-align: inherit;">Tapi ini peta. </font><font style="vertical-align: inherit;">Setiap kali sesuatu bergerak atau berubah status pada peta, informasi pada peta ini akan diperbarui. </font><font style="vertical-align: inherit;">Artinya, jika, misalnya, seorang pemain mencoba untuk beralih ke ubin baru, kelas akan memeriksa alamat ubin tujuan di peta, keberadaan musuh dan patennya. </font><font style="vertical-align: inherit;">Berkat ini, kami tidak perlu memeriksa ribuan tabrakan di setiap belokan, dan kami tidak membutuhkan collider untuk setiap objek game, yang akan memudahkan dan menyederhanakan pekerjaan dengan game. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode yang dihasilkan terlihat seperti ini:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MapManager</span> <font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Tile[,] map; <span class="hljs-comment">// the 2-dimensional map with the information for all the tiles</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Tile</span> { <span class="hljs-comment">//Holds all the information for each tile on the map</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> xPosition; <span class="hljs-comment">// the position on the x axis</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> yPosition; <span class="hljs-comment">// the position on the y axis</span>
    <span class="hljs-keyword">public</span> GameObject baseObject; <span class="hljs-comment">// the map game object attached to that position: a floor, a wall, etc.</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tahap pertama selesai, mari kita lanjutkan untuk mengisi kartu. </font><font style="vertical-align: inherit;">Sekarang kita akan mulai membuat generator penjara bawah tanah.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tahap 2 - beberapa kata tentang struktur data</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi sebelum Anda mulai, izinkan saya berbagi kiat-kiat yang muncul berkat umpan balik yang diterima setelah penerbitan bagian pertama. Saat membuat struktur data, Anda harus berpikir dari awal bagaimana Anda akan mempertahankan kondisi permainan. Kalau tidak, nanti akan jauh lebih kacau. Pengguna Discord st33d, pengembang Star Shaped Bagel (Anda dapat memainkan game ini secara gratis di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), mengatakan bahwa pada awalnya ia membuat game, berpikir bahwa itu tidak akan menyelamatkan negara sama sekali. Perlahan-lahan, permainan mulai bertambah besar, dan penggemarnya meminta dukungan untuk peta yang disimpan. Tetapi karena metode yang dipilih untuk membuat struktur data, sangat sulit untuk menyimpan data, jadi dia tidak dapat melakukan ini.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82c/b02/858/82cb02858af686ef409ad8a6c0496135.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami benar-benar belajar dari kesalahan kami. Terlepas dari kenyataan bahwa saya meletakkan bagian save / load di akhir tutorial, saya memikirkannya sejak awal, dan belum menjelaskannya. Pada bagian ini saya akan berbicara sedikit tentang mereka, tetapi agar tidak membebani pengembang yang tidak berpengalaman. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan menyimpan hal-hal seperti array variabel dari kelas Tile di mana peta disimpan. Kami akan menyimpan semua data ini, kecuali variabel kelas GameObject, yang ada di dalam kelas Tile. Mengapa? Hanya karena GameObjects tidak dapat diserialisasi dengan Unity ke data yang disimpan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena itu, pada kenyataannya, kita tidak perlu menyimpan data yang disimpan di dalam GameObjects. Semua data akan disimpan di kelas seperti Tile, dan nanti juga Player, Musuh, dll. Kemudian kita akan memiliki GameObjects untuk menyederhanakan perhitungan hal-hal seperti visibilitas dan gerakan, serta menggambar sprite di layar. Oleh karena itu, di dalam kelas akan ada variabel GameObject, tetapi nilai variabel-variabel ini tidak akan disimpan dan dimuat. Saat memuat, kami akan dipaksa untuk menghasilkan GameObject lagi dari data yang disimpan (posisi, sprite, dll.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lalu apa yang perlu kita lakukan sekarang? Nah, tambahkan saja dua baris ke kelas Tile yang ada dan satu ke bagian atas skrip. Pertama kita tambahkan "using System;" ke judul skrip, dan kemudian [Serializable] di depan seluruh kelas dan [NonSerialized] tepat di depan variabel GameObject. Seperti ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfd/931/aa3/bfd931aa3a4a1b2b7792650cc25cba07.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2e/178/9d3/a2e1789d3663b1530d64d3d900c7f047.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya akan memberi tahu Anda lebih banyak tentang ini ketika kita sampai pada bagian tutorial tentang menabung / memuat. </font><font style="vertical-align: inherit;">Untuk saat ini, mari kita tinggalkan semuanya dan lanjutkan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tahap 3 - lebih banyak tentang struktur data</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mendapat ulasan lain tentang struktur data yang ingin saya bagikan di sini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faktanya, ada banyak cara untuk mengimplementasikan data dalam game. Yang pertama saya gunakan dan yang akan diterapkan dalam tutorial ini: semua data ubin berada di kelas Tile, dan semuanya disimpan dalam array. Pendekatan ini memiliki banyak keuntungan: lebih mudah dibaca, semua yang Anda butuhkan ada di satu tempat, data lebih mudah untuk dimanipulasi dan diekspor ke file penyimpanan. Tetapi dari sudut pandang memori, itu tidak begitu efektif. Anda harus mengalokasikan banyak memori untuk variabel yang tidak akan pernah digunakan dalam game. Sebagai contoh, nanti kita akan meletakkan variabel GameObject Musuh di kelas Tile sehingga kita bisa mengarahkan langsung dari peta ke GameObject musuh yang berdiri di ubin ini untuk menyederhanakan semua perhitungan yang terkait dengan pertempuran. Tetapi ini berarti setiap ubin dalam gim akan mengalokasikan ruang dalam memori untuk variabel GameObject,bahkan jika tidak ada musuh di ubin ini. Jika ada 10 musuh di peta 2500 ubin, maka akan ada 2490 variabel GameObject kosong, tetapi dialokasikan - Anda dapat melihat berapa banyak memori yang terbuang.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode alternatif adalah menggunakan struktur untuk menyimpan data dasar ubin (misalnya, posisi dan jenis), dan semua data lainnya akan disimpan dalam hashmap-s, yang akan dihasilkan hanya jika perlu. </font><font style="vertical-align: inherit;">Ini akan menghemat banyak memori, tetapi pengembaliannya akan menjadi implementasi yang sedikit lebih rumit. </font><font style="vertical-align: inherit;">Sebenarnya itu akan menjadi sedikit lebih maju daripada yang saya inginkan dalam tutorial ini, tetapi jika Anda mau, maka di masa depan saya dapat menulis posting yang lebih rinci tentang hal itu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, jika Anda ingin membaca diskusi tentang topik ini, maka ini dapat dilakukan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di Reddit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tahap 4 - Algoritma Generasi Bawah Tanah</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya, ini adalah bagian lain di mana saya akan berbicara dan kami tidak akan mulai memprogram apa pun. Tapi ini penting, perencanaan algoritma yang cermat akan menghemat banyak waktu kerja kita di masa depan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada beberapa cara untuk membuat generator penjara bawah tanah. Salah satu yang akan kami terapkan bersama bukanlah yang terbaik dan bukan yang paling efektif ... itu hanya cara awal yang mudah. Ini sangat sederhana, tetapi hasilnya akan cukup bagus. Masalah utama akan banyak koridor jalan buntu. Nanti, jika Anda mau, saya bisa menerbitkan tutorial lain tentang algoritma yang lebih baik.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, algoritma yang kami gunakan berfungsi sebagai berikut: katakanlah kami memiliki seluruh peta yang diisi dengan nilai nol - tingkat yang terdiri dari batu. </font><font style="vertical-align: inherit;">Awalnya kami memotong sebuah ruangan di tengah. </font><font style="vertical-align: inherit;">Dari ruangan ini kita menerobos koridor dalam satu arah, dan kemudian menambahkan koridor dan kamar lain, selalu mulai secara acak dari ruang atau koridor yang ada, sampai kita mencapai jumlah maksimum koridor / kamar yang diberikan di awal. </font><font style="vertical-align: inherit;">Atau hingga algoritme dapat menemukan tempat baru untuk menambahkan ruang / koridor baru, mana yang lebih dulu. </font><font style="vertical-align: inherit;">Dan jadi kami mendapatkan ruang bawah tanah.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, mari kita jelaskan ini dengan cara yang lebih mirip algoritma, langkah demi langkah. </font><font style="vertical-align: inherit;">Untuk kenyamanan, saya akan menyebut setiap detail peta (koridor atau ruangan) sebagai elemen sehingga saya tidak perlu mengatakan "kamar / koridor" setiap waktu.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Potong ruangan di tengah peta</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilih salah satu dinding secara acak</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menerobos koridor di dinding ini</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilih secara acak salah satu elemen yang ada.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilih salah satu dinding elemen ini secara acak</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika item yang dipilih terakhir adalah ruangan, maka kami menghasilkan koridor. </font><font style="vertical-align: inherit;">Jika koridor, maka pilih secara acak apakah elemen berikutnya akan menjadi ruangan atau koridor lain</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Periksa apakah ada cukup ruang di arah yang dipilih untuk membuat item yang diinginkan</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika ada tempat, buat elemen, jika tidak, kembali ke langkah 4</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ulangi dari langkah 4</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu saja. </font><font style="vertical-align: inherit;">Kami akan mendapatkan peta sederhana dari ruang bawah tanah, di mana hanya ada kamar dan koridor, tanpa pintu dan elemen khusus, tetapi ini akan menjadi awal kami. </font><font style="vertical-align: inherit;">Nanti kita akan mengisinya dengan peti, musuh dan jebakan. </font><font style="vertical-align: inherit;">Dan Anda bahkan dapat menyesuaikannya: kita akan belajar cara menambahkan elemen menarik yang Anda butuhkan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tahap 5 - memotong ruangan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akhirnya lanjutkan ke pengkodean! </font><font style="vertical-align: inherit;">Mari kita potong kamar pertama kita. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, buat skrip baru dan beri nama DungeonGenerator. </font><font style="vertical-align: inherit;">Ini akan mewarisi dari Monobehaviour, jadi Anda harus melampirkannya ke GameObject nanti. </font><font style="vertical-align: inherit;">Kemudian kita perlu mendeklarasikan beberapa variabel publik di kelas sehingga kita dapat mengatur parameter ruang bawah tanah dari inspektur. </font><font style="vertical-align: inherit;">Variabel-variabel ini akan menjadi lebar dan tinggi peta, tinggi minimum dan maksimum dan lebar ruangan, panjang maksimum koridor dan jumlah elemen yang harus ada di peta.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/120/331/04d/12033104d1f3fcf270fdc5fd64ffb6bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya kita perlu menginisialisasi generator penjara bawah tanah. Kami melakukan ini untuk menginisialisasi variabel yang akan diisi oleh generasi. Untuk saat ini, ini hanyalah peta. Dan, dan juga menghapus fungsi Mulai () dan Pembaruan () yang dihasilkan Unity untuk skrip baru, kami tidak akan membutuhkannya.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f92/a8f/e5d/f92a8fe5dc2ea241284fe95b8758c289.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad7/841/44b/ad784144b6aeea6aee3967caedaa37eb.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kita menginisialisasi variabel peta kelas MapManager (yang kita buat pada langkah sebelumnya), melewati lebar dan tinggi peta, didefinisikan oleh variabel di atas sebagai parameter dari dua dimensi array. Berkat ini, kami akan memiliki peta ukuran x horizontal (lebar) dan ukuran vertikal y (tinggi), dan kami dapat mengakses sel apa pun di peta dengan memasukkan MapManager.map [x, y]. Ini akan sangat berguna ketika memanipulasi posisi objek. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita akan membuat fungsi untuk membuat ruang pertama. Kami akan menyebutnya FirstRoom (). Kami menjadikan InitializeDungeon () fungsi publik, karena akan diluncurkan oleh skrip lain (Game Manager, yang akan segera kami buat; itu akan memusatkan pengelolaan seluruh proses peluncuran game). Kami tidak memerlukan skrip eksternal untuk memiliki akses ke FirstRoom (), jadi kami tidak membuatnya publik.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, untuk melanjutkan, kami akan membuat tiga kelas baru dalam skrip MapManager sehingga Anda dapat membuat ruang. Ini adalah kelas Fitur, Dinding, dan Posisi. Kelas Position akan berisi posisi x dan y sehingga kita dapat melacak di mana semuanya berada. Dinding akan memiliki daftar posisi, arah di mana ia "terlihat" relatif terhadap pusat ruangan (utara, selatan, timur atau barat), panjangnya, dan keberadaan elemen baru yang diciptakan darinya. Elemen akan memiliki daftar semua posisi yang terdiri dari, jenis elemen (ruangan atau koridor), array variabel Wall, dan lebar dan tinggi.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b7/abe/924/3b7abe9241bb1442f3224048384263ff.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/938/8bc/8d7/9388bc8d7dd523b45013fa80d918d8a2.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita ke fungsi FirstRoom (). </font><font style="vertical-align: inherit;">Mari kita kembali ke skrip DungeonGenerator dan membuat fungsi tepat di bawah InitializeDungeon. </font><font style="vertical-align: inherit;">Dia tidak perlu menerima parameter apa pun, jadi kami akan membiarkannya sederhana (). </font><font style="vertical-align: inherit;">Selanjutnya, di dalam fungsi, pertama-tama kita perlu membuat dan menginisialisasi variabel Room dan daftar variabel Posisi. </font><font style="vertical-align: inherit;">Kami melakukannya seperti ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/164/b81/b5d/164b81b5dde06f8e996e22a75bf0b947.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita mengatur ukuran ruangan. </font><font style="vertical-align: inherit;">Ini akan menerima nilai acak antara tinggi dan lebar minimum dan maksimum yang dinyatakan pada awal skrip. </font><font style="vertical-align: inherit;">Sementara mereka kosong, karena kami tidak menetapkan nilai untuk mereka di inspektur, tetapi jangan khawatir, kami akan segera melakukannya. </font><font style="vertical-align: inherit;">Kami menetapkan nilai acak seperti ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d77/bbd/389/d77bbd3896dc4c60d93a9e6b1c006729.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, kita perlu menyatakan di mana titik awal ruangan akan terletak, yaitu, di mana titik kamar 0,0 akan terletak di kisi peta. Kami ingin membuatnya mulai di tengah peta (setengah lebar dan setengah tinggi), tapi mungkin tidak </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tepat</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di tengah peta. Mungkin perlu menambahkan pengacak kecil sehingga bergerak sedikit ke kiri dan ke bawah. Oleh karena itu, kita menetapkan xStartingPoint sebagai setengah lebar peta, dan yStartingPoint sebagai setengah tinggi peta, dan kemudian mengambil roomWidth dan roomHeight yang baru saja diberikan, dapatkan nilai acak dari 0 hingga lebar / tinggi ini, dan kurangi dari awal x dan y. Seperti ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50f/3f2/f0e/50f3f2f0ecb267d5283dcd4684019708.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8eb/0e7/f2b/8eb0e7f2bff7d3d08b1b0691885e89cd.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, dalam fungsi yang sama kita akan menambahkan dinding. Kita perlu menginisialisasi array dinding yang ada di variabel kamar yang baru dibuat, dan kemudian menginisialisasi setiap variabel dinding di dalam array ini. Dan kemudian inisialisasi setiap daftar posisi, atur panjang dinding ke 0 dan masukkan arah di mana setiap dinding akan "terlihat". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah array diinisialisasi, kita berputar di sekitar setiap elemen array di for () loop, menginisialisasi variabel dari setiap dinding, dan kemudian menggunakan switch, yang menamai arah setiap dinding. Ini dipilih secara sewenang-wenang, kita hanya perlu mengingat apa artinya.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3a/f8f/9da/d3af8f9da1ee8f317452d52f9f905536.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita akan mengeksekusi dua bersarang untuk loop segera setelah menempatkan dinding. </font><font style="vertical-align: inherit;">Di loop luar, kita berkeliling semua nilai y di ruangan, dan di loop bersarang, semua nilai x. </font><font style="vertical-align: inherit;">Dengan cara ini kita akan memeriksa setiap sel x dalam baris y sehingga kita dapat mengimplementasikannya.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ee/cb3/695/3eecb3695c59d199fb32064501ce1009.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maka hal pertama yang harus dilakukan adalah menemukan nilai sebenarnya dari posisi sel pada skala peta dari posisi ruangan. </font><font style="vertical-align: inherit;">Ini cukup sederhana: kami memiliki titik awal x dan y. </font><font style="vertical-align: inherit;">Mereka akan berada di posisi 0,0 di kisi-kisi ruangan. </font><font style="vertical-align: inherit;">Kemudian jika kita perlu mendapatkan nilai nyata x, y dari sembarang lokal x, y, maka kita tambahkan x lokal dan y dengan posisi awal x dan y. </font><font style="vertical-align: inherit;">Kemudian kami menyimpan nilai x, y asli ini ke variabel Posisi (dari kelas yang dibuat sebelumnya), dan kemudian menambahkannya ke Daftar &lt;&gt; dari posisi ruangan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b2/cc4/4a0/0b2cc44a0ae9953a3d49ac0b3c01a6c9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Langkah selanjutnya adalah menambahkan informasi ini ke peta. </font><font style="vertical-align: inherit;">Sebelum mengubah nilai, ingatlah untuk menginisialisasi variabel Tile.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1aa/fe5/a43/1aafe5a43a8c30f2c343472ad7f157ca.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita akan membuat perubahan ke kelas Tile. </font><font style="vertical-align: inherit;">Mari kita pergi ke skrip MapManager dan menambahkan satu baris ke definisi kelas Tile: "tipe string publik;". </font><font style="vertical-align: inherit;">Ini akan memungkinkan kita untuk menambahkan kelas ubin dengan menyatakan bahwa ubin di x, y adalah dinding, lantai, atau yang lainnya. </font><font style="vertical-align: inherit;">Selanjutnya, mari kita kembali ke siklus di mana kita melakukan pekerjaan dan menambahkan konstruksi if-else besar, yang akan memungkinkan kita tidak hanya menentukan setiap dinding, panjangnya dan semua posisi di dinding ini, tetapi juga untuk menentukan pada peta global apa ubin tertentu - dinding atau jenis kelamin.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c3/276/28c/7c327628cea73dafe9319a01ac10b72b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan kita sudah melakukan sesuatu. Jika variabel y (kontrol variabel di loop luar) adalah 0, maka ubin milik baris sel terendah di ruangan, yaitu, itu adalah dinding selatan. Jika x (kontrol variabel loop dalam) adalah 0, maka ubin milik kolom sel paling kiri, yaitu, itu adalah dinding barat. Dan jika itu berada di garis paling atas, maka itu milik tembok utara, dan di kanan - tembok timur. Kita kurangi 1 dari variabel roomWidth dan roomHeight, karena nilai-nilai ini dihitung mulai dari 1, dan variabel x dan y dari siklus dimulai dari 0, jadi kita perlu memperhitungkan perbedaan ini. Dan semua sel yang tidak memenuhi kondisi bukanlah dinding, yaitu, mereka adalah lantai.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/258/4a6/2c9/2584a62c91fc46205f903cb4283bd1ce.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hebat, kita hampir selesai dengan kamar pertama. </font><font style="vertical-align: inherit;">Hampir siap, kita hanya perlu meletakkan nilai terakhir dalam variabel Fitur yang kita buat. </font><font style="vertical-align: inherit;">Kami keluar dari loop dan mengakhiri fungsi seperti ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bd/aaf/a47/2bdaafa47adb2694f360eea850341920.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baik! </font><font style="vertical-align: inherit;">Kami punya kamar! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi bagaimana kita memahami bahwa semuanya bekerja? </font><font style="vertical-align: inherit;">Perlu diuji. </font><font style="vertical-align: inherit;">Tapi bagaimana cara mengujinya? </font><font style="vertical-align: inherit;">Kita dapat menghabiskan waktu dan menambahkan aset untuk ini, tetapi itu akan membuang-buang waktu dan terlalu mengalihkan kita dari menyelesaikan algoritme. </font><font style="vertical-align: inherit;">Hmm, tapi ini bisa dilakukan menggunakan ASCII! </font><font style="vertical-align: inherit;">Ya, ide bagus! </font><font style="vertical-align: inherit;">ASCII adalah cara sederhana dan murah untuk menggambar peta sehingga dapat diuji. </font><font style="vertical-align: inherit;">Juga, jika Anda mau, Anda dapat melewati bagian tersebut dengan sprite dan efek visual, yang akan kami pelajari nanti, dan membuat seluruh permainan Anda di ASCII. </font><font style="vertical-align: inherit;">Jadi mari kita lihat bagaimana ini dilakukan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tahap 6 - menggambar ruang pertama</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal pertama yang harus dipikirkan ketika mengimplementasikan kartu ASCII adalah font mana yang harus dipilih. Faktor utama yang perlu dipertimbangkan ketika memilih font untuk ASCII adalah apakah itu proporsional (lebar variabel) atau monospasi (lebar tetap). Kami membutuhkan font monospace agar kartu terlihat sesuai kebutuhan (lihat contoh di bawah). Secara default, setiap proyek Unity baru menggunakan font Arial, dan itu bukan monospace, jadi kita perlu mencari yang lain. Windows 10 biasanya memiliki font monospaced Courier New, Consolas, dan Lucida Console. Pilih salah satu dari tiga ini atau unduh yang lain di tempat yang Anda butuhkan dan letakkan di folder Font di dalam folder Aset proyek.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff4/beb/f23/ff4bebf23a4523f4dd348524ac6b0a9f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita siapkan adegan untuk output ASCII. Sebagai permulaan, buat warna latar belakang kamera utama dari adegan itu menjadi hitam. Kemudian kita menambahkan objek Canvas ke adegan, dan menambahkan objek Text ke dalamnya. Atur transformasi persegi panjang Teks ke tengah tengah dan ke posisi 0,0,0. Atur objek Teks sehingga menggunakan font yang Anda pilih dan warna putih, overflow horisontal dan vertikal (overflow horisontal / vertikal), pilih Overflow, dan pusatkan pelurusan vertikal dan horizontal. Kemudian ganti nama objek Teks menjadi "ASCIITest" atau yang serupa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kembali ke kode. Di skrip DungeonGenerator, buat fungsi baru yang disebut DrawMap. Kami ingin dia mendapatkan parameter yang memberitahukan kartu mana yang akan dihasilkan - ASCII atau sprite, jadi buat parameter boolean dan sebut itu adalah ASCII.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/387/67a/957/38767a9575270115821d6be36ce97293.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian kami akan memeriksa apakah peta yang diberikan adalah ASCII. </font><font style="vertical-align: inherit;">Jika ya (untuk saat ini, kami hanya akan mempertimbangkan kasus ini), maka kami akan mencari objek teks dalam adegan, meneruskan nama yang diberikan kepadanya sebagai parameter, dan mendapatkan komponen Teksnya. </font><font style="vertical-align: inherit;">Tetapi pertama-tama, kita perlu memberi tahu Unity bahwa kita ingin bekerja dengan UI. </font><font style="vertical-align: inherit;">Tambahkan baris menggunakan UnityEngine.UI ke header skrip:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17c/e18/c24/17ce18c24ec7c286b4390159dc98dab1.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baik. </font><font style="vertical-align: inherit;">Sekarang kita bisa mendapatkan komponen teks dari objek. </font><font style="vertical-align: inherit;">Peta akan menjadi garis besar, yang tercermin di layar sebagai teks. </font><font style="vertical-align: inherit;">Itulah mengapa sangat mudah diatur. </font><font style="vertical-align: inherit;">Jadi mari kita buat string dan inisialisasi dengan nilai "".</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d2/7f2/92c/6d27f292c1f519a7b351d7b8d80a8f84.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baik. Jadi, setiap kali DrawMap dipanggil, kita perlu memberi tahu apakah kartu tersebut adalah ASCII. Jika demikian (dan kami akan selalu melakukannya dengan cara ini, kami akan bekerja dengan yang lain nanti), maka fungsinya akan mencari hirarki adegan dalam mencari objek game yang disebut "ASCIITest". Jika ya, maka ia akan menerima komponen Teks dan menyimpannya ke variabel layar, yang kemudian dapat dengan mudah kita tulis peta. Kemudian ia menciptakan string yang nilainya awalnya kosong. Kami akan mengisi baris ini dengan peta kami yang ditandai dengan simbol.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Biasanya kita berkeliling peta dalam satu lingkaran, mulai dari 0 dan pergi ke ujung panjangnya. </font><font style="vertical-align: inherit;">Tetapi untuk mengisi baris, kita mulai dengan baris teks pertama, yaitu baris paling atas. </font><font style="vertical-align: inherit;">Oleh karena itu, pada sumbu y, kita perlu bergerak dalam satu lingkaran ke arah yang berlawanan, pergi dari ujung ke awal array. </font><font style="vertical-align: inherit;">Tetapi sumbu x dari array bergerak dari kiri ke kanan, sama seperti teks, jadi ini cocok untuk kita.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/536/019/f47/536019f479ea1af260d551f342ed46aa.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam siklus ini, kami memeriksa setiap sel peta untuk mencari tahu apa yang ada di dalamnya. </font><font style="vertical-align: inherit;">Sejauh ini, kami hanya menginisialisasi sel sebagai Tile baru (), yang kami potong untuk ruangan, jadi semua orang akan mengembalikan kesalahan ketika mencoba mengakses. </font><font style="vertical-align: inherit;">Jadi pertama-tama kita perlu memeriksa </font><font style="vertical-align: inherit;">apakah </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sesuatu di sel ini, dan kita melakukan ini dengan memeriksa sel untuk nol. </font><font style="vertical-align: inherit;">Jika bukan nol, maka kami terus bekerja, tetapi jika itu nol, maka tidak ada apa-apa di dalamnya, sehingga kami dapat menambahkan ruang kosong ke peta.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f3/f56/5d9/3f3f565d9e9f7886c3baa600cd1ab99f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, untuk setiap sel yang tidak kosong, kami memeriksa tipenya, dan kemudian menambahkan simbol yang sesuai. </font><font style="vertical-align: inherit;">Kami ingin dinding ditandai dengan simbol "#" dan lantai ditandai oleh ".". </font><font style="vertical-align: inherit;">Dan sementara kita hanya memiliki dua tipe ini. </font><font style="vertical-align: inherit;">Nanti, ketika kita menambahkan pemain, monster, dan jebakan, semuanya akan menjadi sedikit lebih rumit.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9f/a24/ef0/f9fa24ef002860f5331479f9ac07a6e8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, kita perlu melakukan jeda baris ketika mencapai akhir baris array, sehingga sel-sel dengan posisi x yang sama berada langsung di bawah satu sama lain. </font><font style="vertical-align: inherit;">Kami akan memeriksa pada setiap iterasi dari loop apakah sel adalah yang terakhir di baris, dan kemudian menambahkan satu baris dengan karakter khusus "\ n".</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/7b8/1eb/c147b81eb1f4efa01bafdfa8a4aa092d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu saja. </font><font style="vertical-align: inherit;">Kemudian kita keluar dari loop sehingga kita dapat menambahkan baris ini setelah selesai ke objek teks di tempat kejadian.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20f/8bb/f4d/20f8bbf4d1c8e5b59afc3163a97d57bb.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fcb/83f/a7f/fcb83fa7f923ec53e33696bb8962a1d9.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selamat! Anda telah menyelesaikan skrip yang menciptakan ruangan dan menampilkannya di layar. Sekarang kita hanya perlu menerapkannya. Kami tidak menggunakan Start () dalam skrip DungeonGenerator, karena kami ingin memiliki skrip terpisah untuk mengontrol semua yang dilakukan pada awal permainan, termasuk menghasilkan peta, tetapi juga menyiapkan pemain, musuh, dll. Karenanya, skrip lain ini akan berisi fungsi Mulai (), dan, jika perlu, akan memanggil fungsi skrip kami. Skrip DungeonGenerator memiliki fungsi Inisialisasi, yang bersifat publik, dan FirstRoom serta DrawMap tidak bersifat publik. Inisialisasi hanya menginisialisasi variabel untuk menyesuaikan proses pembuatan dungeon, jadi kita membutuhkan fungsi lain yang memanggil proses pembuatan, yang harus bersifat publik sehingga dapat dipanggil dari skrip lain.Untuk saat ini, ia hanya akan memanggil fungsi FirstRoom (), dan kemudian fungsi DrawMap (), meneruskannya dengan nilai yang benar sehingga ia menggambar peta ASCII. Oh, atau tidak, ini bahkan lebih baik - mari kita buat variabel publik isASCII, yang dapat dimasukkan dalam inspektur, dan kirimkan variabel ini sebagai parameter ke fungsi. Baik.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c58/288/502/c58288502f107440def4f803d602662b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, sekarang mari kita buat skrip GameManager. </font><font style="vertical-align: inherit;">Ini akan menjadi skrip yang mengontrol semua elemen level tinggi dari gim, misalnya, membuat peta dan arah gerakan. </font><font style="vertical-align: inherit;">Mari kita hapus fungsi Update () di dalamnya, tambahkan variabel tipe DungeonGenerator yang disebut dungeonGenerator, dan buat instance variabel ini di fungsi Start ().</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5b/8da/424/e5b8da4243c91f887c08213b9ec14953.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah itu, kita cukup memanggil fungsi InitializeDungeon () dan GenerateDungeon () dari dungeonGenerator, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam urutan itu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ini penting - pertama Anda perlu menginisialisasi variabel, dan hanya setelah itu mulai membangun berdasarkan mereka.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/158/7e6/781/1587e6781595d0ee6661aea7898aa6e4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada bagian ini dengan kode selesai. </font><font style="vertical-align: inherit;">Kita perlu membuat objek game kosong di panel hierarki, mengganti namanya menjadi GameManager dan melampirkan skrip GameManager dan DungeonGenerator padanya. </font><font style="vertical-align: inherit;">Dan kemudian mengatur nilai generator penjara bawah tanah di inspektur. </font><font style="vertical-align: inherit;">Anda dapat mencoba berbagai skema untuk generator, dan saya memutuskan ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a11/41f/495/a1141f4953a6fdeac32cc978ac4a0b05.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang klik saja bermain dan saksikan keajaiban! </font><font style="vertical-align: inherit;">Anda akan melihat sesuatu yang serupa di layar game:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad4/093/6ab/ad40936ab0dff25fd3214571faf9aa61.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selamat, sekarang kita punya kamar! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya ingin kami meletakkan karakter pemain di sana dan membuatnya bergerak, tetapi posnya sudah cukup panjang. </font><font style="vertical-align: inherit;">Oleh karena itu, di bagian selanjutnya, kita dapat melanjutkan langsung ke implementasi sisa dari algoritma penjara bawah tanah, atau kita dapat menempatkan pemain di dalamnya dan mengajarkannya bagaimana cara bergerak. </font><font style="vertical-align: inherit;">Pilih yang paling Anda sukai di komentar ke artikel asli. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MapManager.cs:</font></font></b><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System; <span class="hljs-comment">// So the script can use the serialization commands</span>
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MapManager</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Tile[,] map; <span class="hljs-comment">// the 2-dimensional map with the information for all the tiles</span><font></font>
}<font></font>
<font></font>
[<span class="hljs-meta">Serializable</span>] <span class="hljs-comment">// Makes the class serializable so it can be saved out to a file</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Tile</span> { <span class="hljs-comment">// Holds all the information for each tile on the map</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> xPosition; <span class="hljs-comment">// the position on the x axis</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> yPosition; <span class="hljs-comment">// the position on the y axis</span>
    [<span class="hljs-meta">NonSerialized</span>]
    <span class="hljs-keyword">public</span> GameObject baseObject; <span class="hljs-comment">// the map game object attached to that position: a floor, a wall, etc.</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> type; <span class="hljs-comment">// The type of the tile, if it is wall, floor, etc</span><font></font>
}<font></font>
<font></font>
[<span class="hljs-meta">Serializable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Position</span> { <span class="hljs-comment">//A class that saves the position of any cell</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> x;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> y;<font></font>
}<font></font>
<font></font>
[<span class="hljs-meta">Serializable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Wall</span> { <span class="hljs-comment">// A class for saving the wall information, for the dungeon generation algorithm</span>
    <span class="hljs-keyword">public</span> List&lt;Position&gt; positions;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> direction;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> length;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> hasFeature = <span class="hljs-literal">false</span>;<font></font>
}<font></font>
<font></font>
[<span class="hljs-meta">Serializable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Feature</span> { <span class="hljs-comment">// A class for saving the feature (corridor or room) information, for the dungeon generation algorithm</span>
    <span class="hljs-keyword">public</span> List&lt;Position&gt; positions;
    <span class="hljs-keyword">public</span> Wall[] walls;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> type;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> width;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DungeonGenerator.cs:</font></font></b><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> UnityEngine.UI;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DungeonGenerator</span> : <span class="hljs-title">MonoBehaviour</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapWidth;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapHeight;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMaxRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMaxRoom;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxFeatures;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> isASCII;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitializeDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        MapManager.map = <span class="hljs-keyword">new</span> Tile[mapWidth, mapHeight];<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GenerateDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        FirstRoom();<font></font>
        DrawMap(isASCII);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FirstRoom</span>(<span class="hljs-params"></span>)</span> {<font></font>
        Feature room = <span class="hljs-keyword">new</span> Feature();<font></font>
        room.positions = <span class="hljs-keyword">new</span> List&lt;Position&gt;();<font></font>
<font></font>
        <span class="hljs-keyword">int</span> roomWidth = Random.Range(widthMinRoom, widthMaxRoom);
        <span class="hljs-keyword">int</span> roomHeight = Random.Range(heightMinRoom, heightMaxRoom);<font></font>
<font></font>
        <span class="hljs-keyword">int</span> xStartingPoint = mapWidth / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">int</span> yStartingPoint = mapHeight / <span class="hljs-number">2</span>;<font></font>
<font></font>
        xStartingPoint -= Random.Range(<span class="hljs-number">0</span>, roomWidth);<font></font>
        yStartingPoint -= Random.Range(<span class="hljs-number">0</span>, roomHeight);<font></font>
<font></font>
        room.walls = <span class="hljs-keyword">new</span> Wall[<span class="hljs-number">4</span>];<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; room.walls.Length; i++) {<font></font>
            room.walls[i] = <span class="hljs-keyword">new</span> Wall();<font></font>
            room.walls[i].positions = <span class="hljs-keyword">new</span> List&lt;Position&gt;();<font></font>
            room.walls[i].length = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">switch</span> (i) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"South"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"North"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"West"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"East"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; roomHeight; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; roomWidth; x++) {<font></font>
                Position position = <span class="hljs-keyword">new</span> Position();<font></font>
                position.x = xStartingPoint + x;<font></font>
                position.y = yStartingPoint + y;<font></font>
<font></font>
                room.positions.Add(position);<font></font>
<font></font>
                MapManager.map[position.x, position.y] = <span class="hljs-keyword">new</span> Tile();<font></font>
                MapManager.map[position.x, position.y].xPosition = position.x;<font></font>
                MapManager.map[position.x, position.y].yPosition = position.y;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">0</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">0</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (y == (roomHeight - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">1</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">1</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">2</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">2</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x == (roomWidth - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">3</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">3</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Floor"</span>;<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
<font></font>
        room.width = roomWidth;<font></font>
        room.height = roomHeight;<font></font>
        room.type = <span class="hljs-string">"Room"</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawMap</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> isASCII</span>)</span> {
        <span class="hljs-keyword">if</span> (isASCII) {<font></font>
            Text screen = GameObject.Find(<span class="hljs-string">"ASCIITest"</span>).GetComponent&lt;Text&gt;();<font></font>
<font></font>
            <span class="hljs-keyword">string</span> asciiMap = <span class="hljs-string">""</span>;<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = (mapHeight - <span class="hljs-number">1</span>); y &gt;= <span class="hljs-number">0</span>; y--) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; mapWidth; x++) {
                    <span class="hljs-keyword">if</span> (MapManager.map[x,y] != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">switch</span> (MapManager.map[x, y].type) {
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Wall"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"#"</span>;
                                <span class="hljs-keyword">break</span>;
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Floor"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"."</span>;
                                <span class="hljs-keyword">break</span>;<font></font>
                        }<font></font>
                    } <span class="hljs-keyword">else</span> {<font></font>
                        asciiMap += <span class="hljs-string">" "</span>;<font></font>
                    }<font></font>
<font></font>
                    <span class="hljs-keyword">if</span> (x == (mapWidth - <span class="hljs-number">1</span>)) {<font></font>
                        asciiMap += <span class="hljs-string">"\n"</span>;<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
<font></font>
            screen.text = asciiMap;<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameManager.cs:</font></font></b><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameManager</span> : <span class="hljs-title">MonoBehaviour</span><font></font>
{<font></font>
    DungeonGenerator dungeonGenerator;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> {<font></font>
        dungeonGenerator = GetComponent&lt;DungeonGenerator&gt;();<font></font>
<font></font>
        dungeonGenerator.InitializeDungeon();<font></font>
        dungeonGenerator.GenerateDungeon();<font></font>
    }<font></font>
}</code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id490812/index.html">Pengalaman Pengajuan Sertifikasi Spring Professional 5</a></li>
<li><a href="../id490816/index.html">Bagaimana situs E-commerce menolak botnet AuthBots?</a></li>
<li><a href="../id490820/index.html">Semua Habr dalam satu basis</a></li>
<li><a href="../id490822/index.html">Bahan terbaik untuk meretas mobil dengan DEF CON 2019-2020</a></li>
<li><a href="../id490826/index.html">Sumber efisiensi produksi</a></li>
<li><a href="../id490830/index.html">Manajemen Kata Sandi dalam Zimbra Collaboration Suite Open-Source Edition</a></li>
<li><a href="../id490832/index.html">Penandaan sepatu: bagaimana kami memasukkan ke dalam 2 juta kode penandaan "1C" + "Tanda Jujur"</a></li>
<li><a href="../id490836/index.html">Cara membuka komentar dan tidak tenggelam dalam spam</a></li>
<li><a href="../id490838/index.html">WiFi 6 ada di sini: apa yang ditawarkan pasar dan mengapa kita membutuhkan teknologi ini</a></li>
<li><a href="../id490840/index.html">Perencanaan sumber daya. Bagian 4.1. Sebelum Anda membuat rencana sumber daya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>