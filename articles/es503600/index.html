<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòô üë©‚Äçüë©‚Äçüëß‚Äçüë¶ ‚úãüèΩ STM32MP1: U-Boot, Buildroot, Arch Linux y un poco de Debian üíê üë®üèª‚Äçüè´ üë©üèª‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! 
 
 Hace alg√∫n tiempo, STMicroelectronics lanz√≥ interesantes procesadores de la serie STM32MP1. Cuando finalmente puse mis manos en la plac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>STM32MP1: U-Boot, Buildroot, Arch Linux y un poco de Debian</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503600/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hola Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hace alg√∫n tiempo, STMicroelectronics lanz√≥ interesantes procesadores de la serie STM32MP1. </font><font style="vertical-align: inherit;">Cuando finalmente puse mis manos en la placa de depuraci√≥n basada en este procesador, me sorprendi√≥ descubrir que carece de compilaciones basadas en distribuciones populares (Debian, Arch Linux, etc.). </font><font style="vertical-align: inherit;">Todo lo que quedaba era intentar adaptar alg√∫n kit de distribuci√≥n para esta placa. </font><font style="vertical-align: inherit;">Basado en los resultados de esto, apareci√≥ este art√≠culo.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ws/zo/9c/wszo9cao_bq-m_5z9q9fk8moxls.jpeg"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øCu√°les son las caracter√≠sticas?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este art√≠culo no estar√≠a completo sin al menos una breve descripci√≥n de las caracter√≠sticas de los procesadores de la serie STM32MP1. </font><font style="vertical-align: inherit;">Hay tres familias de procesadores en la serie STM32MP1: STM32MP151, STM32MP153 y STM32MP157. </font><font style="vertical-align: inherit;">Sus caracter√≠sticas principales se dan en la tabla. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rf/ez/9u/rfez9ud26bcli38_4juxyx-byya.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver en la tabla, la diferencia entre las familias es que STM32MP151 tiene un n√∫cleo de Cortex-A7, mientras que STM32MP153 y STM32MP157 tienen dos n√∫cleos, y STM32MP157 tambi√©n tiene soporte para GPU 3D. </font><font style="vertical-align: inherit;">Pero, en general, las caracter√≠sticas de estos procesadores en 2020 no causan ninguna impresi√≥n, son m√°s bien modestas. </font><font style="vertical-align: inherit;">¬øPor qu√© segu√≠ prest√°ndoles atenci√≥n?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© STM32MP1?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, puede surgir una pregunta completamente l√≥gica: ¬øhay una Raspberry Pi, hay una Banana Pi, hay una Orange Pi y, finalmente, por qu√© necesitamos alguna otra STM32MP1? </font><font style="vertical-align: inherit;">Adem√°s, todas estas placas suelen tener un rendimiento significativamente mayor que el objeto de nuestro estudio. </font><font style="vertical-align: inherit;">La respuesta es simple: si est√° haciendo manualidades para uso dom√©stico, es necesario tomar la frambuesa y estar√° bien. </font><font style="vertical-align: inherit;">Pero si hablamos de productos producidos en masa para aplicaciones industriales, aqu√≠ otras cosas comienzan a desempe√±ar un papel decisivo, gracias al cual el STM32MP1 es el ganador:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rango de temperatura de funcionamiento. </font><font style="vertical-align: inherit;">Para STM32MP1, comienza a menos 40 grados, mientras que para muchos procesadores de otras computadoras de una sola placa es bueno si es menos 20.</font></font></li>
<li>  .  STMicroelectronics      ,            .</li>
<li>      .   DigiKey  Mouser       STM32MP1,           .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, ST32MP1 no es el √∫nico procesador en el mercado para aplicaciones industriales. </font><font style="vertical-align: inherit;">Hay tanto NXP como TI. </font><font style="vertical-align: inherit;">En cuanto a TI, ten√≠a un proyecto de un m√≥dulo bastante complejo basado en √©l, y hab√≠a un sedimento de un n√∫mero notable de caracter√≠sticas de hardware que no estaban cubiertas en la documentaci√≥n, pero si no se respetaba, el procesador podr√≠a fallar por completo, y no de inmediato, sino con el tiempo y en el momento m√°s inoportuno. </font><font style="vertical-align: inherit;">Adem√°s, era un procesador de un solo n√∫cleo, y con un aumento en el n√∫mero de tareas que se le asignaron, surgieron problemas cada vez m√°s frecuentes. </font><font style="vertical-align: inherit;">Al mismo tiempo, estaba lidiando con microcontroladores STMicroelectronics, y demostraron ser bastante buenos, as√≠ que decid√≠ tratar de elegir este nuevo peque√±o.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Junta de depuraci√≥n</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para los experimentos, compr√© una placa de depuraci√≥n STM32MP157A-DK1. </font><font style="vertical-align: inherit;">Esta placa es bastante modesta en t√©rminos de equipamiento: no tiene una pantalla LCD como el STM32MP157C-DK2 o un perif√©rico tan rico como el STM32MP157A-EV1. </font><font style="vertical-align: inherit;">Sin embargo, hay una ranura para tarjeta microSD, una consola USB-UART, varios puertos USB y Ethernet. </font><font style="vertical-align: inherit;">Para el primer comienzo, m√°s que suficiente. </font><font style="vertical-align: inherit;">Y para diluir la historia seca con una imagen, adjunto una foto de este tablero de depuraci√≥n.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jq/o9/ta/jqo9tap0mu2icbhbofhdjoocquk.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© es del software listo para usar?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En STMicroelectronics, todo suele ser bastante bueno en t√©rminos de hardware, pero terrible en t√©rminos de software. Todas estas modificaciones de Atollic True Studio, CubeMX, CubeIDE, que son cada vez m√°s defectuosas con cada nueva versi√≥n, evocan cierta angustia. La situaci√≥n es un poco mejor con el soporte STM32MP1. STMicroelectronics ofrece solo un cierto conjunto de OpenSTLinux. Este conjunto es una distribuci√≥n construida utilizando el Proyecto Yocto. Por supuesto, todo esto puede existir de esta forma, pero para m√≠ el principal inconveniente fue la falta de acceso a repositorios de distribuciones conocidas. Esto significa que no podr√° poner en su placa ninguna utilidad de los repositorios de distribuciones populares simplemente ejecutando un comando como apt-get install. A menudo esto no es necesario para soluciones integradas, pero las situaciones son posibles,cuando tal oportunidad definitivamente no ser√° superflua.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qu√© hacemos?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, la tarea es clara: necesitamos ejecutar una distribuci√≥n popular en nuestro tablero de depuraci√≥n. </font><font style="vertical-align: inherit;">Mi elecci√≥n recay√≥ en Arch Linux. </font><font style="vertical-align: inherit;">Esta no es la distribuci√≥n m√°s f√°cil, pero est√° bien adaptada para dispositivos ARM: hay ensamblajes listos para usar y un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sitio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oficial </font><font style="vertical-align: inherit;">dedicado a esto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo primero que trat√© de resolver el problema con un chasquido: acabo de deslizar el n√∫cleo listo para el cargador de arranque de la distribuci√≥n de Arch Linux, ensamblado bajo armv7. </font><font style="vertical-align: inherit;">Esto a veces funcion√≥ en otras placas, pero hab√≠a un fiasco esper√°ndome: a pesar de que el n√∫cleo se ensambl√≥ para la arquitectura correcta, no comenz√≥. </font><font style="vertical-align: inherit;">Bueno, entonces necesitas ensamblar tu kernel y al mismo tiempo tu cargador. </font><font style="vertical-align: inherit;">Mi plan de acci√≥n fue este:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Construye el gestor de arranque U-Boot.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Construye el kernel de Linux. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Marcamos la tarjeta microSD.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escribimos el gestor de arranque, el n√∫cleo y el sistema de archivos ra√≠z en la tarjeta microSD.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lucro</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preparaci√≥n de la asamblea</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para implementar este plan, necesitamos una computadora con Linux y un lector de tarjetas para grabar en una tarjeta microSD. </font><font style="vertical-align: inherit;">Utilic√© una computadora port√°til con Debian 10, pero en general esto no es importante, los nombres de las utilidades pueden diferir ligeramente. </font><font style="vertical-align: inherit;">Entonces, ponemos las utilidades requeridas. </font><font style="vertical-align: inherit;">Noto de inmediato que ahora y m√°s todos los comandos deben ejecutarse como root o mediante sudo.</font></font><br>
<br>
<pre><code class="cpp hljs">apt-get install git<font></font>
apt-get install make<font></font>
apt-get install gcc<font></font>
apt-get install gcc-arm-linux-gnueabihf<font></font>
apt-get install bison<font></font>
apt-get install flex<font></font>
apt-get install g++<font></font>
apt-get install rsync<font></font>
apt-get install libncurses-dev</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En preparaci√≥n para el ensamblaje, creamos tres directorios en el directorio de trabajo: u-boot (para el gestor de arranque), buildroot (para la compilaci√≥n del sistema) y archlinux (para la distribuci√≥n):</font></font><br>
<br>
<pre><code class="cpp hljs">mkdir u-boot<font></font>
mkdir buildroot<font></font>
mkdir archlinux</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Necesitaremos m√°s estos directorios. </font><font style="vertical-align: inherit;">Me referir√© a estos nombres m√°s adelante en el texto del art√≠culo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensamblaje de arranque en U</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya se han escrito muchos art√≠culos sobre U-Boot, y como parte de esto, no profundizar√© en las explicaciones de qu√© es, para qu√© sirve y c√≥mo funciona. Solo puedo decir que este es un gestor de arranque que proporciona arranque de Linux en dispositivos ARM. El c√≥digo fuente para el gestor de arranque U-Boot est√° disponible en GitHub. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para construir U-Boot, en primer lugar clonamos el repositorio de U-Boot en el directorio u-boot que creamos anteriormente:</font></font><br>
<br>
<pre><code class="cpp hljs">git clone https:<span class="hljs-comment">//github.com/u-boot/u-boot</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para construir con √©xito U-Boot, necesitamos un archivo de √°rbol de dispositivo y un archivo de configuraci√≥n de U-Boot. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El archivo del √°rbol de dispositivos es un archivo dependiente del dispositivo. Este archivo describe la configuraci√≥n del procesador para una placa espec√≠fica. Si crea su hardware en un procesador ARM y planea ejecutar Linux en √©l, deber√° desarrollar el archivo de √°rbol de su dispositivo (o adaptar uno listo para usar). Sin embargo, muchas placas de depuraci√≥n ya tienen archivos listos para usar: los desarrolladores U-Boot interesados ‚Äã‚Äãlos incluyen en su repositorio. Entonces, mira el directorio u-boot / arch / arm / dts. Debe contener el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archivo stm32mp157a-dk1.dtb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : este es el archivo de √°rbol de dispositivo para nuestra placa de depuraci√≥n.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el archivo de configuraci√≥n de U-Boot, se escriben las configuraciones b√°sicas del cargador de arranque. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Configurar U-Boot desde cero es un proceso bastante largo y laborioso, porque hay muchas configuraciones. </font><font style="vertical-align: inherit;">Para estos fines, hay configuradores gr√°ficos y de consola. </font><font style="vertical-align: inherit;">Sin embargo, aqu√≠ tuvimos suerte: en el directorio u-boot / configs hay un archivo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp15_basic_defconfig</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este es el archivo de configuraci√≥n b√°sica de U-Boot para las placas de depuraci√≥n STM32MP15. </font><font style="vertical-align: inherit;">Abrimos este archivo y vemos que para comenzar r√°pidamente es suficiente cambiar solo una l√≠nea: en su lugar</font></font><br>
<br>
<pre><code class="cpp hljs">CONFIG_DEFAULT_DEVICE_TREE=‚Äùstm32mp157c-ev1‚Äù</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
escribir</font></font><br>
<br>
<pre><code class="cpp hljs">CONFIG_DEFAULT_DEVICE_TREE=‚Äùstm32mp157a-dk1‚Äù</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con esta l√≠nea, le decimos al gestor de arranque que necesitamos usar el archivo de √°rbol del dispositivo para nuestra placa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora est√°s listo para construir U-Boot. </font><font style="vertical-align: inherit;">Usamos nuestra configuraci√≥n:</font></font><br>
<br>
<pre><code class="cpp hljs">make CROSS_COMPILE=arm-linux-gnueabihf- stm32mp15_basic_defconfig</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y ejecuta la asamblea:</font></font><br>
<br>
<pre><code class="cpp hljs">make CROSS_COMPILE=arm-linux-gnueabihf-</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si todo sali√≥ bien, entonces en el directorio u-boot deber√≠amos tener un mont√≥n de archivos. </font><font style="vertical-align: inherit;">De estos, dos son de inter√©s para nosotros: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-boot-spl.stm32</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-boot.img</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El primer archivo es el denominado First Stage Boot Loader (FSBL). </font><font style="vertical-align: inherit;">Est√° ubicado frente a U-Boot, se inicia primero e inicializa la memoria DDR3, que es necesaria para iniciar U-Boot. </font><font style="vertical-align: inherit;">En otras placas, FSBL a menudo se combina con U-Boot en una imagen, pero aqu√≠ debe escribir cada imagen en una unidad flash USB por separado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eso es todo con U-Boot por ahora, guarde los archivos designados y proceda directamente al ensamblaje del kernel de Linux.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensamblaje del kernel de Linux</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usar√© Buildroot para construir el kernel de Linux. Por supuesto, para estos prop√≥sitos, puede usar el Yocto igualmente popular, o incluso tratar de construir el n√∫cleo desde la fuente de kernel.org. Sin embargo, ten√≠a algo de experiencia trabajando con Buildroot, as√≠ que decid√≠ hacerlo. Adem√°s, Buildroot tambi√©n construye el sistema de archivos ra√≠z (rootfs) e incluso el cargador U-Boot. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, por cualquier medio disponible, descargue el archivo de Buildroot desde el sitio </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">web</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oficial </font><font style="vertical-align: inherit;">, descompr√≠malo en el directorio de buildroot y vaya a √©l. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como en el caso de U-Boot, lo primero que debe tener en cuenta es el archivo de configuraci√≥n de nuestro hardware. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos al directorio buildroot / configs y vemos que los desarrolladores ya han agregado un archivo de configuraci√≥n para nuestra placa: hay un archivo</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp157a_dk1_defconfig</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (verdadero para Buildroot-2020.05 build, en versiones anteriores de este archivo todav√≠a no exist√≠a). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trat√© de construir el kernel 5.4.26 usando este archivo de configuraci√≥n, y generalmente comenz√≥ con √©xito en mi placa. Sin embargo, por alguna raz√≥n, el archivo del √°rbol de dispositivos Linux en este ensamblaje result√≥ truncado: de forma predeterminada, ni siquiera era compatible con los puertos USB. Esperemos que con el tiempo se solucione este error, pero ¬øqu√© hacer ahora?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Busqu√© en Google este problema y encontr√© repositorios de STMicroelectronics, donde encontr√© fuentes de Linux 4.19 con parches para sus productos. </font><font style="vertical-align: inherit;">Incluyendo, los archivos DTB correctos tambi√©n estaban all√≠. </font><font style="vertical-align: inherit;">Solo queda decirle a Buildroot que use este repositorio al construir el kernel. </font><font style="vertical-align: inherit;">Para hacer esto, copie el archivo stm32mp157a_dk1_defconfig y c√°mbiele el nombre a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp157a_dk1_new_defconfig</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">√Åbralo y realice los siguientes cambios: en su </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lugar</font></font><br>
<br>
<pre><code class="cpp hljs">BR2_PACKAGE_HOST_LINUX_HEADERS_CUSTOM_5_4=y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nosotros escribimos </font></font><br>
<br>
<pre><code class="cpp hljs">BR2_PACKAGE_HOST_LINUX_HEADERS_CUSTOM_4_19=y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En lugar </font></font><br>
<br>
<pre><code class="cpp hljs">BR2_LINUX_KERNEL_CUSTOM_VERSION=y<font></font>
BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE=<span class="hljs-string">"5.4.26"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nosotros escribimos</font></font><br>
<br>
<pre><code class="cpp hljs">BR2_LINUX_KERNEL_CUSTOM_TARBALL=y<font></font>
BR2_LINUX_KERNEL_CUSTOM_TARBALL_LOCATION=<span class="hljs-string">"$(call github,STMicroelectronics,linux,v4.19-stm32mp-r1.2)/linux-v4.19-stm32mp-r1.2.tar.gz"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Guarde y cierre el archivo. </font><font style="vertical-align: inherit;">El archivo de configuraci√≥n est√° listo, apliqu√©moslo (debe ejecutarlo desde el directorio buildroot):</font></font><br>
<br>
<pre><code class="cpp hljs">make CROSS_COMPILE=arm-linux-gnueabihf- stm32mp157a_dk1_new_defconfig</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este comando transferir√° informaci√≥n desde nuestro archivo de configuraci√≥n stm32mp157a_dk1_defconfig al archivo .config, que se encuentra en el directorio buildroot. En el futuro, el ensamblado se construir√° sobre la base del archivo .config. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, ahora todo est√° casi listo para comenzar el proceso de compilaci√≥n, pero antes de eso debe configurar nuestro n√∫cleo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ vale la pena decir que, por defecto, se incluir√° una funcionalidad m√≠nima en el n√∫cleo. Si queremos expandirlo, entonces el n√∫cleo deber√° configurarse por nosotros mismos. Como m√≠nimo, deber√° agregar soporte para el Grupo de control al n√∫cleo: sin esto, nuestro Arch Linux no se iniciar√°. Adem√°s, como ejemplo, demostrar√© c√≥mo agregar soporte para unidades flash USB al n√∫cleo: como resultado, nuestra placa de depuraci√≥n podr√° trabajar con unidades flash.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para iniciar el configurador de kernel desde el directorio buildroot, ejecute el comando</font></font><br>
<br>
<pre><code class="cpp hljs">make linux-menuconfig</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
e ir a tomar el t√©. </font><font style="vertical-align: inherit;">Este proceso no es r√°pido y, dependiendo de la potencia de su computadora, puede tomar de quince minutos a varias horas. </font><font style="vertical-align: inherit;">Importante: durante el trabajo de buildroot necesita una conexi√≥n estable a Internet, se descargar√°n muchos paquetes diferentes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si en el proceso aparece un error</font></font><br>
<br>
<pre><code class="cpp hljs">configure: error: <span class="hljs-function">you should <span class="hljs-keyword">not</span> run configure as <span class="hljs-title">root</span> <span class="hljs-params">(<span class="hljs-built_in">set</span> FORCE_UNSAFE_CONFIGURE=<span class="hljs-number">1</span> in environment to bypass <span class="hljs-keyword">this</span> check)</span>
See `config.<span class="hljs-built_in">log</span>' <span class="hljs-keyword">for</span> more details</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
necesitar√° ejecutar el comando</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">export</span> FORCE_UNSAFE_CONFIGURE=<span class="hljs-number">1</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
y reinicie el configurador del kernel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, deber√≠a aparecer la ventana del configurador: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xs/ah/h7/xsahh7p0h-ee5ly4sz54vvg1gcc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agregar soporte de Grupo de control: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuraci√≥n general -&gt; Soporte de Grupo de control</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y establecer el asterisco con un espacio:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/x-/hu/lm/x-hulmm3zia2p1azslxcwuszfto.jpeg"><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øY c√≥mo agregar soporte para unidades flash?</font></font></b>
                        <div class="spoiler_text">  SCSI .     80- ,  , ,     USB FLASH .   <b>Device Drivers -&gt; SCSI support</b>       :<br>
<br>
<img src="https://habrastorage.org/webt/kh/59/mq/kh59mqwq_7lppvsozcmqzq4pp94.jpeg"><br>
<br>
     USB FLASH .   <b>Device Drivers -&gt; USB support</b>    <b>USB Mass Storage support</b>:<br>
<br>
<img src="https://habrastorage.org/webt/ar/uu/qy/aruuqyuuanaakzw8mm1givi6yua.jpeg"><br>
<br>
,     FLASH     : <b>File systems -&gt; Native language support -&gt; Codepage 437</b>  <b>File systems -&gt; Native language support -&gt; NLS ISO 8859-1:</b><br>
<br>
<img src="https://habrastorage.org/webt/n2/mt/_x/n2mt_x_utdbu9zdr1dxcugqmaoy.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/0o/sy/f8/0osyf81e1zk8m8fyic9rhhh4yw0.jpeg"><br>
<br>
   ,  USB FLASH      . <br>
</div>
                    </div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de realizar todos los ajustes en el configurador del n√∫cleo, gu√°rdelos con el bot√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guardar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y salga del configurador con el bot√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salir</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora solo queda comenzar el proceso de compilaci√≥n con el comando:</font></font><br>
<br>
<pre><code class="cpp hljs">make CROSS_COMPILE=arm-linux-gnueabihf-</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
y puedes ir a tomar el t√© por segunda vez, este proceso tambi√©n lleva mucho tiempo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si todo sali√≥ bien, el siguiente conjunto de archivos deber√≠a aparecer en el directorio buildroot / output / images:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rootfs.ext2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un sistema de archivos ra√≠z compilado con ext2. </font><font style="vertical-align: inherit;">No nos interesa;</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rootfs.ext4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un sistema de archivos ra√≠z compilado con ext4. </font><font style="vertical-align: inherit;">Nos ser√° √∫til un poco m√°s tarde;</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdcard.img</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : una imagen de una tarjeta microSD, que incluye FSBL + U-Boot + zImage + rootfs. </font><font style="vertical-align: inherit;">Un archivo para los perezosos, le permite no molestarse en marcar una tarjeta microSD e inmediatamente cargar todo el sistema en ella. </font><font style="vertical-align: inherit;">Por supuesto, este no es nuestro camino :).</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp157a-dk1.dtb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : archivo del √°rbol de dispositivos. </font><font style="vertical-align: inherit;">Aseg√∫rese de ser √∫til para iniciar el sistema;</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-boot.img</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-boot-spl.stm32</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : archivo FSBL y U-Boot. </font><font style="vertical-align: inherit;">Como los recolectamos en el √∫ltimo paso, no los necesitamos;</font></font><br>
 <div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© los recolectamos por separado?</font></font></b>
                        <div class="spoiler_text"> , Buildroot             U-Boot.    ,       .                 U-Boot,        ‚Äì     Linux.<br>
 </div>
                    </div></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zImage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - el coraz√≥n de todo el sistema - un archivo comprimido de kernel de Linux.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, el proceso de ensamblaje se completa, ahora procedemos a marcar la tarjeta de memoria microSD y crear particiones en ella.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Particionamiento y secciones de una tarjeta microSD</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Marcar una tarjeta microSD y crear particiones es una etapa muy importante, fuertemente ligada a una plataforma de hardware espec√≠fica. Desafortunadamente, la informaci√≥n sobre este problema en un procesador espec√≠fico no siempre es f√°cil de encontrar, e incluso si recopila U-Boot totalmente funcional y el kernel de Linux, nada de esto funcionar√° con el m√°s m√≠nimo error en el dise√±o de la tarjeta microSD. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inmediatamente, observo que la tarjeta microSD con la que se inicia el sistema en el STM32MP1 debe tener marcado GPT. La utilidad </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gdisk</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nos ayudar√° con esto </font><font style="vertical-align: inherit;">, pero m√°s sobre eso m√°s adelante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las secciones de la tarjeta microSD deber√≠an tener este aspecto:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xs/-l/rr/xs-lrrpr3mi-vrdqemol2sy8szg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver en la figura, la tarjeta debe contener al menos 5 particiones: fsbl1, fsbl2, ssbl, kernel, rootfs. </font><font style="vertical-align: inherit;">Adem√°s, tambi√©n puede crear una o m√°s secciones de datos para almacenar cualquier informaci√≥n sobre ellas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las </font><b><font style="vertical-align: inherit;">secciones </font></b></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fsbl1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fsbl2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son completamente id√©nticas y el cargador de arranque primario est√° escrito en ellas (como recordar√°n, este es el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archivo u-boot-spl.stm32</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que recibimos durante el proceso de ensamblaje de U-Boot). </font><font style="vertical-align: inherit;">A pesar de que todo deber√≠a funcionar y con solo una de esas secciones, la documentaci√≥n en STM2MP1 recomienda hacer dos de ellas. </font><font style="vertical-align: inherit;">Otros requisitos se aplican a estas secciones:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada partici√≥n debe tener un tama√±o de 256 KB.</font></font></li>
<li>    ,      <b>fsbl</b> (fsbl1  fsbl2).   :          ,     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La secci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ssbl est√°</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dise√±ada para escribir el gestor de arranque U-Boot (el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archivo u-boot.img</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que recibimos durante el proceso de ensamblaje de U-Boot). El tama√±o de partici√≥n ssbl recomendado es de 2 MB. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La secci√≥n del </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kernel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est√° </font><font style="vertical-align: inherit;">destinada a escribirle el kernel de Linux (archivo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zImage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), el √°rbol de dispositivos ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archivo stm32mp157a-dk1.dtb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), as√≠ como el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">script</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para U-Boot, con el que se iniciar√° el sistema. El tama√±o de partici√≥n del n√∫cleo recomendado es de 64 MB. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La secci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rootfs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es para escribir el sistema de archivos ra√≠z. Intentaremos escribirle el sistema de archivos ra√≠z compilado por Buildroot, as√≠ como el sistema de archivos ra√≠z de Arch Linux. El tama√±o de partici√≥n rootfs recomendado es de 1 GB o m√°s.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La secci√≥n de datos est√° destinada a almacenar datos de usuario. </font><font style="vertical-align: inherit;">Puedes hacer una o varias de estas secciones. </font><font style="vertical-align: inherit;">Y puedes prescindir de √©l en absoluto. </font><font style="vertical-align: inherit;">En este art√≠culo, no crear√© esta secci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, comenzamos a marcar. </font><font style="vertical-align: inherit;">Insertamos la tarjeta microSD en el lector de tarjetas de nuestra computadora con Linux a bordo y usando cualquier medio disponible (por ejemplo, usando dmesg) determinamos el nombre del dispositivo que aparece. </font><font style="vertical-align: inherit;">En mi caso, esto es / dev / sdb. </font><font style="vertical-align: inherit;">En su caso, puede ser un nombre diferente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ejecute la utilidad gdisk y elimine completamente el marcado en la tarjeta microSD:</font></font><br>
<br>
<pre><code class="cpp hljs">root@debian:/home/myuser<span class="hljs-meta"># gdisk /dev/sdb</span>
<span class="hljs-function">GPT <span class="hljs-title">fdisk</span> <span class="hljs-params">(gdisk)</span> version 1.0.3
Partition table scan:
  MBR: protective
  BSD: <span class="hljs-keyword">not</span> present
  APM: <span class="hljs-keyword">not</span> present
  GPT: present
Found valid GPT with protective MBR</span>; <span class="hljs-keyword">using</span> GPT.<font></font>
Command (? <span class="hljs-keyword">for</span> help): <span class="hljs-function">x
Expert <span class="hljs-title">command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: z
About to wipe out GPT on /dev/sdb. Proceed? <span class="hljs-params">(Y/N)</span>: y
GPT data structures destroyed! You may now partition the disk <span class="hljs-keyword">using</span> fdisk <span class="hljs-keyword">or</span>
other utilities.
Blank out MBR? <span class="hljs-params">(Y/N)</span>: y</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por si acaso, martillamos el comienzo de la tarjeta microSD con ceros. </font></font><br>
<br>
<pre><code class="cpp hljs">dd <span class="hljs-keyword">if</span>=/dev/zero of=/dev/sdb bs=<span class="hljs-number">1</span>M count=<span class="hljs-number">64</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora ejecute gdisk nuevamente, agregue el marcado y cree 5 particiones en la tarjeta microSD de acuerdo con la tabla que proporcion√© anteriormente:</font></font><br>
<br>
<pre><code class="cpp hljs">root@debian:/home/myuser<span class="hljs-meta"># gdisk /dev/sdb</span>
<span class="hljs-function">GPT <span class="hljs-title">fdisk</span> <span class="hljs-params">(gdisk)</span> version 1.0.3

Partition table scan:
  MBR: <span class="hljs-keyword">not</span> present
  BSD: <span class="hljs-keyword">not</span> present
  APM: <span class="hljs-keyword">not</span> present
  GPT: <span class="hljs-keyword">not</span> present

Creating <span class="hljs-keyword">new</span> GPT entries.

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: o
This option deletes all partitions <span class="hljs-keyword">and</span> creates a <span class="hljs-keyword">new</span> protective MBR.
Proceed? <span class="hljs-params">(Y/N)</span>: y

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>)</span>: 1
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">2048</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">2048</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: +<span class="hljs-number">256</span>K<font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">2</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">2</span>)</span>: 2
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">4096</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">4096</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: +<span class="hljs-number">256</span>K<font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">3</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">3</span>)</span>: 3
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">6144</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">6144</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: +<span class="hljs-number">2</span>M<font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">4</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">4</span>)</span>: 4
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">10240</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">10240</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: +<span class="hljs-number">64</span>M<font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">5</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">5</span>)</span>: 5
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">141312</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">141312</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: <font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? <span class="hljs-params">(Y/N)</span>: y
OK</span>; <span class="hljs-function">writing <span class="hljs-keyword">new</span> GUID partition <span class="hljs-title">table</span> <span class="hljs-params">(GPT)</span> to /dev/sdb.
The operation has completed successfully.</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego, agregue los nombres a las secciones de la tarjeta microSD. </font><font style="vertical-align: inherit;">Como recordar√°, esto es especialmente cr√≠tico para las primeras secciones donde se escribir√° FSBL: si no les asigna los nombres requeridos, el sistema no se iniciar√°:</font></font><br>
<br>
<pre><code class="cpp hljs">root@debian:/home/myuser<span class="hljs-meta"># gdisk /dev/sdb</span>
<span class="hljs-function">GPT <span class="hljs-title">fdisk</span> <span class="hljs-params">(gdisk)</span> version 1.0.3

Partition table scan:
  MBR: protective
  BSD: <span class="hljs-keyword">not</span> present
  APM: <span class="hljs-keyword">not</span> present
  GPT: present

Found valid GPT with protective MBR</span>; <span class="hljs-keyword">using</span> GPT.<font></font>
<font></font>
Command (? <span class="hljs-keyword">for</span> help): <span class="hljs-function">c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 1
Enter name: fsbl1

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 2
Enter name: fsbl2

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 3
Enter name: ssbl

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 4
Enter name: kernel

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 5
Enter name: roootfs

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? <span class="hljs-params">(Y/N)</span>: y
OK</span>; <span class="hljs-function">writing <span class="hljs-keyword">new</span> GUID partition <span class="hljs-title">table</span> <span class="hljs-params">(GPT)</span> to /dev/sdb.
The operation has completed successfully.</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al final del trabajo con la tarjeta microSD, necesitamos agregar el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atributo de arranque BIOS heredado</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a la secci√≥n en la que escribiremos el kernel de Linux. </font><font style="vertical-align: inherit;">Sin este atributo, el n√∫cleo se neg√≥ a comenzar:</font></font><br>
<br>
<pre><code class="cpp hljs">root@debian:/home/myuser<span class="hljs-meta"># gdisk /dev/sdb</span>
<span class="hljs-function">GPT <span class="hljs-title">fdisk</span> <span class="hljs-params">(gdisk)</span> version 1.0.3

Partition table scan:
  MBR: protective
  BSD: <span class="hljs-keyword">not</span> present
  APM: <span class="hljs-keyword">not</span> present
  GPT: present

Found valid GPT with protective MBR</span>; <span class="hljs-keyword">using</span> GPT.<font></font>
<font></font>
Command (? <span class="hljs-keyword">for</span> help): <span class="hljs-function">x

Expert <span class="hljs-title">command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: a
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 4
Known attributes are:
0: system partition
1: hide from EFI
2: legacy BIOS bootable
60: read-only
62: hidden
63: <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> automount

Attribute value is 0000000000000000. Set fields are:
  No fields <span class="hljs-built_in">set</span>

Toggle which attribute <span class="hljs-title">field</span> <span class="hljs-params">(<span class="hljs-number">0</span><span class="hljs-number">-63</span>, <span class="hljs-number">64</span> <span class="hljs-keyword">or</span> &lt;Enter&gt; to <span class="hljs-built_in">exit</span>)</span>: 2
Have enabled the 'legacy BIOS bootable' attribute.
Attribute value is 0000000000000004. Set fields are:
2 <span class="hljs-params">(legacy BIOS bootable)</span>

Toggle which attribute <span class="hljs-title">field</span> <span class="hljs-params">(<span class="hljs-number">0</span><span class="hljs-number">-63</span>, <span class="hljs-number">64</span> <span class="hljs-keyword">or</span> &lt;Enter&gt; to <span class="hljs-built_in">exit</span>)</span>: 

Expert <span class="hljs-title">command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? <span class="hljs-params">(Y/N)</span>: y
OK</span>; <span class="hljs-function">writing <span class="hljs-keyword">new</span> GUID partition <span class="hljs-title">table</span> <span class="hljs-params">(GPT)</span> to /dev/sdb.
The operation has completed successfully.</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eso es todo, el dise√±o de la tarjeta de memoria est√° listo. </font><font style="vertical-align: inherit;">Por si acaso, verifique que todo est√© registrado como deber√≠a. </font><font style="vertical-align: inherit;">Para hacer esto, ejecute </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gdisk</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nuevamente </font><font style="vertical-align: inherit;">y ejecute el comando </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">El resultado deber√≠a aconsejar la imagen: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q9/ko/ff/q9koffmcelcxpna_qtwtfkdlzz8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ahora cree el sistema de archivos ext4 en / dev / sdb4 y / dev / sdb5:</font></font><br>
<br>
<pre><code class="cpp hljs">mkfs.ext4 /dev/sdb4<font></font>
mkfs.ext4 /dev/sdb5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y prescribimos etiquetas de volumen para que luego sea m√°s f√°cil acceder a ellas:</font></font><br>
<br>
<pre><code class="cpp hljs">e2label /dev/sdb4 kernel<font></font>
e2label /dev/sdb5 rootfs</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto completa la creaci√≥n de secciones de la tarjeta de memoria, puede proceder a escribir archivos en ella.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grabaci√≥n de tarjeta microSD</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, en la etapa actual, todo est√° listo para grabar en una tarjeta microSD. </font><font style="vertical-align: inherit;">Lo insertamos en el lector de tarjetas de la computadora Linux y escribimos el gestor de arranque primario (FSBL) en la primera y segunda secci√≥n de la tarjeta mocroSD:</font></font><br>
<br>
<pre><code class="cpp hljs">dd <span class="hljs-keyword">if</span>=u-boot/u-boot-spl.stm32 of=/dev/sdb1<font></font>
dd <span class="hljs-keyword">if</span>=u-boot/u-boot-spl.stm32 of=/dev/sdb2</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora escriba U-Boot en la tercera secci√≥n de la tarjeta microSD:</font></font><br>
<br>
<pre><code class="cpp hljs">dd <span class="hljs-keyword">if</span>=u-boot/u-boot.img of=/dev/sdb3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci√≥n, debe copiar el n√∫cleo, el archivo del √°rbol de dispositivos y la secuencia de comandos de arranque en la cuarta secci√≥n de la tarjeta microSD. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de comenzar a copiar archivos, necesita una peque√±a explicaci√≥n sobre el script de descarga. En este script, de hecho, se indica diversa informaci√≥n para U-Boot, con la ayuda de la cual puede arrancar el sistema y transferir el control al kernel. Hay diferentes formas de escribir estos scripts, pero el m√°s simple (en mi opini√≥n) se describe en la documentaci√≥n de STM32MP1: debe crear el directorio </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ extlinux</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la ra√≠z de la secci√≥n del n√∫cleo </font><font style="vertical-align: inherit;">y crear un archivo de texto con el nombre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extlinux.conf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con los siguientes contenidos:</font></font><br>
<br>
<pre><code class="cpp hljs">LABEL stm32mp157a-dk1<font></font>
KERNEL /zImage<font></font>
FDT /stm32mp157a-dk1.dtb<font></font>
APPEND root=/dev/mmcblk0p5 rootwait rw console=ttySTM0,<span class="hljs-number">115200</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ todo es bastante simple: le decimos al cargador d√≥nde obtener el n√∫cleo, el √°rbol de dispositivos, el sistema de archivos ra√≠z y decimos que tendremos el puerto ttySTM0 como consola de trabajo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora copie el kernel:</font></font><br>
<br>
<pre><code class="cpp hljs">cp -a buildroot/output/images/zImage /media/myuser/kernel/</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: en el directorio / media / myuser /, monte una tarjeta microSD cuando est√© instalada en el lector de tarjetas. </font><font style="vertical-align: inherit;">En su caso, puede ser un directorio diferente. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Copie el archivo del √°rbol del dispositivo:</font></font><br>
<br>
<pre><code class="cpp hljs">cp -a buildroot/output/images/stm32mp157a-dk1.dtb /media/myuser/kernel/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Crea un directorio:</font></font><br>
<br>
<pre><code class="cpp hljs">mkdir /media/myuser/kernel/extlinux</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Crea un archivo:</font></font><br>
<br>
<pre><code class="cpp hljs">nano /media/myuser/kernel/extlinux/extlinux.conf</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
y ll√©nalo con el contenido:</font></font><br>
<br>
<pre><code class="cpp hljs">LABEL stm32mp157a-dk1<font></font>
KERNEL /zImage<font></font>
FDT /stm32mp157a-dk1.dtb<font></font>
APPEND root=/dev/mmcblk0p5 rootwait rw console=ttySTM0,<span class="hljs-number">115200</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Guarde el archivo y cierre el editor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En esto, la cuarta secci√≥n de la tarjeta microSD est√° lista: el kernel de Linux y todos los archivos auxiliares ya est√°n escritos. </font><font style="vertical-align: inherit;">Ya en esta etapa, si inserta una tarjeta microSD en la placa de depuraci√≥n, el kernel de Linux debe cargarse, sin embargo, al final se bloquear√° en el kernel panic debido al hecho de que el sistema de archivos ra√≠z no se puede montar. </font><font style="vertical-align: inherit;">Esto no es sorprendente, porque lo hemos grabado hasta ahora. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existe la etapa final, en la que escribiremos el sistema de archivos ra√≠z en la tarjeta microSD. </font><font style="vertical-align: inherit;">Y aqu√≠ hay varias opciones posibles:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escriba el sistema de archivos ra√≠z generado por Buildroot</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reescribe el sistema de archivos ra√≠z Arch Linux</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, escriba el sistema de archivos ra√≠z que Buildroot gener√≥ para nosotros e intente comenzar con √©l. Este no era el prop√≥sito de este art√≠culo, pero me pareci√≥ que, en general, podr√≠a ser √∫til para cualquier aplicaci√≥n, especialmente porque esta acci√≥n no lleva mucho tiempo. El sistema de archivos ra√≠z se escribe en la quinta secci√≥n de nuestra tarjeta microSD con un solo comando:</font></font><br>
<br>
<pre><code class="cpp hljs">dd <span class="hljs-keyword">if</span>=buildroot/output/images/rootfs.ext4 of=/dev/sdb5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora inserte la tarjeta de memoria en la placa de depuraci√≥n e inicie el sistema. Observaremos la salida de informaci√≥n de depuraci√≥n a trav√©s de la consola USB-UART: el acceso se proporciona a trav√©s de un puerto microUSB en la placa STM32MP157A-DK1. La visualizaci√≥n de la informaci√≥n mostrada es posible en cualquier programa de terminal, por ejemplo, Putty o Minicom. Para los fines de este art√≠culo, utilic√© este √∫ltimo abriendo otra ventana de terminal en Debian. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora insertamos la tarjeta microSD en la placa de depuraci√≥n, suministramos energ√≠a a la placa y miramos el terminal. Si todo se hizo correctamente, entonces los registros de FSBL, U-Boot, kernel se deben verter all√≠ y, en √∫ltima instancia, aparecer√° una invitaci√≥n para ingresar al inicio de sesi√≥n. Entramos en la ra√≠z y, voila, llegamos a la consola del sistema que acabamos de recopilar:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1q/hh/sz/1qhhszribllpziacncz6titn6bw.jpeg"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S√≠, ni siquiera tiene un administrador de paquetes y, en general, la funcionalidad es muy pobre, pero con la ayuda de Buildroot puedes construirlo muy bien y crear un sistema complejo realmente funcional. </font><font style="vertical-align: inherit;">Mientras tanto, su tama√±o es de solo 7 megabytes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rq/e7/iv/rqe7iv12mmdleosrwxo8jb-rmj8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de asegurarse de que el sistema de archivos ra√≠z casero se inicia correctamente, es hora de iniciar Arch Linux. </font><font style="vertical-align: inherit;">Nuevamente, inserte la tarjeta microSD en el lector de tarjetas de nuestra computadora y formatee nuevamente la quinta secci√≥n de la tarjeta de memoria:</font></font><br>
<br>
<pre><code class="cpp hljs">mkfs.ext4 /dev/sdb5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Descargue el archivo con Arch Linux, ensamblado bajo armv7, desde el sitio oficial. </font><font style="vertical-align: inherit;">Descomprima el archivo en el directorio archlinux y use el comando:</font></font><br>
<br>
<pre><code class="cpp hljs">cp -a archlinux<span class="hljs-comment">/* /media/myuser/rootfs </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C√≥pielo en la secci√≥n rootfs de la tarjeta microSD. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Limpiamos el directorio / media / myuser / rootfs / boot: no necesitamos los contenidos, porque el n√∫cleo y el √°rbol de dispositivos est√°n en una secci√≥n separada de la tarjeta microSD:</font></font><br>
<br>
<pre><code class="cpp hljs">rm ‚Äìrf /media/myuser/rootfs/boot<span class="hljs-comment">/*</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
M√°s tarde, puede montar la partici√≥n / dev / sdb4 en el directorio de arranque, donde tenemos la imagen del kernel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de eso, inserte la tarjeta microSD en la placa de depuraci√≥n, energ√≠cese y disfrute trabajando ArchLinux: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bj/n8/6i/bjn86iex090rkcggj7v5sz7yayg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de que Arch Linux se inici√≥ con √©xito, decid√≠ intentar ejecutar Debian tambi√©n en la placa de depuraci√≥n. </font><font style="vertical-align: inherit;">Utilizando manipulaciones absolutamente similares con el sistema de archivos ra√≠z, funcion√≥ con √©xito:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8h/kg/1c/8hkg1c82dcu2ruov5fm7rdu-j-i.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusi√≥n</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este art√≠culo, jugamos lo suficiente con la placa de depuraci√≥n STM32MP157A-DK1: colocamos U-Boot, el kernel de Linux, nuestro propio sistema de archivos ra√≠z, y tambi√©n lanzamos Arch Linux y Debian. </font><font style="vertical-align: inherit;">Espero que este material sea √∫til para alguien cuando trabaje con procesadores de la familia STM32MP1 o con cualquier otra placa √∫nica en ARM.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enlaces √∫tiles</font></font></b>
                        <div class="spoiler_text"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">www.st.com/en/microcontrollers-microprocessors/stm32mp1-series.html</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">wiki.st.com/stm32mpu/wiki/Category</a>:STM32_MPU_microprocessor_devices</div>
                    </div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es503578/index.html">Los buenos programadores copian, los grandes programadores roban</a></li>
<li><a href="../es503580/index.html">¬øQu√© es el Big Data?</a></li>
<li><a href="../es503588/index.html">Bill Gates: lo que necesita saber sobre la vacuna COVID-19</a></li>
<li><a href="../es503594/index.html">Observador remoto</a></li>
<li><a href="../es503598/index.html">FOSS News No. 17 - revisi√≥n de noticias gratuitas y de c√≥digo abierto del 18 al 24 de mayo de 2020</a></li>
<li><a href="../es503604/index.html">Sergey y "la programaci√≥n es mejor que el sexo"</a></li>
<li><a href="../es503606/index.html">Swift 5.3: ¬øQu√© hay de nuevo?</a></li>
<li><a href="../es503608/index.html">C√≥mo buscamos filtros de virus</a></li>
<li><a href="../es503610/index.html">¬øPor qu√© no hacer tu propio Lisp para la web?</a></li>
<li><a href="../es503612/index.html">Mejores pr√°cticas de Kubernetes. Mapeo de servicios externos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>