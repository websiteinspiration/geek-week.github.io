<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚹 🕸️ 👩‍👩‍👦 .NET：マルチスレッドと非同期を操作するためのツール。パート2 ⛵️ 📇 👨🏾‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私はHabrに関するオリジナルの記事を公開しています。その翻訳はCodingsightブログに投稿されています。
 
 マルチスレッド会議での講演のテキスト版を作成し続けます。最初の部分はここまたはここにあります。スレッドまたはタスクを開始するためのツールの基本セット、それらのステータスを表示する方...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>.NET：マルチスレッドと非同期を操作するためのツール。パート2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459514/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私はHabrに関するオリジナルの記事を公開しています。その翻訳は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codingsight</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブログに投稿されてい</font><font style="vertical-align: inherit;">ます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マルチスレッド会議での講演のテキスト版を作成し続けます。</font><font style="vertical-align: inherit;">最初の部分は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にあります。スレッドまたはタスクを開始するためのツールの基本セット、それらのステータスを表示する方法、およびPLinqなどのいくつかの甘いものについての詳細がありました。</font><font style="vertical-align: inherit;">この記事では、マルチスレッド環境で発生する可能性のある問題と、それらを解決するいくつかの方法にさらに焦点を当てたいと思います。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共有リソースについて</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチスレッド環境で作業するときに起こりうる問題</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドロック</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レース状態</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジー待機</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドの飢餓</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期ツール</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">連動</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Monitor.Enter、Monitor.Exit、lock</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SpinLock、SpinWait</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Monitor.Wait、Monitor.Pulse [すべて]</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReaderWriterLockSlim</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ResetEventファミリー</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></a></li>
</ul><br>
<a name="habracut"></a><br>
<a name="SharedResources"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共有リソースについて</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のスレッドで機能するが、単一のリソースを持たないプログラムを書くことは不可能です。</font><font style="vertical-align: inherit;">それが抽象化のレベルで機能する場合でも、その1つ以上のレベルを下回ると、まだ共通のリソースがあることがわかります。</font><font style="vertical-align: inherit;">いくつか例を示します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例＃1：</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
考えられる問題を恐れて、スレッドをさまざまなファイルで動作させました。</font><font style="vertical-align: inherit;">ストリームするファイルごと。</font><font style="vertical-align: inherit;">プログラムには単一の共通リソースがないように思われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかのレベルを下回ったため、ハードドライブは1つしかなく、そのドライバーまたはオペレーティングシステムは、ハードドライブへのアクセスを確保するという問題を解決する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例＃2：例を</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
読んだ後</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1、ファイルを2つの物理的に異なる鉄とオペレーティングシステムの2つの異なるリモートマシンに配置することにしました。 FTPまたはNFSを介して2つの異なる接続を維持します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下のいくつかのレベルを下ったので、何も変わっていないことを理解しています。ネットワークカードのドライバーまたはプログラムが実行されているマシンのオペレーティングシステムは、競合するアクセスの問題を解決する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例＃3：</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
マルチスレッドプログラムを作成する可能性を証明しようとして髪の毛をかなり失ったので、ファイルを完全に拒否し、計算を2つの異なるオブジェクトに分解します。各オブジェクトへのリンクは1つのスレッドでのみ使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後の数十の釘をこのアイデアの棺に打ち込みます。1つのランタイムとガベージコレクター、スレッドスケジューラー、物理的に1つのRAMとメモリ、1つのプロセッサーはまだ共有リソースです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、テクノロジースタック全体の抽象化のすべてのレベルで、単一の共有リソースなしにマルチスレッドプログラムを作成することは不可能であることがわかりました。</font><font style="vertical-align: inherit;">幸いなことに、抽象化の各レベルは、原則として、競合アクセスの問題を部分的または完全に解決するか、単にそれを禁止します（例：UIフレームワークは、異なるスレッドの要素の操作を禁止します）。抽象化のレベル。</font><font style="vertical-align: inherit;">それらを解決するには、同期の概念を導入します。</font></font><br>
<a name="Problems"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチスレッド環境で作業するときに起こりうる問題</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソフトウェアのエラーは、いくつかのグループに分類できます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムは結果を生成しません。</font><font style="vertical-align: inherit;">クラッシュまたはフリーズします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムが誤った結果を返します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムは正しい結果を生成しますが、1つまたは別の機能以外の要件を満たしていません。</font><font style="vertical-align: inherit;">実行時間が長すぎるか、リソースを大量に消費しています。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マルチスレッド環境では、エラー1と2を引き起こす主な2つの問題は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドロック</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">競合状態</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<a name="Deadlock"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドロック</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デッドロック-デッドロック。</font><font style="vertical-align: inherit;">多くの異なるバリエーションがあります。</font><font style="vertical-align: inherit;">以下は、最も頻繁に考えることができる。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fl/ij/aj/flijajjtgsaczutpuk9t1filaig.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方で</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、スレッド＃1をして</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何かをして、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃2スレッド</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のリソースブロックされた</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少し後に、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃1スレッド</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のリソースブロックされた</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロックリソースへと試行を</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、残念ながらこれは決して起こらないだろう、なぜならを </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッド＃2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">、リソースブロック</font><b><font style="vertical-align: inherit;">Aの</font></b><font style="vertical-align: inherit;">後でのみ</font><font style="vertical-align: inherit;">リソース</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解放します</font><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<a name="RaceCondition"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レース状態</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
競合状態-競合状態。</font><font style="vertical-align: inherit;">プログラムによって実行される計算の動作と結果がランタイムスレッドスケジューラの作業に依存する状況。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況の不愉快さは、プログラムが100万回に1回、または100万回に1回しか機能しない可能性があるという事実に正確にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、スレッドスケジューラの特定の動作により、デッドロックが発生するなどの問題が同時に発生する可能性があるため、状況はさらに悪化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムの明らかなエラーにつながるこれらの2つの問題に加えて、正しくない計算結果につながらない可能性もありますが、それを取得するためにより多くの時間または処理能力が費やされます。</font><font style="vertical-align: inherit;">これらの問題の2つは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジー待機</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドスタベーション</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<a name="BusyWait"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジー待機</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Busy-Waitは、プログラムがプロセッサリソースを計算ではなく待機のために消費する問題です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの場合、このようなコードの問題は次のようになります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">while</span>(!hasSomethingHappened)<font></font>
    ;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは非常に悪いコードの例です。</font><font style="vertical-align: inherit;">このようなコードは、プロセッサーの1つのコアを完全に占有しますが、有用なことは何もしません。</font><font style="vertical-align: inherit;">別のスレッドで何らかの値の変更を処理することが非常に重要である場合にのみ、正当化できます。</font><font style="vertical-align: inherit;">簡単に言えば、数ナノ秒も待てない場合のことです。</font><font style="vertical-align: inherit;">他の場合、つまり、健全な脳を生成できるすべてのものでは、ResetEventの種類とそのSlimバージョンを使用する方が合理的です。</font><font style="vertical-align: inherit;">以下について。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、読者の1人が、ループにThread.Sleep（1）のような構造を追加することによって、無駄な待機で単一のカーネルを完全にロードする問題を解決することを提案するでしょう。</font><font style="vertical-align: inherit;">これで問題は本当に解決しますが、別の問題が発生します。変更に対する応答時間は平均で0.5ミリ秒です。これは多くはないかもしれませんが、ResetEventファミリの同期プリミティブを使用する場合よりも致命的です。</font></font><br>
<a name="ThreadStarvation"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドの飢餓</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッドスターベーションは、プログラムの同時スレッドが多すぎる問題です。 IOからの応答を待つだけでなく、計算でビジー状態のフローとはどういう意味ですか。この問題により、スレッドを使用することによるパフォーマンスの向上はすべて失われます。プロセッサは、コンテキストの切り替えに多くの時間を費やしています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さまざまなプロファイラーを使用してこのような問題を探すと便利です。以下は、</font><font style="vertical-align: inherit;">タイムラインモードで起動し</font><font style="vertical-align: inherit;">た</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dotTrace</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロファイラーのスクリーンショットの例</font><font style="vertical-align: inherit;">です。</font><i><font style="vertical-align: inherit;">（画像はクリック可能です）</font></i><font style="vertical-align: inherit;"> 
ストリーミングの空腹に悩まされていないプログラムでは、ストリームを反映するグラフにピンク色はありません。さらに、サブシステムカテゴリでは、プログラムの30.6％がCPUを待機していたことがわかります。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/qy/n9/nk/qyn9nkwglryzuu60cipo8zdi0ra.png"></a><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような問題が診断されると、非常に簡単に解決されます。一度に開始したスレッドが多すぎたり、一度に開始したスレッドが少なかったり、まったくなかったりします。</font></font><br>
<a name="SyncPrimitives"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期ツール</font></font></h2><br>
<a name="Interlocked"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">連動</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはおそらく同期する最も軽量な方法です。</font><font style="vertical-align: inherit;">Interlockedは、単純なアトミック操作のコレクションです。</font><font style="vertical-align: inherit;">アトミック操作は、何も起こらない操作と呼ばれます。</font><font style="vertical-align: inherit;">.NETでは、Interlockedは同じ名前の静的クラスで表され、いくつかのメソッドがあり、それぞれが1つのアトミック操作を実装しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非アトミック操作の恐ろしさを理解するには、それぞれが同じ変数の100万の増分を作成する10のスレッドを開始するプログラムを作成してみてください。作業の最後に、この変数の値を出力します。残念ながら、1000万とは非常に異なります。プログラムが開始するたびに、それは異なります。これは、インクリメントなどの単純な操作でもアトミックではなく、メモリから値を抽出し、新しい値を計算し、書き戻すためです。したがって、2つのスレッドがこれらの各操作を同時に実行できます。その場合、増分は失われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Interlockedクラスは、Increment / Decrementメソッドを提供します。それらが何をするかは簡単に推測できます。複数のスレッドでデータを処理していて、何かを検討する場合に使用すると便利です。このようなコードは、従来のロックよりもはるかに速く機能します。前の段落で説明した状況でInterlockedを使用すると、プログラムはどのような状況でも1,000万の値を安定して提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CompareExchangeメソッドは、一見すると、あまり目立たない機能を実行しますが、そのすべての存在により、多くの興味深いアルゴリズム、特にロックフリーファミリを実装できます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">CompareExchange</span> (<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-keyword">int</span> location1, <span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span>, <span class="hljs-keyword">int</span> comparand</span>)</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッドは3つの値を取ります。最初の値は参照によって渡され、これが2番目の値に変更されます。比較の瞬間にlocation1がcomparandと一致する場合、location1の元の値が返されます。</font><font style="vertical-align: inherit;">CompareExchangeと同じ操作を実行するコードを作成する方が簡単なので、混乱を招くように見えます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> original = location1;
<span class="hljs-keyword">if</span> (location1 == comparand)<font></font>
    location1 = <span class="hljs-keyword">value</span>;
<span class="hljs-keyword">return</span> original;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Interlockedクラスの実装のみがアトミックになります。</font><font style="vertical-align: inherit;">つまり、そのようなコードを自分で記述した場合、条件location1 == comparandがすでに満たされていたにもかかわらず、式location1 = valueが実行された時点で、別のスレッドがlocation1の値を変更していたために、状況が失われた可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーがC＃イベント用に生成するコードで、このメソッドを使用する良い例を見つけることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MyEventイベントを1つ持つ単純なクラスを書きましょう。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler MyEvent;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リリース構成でプロジェクトをビルドし、</font><font style="vertical-align: inherit;">コンパイラが生成したコードを表示オプションをオンにし</font><font style="vertical-align: inherit;">て</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dotPeek</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用してアセンブリを開き</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">CompilerGenerated</span>]
<span class="hljs-keyword">private</span> EventHandler MyEvent;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler MyEvent<font></font>
{<font></font>
  [<span class="hljs-meta">CompilerGenerated</span>] <span class="hljs-keyword">add</span><font></font>
  {<font></font>
    EventHandler eventHandler = <span class="hljs-keyword">this</span>.MyEvent;<font></font>
    EventHandler comparand;<font></font>
    <span class="hljs-keyword">do</span><font></font>
    {<font></font>
      comparand = eventHandler;<font></font>
      eventHandler = Interlocked.CompareExchange&lt;EventHandler&gt;(<span class="hljs-keyword">ref</span> <span class="hljs-keyword">this</span>.MyEvent, (EventHandler) Delegate.Combine((Delegate) comparand, (Delegate) <span class="hljs-keyword">value</span>), comparand);<font></font>
    }<font></font>
    <span class="hljs-keyword">while</span> (eventHandler != comparand);<font></font>
  }<font></font>
  [<span class="hljs-meta">CompilerGenerated</span>] <span class="hljs-keyword">remove</span><font></font>
  {<font></font>
    <span class="hljs-comment">// The same algorithm but with Delegate.Remove</span><font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、裏でコンパイラがかなり洗練されたアルゴリズムを生成したことがわかります。</font><font style="vertical-align: inherit;">このアルゴリズムは、複数のスレッドがこのイベントを同時にサブスクライブするときに、イベントサブスクリプションが失われる状況から保護します。</font><font style="vertical-align: inherit;">addExchangeメソッドを詳細に記述して、CompareExchangeメソッドがバックグラウンドで実行することを思い出してください。</font></font><br>
<br>
<pre><code class="cs hljs">EventHandler eventHandler = <span class="hljs-keyword">this</span>.MyEvent;<font></font>
EventHandler comparand;<font></font>
<span class="hljs-keyword">do</span><font></font>
{<font></font>
    comparand = eventHandler;<font></font>
    <span class="hljs-comment">// Begin Atomic Operation</span>
    <span class="hljs-keyword">if</span> (MyEvent == comparand)<font></font>
    {<font></font>
        eventHandler = MyEvent;<font></font>
        MyEvent = Delegate.Combine(MyEvent, <span class="hljs-keyword">value</span>);<font></font>
    }<font></font>
    <span class="hljs-comment">// End Atomic Operation</span><font></font>
}<font></font>
<span class="hljs-keyword">while</span> (eventHandler != comparand);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まだ説明が必要かもしれませんが、これはもう少し明確です。</font><font style="vertical-align: inherit;">つまり、このアルゴリズムを次のように説明します</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。MyEventがDelegate.Combineの実行を開始したときと同じである場合は、Delegate.Combineが返すものをその中に書き留め、そうでない場合は問題ではないので、もう一度試してみましょうそれが出るまで繰り返します。</font></font><br>
</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、イベントのサブスクリプションは失われません。</font><font style="vertical-align: inherit;">動的なスレッドセーフなロックフリー配列を突然実装したい場合は、同様の問題を解決する必要があります。</font><font style="vertical-align: inherit;">複数のストリームが急いでそれに要素を追加する場合、すべてのストリームが最終的に追加されることが重要です。</font></font><br>
<a name="Lock"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Monitor.Enter、Monitor.Exit、lock</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらは、スレッド同期に最も一般的に使用される構造です。それらは重要なセクションのアイデアを実装します：つまり、1つのリソースのMonitor.Enter、Monitor.Exitの呼び出しの間に記述されたコードは、1つのスレッドで一度に実行できます。ロックステートメントは、try-finallyでラップされたEnter / Exit呼び出しに関する構文糖衣です。 .NETにクリティカルセクションを実装する優れた機能は、同じストリームにクリティカルセクションを再入力できることです。これは、同様のコードが問題なく実行されることを意味します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">lock</span>(a) {
  <span class="hljs-keyword">lock</span> (a) {<font></font>
    ...<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、誰かがこのように書くことはほとんどありませんが、このコードをコールスタックの深さでいくつかのメソッドに塗りつぶすと、この機能によってifを節約できます。このようなトリックを可能にするために、.NET開発者は制限を追加する必要がありました。同期オブジェクトとして使用できるのは参照タイプのインスタンスのみであり、ストリーム識別子が書き込まれる各オブジェクトに数バイトが暗黙的に追加されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C＃のクリティカルセクションのこの機能は、ロックステートメントの操作に1つの興味深い制限を課します。ロックステートメント内でawaitステートメントを使用することはできません。最初は、同様のtry-finally Monitor.Enter / Exitコンストラクトがコンパイルされるので、私は驚きました。何か問題でもありますか？ここでもう一度最後の段落を注意深く読み直して、非同期/待機の原則に関する知識を追加する必要があります。待機後のコードは、待機前のコードと同じスレッドで実行されるとは限りません。同期コンテキストと存在に依存します。 ConfigureAwaitの呼び出しはありません。そのため、Monitor.ExitはMonitor.Enter以外のスレッドで実行され、</font><b><font style="vertical-align: inherit;">SynchronizationLockException</font></b><font style="vertical-align: inherit;">がスローされます。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">信じられない場合は、コンソールアプリケーションで次のコードを実行できます。SynchronizationLockExceptionがスローされます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> syncObject = <span class="hljs-keyword">new</span> Object();<font></font>
Monitor.Enter(syncObject);<font></font>
Console.WriteLine(Thread.CurrentThread.ManagedThreadId);<font></font>
<font></font>
<span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>);<font></font>
<font></font>
Monitor.Exit(syncObject);<font></font>
Console.WriteLine(Thread.CurrentThread.ManagedThreadId);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WinFormsまたはWPFアプリケーションでは、このコードがメインスレッドから呼び出された場合に正しく機能することは注目に値します。</font><font style="vertical-align: inherit;">待機後、UIスレッドへの戻りを実装する同期コンテキストがあります。</font><font style="vertical-align: inherit;">いずれの場合も、await演算子を含むコードのコンテキストでクリティカルセクションを操作しないでください。</font><font style="vertical-align: inherit;">このような場合は、後で説明する同期プリミティブを使用することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NETの重要なセクションの作業については、その実装の別の機能に言及する価値があります。</font><font style="vertical-align: inherit;">.NETのクリティカルセクションは、スピンウェイトモードとカーネルモードの2つのモードで動作します。</font><font style="vertical-align: inherit;">スピンウェイトアルゴリズムは、次の擬似コードで表すと便利です。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">while</span>(!TryEnter(syncObject))<font></font>
    ;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この最適化は、リソースが現在ビジー状態の場合、リソースがすぐに解放されるという想定に基づいて、クリティカルセクションを短時間で最速でキャプチャすることを目的としています。</font><font style="vertical-align: inherit;">これが短時間で発生しない場合、スレッドはカーネルモードで待機するため、そこから戻るように時間がかかります。</font><font style="vertical-align: inherit;">.NET開発者は、ショートロックシナリオをできる限り最適化していますが、残念ながら、多くのスレッドがクリティカルセクションを切り離し始めると、CPUの負荷が突然高くなる可能性があります。</font></font><br>
<a name="SpinLock"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SpinLock、SpinWait</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スピンウェイトアルゴリズムについて述べたので、BCLのSpinLock構造とSpinWait構造について言及する価値があります。</font><font style="vertical-align: inherit;">常に非常に迅速にロックを取得する機会が常にあると信じる理由がある場合に使用してください。</font><font style="vertical-align: inherit;">一方、プロファイリングの結果がプログラムのボトルネックである他の同期プリミティブの使用であることを示す前に、それらについて覚えておくことはほとんど価値がありません。</font></font><br>
<a name="Pulse"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Monitor.Wait、Monitor.Pulse [すべて]</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この2つの方法を一緒に検討する必要があります。彼らの助けを借りて、さまざまな生産者-消費者シナリオを実装できます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロデューサー-コンシューマー-データを生成する1つ以上のスレッド/プロセスと、このデータを処理する1つ以上のプロセス/スレッドの存在を想定したマルチプロセス/マルチスレッド設計パターン。通常は共有コレクションを使用します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これらのメソッドは両方とも、それらを呼び出しているスレッドに現在ロックがある場合にのみ呼び出すことができます。 Waitメソッドはロックを解放し、別のスレッドがPulseを呼び出すまでハングします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作業を説明するために、小さな例を書きました。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">object</span> syncObject = <span class="hljs-keyword">new</span> <span class="hljs-keyword">object</span>();<font></font>
Thread t1 = <span class="hljs-keyword">new</span> Thread(T1);<font></font>
t1.Start();<font></font>
<font></font>
Thread.Sleep(<span class="hljs-number">100</span>);<font></font>
Thread t2 = <span class="hljs-keyword">new</span> Thread(T2);<font></font>
t2.Start();<font></font>
</code></pre><img src="https://habrastorage.org/webt/0-/7k/uy/0-7kuyx2b8evi2iwzmt-6-capv0.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（説明の順序を明確に示すために、テキストではなく画像を使用しました）</font></font></i><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析：</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2番目のストリームの開始時に100ミリ秒の遅延</font><u><font style="vertical-align: inherit;">を</font></u><font style="vertical-align: inherit;">設定しました。特に、その実行が後で確実に開始されるようにしています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -T1：ライン＃2ストリームが開始します</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -T1：ライン＃3ストリームがクリティカルセクションに入ります</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -T1：ライン＃6ストリームが眠りに落ちます</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -T2：ライン＃3ストリームが開始します</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -T2：ライン＃4がクリティカルセクションを待っている間にフリーズします</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -T1：ライン＃7はクリティカルセクションを解放し、パルスの待機中にフリーズします</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -T2：ライン＃8はクリティカルセクションに入ります</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -T2：ライン＃11はパルス方式を使用してT1に通知し</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 ます-T2：ライン＃14はクリティカルセクションを終了します。それまでは、T1は実行を継続できません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -T1：スタンバイからの行＃15 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -T1：行＃16は</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSDNの</font></font></a><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クリティカルセクションから出て</font><i><font style="vertical-align: inherit;">います。Pulse/ Waitメソッドの使用に関する重要な注意事項があります。つまり、モニターはステータスに関する情報を保存しません。つまり、メソッドがPulseを呼び出すと、 Waitメソッドを呼び出すと、デッドロックが発生する可能性があります。</font></i><i><font style="vertical-align: inherit;">この状況が発生する可能性がある場合は、ResetEventファミリーのクラスの1つを使用することをお勧めします。</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前の例は、MonitorクラスのWait / Pulseメソッドの原則を明確に示していますが、それでも、使用する価値がある場合については疑問を残しています。</font><font style="vertical-align: inherit;">良い例は、BlockingQueue &lt;T&gt;のこのような実装です。一方、System.Collections.ConcurrentからのBlockingCollection &lt;T&gt;の実装は、同期にSemaphoreSlimを使用します。</font></font><br>
<a name="ReaderWriterLockSlim"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReaderWriterLockSlim</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、私の愛する同期プリミティブであり、同じ名前のSystem.Threading名前空間クラスで表されます。開発者が通常のロックの代わりにこのクラスを使用すると、多くのプログラムがよりうまく機能するように思えます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アイデア：多くのスレッドが読み取ることができ、書き込みは1つだけです。ストリームが書き込み要求を宣言するとすぐに、新しい読み取りを開始することはできませんが、記録が完了するまで待機します。アップグレード可能な読み取りロックの概念もあります。これは、読み取りプロセス中に何かを書き込む必要があることを理解している場合に使用できます。このようなロックは、1つのアトミック操作で書き込みロックに変換されます。</font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Threading名前空間にはReadWriteLockクラスもありますが、新規開発には強く推奨されます。スリムバージョンでは、デッドロックにつながる多くのケースを回避できるほか、ロックをすばやく取得することもできます。カーネルモードに移行する前のスピンウェイトモードでの同期をサポートします。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この記事を読んだ時点で、このクラスについてまだ知らなかった場合は、最近書かれたコードからかなりの数の例を思い出したと思います。このようなロック方法により、プログラムは効率的に機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ReaderWriterLockSlimクラスのインターフェースはシンプルで単純ですが、その使用は便利とは言えません。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> @lock = <span class="hljs-keyword">new</span> ReaderWriterLockSlim();<font></font>
<font></font>
@lock.EnterReadLock();<font></font>
<span class="hljs-keyword">try</span><font></font>
{<font></font>
    <span class="hljs-comment">// ...</span><font></font>
}<font></font>
<span class="hljs-keyword">finally</span><font></font>
{<font></font>
    @lock.ExitReadLock();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はその使用をクラスでラップするのが好きです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アイデア：Disposeメソッドを使用してオブジェクトを返すRead / WriteLockメソッドを作成すると、使用に使用できるようになり、行数によって通常のロックとほとんど変わりません。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">RWLock</span> : <span class="hljs-title">IDisposable</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> WriteLockToken : IDisposable<font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ReaderWriterLockSlim @lock;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WriteLockToken</span>(<span class="hljs-params">ReaderWriterLockSlim @<span class="hljs-keyword">lock</span></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">this</span>.@lock = @lock;<font></font>
            @lock.EnterWriteLock();<font></font>
        }<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>(<span class="hljs-params"></span>)</span> =&gt; @lock.ExitWriteLock();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> ReadLockToken : IDisposable<font></font>
    {<font></font>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ReaderWriterLockSlim @lock;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReadLockToken</span>(<span class="hljs-params">ReaderWriterLockSlim @<span class="hljs-keyword">lock</span></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">this</span>.@lock = @lock;<font></font>
            @lock.EnterReadLock();<font></font>
        }<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>(<span class="hljs-params"></span>)</span> =&gt; @lock.ExitReadLock();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ReaderWriterLockSlim @lock = <span class="hljs-keyword">new</span> ReaderWriterLockSlim();<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ReadLockToken <span class="hljs-title">ReadLock</span>(<span class="hljs-params"></span>)</span> =&gt; <span class="hljs-keyword">new</span> ReadLockToken(@lock);
    <span class="hljs-function"><span class="hljs-keyword">public</span> WriteLockToken <span class="hljs-title">WriteLock</span>(<span class="hljs-params"></span>)</span> =&gt; <span class="hljs-keyword">new</span> WriteLockToken(@lock);<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>(<span class="hljs-params"></span>)</span> =&gt; @lock.Dispose();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなトリックを使用すると、さらに書くことができます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> rwLock = <span class="hljs-keyword">new</span> RWLock();
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">using</span>(rwLock.ReadLock())<font></font>
{<font></font>
    <span class="hljs-comment">// ...</span><font></font>
}<font></font>
</code></pre><br>
<a name="ResetEvent"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ResetEventファミリー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このファミリには、ManualResetEvent、ManualResetEventSlim、AutoResetEventクラスを含めています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ManualResetEventクラス、そのSlimバージョン、およびAutoResetEventクラスは、次の2つの状態になります。- </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 非シグナル状態。この状態では、WaitOneを呼び出したすべてのスレッドが、イベントがシグナル状態に遷移するまでハングします。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -下げられた状態（シグナル状態）。この状態では、WaitOneコールでハングしているすべてのフローが解放されます。ランダウンイベントに対するすべての新しいWaitOne呼び出しは、条件付きで即座に渡されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AutoResetEventクラスは、ManualResetEventクラスとは異なり、1つのスレッドを解放すると自動的にコック状態になります。 AutoResetEventの待機中にいくつかのスレッドがハングする場合、ManualResetEventとは異なり、Set呼び出しは任意の1つだけを解放します。 ManualResetEventはすべてのスレッドを解放します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AutoResetEventの動作の例を見てみましょう。</font></font><br>
<pre><code class="cs hljs">AutoResetEvent evt = <span class="hljs-keyword">new</span> AutoResetEvent(<span class="hljs-literal">false</span>);<font></font>
<font></font>
Thread t1 = <span class="hljs-keyword">new</span> Thread(T1);<font></font>
t1.Start();<font></font>
Thread.Sleep(<span class="hljs-number">100</span>);<font></font>
<font></font>
Thread t2 = <span class="hljs-keyword">new</span> Thread(T2);<font></font>
t2.Start();<font></font>
</code></pre><img src="https://habrastorage.org/webt/ku/us/k2/kuusk2oupkj4_gftf8fixy_51pu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例は、WaitOne呼び出しでハングしているスレッドを解放することによってのみ、イベントが自動的にコック状態（シグナルなし）になることを示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ReaderWriterLockとは異なり、ManualResetEventクラスは非推奨としてマークされておらず、Slimバージョンの出現後の使用は推奨されていません。</font><font style="vertical-align: inherit;">このクラスのスリムバージョンは、以下のような短い期待に効率的に使用されます。</font><font style="vertical-align: inherit;">これはスピンウェイトモードで発生し、通常のバージョンは長いバージョンに適しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ManualResetEventクラスとAutoResetEventクラスに加えて、CountdownEventクラスも存在します。</font><font style="vertical-align: inherit;">このクラスは、アルゴリズムの実装に便利です。並列化に成功した部分の後に、結果をまとめる部分が続きます。</font><font style="vertical-align: inherit;">このアプローチは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fork-join</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として知られてい</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">このクラスの作品に特化した優れた</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事です。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">したがって、ここでは詳しく分析しません。</font></font><br>
<a name="Conclusions"></a><br>
<h2></h2><br>
<ul>
<li>     ,       ,  race condition  deadlock</li>
<li>,         — thread starvation  busy wait</li>
<li>.NET     </li>
<li> 2    — Spin Wait, Core Wait.     .NET  </li>
<li>Interlocked     ,   lock-free ,     </li>
<li> lock  Monitor.Enter/Exit     —  ,           </li>
<li> Monitor.Pulse/Wait    Producer-Consumer </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReaderWriterLockSlimは、並列読み取りが許容されるスクリプトの通常のロックよりも効率的かもしれません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ResetEventクラスファミリは、スレッドの同期に役立ちます。</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja459500/index.html">HTMLはウェブです</a></li>
<li><a href="../ja459502/index.html">私たちはロシア人のための冒険プラットフォームを開発し続けています：インターフェース機能と夏の好み</a></li>
<li><a href="../ja459504/index.html">ヤングゲームデザイナーコース：数学を使わずにキャラクターと装備のバランスを数える方法</a></li>
<li><a href="../ja459506/index.html">とらえどころのないマルヴァリの冒険、パートIII：笑いと利益のための複雑なVBAスクリプト</a></li>
<li><a href="../ja459508/index.html">経験豊富なプレゼンターが無視した5枚のスライド</a></li>
<li><a href="../ja459518/index.html">就職の面接とPythonタスクの説明</a></li>
<li><a href="../ja459520/index.html">自然数列とその要素のモデル。ひし形</a></li>
<li><a href="../ja459528/index.html">フランスの生態を教えて瓶を集めるには</a></li>
<li><a href="../ja459530/index.html">微生物相。研究の歴史と研究方法</a></li>
<li><a href="../ja459532/index.html">1から10までの乱数を選択する方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>