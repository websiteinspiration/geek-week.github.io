<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôå üöè üë©üèø‚Äçü§ù‚Äçüë®üèΩ Unsuccessful article about acceleration of reflection üòë üëî üè∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I‚Äôll explain the title of the article right away. Initially, it was planned to give good, reliable advice on accelerating the use of reflexion using a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Unsuccessful article about acceleration of reflection</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499562/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I‚Äôll explain the title of the article right away. Initially, it was planned to give good, reliable advice on accelerating the use of reflexion using a simple but realistic example, but during benchmarking it turned out that reflection does not work as slowly as I thought, LINQ works slower than dreamed of in nightmares. But in the end it turned out that I also made a mistake in the measurements ... Details of this life story under the cut and in the comments. Since the example is quite everyday and implemented in principle, as is usually done in the enterprise, it turned out to be quite interesting, as it seems to me, a demonstration of life: there was no noticeable effect on the speed of the main subject of the article due to external logic: Moq, Autofac, EF Core, etc. "Strapping".</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I started my work under the impression of this article: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why is Reflection slow</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
As you can see, the author suggests using compiled delegates instead of directly invoking reflection type methods as a great way to greatly speed up the application. There is, of course, IL emission, but I would like to avoid it, since this is the most labor-intensive way to complete the task, which is fraught with errors. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considering that I always adhered to a similar opinion about the speed of reflection, I did not intend to cast particular doubt on the conclusions of the author.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I often encounter the naive use of reflection in an enterprise. Type is taken. Property information is taken. The SetValue method is called, and everyone is happy. The value flew into the target field, everyone is happy. People who are very clever - siniors and team leaders - write their extensions on object, basing on such a naive implementation of "universal" mappers of one type in another. The essence of this is usually: we take all the fields, we take all the properties, iterate over them: if the names of the type members coincide, we execute SetValue. We periodically catch exceptions on misses where one of the types did not find some property, but there is also a way out that achieves performance. Try / catch.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I saw people reinventing parsers and mappers without being fully armed with information on how the bikes invented before them work. I saw people hide their naive implementations behind strategies, behind interfaces, behind injections, as if this would excuse the subsequent bacchanalia. From such implementations I turned my nose. In fact, I did not measure the real performance leak, and if possible, I simply changed the implementation to a more ‚Äúoptimal‚Äù one, if my hands reached. Because the first measurements, which are discussed below, I was seriously embarrassed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I think many of you, when reading Richter or other ideologists, have come up with the quite fair assertion that reflection in code is a phenomenon that has an extremely negative effect on application performance.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The reflection call forces the CLR to go around the assembly in search of the right one, pull up its metadata, parse it, etc. In addition, reflection during sequence traversal leads to the allocation of a large amount of memory. We spend memory, the CLR uncovers the HZ and freezes raced. It should be noticeably slow, believe me. The huge amounts of memory of modern production servers or cloud machines do not save from high processing delays. In fact, the more memory, the higher the likelihood that you WILL NOTICE how the HZ works. Reflection is, in theory, an extra red rag for him.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nevertheless, we all use both IoC containers and date mappers, the principle of which is also based on reflection, however, questions about their performance usually do not arise. No, not because the introduction of dependencies and abstracting from models of external limited context is so necessary things that we have to sacrifice performance in any case. Everything is simpler - it really does not greatly affect performance.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The fact is that the most common frameworks that are based on reflection technology use all kinds of tricks to work with it more optimally. This is usually a cache. Usually these are Expressions and delegates compiled from the expression tree. The same auto-mapper holds a competitive dictionary, matching types with functions that they can convert to one another without calling reflection. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How is this achieved? In fact, this is no different from the logic that the platform itself uses to generate JIT code. When you first call a method, it compiles (and, yes, this process is not fast), with subsequent calls, control is transferred to the already compiled method, and there will be no special performance drawdowns.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our case, you can also use JIT compilation and then use the compiled behavior with the same performance as its AOT counterparts. In this case, expressions will come to our aid. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Briefly, we can formulate the principle in question as follows: The </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
final result of the reflection should be cached in the form of a delegate containing a compiled function. It also makes sense to cache all the necessary objects with information about types in fields of your type that are stored outside objects ‚Äî the worker. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is logic in this. Common sense tells us that if something can be compiled and cached, then this should be done.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Looking ahead, it should be said that the cache in working with reflection has its advantages, even if you do not use the proposed method for compiling expressions. Actually, here I am simply repeating the theses of the author of the article to which I refer above. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now about the code. Let's look at an example that is based on my recent pain that I had to face in serious production of a serious credit organization. All entities are fictitious so that no one would guess. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is a certain entity. Let it be Contact. There are letters with a standardized body, from which the parser and hydrator create these same contacts. A letter arrived, we read it, disassembled the key-value pairs, created a contact, saved it in the database.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is elementary. Suppose a contact has the name, age, and contact number of the property. These data are transmitted in a letter. Also, the business wants support to be able to quickly add new keys for mapping entity properties to pairs in the body of the letter. In case someone imprinted in the template or if prior to release it would be necessary to urgently start mapping from a new partner, adjusting to the new format. Then we can add a new mapping correlation as a cheap datafix. That is, a life example. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We implement, create tests. Works.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will not give the code: there were a lot of source codes, and they are available on GitHub by the link at the end of the article. You can download them, torture them beyond recognition and measure them, as it would affect your case. I will give only the code of two template methods that distinguish the hydrator, which should have been fast from the hydrator, which should have been slow. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The logic is as follows: the template method receives the pairs formed by the base parser logic. The LINQ level is a parser and the basic logic of the hydrator, making a request to the db context and matching keys with pairs from the parser (for these functions there is a code without LINQ for comparison). Next, the pairs are transferred to the main hydration method and the values ‚Äã‚Äãof the pairs are set to the corresponding properties of the entity. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚ÄúFast‚Äù (Fast prefix in benchmarks):</font></font><br>
<br>
<pre><code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Contact <span class="hljs-title">GetContact</span>(<span class="hljs-params">PropertyToValueCorrelation[] correlations</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> contact = <span class="hljs-keyword">new</span> Contact();
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> setterMapItem <span class="hljs-keyword">in</span> _proprtySettersMap)<font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> correlation = correlations.FirstOrDefault(x =&gt; x.PropertyName == setterMapItem.Key);<font></font>
                setterMapItem.Value(contact, correlation?.Value);<font></font>
            }<font></font>
            <span class="hljs-keyword">return</span> contact;<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As we can see, a static collection with property setters is used - compiled lambdas that call the setter entity. </font><font style="vertical-align: inherit;">Generated by the following code:</font></font><br>
<br>
<pre><code class="cs hljs">        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">FastContactHydrator</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">typeof</span>(Contact);
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> type.GetProperties())<font></font>
            {<font></font>
                _proprtySettersMap[property.Name] = GetSetterAction(property);<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Action&lt;Contact, <span class="hljs-keyword">string</span>&gt; <span class="hljs-title">GetSetterAction</span>(<span class="hljs-params">PropertyInfo property</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> setterInfo = property.GetSetMethod();
            <span class="hljs-keyword">var</span> paramValueOriginal = Expression.Parameter(property.PropertyType, <span class="hljs-string">"value"</span>);
            <span class="hljs-keyword">var</span> paramEntity = Expression.Parameter(<span class="hljs-keyword">typeof</span>(Contact), <span class="hljs-string">"entity"</span>);
            <span class="hljs-keyword">var</span> setterExp = Expression.Call(paramEntity, setterInfo, paramValueOriginal).Reduce();<font></font>
            <font></font>
            <span class="hljs-keyword">var</span> lambda = (Expression&lt;Action&lt;Contact, <span class="hljs-keyword">string</span>&gt;&gt;)Expression.Lambda(setterExp, paramEntity, paramValueOriginal);<font></font>
<font></font>
            <span class="hljs-keyword">return</span> lambda.Compile();<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, it is clear. </font><font style="vertical-align: inherit;">We go around the properties, create delegates for them that call the setters, and save them. </font><font style="vertical-align: inherit;">Then we call when necessary. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Slow" (Slow prefix in benchmarks):</font></font><br>
<br>
<pre><code class="cs hljs">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Contact <span class="hljs-title">GetContact</span>(<span class="hljs-params">PropertyToValueCorrelation[] correlations</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> contact = <span class="hljs-keyword">new</span> Contact();
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> _properties)<font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> correlation = correlations.FirstOrDefault(x =&gt; x.PropertyName == property.Name);
                <span class="hljs-keyword">if</span> (correlation?.Value == <span class="hljs-literal">null</span>)
                    <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
                property.SetValue(contact, correlation.Value);<font></font>
            }<font></font>
            <span class="hljs-keyword">return</span> contact;<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we immediately go around the properties and call SetValue directly. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For clarity and as a reference, I implemented a naive method that writes the values ‚Äã‚Äãof their correlation pairs directly to the entity fields. </font><font style="vertical-align: inherit;">The prefix is ‚Äã‚ÄãManual. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we take BenchmarkDotNet and we study productivity. </font><font style="vertical-align: inherit;">And suddenly ... (spoiler is not the right result, details are below)</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v1/by/o1/v1byo1sssukfywtxg_kaylvadwu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What do we see here? Methods that triumphantly wear the Fast prefix turn out to be slower in almost all passes than methods with the Slow prefix. This is true for allocation, and for speed. On the other hand, the beautiful and elegant implementation of mapping using LINQ methods designed for this purpose, on the contrary, greatly eats up performance. The difference in orders. The trend does not change with a different number of passes. The difference is only in scale. With LINQ 4 to 200 times slower, there is more debris at about the same scale. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPDATED</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
I could not believe my eyes, but more importantly, neither my eyes nor my code was believed by our colleague - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry Tikhonov 0x1000000</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Having rechecked my solution, he brilliantly discovered and pointed out an error that I missed due to a number of changes in the implementation. After fixing the found bug in the Moq setup, all the results fell into place. According to the results of the retest, the main trend does not change - LINQ affects the performance is still stronger than reflection. However, it‚Äôs nice that work with compiling Expressions is not in vain, and the result is visible both in allocation and in runtime. The first run, when static fields are initialized, is naturally slower in the ‚Äúfast‚Äù method, but the situation changes further. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is the result of the retest:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0a/k-/cj/0ak-cjqtjh3okpxobsdcrhgloqa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Conclusion: when using reflection in an enterprise, resorting to tricks is not particularly required - LINQ will gobble up performance more strongly. However, in highly loaded methods requiring optimization, one can preserve reflection in the form of initializers and delegate compilers, which will then provide ‚Äúfast‚Äù logic. So you can maintain the flexibility of reflection, and the speed of the application. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A code with a benchmark is available here. Everyone can double-check my words: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HabraReflectionTests</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
PS: the code uses IoC in the tests, and the explicit design in the benchmarks. The fact is that in the final implementation, I compartment all factors that can affect performance and make noise. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PPS: Thanks to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry Tikhonov @ 0x1000000</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for detecting my error in the Moq setup, which affected the first measurements. </font><font style="vertical-align: inherit;">If any of the readers have enough karma, like it, please. </font><font style="vertical-align: inherit;">The man stopped, the man read, the man double-checked and indicated an error. </font><font style="vertical-align: inherit;">I think this is worthy of respect and sympathy. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PPPS: thanks to that meticulous reader who got to the bottom of style and design. </font><font style="vertical-align: inherit;">I am for uniformity and convenience. </font><font style="vertical-align: inherit;">The diplomacy of the presentation leaves much to be desired, but I took into account the criticism. </font><font style="vertical-align: inherit;">I ask for the shell.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en499546/index.html">Firmware development for an analog video camera EVR-Y2022F</a></li>
<li><a href="../en499548/index.html">Mask - caring for others or an illusion of security?</a></li>
<li><a href="../en499550/index.html">Ecosystem Low-Code Solutions</a></li>
<li><a href="../en499556/index.html">Game Server on MS Orleans - Part 3: Summary</a></li>
<li><a href="../en499560/index.html">Xswitcher layout corrector for linux: step two</a></li>
<li><a href="../en499564/index.html">Coronavirus in YouTube videos and comments</a></li>
<li><a href="../en499566/index.html">Augmentation on the fly - an important tool in the training of neural networks</a></li>
<li><a href="../en499570/index.html">What happens to transport at the end of April and when to wait for recovery</a></li>
<li><a href="../en499574/index.html">–Æ–ª–∏—è ‚Üí Iuliia. –í—Å—ë –æ —Ç—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏–∏</a></li>
<li><a href="../en499576/index.html">How to work with negative keywords in Yandex.Direct and Google Ads [and automate the process]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>