<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüè´ üö∂üèø ü§≥ Auswahl der Wichtigkeit von Merkmalen f√ºr k-n√§chste Nachbarn (Well oder andere Hyperparameter) durch Abstieg √§hnlich dem Gradienten üë®üèΩ‚Äçüíº üÜé üòå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beim Experimentieren mit der einfachsten Aufgabe des maschinellen Lernens fand ich es interessant, 18 Hyperparameter gleichzeitig in einem ziemlich we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Auswahl der Wichtigkeit von Merkmalen f√ºr k-n√§chste Nachbarn (Well oder andere Hyperparameter) durch Abstieg √§hnlich dem Gradienten</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496484/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/eg/qm/x6/egqmx63h8mgrbxfytg9nmuaby-g.gif" alt="Ein wahrer Unsinn kann nicht nur das Unm√∂gliche erf√ºllen, sondern auch als Warnbeispiel dienen"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Experimentieren mit der einfachsten Aufgabe des maschinellen Lernens fand ich es interessant, 18 Hyperparameter gleichzeitig in einem ziemlich weiten Bereich auszuw√§hlen. In meinem Fall war alles so einfach, dass die Aufgabe mit brutaler Computerleistung erledigt werden konnte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn man etwas lernt, kann es sehr interessant sein, eine Art Fahrrad zu erfinden. Manchmal stellt sich heraus, dass sich wirklich etwas Neues einfallen l√§sst. Manchmal stellt sich heraus, dass alles vor mir erfunden wurde. Aber selbst wenn ich nur den Weg wiederhole, den ich lange vor mir zur√ºckgelegt habe, bekomme ich als Belohnung oft ein Verst√§ndnis f√ºr die zugrunde liegenden Mechanismen der Algorithmen hinsichtlich ihrer F√§higkeiten und internen Einschr√§nkungen. Zu dem ich dich einlade.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Python und DS, um es milde auszudr√ºcken, bin ich ein Anf√§nger und mache viele Dinge, die gem√§√ü meiner alten Programmiergewohnheit in einem Team implementiert werden k√∂nnen. Python bestraft dies, indem er nicht zeitweise, sondern um Gr√∂√üenordnungen langsamer wird. </font><font style="vertical-align: inherit;">Daher lade ich meinen gesamten Code in das Repository hoch. </font><font style="vertical-align: inherit;">Wenn Sie wissen, wie Sie es viel effizienter implementieren k√∂nnen, seien Sie nicht sch√ºchtern, bearbeiten Sie es nicht und schreiben Sie nicht in die Kommentare. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/kraidiky/GDforHyperparameters</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wer bereits ein cooler Datatatanist ist und alles in diesem Leben ausprobiert hat, wird meiner Meinung nach eine Visualisierung des Lernprozesses interessant sein, die nicht nur f√ºr diese Aufgabe gilt.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formulierung des Problems</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt einen so guten DS-Kurs von ODS.ai und es gibt die dritte Vorlesungsklassifikation </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Entscheidungsb√§ume und die Methode der n√§chsten Nachbarn</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dort wird an extrem einfachen und wahrscheinlich synthetischen Daten gezeigt, wie der einfachste Entscheidungsbaum eine Genauigkeit von 94,5% ergibt, und dieselbe extrem einfache Methode von k n√§chsten Nachbarn ergibt 89% ohne Vorverarbeitung</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daten importieren und laden</font></font></b><div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<font></font>
%matplotlib inline<font></font>
<span class="hljs-keyword">import</span> warnings<font></font>
warnings.filterwarnings(<span class="hljs-string">'ignore'</span>)<font></font>
<font></font>
df = pd.read_csv(<span class="hljs-string">'data/telecom_churn.csv'</span>)<font></font>
df[<span class="hljs-string">'Voice mail plan'</span>] = pd.factorize(df[<span class="hljs-string">'Voice mail plan'</span>])[<span class="hljs-number">0</span>]<font></font>
df[<span class="hljs-string">'International plan'</span>] = pd.factorize(df[<span class="hljs-string">'International plan'</span>])[<span class="hljs-number">0</span>]<font></font>
df[<span class="hljs-string">'Churn'</span>] = df[<span class="hljs-string">'Churn'</span>].astype(<span class="hljs-string">'int32'</span>)<font></font>
states = df[<span class="hljs-string">'State'</span>]<font></font>
y = df[<span class="hljs-string">'Churn'</span>]<font></font>
df.drop([<span class="hljs-string">'State'</span>,<span class="hljs-string">'Churn'</span>], axis = <span class="hljs-number">1</span>, inplace=<span class="hljs-literal">True</span>)<font></font>
df.head()<font></font>
</code></pre></div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Holz mit knn vergleichen</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split, StratifiedKFold
<span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier
<span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GridSearchCV, cross_val_score
<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<font></font>
<font></font>
X_train, X_holdout, y_train, y_holdout = train_test_split(df.values, y, test_size=<span class="hljs-number">0.3</span>,<font></font>
random_state=<span class="hljs-number">17</span>)<font></font>
<font></font>
tree = DecisionTreeClassifier(random_state=<span class="hljs-number">17</span>, max_depth=<span class="hljs-number">5</span>)<font></font>
knn = KNeighborsClassifier(n_neighbors=<span class="hljs-number">10</span>)<font></font>
<font></font>
tree_params = {<span class="hljs-string">'max_depth'</span>: range(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>), <span class="hljs-string">'max_features'</span>: range(<span class="hljs-number">4</span>,<span class="hljs-number">19</span>)}<font></font>
tree_grid = GridSearchCV(tree, tree_params, cv=<span class="hljs-number">10</span>, n_jobs=<span class="hljs-number">-1</span>, verbose=<span class="hljs-literal">False</span>)<font></font>
tree_grid.fit(X_train, y_train)<font></font>
tree_grid.best_params_, tree_grid.best_score_, accuracy_score(y_holdout, tree_grid.predict(X_holdout))<font></font>
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
({'max_depth': 6, 'max_features': 16}, 0,944706386626661, 0,945)</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleiches gilt f√ºr knn</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time
<span class="hljs-keyword">from</span> sklearn.pipeline <span class="hljs-keyword">import</span> Pipeline
<span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<font></font>
<font></font>
knn_pipe = Pipeline([(<span class="hljs-string">'scaler'</span>, StandardScaler()), (<span class="hljs-string">'knn'</span>, KNeighborsClassifier(n_jobs=<span class="hljs-number">-1</span>))])<font></font>
knn_params = {<span class="hljs-string">'knn__n_neighbors'</span>: range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)}<font></font>
knn_grid = GridSearchCV(knn_pipe, knn_params, cv=<span class="hljs-number">10</span>, n_jobs=<span class="hljs-number">-1</span>, verbose=<span class="hljs-literal">False</span>)<font></font>
<font></font>
knn_grid.fit(X_train, y_train)<font></font>
knn_grid.best_params_, knn_grid.best_score_, accuracy_score(y_holdout, knn_grid.predict(X_holdout))<font></font>
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
({'knn__n_neighbors': 9}, 0.8868409772824689, 0.891) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu diesem Zeitpunkt tat es mir leid, dass knn offensichtlich unehrlich war, da wir keine Arbeit mit der Metrik hatten. </font><font style="vertical-align: inherit;">Ich habe nicht mit meinem Gehirn gedacht, ich habe feature_importances_ aus dem Baum genommen und die Eingabe normalisiert. </font><font style="vertical-align: inherit;">Je wichtiger das Merkmal ist, desto gr√∂√üer ist sein Beitrag zum Abstand zwischen den Punkten.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir f√ºttern die auf die Wichtigkeit von Merkmalen normierten Daten</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time<font></font>
feature_importances = pd.DataFrame({<span class="hljs-string">'features'</span>: df.columns, <span class="hljs-string">'importance'</span>:tree_grid.best_estimator_.feature_importances_})<font></font>
print(feature_importances.sort_values(by=[<span class="hljs-string">'importance'</span>], inplace=<span class="hljs-literal">False</span>, ascending=<span class="hljs-literal">False</span>))<font></font>
<font></font>
scaler = StandardScaler().fit(X_train)<font></font>
X_train_transformed = scaler.transform(X_train)<font></font>
X_train_transformed = X_train_transformed * np.array(feature_importances[<span class="hljs-string">'importance'</span>])<font></font>
<font></font>
X_holdout_transformed = scaler.transform(X_holdout)<font></font>
X_holdout_transformed = X_holdout_transformed * np.array(feature_importances[<span class="hljs-string">'importance'</span>])<font></font>
<font></font>
knn_grid = GridSearchCV(KNeighborsClassifier(n_jobs=<span class="hljs-number">-1</span>), {<span class="hljs-string">'n_neighbors'</span>: range(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">2</span>)}, cv=<span class="hljs-number">5</span>, n_jobs=<span class="hljs-number">-1</span>, verbose=<span class="hljs-literal">False</span>)<font></font>
knn_grid.fit(X_train_transformed, y_train)<font></font>
<span class="hljs-keyword">print</span> (knn_grid.best_params_, knn_grid.best_score_, accuracy_score(y_holdout, knn_grid.predict(X_holdout_transformed)))
</code></pre></div></div><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesamttagesminuten</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,270386</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kundendienstanrufe</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,147185</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesamtabend Minuten</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,135475</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Internationaler Plan</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,097249</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sechszehn</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesamtgeb√ºhr</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,091671</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºnfzehn</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesamtzahl der intl-Aufrufe</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">09.090008</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nummerieren Sie vmail-Nachrichten</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,050646</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesamtvorabendgeb√ºhr</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,038593</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesamttagesgeb√ºhr</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,026422</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voicemail-Plan</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,017068</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elf</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesamtnachtminuten</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,014185</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dreizehn</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesamtnachtgeb√ºhr</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,005742</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total Nachtanrufe</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,005502</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total Vorabend Anrufe</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,003614</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesamtzahl der Tagesanrufe</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,002246</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insgesamt intl Minuten</font></font></td>
<td>0.002009</td>
</tr>
<tr>
<td>0</td>
<td>Account length</td>
<td>0.001998</td>
</tr>
<tr>
<td>1</td>
<td>Area code</td>
<td>0.000000</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{'n_neighbors': 5} 0.909129875696528 0.913 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Baum hat nur ein wenig Wissen mit knn geteilt und jetzt sehen wir 91%. Das ist nicht so weit von 94,5% des Vanillebaums entfernt. Und dann kam mir eine Idee. Aber wie m√ºssen wir die Eingabe tats√§chlich normalisieren, damit knn das beste Ergebnis zeigt? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst werden wir uns √ºberlegen, wie viel dies jetzt als "Stirn" betrachtet wird. 18 Parameter, f√ºr jeden machen wir beispielsweise 10 m√∂gliche Schritte der Faktoren in der logarithmischen Skala. Wir bekommen 10e18 Optionen. Eine Option mit all der m√∂glichen ungeraden Anzahl von Nachbarn ist weniger als 10 und die Kreuzvalidierung ist auch 10, ich denke √ºber 1,5 Sekunden. Es stellt sich heraus, 42 Milliarden Jahre. Vielleicht muss die Idee, die Abrechnung f√ºr die Nacht zu verlassen, aufgegeben werden. :) Und irgendwo hier dachte ich: ‚ÄûHey! Also mache ich ein Fahrrad, das fliegen wird! ‚Äú</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verlaufssuche</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tats√§chlich steht f√ºr diese Aufgabe h√∂chstwahrscheinlich nur ein Maximum zur Verf√ºgung. </font><font style="vertical-align: inherit;">Nun, das ist nat√ºrlich kein Bereich mit guten Ergebnissen, aber sie sind sich ziemlich √§hnlich. </font><font style="vertical-align: inherit;">Daher k√∂nnen wir einfach entlang des Gef√§lles gehen und den am besten geeigneten Punkt finden. </font><font style="vertical-align: inherit;">Der erste Gedanke war, den genetischen Algorithmus zu verallgemeinern, aber hier scheint das adaptive Terrain nicht sehr gekreuzt zu sein, und dies w√§re ein wenig √ºbertrieben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde versuchen, es zun√§chst manuell zu tun. </font><font style="vertical-align: inherit;">Um Faktoren als Hyperparameter zu pushen, muss ich mich mit Skalierern befassen. </font><font style="vertical-align: inherit;">Im vorherigen Beispiel habe ich wie in der Lektion StandartScaler verwendet, der das Trainingsmuster im Durchschnitt zentrierte und Sigma = 1 machte. Um es innerhalb der Pipeline gut zu skalieren, muss der Hyperparameter etwas kniffliger gemacht werden. </font><font style="vertical-align: inherit;">Ich begann unter den in sklearn liegenden Konvertern nach etwas zu suchen, das f√ºr meinen Fall geeignet war, fand aber nichts. </font><font style="vertical-align: inherit;">Daher habe ich versucht, von StandartScaler zu erben, indem ich ein zus√§tzliches B√ºndel von Faktoren daran aufgeh√§ngt habe.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klasse f√ºr Nominalisierung und anschlie√üende Multiplikation mit einer Skala, die leicht mit der sklearn-Pipeline kompatibel ist</font></font></b><div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">from</span> sklearn.base <span class="hljs-keyword">import</span> TransformerMixin
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardAndPoorScaler</span>(<span class="hljs-params">StandardScaler, TransformerMixin</span>):</span>
    <span class="hljs-comment">#normalization = None</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, copy=True, with_mean=True, with_std=True, normalization = None</span>):</span>
        <span class="hljs-comment">#print("new StandardAndPoorScaler(normalization=", normalization.shape if normalization is not None else normalization, ") // ", type(self))</span><font></font>
        self.normalization = normalization<font></font>
        super().__init__(copy, with_mean, with_std)<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fit</span>(<span class="hljs-params">self, X, y=None</span>):</span>
        <span class="hljs-comment">#print(type(self),".fit(",X.shape, ",", y.shape if y is not None else "&lt;null&gt;",")")</span><font></font>
        super().fit(X, y)<font></font>
        <span class="hljs-keyword">return</span> self
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partial_fit</span>(<span class="hljs-params">self, X, y=None</span>):</span>
        <span class="hljs-comment">#print(type(self),".partial_fit(",X.shape, ",", y.shape if y is not None else "&lt;null&gt;)")</span><font></font>
        super().partial_fit(X, y)<font></font>
        <span class="hljs-keyword">if</span> self.normalization <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
            self.normalization = np.ones((X.shape[<span class="hljs-number">1</span>]))
        <span class="hljs-keyword">elif</span> type(self.normalization) != np.ndarray:<font></font>
            self.normalization = np.array(self.normalization)<font></font>
        <span class="hljs-keyword">if</span> X.shape[<span class="hljs-number">1</span>] != self.normalization.shape[<span class="hljs-number">0</span>]:
            <span class="hljs-keyword">raise</span> <span class="hljs-string">"X.shape[1]="</span>+X.shape[<span class="hljs-number">1</span>]+<span class="hljs-string">" in equal self.scale.shape[0]="</span>+self.normalization.shape[<span class="hljs-number">0</span>]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transform</span>(<span class="hljs-params">self, X, copy=None</span>):</span>
        <span class="hljs-comment">#print(type(self),".transform(",X.shape,",",copy,").self.normalization", self.normalization)</span><font></font>
        Xresult = super().transform(X, copy)<font></font>
        Xresult *= self.normalization<font></font>
        <span class="hljs-keyword">return</span> Xresult
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_reset</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-comment">#print(type(self),"._reset()")</span><font></font>
        super()._reset()<font></font>
    <font></font>
scaler = StandardAndPoorScaler(normalization = feature_importances[<span class="hljs-string">'importance'</span>])<font></font>
scaler.fit(X = X_train, y = <span class="hljs-literal">None</span>)<font></font>
print(scaler.normalization)<font></font>
</code></pre></div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich versuche, diese Klasse anzuwenden</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time<font></font>
knn_pipe = Pipeline([(<span class="hljs-string">'scaler'</span>, StandardAndPoorScaler()), (<span class="hljs-string">'knn'</span>, KNeighborsClassifier(n_jobs=<span class="hljs-number">-1</span>))])<font></font>
<font></font>
knn_params = {<span class="hljs-string">'knn__n_neighbors'</span>: range(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>), <span class="hljs-string">'scaler__normalization'</span>: [feature_importances[<span class="hljs-string">'importance'</span>]]}<font></font>
knn_grid = GridSearchCV(knn_pipe, knn_params, cv=<span class="hljs-number">5</span>, n_jobs=<span class="hljs-number">-1</span>, verbose=<span class="hljs-literal">False</span>)<font></font>
<font></font>
knn_grid.fit(X_train, y_train)<font></font>
knn_grid.best_params_, knn_grid.best_score_, accuracy_score(y_holdout, knn_grid.predict(X_holdout))<font></font>
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
({'knn__n_neighbors': 5, 'scaler__normalization': Name: Wichtigkeit, Typ: float64}, 0.909558508358337, 0.913) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis </font><font style="vertical-align: inherit;">weicht </font><font style="vertical-align: inherit;">geringf√ºgig von meinen Erwartungen ab. Das hei√üt, im Prinzip funktioniert alles. Um dies zu verstehen, musste ich diese Klasse in drei Stunden mit allem Mut von Grund auf neu reproduzieren. Erst dann wurde mir klar, dass der Druck nicht gedruckt wird, nicht weil sklearn irgendwie falsch gemacht wurde, sondern weil GridSearchCV Klone im Hauptstrom erstellt , konfiguriert und trainiert sie jedoch in anderen Threads. Und alles, was Sie in anderen Streams drucken, verschwindet in Vergessenheit. Wenn Sie jedoch n_jobs = 1 setzen, werden alle Aufrufe √ºberschriebener Funktionen als niedlich angezeigt. Wissen war sehr teuer, jetzt haben Sie es auch und Sie haben es bezahlt, indem Sie einen langwierigen Artikel gelesen haben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Okay, lass uns weitermachen. </font><font style="vertical-align: inherit;">Jetzt m√∂chte ich f√ºr jeden ihrer Parameter eine gewisse Varianz angeben und sie dann um den besten Wert herum etwas weniger angeben, und so weiter, bis ich ein realit√§ts√§hnliches Ergebnis erhalte. </font><font style="vertical-align: inherit;">Dies wird die erste unh√∂fliche Grundlinie dessen sein, was irgendwann den Algorithmus meiner Tr√§ume bekommen sollte.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich werde verschiedene Optionen f√ºr die Neugewichtung bilden, die sich in mehreren Parametern unterscheiden</font></font></b><div class="spoiler_text"><pre><code class="python hljs">feature_base = feature_importances[<span class="hljs-string">'importance'</span>]<font></font>
searchArea = np.array([feature_base - <span class="hljs-number">.05</span>, feature_base, feature_base + <span class="hljs-number">.05</span>])<font></font>
searchArea[searchArea &lt; <span class="hljs-number">0</span>] = <span class="hljs-number">0</span>
searchArea[searchArea &gt; <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>
print(searchArea[<span class="hljs-number">2</span>,:] - searchArea[<span class="hljs-number">0</span>,:])<font></font>
<font></font>
<span class="hljs-keyword">import</span> itertools<font></font>
<font></font>
affected_props = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<font></font>
parametrs_ranges = np.concatenate([<font></font>
    np.linspace(searchArea[<span class="hljs-number">0</span>,affected_props], searchArea[<span class="hljs-number">1</span>,affected_props], <span class="hljs-number">2</span>, endpoint=<span class="hljs-literal">False</span>),<font></font>
    np.linspace(searchArea[<span class="hljs-number">1</span>,affected_props], searchArea[<span class="hljs-number">2</span>,affected_props], <span class="hljs-number">3</span>, endpoint=<span class="hljs-literal">True</span>)]).transpose()<font></font>
<font></font>
print(parametrs_ranges) <span class="hljs-comment">#      .  125 </span>
recombinations = itertools.product(parametrs_ranges[<span class="hljs-number">0</span>],parametrs_ranges[<span class="hljs-number">1</span>],parametrs_ranges[<span class="hljs-number">1</span>])<font></font>
<font></font>
variances = []<font></font>
<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> recombinations: <span class="hljs-comment">#          ,       Python .</span><font></font>
    varince = feature_base.copy()<font></font>
    varince[affected_props] = item<font></font>
    variances.append(varince)<font></font>
print(variances[<span class="hljs-number">0</span>])<font></font>
print(len(variances))<font></font>
<span class="hljs-comment">#  knn   ,               .</span>
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, der Datensatz f√ºr das erste Experiment ist fertig. </font><font style="vertical-align: inherit;">Jetzt werde ich versuchen, mit den Daten zu experimentieren, um zun√§chst die resultierenden 15 Optionen gr√ºndlich zu durchsuchen.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir treffen eine Versuchsauswahl von Parametern wie im Artikel</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time
<span class="hljs-comment">#scale = np.ones([18])</span>
knn_pipe = Pipeline([(<span class="hljs-string">'scaler'</span>, StandardAndPoorScaler()), (<span class="hljs-string">'knn'</span>, KNeighborsClassifier(n_neighbors = <span class="hljs-number">7</span> , n_jobs=<span class="hljs-number">-1</span>))])<font></font>
<font></font>
knn_params = {<span class="hljs-string">'scaler__normalization'</span>: variances} <span class="hljs-comment"># 'knn__n_neighbors': range(3, 9, 2), </span>
knn_grid = GridSearchCV(knn_pipe, knn_params, cv=<span class="hljs-number">10</span>, n_jobs=<span class="hljs-number">-1</span>, verbose=<span class="hljs-literal">False</span>)<font></font>
<font></font>
knn_grid.fit(X_train, y_train)<font></font>
knn_grid.best_params_, knn_grid.best_score_, accuracy_score(y_holdout, knn_grid.predict(X_holdout))</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, alles ist schlecht, die Zeit wurde f√ºr einen Durchbruch aufgewendet und das Ergebnis ist sehr instabil. </font><font style="vertical-align: inherit;">Dies geht auch aus der X_holdout-Pr√ºfung hervor, bei der das Ergebnis wie in einem Kaleidoskop mit geringf√ºgigen √Ñnderungen an den Eingabedaten tanzt. </font><font style="vertical-align: inherit;">Ich werde einen anderen Ansatz versuchen. </font><font style="vertical-align: inherit;">Ich werde jeweils nur einen Parameter √§ndern, jedoch mit einer viel gr√∂√üeren Diskretisierung.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich √§ndere eine 4. Eigenschaft</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time<font></font>
affected_property = <span class="hljs-number">4</span><font></font>
parametrs_range = np.concatenate([<font></font>
    np.linspace(searchArea[<span class="hljs-number">0</span>,affected_property], searchArea[<span class="hljs-number">1</span>,affected_property], <span class="hljs-number">29</span>, endpoint=<span class="hljs-literal">False</span>),<font></font>
    np.linspace(searchArea[<span class="hljs-number">1</span>,affected_property], searchArea[<span class="hljs-number">2</span>,affected_property], <span class="hljs-number">30</span>, endpoint=<span class="hljs-literal">True</span>)]).transpose()<font></font>
<font></font>
print(searchArea[<span class="hljs-number">1</span>,affected_property])<font></font>
print(parametrs_range) <span class="hljs-comment"># C   ,  .</span><font></font>
<font></font>
<font></font>
variances = []<font></font>
<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> parametrs_range: <span class="hljs-comment">#          ,       Python .</span><font></font>
    varince = feature_base.copy()<font></font>
    varince[affected_property] = item<font></font>
    variances.append(varince)<font></font>
print(variances[<span class="hljs-number">0</span>])<font></font>
print(len(variances))<font></font>
<span class="hljs-comment">#  knn   ,               .</span><font></font>
<font></font>
knn_pipe = Pipeline([(<span class="hljs-string">'scaler'</span>, StandardAndPoorScaler()), (<span class="hljs-string">'knn'</span>, KNeighborsClassifier(n_neighbors = <span class="hljs-number">7</span> , n_jobs=<span class="hljs-number">-1</span>))])<font></font>
<font></font>
knn_params = {<span class="hljs-string">'scaler__normalization'</span>: variances} <span class="hljs-comment"># 'knn__n_neighbors': range(3, 9, 2), </span>
knn_grid = GridSearchCV(knn_pipe, knn_params, cv=<span class="hljs-number">10</span>, n_jobs=<span class="hljs-number">-1</span>, verbose=<span class="hljs-literal">False</span>)<font></font>
<font></font>
knn_grid.fit(X_train, y_train)<font></font>
knn_grid.best_params_, knn_grid.best_score_, accuracy_score(y_holdout, knn_grid.predict(X_holdout))</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
({'scaler__normalization': 4 0.079957 Name: Wichtigkeit, Typ: float64}, 0.9099871410201458, 0.913) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, was haben wir mit einer Gans? </font><font style="vertical-align: inherit;">Verschiebungen von ein bis zwei Zehntel Prozent bei der Kreuzvalidierung und ein halbes Prozent Sprung bei X_holdout, wenn Sie sich verschiedene betroffene Eigenschaften ansehen. </font><font style="vertical-align: inherit;">Anscheinend ist es wichtig und billig, die Situation zu verbessern, wenn Sie mit der Tatsache beginnen, dass der Baum uns gibt, dass es mit solchen Daten unm√∂glich ist. </font><font style="vertical-align: inherit;">Nehmen wir jedoch an, wir haben keine anf√§ngliche, bekannte Gewichtsverteilung und versuchen, dies an einem beliebigen Punkt im Zyklus mit winzigen Schritten zu tun. </font><font style="vertical-align: inherit;">Es ist sehr interessant, wozu wir kommen werden.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstbef√ºllung</font></font></b><div class="spoiler_text"><pre><code class="python hljs">searchArea = np.array([np.zeros((<span class="hljs-number">18</span>,)), np.ones((<span class="hljs-number">18</span>,)) /<span class="hljs-number">18</span>, np.ones((<span class="hljs-number">18</span>,))])<font></font>
print(searchArea[:,<span class="hljs-number">0</span>])<font></font>
<font></font>
history_parametrs = [searchArea[<span class="hljs-number">1</span>,:].copy()]<font></font>
scaler = StandardAndPoorScaler(normalization=searchArea[<span class="hljs-number">1</span>,:])<font></font>
scaler.fit(X_train)<font></font>
knn = KNeighborsClassifier(n_neighbors = <span class="hljs-number">7</span> , n_jobs=<span class="hljs-number">-1</span>)<font></font>
knn.fit(scaler.transform(X_train), y_train)<font></font>
history_holdout_score = [accuracy_score(y_holdout, knn.predict(scaler.transform(X_holdout)))]</code></pre></div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktion, die einen Parameter leicht √§ndert (mit Debug-Protokollen)</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">changePropertyNormalization</span>(<span class="hljs-params">affected_property, points_count = <span class="hljs-number">15</span></span>):</span><font></font>
    test_range = np.concatenate([<font></font>
        np.linspace(searchArea[<span class="hljs-number">0</span>,affected_property], searchArea[<span class="hljs-number">1</span>,affected_property], points_count//<span class="hljs-number">2</span>, endpoint=<span class="hljs-literal">False</span>),<font></font>
        np.linspace(searchArea[<span class="hljs-number">1</span>,affected_property], searchArea[<span class="hljs-number">2</span>,affected_property], points_count//<span class="hljs-number">2</span> + <span class="hljs-number">1</span>, endpoint=<span class="hljs-literal">True</span>)]).transpose()<font></font>
    variances = [searchArea[<span class="hljs-number">1</span>,:].copy() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(test_range.shape[<span class="hljs-number">0</span>])]
    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(len(variances)):<font></font>
        variances[row][affected_property] = test_range[row]<font></font>
    <font></font>
    knn_pipe = Pipeline([(<span class="hljs-string">'scaler'</span>, StandardAndPoorScaler()), (<span class="hljs-string">'knn'</span>, KNeighborsClassifier(n_neighbors = <span class="hljs-number">7</span> , n_jobs=<span class="hljs-number">-1</span>))])<font></font>
    knn_params = {<span class="hljs-string">'scaler__normalization'</span>: variances} <span class="hljs-comment"># 'knn__n_neighbors': range(3, 9, 2), </span>
    knn_grid = GridSearchCV(knn_pipe, knn_params, cv=<span class="hljs-number">10</span>, n_jobs=<span class="hljs-number">-1</span>, verbose=<span class="hljs-literal">False</span>)<font></font>
<font></font>
    knn_grid.fit(X_train, y_train)<font></font>
    holdout_score = accuracy_score(y_holdout, knn_grid.predict(X_holdout))<font></font>
    best_param = knn_grid.best_params_[<span class="hljs-string">'scaler__normalization'</span>][affected_property]<font></font>
    print(affected_property,<font></font>
          <span class="hljs-string">'property:'</span>, searchArea[<span class="hljs-number">1</span>, affected_property], <span class="hljs-string">"=&gt;"</span>, best_param,
          <span class="hljs-string">'holdout:'</span>, history_holdout_score[<span class="hljs-number">-1</span>], <span class="hljs-string">"=&gt;"</span>, holdout_score, <span class="hljs-string">'('</span>, knn_grid.best_score_, <span class="hljs-string">')'</span>)
    <span class="hljs-comment">#             .</span><font></font>
    before = searchArea[:, affected_property]<font></font>
    propertySearchArea = searchArea[:, affected_property].copy()<font></font>
    <span class="hljs-keyword">if</span> best_param == propertySearchArea[<span class="hljs-number">0</span>]:<font></font>
        print(<span class="hljs-string">'|&lt;&lt;'</span>)<font></font>
        searchArea[<span class="hljs-number">0</span>, affected_property] = best_param/<span class="hljs-number">2</span> <span class="hljs-keyword">if</span> best_param &gt; <span class="hljs-number">0.01</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
        searchArea[<span class="hljs-number">2</span>, affected_property] = (best_param + searchArea[<span class="hljs-number">2</span>, affected_property])/<span class="hljs-number">2</span>
        searchArea[<span class="hljs-number">1</span>, affected_property] = best_param
    <span class="hljs-keyword">elif</span> best_param == propertySearchArea[<span class="hljs-number">2</span>]:<font></font>
        print(<span class="hljs-string">'&gt;&gt;|'</span>)<font></font>
        searchArea[<span class="hljs-number">2</span>, affected_property] = (best_param + <span class="hljs-number">1</span>)/<span class="hljs-number">2</span> <span class="hljs-keyword">if</span> best_param &lt; <span class="hljs-number">0.99</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>
        searchArea[<span class="hljs-number">0</span>, affected_property] = (best_param + searchArea[<span class="hljs-number">0</span>, affected_property])/<span class="hljs-number">2</span>
        searchArea[<span class="hljs-number">1</span>, affected_property] = best_param
    <span class="hljs-keyword">elif</span> best_param &lt; (propertySearchArea[<span class="hljs-number">0</span>] + propertySearchArea[<span class="hljs-number">1</span>])/<span class="hljs-number">2</span>:<font></font>
        print(<span class="hljs-string">'&lt;&lt;'</span>)<font></font>
        searchArea[<span class="hljs-number">0</span>, affected_property] = max(propertySearchArea[<span class="hljs-number">0</span>]*<span class="hljs-number">1.1</span> - <span class="hljs-number">.1</span>*propertySearchArea[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>)<font></font>
        searchArea[<span class="hljs-number">2</span>, affected_property] = (best_param + propertySearchArea[<span class="hljs-number">2</span>])/<span class="hljs-number">2</span>
        searchArea[<span class="hljs-number">1</span>, affected_property] = best_param
    <span class="hljs-keyword">elif</span> best_param &gt; (propertySearchArea[<span class="hljs-number">1</span>] + propertySearchArea[<span class="hljs-number">2</span>])/<span class="hljs-number">2</span>:<font></font>
        print(<span class="hljs-string">'&gt;&gt;'</span>)<font></font>
        searchArea[<span class="hljs-number">0</span>, affected_property] = (best_param + propertySearchArea[<span class="hljs-number">0</span>])/<span class="hljs-number">2</span>
        searchArea[<span class="hljs-number">2</span>, affected_property] = min(propertySearchArea[<span class="hljs-number">2</span>]*<span class="hljs-number">1.1</span> - <span class="hljs-number">.1</span>*propertySearchArea[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>)<font></font>
        searchArea[<span class="hljs-number">1</span>, affected_property] = best_param
    <span class="hljs-keyword">elif</span> best_param &lt; propertySearchArea[<span class="hljs-number">1</span>]:<font></font>
        print(<span class="hljs-string">'&lt;'</span>)<font></font>
        searchArea[<span class="hljs-number">2</span>, affected_property] = searchArea[<span class="hljs-number">1</span>, affected_property]*<span class="hljs-number">.25</span> + <span class="hljs-number">.75</span>*searchArea[<span class="hljs-number">2</span>, affected_property]<font></font>
        searchArea[<span class="hljs-number">1</span>, affected_property] = best_param
    <span class="hljs-keyword">elif</span> best_param &gt; propertySearchArea[<span class="hljs-number">1</span>]:<font></font>
        print(<span class="hljs-string">'&gt;'</span>)<font></font>
        searchArea[<span class="hljs-number">0</span>, affected_property] = searchArea[<span class="hljs-number">1</span>, affected_property]*<span class="hljs-number">.25</span> + <span class="hljs-number">.75</span>*searchArea[<span class="hljs-number">0</span>, affected_property]<font></font>
        searchArea[<span class="hljs-number">1</span>, affected_property] = best_param
    <span class="hljs-keyword">else</span>:<font></font>
        print(<span class="hljs-string">'='</span>)<font></font>
        searchArea[<span class="hljs-number">0</span>, affected_property] = searchArea[<span class="hljs-number">1</span>, affected_property]*<span class="hljs-number">.25</span> + <span class="hljs-number">.75</span>*searchArea[<span class="hljs-number">0</span>, affected_property]<font></font>
        searchArea[<span class="hljs-number">2</span>, affected_property] = searchArea[<span class="hljs-number">1</span>, affected_property]*<span class="hljs-number">.25</span> + <span class="hljs-number">.75</span>*searchArea[<span class="hljs-number">2</span>, affected_property]<font></font>
    normalization = searchArea[<span class="hljs-number">1</span>,:].sum() <span class="hljs-comment">#,      .</span><font></font>
    searchArea[:,:] /= normalization<font></font>
    print(before, <span class="hljs-string">"=&gt;"</span>,searchArea[:, affected_property])<font></font>
    history_parametrs.append(searchArea[<span class="hljs-number">1</span>,:].copy())<font></font>
    history_holdout_score.append(holdout_score)<font></font>
    <font></font>
changePropertyNormalization(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>)<font></font>
changePropertyNormalization(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>)
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe nirgendwo etwas optimiert und deshalb fast eine halbe Stunde lang den n√§chsten entscheidenden Schritt getan:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versteckter Text</font></font></b><div class="spoiler_text">       40 .<pre><code class="python hljs">%%time
<span class="hljs-comment">#   </span>
searchArea = np.array([np.zeros((<span class="hljs-number">18</span>,)), np.ones((<span class="hljs-number">18</span>,)) /<span class="hljs-number">18</span>, np.ones((<span class="hljs-number">18</span>,))])<font></font>
print(searchArea[:,<span class="hljs-number">0</span>])<font></font>
<font></font>
history_parametrs = [searchArea[<span class="hljs-number">1</span>,:].copy()]<font></font>
scaler = StandardAndPoorScaler(normalization=searchArea[<span class="hljs-number">1</span>,:])<font></font>
scaler.fit(X_train)<font></font>
knn = KNeighborsClassifier(n_neighbors = <span class="hljs-number">7</span> , n_jobs=<span class="hljs-number">-1</span>)<font></font>
knn.fit(scaler.transform(X_train), y_train)<font></font>
history_holdout_score = [accuracy_score(y_holdout, knn.predict(scaler.transform(X_holdout)))]<font></font>
<font></font>
<span class="hljs-keyword">for</span> tick <span class="hljs-keyword">in</span> range(<span class="hljs-number">40</span>):
    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> range(searchArea.shape[<span class="hljs-number">1</span>]):<font></font>
        changePropertyNormalization(p, <span class="hljs-number">7</span>)<font></font>
    <font></font>
print(searchArea[<span class="hljs-number">1</span>,:])<font></font>
print(history_holdout_score)</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die resultierende Genauigkeit von knn: 91,9% Besser als wenn wir die Daten aus dem Baum rei√üen. </font><font style="vertical-align: inherit;">Und viel, viel besser als in der Originalversion. </font><font style="vertical-align: inherit;">Vergleichen Sie das, was wir haben, mit der Wichtigkeit von Merkmalen gem√§√ü dem Entscheidungsbaum:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visualisierung der Wichtigkeit von Merkmalen nach knn</font></font></b><div class="spoiler_text"><pre><code class="python hljs">feature_importances[<span class="hljs-string">'knn_importance'</span>] = history_parametrs[<span class="hljs-number">-1</span>]<font></font>
diagramma = feature_importances.copy()<font></font>
indexes = diagramma.index<font></font>
diagramma.index = diagramma[<span class="hljs-string">'features'</span>]<font></font>
diagramma.drop(<span class="hljs-string">'features'</span>, <span class="hljs-number">1</span>, inplace = <span class="hljs-literal">True</span>)<font></font>
diagramma.plot(kind=<span class="hljs-string">'bar'</span>);<font></font>
plt.savefig(<span class="hljs-string">"images/pic1.png"</span>, format = <span class="hljs-string">'png'</span>)<font></font>
plt.show()<font></font>
feature_importances</code></pre></div></div><br>
<img src="https://habrastorage.org/webt/kk/pe/nf/kkpenftrnyfl6dpu4p1qh2dnwqq.gif"><br>
<br>
<img src="https://habrastorage.org/webt/ui/o2/rp/uio2rplq9j2p5cxppq7jb7h_mpk.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Scheinen? </font><font style="vertical-align: inherit;">Ja, es scheint. </font><font style="vertical-align: inherit;">Aber alles andere als identisch. </font><font style="vertical-align: inherit;">Interessante Beobachtung. </font><font style="vertical-align: inherit;">Der Datensatz enth√§lt mehrere Funktionen, die sich vollst√§ndig duplizieren, z. B. "Gesamtnachtminuten" und "Gesamtnachtgeb√ºhr". </font><font style="vertical-align: inherit;">Achten Sie also darauf, dass Sie selbst einen wesentlichen Teil dieser wiederholten Merkmale herausges√§gt haben.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden die Ergebnisse in einer Datei speichern, andernfalls ist es etwas unpraktisch, zur Arbeit zur√ºckzukehren.</font></font></b><div class="spoiler_text"><pre><code class="python hljs">parametrs_df = pd.DataFrame(history_parametrs)<font></font>
parametrs_df[<span class="hljs-string">'scores'</span>] = history_holdout_score<font></font>
parametrs_df.index.name = <span class="hljs-string">'index'</span>
parametrs_df.to_csv(<span class="hljs-string">'parametrs_and_scores.csv'</span>)
</code></pre></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, das Ergebnis .919 an sich ist nicht schlecht f√ºr knn, es gibt 1,5-mal weniger Fehler als in der Vanilla-Version und 7% weniger als zu dem Zeitpunkt, als wir den Baum feature_importance zum Fahren genommen haben. </font><font style="vertical-align: inherit;">Aber das Interessanteste ist, dass wir jetzt nach knn selbst feature_importance haben. </font><font style="vertical-align: inherit;">Es ist etwas anders als das, was der Baum uns gesagt hat. </font><font style="vertical-align: inherit;">Zum Beispiel haben Baum und Knn unterschiedliche Meinungen dar√ºber, welche der Zeichen f√ºr uns √ºberhaupt nicht wichtig sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, am Ende. </font><font style="vertical-align: inherit;">Wir haben etwas relativ Neues und Ungew√∂hnliches, das √ºber eine Wissensreserve von drei Vortr√§gen mlcourse.ai </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ods und Google verf√ºgt, um einfache Fragen zu Python zu beantworten. </font><font style="vertical-align: inherit;">Meiner Meinung nach nicht schlecht.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt Folien</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Nebenprodukt der Arbeit des Algorithmus ist der Weg, den er zur√ºckgelegt hat. Der Pfad ist jedoch 18-dimensional, was sein Bewusstsein ein wenig behindert, in Echtzeit zu verfolgen, was der Algorithmus dort tut. Lernen oder Verwenden von M√ºll ist nicht so bequem. Nach dem Fehlerplan ist dies tats√§chlich nicht immer sichtbar. Der Fehler √§ndert sich m√∂glicherweise lange Zeit nicht merklich, aber der Algorithmus ist sehr besch√§ftigt und kriecht im adaptiven Raum entlang eines langen, engen Tals. Daher werde ich zun√§chst den ersten einfachsten, aber recht informativen Ansatz anwenden - ich projiziere zuf√§llig einen 18-dimensionalen Raum auf einen zweidimensionalen Raum, so dass die Beitr√§ge aller Parameter unabh√§ngig von ihrer Bedeutung einzeln sind. Tats√§chlich ist der 18-dimensionale Pfad in unserem Artikel </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Peeping Over the Throws of a Neural Network</font></a><font style="vertical-align: inherit;"> sehr klein</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich bewunderte ebenfalls den Raum der Skalen aller Synapsen, die das neuronale Netzwerk hatte, und es war nett und informativ.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich lese die Daten aus der Datei, wenn ich zur Arbeit zur√ºckkehre, nachdem ich die Schulungsphase selbst bestanden habe</font></font></b><div class="spoiler_text"><pre><code class="python hljs">parametrs_df = pd.read_csv(<span class="hljs-string">'parametrs_and_scores.csv'</span>, index_col = <span class="hljs-string">'index'</span>)<font></font>
history_holdout_score = np.array(parametrs_df[<span class="hljs-string">'scores'</span>])<font></font>
parametrs_df.drop(<span class="hljs-string">'scores'</span>,axis=<span class="hljs-number">1</span>)<font></font>
history_parametrs = np.array(parametrs_df.drop(<span class="hljs-string">'scores'</span>,axis=<span class="hljs-number">1</span>))</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Fehler bei der Validierung √§ndert sich ab einem bestimmten Punkt nicht mehr. </font><font style="vertical-align: inherit;">Hier w√§re es m√∂glich, einen automatischen Lernstopp einzuschalten und die empfangene Funktion f√ºr den Rest meines Lebens zu nutzen, aber ich habe bereits ein wenig Zeit. </font><font style="vertical-align: inherit;">:(</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir bestimmen, wie viel wir lernen sollen.</font></font></b><div class="spoiler_text"><pre><code class="python hljs">last = history_holdout_score[<span class="hljs-number">-1</span>]<font></font>
steps = np.arange(<span class="hljs-number">0</span>, history_holdout_score.shape[<span class="hljs-number">0</span>])[history_holdout_score != last].max()<font></font>
print(steps/<span class="hljs-number">18</span>)</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
35.5555555555555556 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben jeweils einen Parameter ge√§ndert, sodass ein Optimierungszyklus </font><font style="vertical-align: inherit;">aus </font><font style="vertical-align: inherit;">18 Schritten besteht. </font><font style="vertical-align: inherit;">Es stellt sich heraus, dass wir 36 bedeutungsvolle Schritte hatten, oder so √§hnlich. </font><font style="vertical-align: inherit;">Versuchen wir nun, die Flugbahn zu visualisieren, auf der die Methode trainiert wurde.</font></font><br>
<br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versteckter Text</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time
<span class="hljs-comment">#    :</span>
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<font></font>
%matplotlib inline<font></font>
<span class="hljs-keyword">import</span> random
<span class="hljs-keyword">import</span> math<font></font>
random.seed(<span class="hljs-number">17</span>)<font></font>
property_projection = np.array([[math.sin(a), math.cos(a)] <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> [random.uniform(-math.pi, math.pi) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(history_parametrs[<span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>])]]).transpose()<font></font>
history = np.array(history_parametrs[::<span class="hljs-number">18</span>]) <span class="hljs-comment">#   - 18 .</span>
<span class="hljs-comment">#           . :(</span>
points = np.array([(history[i] * property_projection).sum(axis=<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(history.shape[<span class="hljs-number">0</span>])])<font></font>
plt.plot(points[:<span class="hljs-number">36</span>,<span class="hljs-number">0</span>],points[<span class="hljs-number">0</span>:<span class="hljs-number">36</span>,<span class="hljs-number">1</span>]);<font></font>
plt.savefig(<span class="hljs-string">"images/pic2.png"</span>, format = <span class="hljs-string">'png'</span>)<font></font>
plt.show()</code></pre></div></div><br>
<img src="https://habrastorage.org/webt/jt/zs/rc/jtzsrcgk60i_aeqhcvxjq9atvee.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist ersichtlich, dass ein wesentlicher Teil der Reise in den ersten vier Schritten abgeschlossen wurde. </font><font style="vertical-align: inherit;">Schauen wir uns den Rest des Weges mit zunehmender Bedeutung an</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne die ersten 4 Punkte</font></font></b><div class="spoiler_text"><pre><code class="python hljs">plt.plot(points[<span class="hljs-number">4</span>:<span class="hljs-number">36</span>,<span class="hljs-number">0</span>],points[<span class="hljs-number">4</span>:<span class="hljs-number">36</span>,<span class="hljs-number">1</span>]);<font></font>
plt.savefig(<span class="hljs-string">"images/pic3.png"</span>, format = <span class="hljs-string">'png'</span>)</code></pre></div></div><br>
<img src="https://habrastorage.org/webt/gq/xh/wa/gqxhwawt9nnsmypgk3tkry9vbpw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns den letzten Teil des Weges genauer an und sehen, was die Lehrerin getan hat, nachdem sie ihr Ziel erreicht hat.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√ºckt n√§her</font></font></b><div class="spoiler_text"><pre><code class="python hljs">plt.plot(points[<span class="hljs-number">14</span>:<span class="hljs-number">36</span>,<span class="hljs-number">0</span>],points[<span class="hljs-number">14</span>:<span class="hljs-number">36</span>,<span class="hljs-number">1</span>]);<font></font>
plt.savefig(<span class="hljs-string">"images/pic4.png"</span>, format = <span class="hljs-string">'png'</span>)<font></font>
plt.show()<font></font>
plt.plot(points[<span class="hljs-number">24</span>:<span class="hljs-number">36</span>,<span class="hljs-number">0</span>],points[<span class="hljs-number">24</span>:<span class="hljs-number">36</span>,<span class="hljs-number">1</span>]);<font></font>
plt.plot(points[<span class="hljs-number">35</span>:,<span class="hljs-number">0</span>],points[<span class="hljs-number">35</span>:,<span class="hljs-number">1</span>], color = <span class="hljs-string">'red'</span>);<font></font>
plt.savefig(<span class="hljs-string">"images/pic5.png"</span>, format = <span class="hljs-string">'png'</span>)<font></font>
plt.show()</code></pre></div></div><br>
<img src="https://habrastorage.org/webt/a5/kq/6m/a5kq6mq5yxl3roojyjfzdw8wq8a.png"><br>
<br>
<img src="https://habrastorage.org/webt/g5/lo/gs/g5logsa_jmna5lveoc-w0679koy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist ersichtlich, dass der Algorithmus intensiv trainiert wird. Bis er sein Ziel findet. Der spezifische Punkt h√§ngt nat√ºrlich von der Randomisierung bei der Kreuzvalidierung ab. Unabh√§ngig vom konkreten Punkt ist das allgemeine Bild des Geschehens verst√§ndlich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úbrigens habe ich einen solchen Zeitplan verwendet, um den Lernprozess zu demonstrieren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird nicht die gesamte Flugbahn angezeigt, sondern die letzten Schritte mit gleitender Gl√§ttung der Skala. Ein Beispiel finden Sie in meinem anderen Artikel ‚ÄûWir spionieren die W√ºrfe eines neuronalen Netzwerks aus‚Äú. Und ja, nat√ºrlich fragt jeder, der auf eine solche Visualisierung st√∂√üt, sofort, warum alle Faktoren das gleiche Gewicht und die gleiche Bedeutung haben und dann unterschiedliche. Das letzte Mal in diesem Artikel habe ich versucht, die Bedeutung von Synapsen neu zu gewichten, und es stellte sich als weniger informativ heraus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Mal werde ich mit neuem Wissen versuchen, mit t-SNE mehrdimensionalen Raum in einer Projektion bereitzustellen, in der alles besser sein kann.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t-SNE</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time
<span class="hljs-keyword">import</span> sklearn.manifold <span class="hljs-keyword">as</span> manifold<font></font>
tsne = manifold.TSNE(random_state=<span class="hljs-number">19</span>)<font></font>
tsne_representation = tsne.fit_transform(history)<font></font>
plt.plot(tsne_representation[:, <span class="hljs-number">0</span>], tsne_representation[:, <span class="hljs-number">1</span>])<font></font>
plt.savefig(<span class="hljs-string">"images/pic6.png"</span>, format = <span class="hljs-string">'png'</span>)<font></font>
plt.show();</code></pre></div></div><br>
<img src="https://habrastorage.org/webt/qe/bp/nn/qebpnnz71ywbxgqvhzj3fpv8vzc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
t-Sne scheint den Raum so entfaltet zu haben, dass er das Ausma√ü der √Ñnderungen f√ºr jene Merkmale, die sich schnell nicht mehr √§nderten, vollst√§ndig verschlang, was das Bild v√∂llig uninformativ machte. </font><font style="vertical-align: inherit;">Schlussfolgerung - Versuchen Sie nicht, die Algorithmen an Stellen zu verschieben, die nicht f√ºr sie bestimmt sind: \</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen nicht weiter lesen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe auch versucht, tsne nach innen zu injizieren, um Zwischenoptimierungszust√§nde zu visualisieren, in der Hoffnung, dass sich Sch√∂nheit herausstellen w√ºrde. aber es stellte sich heraus, nicht Sch√∂nheit, etwas M√ºll. Wenn Sie interessiert sind, sehen Sie, wie es geht. Das Internet ist Beispiele f√ºr solche Injektions Codes √ºbers√§t sondern durch einfaches Kopieren sie nicht pa bieten , </font><font style="vertical-align: inherit;">weil Ersatz in enthaltene </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sklearn.manifold.t_sne</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> interner Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_gradient_descent</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und es je nach Ausf√ºhrung kann sehr unterschiedlich sein , </font><font style="vertical-align: inherit;">sowohl in der Signatur und auf der Behandlung von internen Variablen. Suchen Sie also einfach die Quellen in sich selbst, w√§hlen Sie dort Ihre Version der Funktion aus und f√ºgen Sie nur eine Zeile ein, die Ihrer </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eigenen </font><font style="vertical-align: inherit;">Variablen Zwischendumps hinzuf√ºgt: </font><font style="vertical-align: inherit;">position.append (p.copy ()) # Wir speichern die aktuelle Position.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und dann visualisieren wir wundersch√∂n, was wir als Ergebnis erhalten:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Injektionscode</font></font></b><div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> linalg
<span class="hljs-comment"># This list will contain the positions of the map points at every iteration.</span><font></font>
positions = []<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_gradient_descent</span>(<span class="hljs-params">objective, p0, it, n_iter,
                      n_iter_check=<span class="hljs-number">1</span>, n_iter_without_progress=<span class="hljs-number">300</span>,
                      momentum=<span class="hljs-number">0.8</span>, learning_rate=<span class="hljs-number">200.0</span>, min_gain=<span class="hljs-number">0.01</span>,
                      min_grad_norm=<span class="hljs-number">1e-7</span>, verbose=<span class="hljs-number">0</span>, args=None, kwargs=None</span>):</span>
    <span class="hljs-comment"># The documentation of this function can be found in scikit-learn's code.</span>
    <span class="hljs-keyword">if</span> args <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
        args = []<font></font>
    <span class="hljs-keyword">if</span> kwargs <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
        kwargs = {}<font></font>
<font></font>
    p = p0.copy().ravel()<font></font>
    update = np.zeros_like(p)<font></font>
    gains = np.ones_like(p)<font></font>
    error = np.finfo(np.float).max<font></font>
    best_error = np.finfo(np.float).max<font></font>
    best_iter = i = it<font></font>
<font></font>
    tic = time()<font></font>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(it, n_iter):<font></font>
        positions.append(p.copy()) <span class="hljs-comment"># We save the current position.</span><font></font>
        <font></font>
        check_convergence = (i + <span class="hljs-number">1</span>) % n_iter_check == <span class="hljs-number">0</span>
        <span class="hljs-comment"># only compute the error when needed</span>
        kwargs[<span class="hljs-string">'compute_error'</span>] = check_convergence <span class="hljs-keyword">or</span> i == n_iter - <span class="hljs-number">1</span><font></font>
<font></font>
        error, grad = objective(p, *args, **kwargs)<font></font>
        grad_norm = linalg.norm(grad)<font></font>
<font></font>
        inc = update * grad &lt; <span class="hljs-number">0.0</span><font></font>
        dec = np.invert(inc)<font></font>
        gains[inc] += <span class="hljs-number">0.2</span>
        gains[dec] *= <span class="hljs-number">0.8</span><font></font>
        np.clip(gains, min_gain, np.inf, out=gains)<font></font>
        grad *= gains<font></font>
        update = momentum * update - learning_rate * grad<font></font>
        p += update<font></font>
<font></font>
        <span class="hljs-keyword">if</span> check_convergence:<font></font>
            toc = time()<font></font>
            duration = toc - tic<font></font>
            tic = toc<font></font>
<font></font>
            <span class="hljs-keyword">if</span> verbose &gt;= <span class="hljs-number">2</span>:<font></font>
                print(<span class="hljs-string">"[t-SNE] Iteration %d: error = %.7f,"</span>
                      <span class="hljs-string">" gradient norm = %.7f"</span>
                      <span class="hljs-string">" (%s iterations in %0.3fs)"</span>
                      % (i + <span class="hljs-number">1</span>, error, grad_norm, n_iter_check, duration))<font></font>
<font></font>
            <span class="hljs-keyword">if</span> error &lt; best_error:<font></font>
                best_error = error<font></font>
                best_iter = i<font></font>
            <span class="hljs-keyword">elif</span> i - best_iter &gt; n_iter_without_progress:
                <span class="hljs-keyword">if</span> verbose &gt;= <span class="hljs-number">2</span>:<font></font>
                    print(<span class="hljs-string">"[t-SNE] Iteration %d: did not make any progress "</span>
                          <span class="hljs-string">"during the last %d episodes. Finished."</span>
                          % (i + <span class="hljs-number">1</span>, n_iter_without_progress))
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">if</span> grad_norm &lt;= min_grad_norm:
                <span class="hljs-keyword">if</span> verbose &gt;= <span class="hljs-number">2</span>:<font></font>
                    print(<span class="hljs-string">"[t-SNE] Iteration %d: gradient norm %f. Finished."</span>
                          % (i + <span class="hljs-number">1</span>, grad_norm))
                <span class="hljs-keyword">break</span><font></font>
<font></font>
    <span class="hljs-keyword">return</span> p, error, i<font></font>
<font></font>
manifold.t_sne._gradient_descent = _gradient_descent</code></pre></div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenden Sie das `` feste '' t-SNE an</font></font></b><div class="spoiler_text"><pre><code class="python hljs">tsne_representation = manifold.TSNE(random_state=<span class="hljs-number">17</span>).fit_transform(history)<font></font>
X_iter = np.dstack(position.reshape(<span class="hljs-number">-1</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> position <span class="hljs-keyword">in</span> positions)<font></font>
position_reshape = [position.reshape(<span class="hljs-number">-1</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> position <span class="hljs-keyword">in</span> positions]<font></font>
print(position_reshape[<span class="hljs-number">0</span>].shape)<font></font>
print(<span class="hljs-string">'[0] min'</span>, position_reshape[<span class="hljs-number">0</span>][:,<span class="hljs-number">0</span>].min(),<span class="hljs-string">'max'</span>, position_reshape[<span class="hljs-number">0</span>][:,<span class="hljs-number">0</span>].max())<font></font>
print(<span class="hljs-string">'[1] min'</span>, position_reshape[<span class="hljs-number">1</span>][:,<span class="hljs-number">0</span>].min(),<span class="hljs-string">'max'</span>, position_reshape[<span class="hljs-number">1</span>][:,<span class="hljs-number">0</span>].max())<font></font>
print(<span class="hljs-string">'[2] min'</span>, position_reshape[<span class="hljs-number">2</span>][:,<span class="hljs-number">0</span>].min(),<span class="hljs-string">'max'</span>, position_reshape[<span class="hljs-number">2</span>][:,<span class="hljs-number">0</span>].max())
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(41, 2) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[0] min -0.00018188123 max 0.00027207955 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[1] min -0.05136269 max 0.032607622 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[2] min -4.392309 max 7.9074526 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Werte tanzen in einem sehr weiten Bereich, daher werde ich sie vor dem Zeichnen skalieren. </font><font style="vertical-align: inherit;">Bei Zyklen geschieht dies alles langsam. </font><font style="vertical-align: inherit;">:(</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich skaliere</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time
<span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> MinMaxScaler<font></font>
minMaxScaler = MinMaxScaler()<font></font>
minMaxScaler.fit_transform(position_reshape[<span class="hljs-number">0</span>])<font></font>
position_reshape = [minMaxScaler.fit_transform(frame) <span class="hljs-keyword">for</span> frame <span class="hljs-keyword">in</span> position_reshape]<font></font>
position_reshape[<span class="hljs-number">0</span>].min(), position_reshape[<span class="hljs-number">0</span>].max()</code></pre></div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animieren</font></font></b><div class="spoiler_text"><pre><code class="python hljs">%%time<font></font>
<font></font>
<span class="hljs-keyword">from</span> matplotlib.animation <span class="hljs-keyword">import</span> FuncAnimation, PillowWriter
<span class="hljs-comment">#plt.style.use('seaborn-pastel')</span><font></font>
<font></font>
fig = plt.figure()<font></font>
<font></font>
ax = plt.axes(xlim=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), ylim=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<font></font>
line, = ax.plot([], [], lw=<span class="hljs-number">3</span>)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init</span>():</span><font></font>
    line.set_data([], [])<font></font>
    <span class="hljs-keyword">return</span> line,
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">animate</span>(<span class="hljs-params">i</span>):</span>
    x = position_reshape[i][:,<span class="hljs-number">0</span>]<font></font>
    y = position_reshape[i][:,<span class="hljs-number">1</span>]<font></font>
    line.set_data(x, y)<font></font>
    <span class="hljs-keyword">return</span> line,<font></font>
<font></font>
anim = FuncAnimation(fig, animate, init_func=init, frames=<span class="hljs-number">36</span>, interval=<span class="hljs-number">20</span>, blit=<span class="hljs-literal">True</span>, repeat_delay = <span class="hljs-number">1000</span>)<font></font>
anim.save(<span class="hljs-string">'images/animate_tsne_learning.gif'</span>, writer=PillowWriter(fps=<span class="hljs-number">5</span>))
</code></pre></div></div><br>
<img src="https://habrastorage.org/webt/lh/dq/g6/lhdqg6khzhplw6jtkei6y0s3pdu.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist lehrreich in Bezug auf F√§higkeiten, aber absolut nutzlos in dieser Aufgabe und h√§sslich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dazu verabschiede ich mich von dir. </font><font style="vertical-align: inherit;">Ich hoffe, dass die Idee, dass Sie selbst von knn etwas Neues und Interessantes sowie Code erhalten k√∂nnen, Ihnen auch dabei helfen wird, Spa√ü mit den Daten bei diesem intellektuellen Fest w√§hrend der Pest zu haben.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de496466/index.html">Jede ausreichend schnelle Lichtquelle hat eine rote Doppler-Verschiebung</a></li>
<li><a href="../de496472/index.html">10 interessante Repositories auf GitHub, n√ºtzlich f√ºr jeden Entwickler</a></li>
<li><a href="../de496476/index.html">Schieben Sie Windows Server mit Windows Server Core auf einen VPS mit geringem Stromverbrauch</a></li>
<li><a href="../de496480/index.html">Der Klang zuk√ºnftiger Stille</a></li>
<li><a href="../de496482/index.html">Die Entwicklung einer informierten F√ºhrung f√ºr das Teammanagement</a></li>
<li><a href="../de496486/index.html">Meinung: Spamhaus - Online-Zensur oder saubere Webk√§mpfer?</a></li>
<li><a href="../de496488/index.html">IaaS-Anbieter k√§mpfen gegen Angriffe auf das BGP-Protokoll</a></li>
<li><a href="../de496490/index.html">Wir untersuchen die Mediastreamer2 VoIP-Engine. Teil 7</a></li>
<li><a href="../de496492/index.html">Grundlegende LXD-Funktionen - Linux-Containersysteme</a></li>
<li><a href="../de496494/index.html">Wir spielen Musik von Mario √ºber den Systemlautsprecher</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>