<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏰 👨🏼‍💻 🦗 Kesan pertama konsep 📅 🚔 👩‍❤️‍💋‍👨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya memutuskan untuk berurusan dengan fitur - konsep C ++ 20 yang baru. 
 
 Konsep (atau konsep , seperti yang ditulis Wiki berbahasa Rusia) adalah f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kesan pertama konsep</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495396/"><img src="https://habrastorage.org/webt/qd/ja/kc/qdjakcxd4173w_juzv5fx3bf0_o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya memutuskan untuk berurusan dengan fitur - konsep C ++ 20 yang baru. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konsep</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (atau </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konsep</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , seperti yang ditulis Wiki berbahasa Rusia) adalah fitur yang sangat menarik dan bermanfaat yang telah lama kurang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada dasarnya, ini mengetik argumen templat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah utama templat sebelum C ++ 20 adalah Anda dapat mengganti apa pun di dalamnya, termasuk sesuatu yang tidak dirancang sama sekali. Yaitu, sistem templat sepenuhnya tidak diketik. Akibatnya, pesan kesalahan yang sangat panjang dan benar-benar tidak dapat dibaca terjadi ketika memberikan parameter yang salah ke templat. Mereka mencoba melawan ini dengan bantuan peretas bahasa yang berbeda, yang bahkan tidak ingin saya sebutkan (walaupun saya harus berurusan dengan).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Konsep dirancang untuk memperbaiki kesalahpahaman ini. </font><font style="vertical-align: inherit;">Mereka menambahkan sistem pengetikan ke template, dan ini sangat kuat. </font><font style="vertical-align: inherit;">Dan sekarang, setelah memahami fitur-fitur sistem ini, saya mulai mempelajari materi yang tersedia di Internet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terus terang, saya sedikit kaget :) C ++ adalah bahasa yang sudah rumit, tapi setidaknya ada alasan: itu terjadi. </font><font style="vertical-align: inherit;">Metaprogramming pada templat ditemukan, tidak diletakkan, ketika merancang bahasa. </font><font style="vertical-align: inherit;">Dan kemudian, ketika mengembangkan versi bahasa berikutnya, mereka dipaksa untuk beradaptasi dengan "penemuan" ini, karena banyak kode ditulis di dunia. </font><font style="vertical-align: inherit;">Konsep adalah peluang yang secara fundamental baru. </font><font style="vertical-align: inherit;">Dan, menurut saya, beberapa opacity sudah ada dalam implementasinya. </font><font style="vertical-align: inherit;">Mungkin ini merupakan konsekuensi dari kebutuhan untuk memperhitungkan sejumlah besar kemampuan yang diwarisi? </font><font style="vertical-align: inherit;">Mari kita coba mencari tahu ...</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informasi Umum</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Konsep adalah entitas bahasa baru berdasarkan sintaks templat. </font><font style="vertical-align: inherit;">Konsep memiliki nama, parameter, dan tubuh - predikat yang mengembalikan nilai konstanta (mis., Dihitung pada tahap kompilasi) tergantung pada parameter konsep. </font><font style="vertical-align: inherit;">Seperti ini:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> I&gt; 
<span class="hljs-keyword">concept</span> Even = I % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;  <font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> FourByte = <span class="hljs-keyword">sizeof</span>(T)==<span class="hljs-number">4</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara teknis, konsep sangat mirip dengan ekspresi template constexpr seperti bool:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> I&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> EvenX = I % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; <font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> FourByteX = <span class="hljs-keyword">sizeof</span>(T)==<span class="hljs-number">4</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda bahkan dapat menggunakan konsep dalam ekspresi umum:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b1 = Even&lt;<span class="hljs-number">2</span>&gt;; </code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ide utama dari konsep ini adalah bahwa mereka dapat digunakan sebagai ganti dari nama ketik atau kata kunci kelas dalam template. </font><font style="vertical-align: inherit;">Seperti metatypes ("types for types"). </font><font style="vertical-align: inherit;">Jadi, pengetikan statis dimasukkan ke dalam templat.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;FourByte T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp; t)</span> </span>{}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, jika kita menggunakan int sebagai parameter templat, maka kode di sebagian besar kasus akan dikompilasi; </font><font style="vertical-align: inherit;">dan jika dobel, maka pesan kesalahan pendek dan dapat dimengerti akan dikeluarkan. </font><font style="vertical-align: inherit;">Pengetikan templat yang sederhana dan jelas, sejauh ini semuanya baik-baik saja.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membutuhkan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah kata kunci C ++ 20 “kontekstual” baru dengan tujuan ganda: memerlukan klausa dan memerlukan ekspresi. </font><font style="vertical-align: inherit;">Seperti yang akan ditampilkan nanti, penghematan kata kunci yang aneh ini menyebabkan beberapa kebingungan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membutuhkan ekspresi</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, pertimbangkan membutuhkan ekspresi. </font><font style="vertical-align: inherit;">Idenya cukup bagus: kata ini memiliki blok di kurung kurawal, kode di dalamnya dievaluasi untuk kompilasi. </font><font style="vertical-align: inherit;">Benar, kode di sana tidak boleh ditulis </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam C ++, tetapi dalam bahasa khusus, dekat dengan C ++, tetapi memiliki karakteristik sendiri</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ini adalah keanehan pertama, sangat mungkin untuk membuat hanya kode C ++). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kode itu benar - memerlukan ekspresi mengembalikan true, jika tidak, false. </font><font style="vertical-align: inherit;">Kode itu sendiri, tentu saja, tidak pernah masuk ke dalam pembuatan kode, seperti halnya ekspresi dalam sizeof atau decltype. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sayangnya, kata tersebut kontekstual dan hanya berfungsi di dalam templat, yaitu di luar templat, ini tidak dapat dikompilasi:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b = <span class="hljs-keyword">requires</span> { <span class="hljs-number">3.14</span> &gt;&gt; <span class="hljs-number">1</span>; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan dalam template - silakan:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> Shiftable = <span class="hljs-keyword">requires</span>(T i) { i&gt;&gt;<span class="hljs-number">1</span>; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan itu akan berhasil:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b1 = Shiftable&lt;<span class="hljs-keyword">int</span>&gt;; <span class="hljs-comment">// true</span>
<span class="hljs-keyword">bool</span> b2 = Shiftable&lt;<span class="hljs-keyword">double</span>&gt;; <span class="hljs-comment">// false</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penggunaan utama ekspresi membutuhkan adalah penciptaan konsep. </font><font style="vertical-align: inherit;">Misalnya, ini adalah bagaimana Anda bisa memeriksa keberadaan bidang dan metode dalam suatu tipe. </font><font style="vertical-align: inherit;">Kasus yang sangat populer.</font></font><br>
<br>
<pre><code class="plaintext hljs">template &lt;typename T&gt;<font></font>
concept Machine = <font></font>
  requires(T m) {  //   `m` ,   Machine<font></font>
	m.start();     //    `m.start()` <font></font>
	m.stop();      //   `m.stop()`<font></font>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Omong-omong, semua variabel yang mungkin diperlukan dalam kode yang diuji (tidak hanya parameter templat) harus dinyatakan dalam tanda kurung membutuhkan ekspresi. </font><font style="vertical-align: inherit;">Untuk beberapa alasan, menyatakan suatu variabel sama sekali tidak mungkin.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketik memeriksa di dalam membutuhkan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sinilah perbedaan antara membutuhkan kode dan standar C ++ dimulai. </font><font style="vertical-align: inherit;">Untuk memeriksa jenis yang dikembalikan, sintaks khusus digunakan: objek diambil dalam kurung keriting, panah ditempatkan, dan setelah itu, sebuah konsep ditulis bahwa jenis harus memenuhi. </font><font style="vertical-align: inherit;">Selain itu, penggunaan tipe langsung tidak diperbolehkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Periksa bahwa kembalinya fungsi dapat dikonversi ke int:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(T v, <span class="hljs-keyword">int</span> i) {<font></font>
  { v.f(i) } -&gt; <span class="hljs-built_in">std</span>::convertible_to&lt;<span class="hljs-keyword">int</span>&gt;;<font></font>
}  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Periksa apakah fungsi pengembalian tepat int:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(T v, <span class="hljs-keyword">int</span> i) {<font></font>
  { v.f(i) } -&gt; <span class="hljs-built_in">std</span>::same_as&lt;<span class="hljs-keyword">int</span>&gt;; <font></font>
}  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(std :: same_as dan std :: convertible_to adalah konsep dari pustaka standar). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda tidak menyertakan ekspresi yang tipenya diperiksa dalam kurung, kompiler tidak mengerti apa yang mereka inginkan darinya dan menafsirkan seluruh string sebagai ekspresi tunggal yang perlu diperiksa untuk kompilasi.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membutuhkan di dalam membutuhkan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kata kunci yang membutuhkan memiliki arti khusus di dalam membutuhkan ekspresi. </font><font style="vertical-align: inherit;">Nested membutuhkan-ekspresi (sudah tanpa kurung kurawal) diperiksa bukan untuk kompilasi, tetapi untuk kesetaraan benar atau salah. </font><font style="vertical-align: inherit;">Jika ungkapan seperti itu ternyata salah, maka ungkapan terlampir segera ternyata salah (dan analisis kompilasi lebih lanjut terganggu). </font><font style="vertical-align: inherit;">Bentuk umum:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> { <font></font>
  expression;         <span class="hljs-comment">// expression is valid</span>
  <span class="hljs-keyword">requires</span> predicate; <span class="hljs-comment">// predicate is true</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai predikat, misalnya, konsep atau tipe karakter yang didefinisikan sebelumnya dapat digunakan. </font><font style="vertical-align: inherit;">Contoh:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(Iter it) {
  <span class="hljs-comment">//     (   Iter   *  ++)</span><font></font>
  *it++;<font></font>
 <font></font>
  <span class="hljs-comment">//    -  </span>
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::convertible_to&lt;<span class="hljs-keyword">decltype</span>(*it++), <span class="hljs-keyword">typename</span> Iter::value_type&gt;;<font></font>
 <font></font>
  <span class="hljs-comment">//    -  </span>
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::is_convertible_v&lt;<span class="hljs-keyword">decltype</span>(*it++), <span class="hljs-keyword">typename</span> Iter::value_type&gt;;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada saat yang sama, ekspresi-kebutuhan bersarang diizinkan dengan kode dalam kurung keriting, yang diperiksa validitasnya. </font><font style="vertical-align: inherit;">Namun, jika Anda hanya menulis satu ekspresi-kebutuhan di dalam yang lain, maka ekspresi bersarang (semuanya secara keseluruhan, termasuk kata kunci yang diperlukan bersarang) hanya akan diperiksa validitasnya:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> (T v) { 
  <span class="hljs-keyword">requires</span> (<span class="hljs-keyword">typename</span> T::value_type x) { ++x; }; <span class="hljs-comment">//     , </span>
												<span class="hljs-comment">//     !</span>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oleh karena itu, bentuk aneh dengan kebutuhan ganda muncul:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> (T v) { 
  <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span> <span class="hljs-params">(<span class="hljs-keyword">typename</span> T::value_type x)</span> </span>{ ++x; }; <span class="hljs-comment">//       "++x"</span>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut ini adalah urutan melarikan diri yang menyenangkan dari "membutuhkan". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ngomong-ngomong, kombinasi keduanya diperlukan adalah klausa waktu ini (lihat di bawah) dan ekspresi:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span><span class="hljs-params">(T x, T y)</span> </span>{ <span class="hljs-keyword">bool</span>(x &lt; y); }
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">equivalent</span><span class="hljs-params">(T <span class="hljs-keyword">const</span>&amp; x, T <span class="hljs-keyword">const</span>&amp; y)</span>
</span>{
  <span class="hljs-keyword">return</span> !(x &lt; y) &amp;&amp; !(y &lt; x);<font></font>
};</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membutuhkan klausa</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita beralih ke penggunaan kata lain yang diperlukan - untuk menyatakan batasan jenis templat. </font><font style="vertical-align: inherit;">Ini adalah alternatif untuk menggunakan nama konsep alih-alih nama ketik. </font><font style="vertical-align: inherit;">Dalam contoh berikut, ketiga metode ini setara:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  require</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cont&gt;
	<span class="hljs-keyword">requires</span> Sortable&lt;Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span></span>;<font></font>
<font></font>
<span class="hljs-comment">//   require (  )</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span> <span class="hljs-keyword">requires</span> Sortable&lt;Cont&gt;</span>;<font></font>
<font></font>
<span class="hljs-comment">//    typename</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;Sortable Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span>  </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deklarasi yang mewajibkan dapat menggunakan beberapa predikat yang dikombinasikan oleh operator logis.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_standard_layout_v&lt;T&gt; &amp;&amp; is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; <font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s;<font></font>
 <font></font>
  fun(<span class="hljs-number">1</span>);  <span class="hljs-comment">// ok</span>
  fun(s);  <span class="hljs-comment">// compiler error</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, balikkan salah satu syarat, saat kesalahan kompilasi terjadi:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_standard_layout_v&lt;T&gt; &amp;&amp; !is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut adalah contoh yang tidak akan dikompilasi</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> !<span class="hljs-function">is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>;	</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alasan untuk ini adalah ambiguitas yang muncul ketika mengurai beberapa ekspresi. </font><font style="vertical-align: inherit;">Misalnya, dalam templat seperti itu:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; 
  <span class="hljs-keyword">requires</span> (<span class="hljs-keyword">bool</span>)&amp;<span class="hljs-function">T::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tidak jelas apa atribut yang tidak ditandatangani - operator atau prototipe fungsi foo (). </font><font style="vertical-align: inherit;">Oleh karena itu, pengembang memutuskan bahwa tanpa tanda kurung hanya petunjuk literal benar atau salah, nama bidang tipe bool dari nilai formulir, nilai, T :: value, ns :: trait :: value, dapat digunakan sebagai argumen yang membutuhkan klausa. Konsep nama dari tipe Konsep dan membutuhkan ekspresi. </font><font style="vertical-align: inherit;">Segala sesuatu yang lain harus ditutup dalam tanda kurung:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> (!is_trivial_v&lt;T&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang tentang fitur predikat di membutuhkan klausa</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan contoh lain.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; 
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh ini, mengharuskan menggunakan sifat yang bergantung pada tipe value_type bersarang. </font><font style="vertical-align: inherit;">Tidak diketahui sebelumnya apakah tipe arbitrer memiliki tipe bersarang yang dapat diteruskan ke templat. </font><font style="vertical-align: inherit;">Jika Anda melewatkan, misalnya, tipe int sederhana untuk templat seperti itu, akan ada kesalahan kompilasi, namun, jika kami memiliki dua spesialisasi templat, maka tidak akan ada kesalahan; </font><font style="vertical-align: inherit;">hanya spesialisasi lain yang akan dipilih.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; 
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"1"</span>; } <font></font>
 <font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"2"</span>; } <font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
  fun(<span class="hljs-number">1</span>);  <span class="hljs-comment">// displays: "2"</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, spesialisasi tidak hanya dibuang ketika prasyarat klausa klausa mengembalikan false, tetapi juga ketika ternyata salah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tanda kurung di sekitar predikat adalah pengingat penting bahwa dalam membutuhkan klausa, kebalikan dari predikat bukanlah kebalikan dari predikat itu sendiri. </font><font style="vertical-align: inherit;">Begitu,</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
berarti sifat tersebut benar dan mengembalikan true. </font><font style="vertical-align: inherit;">Di mana</font></font><br>
<br>
<pre><code class="cpp hljs">!is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
akan berarti "sifatnya benar dan mengembalikan salah" </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pembalikan logis sebenarnya dari predikat pertama BUKAN ("sifat itu benar dan mengembalikan benar") == "sifat itu TIDAK BENAR atau mengembalikan salah" - ini dicapai dengan cara yang sedikit lebih kompleks - melalui definisi eksplisit dari konsep:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> value_type_valid_and_trivial <font></font>
  = is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;; <font></font>
 <font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> (!value_type_valid_and_trivial&lt;T&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konjungsi dan Disjungsi</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Operator konjungsi dan disjungsi logis terlihat seperti biasa, tetapi sebenarnya bekerja sedikit berbeda dari pada C ++ normal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan dua cuplikan kode yang sangat mirip. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang pertama adalah predikat tanpa tanda kurung:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;<font></font>
		|| <span class="hljs-function"><span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> U::value_type&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v, U u)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang kedua adalah dengan tanda kurung:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-keyword">requires</span> (<span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;<font></font>
		 || <span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> U::value_type&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v, U u)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perbedaannya hanya pada tanda kurung. </font><font style="vertical-align: inherit;">Tetapi karena ini, dalam templat kedua, tidak ada dua kendala yang disatukan oleh "keharusan-klausa", tetapi satu disatukan oleh OR logis atau biasa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perbedaan ini adalah sebagai berikut. </font><font style="vertical-align: inherit;">Pertimbangkan kodenya</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::optional&lt;<span class="hljs-keyword">int</span>&gt; oi {};
<span class="hljs-keyword">int</span> i {};<font></font>
fun(i, oi);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini templat dipakai oleh tipe int dan std :: opsional. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus pertama, tipe int :: value_type tidak valid, dan batasan pertama karenanya tidak dipenuhi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi tipe opsional :: value_type valid, sifat kedua mengembalikan true, dan karena ada operator ATAU di antara kendala, keseluruhan predikat puas secara keseluruhan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus kedua, ini adalah ekspresi tunggal yang berisi jenis yang tidak valid, karena itu tidak valid secara umum dan predikat tidak puas. </font><font style="vertical-align: inherit;">Jadi kurung sederhana secara tidak kasat mata mengubah makna dari apa yang terjadi.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulannya</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, tidak semua fitur konsep ditampilkan di sini. Saya hanya tidak melangkah lebih jauh. Tetapi sebagai kesan pertama - ide yang sangat menarik dan implementasi bingung yang agak aneh. Dan sintaks yang lucu dengan pengulangan membutuhkan, yang benar-benar membingungkan. Apakah benar ada begitu sedikit kata dalam bahasa Inggris sehingga Anda harus menggunakan satu kata untuk tujuan yang sama sekali berbeda? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ide dengan kode yang dikompilasi pasti bagus. Bahkan agak mirip dengan "quasi-quoting" di makro sintaks. Tetapi apakah itu layak mencampur sintaks khusus untuk memeriksa tipe kembali? IMHO, untuk ini hanya perlu membuat kata kunci terpisah.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pencampuran implisit dari konsep "benar / salah" dan "mengkompilasi / tidak mengkompilasi" dalam satu tumpukan, dan sebagai hasilnya, lelucon dengan tanda kurung juga salah. </font><font style="vertical-align: inherit;">Ini adalah konsep yang berbeda, dan mereka harus ada secara ketat dalam konteks yang berbeda (meskipun saya mengerti dari mana asalnya - dari aturan SFINAE, di mana kode yang tidak dikompilasi hanya diam-diam mengeluarkan spesialisasi dari pertimbangan). </font><font style="vertical-align: inherit;">Tetapi jika tujuan dari konsep ini adalah untuk membuat kode sejelas mungkin, apakah layak untuk menyeret semua hal tersirat ini ke fitur-fitur baru? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ini ditulis terutama berdasarkan </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akrzemi1.wordpress.com/2020/01/29/requires-expression </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akrzemi1.wordpress.com/2020/03/26/requires-clause</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
(ada lebih banyak contoh dan fitur menarik) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dengan tambahan saya dari sumber lain, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
semua contoh dapat diperiksa</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wandbox.org</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id495380/index.html">Firewall Mesir Hebat</a></li>
<li><a href="../id495384/index.html">Pengalaman magang saya di Microsoft Redmond dan mendapatkan tawaran</a></li>
<li><a href="../id495388/index.html">Acara televisi 1970-an yang menjadi nenek moyang eSports</a></li>
<li><a href="../id495390/index.html">STM32CubeMonitor patut dicoba</a></li>
<li><a href="../id495392/index.html">Cara mencari bug di ujung depan: 4 tahap utama</a></li>
<li><a href="../id495398/index.html">Ro.Ri.Re</a></li>
<li><a href="../id495400/index.html">Bekerja dengan kartu SD melalui antarmuka SPI. Implementasi VHDL</a></li>
<li><a href="../id495402/index.html">Tahun lalu, kami akhirnya memotret lubang hitam. Sekarang apa?</a></li>
<li><a href="../id495404/index.html">Apakah saham melorot menjanjikan? Mari kita analisa dengan python</a></li>
<li><a href="../id495408/index.html"># 02 - Dan seluruh byte tidak cukup ... | Salib perubahan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>