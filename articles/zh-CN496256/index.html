<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗳️ 🤞🏿 📏 R上的机器学习：预测分析的专家技术 🔹 📪 🙅🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您好，habrozhiteli！ R语言提供了一组功能强大的机器学习方法，可让您快速进行数据的重要分析。这本书是一本指南，将有助于应用机器学习方法来解决日常问题。 Brett Lanz将教您数据分析，预测和数据可视化所需的一切。在这里，您将找到有关新的和改进的库的信息，有关机器学习和偏见问题的道德方...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>R上的机器学习：预测分析的专家技术</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/496256/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/lf/4u/ao/lf4uaojxjnbk8d6no9t-3j-v7ww.jpeg" align="left" alt="图片"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您好，habrozhiteli！ R语言提供了一组功能强大的机器学习方法，可让您快速进行数据的重要分析。这本书是一本指南，将有助于应用机器学习方法来解决日常问题。 Brett Lanz将教您数据分析，预测和数据可视化所需的一切。在这里，您将找到有关新的和改进的库的信息，有关机器学习和偏见问题的道德方面的提示，以及深入的培训。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本书-机器学习的基础知识和计算机培训的功能实例。</font><font style="vertical-align: inherit;">-通过语言R准备用于机器学习的数据。-结果重要性的分类。</font><font style="vertical-align: inherit;">-使用决策树，规则和参考向量来预测事件。</font><font style="vertical-align: inherit;">-使用回归方法预测数值数据和评估财务数据。</font><font style="vertical-align: inherit;">-使用神经网络对复杂过程进行建模是深度学习的基础。</font><font style="vertical-align: inherit;">-评估模型并改善其性能。</font><font style="vertical-align: inherit;">-处理大数据的最新技术，尤其是R 3.6，Spark，H2O和TensorFlow。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这本书是给谁的？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该书适用于希望在特定区域使用数据的人。</font><font style="vertical-align: inherit;">您可能已经对机器学习有所了解，但是您从未使用过R语言。</font><font style="vertical-align: inherit;">或者，相反，您对R有所了解，但几乎不了解机器学习。</font><font style="vertical-align: inherit;">无论如何，这本书都会帮助您快速入门。</font><font style="vertical-align: inherit;">刷新一下数学和程序设计的基本概念将很有用，但是不需要任何先验经验。</font><font style="vertical-align: inherit;">您所需要的只是学习的欲望。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您将在出版物中读到什么</font></font></b><div class="spoiler_text"> 1 «   »    ,          ,      ,   ,     .<br>
<br>
 2 «    »            R.         ,   ,    .<br>
<br>
 3 « :      »      ,           :     .<br>
<br>
 4 « :      »     ,       .    ,      .<br>
<br>
 5 «  :       »    ,     ,    .      ,    .<br>
<br>
 6 «  :  »     ,    .        ,     ,     .<br>
<br>
 7 « “ ”:      »   ,     .        ,    ,    .<br>
<br>
 8 « :       »  ,    ,      .   -   ,         ,   ,      .<br>
<br>
 9 «  :   k-»      .         -.<br>
<br>
 10 «  »    ,                  .<br>
<br>
 11 «  »  ,  ,        .                ,         .<br>
<br>
 12 «   »    :        R.  ,        ,       R.<br>
</div></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示例：使用神经网络对混凝土强度进行建模</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在土木工程领域，对建筑材料的有效性进行准确评估非常重要。</font><font style="vertical-align: inherit;">这些评估对于制定安全规则以管理建筑物，桥梁和道路建设中的材料使用是必要的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特别感兴趣的是混凝土强度的评估。</font><font style="vertical-align: inherit;">混凝土几乎用于任何建筑中，混凝土的性能特征有很大不同，因为它由在复合物中相互作用的大量成分组成。</font><font style="vertical-align: inherit;">结果，很难确切地说出成品的强度。</font><font style="vertical-align: inherit;">考虑到原材料的组成，可以确定混凝土强度的模型可以为建筑工地提供更高的安全性。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">步骤1.数据收集</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于此分析，我们将使用叶正成提供给UCI机器学习存储库（http://archive.ics.uci.edu/ml）的具体抗压强度数据。</font><font style="vertical-align: inherit;">由于叶爱成（Ya-Cheng Ye）成功地使用神经网络对该数据进行建模，因此我们将通过在R中应用神经网络的简单模型来尝试重现他的工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从现场来看，该数据集包含1030条有关不同品牌混凝土的记录，这些记录具有八个特征，这些特征描述了混凝土配合料的成分。</font><font style="vertical-align: inherit;">据信这些特性影响最终的抗压强度。</font><font style="vertical-align: inherit;">其中包括：水泥，水，各种添加剂，大大小小的集料（如碎石和沙粒）的量（以每立方米为单位），以及制成时间（以天为单位）。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要运行此示例，请下载concrete.csv文件并将其保存在R工​​作目录中。</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">步骤2.研究和数据准备</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与往常一样，我们通过使用read.csv（）函数将数据加载到R对象中来开始分析，并确保结果对应于预期的结构：</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete &lt;- read.csv(<span class="hljs-string">"concrete.csv"</span>)<font></font>
&gt; str(concrete)<font></font>
<span class="hljs-string">'data.frame'</span>:        <span class="hljs-number">1030</span> obs. of <span class="hljs-number">9</span> variables:<font></font>
$ cement       : num <span class="hljs-number">141</span> <span class="hljs-number">169</span> <span class="hljs-number">250</span> <span class="hljs-number">266</span> <span class="hljs-number">155</span> ...<font></font>
$ slag            : num <span class="hljs-number">212</span> <span class="hljs-number">42.2</span> <span class="hljs-number">0</span> <span class="hljs-number">114</span> <span class="hljs-number">183.4</span> ...<font></font>
$ ash             : num <span class="hljs-number">0</span> <span class="hljs-number">124.3</span> <span class="hljs-number">95.7</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> ...<font></font>
$ water          : num <span class="hljs-number">204</span> <span class="hljs-number">158</span> <span class="hljs-number">187</span> <span class="hljs-number">228</span> <span class="hljs-number">193</span> ...<font></font>
$ superplastic : num <span class="hljs-number">0</span> <span class="hljs-number">10.8</span> <span class="hljs-number">5.5</span> <span class="hljs-number">0</span> <span class="hljs-number">9.1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">6.4</span> <span class="hljs-number">0</span> <span class="hljs-number">9</span> ...<font></font>
$ coarseagg    : num <span class="hljs-number">972</span> <span class="hljs-number">1081</span> <span class="hljs-number">957</span> <span class="hljs-number">932</span> <span class="hljs-number">1047</span> ...<font></font>
$ fineagg        : num <span class="hljs-number">748</span> <span class="hljs-number">796</span> <span class="hljs-number">861</span> <span class="hljs-number">670</span> <span class="hljs-number">697</span> ...<font></font>
$ age             : <span class="hljs-keyword">int</span> <span class="hljs-number">28</span> <span class="hljs-number">14</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">90</span> <span class="hljs-number">7</span> <span class="hljs-number">56</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> ...<font></font>
$ strength      : num <span class="hljs-number">29.9</span> <span class="hljs-number">23.5</span> <span class="hljs-number">29.2</span> <span class="hljs-number">45.9</span> <span class="hljs-number">18.3</span> ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数据帧中的9个变量对应于8个特征和一个预期结果，但是显然存在问题。</font><font style="vertical-align: inherit;">当输入数据缩放到以0为中心的狭窄范围时，神经网络效果最好，在这里我们看到的值在0到1000以上的范围内。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，解决此问题的方法是使用归一化或标准化功能缩放数据。如果数据分布对应于钟形曲线（正态分布，请参阅第2章），则可以使用内置的scale（）函数使用标准化。如果数据分布接近均匀或与正常分布非常不同，则将归一化到0到1的范围可能更合适，在这种情况下，我们将使用后者。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第3章中，我们创建了自己的normalize（）函数：</font></font><br>
<br>
<pre><code class="java hljs">&gt; normalize &lt;- function(x) {
       <span class="hljs-keyword">return</span>((x - min(x)) / (max(x) — min(x)))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
执行此代码后，您可以使用lapply（）函数将normalize（）函数应用于所选数据帧的所有列：</font></font><br>
<br>
<code>&gt; concrete_norm &lt;- as.data.frame(lapply(concrete, normalize))</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要验证规范化是否有效，您可以检查strength属性的最小值和最大值分别为0和1：</font></font><br>
<br>
<pre><code class="java hljs">&gt; summary(concrete_norm$strength)<font></font>
       Min.     <span class="hljs-number">1</span>st Qu.         Median     Mean      <span class="hljs-number">3</span>rd Qu.      Max.
   <span class="hljs-number">0.0000</span>     <span class="hljs-number">0.2664</span>         <span class="hljs-number">0.4001</span>  <span class="hljs-number">0.4172</span>      <span class="hljs-number">0.5457</span>   <span class="hljs-number">1.0000</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了比较：此属性的初始最小值和最大值分别为2.33和82.60：</font></font><br>
<br>
<pre><code class="java hljs">&gt; summary(concrete$strength)<font></font>
     Min.       <span class="hljs-number">1</span>st Qu.     Median       Mean      <span class="hljs-number">3</span>rd Qu.       Max.
    <span class="hljs-number">2.33</span>         <span class="hljs-number">23.71</span>       <span class="hljs-number">34.44</span>      <span class="hljs-number">35.82</span>        <span class="hljs-number">46.14</span>      <span class="hljs-number">82.60</span></code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在训练模型之前应用于数据的任何转换应随后以相反顺序应用，以将属性转换回原始单位。</font><font style="vertical-align: inherit;">为了便于扩展，建议保存源数据，或者至少保存源数据统计信息的摘要。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
按照Ye在原始文章中描述的场景，我们将数据分为一个训练集（包括所有示例的75％）和一个测试集（包括25％）。</font><font style="vertical-align: inherit;">所使用的CSV文件是以随机顺序排序的，因此我们只能将其分为两部分：</font><font style="vertical-align: inherit;">
我们将使用训练数据集构建神经网络，并使用测试数据集来评估模型对未来结果的概括程度。</font><font style="vertical-align: inherit;">由于神经网络很容易进入重新训练状态，因此这一步骤非常重要。</font></font><br>
<br>
<code>&gt; concrete_train &lt;- concrete_norm[1:773, ]<br>
&gt; concrete_test &lt;- concrete_norm[774:1030, ]</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">步骤3.在数据上训练模型</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了模拟混凝土生产中使用的成分与成品强度之间的关系，我们将建立一个多层直接分布神经网络。由Stefan Fritsch和Frauke Guenther开发的Neuronet软件包提供了此类网络的标准且易于使用的实现。该软件包还包括用于构建网络拓扑的功能。实现神经网络是获取有关神经网络的其他信息的好方法，尽管这并不意味着它也不能用于实际工作-正如您很快就会看到的那样，它是一个功能强大的工具。</font></font><br>
<br>
<blockquote> R    ,       ,        .  nnet      R,  , ,      .       ,      .    —  RSNNS,       ,     ,     .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于神经网络软件包不包含在基本R中，因此您需要通过键入install.packages（“神经网络”）进行安装，并使用库（神经网络）命令进行下载。</font><font style="vertical-align: inherit;">程序包中的Neuronet（）函数可用于使用以下语法在数值预测中训练神经网络。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">神经网络语法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用Neuronet包中的Neuronet（）函数</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
构建模型：</font></font><br>
<br>
<pre><code class="java hljs">m &lt;- neuralnet(target ~ predictors, data = mydata,<font></font>
                       hidden = <span class="hljs-number">1</span>, act.fct = <span class="hljs-string">"logistic"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•目标-将通过对mydata数据框进行训练而建立的模型；</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•预测变量-R公式，用于从mydata数据帧中确定要用于预测的特征；</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•数据-目标和预测变量所属的数据帧；</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•hidden-隐藏层中的神经元数量（默认为1）。注意：为了描述几个隐藏层，使用了一个整数向量，例如c（2，2）; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•act.fct-激活功能：“物流”或“ tanh”。注意：也可以使用任何其他微分功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该函数返回可用于预测的神经网络对象。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预测：</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
p &lt;-计算（m，测试）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•m-使用Neuronet（）函数训练的模型；</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•测试-包含测试数据的数据帧，该数据具有与用于构造分类器的训练数据相同的特征。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该函数返回一个包含两个组件的列表：$神经元，用于存储每个网络层的神经元;以及$ net.result，其中存储使用此模型预测的值。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例子：</font></font></h4><br>
<br>
<pre><code class="java hljs">concrete_model &lt;- neuralnet(strength ~ cement + slag + ash,<font></font>
      data = concrete, hidden = c(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), act.fct = <span class="hljs-string">"tanh"</span>)<font></font>
model_results &lt;- compute(concrete_model, concrete_data)<font></font>
strength_predictions &lt;- model_results$net.result</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们开始训练带有默认参数的最简单的多层直接分销网络，该网络只有一个隐藏节点：</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete_model &lt;- neuralnet(strength ~ cement + slag<font></font>
         + ash + water + superplastic + coarseagg + fineagg + age,<font></font>
         data = concrete_train)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，如图所示。</font><font style="vertical-align: inherit;">7.11，您可以使用plot（）函数可视化网络拓扑，并将结果模型对象传递给它：</font></font><br>
<br>
<code>&gt; plot(concrete_model)</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mt/qh/og/mtqhogfq-pcptln4uzbl9ofb8po.png" alt="图片"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此简单模型中，八个要素中的每个要素都有一个输入节点，然后有一个隐藏节点和一个输出节点，这提供了混凝土强度的预测。</font><font style="vertical-align: inherit;">该图还显示了每个连接的权重以及为标记有数字1的节点指示的偏移量值。偏移量值是一个数字常数，可让您向上或向下移动指定节点中的值，就像线性方程式中的移位一样。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有一个隐藏节点的神经网络可以视为第6章讨论的线性回归模型的“表亲”。输入节点和隐藏节点之间的权重类似于beta系数，而偏移权重就像一个平移。</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在图的底部，显示了训练步骤的数量和误差的大小-总均方误差（平方误差总和，SSE），正如预期的那样，是预测值与实际值之间平方差的总和。</font><font style="vertical-align: inherit;">SSE越小，模型与训练数据的匹配越准确，这表明了这些数据的有效性，但是对于该模型如何处理未知数据却知之甚少。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">步骤4.评估模型的有效性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
网络拓扑图为研究神经网络的“黑匣子”提供了机会，但它并未提供太多有关模型与未来数据的匹配程度的信息。要生成关于测试数据集的预测，可以使用compute（）</font></font><br>
<br>
<code>&gt; model_results &lt;- compute(concrete_model, concrete_test[1:8])</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
函数</font><font style="vertical-align: inherit;">：</font><font style="vertical-align: inherit;">compute（）函数的工作方式与我们到目前为止使用的predict（）函数略有不同。它返回一个由两个部分组成的列表：$神经元，用于存储每个网络层的神经元;以及$ net.result，用于存储预测值。我们需要的是$ net.result：</font></font><br>
<br>
<code>&gt; predicted_strength &lt;- model_results$net.result</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于我们需要进行数值预测而不是分类，因此不能使用不一致矩阵来验证模型的准确性。</font><font style="vertical-align: inherit;">我们测量混凝土强度的预测值与真实值之间的相关性。</font><font style="vertical-align: inherit;">如果预测值和实际值之间有很强的相关性，那么该模型可能对确定混凝土的强度很有用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我提醒您，为了获得两个数字向量之间的相关性，使用了cor（）函数：</font></font><br>
<br>
<pre><code class="java hljs">&gt; cor(predicted_strength, concrete_test$strength)<font></font>
                    [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.8064655576</span></code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您的结果与我们的结果不同，请不要惊慌。</font><font style="vertical-align: inherit;">由于神经网络开始使用随机权重，因此本书中提出的预测对于不同的模型可能会有所不同。</font><font style="vertical-align: inherit;">如果要精确匹配结果，请在开始构建神经网络之前尝试使用set.seed（12345）命令。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果相关性接近于1，则表明两个变量之间的线性关系很强。</font><font style="vertical-align: inherit;">因此，大约为0.806的相关性表示相当强的关系。</font><font style="vertical-align: inherit;">这意味着即使只有一个隐藏节点，该模型也可以很好地工作。</font><font style="vertical-align: inherit;">假设我们只使用一个隐藏节点，则可能会提高模型的效率，我们将尝试这样做。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">步骤5.提高模型效率</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于具有更复杂拓扑的网络能够研究更复杂的概念，因此让我们看看将隐藏节点的数量增加到五个会发生什么。</font><font style="vertical-align: inherit;">我们将像以前一样使用Neuronet（）函数，但是添加hidden = 5参数：</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete_model2 &lt;- neuralnet(strength ~ cement + slag +<font></font>
                                               ash + water + superplastic +<font></font>
                                               coarseagg + fineagg + age,<font></font>
                                               data = concrete_train, hidden = <span class="hljs-number">5</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再次构建网络图（图7.12）后，我们将看到连接数量急剧增加。这如何影响效率？</font></font><br>
<br>
<code>&gt; plot(concrete_model2)</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，由此产生的误差（再次以SSE衡量）从以前的模型中的5.08降低到1.63。另外，训练阶段的数量从4882增加到86,849-考虑到模型的复杂程度，这不足为奇。网络越复杂，就需要更多的迭代来找到最佳权重。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
应用相同的步骤将预测值与真实值进行比较，我们得到约0.92的相关性，这与具有一个隐藏节点的网络的先前结果0.80相比要好得多：</font></font><br>
<br>
<pre><code class="java hljs">&gt; model_results2 &lt;- compute(concrete_model2, concrete_test[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>])<font></font>
&gt; predicted_strength2 &lt;- model_results2$net.result<font></font>
&gt; cor(predicted_strength2, concrete_test$strength)<font></font>
                  [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.9244533426</span></code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/x2/57/55/x25755f5wjbx5meuttyzyv0fczi.png" alt="图片"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管有重大改进，但您甚至可以进一步提高模型的有效性。特别是可以引入其他隐藏层并更改网络激活功能。通过进行这些更改，我们为构建简单的深度神经网络奠定了基础。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
激活功能的选择对于深度学习非常重要。特定学习任务的最佳功能通常是通过实验找到的，然后被机器学习研究人员广泛使用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近，激活功能（称为蒸馏功能或整流器）由于在诸如图像识别等复杂任务中的成功应用而变得非常流行。将整流器用作激活函数的神经网络节点称为整流线性单元（ReLU）。如图所示。在图7.13中，整流器类型激活函数的描述方式是：如果x大于或等于0，则返回x，否则返回0。此函数的重要性在于，一方面，它是非线性的，另一方面，它具有简单的数学属性，使其在计算上便宜并且对于梯度下降非常有效。不幸的是，对于x = 0，未定义整流器导数，因此，整流器不能与Neuronet（）函数结合使用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
相反，您可以使用称为softplus或SmoothReLU的平滑ReLU近似值，这是定义为log（1 + ex）的激活函数。</font><font style="vertical-align: inherit;">如图所示。</font><font style="vertical-align: inherit;">7.13，对于x小于0的值，softplus函数接近于零，对于大于0的x近似等于x。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/k9/us/lu/k9uslumivm12vadxdm5d__dhzoq.png" alt="图片"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要在R中定义softplus（）函数，我们使用以下代码：</font></font><br>
<br>
<code>&gt; softplus &lt;- function(x) { log(1 + exp(x)) }</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以使用act.fct参数将这种激活函数提供给输入Neuronet（）。</font><font style="vertical-align: inherit;">另外，我们添加了一个由五个节点组成的第二个隐藏层，为隐藏参数分配了整数矢量c（5，5）的值。</font><font style="vertical-align: inherit;">结果，我们得到了一个两层网络，每个层都有五个节点，并且所有这些节点都使用softplus激活功能：</font></font><br>
<br>
<pre><code class="java hljs">&gt; set.seed(<span class="hljs-number">12345</span>)<font></font>
&gt; concrete_model3 &lt;- neuralnet(strength ~ cement + slag +<font></font>
                                               ash + water + superplastic +<font></font>
                                               coarseagg + fineagg + age,<font></font>
                                               data = concrete_train,<font></font>
                                               hidden = c(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>),<font></font>
                                               act.fct = softplus)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
和以前一样，可以将网络可视化（图7.14）：</font></font><br>
<br>
<code>&gt; plot(concrete_model3)</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yw/yy/om/ywyyomaklvohzlzh-jp2ljggypi.png" alt="图片"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
混凝土的预测强度和实际强度之间的相关关系可以计算如下：</font></font><br>
<br>
<pre><code class="java hljs">&gt; model_results3 &lt;- compute(concrete_model3, concrete_test[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>])<font></font>
&gt; predicted_strength3 &lt;- model_results3$net.result<font></font>
&gt; cor(predicted_strength3, concrete_test$strength)<font></font>
                  [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.9348395359</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
预测强度与实际强度之间的相关性为0.935，这是迄今为止获得的最佳指标。有趣的是，在原始出版物中，Ye报告的相关系数为0.885。这意味着我们只需花费很少的精力，就可以得到可比的结果，甚至超过该领域专家的结果。没错，Ye的结果发表于1998年，这使我们在神经网络领域进行了20多年的额外研究方面处于领先地位！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
应该考虑另一个重要的细节：由于我们在训练模型之前对数据进行了归一化，因此预测也处于从0到1的归一化间隔内。例如，以下代码显示了一个数据帧，该数据帧逐行将初始数据集中的具体强度值与相应的预测进行比较：</font></font><br>
<br>
<pre><code class="java hljs">&gt; strengths &lt;- data.frame(<font></font>
      actual = concrete$strength[<span class="hljs-number">774</span>:<span class="hljs-number">1030</span>],<font></font>
      pred = predicted_strength3<font></font>
   )<font></font>
&gt; head(strengths, n = <span class="hljs-number">3</span>)<font></font>
      actual        pred<font></font>
<span class="hljs-number">774</span> <span class="hljs-number">30.14</span> <span class="hljs-number">0.2860639091</span>
<span class="hljs-number">775</span> <span class="hljs-number">44.40</span> <span class="hljs-number">0.4777304648</span>
<span class="hljs-number">776</span> <span class="hljs-number">24.50</span> <span class="hljs-number">0.2840964250</span></code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
检查相关性，我们看到选择标准化或异常化数据不会影响计算的性能统计信息-就像以前一样，相关性为0.935：</font><font style="vertical-align: inherit;">
但是如果我们计算另一个性能指标，例如预测值与实际值之间的绝对差，则规模的选择将非常重要。</font><font style="vertical-align: inherit;">
考虑到这一点，您可以创建unnormalize（）函数，该函数将执行minimax规范化的反向操作，并允许您将规范化的预测转换为原始比例：</font></font><br>
<br>
<code>&gt; cor(strengths$pred, strengths$actual)<br>
[1] 0.9348395359</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="java hljs">&gt; unnormalize &lt;- function(x) {
     <span class="hljs-keyword">return</span>((x * (max(concrete$strength)) -<font></font>
           min(concrete$strength)) + min(concrete$strength))<font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将我们编写的unnormalize（）函数应用于预测后，很明显新预测的规模类似于混凝土强度的初始值。</font><font style="vertical-align: inherit;">这使您可以计算绝对误差的有意义的值。</font><font style="vertical-align: inherit;">此外，异常强度和初始强度值之间的相关关系保持不变：</font></font><br>
<br>
<pre><code class="java hljs">&gt; strengths$pred_new &lt;- unnormalize(strengths$pred)<font></font>
&gt; strengths$error &lt;- strengths$pred_new — strengths$actual<font></font>
&gt; head(strengths, n = <span class="hljs-number">3</span>)<font></font>
           actual                pred             pred_new                    error<font></font>
<span class="hljs-number">774</span>          <span class="hljs-number">30.14</span>         <span class="hljs-number">0.2860639091</span>               <span class="hljs-number">23.62887889</span>      -<span class="hljs-number">6.511121108</span>
<span class="hljs-number">775</span>          <span class="hljs-number">44.40</span>         <span class="hljs-number">0.4777304648</span>               <span class="hljs-number">39.46053639</span>      -<span class="hljs-number">4.939463608</span>
<span class="hljs-number">776</span>          <span class="hljs-number">24.50</span>         <span class="hljs-number">0.2840964250</span>               <span class="hljs-number">23.46636470</span>      -<span class="hljs-number">1.033635298</span><font></font>
<font></font>
&gt; cor(strengths$pred_new, strengths$actual)<font></font>
[<span class="hljs-number">1</span>] <span class="hljs-number">0.9348395359</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将神经网络应用于您的项目时，您需要遵循类似的步骤序列，以将数据恢复为原始大小。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可能还会发现，神经网络正用于越来越困难的学习任务，因此正迅速变得越来越复杂。例如，当反向传播算法因为没有在合理的时间内收敛而找不到有用的解决方案时，您可能会遇到所谓的“消失”的小梯度问题和紧密相关的“爆炸”梯度问题。为了解决这些问题，您可以尝试更改隐藏节点的数量，应用各种激活功能，例如ReLU，调整学习速度等。在Neuronet功能的帮助页面上，您将找到有关可以配置的各种参数的其他信息。但是，这导致了另一个问题，当建立高效模型的瓶颈正在检查大量参数时。这是使用神经网络乃至更深度学习网络的代价：它们的巨大潜力需要大量时间和处理能力。</font></font><br>
<br>
<blockquote>       ,  ML     .     ,   Amazon Web Services (AWS)  Microsoft Azure,          .       12.</blockquote><br>
<h3>  </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
支持向量机（SVM）方法可以表示为一个表面，该表面形成了在多维空间中绘制的数据点之间的边界，该数据点描述了其属性的示例和值。 SVM的目标是建立一个平坦的边界-一种超平面，该平面以一种在空间的两面形成均质组的方式划分空间。因此，SVM训练结合了基于第3章描述的实例的最近邻训练和第6章讨论的线性回归建模的方面。这是一种非常强大的组合，允许SVM对非常复杂的关系进行建模。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管支持SVM的基本数学已经存在了数十年，但在将这些方法开始应用于ML之后，对这些方法的兴趣已显着增长。在解决复杂的学习问题方面取得了成功的成功故事之后，以及在支持SVM算法的开发和支持SVM算法的开发之后，这些方法的受欢迎程度都得到了提高.SVM算法在包括R在内的许多编程语言的良好支持的库中得到了奖励和实现。否则，可能无法应用实现SVM所需的复杂数学。好消息是，尽管数学可能很复杂，但是基本概念是可以理解的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SVM方法可以适应几乎所有类型的训练任务，包括分类和数值预测。</font><font style="vertical-align: inherit;">该算法的许多关键成功与模式识别有关。</font><font style="vertical-align: inherit;">这些方法的最著名的应用程序包括：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于检测癌症和其他遗传疾病的生物信息学中微阵列基因表达数据的分类；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文本分类，例如确定文档中使用的语言或按主题对文档进行分类；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检测罕见但重要的事件，例如内燃机故障，违反安全规定或发生地震。</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以二进制分类为例，SVM方法最容易理解-这就是通常使用的方法。</font><font style="vertical-align: inherit;">因此，在其余部分中，我们将仅关注SVM分类器。</font><font style="vertical-align: inherit;">将SVM方法用于数值预测时，也会使用与此处介绍的原理相似的原理。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于作者</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brett Lantz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（@DataSpelunking）十多年来一直使用创新的数据处理技术来研究人类行为。</font><font style="vertical-align: inherit;">作为一名受过培训的社会学家，布雷特首先对机器学习产生了兴趣，同时探索了社交网络上青少年档案的大型数据库。</font><font style="vertical-align: inherit;">Brett是DataCamp的老师，经常在世界各地的机器学习会议和研讨会上进行演讲。</font><font style="vertical-align: inherit;">他是体育，无人驾驶汽车，外语和时尚研究以及许多其他行业中数据科学实际应用领域的知名爱好者。</font><font style="vertical-align: inherit;">布雷特希望有一天能在dataspelunking.com上写下所有这些信息，以交流有关查找数据模式的知识。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于科学编辑</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">巴厘岛拉加夫</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Raghav Bali）-世界最大的医疗保健组织之一的高级研究员。他从事基于机器学习，深度学习和自然语言处理的企业解决方案的研究和开发，用于医疗保健和保险。在之前的英特尔职位上，他参与了信息技术领域的前瞻性计划，该计划基于大数据，使用自然语言处理，深度学习和传统统计方法。在美国运通公司，他从事数字参与和客户保留方面的工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
拉加夫（Raghav）是知名出版商出版的几本书的作者。</font><font style="vertical-align: inherit;">他的最新著作是有关转学研究的最新著作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raghav毕业于班加罗尔国际信息技术学院，拥有硕士学位（荣誉学位）。</font><font style="vertical-align: inherit;">在他不忙于解决科学问题的罕见时刻，拉加夫喜欢连续阅读和拍照。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
»有关这本书的更多信息，请</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问出版商的网站</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目录</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font><font style="vertical-align: inherit;">
Khabrozhiteley </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘录</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优惠券可享受25％的折扣- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">机器学习</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
支付纸质版本后，将通过电子邮件发送电子图书。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN496242/index.html">赛博朋克已经在这里：小学生在Minecraft学习，学生在CS中进行身体测试：GO</a></li>
<li><a href="../zh-CN496248/index.html">挑战，光头和葡萄酒。HFLabs我们如何忍受自我隔离</a></li>
<li><a href="../zh-CN496250/index.html">奇怪的代码如何隐藏错误？TensorFlow.NET分析</a></li>
<li><a href="../zh-CN496252/index.html">气动偏置对中飞机</a></li>
<li><a href="../zh-CN496254/index.html">Rostelecom如何错误地将流量重定向到Google，AWS，Cloudflare等。</a></li>
<li><a href="../zh-CN496258/index.html">在线大战：一种新的经验交流形式。这个星期六</a></li>
<li><a href="../zh-CN496260/index.html">在家工作的网络安全提示</a></li>
<li><a href="../zh-CN496262/index.html">获取CVE ID</a></li>
<li><a href="../zh-CN496266/index.html">冠状病毒：我们都会死吗？</a></li>
<li><a href="../zh-CN496268/index.html">2020年面向企业客户的华为企业网络产品和解决方案</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>