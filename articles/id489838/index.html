<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¿â€ğŸŒ¾ â™Šï¸ ğŸ‘ƒğŸ¾ Kebocoran Memori Sisi Server Nuxt Menggunakan SSR (Server Side Rendering) ğŸŒƒ ğŸ‘« ğŸ¤¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Artikel ini harus dibaca untuk siapa saja yang bekerja dengan Vue SSR, khususnya dengan Nuxt . Ini tentang kebocoran memori saat menggunak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kebocoran Memori Sisi Server Nuxt Menggunakan SSR (Server Side Rendering)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489838/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo, Habr! </font><font style="vertical-align: inherit;">Artikel ini harus dibaca untuk siapa saja yang bekerja dengan Vue SSR, khususnya dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuxt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ini tentang kebocoran memori saat menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aksioma</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latar Belakang</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setengah tahun yang lalu, saya mendapatkan proyek dengan tumpukan VueJS + Nuxt, kekhasannya adalah bahwa server Nod (Nuxt) terus-menerus sekarat di prod dan yang baru naik di tempat mereka. </font><font style="vertical-align: inherit;">Dari grafik dan log, jelas bahwa operasi proses simpul mencapai 100% dan jatuh dengan kesalahan memori. </font><font style="vertical-align: inherit;">Pada saat ini, yang baru naik ke tempat proses terbunuh, yang memakan waktu sekitar 30 detik, ini cukup bagi pengguna untuk mendapatkan kesalahan 502. </font><font style="vertical-align: inherit;">Jelas, di suatu tempat dalam kode ada kebocoran memori yang perlu ditemukan.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya ingin langsung menyoroti poin-poin penting, karena hanya membaca sebagian dari artikel ini mungkin tidak menjawab semua pertanyaan Anda:</font></font><br>
<br>
<ol>
<li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relevansi topik </font></font></b> </li>
<li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencegat aksioma</font></font></b> </li>
<li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jalankanInNewContext</font></font></b> </li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Relevansi topik</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal pertama, karena banyak dari kita akan lakukan, saya mulai mencari solusi di internet, pertanyaan saya tampak seperti ini: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kebocoran memori NodeJS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kebocoran memori nuxt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kebocoran memori nuxt dalam produksi</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dll </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, tidak satu pun dari dua puluh masalah pada stackoverflow membantu saya, tetapi saya belajar cara melacak penggunaan memori melalui chrome: // inspect. </font><font style="vertical-align: inherit;">Untuk kekecewaan saya, saya menemukan bahwa 90% dari semua memori yang karena alasan tertentu tidak dibersihkan adalah beberapa fungsi Vue seperti renderComponent, renderElement, dan lainnya.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fa/oo/gn/faoognc9ndcq9h5lw7omfenjq78.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Axios Interceptors</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami dengan cepat melewati siksaan saya untuk mencari masalah dan segera melanjutkan ke fakta bahwa </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aksioma. Pelaku</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> disalahkan atas </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">segalanya</font></a><font style="vertical-align: inherit;"> (Maaf, Habr, karena menemukan yang bersalah). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Segera buat reservasi bahwa aksioma dibuat seperti ini:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> baseAxios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> axios = baseAxios.create({
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span>,<font></font>
});<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> axios;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan melekat pada konteks aplikasi seperti ini: </font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'./index'</span>;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>{<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(!context.axios) {<font></font>
    context.axios = axios;<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah lama mencari kebocoran, saya menemukan bahwa jika Anda menonaktifkan semua axios.interceptors, maka memori mulai dibersihkan.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa masalahnya?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interseptor adalah proxy yang memotong semua respons atau permintaan dan memungkinkan Anda untuk mengeksekusi kode apa pun dengan jawaban (misalnya, untuk menangani kesalahan) atau menambahkan sesuatu sebelum mengirim permintaan secara global untuk semua permintaan dan di satu tempat, nyaman, bukan? </font><font style="vertical-align: inherit;">Berikut adalah contoh tampilannya (file 'plugins / axios / interceptor.js')</font></font></li>
</ul><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">{ axios }</span>) </span>{<font></font>
<font></font>
  <span class="hljs-keyword">const</span> interceptor = axios.interceptors.response.use( <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> response;<font></font>
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
    <span class="hljs-comment">//-   ,  </span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);<font></font>
  });<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan di sini kesenangan dimulai. </font><font style="vertical-align: inherit;">Kami menambahkan fungsi menambahkan interseptor melalui plugin di nuxt.config.js</font></font><br>
<br>
<pre><code class="javascript hljs">  plugins: [<font></font>
    { <span class="hljs-attr">src</span>: <span class="hljs-string">'~/plugins/axios/bindContext'</span> },<font></font>
    { <span class="hljs-attr">src</span>: <span class="hljs-string">'~/plugins/axios/interceptor'</span> },<font></font>
  ]</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dan nuxt secara otomatis untuk setiap permintaan baru melakukan semua fungsi plugin, kemudian melakukan nuxtServerInit dan kemudian semuanya seperti biasa. Artinya, untuk pengguna pertama, kami membuat pencegat di sisi server, di suatu tempat di komponen kami di asyncData atau dalam menjemput kami membuat permintaan, dan pencegat berfungsi sebagaimana mestinya, maka pengguna kedua masuk dan kami membuat pencegat kedua dan kode di dalam fungsi akan bekerja 2 kali! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk pemahaman yang lebih baik dari kata-kata saya, saya akan menggambar penghitung yang menambah setiap kali fungsi dipanggil dan mengetuk indeks 5 kali. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ly/en/uu/lyenuuid32whlgsdqja6nz8z6s8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita dapat melihat bahwa 15 panggilan telah terjadi, dan ini adalah 1 + 2 + 3 + 4 + 5, saya juga meluangkan waktu untuk membuat pencegat berikutnya untuk memastikan bahwa ada tantangan dari mereka yang diciptakan sebelumnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dari sekolah, kita semua ingat rumus perkembangan aritmatika dengan baik, dan jumlah dari 1 ke n dapat ditulis sebagai n * (n + 1) / 2. Ternyata ketika pengguna ke-1000 masuk, fungsi kita akan dipanggil 1000 kali, dan secara total ini sudah setengah juta panggilan, jadi jika bebannya sedang atau tinggi, maka jangan kaget jika server Anda mogok.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solusi untuk masalah tersebut </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UPD. </font><font style="vertical-align: inherit;">Solusi # 0 - Komentar menggambarkan solusi yang baik untuk masalah ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusi # 1 - Jangan gunakan axios.interceptors. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusi No. 2 - Semuanya sangat sederhana, Anda perlu membersihkan pencegat untuk diri sendiri, dipandu oleh dokumentasi aksioma</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">{ axios }</span>) </span>{<font></font>
<font></font>
  <span class="hljs-keyword">const</span> interceptor = axios.interceptors.response.use( <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(process.server) {<font></font>
      axios.interceptors.response.eject(interceptor);<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> response;<font></font>
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
    <span class="hljs-keyword">if</span>(process.server) {<font></font>
      axios.interceptors.response.eject(interceptor);<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);<font></font>
  });<font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini perlu dilakukan hanya di sisi server, karena jika tidak di sisi klien, setelah berhasil mengeksekusi permintaan pertama, pencegat ini akan berhenti mengeksekusi. </font><font style="vertical-align: inherit;">Ada satu lagi nuansa dengan fakta bahwa sementara kita masih di server dan sedang memproses permintaan pengguna berikutnya, tetapi mungkin ada beberapa, tetapi beberapa permintaan, kemudian dengan mengeluarkan pencegat ini, semua permintaan kecuali yang pertama tidak akan melewatinya, dalam hal ini untuk secara mandiri memikirkan saat di mana Anda perlu melakukan eject, cara termudah untuk melakukan ini adalah melalui setTimeout, misalnya, setelah 10 detik, maka kita dapat mengasumsikan bahwa di sisi server kita akan berhasil menyelesaikan semua permintaan untuk pengguna saat ini dan semuanya akan dieksekusi selama waktu ini, ketika pencegat masih akan aktif.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jalankanInNewContext </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah pilihan yang sangat lucu, karena bug ini tidak dapat diputar secara lokal, tetapi sangat mudah untuk dimainkan di build. </font><font style="vertical-align: inherit;">Baca tentang ini di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ketika saya bersiap-siap untuk menulis artikel ini, saya membuat proyek nuxt starter-template untuk mereproduksi masalah ini, dan betapa saya terkejut bahwa untuk setiap pengguna biasa - interceptor dieksekusi 1 kali, dan bukan n. </font><font style="vertical-align: inherit;">Masalahnya adalah, ketika kita menulis npm run dev - opsi ini benar secara default, dan setiap kali kita melakukan fungsi dari plugin di sisi server, konteksnya baru setiap kali (jelas dari nama bendera), dan itu secara otomatis dilakukan dalam build false untuk kinerja yang lebih baik di prod, jadi saya harus menonaktifkan opsi ini di nuxt.config.js</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-attr">render</span>: {
    <span class="hljs-attr">bundleRenderer</span>: {
      <span class="hljs-attr">runInNewContext</span>: <span class="hljs-literal">false</span>,<font></font>
    },<font></font>
  },<font></font>
</code></pre> <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kesimpulan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagi saya, masalah ini sangat serius, dan perlu diperhatikan secara khusus. </font><font style="vertical-align: inherit;">Mungkin masalah ini tidak hanya menyangkut Vue ssr, tetapi juga yang lain, dan tidak hanya aksioma, tetapi juga klien HTTP lain yang memiliki proxy yang mirip dengan pencegat. </font><font style="vertical-align: inherit;">Jika Anda memiliki pertanyaan, Anda dapat menulis kepada saya di Telegram </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@alexander_proydenko</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Semua kode yang digunakan dalam artikel dapat dilihat di github di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id489826/index.html">Tentang metode yang dapat diubah dari objek Matematika dalam JavaScript</a></li>
<li><a href="../id489828/index.html">Bekerja dengan GeoJSON di Node.js: pengantar praktis</a></li>
<li><a href="../id489832/index.html">Manik-manik atom buatan manusia: manipulasi dengan macrocycles</a></li>
<li><a href="../id489834/index.html">Sematkan perangkat Smart Home Anda di ekosistem SmartThings</a></li>
<li><a href="../id489836/index.html">Lidar masa depan: 11.000 laser, bukan 128</a></li>
<li><a href="../id489840/index.html">Drive Anatomy: Hard Drives</a></li>
<li><a href="../id489844/index.html">Analisis komparatif dari beberapa decompiler Java</a></li>
<li><a href="../id489848/index.html">Mengapa kolega / karyawan saya berperilaku seperti @% Â§?</a></li>
<li><a href="../id489850/index.html">Pekan Keamanan 09: siapa yang bertanggung jawab atas keamanan Android?</a></li>
<li><a href="../id489852/index.html">Otentikasi transparan di ASP.Net Core di Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>