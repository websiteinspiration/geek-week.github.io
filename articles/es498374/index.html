<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèø üçí üë©üèø‚Äçü§ù‚Äçüë©üèΩ Computaci√≥n GPU: por qu√©, cu√°ndo y c√≥mo. Adem√°s de algunas pruebas üö¨ üèÖ üë∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todos saben desde hace mucho tiempo que en las tarjetas de video no solo puedes jugar juguetes, sino tambi√©n realizar cosas que no est√°n relacionadas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Computaci√≥n GPU: por qu√©, cu√°ndo y c√≥mo. Adem√°s de algunas pruebas</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dbtc/blog/498374/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos saben desde hace mucho tiempo que en las tarjetas de video no solo puedes jugar juguetes, sino tambi√©n realizar cosas que no est√°n relacionadas con los juegos, por ejemplo, entrenar una red neuronal, recordar criptomonedas o realizar c√°lculos cient√≠ficos. C√≥mo sucedi√≥, puede leerlo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero quer√≠a tocar el tema de </font></font><i><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por qu√© la GPU puede ser interesante para el</font></font></strong></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> programador promedio (no relacionado con GameDev) </font></font><i><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c√≥mo abordar el</font></font></strong></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> desarrollo en la GPU sin perder mucho tiempo, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decidir</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si mire en esta direcci√≥n y " </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descubra con los dedos" qu√© beneficio puede obtener.</font></font></strong>&nbsp;<br>
<br>
<div style="text-align:center;"><img width="800" src="https://habrastorage.org/getpro/habr/post_images/3ee/2ac/893/3ee2ac8936a685e6993966cfa40f53fd.jpg"></div><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El art√≠culo fue escrito en base a mi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presentaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en HighLoad ++. </font><font style="vertical-align: inherit;">Discute principalmente las tecnolog√≠as ofrecidas por NVIDIA. </font><font style="vertical-align: inherit;">No tengo ning√∫n prop√≥sito de anunciar ning√∫n producto, solo los doy a modo de ejemplo, y seguro que se puede encontrar algo similar en los fabricantes de la competencia.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© contar con la GPU?</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se pueden comparar dos procesadores de acuerdo con diferentes criterios, probablemente los m√°s populares son la frecuencia y el n√∫mero de n√∫cleos, el tama√±o de los cach√©s, etc., pero al final, estamos interesados ‚Äã‚Äãen cu√°ntas operaciones puede realizar un procesador por unidad de tiempo, qu√© tipo de operaci√≥n es, pero una pregunta aparte Una m√©trica com√∫n es el n√∫mero de operaciones de punto flotante por segundo - flops. Y cuando queremos comparar c√°lido con suave, y en nuestro caso GPU con CPU, esta m√©trica es √∫til. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El siguiente gr√°fico muestra el crecimiento de estos mismos fracasos a lo largo del tiempo para procesadores y tarjetas de video.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e2/048/3f5/5e20483f59e87b0a395b0fae0e6495c5.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Los datos se recopilan de fuentes abiertas, no hay datos para 2019-20 a√±os, porque no todo es tan hermoso all√≠, pero las GPU a√∫n ganan)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Bueno, es tentador, ¬øno? </font><font style="vertical-align: inherit;">¬°Cambiamos todos los c√°lculos de la CPU a la GPU y obtenemos ocho veces el mejor rendimiento! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero, por supuesto, no todo es tan simple. </font><font style="vertical-align: inherit;">No puede simplemente tomar y transferir todo a la GPU, por eso, hablaremos m√°s.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arquitectura de GPU y su comparaci√≥n con la CPU</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les traigo a muchos una imagen familiar con la arquitectura de la CPU y los elementos b√°sicos:</font></font><br>
<br>
<div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/df0/8c2/4c3/df08c24c3fe92cd97356670729c318cd.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU Core</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
¬øQu√© es tan especial? </font><font style="vertical-align: inherit;">Un n√∫cleo y un mont√≥n de bloques auxiliares. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora echemos un vistazo a la arquitectura GPU:</font></font><br>
<br>
<div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/0fe/138/0cc/0fe1380ccbb321b289d16e39a499009a.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
tarjeta de video </font><i><font style="vertical-align: inherit;">GPU Core</font></i><font style="vertical-align: inherit;"> A tiene muchos n√∫cleos de procesamiento, generalmente varios miles, pero se combinan en bloques; para las tarjetas de video NVIDIA, generalmente 32 cada una, y tienen elementos comunes, incluidos y se registra. La arquitectura del n√∫cleo de la GPU y los elementos l√≥gicos es mucho m√°s simple que en la CPU, es decir, no hay pretratadores, predictores de brunch y mucho m√°s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno, estos son los puntos clave de la diferencia en la arquitectura de la CPU y la GPU y, de hecho, imponen restricciones o, por el contrario, abren las posibilidades de lo que podemos leer efectivamente en la GPU.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No mencion√© un punto m√°s importante, por lo general, la tarjeta de video y el procesador no "hurgan" entre ellos y escriben datos en la tarjeta de video y leen el resultado; estas son operaciones separadas y pueden resultar en un "cuello de botella" en su sistema, un gr√°fico del tiempo de bombeo versus el tama√±o Los datos se dan m√°s adelante en el art√≠culo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limitaciones y caracter√≠sticas de la GPU</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øQu√© limitaciones impone esta arquitectura a los algoritmos ejecutables?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si estamos calculando en una GPU, entonces no podemos seleccionar solo un n√∫cleo, se asignar√° un bloque completo de n√∫cleos (32 para NVIDIA).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos los n√∫cleos ejecutan las mismas instrucciones, pero con datos diferentes (hablaremos de esto m√°s adelante), tales c√°lculos se denominan Datos de instrucciones m√∫ltiples o SIMD (aunque NVIDIA introduce su refinamiento).&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debido al conjunto relativamente simple de bloques l√≥gicos y registros generales, a la GPU realmente no le gusta la ramificaci√≥n, y de hecho la l√≥gica compleja en los algoritmos.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øQu√© oportunidades abre?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En realidad, la aceleraci√≥n de esos mismos c√°lculos SIMD. </font><font style="vertical-align: inherit;">El ejemplo m√°s simple es la adici√≥n de matrices por elementos, y analic√©moslo.</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reducci√≥n de algoritmos cl√°sicos a representaci√≥n SIMD</font></font></h1><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transformaci√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenemos dos matrices, A y B, y queremos agregar un elemento de la matriz B a cada elemento de la matriz A. A continuaci√≥n se muestra un ejemplo en C, aunque espero que quede claro para aquellos que no hablan este idioma:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *A, <span class="hljs-keyword">float</span> *B, size)</span>
</span>{ 
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) <font></font>
   { <font></font>
       A[i] += B[i]<font></font>
   } <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bucle cl√°sico de elementos en un bucle y tiempo de ejecuci√≥n lineal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora veamos c√≥mo se ver√° ese c√≥digo para la GPU:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *A, <span class="hljs-keyword">float</span> *B, size)</span> 
</span>{ 
   <span class="hljs-keyword">int</span> i = threadIdx.x; 
   <span class="hljs-keyword">if</span> (i &lt; size) <font></font>
      A[i] += B[i] <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y aqu√≠ ya es interesante, apareci√≥ la variable threadIdx, que no parec√≠a declarar en ning√∫n lado. S√≠, su sistema nos proporciona. Imagine que en el ejemplo anterior la matriz consta de tres elementos y desea ejecutarla en tres hilos paralelos. Para hacer esto, necesitar√° agregar otro par√°metro: el √≠ndice o el n√∫mero de flujo. Esto es lo que la tarjeta de video hace por nosotros, aunque pasa el √≠ndice como una variable est√°tica y puede funcionar con varias dimensiones a la vez: x, y, z. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro matiz, si va a iniciar una gran cantidad de transmisiones paralelas a la vez, entonces las transmisiones tendr√°n que dividirse en bloques (una caracter√≠stica arquitect√≥nica de las tarjetas de video). El tama√±o m√°ximo de bloque depende de la tarjeta de video, y el √≠ndice del elemento para el que realizamos los c√°lculos deber√° obtenerse de la siguiente manera:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> i = blockIdx.x * blockDim.x + threadIdx.x; <span class="hljs-comment">// blockIdx ‚Äì  , blockDim ‚Äì  , threadIdx ‚Äì    </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, lo que tenemos: muchos subprocesos de ejecuci√≥n paralela que ejecutan el mismo c√≥digo, pero con diferentes √≠ndices y, en consecuencia, datos, es decir. </font><font style="vertical-align: inherit;">El mismo SIMD. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es el ejemplo m√°s simple, pero si desea trabajar con la GPU, debe llevar su tarea a la misma forma. </font><font style="vertical-align: inherit;">Desafortunadamente, esto no siempre es posible y, en algunos casos, puede ser objeto de una disertaci√≥n doctoral, pero, sin embargo, los algoritmos cl√°sicos a√∫n pueden llevarse a esta forma.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregaci√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos ahora c√≥mo se ver√° la agregaci√≥n agregada a la representaci√≥n SIMD:</font></font><br>
&nbsp;<br>
<div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/ecd/78a/bba/ecd78abbaff0c1be8799c1337f7652f8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenemos una matriz de n elementos. </font><font style="vertical-align: inherit;">En la primera etapa, comenzamos n / 2 hilos y cada hilo agrega dos elementos, es decir </font><font style="vertical-align: inherit;">En una iteraci√≥n, sumamos la mitad de los elementos en la matriz. </font><font style="vertical-align: inherit;">Y luego, en el bucle, repetimos lo mismo para la matriz reci√©n creada, hasta que agreguemos los dos √∫ltimos elementos. </font><font style="vertical-align: inherit;">Como puede ver, cuanto m√°s peque√±o es el tama√±o de la matriz, menos hilos paralelos podemos comenzar, es decir </font><font style="vertical-align: inherit;">en una GPU, tiene sentido agregar matrices de un tama√±o suficientemente grande. </font><font style="vertical-align: inherit;">Tal algoritmo se puede usar para calcular la suma de elementos (por cierto, no se olvide del posible desbordamiento del tipo de datos con el que est√° trabajando), busque el m√°ximo, m√≠nimo o simplemente busque.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clasificaci√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero la clasificaci√≥n ya parece mucho m√°s complicada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los dos algoritmos de clasificaci√≥n m√°s populares en la GPU son:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipo bit√≥nico</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Radix-sort</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero la clasificaci√≥n por radix todav√≠a se usa con m√°s frecuencia, y la implementaci√≥n lista para producci√≥n se puede encontrar en algunas bibliotecas. </font><font style="vertical-align: inherit;">No analizar√© en detalle c√≥mo funcionan estos algoritmos; aquellos que est√©n interesados ‚Äã‚Äãpueden encontrar una descripci√≥n de clasificaci√≥n por radix en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.codeproject.com/Articles/543451/Parallel-Radix-Sort-on-the-GPU-using-Cplusplus- AMP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://stackoverflow.com/a/26229897</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pero la idea es que incluso un algoritmo no lineal como la clasificaci√≥n se puede reducir a una vista SIMD. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y ahora, antes de ver los n√∫meros reales que se pueden obtener de la GPU, descubramos c√≥mo programar para este milagro de la tecnolog√≠a.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donde empezar</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las dos tecnolog√≠as m√°s comunes que se pueden usar para programar en la GPU:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opencl</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuda</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpenCL es un est√°ndar que es compatible con la mayor√≠a de los fabricantes de tarjetas de video, incluyendo </font><font style="vertical-align: inherit;">y en dispositivos m√≥viles, tambi√©n el c√≥digo escrito en OpenCL puede ejecutarse en la CPU. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede usar OpenCL desde C / C ++, hay carpetas para otros idiomas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para OpenCL, me gust√≥ m√°s el libro </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCL en acci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tambi√©n describe diferentes algoritmos en la GPU, incluidos </font><font style="vertical-align: inherit;">Bitonic-sort y Radix-sort. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CUDA es la tecnolog√≠a patentada y SDK de NVIDIA. </font><font style="vertical-align: inherit;">Puede escribir en C / C ++ o usar enlaces a otros idiomas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comparar OpenCL y CUDA es algo incorrecto, porque </font><font style="vertical-align: inherit;">uno es el est√°ndar, el otro es todo el SDK. </font><font style="vertical-align: inherit;">Sin embargo, muchas personas eligen CUDA para el desarrollo de tarjetas de video, a pesar de que la tecnolog√≠a es propietaria, aunque gratuita y solo funciona en tarjetas NVIDIA. </font><font style="vertical-align: inherit;">Hay varias razones para esto:</font></font><br>
<br>
<ul>
<li>  API</li>
<li>    </li>
<li>,   GPU,      (host) </li>
<li> ,  ..  </li>
<li>   </li>
<li>  </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las peculiaridades incluyen el hecho de que CUDA viene con su propio compilador, que tambi√©n puede compilar c√≥digo C / C ++ est√°ndar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El libro de CUDA m√°s completo que encontr√© fue la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programaci√≥n profesional de CUDA C</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aunque ya est√° un poco desactualizado, sin embargo, analiza muchos matices t√©cnicos de programaci√≥n para tarjetas NVIDIA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero, ¬øqu√© pasa si no quiero pasar un par de meses leyendo estos libros, escribiendo mi propio programa para una tarjeta de video, probando y depurando, y luego descubriendo que esto no es para m√≠?&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como dije, hay una gran cantidad de bibliotecas que ocultan la complejidad del desarrollo bajo la GPU: XGBoost, cuBLAS, TensorFlow, PyTorch y otras, consideraremos la biblioteca de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">empuje</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ya que es menos especializado que las otras bibliotecas anteriores, pero al mismo tiempo implementa algoritmos b√°sicos, por ejemplo, clasificaci√≥n, b√∫squeda, agregaci√≥n, y con alta probabilidad puede ser aplicable en sus tareas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thrust es una biblioteca de C ++ que tiene como objetivo "reemplazar" los algoritmos STL est√°ndar con algoritmos basados ‚Äã‚Äãen GPU. </font><font style="vertical-align: inherit;">Por ejemplo, ordenar una matriz de n√∫meros usando esta biblioteca en una tarjeta de video se ver√≠a as√≠:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">thrust::host_vector&lt;DataType&gt; <span class="hljs-title">h_vec</span><span class="hljs-params">(size)</span></span>; <span class="hljs-comment">//    </span>
<span class="hljs-built_in">std</span>::generate(h_vec.begin(), h_vec.end(), rand); <span class="hljs-comment">//   </span>
thrust::device_vector&lt;DataType&gt; d_vec = h_vec; <span class="hljs-comment">//        &nbsp;</span>
thrust::sort(d_vec.begin(), d_vec.end()); <span class="hljs-comment">//    </span>
thrust::copy(d_vec.begin(), d_vec.end(), h_vec.begin()); <span class="hljs-comment">//   ,     </span>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(no olvide que el ejemplo debe ser compilado por un compilador de NVIDIA)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, thrust :: sort es muy similar a un algoritmo similar de STL. Esta biblioteca esconde muchas dificultades, en particular el desarrollo de un subprograma (m√°s precisamente, el n√∫cleo), que se ejecutar√° en la tarjeta de video, pero al mismo tiempo priva de flexibilidad. Por ejemplo, si queremos clasificar varios gigabytes de datos, ser√≠a l√≥gico enviar un dato a la tarjeta para comenzar a ordenar, y mientras la clasificaci√≥n est√° en progreso, enviar m√°s datos a la tarjeta. Este enfoque se llama ocultaci√≥n de latencia y permite un uso m√°s eficiente de los recursos del mapa del servidor, pero, desafortunadamente, cuando usamos bibliotecas de alto nivel, tales oportunidades permanecen ocultas. Pero para la creaci√≥n de prototipos y la medici√≥n del rendimiento, son iguales, especialmente con el empuje que puede medir qu√© gastos generales proporciona la transferencia de datos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Escrib√≠ un peque√±o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">punto de referencia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usando esta biblioteca, que ejecuta varios algoritmos populares con diferentes cantidades de datos en la GPU, veamos cu√°les son los resultados.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultados del algoritmo de GPU</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para probar la GPU, tom√© una instancia en AWS con una tarjeta gr√°fica Tesla k80, esta no es la tarjeta de servidor m√°s potente hasta la fecha (la m√°s potente Tesla v100), pero es la m√°s asequible y tiene a bordo:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4992 granos de CUDA</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24 GB de memoria</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">480 Gb / s - ancho de banda de memoria&nbsp;</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y para las pruebas en la CPU, tom√© una instancia con un procesador Intel Xeon CPU E5-2686 v4 @ 2.30GHz</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transformaci√≥n</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/930/6e1/687/9306e1687be5ee95c29c8aac7b2ae337.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiempo de ejecuci√≥n de transformaci√≥n en la GPU y la CPU en ms</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Como puede ver, la transformaci√≥n habitual de los elementos de la matriz es aproximadamente la misma en el tiempo, tanto en la GPU como en la CPU. </font><font style="vertical-align: inherit;">¬øY por qu√©? </font><font style="vertical-align: inherit;">Debido a que la sobrecarga para enviar datos a la tarjeta y viceversa consume todo el aumento del rendimiento (hablaremos de la sobrecarga por separado), y hay relativamente pocos c√°lculos en la tarjeta. </font><font style="vertical-align: inherit;">Adem√°s, no olvide que los procesadores tambi√©n son compatibles con las instrucciones SIMD, y los compiladores en casos simples pueden usarlas de manera efectiva.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos ahora qu√© tan eficientemente se realiza la agregaci√≥n en la GPU.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregaci√≥n</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c92/d0e/cb9/c92d0ecb96c32866000e6948f5da61f9.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiempo de ejecuci√≥n de agregaci√≥n en GPU y CPU en ms</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
En el ejemplo de agregaci√≥n, ya vemos un aumento significativo en el rendimiento con un aumento en el volumen de datos. </font><font style="vertical-align: inherit;">Tambi√©n vale la pena prestar atenci√≥n al hecho de que bombeamos una gran cantidad de datos a la memoria de la tarjeta, y solo se recupera un valor agregado, es decir </font><font style="vertical-align: inherit;">Los gastos generales para transferir datos de la tarjeta a la RAM son m√≠nimos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pasemos al ejemplo m√°s interesante: la clasificaci√≥n.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clasificaci√≥n</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fde/504/8da/fde5048da5084d1f0902c9362b21d939.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiempo de clasificaci√≥n para la GPU y la CPU en ms</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
A pesar de que enviamos toda la matriz de datos a la tarjeta de video y viceversa, la clasificaci√≥n a la GPU de 800 MB de datos es aproximadamente 25 veces m√°s r√°pida que en el procesador.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobrecarga de transferencia de datos</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como se puede ver en el ejemplo de transformaci√≥n, no siempre es obvio si la GPU ser√° efectiva incluso en aquellas tareas que funcionan bien en paralelo. </font><font style="vertical-align: inherit;">La raz√≥n de esto es una sobrecarga para transferir datos desde la RAM de la computadora a la memoria de la tarjeta de video (en las consolas de juegos, por cierto, la memoria se comparte entre la CPU y la GPU, y no hay necesidad de transferir datos). </font><font style="vertical-align: inherit;">Una de las caracter√≠sticas de una tarjeta de video es el ancho de banda de la memoria o el ancho de banda de la memoria, que determina el ancho de banda te√≥rico de la tarjeta. </font><font style="vertical-align: inherit;">Para Tesla k80 es de 480 GB / s, para Tesla v100 ya es de 900 GB / s. </font><font style="vertical-align: inherit;">Adem√°s, la versi√≥n PCI Express y la implementaci√≥n de c√≥mo transferir√° los datos a la tarjeta afectar√°n el rendimiento, por ejemplo, esto puede hacerse en varias transmisiones paralelas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos los resultados pr√°cticos que se obtuvieron para la tarjeta gr√°fica Tesla k80 en la nube de Amazon:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/798/fb5/613/798fb56139f6158566232bc6283b24e7.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiempo para transferir datos a la GPU, ordenar y transferir datos de vuelta a la RAM en ms </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HtoD - transferir datos a la tarjeta de video </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GPU Ejecuci√≥n - ordenar en la tarjeta de video </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DtoH - copiar datos de la tarjeta de video a la RAM</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Lo primero a tener en cuenta es que leer los datos de la tarjeta de video es m√°s r√°pido que escr√≠belos ah√≠ abajo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo: cuando trabaja con una tarjeta de video, puede obtener una latencia de 350 microsegundos, y esto puede ser suficiente para algunas aplicaciones de baja latencia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El siguiente cuadro muestra una sobrecarga para m√°s datos:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d18/653/b96/d18653b96af325f35fade713bdaa8dae.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiempo para transferir datos a la GPU, ordenar y transferir datos a la RAM en ms</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uso del servidor</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La pregunta m√°s com√∫n es ¬øen qu√© se diferencia una tarjeta de video de juego de una de servidor? </font><font style="vertical-align: inherit;">Seg√∫n las caracter√≠sticas, son muy similares, pero los precios difieren significativamente.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/203/01b/741/20301b7418ee616d9611f42d2b4a8f5d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las principales diferencias entre el servidor (NVIDIA) y la tarjeta de juego:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Garant√≠a del fabricante</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (la tarjeta de juego no est√° dise√±ada para uso del servidor)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Posibles problemas de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtualizaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para una tarjeta gr√°fica de consumidor</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disponibilidad del mecanismo de correcci√≥n de errores en la tarjeta del servidor</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El n√∫mero de subprocesos paralelos (no n√∫cleos CUDA) o soporte para Hyper-Q, que le permite trabajar con la tarjeta desde varios subprocesos en la CPU, por ejemplo, cargar datos a la tarjeta desde un subproceso e iniciar c√°lculos desde otro</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas son, quiz√°s, las principales diferencias importantes que encontr√©.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multithreading</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de descubrir c√≥mo ejecutar el algoritmo m√°s simple en la tarjeta de video y qu√© resultados se pueden esperar, la siguiente pregunta l√≥gica es c√≥mo se comportar√° la tarjeta de video al procesar varias solicitudes paralelas. Como respuesta, tengo dos gr√°ficos de computaci√≥n en la GPU y un procesador con 4 y 32 n√∫cleos:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a1/1f6/022/0a11f6022198a582929f384be357fe43.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El tiempo necesario para realizar c√°lculos matem√°ticos en la GPU y la CPU con matrices de 1000 x 60 en ms</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
. Este gr√°fico realiza c√°lculos con matrices de 1000 x 60 elementos. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los c√°lculos se</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inician a </font><font style="vertical-align: inherit;">partir de varias secuencias de programas, se crea una secuencia separada para la GPU para cada secuencia de CPU (se utiliza el Hyper-Q).&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, el procesador hace frente a esta carga muy bien, mientras que la latencia para una solicitud por GPU aumenta significativamente con un aumento en el n√∫mero de solicitudes paralelas.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e09/22c/7fb/e0922c7fba0ef001cca97c7a99817c83.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El tiempo para realizar c√°lculos matem√°ticos en la GPU y la CPU con matrices de 10,000 x 60 en ms.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
En el segundo gr√°fico, los mismos c√°lculos, pero con matrices 10 veces m√°s largas, y la GPU se comporta mucho mejor bajo tal carga. Estos gr√°ficos son muy indicativos, y podemos concluir: el comportamiento bajo carga depende de la naturaleza de la carga misma. Un procesador tambi√©n puede manejar c√°lculos matriciales de manera bastante eficiente, pero hasta cierto punto. Para una tarjeta de video, es caracter√≠stico que para una carga inform√°tica peque√±a, el rendimiento se reduzca aproximadamente linealmente. Con un aumento en la carga y el n√∫mero de hilos paralelos, la tarjeta de video se adapta mejor.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es dif√≠cil plantear la hip√≥tesis de c√≥mo se comportar√° la GPU en diversas situaciones, pero como puede ver, bajo ciertas condiciones, una tarjeta de servidor puede procesar solicitudes de varios flujos paralelos de manera bastante eficiente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Discutiremos algunas preguntas m√°s que puede tener si a√∫n decide usar la GPU en sus proyectos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√≠mite de recursos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como ya dijimos, los dos recursos principales de una tarjeta de video son los n√∫cleos inform√°ticos y la memoria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, tenemos varios procesos o contenedores que usan una tarjeta de video, y nos gustar√≠a poder compartir la tarjeta de video entre ellos. </font><font style="vertical-align: inherit;">Desafortunadamente, no hay una API simple para esto. </font><font style="vertical-align: inherit;">NVIDIA ofrece tecnolog√≠a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vGPU</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero no encontr√© la tarjeta Tesla k80 en la lista de compatibles, y hasta donde puedo entender por la descripci√≥n, la tecnolog√≠a est√° m√°s enfocada en pantallas virtuales que en c√°lculos. </font><font style="vertical-align: inherit;">Quiz√°s AMD ofrece algo m√°s adecuado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, si planea usar la GPU en sus proyectos, debe confiar en el hecho de que la aplicaci√≥n usar√° la tarjeta de video exclusivamente, o controlar√° mediante programaci√≥n la cantidad de memoria asignada y la cantidad de n√∫cleos utilizados para los c√°lculos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contenedores y GPU</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si descubri√≥ el l√≠mite de recursos, entonces la siguiente pregunta l√≥gica: ¬øqu√© pasa si hay varias tarjetas de video en el servidor? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuevamente, puede decidir a nivel de aplicaci√≥n qu√© GPU usar√°. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra forma m√°s conveniente son los contenedores Docker. </font><font style="vertical-align: inherit;">Puede usar contenedores regulares, pero NVIDIA ofrece sus contenedores </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NGC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , con versiones optimizadas de varios software, bibliotecas y controladores. </font><font style="vertical-align: inherit;">Para un contenedor, puede limitar la cantidad de GPU utilizadas y su visibilidad al contenedor. </font><font style="vertical-align: inherit;">Los gastos generales en el uso de contenedores son aproximadamente del 3%.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabajar en un cl√∫ster</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra pregunta, ¬øqu√© hacer si desea realizar una tarea en varias GPU dentro del mismo servidor o cl√∫ster? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si elige una biblioteca similar a empuje o una soluci√≥n de nivel inferior, entonces la tarea deber√° resolverse manualmente. </font><font style="vertical-align: inherit;">Los marcos de alto nivel, por ejemplo, para el aprendizaje autom√°tico o las redes neuronales, por lo general admiten la capacidad de usar varias tarjetas de f√°brica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, me gustar√≠a se√±alar que, por ejemplo, NVIDIA ofrece una interfaz para el intercambio directo de datos entre tarjetas: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVLINK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que es significativamente m√°s r√°pido que PCI Express. </font><font style="vertical-align: inherit;">Y hay tecnolog√≠a para el acceso directo a la memoria de la tarjeta desde otros dispositivos PCI Express: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUDirect RDMA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , incl. </font><font style="vertical-align: inherit;">y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">red</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recomendaciones</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si est√° considerando usar la GPU en sus proyectos, entonces la GPU es m√°s adecuada para usted si:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Su tarea puede reducirse a una vista SIMD</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es posible cargar la mayor√≠a de los datos en el mapa antes de los c√°lculos (cach√©)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El desaf√≠o implica la computaci√≥n intensiva</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n debe hacer preguntas por adelantado:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øCu√°ntas consultas paralelas ser√°n&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© latencia esperas?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNecesita una tarjeta para su carga? ¬øNecesita un servidor con varias tarjetas o un grupo de servidores GPU?&nbsp;</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬°Eso es todo, espero que el material te sea √∫til y te ayude a tomar la decisi√≥n correcta!</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referencias</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Benchmark y resultados en github - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/tishden/gpu_benchmark/tree/master/cuda</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Adem√°s del tema, una grabaci√≥n del informe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Bases de datos de GPU - Arquitectura, rendimiento y perspectivas de uso"</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Seminario web NVIDIA NGC Containers - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http : //bit.ly/2UmVIVt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://bit.ly/2x4vJKF</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es498360/index.html">Evaluaci√≥n integrada de m√©tricas de carga del servidor</a></li>
<li><a href="../es498362/index.html">Kingston mantiene el liderazgo en env√≠os SSD: ¬øc√≥mo lo hacemos?</a></li>
<li><a href="../es498368/index.html">La historia de un interruptor</a></li>
<li><a href="../es498370/index.html">SAP UI5 y Windows de confirmaci√≥n: nuevamente sobre el contexto</a></li>
<li><a href="../es498372/index.html">Simulador de red tutorial ns-3. Cap√≠tulo 5</a></li>
<li><a href="../es498378/index.html">Anuncio de la escuela vespertina de Slurm por Agile</a></li>
<li><a href="../es498380/index.html">La ventana de Overton en acci√≥n: c√≥mo se usa una pandemia para limitar nuestra libertad</a></li>
<li><a href="../es498390/index.html">IAR + Clion = amistad</a></li>
<li><a href="../es498392/index.html">18 funciones de GitLab van de c√≥digo abierto</a></li>
<li><a href="../es498394/index.html">7 an√°logos gratuitos de Screaming Frog y Netpeak Spider</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>