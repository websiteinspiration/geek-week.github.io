<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⤴️ ✋🏽 👨‍🚒 Fonctionnement de l'attaque de réinitialisation TCP 👩🏽‍🏭 ⏺️ 🐑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une attaque de réinitialisation TCP est effectuée à l'aide d'un seul paquet de données de quelques octets au maximum. Le segment TCP remplacé par l'us...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Fonctionnement de l'attaque de réinitialisation TCP</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499902/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une attaque de réinitialisation TCP est effectuée à l'aide d'un seul paquet de données de quelques octets au maximum. </font><font style="vertical-align: inherit;">Le segment TCP remplacé par l'usurpation d'identité, créé et transmis par l'attaquant, trompe les deux victimes pour mettre fin à la connexion TCP, interrompant la connexion entre elles, ce qui pourrait être critique.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0e/768/854/d0e7688544d90ce84fd01f7aae77b348.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette attaque a eu des conséquences dans le monde réel. </font><font style="vertical-align: inherit;">Les craintes de son utilisation ont été provoquées par l'introduction de modifications au protocole TCP lui-même. </font><font style="vertical-align: inherit;">L'attaque serait une composante essentielle du grand pare-feu chinois (le Bouclier d'or), qui est utilisé par le gouvernement chinois pour censurer Internet en dehors de la Chine. </font><font style="vertical-align: inherit;">Malgré ses antécédents impressionnants, la compréhension des mécanismes derrière cette attaque ne nécessite pas nécessairement une connaissance approfondie de TCP. </font><font style="vertical-align: inherit;">Bien sûr, une compréhension de ses subtilités peut vous en apprendre beaucoup sur les fonctionnalités de la mise en œuvre du protocole TCP, et, comme nous le verrons bientôt, vous pouvez même mener cette attaque contre vous-même en utilisant un seul ordinateur portable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, nous:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apprenez les bases de TCP</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apprenez comment fonctionne l'attaque.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lançons une attaque contre nous-mêmes avec un simple script Python.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de commencer à analyser la mécanique de l'attaque, voyons d'abord comment elle est utilisée dans le monde réel.</font></font><a name="habracut"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment l'attaque de réinitialisation TCP est-elle utilisée dans le grand pare-feu?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Great Firewall (GFW) est un ensemble de systèmes et de techniques utilisés par le gouvernement chinois pour censurer Internet pour les utilisateurs chinois internes. </font><font style="vertical-align: inherit;">GFW bloque et rompt activement les connexions avec les serveurs à l'intérieur et à l'extérieur du pays, et surveille également passivement le trafic Internet de contenu interdit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour empêcher les utilisateurs de se connecter même à des serveurs interdits, GFW utilise des techniques telles que la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pollution DNS</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blocage IP</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(les deux coûtent des articles séparés). </font><font style="vertical-align: inherit;">Cependant, le pare-feu GFW doit parfois être autorisé à établir une connexion, mais à le rompre au milieu. </font><font style="vertical-align: inherit;">Par exemple, cela est nécessaire si vous souhaitez effectuer une analyse lente et en attente de la connexion, par exemple, sa corrélation avec d'autres actions. </font><font style="vertical-align: inherit;">Ou il est utilisé si le pare-feu doit analyser les données échangées au cours du processus de connexion, puis utiliser ces informations pour décider de continuer ou de les bloquer. </font><font style="vertical-align: inherit;">Par exemple, le trafic vers un site Web d'actualités peut être autorisé, mais les vidéos contenant des mots clés interdits seront censurées. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour cela, GFW a besoin d'outils capables d'interrompre les connexions déjà établies. </font><font style="vertical-align: inherit;">Un tel outil est une attaque de réinitialisation TCP.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment fonctionne une attaque de réinitialisation TCP?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans une attaque de réinitialisation TCP, l'attaquant rompt la connexion entre les deux victimes, envoyant un ou les deux faux messages leur disant de se déconnecter immédiatement. Ces messages sont appelés </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segments de réinitialisation TCP</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En fonctionnement normal sans la participation d'un attaquant, les ordinateurs envoient des segments de suppression TCP lorsqu'ils reçoivent du trafic TCP inattendu et souhaitent que l'expéditeur arrête de l'envoyer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'attaque de réinitialisation TCP exploite malicieusement ce mécanisme, incitant les victimes à mettre fin prématurément aux connexions TCP en leur envoyant de faux segments de réinitialisation. Si le faux segment de réinitialisation est effectué correctement, le récepteur le prendra pour le segment réel et fermera la connexion de sa part, interrompant la transmission d'informations sur cette connexion. Pour poursuivre l'échange de données, les victimes peuvent essayer de créer une nouvelle connexion TCP, mais l'attaquant peut avoir la possibilité de réinitialiser cette nouvelle connexion. Heureusement, comme un attaquant a besoin de temps pour créer et envoyer un faux paquet, la suppression des attaques n'est vraiment efficace que contre les connexions à long terme. Connexions à court terme. par exemple, utilisé pour transférer de petites pages Web, ont généralement le temps de remplir leur mission au moment oùquand l'attaquant pourra les réinitialiser.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'envoi de faux segments TCP est en quelque sorte un processus facile, car ni TCP ni IP n'ont leurs propres moyens de vérifier l'identité de l'expéditeur. Il existe une extension IP appelée IPSec qui fournit l'authentification, mais elle n'est pas si largement utilisée. Les fournisseurs de services Internet doivent refuser de transmettre des paquets IP provenant d'une adresse IP manifestement fausse, mais il est allégué que ce contrôle est très médiocre. Tout ce que le destinataire peut faire est de prendre l'adresse IP source et le port à l'intérieur du paquet ou du segment à leur valeur nominale et, si possible, d'utiliser des protocoles de niveau supérieur, tels que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/2014/03/27/how-does-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pour identifier l'expéditeur </font><font style="vertical-align: inherit;">. Cependant, comme les paquets de vidage TCP font partie du protocole TCP lui-même, ils ne peuvent pas être vérifiés à l'aide de ces protocoles de haut niveau.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malgré la simplicité de l'envoi de faux segments, la création d'un faux segment et l'exécution d'une attaque de réinitialisation TCP réussie peuvent toujours être une tâche ardue. </font><font style="vertical-align: inherit;">Pour comprendre pourquoi cela se produit, nous devons comprendre le fonctionnement du protocole TCP.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment fonctionne TCP</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le but du protocole TCP est d'envoyer au destinataire une copie exacte du bloc de données. </font><font style="vertical-align: inherit;">Par exemple, si mon serveur envoie du HTML via TCP à votre ordinateur, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la pile TCP de</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> votre ordinateur (la partie de son système d'exploitation qui traite TCP) devrait sortir mon HTML exactement sous la même forme et dans l'ordre dans lequel mon serveur l'a envoyé.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54d/bf5/d64/54dbf5d644d0a3d8ece1cff6cde7b790.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, mon HTML n'est pas transmis sur Internet d'une manière aussi parfaitement ordonnée. Il est divisé en plusieurs petits fragments (appelés </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segments TCP</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), chacun étant transmis individuellement sur Internet et recréé dans l'ordre transféré par la pile TCP de votre ordinateur. Cette sortie restaurée est appelée </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un flux TCP</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Chaque segment TCP est transmis dans son propre </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet IP</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , cependant, pour comprendre l'attaque, nous n'avons pas besoin de connaître les détails de l'IP.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/468/904/175/4689041752b8fa9f66c57c696c4be2ef.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La conversion de segments en un flux nécessite des précautions car Internet n'est pas fiable. </font><font style="vertical-align: inherit;">Les segments TCP peuvent être perdus. </font><font style="vertical-align: inherit;">Ils peuvent être hors service, envoyés deux fois, endommagés et subir de nombreuses autres mésaventures. </font><font style="vertical-align: inherit;">Par conséquent, le but du protocole TCP est d'assurer une transmission de données fiable sur un réseau peu fiable. </font><font style="vertical-align: inherit;">TCP effectue cette tâche, exigeant que les deux côtés de la connexion maintiennent un contact étroit entre eux et transmettent constamment des informations sur les blocs de données reçus. </font><font style="vertical-align: inherit;">Cela permet aux expéditeurs de comprendre les données que le destinataire n'a pas encore reçues et de retransmettre les données perdues. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour comprendre le fonctionnement du processus, nous devons comprendre comment les expéditeurs et les récepteurs utilisent </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les numéros de séquence TCP</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour le marquage et le suivi des données transmises via TCP.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numéros de séquence TCP</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque octet transmis sur une connexion TCP a un numéro de séquence qui lui est attribué par l'expéditeur. </font><font style="vertical-align: inherit;">Les machines réceptrices utilisent des numéros de série pour déplacer les données reçues dans la commande d'origine.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/402/fbc/144/402fbc144a2864f986debfb2ea9b6412.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque deux machines négocient une connexion TCP, chaque machine envoie un autre </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">numéro de séquence de démarrage</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aléatoire </font><font style="vertical-align: inherit;">. Il s'agit du numéro de séquence que la machine attribuera au premier octet qu'elle envoie. Chaque octet suivant reçoit le numéro de séquence de l'octet précédent plus 1. Les segments </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contiennent </font><em><font style="vertical-align: inherit;">des en-têtes TCP</font></em><font style="vertical-align: inherit;"> , qui sont des métadonnées attachées au début du segment. Le numéro de séquence du premier octet dans le corps du segment est inclus dans l'en-tête TCP de ce segment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il convient de noter que les connexions TCP sont bidirectionnelles, c'est-à-dire que les données peuvent être transmises dans les deux sens, et chaque machine dans une connexion TCP agit à la fois comme un expéditeur et un récepteur. Pour cette raison, chaque machine doit attribuer et traiter son propre ensemble indépendant de numéros de séquence.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Confirmation de réception des données</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsqu'une machine reçoit un segment TCP, elle indique à l'expéditeur du segment qu'il a été reçu. </font><font style="vertical-align: inherit;">Le destinataire le fait en envoyant un segment </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(abréviation de «accusé de réception»), contenant le numéro de séquence de l' </font><font style="vertical-align: inherit;">octet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suivant</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qu'il s'attend à recevoir de l'expéditeur. </font><font style="vertical-align: inherit;">L'expéditeur utilise ces informations pour comprendre que le récepteur a bien reçu tous les autres octets jusqu'à ce nombre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un segment est </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indiqué par la présence d'un indicateur </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et le numéro de confirmation correspondant dans l'en-tête TCP du segment. </font><font style="vertical-align: inherit;">Il n'y a que 6 drapeaux dans le protocole TCP, y compris (comme nous le verrons bientôt) un drapeau </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(abréviation de «reset» - «reset»), indiquant le segment de réinitialisation.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/242/452/e35/242452e35d360faf406441ab93f8c383.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remarque: TCP permet également l'utilisation d' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accusés de réception sélectifs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui sont transmis lorsque le récepteur a reçu certains segments, mais pas tous, dans la plage de nombres. Par exemple, "J'ai reçu les octets 1000-3000 et 4000-5000, mais pas 3001-3999". Par souci de simplicité, je ne considérerai pas les ACK sélectifs dans notre discussion sur les attaques de réinitialisation TCP. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si l'expéditeur transmet des données mais ne reçoit pas</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour eux pendant un certain intervalle de temps, il suppose que les données ont été perdues et les renvoie, en leur donnant les mêmes numéros de série. Cela signifie que si le récepteur accepte deux fois les mêmes octets, il utilise trivialement les numéros de séquence pour se débarrasser des doublons sans interrompre le flux. Le destinataire peut accepter des données en double parce que le segment d'origine a été reçu plus tard, après qu'il a été envoyé à nouveau, ou parce que le segment d'origine a été reçu avec succès, mais que le segment correspondant a été </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perdu sur le chemin de l'expéditeur.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6d/22f/a09/e6d22fa098d7375dab30e6c8341ff358.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien que ces données en double soient assez rares, le gaspillage excessif de ressources qui en résulte ne pose pas de problèmes. </font><font style="vertical-align: inherit;">Si toutes les données parviennent tôt ou tard au destinataire et que les données correspondantes </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parviennent à l'expéditeur, la connexion TCP fait son travail.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Choisir un numéro de série pour un faux segment</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la création d'un faux segment, l' </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attaquant doit lui donner un numéro de série. </font><font style="vertical-align: inherit;">Les destinataires sont très heureux que vous ayez besoin d'accepter des segments avec des numéros de série incohérents et de les connecter indépendamment dans le bon ordre. </font><font style="vertical-align: inherit;">Cependant, leurs capacités sont limitées. </font><font style="vertical-align: inherit;">Si le destinataire reçoit un segment avec un numéro de séquence qui est «trop» hors service, il rejette un tel segment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, pour une attaque de réinitialisation TCP réussie, un numéro de séquence plausible est requis. </font><font style="vertical-align: inherit;">Mais qu'est-ce qui est considéré comme un tel nombre? </font><font style="vertical-align: inherit;">Pour la plupart des segments (bien que, comme nous le verrons plus loin, pas pour </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), la réponse est déterminée par la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">taille de la fenêtre TCP</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taille de la fenêtre TCP</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imaginez un ancien ordinateur du début des années 1990, connecté à un réseau de fibre optique gigabit moderne. Un réseau ultrarapide peut transférer des données vers cet ordinateur âgé à une vitesse incroyable, plus rapidement que la machine ne peut les traiter. Cela nous dérange, car le segment TCP ne peut pas être considéré comme reçu tant que le récepteur ne peut pas le traiter.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/299/76a/8a529976a3acd7a28babb9e8220bcb7d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les ordinateurs ont une </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mémoire tampon TCP</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans laquelle les nouvelles données arrivant en attente de traitement pendant que l'ordinateur travaille sur les données qui arrivent avant. Cependant, ce tampon a une taille limitée. Si le destinataire n'est pas en mesure de faire face à la quantité de données qui lui est transmise par le réseau, le tampon débordera. Lorsque le tampon est plein, le destinataire n'a d'autre choix que de se débarrasser des données redondantes. Le destinataire n'envoie pas </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de données supprimées, l'expéditeur doit donc les renvoyer lorsqu'il y a de l'espace libre dans le tampon du destinataire. Peu importe la vitesse à laquelle le réseau peut transmettre des données si le destinataire n'a pas le temps de les gérer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imaginez un ami trop zélé qui vous envoie un flux entier de lettres à votre courrier plus rapidement que vous ne pouvez le lire. Il y a un certain espace tampon à l'intérieur de votre boîte aux lettres, mais une fois qu'il est plein, toutes les lettres non placées tomberont au sol, où les renards et autres créatures les mangeront. Un ami devra renvoyer les lettres qu'il a mangées, mais pour l'instant vous aurez le temps de recevoir ses précédents messages. L'envoi d'un trop grand nombre de lettres ou d'un volume de données que le destinataire n'est pas en mesure de traiter est un gaspillage d'énergie et de canal de transmission. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
«Trop» - de combien de données s'agit-il? Comment l'expéditeur comprend-il quand envoyer plus de données et quand vaut-il la peine d'attendre? C'est là que la </font><em><font style="vertical-align: inherit;">taille de la fenêtre TCP</font></em><font style="vertical-align: inherit;"> est utile.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La taille de la fenêtre du destinataire est le nombre maximal d'octets non acquittés que l'expéditeur peut lui transférer à tout moment. Supposons que le destinataire signale que sa taille de fenêtre est de 100 000 (nous découvrirons bientôt comment il transmet cette valeur), de sorte que l'expéditeur envoie 100 000 octets. Supposons qu'au moment où l'expéditeur a transmis un cent millième d'octet, le récepteur ait envoyé les segments </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour les 10 000 premiers de ces octets. Cela signifie que 90 000 octets n'ont pas encore été confirmés. Étant donné que la taille de la fenêtre est de 100 000, l'expéditeur peut transférer 10 000 autres octets avant d'attendre de nouveaux </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si, après avoir envoyé ces 10 000 octets supplémentaires,</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s'il n'a pas été reçu, l'expéditeur s'exécutera dans sa limite de 100 000 octets non confirmés. Par conséquent, l'expéditeur devra attendre et cesser d'envoyer des données (sauf pour la retransmission de données qu'il considère comme perdues) jusqu'à ce qu'il en reçoive de nouvelles </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afa/5df/46f/afa5df46f3304b04abbf629ca6ef34a0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque côté de la connexion TCP notifie à l'autre la taille de sa fenêtre pendant le processus de prise de contact qui est effectué lorsque la connexion est ouverte. De plus, la taille des fenêtres peut être modifiée dynamiquement pendant le processus de connexion. Un ordinateur avec un grand tampon TCP peut annoncer une grande taille de fenêtre pour maximiser le débit. Cela permet à la machine qui communique avec elle de transmettre en continu des données via une connexion TCP sans pause ni attente de confirmation. Un ordinateur avec un petit tampon TCP peut être contraint de signaler une petite taille de fenêtre. Parfois, les expéditeurs remplissent complètement la fenêtre et sont obligés d'attendre que certains segments soient confirmés. La bande passante en souffre, mais il est nécessaire que les tampons TCP ne débordent pas.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e3/d5e/5e0/8e3d5e5e0e4b574c6896e6ef7adc94bc.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La taille de la fenêtre TCP est une limite stricte sur la quantité de données non confirmées transmises. </font><font style="vertical-align: inherit;">Nous pouvons l'utiliser pour calculer le numéro de séquence maximum possible (que dans l'équation ci-dessous j'ai désigné comme </font></font><code>max_seq_no</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), que l'expéditeur peut envoyer à l'heure actuelle:</font></font><br>
<br>
<blockquote><code>max_seq_no = max_acked_seq_no + window_size</code></blockquote><br>
<code>max_acked_seq_no</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Il s'agit du numéro de séquence maximum pour lequel le destinataire a envoyé </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il s'agit du numéro de séquence maximal que l'expéditeur sait que le destinataire a exactement reçu. </font><font style="vertical-align: inherit;">Étant donné que l'expéditeur ne peut transmettre que des </font></font><code>window_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">octets non confirmés, le numéro de séquence maximal qu'il peut envoyer est </font></font><code>max_acked_seq_no + window_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour cette raison, la spécification TCP indique que le destinataire doit ignorer toutes les données qu'il reçoit qui ont des numéros de série en dehors de la fenêtre valide. Par exemple, si le destinataire a confirmé tous les octets jusqu'à 15 000 et que la taille de sa fenêtre est de 30 000, il recevra toutes les données avec un numéro de série compris entre 15 000 et (15 000 + 30 000 = 45 000). De plus, le destinataire ignore complètement les données avec des numéros de série en dehors de cet intervalle. Si un segment contient des données, dont certaines se trouvent dans cette fenêtre et d'autres en dehors, alors les données à l'intérieur de la fenêtre seront acceptées et confirmées, mais les données à l'extérieur seront rejetées. Notez que nous ignorons toujours la possibilité des </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sélections</font></font><code>ACK</code></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui ont été brièvement évoquées au début du post.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cas de la plupart des segments TCP, cette règle nous donne un intervalle de numéros de séquence acceptables. </font><font style="vertical-align: inherit;">Cependant, comme mentionné précédemment, les </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">restrictions </font><font style="vertical-align: inherit;">imposées sur les segments </font><font style="vertical-align: inherit;">sont encore plus strictes que les restrictions sur les segments de transmission de données ordinaires. </font><font style="vertical-align: inherit;">Comme nous le verrons bientôt, cela a été fait pour compliquer la conduite d'une variante d'une </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attaque de</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> réinitialisation TCP appelée </font><em><font style="vertical-align: inherit;">«attaque de réinitialisation TCP aveugle»</font></em><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numéros de séquence acceptables pour les segments RST</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les segments réguliers sont acceptés si leur numéro de séquence se situe entre le prochain numéro de séquence attendu et ce numéro plus la taille de la fenêtre. Cependant, les paquets </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne sont reçus que lorsque leur numéro de séquence est </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exactement égal au</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> prochain numéro de séquence attendu. Revenons à l'exemple précédent, dans lequel le destinataire a envoyé le numéro de confirmation 15 000. Pour que le paquet </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soit reçu, son numéro de séquence doit être exactement 15 000. Si le destinataire reçoit un segment </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec un numéro de séquence différent de 15 000, il ne l'acceptera pas.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/596/b55/1d9596b55bb0ac4946ed16ff6b878dff.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si le numéro de séquence est en dehors de l'intervalle, le récepteur l'ignore complètement. </font><font style="vertical-align: inherit;">Cependant, s'il se trouve dans la fenêtre des numéros de séquence attendus, le récepteur envoie un «défi </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">» («appel ACK»). </font><font style="vertical-align: inherit;">Il s'agit d'un segment qui indique à l'expéditeur que le segment </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a un numéro de séquence non valide. </font><font style="vertical-align: inherit;">Il indique également à l'expéditeur le numéro de séquence que le destinataire attend. </font><font style="vertical-align: inherit;">L'expéditeur peut utiliser ces informations de l' </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appel pour recréer et renvoyer les siennes </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jusqu'en 2010, TCP n'a pas imposé ces restrictions de segment supplémentaires </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Les segments ont été </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acceptés ou rejetés conformément aux mêmes règles que les autres. </font><font style="vertical-align: inherit;">Cependant, cela a également simplifié les </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attaques aveugles de réinitialisation TCP aveugles</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attaques TCP aveugles</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si l'attaquant a la capacité d'intercepter le trafic échangé entre ses victimes, il peut lire les numéros de série et de confirmation des paquets TCP des victimes. Il peut utiliser ces informations pour sélectionner les numéros de série à attribuer à ses faux segments </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cependant, si l'attaquant ne peut pas intercepter le trafic des victimes, il ne saura pas quels numéros de séquence insérer. Mais il peut toujours transférer n'importe quel nombre de segments </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec un nombre quelconque de numéros de série différents, en espérant que l'un d'eux se révèle être correct. Une telle attaque est appelée attaque de réinitialisation TCP aveugle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme nous l'avons déjà dit, dans la version initiale du protocole TCP, l'attaquant n'avait qu'à récupérer le numéro de série</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la fenêtre TCP du récepteur. </font><font style="vertical-align: inherit;">Un article intitulé «Slipping in the Window» a montré que cela rendait les attaques aveugles trop faciles, car pour un succès presque garanti, un attaquant n'avait qu'à envoyer des dizaines de milliers de segments. </font><font style="vertical-align: inherit;">Pour contrer cela, la règle qui obligeait le destinataire à accepter le segment a </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">été remplacée par le critère plus strict décrit ci-dessus. </font><font style="vertical-align: inherit;">Grâce aux nouvelles règles pour effectuer des attaques de réinitialisation TCP, des millions de segments doivent être envoyés à l'aveugle, ce qui les rend pratiquement irréalisables. </font><font style="vertical-align: inherit;">Voir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC-5963 pour</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plus </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">de</font></a><font style="vertical-align: inherit;"> détails </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Effectuer une attaque de réinitialisation TCP contre nous-mêmes</font></font></h2><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque: J'ai testé ce processus sur OSX, mais j'ai reçu quelques commentaires selon lesquels il ne fonctionne pas correctement sous Linux. </font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous savons maintenant tout sur l'exécution d'une attaque de réinitialisation TCP. </font><font style="vertical-align: inherit;">L'attaquant doit:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regarder le trafic réseau ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«sniff»</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) entre deux victimes</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renifler le segment TCP avec le drapeau activé </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et lire son numéro confirmé</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créez un faux segment TCP avec l'indicateur activé </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et un numéro de séquence égal au numéro confirmé du segment intercepté (notez que cela implique une transmission lente, sinon le numéro de séquence sélectionné deviendra rapidement obsolète. (Pour augmenter les chances de succès, vous pouvez transférer plusieurs segments </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec un grand intervalle de numéros de séquence .)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Envoyez de faux segments à une ou aux deux victimes, en espérant que cela rompra leur connexion TCP</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour nous entraîner, menons une attaque TCP contre nous-mêmes sur le même ordinateur, en communiquant avec nous-mêmes </font></font><code>localhost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour cela, nous avons besoin de:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configurer la connexion TCP entre deux fenêtres de terminal</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Écrivez un programme d'attaque qui traitera le reniflement du trafic</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez le programme pour qu'il produise et envoie de faux segments </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Etablissement d'une connexion TCP entre deux fenêtres de terminal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons configurer la connexion TCP à l'aide de l'outil </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><code>netcat</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui par défaut est disponible sur de nombreux systèmes d'exploitation. </font><font style="vertical-align: inherit;">Tout autre </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">client TCP fera l'affaire</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dans la première fenêtre du terminal, nous exécuterons la commande suivante:</font></font><br>
<br>
<blockquote><code>nc -nvl 8000</code></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette commande démarre un serveur TCP écoutant sur un port de notre machine locale </font></font><code>8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans la deuxième fenêtre de terminal, exécutez la commande suivante:</font></font><br>
<br>
<blockquote><code>nc 127.0.0.1 8000</code></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette commande tente de créer une connexion TCP à la machine par l'adresse IP du </font></font><code>127.0.0.1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">port </font></font><code>8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Maintenant, entre les deux fenêtres du terminal, une connexion TCP doit être établie. </font><font style="vertical-align: inherit;">Essayez de saisir quelque chose dans une fenêtre - les données devront être transmises via la connexion TCP et apparaître dans une autre fenêtre.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/911/301/786/911301786c4f56287f80d38f67ef73f6.gif"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Reniflement du trafic</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons écrire un programme d'attaque qui effectue le reniflement du trafic à l'aide de la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><code>scapy</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bibliothèque réseau Python populaire. </font><font style="vertical-align: inherit;">Ce programme utilise scapy pour lire les données transférées entre deux fenêtres du terminal, bien qu'il ne fasse pas partie de la connexion. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code du programme est publié dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mon référentiel sur GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Le programme renifle le trafic de connexion et l'affiche sur le terminal. </font><font style="vertical-align: inherit;">Le noyau principal du code est l'appel </font></font><code>sniff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font><font style="vertical-align: inherit;">méthode à </font><font style="vertical-align: inherit;">partir de la bibliothèque </font></font><code>scapy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">située à la fin du fichier:</font></font><br>
<br>
<pre><code class="python hljs">t = sniff(<font></font>
        iface=<span class="hljs-string">'lo0'</span>,<font></font>
        lfilter=is_packet_tcp_client_to_server(localhost_ip, localhost_server_port, localhost_ip),<font></font>
        prn=log_packet,<font></font>
        count=<span class="hljs-number">50</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce morceau de code nous dit </font></font><code>scapy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de renifler les paquets sur l'interface </font></font><code>lo0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et de capturer les détails de tous les paquets dans le cadre de notre connexion TCP. </font><font style="vertical-align: inherit;">L'appel a les paramètres suivants:</font></font><br>
<br>
<ul>
<li><code>iface</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- commandes </font></font><code>scapy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'écoute de l'interface réseau </font></font><code>lo0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou localhost</font></font></li>
<li><code>lfilter</code> —  ,  <code>scapy</code>   ,      IP- localhost   .   ,        ,   <code>lo0</code>.     ,     .</li>
<li><code>prn</code> — ,  <code>scapy</code>     ,    <code>lfilter</code>.          .       ,      <code>RST</code>.</li>
<li><code>count</code> —  ,  <code>scapy</code>    .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour tester ce programme, configurez la connexion TCP à partir de l'étape 1. Clonez mon référentiel GitHub, suivez les instructions de configuration et exécutez le programme dans la troisième fenêtre du terminal. </font><font style="vertical-align: inherit;">Saisissez du texte dans l'un des terminaux de la connexion TCP. </font><font style="vertical-align: inherit;">Vous devriez voir que le programme commencera à enregistrer des informations sur les segments de connexion.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Envoi de faux colis </font></font><code>RST</code></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons établi une connexion et le programme peut détecter tous les segments TCP qui le traversent. Il ne nous reste plus qu'à modifier le programme pour qu'il effectue une attaque de réinitialisation TCP en transmettant de faux segments </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pour ce faire, nous allons changer la fonction </font></font><code>prn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(voir la liste des paramètres ci-dessus), appelée </font></font><code>scapy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour les packages qui répondent aux exigences de la fonction </font></font><code>lfilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dans la version modifiée de la fonction, au lieu de simplement fixer le package correspondant, nous l'étudions, extrayons les paramètres nécessaires et utilisons ces paramètres pour créer et envoyer le segment </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que nous ayons intercepté un segment allant de </font></font><code>(src_ip, src_port)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k </font></font><code>(dst_ip, dst_port)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il a un drapeau </font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et le numéro de confirmation est 100 000. Pour fabriquer et envoyer un segment, nous:</font></font><br>
<br>
<ul>
<li>  IP-   ,    .  ,         .          ,  .</li>
<li>  <code>RST</code> ,     ,    <code>RST</code></li>
<li>        ,      ,    </li>
<li>  <code>send</code>  <code>scapy</code>     —   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour modifier notre programme précédent selon vos besoins, décommentez </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cette ligne</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et commentez la ligne au-dessus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous sommes maintenant prêts pour une attaque à grande échelle. </font><font style="vertical-align: inherit;">Configurez la connexion TCP conformément à l'étape 1. Exécutez le programme d'attaque à partir de l'étape 2 dans la troisième fenêtre du terminal. </font><font style="vertical-align: inherit;">Saisissez ensuite du texte dans l'un des terminaux de la connexion TCP. </font><font style="vertical-align: inherit;">Dans le terminal où vous avez saisi le texte, la connexion TCP se coupera soudainement et mystérieusement. </font><font style="vertical-align: inherit;">L'attaque est terminée!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad9/2a2/b18/ad92a2b18c1533c47d88ab4ff10dedf7.gif"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La poursuite des travaux</font></font></h3><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuez d'expérimenter avec l'outil d'attaque. </font><font style="vertical-align: inherit;">Suivez ce qui se passe si vous ajoutez ou soustrayez 1 du numéro de séquence du package </font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Assurez-vous qu'il doit être </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exactement</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> égal à la valeur du </font></font><code>ack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet intercepté.</font></font></li>
<li> Wireshark       <code>lo0</code>    .            TCP-,       <code>RST</code>.   <code>ip.src == 127.0.0.1 &amp;&amp; ip.dst == 127.0.0.1 &amp;&amp; tcp.port == 8000</code>       .</li>
<li>  ,      .           <code>RST</code>,       <code>RST</code>         ,      .   ,      <code>RST</code>,       .</li>
</ol><br>
<h2></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'attaque de réinitialisation TCP est à la fois profonde et simple à la fois. </font><font style="vertical-align: inherit;">Bonne chance avec vos expériences et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">faites-moi savoir</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si vous avez des questions ou des commentaires.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr499884/index.html">11 choses que j'ai comprises sur CustDev</a></li>
<li><a href="../fr499894/index.html">Maison des choses chantantes. Chipolo ONE Smart Keychain Tracker Review</a></li>
<li><a href="../fr499896/index.html">Nous partons correctement sur le site distant: comment organiser notre travail et le travail du projet en Telegram?</a></li>
<li><a href="../fr499898/index.html">Comment les informaticiens se rapportent à la quarantaine, ce qu'ils font de manière autonome et ce qu'ils utilisent</a></li>
<li><a href="../fr499900/index.html">Analyse de produits mitap: gratuit, sans contact, en ligne</a></li>
<li><a href="../fr499904/index.html">"J'ai peur". Que faire?</a></li>
<li><a href="../fr499906/index.html">Exemples d'utilisation de la RA dans l'industrie du jouet</a></li>
<li><a href="../fr499910/index.html">Équilibre dans la prise de décision. Fork "expérience aléatoire"</a></li>
<li><a href="../fr499920/index.html">SSH Little Tricks</a></li>
<li><a href="../fr499922/index.html">Enfin, nous traitons du débit en bauds Modbus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>