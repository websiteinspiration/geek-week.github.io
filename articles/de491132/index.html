<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚫 🏧 ☸️ Wenn der Bloom-Filter nicht passt 💇🏽 🐋 👄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich wusste von der Universität über den Bloom-Filter Bescheid , eine probabilistische Datenstruktur, die nach Burton Bloom benannt ist. Aber ich hatte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Wenn der Bloom-Filter nicht passt</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491132/"><img src="https://habrastorage.org/webt/7x/rh/8w/7xrh8wafuzqnbs-o1jpgzjxtruw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich wusste von der Universität über </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Bloom-Filter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bescheid </font><font style="vertical-align: inherit;">, eine probabilistische Datenstruktur, die nach Burton Bloom benannt ist. Aber ich hatte keine Gelegenheit, es zu nutzen. Im vergangenen Monat bot sich eine solche Gelegenheit - und diese Struktur faszinierte mich buchstäblich. Ich fand jedoch bald einige Mängel in ihr. Dieser Artikel ist eine Geschichte über meine kurze Liebesbeziehung mit dem Bloom-Filter.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Untersuchung des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP-Spoofing mussten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die IP-Adressen in den eingehenden Paketen überprüft und mit dem geografischen Standort unserer Rechenzentren verglichen werden. Beispielsweise sollten Pakete aus Italien nicht in das brasilianische Rechenzentrum gehen. Dieses Problem mag einfach erscheinen, aber in der sich ständig ändernden Landschaft des Internets ist es alles andere als einfach. Es genügt zu sagen, dass ich am Ende viele große Textdateien mit ungefähr dem folgenden Inhalt gesammelt habe: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7cf/4b4/f67/7cf4b4f67fdf8b4d8a88c2685051c15f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet, dass eine Anfrage von der aufgelösten IP-Adresse 192.0.2.1 im Cloudflare-Rechenzentrum Nummer 107 aufgezeichnet wurde. Diese Daten stammen aus vielen Quellen, einschließlich unserer aktiven und passiven Beispiele, den Protokollen einiger Domänen, die wir besitzen (z. B.</font></font><code>cloudflare.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), Open Source (z. B. BGP-Tabellen) usw. Dieselbe Zeile wird normalerweise in mehreren Dateien wiederholt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende hatte ich einen riesigen Datensatz dieser Art. </font><font style="vertical-align: inherit;">Irgendwann zählte ich in allen gesammelten Quellen 1 Milliarde Zeilen. </font><font style="vertical-align: inherit;">Normalerweise schreibe ich Bash-Skripte für die Vorverarbeitung der Eingabedaten, aber in diesem Maßstab hat dieser Ansatz nicht funktioniert. </font><font style="vertical-align: inherit;">Zum Beispiel nimmt Duplikate aus dieser kleinen Datei von 600 MiB und 40 Millionen Zeilen zu </font><font style="vertical-align: inherit;">entfernen ... Ewigkeit: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bfa/dc1/9c0/bfadc19c083b6a31bc34b568cdc81d74.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es reicht aus , </font><font style="vertical-align: inherit;">dass die </font><font style="vertical-align: inherit;">Deduplizierung Linien mit gewöhnlichen Befehlen des Typs zu sagen , </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in verschiedenen Konfigurationen (siehe </font></font><code>--parallel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>--buffer-size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>--unique</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) war nicht die beste für einen so großen Datensatz.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloom Filter</font></font></h1><br>
<img src="https://habrastorage.org/getpro/habr/post_images/3a6/110/0e6/3a61100e64277b6a515666b8bf0293f9.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Illustration von </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">David Epstein</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im öffentlichen Bereich</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dann wurde mir klar: Sortieren Sie die Zeilen nicht! Sie müssen Duplikate entfernen, damit eine Art 'festgelegte' Datenstruktur viel schneller funktioniert. Außerdem kenne ich ungefähr die Größe der Eingabedatei (die Anzahl der eindeutigen Zeilen), und der Verlust einiger Daten ist nicht kritisch, dh die probabilistische Datenstruktur ist durchaus geeignet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist perfekt für Bloom-Filter!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während Sie</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia über Bloom-Filter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lesen</font><font style="vertical-align: inherit;">, sehe ich diese Datenstruktur so.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie würden Sie</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Pluralität</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">umsetzen</font><font style="vertical-align: inherit;">? Bei einer idealen Hash-Funktion und einem unendlichen Speicher können wir einfach eine unendliche Bitmap erstellen und für jedes Element eine Bitnummer festlegen</font></font><code>hash(item)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies liefert die ideale Datenstruktur für die "Menge". </font><font style="vertical-align: inherit;">Recht? </font><font style="vertical-align: inherit;">Trivial. </font><font style="vertical-align: inherit;">Leider kollidieren Hash-Funktionen und es gibt kein unendliches Gedächtnis. In unserer Realität müssen wir also Kompromisse eingehen. </font><font style="vertical-align: inherit;">Wir können aber die Wahrscheinlichkeit von Kollisionen berechnen und diesen Wert verwalten. </font><font style="vertical-align: inherit;">Zum Beispiel haben wir eine gute Hash-Funktion und 128 GB Speicher. </font><font style="vertical-align: inherit;">Wir können berechnen, dass die Kollisionswahrscheinlichkeit für jedes neue Element 1 in 1099511627776 beträgt. Wenn Sie weitere Elemente hinzufügen, erhöht sich die Wahrscheinlichkeit, wenn die Bitmap gefüllt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus können wir mehr als eine Hash-Funktion anwenden und eine dichtere Bitmap erhalten. </font><font style="vertical-align: inherit;">Hier funktioniert der Bloom-Filter gut. Hierbei handelt es sich um einen Satz mathematischer Daten mit vier Variablen:</font></font><br>
<br>
<ul>
<li><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Anzahl der eingefügten Elemente (Kardinalzahl)</font></font><br>
</li>
<li><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Von der Bitmap verwendeter Speicher</font></font><br>
</li>
<li><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Die Anzahl der für jede Eingabe berechneten Hash-Funktionen</font></font><br>
</li>
<li><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Wahrscheinlichkeit eines falsch positiven Zufalls</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angesichts der Kardinalzahl </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und der gewünschten Wahrscheinlichkeit von Fehlalarmen </font></font><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt der Bloom-Filter den erforderlichen Speicher </font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die erforderliche Anzahl von Hash-Funktionen zurück </font></font><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich diese </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hervorragende</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thomas Hurst- </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Visualisierung an,</font></a><font style="vertical-align: inherit;"> wie sich Parameter gegenseitig beeinflussen.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-Blüte</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von der Intuition geleitet, habe ich meinem Arsenal das probabilistische Werkzeug mmuniq-bloom hinzugefügt, das die Eingabe STDIN verwendet und nur eindeutige Zeilen in STDOUT zurückgibt. </font><font style="vertical-align: inherit;">Es sollte viel schneller sein als eine Kombination von </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font><code>uniq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da ist er:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-bloom.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Einfachheit und Geschwindigkeit halber habe ich zunächst einige Parameter eingestellt. Erstens verwendet mmuniq-bloom, sofern nicht anders angegeben, acht Hash-Funktionen k = 8. Dies scheint nahe an der optimalen Anzahl für unsere Datengröße zu liegen, und die Hash-Funktion kann schnell acht anständige Hashes erzeugen. Dann richten wir den Speicher </font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Bitmap auf eine Zweierpotenz aus, um eine teure Operation zu vermeiden </font></font><code>%modulo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die im Assembler zu langsam wird </font></font><code>div</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn das Array gleich der Zweierpotenz ist, können wir nur bitweises UND verwenden (lesen Sie zum Spaß, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie die Compiler einige Divisionsoperationen durch Multiplikation mit einer magischen Konstante optimieren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt können wir es mit derselben Datendatei ausführen, die wir zuvor verwendet haben:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3fa/019/d05/3fa019d05b8d6a72ad1ea3bde9c15a19.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oh, das ist viel besser! 12 Sekunden statt zwei Minuten. Das Programm verwendet eine optimierte Datenstruktur, eine relativ begrenzte Speichermenge, eine optimierte Zeilenanalyse und eine gute Ausgabepufferung ... und bei alledem scheinen 12 Sekunden im Vergleich zum Tool eine Ewigkeit zu sein </font></font><code>wc -l</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/953/ede/adb/953edeadb5701d03f92c7717f159f20d.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was passiert? Ich verstehe, dass das Einzählen von Zeichenfolgen </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einfacher ist als das Berechnen eindeutiger Zeichenfolgen, aber ist der 26-fache Unterschied wirklich gerechtfertigt? Was nimmt die CPU auf </font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muss für die Berechnung von Hashes sein. Das Dienstprogramm </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt den Prozessor nicht aus und führt all diese seltsamen Berechnungen für jede der 40 Millionen Zeilen durch. Ich benutze eine eher nicht triviale Hash-Funktion </font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die den Prozessor sicher verbrennt, oder? Lassen Sie uns überprüfen, indem Sie nur die Hash-Funktion ausführen, aber </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keine Operationen mit dem Bloom-Filter ausführen: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f5e/7a0/e0f/f5e7a0e0f26a3136ca3d0a9b362e0fe3.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist seltsam. </font><font style="vertical-align: inherit;">Die Berechnung der Hash-Funktion dauert nur etwa zwei Sekunden, obwohl das gesamte Programm im vorherigen Lauf 12 Sekunden lang ausgeführt wurde. </font><font style="vertical-align: inherit;">Funktioniert ein Bloom-Filter 10 Sekunden lang? </font><font style="vertical-align: inherit;">Wie ist das möglich? </font><font style="vertical-align: inherit;">Dies ist eine so einfache Datenstruktur ...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geheimwaffe - Profiler</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist Zeit, das richtige Tool für diese Aufgabe anzuwenden. Lassen Sie uns den Profiler ausführen und sehen, woran der Prozessor arbeitet. Lassen Sie uns </font></font><code>strace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zunächst überprüfen, ob keine unerwarteten Systemaufrufe vorliegen: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7bc/29b/87c/7bc29b87cdeadac9a11ce78aa61129f6.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles sieht gut aus. Zehn Anrufe zu je </font></font><code>mmap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 ms (3971 μs) sind faszinierend, aber das ist in Ordnung. Wir füllen den Speicher vor </font></font><code>MAP_POPULATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um später Fehler aufgrund fehlender Seite zu vermeiden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist der nächste Schritt? Natürlich ist es das </font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/1da/aa8/acc/1daaa8acc9e3a84d1f591ad94cd84387.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann sehen wir uns das Ergebnis an: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/637/38f/3e2/63738f3e2a4bb1207927ecbc45b0cf3b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir brennen also wirklich 87,2% der Zyklen im Hauptcode. Mal sehen wo genau. Das Team </font></font><code>perf annotate process_line --source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zeigt sofort etwas Unerwartetes. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/17f/f6f/cc8/17ff6fcc833def72269a07f7fd54d9f0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sehen, dass 26,90% des Prozessors ausgebrannt sind</font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Aber das ist nicht alles! Der Compiler fügt die Funktion korrekt ein und erweitert die Schleife. Es stellt sich heraus, dass die meisten Zyklen zu dieser </font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder zur Linie gehen </font></font><code>uint64_t v = *p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5c0/a3e/59c/5c0a3e59c8f954146bed3b2f1478e0ba.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Offensichtlich ist Perf falsch. Wie kann eine so einfache Zeichenfolge so viele Ressourcen beanspruchen? Das Wiederholen des Tests mit einem anderen Profiler zeigt jedoch das gleiche Problem. Zum Beispiel verwende ich wegen der farbenfrohen Diagramme gerne Google-Perftools mit kcachegrind: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8af/fbd/e9e/8affbde9e2b92d4da89d445314ec4654.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Visualisierungsergebnis lautet wie folgt: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/130/ea3/9f9/130ea39f9a8c6a22c252381c3af88045.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie mich zusammenfassen, was wir bisher entdeckt haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Standarddienstprogramm </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verarbeitet eine 600-MiB-Datei für eine Prozessorzeit von 0,45 s. Unser optimiertes Tool </font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">läuft 12 Sekunden. Der Prozessor wird auf einen Befehl gebrannt </font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wodurch der Speicher dereferenziert wird ...</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6aa/3dd/e6a/6aa3dde6a6562dad5d0b3b2fa94c4565.jpg"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bild von </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jose Nicdao</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , CC BY / 2.0</font></font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Oh! Wie könnte ich vergessen. Der zufällige Zugriff auf den Speicher ist</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">langsam! Sehr, sehr, sehr langsam!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach den</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zahlen, die jeder Programmierer kennen sollte,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dauert ein einzelner Zugriff auf den RAM etwa 100 ns. Zählen wir: 40 Millionen Zeilen mit jeweils 8 Hashes. Da unser Bloom-Filter eine Größe von 128 MiB hat,</font><font style="vertical-align: inherit;">passt er</font><font style="vertical-align: inherit;">auf</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unserer alten Hardware</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht in den L3-Cache! Hashes sind gleichmäßig über einen weiten Speicherbereich verteilt - jeder von ihnen erzeugt einen Cache-Miss. Alles zusammen und es stellt sich heraus ...</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b54/7e8/2e6/b547e82e6368f26843834121b1765103.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellt sich heraus, dass 32 Sekunden nur bei Speicherzugriffen ausbrennen. Das eigentliche Programm passt in nur 12 Sekunden, da der Bloom-Filter immer noch vom Caching profitiert. Dies ist leicht zu erkennen bei </font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2b8/199/785/2b8199785c666437f37b9d96c209670f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ja, wir hätten mindestens 320 Millionen Cache-Fehler (LLC-Ladefehler) haben müssen, aber nur 280 Millionen sind passiert: Dies erklärt immer noch nicht, warum das Programm in nur 12 Sekunden funktioniert hat. Aber das ist egal. Es ist wichtig, dass die Anzahl der Cache-Fehler ein echtes Problem darstellt, und wir können es nur lösen, indem wir die Anzahl der Speicherzugriffe reduzieren. Versuchen wir, den Bloom-Filter so zu konfigurieren, dass nur eine Hash-Funktion verwendet wird: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/052/bec/d4f/052becd4ffe91553d1d3b01bfa53755b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ay! Es tut wirklich weh! Um eine Kollisionswahrscheinlichkeit von 1 pro 10.000 Zeilen zu erhalten, benötigte der Bloom-Filter 64 Gigabyte Speicher. Es ist schrecklich!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus scheint die Geschwindigkeit nicht wesentlich zugenommen zu haben. </font><font style="vertical-align: inherit;">Das Betriebssystem brauchte 22 Sekunden, um den Speicher für uns vorzubereiten, aber wir verbrachten immer noch 11 Sekunden im Benutzerbereich. </font><font style="vertical-align: inherit;">Ich glaube, dass jetzt alle Vorteile eines selteneren Zugriffs auf den Speicher durch eine geringere Wahrscheinlichkeit kompensiert werden, aufgrund einer stark erhöhten Speichergröße in den Cache zu gelangen. </font><font style="vertical-align: inherit;">Früher reichten 128 MiB für den Bloom-Filter!</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloom-Filter ablehnen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das wird nur lächerlich. </font><font style="vertical-align: inherit;">Um die Wahrscheinlichkeit von Fehlalarmen zu verringern, müssen Sie entweder viele Hashes im Bloom-Filter (z. B. acht) mit einer großen Anzahl von Speicherzugriffen verwenden oder eine Hash-Funktion belassen, aber sehr viel Speicher verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben eigentlich kein Speicherlimit, wir wollen die Anzahl der Aufrufe minimieren. </font><font style="vertical-align: inherit;">Wir brauchen eine Datenstruktur, die maximal einen Cache-Miss pro Element kostet und weniger als 64 Gigabyte RAM benötigt ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich können Sie komplexe Datenstrukturen wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Kuckucksfilter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementieren </font><font style="vertical-align: inherit;">, aber es gibt sicherlich eine einfachere Option. </font><font style="vertical-align: inherit;">Was ist mit der guten alten linearen Probing-Hash-Tabelle? </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c29/a0d/136/c29a0d136e80e5fc0a6f90f1cab1378e.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Illustration von </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vadims Podans</font></font></a></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Treffen Sie mmuniq-Hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist die neue Version von mmuniq-bloom unter Verwendung einer Hash-Tabelle:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-hash.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anstelle der Bits für den Bloom-Filter speichern wir jetzt 64-Bit-Hashes aus </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Funktion 'siphash24'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies bietet einen viel besseren Schutz gegen Hash-Kollisionen: viel besser als eine pro 10.000 Zeilen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lass uns zählen. </font><font style="vertical-align: inherit;">Das Hinzufügen eines neuen Elements zu einer Hash-Tabelle, beispielsweise mit 40 Millionen Einträgen, erhöht die Wahrscheinlichkeit von Hash-Kollisionen </font></font><code>40 000 000/2^64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist ungefähr 1 von 461 Milliarden - eine ziemlich geringe Wahrscheinlichkeit. </font><font style="vertical-align: inherit;">Wir fügen dem vorgefüllten Set jedoch kein Element hinzu! </font><font style="vertical-align: inherit;">Stattdessen fügen wir dem anfänglich leeren Satz 40 Millionen Zeilen hinzu. </font><font style="vertical-align: inherit;">Nach </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem Geburtstagsparadoxon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erhöht dies die Wahrscheinlichkeit von Kollisionen erheblich. </font><font style="vertical-align: inherit;">Eine vernünftige Annäherung wäre </font></font><code>'~n^2/2m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in unserem Fall </font><font style="vertical-align: inherit;">eine Schätzung</font></font><code>~(40M^2)/(2*(2^64))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es ergibt sich eine Chance von 23.000. Mit anderen Worten, mit einer guten Hash-Funktion erwarten wir eine Kollision in einer der 23.000 zufälligen Mengen von 40 Millionen Elementen. Dies ist eine Wahrscheinlichkeit ungleich Null, aber immer noch besser als im Bloom-Filter und für unseren Anwendungsfall vollständig tolerierbar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code mit einer Hash-Tabelle funktioniert schneller, hat bessere Speicherzugriffsmuster und eine geringere Wahrscheinlichkeit von Fehlalarmen als im Bloom-Filter.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/0ea/5c5/817/0ea5c5817289f136355f452748da0f86.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie sich nicht von der Zeile "Hash-Konflikte" beunruhigen, sie zeigt nur, wie voll die Hash-Tabelle ist. </font><font style="vertical-align: inherit;">Wir verwenden die lineare Abtastung. Wenn wir also in den vollständigen Satz kommen, nehmen wir einfach den nächsten leeren. </font><font style="vertical-align: inherit;">In unserem Fall müssen wir durchschnittlich 0,7 Sätze überspringen, um eine leere Stelle in der Tabelle zu finden. </font><font style="vertical-align: inherit;">Es ist in Ordnung. </font><font style="vertical-align: inherit;">Da wir die Mengen in einer linearen Reihenfolge durchlaufen, muss der Speicher qualitativ voll sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus dem vorherigen Beispiel wissen wir, dass unsere Hash-Funktion ungefähr zwei Sekunden dauert. </font><font style="vertical-align: inherit;">Wir schließen daraus, dass 40 Millionen Speicherzugriffe etwa vier Sekunden dauern.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gewonnene Erkenntnisse</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Moderne Prozessoren können sehr gut sequentiell auf den Speicher zugreifen, wenn Sie Beispielmuster vorhersagen können (siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cache-Prefetching</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Der zufällige Zugriff auf den Speicher ist dagegen sehr teuer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erweiterte Datenstrukturen sind sehr interessant, aber seien Sie vorsichtig. Moderne Computer erfordern die Verwendung von Cache-optimierten Algorithmen. Bei der Arbeit mit großen Datenmengen, die nicht in L3 passen, wird die Optimierung über die Anzahl der Treffer gegenüber der Optimierung über die verwendete Speichermenge bevorzugt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Man kann mit Recht sagen, dass Bloom-Filter im L3-Cache eine hervorragende Leistung erbringen. Aber wenn nicht, dann sind sie schrecklich. Dies ist keine Neuigkeit: Bloom-Filter sind für die Speichermenge optimiert, nicht für die Anzahl der Aufrufe. Zum Beispiel siehe</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wissenschaftlicher Artikel über Kuckucksfilter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine andere Sache sind endlose Diskussionen über Hash-Funktionen. Ehrlich gesagt spielt dies in den meisten Fällen keine Rolle. Die Kosten für das Zählen selbst komplexer Hash-Funktionen scheinen im </font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergleich zu den Kosten für den wahlfreien Zugriff auf den Speicher gering zu sein. In unserem Fall bringt die Vereinfachung der Hash-Funktion nur einen geringen Vorteil. CPU-Zeit wird nur woanders verschwendet - auf Speicher warten! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Kollege sagt oft: „Man kann davon ausgehen, dass moderne Prozessoren unendlich schnell sind. Sie arbeiten mit unendlicher Geschwindigkeit, bis sie an der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wand der Erinnerung ruhen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . " </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließlich wiederholen Sie nicht meinen Fehler. Sie müssen immer zuerst eine Profilerstellung durchführen</font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und schauen Sie sich den IPC-Zähler an (Anweisungen pro Zyklus). </font><font style="vertical-align: inherit;">Wenn es weniger als eins ist, bedeutet dies normalerweise, dass das Programm nicht mehr auf Speicher wartet. </font><font style="vertical-align: inherit;">Die optimalen Werte liegen über zwei. </font><font style="vertical-align: inherit;">Dies bedeutet, dass die Arbeitslast hauptsächlich auf der CPU liegt. </font><font style="vertical-align: inherit;">Leider ist der IPC bei meinen Aufgaben immer noch niedrig ...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überlegene mmuniq</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Hilfe von Kollegen habe ich eine verbesserte Version des mmuniq-Tools basierend auf einer Hash-Tabelle geschrieben. </font><font style="vertical-align: inherit;">Hier ist der Code:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es kann die Größe der Hash-Tabelle dynamisch ändern und unterstützt die Eingabe mit einer beliebigen Kardinalzahl. </font><font style="vertical-align: inherit;">Anschließend werden die Daten in Paketen verarbeitet, wobei der Hinweis </font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der CPU </font><font style="vertical-align: inherit;">effektiv verwendet wird </font><font style="vertical-align: inherit;">, wodurch das Programm um 35-40% beschleunigt wird. </font><font style="vertical-align: inherit;">Seien Sie vorsichtig, eine reichliche Verwendung </font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des Codes führt selten zu einer Wirkung. </font><font style="vertical-align: inherit;">Um diese Funktion nutzen zu können, habe ich die Algorithmen speziell neu angeordnet. </font><font style="vertical-align: inherit;">Mit allen Verbesserungen wurde die Ausführungszeit auf 2,1 Sekunden reduziert:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e40/4df/9c4/e404df9c42a97be2f1051a69f98116e6.png"><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Ende</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Entwicklung eines grundlegenden Tools, das versucht, die Kombination 'sort / uniq' zu übertreffen, hat einige verborgene Merkmale des modernen Computing aufgedeckt. </font><font style="vertical-align: inherit;">Nachdem wir ein wenig geschwitzt hatten, beschleunigten wir das Programm von mehr als zwei Minuten auf zwei Sekunden. </font><font style="vertical-align: inherit;">Während der Entwicklung haben wir die Verzögerung beim Direktzugriff auf den Speicher sowie die Leistungsfähigkeit cachefreundlicher Datenstrukturen kennengelernt. </font><font style="vertical-align: inherit;">Bizarre Datenstrukturen ziehen die Aufmerksamkeit auf sich, aber in der Praxis ist es oft effizienter, die Anzahl der zufälligen Zugriffe auf den Speicher zu reduzieren.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de491116/index.html">Moderne Identifikationsstandards: OAuth 2.0, OpenID Connect, WebAuthn</a></li>
<li><a href="../de491118/index.html">Entwicklerherz: Devkits der 5. Konsolengeneration (Teil 1)</a></li>
<li><a href="../de491120/index.html">$ mol: 4 Jahre später</a></li>
<li><a href="../de491122/index.html">Forensische Analyse von HiSuite-Backups</a></li>
<li><a href="../de491130/index.html">Vue Features zum Erinnern</a></li>
<li><a href="../de491134/index.html">5 Stufen der Unvermeidlichkeit der Annahme der ISO / IEC 27001-Zertifizierung. Negation</a></li>
<li><a href="../de491136/index.html">Projizieren von Inhalten in Angular oder verlorene ng-Inhaltsdokumentation</a></li>
<li><a href="../de491138/index.html">Satelliten- und Ansible Tower-Integration</a></li>
<li><a href="../de491146/index.html">UML für Entwickler</a></li>
<li><a href="../de491150/index.html">Wie ich Betrüger gehackt habe oder nur die Innenseiten von Phishing-Panels</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>