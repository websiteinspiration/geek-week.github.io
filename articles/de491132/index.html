<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö´ üèß ‚ò∏Ô∏è Wenn der Bloom-Filter nicht passt üíáüèΩ üêã üëÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich wusste von der Universit√§t √ºber den Bloom-Filter Bescheid , eine probabilistische Datenstruktur, die nach Burton Bloom benannt ist. Aber ich hatte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Wenn der Bloom-Filter nicht passt</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491132/"><img src="https://habrastorage.org/webt/7x/rh/8w/7xrh8wafuzqnbs-o1jpgzjxtruw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich wusste von der Universit√§t √ºber </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Bloom-Filter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bescheid </font><font style="vertical-align: inherit;">, eine probabilistische Datenstruktur, die nach Burton Bloom benannt ist. Aber ich hatte keine Gelegenheit, es zu nutzen. Im vergangenen Monat bot sich eine solche Gelegenheit - und diese Struktur faszinierte mich buchst√§blich. Ich fand jedoch bald einige M√§ngel in ihr. Dieser Artikel ist eine Geschichte √ºber meine kurze Liebesbeziehung mit dem Bloom-Filter.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Untersuchung des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP-Spoofing mussten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die IP-Adressen in den eingehenden Paketen √ºberpr√ºft und mit dem geografischen Standort unserer Rechenzentren verglichen werden. Beispielsweise sollten Pakete aus Italien nicht in das brasilianische Rechenzentrum gehen. Dieses Problem mag einfach erscheinen, aber in der sich st√§ndig √§ndernden Landschaft des Internets ist es alles andere als einfach. Es gen√ºgt zu sagen, dass ich am Ende viele gro√üe Textdateien mit ungef√§hr dem folgenden Inhalt gesammelt habe: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7cf/4b4/f67/7cf4b4f67fdf8b4d8a88c2685051c15f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet, dass eine Anfrage von der aufgel√∂sten IP-Adresse 192.0.2.1 im Cloudflare-Rechenzentrum Nummer 107 aufgezeichnet wurde. Diese Daten stammen aus vielen Quellen, einschlie√ülich unserer aktiven und passiven Beispiele, den Protokollen einiger Dom√§nen, die wir besitzen (z. B.</font></font><code>cloudflare.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), Open Source (z. B. BGP-Tabellen) usw. Dieselbe Zeile wird normalerweise in mehreren Dateien wiederholt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende hatte ich einen riesigen Datensatz dieser Art. </font><font style="vertical-align: inherit;">Irgendwann z√§hlte ich in allen gesammelten Quellen 1 Milliarde Zeilen. </font><font style="vertical-align: inherit;">Normalerweise schreibe ich Bash-Skripte f√ºr die Vorverarbeitung der Eingabedaten, aber in diesem Ma√üstab hat dieser Ansatz nicht funktioniert. </font><font style="vertical-align: inherit;">Zum Beispiel nimmt Duplikate aus dieser kleinen Datei von 600 MiB und 40 Millionen Zeilen zu </font><font style="vertical-align: inherit;">entfernen ... Ewigkeit: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bfa/dc1/9c0/bfadc19c083b6a31bc34b568cdc81d74.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es reicht aus , </font><font style="vertical-align: inherit;">dass die </font><font style="vertical-align: inherit;">Deduplizierung Linien mit gew√∂hnlichen Befehlen des Typs zu sagen , </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in verschiedenen Konfigurationen (siehe </font></font><code>--parallel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>--buffer-size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>--unique</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) war nicht die beste f√ºr einen so gro√üen Datensatz.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloom Filter</font></font></h1><br>
<img src="https://habrastorage.org/getpro/habr/post_images/3a6/110/0e6/3a61100e64277b6a515666b8bf0293f9.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Illustration von </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">David Epstein</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im √∂ffentlichen Bereich</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dann wurde mir klar: Sortieren Sie die Zeilen nicht! Sie m√ºssen Duplikate entfernen, damit eine Art 'festgelegte' Datenstruktur viel schneller funktioniert. Au√üerdem kenne ich ungef√§hr die Gr√∂√üe der Eingabedatei (die Anzahl der eindeutigen Zeilen), und der Verlust einiger Daten ist nicht kritisch, dh die probabilistische Datenstruktur ist durchaus geeignet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist perfekt f√ºr Bloom-Filter!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
W√§hrend Sie</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia √ºber Bloom-Filter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lesen</font><font style="vertical-align: inherit;">, sehe ich diese Datenstruktur so.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie w√ºrden Sie</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Pluralit√§t</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">umsetzen</font><font style="vertical-align: inherit;">? Bei einer idealen Hash-Funktion und einem unendlichen Speicher k√∂nnen wir einfach eine unendliche Bitmap erstellen und f√ºr jedes Element eine Bitnummer festlegen</font></font><code>hash(item)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies liefert die ideale Datenstruktur f√ºr die "Menge". </font><font style="vertical-align: inherit;">Recht? </font><font style="vertical-align: inherit;">Trivial. </font><font style="vertical-align: inherit;">Leider kollidieren Hash-Funktionen und es gibt kein unendliches Ged√§chtnis. In unserer Realit√§t m√ºssen wir also Kompromisse eingehen. </font><font style="vertical-align: inherit;">Wir k√∂nnen aber die Wahrscheinlichkeit von Kollisionen berechnen und diesen Wert verwalten. </font><font style="vertical-align: inherit;">Zum Beispiel haben wir eine gute Hash-Funktion und 128 GB Speicher. </font><font style="vertical-align: inherit;">Wir k√∂nnen berechnen, dass die Kollisionswahrscheinlichkeit f√ºr jedes neue Element 1 in 1099511627776 betr√§gt. Wenn Sie weitere Elemente hinzuf√ºgen, erh√∂ht sich die Wahrscheinlichkeit, wenn die Bitmap gef√ºllt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus k√∂nnen wir mehr als eine Hash-Funktion anwenden und eine dichtere Bitmap erhalten. </font><font style="vertical-align: inherit;">Hier funktioniert der Bloom-Filter gut. Hierbei handelt es sich um einen Satz mathematischer Daten mit vier Variablen:</font></font><br>
<br>
<ul>
<li><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Anzahl der eingef√ºgten Elemente (Kardinalzahl)</font></font><br>
</li>
<li><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Von der Bitmap verwendeter Speicher</font></font><br>
</li>
<li><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Die Anzahl der f√ºr jede Eingabe berechneten Hash-Funktionen</font></font><br>
</li>
<li><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Wahrscheinlichkeit eines falsch positiven Zufalls</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angesichts der Kardinalzahl </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und der gew√ºnschten Wahrscheinlichkeit von Fehlalarmen </font></font><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt der Bloom-Filter den erforderlichen Speicher </font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die erforderliche Anzahl von Hash-Funktionen zur√ºck </font></font><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich diese </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hervorragende</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thomas Hurst- </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Visualisierung an,</font></a><font style="vertical-align: inherit;"> wie sich Parameter gegenseitig beeinflussen.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-Bl√ºte</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von der Intuition geleitet, habe ich meinem Arsenal das probabilistische Werkzeug mmuniq-bloom hinzugef√ºgt, das die Eingabe STDIN verwendet und nur eindeutige Zeilen in STDOUT zur√ºckgibt. </font><font style="vertical-align: inherit;">Es sollte viel schneller sein als eine Kombination von </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font><code>uniq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da ist er:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-bloom.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Einfachheit und Geschwindigkeit halber habe ich zun√§chst einige Parameter eingestellt. Erstens verwendet mmuniq-bloom, sofern nicht anders angegeben, acht Hash-Funktionen k = 8. Dies scheint nahe an der optimalen Anzahl f√ºr unsere Datengr√∂√üe zu liegen, und die Hash-Funktion kann schnell acht anst√§ndige Hashes erzeugen. Dann richten wir den Speicher </font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Bitmap auf eine Zweierpotenz aus, um eine teure Operation zu vermeiden </font></font><code>%modulo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die im Assembler zu langsam wird </font></font><code>div</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn das Array gleich der Zweierpotenz ist, k√∂nnen wir nur bitweises UND verwenden (lesen Sie zum Spa√ü, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie die Compiler einige Divisionsoperationen durch Multiplikation mit einer magischen Konstante optimieren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt k√∂nnen wir es mit derselben Datendatei ausf√ºhren, die wir zuvor verwendet haben:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3fa/019/d05/3fa019d05b8d6a72ad1ea3bde9c15a19.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oh, das ist viel besser! 12 Sekunden statt zwei Minuten. Das Programm verwendet eine optimierte Datenstruktur, eine relativ begrenzte Speichermenge, eine optimierte Zeilenanalyse und eine gute Ausgabepufferung ... und bei alledem scheinen 12 Sekunden im Vergleich zum Tool eine Ewigkeit zu sein </font></font><code>wc -l</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/953/ede/adb/953edeadb5701d03f92c7717f159f20d.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was passiert? Ich verstehe, dass das Einz√§hlen von Zeichenfolgen </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einfacher ist als das Berechnen eindeutiger Zeichenfolgen, aber ist der 26-fache Unterschied wirklich gerechtfertigt? Was nimmt die CPU auf </font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muss f√ºr die Berechnung von Hashes sein. Das Dienstprogramm </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt den Prozessor nicht aus und f√ºhrt all diese seltsamen Berechnungen f√ºr jede der 40 Millionen Zeilen durch. Ich benutze eine eher nicht triviale Hash-Funktion </font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die den Prozessor sicher verbrennt, oder? Lassen Sie uns √ºberpr√ºfen, indem Sie nur die Hash-Funktion ausf√ºhren, aber </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keine Operationen mit dem Bloom-Filter ausf√ºhren: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f5e/7a0/e0f/f5e7a0e0f26a3136ca3d0a9b362e0fe3.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist seltsam. </font><font style="vertical-align: inherit;">Die Berechnung der Hash-Funktion dauert nur etwa zwei Sekunden, obwohl das gesamte Programm im vorherigen Lauf 12 Sekunden lang ausgef√ºhrt wurde. </font><font style="vertical-align: inherit;">Funktioniert ein Bloom-Filter 10 Sekunden lang? </font><font style="vertical-align: inherit;">Wie ist das m√∂glich? </font><font style="vertical-align: inherit;">Dies ist eine so einfache Datenstruktur ...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geheimwaffe - Profiler</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist Zeit, das richtige Tool f√ºr diese Aufgabe anzuwenden. Lassen Sie uns den Profiler ausf√ºhren und sehen, woran der Prozessor arbeitet. Lassen Sie uns </font></font><code>strace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zun√§chst √ºberpr√ºfen, ob keine unerwarteten Systemaufrufe vorliegen: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7bc/29b/87c/7bc29b87cdeadac9a11ce78aa61129f6.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles sieht gut aus. Zehn Anrufe zu je </font></font><code>mmap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 ms (3971 Œºs) sind faszinierend, aber das ist in Ordnung. Wir f√ºllen den Speicher vor </font></font><code>MAP_POPULATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um sp√§ter Fehler aufgrund fehlender Seite zu vermeiden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist der n√§chste Schritt? Nat√ºrlich ist es das </font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/1da/aa8/acc/1daaa8acc9e3a84d1f591ad94cd84387.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann sehen wir uns das Ergebnis an: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/637/38f/3e2/63738f3e2a4bb1207927ecbc45b0cf3b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir brennen also wirklich 87,2% der Zyklen im Hauptcode. Mal sehen wo genau. Das Team </font></font><code>perf annotate process_line --source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zeigt sofort etwas Unerwartetes. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/17f/f6f/cc8/17ff6fcc833def72269a07f7fd54d9f0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sehen, dass 26,90% des Prozessors ausgebrannt sind</font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Aber das ist nicht alles! Der Compiler f√ºgt die Funktion korrekt ein und erweitert die Schleife. Es stellt sich heraus, dass die meisten Zyklen zu dieser </font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder zur Linie gehen </font></font><code>uint64_t v = *p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5c0/a3e/59c/5c0a3e59c8f954146bed3b2f1478e0ba.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Offensichtlich ist Perf falsch. Wie kann eine so einfache Zeichenfolge so viele Ressourcen beanspruchen? Das Wiederholen des Tests mit einem anderen Profiler zeigt jedoch das gleiche Problem. Zum Beispiel verwende ich wegen der farbenfrohen Diagramme gerne Google-Perftools mit kcachegrind: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8af/fbd/e9e/8affbde9e2b92d4da89d445314ec4654.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Visualisierungsergebnis lautet wie folgt: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/130/ea3/9f9/130ea39f9a8c6a22c252381c3af88045.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie mich zusammenfassen, was wir bisher entdeckt haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Standarddienstprogramm </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verarbeitet eine 600-MiB-Datei f√ºr eine Prozessorzeit von 0,45 s. Unser optimiertes Tool </font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l√§uft 12 Sekunden. Der Prozessor wird auf einen Befehl gebrannt </font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wodurch der Speicher dereferenziert wird ...</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6aa/3dd/e6a/6aa3dde6a6562dad5d0b3b2fa94c4565.jpg"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bild von </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jose Nicdao</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , CC BY / 2.0</font></font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Oh! Wie k√∂nnte ich vergessen. Der zuf√§llige Zugriff auf den Speicher ist</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">langsam! Sehr, sehr, sehr langsam!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach den</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zahlen, die jeder Programmierer kennen sollte,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dauert ein einzelner Zugriff auf den RAM etwa 100 ns. Z√§hlen wir: 40 Millionen Zeilen mit jeweils 8 Hashes. Da unser Bloom-Filter eine Gr√∂√üe von 128 MiB hat,</font><font style="vertical-align: inherit;">passt er</font><font style="vertical-align: inherit;">auf</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unserer alten Hardware</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht in den L3-Cache! Hashes sind gleichm√§√üig √ºber einen weiten Speicherbereich verteilt - jeder von ihnen erzeugt einen Cache-Miss. Alles zusammen und es stellt sich heraus ...</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b54/7e8/2e6/b547e82e6368f26843834121b1765103.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellt sich heraus, dass 32 Sekunden nur bei Speicherzugriffen ausbrennen. Das eigentliche Programm passt in nur 12 Sekunden, da der Bloom-Filter immer noch vom Caching profitiert. Dies ist leicht zu erkennen bei </font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2b8/199/785/2b8199785c666437f37b9d96c209670f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ja, wir h√§tten mindestens 320 Millionen Cache-Fehler (LLC-Ladefehler) haben m√ºssen, aber nur 280 Millionen sind passiert: Dies erkl√§rt immer noch nicht, warum das Programm in nur 12 Sekunden funktioniert hat. Aber das ist egal. Es ist wichtig, dass die Anzahl der Cache-Fehler ein echtes Problem darstellt, und wir k√∂nnen es nur l√∂sen, indem wir die Anzahl der Speicherzugriffe reduzieren. Versuchen wir, den Bloom-Filter so zu konfigurieren, dass nur eine Hash-Funktion verwendet wird: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/052/bec/d4f/052becd4ffe91553d1d3b01bfa53755b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ay! Es tut wirklich weh! Um eine Kollisionswahrscheinlichkeit von 1 pro 10.000 Zeilen zu erhalten, ben√∂tigte der Bloom-Filter 64 Gigabyte Speicher. Es ist schrecklich!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus scheint die Geschwindigkeit nicht wesentlich zugenommen zu haben. </font><font style="vertical-align: inherit;">Das Betriebssystem brauchte 22 Sekunden, um den Speicher f√ºr uns vorzubereiten, aber wir verbrachten immer noch 11 Sekunden im Benutzerbereich. </font><font style="vertical-align: inherit;">Ich glaube, dass jetzt alle Vorteile eines selteneren Zugriffs auf den Speicher durch eine geringere Wahrscheinlichkeit kompensiert werden, aufgrund einer stark erh√∂hten Speichergr√∂√üe in den Cache zu gelangen. </font><font style="vertical-align: inherit;">Fr√ºher reichten 128 MiB f√ºr den Bloom-Filter!</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloom-Filter ablehnen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das wird nur l√§cherlich. </font><font style="vertical-align: inherit;">Um die Wahrscheinlichkeit von Fehlalarmen zu verringern, m√ºssen Sie entweder viele Hashes im Bloom-Filter (z. B. acht) mit einer gro√üen Anzahl von Speicherzugriffen verwenden oder eine Hash-Funktion belassen, aber sehr viel Speicher verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben eigentlich kein Speicherlimit, wir wollen die Anzahl der Aufrufe minimieren. </font><font style="vertical-align: inherit;">Wir brauchen eine Datenstruktur, die maximal einen Cache-Miss pro Element kostet und weniger als 64 Gigabyte RAM ben√∂tigt ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nat√ºrlich k√∂nnen Sie komplexe Datenstrukturen wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Kuckucksfilter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementieren </font><font style="vertical-align: inherit;">, aber es gibt sicherlich eine einfachere Option. </font><font style="vertical-align: inherit;">Was ist mit der guten alten linearen Probing-Hash-Tabelle? </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c29/a0d/136/c29a0d136e80e5fc0a6f90f1cab1378e.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Illustration von </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vadims Podans</font></font></a></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Treffen Sie mmuniq-Hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist die neue Version von mmuniq-bloom unter Verwendung einer Hash-Tabelle:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-hash.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anstelle der Bits f√ºr den Bloom-Filter speichern wir jetzt 64-Bit-Hashes aus </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Funktion 'siphash24'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies bietet einen viel besseren Schutz gegen Hash-Kollisionen: viel besser als eine pro 10.000 Zeilen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lass uns z√§hlen. </font><font style="vertical-align: inherit;">Das Hinzuf√ºgen eines neuen Elements zu einer Hash-Tabelle, beispielsweise mit 40 Millionen Eintr√§gen, erh√∂ht die Wahrscheinlichkeit von Hash-Kollisionen </font></font><code>40 000 000/2^64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist ungef√§hr 1 von 461 Milliarden - eine ziemlich geringe Wahrscheinlichkeit. </font><font style="vertical-align: inherit;">Wir f√ºgen dem vorgef√ºllten Set jedoch kein Element hinzu! </font><font style="vertical-align: inherit;">Stattdessen f√ºgen wir dem anf√§nglich leeren Satz 40 Millionen Zeilen hinzu. </font><font style="vertical-align: inherit;">Nach </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem Geburtstagsparadoxon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erh√∂ht dies die Wahrscheinlichkeit von Kollisionen erheblich. </font><font style="vertical-align: inherit;">Eine vern√ºnftige Ann√§herung w√§re </font></font><code>'~n^2/2m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in unserem Fall </font><font style="vertical-align: inherit;">eine Sch√§tzung</font></font><code>~(40M^2)/(2*(2^64))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es ergibt sich eine Chance von 23.000. Mit anderen Worten, mit einer guten Hash-Funktion erwarten wir eine Kollision in einer der 23.000 zuf√§lligen Mengen von 40 Millionen Elementen. Dies ist eine Wahrscheinlichkeit ungleich Null, aber immer noch besser als im Bloom-Filter und f√ºr unseren Anwendungsfall vollst√§ndig tolerierbar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code mit einer Hash-Tabelle funktioniert schneller, hat bessere Speicherzugriffsmuster und eine geringere Wahrscheinlichkeit von Fehlalarmen als im Bloom-Filter.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/0ea/5c5/817/0ea5c5817289f136355f452748da0f86.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie sich nicht von der Zeile "Hash-Konflikte" beunruhigen, sie zeigt nur, wie voll die Hash-Tabelle ist. </font><font style="vertical-align: inherit;">Wir verwenden die lineare Abtastung. Wenn wir also in den vollst√§ndigen Satz kommen, nehmen wir einfach den n√§chsten leeren. </font><font style="vertical-align: inherit;">In unserem Fall m√ºssen wir durchschnittlich 0,7 S√§tze √ºberspringen, um eine leere Stelle in der Tabelle zu finden. </font><font style="vertical-align: inherit;">Es ist in Ordnung. </font><font style="vertical-align: inherit;">Da wir die Mengen in einer linearen Reihenfolge durchlaufen, muss der Speicher qualitativ voll sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus dem vorherigen Beispiel wissen wir, dass unsere Hash-Funktion ungef√§hr zwei Sekunden dauert. </font><font style="vertical-align: inherit;">Wir schlie√üen daraus, dass 40 Millionen Speicherzugriffe etwa vier Sekunden dauern.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gewonnene Erkenntnisse</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Moderne Prozessoren k√∂nnen sehr gut sequentiell auf den Speicher zugreifen, wenn Sie Beispielmuster vorhersagen k√∂nnen (siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cache-Prefetching</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Der zuf√§llige Zugriff auf den Speicher ist dagegen sehr teuer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erweiterte Datenstrukturen sind sehr interessant, aber seien Sie vorsichtig. Moderne Computer erfordern die Verwendung von Cache-optimierten Algorithmen. Bei der Arbeit mit gro√üen Datenmengen, die nicht in L3 passen, wird die Optimierung √ºber die Anzahl der Treffer gegen√ºber der Optimierung √ºber die verwendete Speichermenge bevorzugt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Man kann mit Recht sagen, dass Bloom-Filter im L3-Cache eine hervorragende Leistung erbringen. Aber wenn nicht, dann sind sie schrecklich. Dies ist keine Neuigkeit: Bloom-Filter sind f√ºr die Speichermenge optimiert, nicht f√ºr die Anzahl der Aufrufe. Zum Beispiel siehe</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wissenschaftlicher Artikel √ºber Kuckucksfilter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine andere Sache sind endlose Diskussionen √ºber Hash-Funktionen. Ehrlich gesagt spielt dies in den meisten F√§llen keine Rolle. Die Kosten f√ºr das Z√§hlen selbst komplexer Hash-Funktionen scheinen im </font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergleich zu den Kosten f√ºr den wahlfreien Zugriff auf den Speicher gering zu sein. In unserem Fall bringt die Vereinfachung der Hash-Funktion nur einen geringen Vorteil. CPU-Zeit wird nur woanders verschwendet - auf Speicher warten! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Kollege sagt oft: ‚ÄûMan kann davon ausgehen, dass moderne Prozessoren unendlich schnell sind. Sie arbeiten mit unendlicher Geschwindigkeit, bis sie an der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wand der Erinnerung ruhen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . " </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schlie√ülich wiederholen Sie nicht meinen Fehler. Sie m√ºssen immer zuerst eine Profilerstellung durchf√ºhren</font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und schauen Sie sich den IPC-Z√§hler an (Anweisungen pro Zyklus). </font><font style="vertical-align: inherit;">Wenn es weniger als eins ist, bedeutet dies normalerweise, dass das Programm nicht mehr auf Speicher wartet. </font><font style="vertical-align: inherit;">Die optimalen Werte liegen √ºber zwei. </font><font style="vertical-align: inherit;">Dies bedeutet, dass die Arbeitslast haupts√§chlich auf der CPU liegt. </font><font style="vertical-align: inherit;">Leider ist der IPC bei meinen Aufgaben immer noch niedrig ...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberlegene mmuniq</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Hilfe von Kollegen habe ich eine verbesserte Version des mmuniq-Tools basierend auf einer Hash-Tabelle geschrieben. </font><font style="vertical-align: inherit;">Hier ist der Code:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es kann die Gr√∂√üe der Hash-Tabelle dynamisch √§ndern und unterst√ºtzt die Eingabe mit einer beliebigen Kardinalzahl. </font><font style="vertical-align: inherit;">Anschlie√üend werden die Daten in Paketen verarbeitet, wobei der Hinweis </font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der CPU </font><font style="vertical-align: inherit;">effektiv verwendet wird </font><font style="vertical-align: inherit;">, wodurch das Programm um 35-40% beschleunigt wird. </font><font style="vertical-align: inherit;">Seien Sie vorsichtig, eine reichliche Verwendung </font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des Codes f√ºhrt selten zu einer Wirkung. </font><font style="vertical-align: inherit;">Um diese Funktion nutzen zu k√∂nnen, habe ich die Algorithmen speziell neu angeordnet. </font><font style="vertical-align: inherit;">Mit allen Verbesserungen wurde die Ausf√ºhrungszeit auf 2,1 Sekunden reduziert:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e40/4df/9c4/e404df9c42a97be2f1051a69f98116e6.png"><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Ende</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Entwicklung eines grundlegenden Tools, das versucht, die Kombination 'sort / uniq' zu √ºbertreffen, hat einige verborgene Merkmale des modernen Computing aufgedeckt. </font><font style="vertical-align: inherit;">Nachdem wir ein wenig geschwitzt hatten, beschleunigten wir das Programm von mehr als zwei Minuten auf zwei Sekunden. </font><font style="vertical-align: inherit;">W√§hrend der Entwicklung haben wir die Verz√∂gerung beim Direktzugriff auf den Speicher sowie die Leistungsf√§higkeit cachefreundlicher Datenstrukturen kennengelernt. </font><font style="vertical-align: inherit;">Bizarre Datenstrukturen ziehen die Aufmerksamkeit auf sich, aber in der Praxis ist es oft effizienter, die Anzahl der zuf√§lligen Zugriffe auf den Speicher zu reduzieren.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de491116/index.html">Moderne Identifikationsstandards: OAuth 2.0, OpenID Connect, WebAuthn</a></li>
<li><a href="../de491118/index.html">Entwicklerherz: Devkits der 5. Konsolengeneration (Teil 1)</a></li>
<li><a href="../de491120/index.html">$ mol: 4 Jahre sp√§ter</a></li>
<li><a href="../de491122/index.html">Forensische Analyse von HiSuite-Backups</a></li>
<li><a href="../de491130/index.html">Vue Features zum Erinnern</a></li>
<li><a href="../de491134/index.html">5 Stufen der Unvermeidlichkeit der Annahme der ISO / IEC 27001-Zertifizierung. Negation</a></li>
<li><a href="../de491136/index.html">Projizieren von Inhalten in Angular oder verlorene ng-Inhaltsdokumentation</a></li>
<li><a href="../de491138/index.html">Satelliten- und Ansible Tower-Integration</a></li>
<li><a href="../de491146/index.html">UML f√ºr Entwickler</a></li>
<li><a href="../de491150/index.html">Wie ich Betr√ºger gehackt habe oder nur die Innenseiten von Phishing-Panels</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>