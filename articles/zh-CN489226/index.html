<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏿 🚚 🤞🏼 在C＃.NET中优化LINQ查询的方法 🥁 ❕ 🈁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="介绍
 在本文中，我们讨论了LINQ查询的一些优化技术。
 这是与LINQ查询相关的更多代码优化方法。
 
 众所周知，LINQ（语言集成查询）是一种用于查询数据源的简单便捷的语言。
 
 和LINQ到SQL是一个数据库管理系统数据接入技术。这是用于处理数据的强大工具，其中查询是通过声明性语言构造的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>在C＃.NET中优化LINQ查询的方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489226/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">介绍</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本文中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们讨论了</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LINQ查询的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一些优化技术</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是与</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LINQ查询</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相关的更多代码优化方法</font><font style="vertical-align: inherit;">。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
众所周知，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LINQ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（语言集成查询）是一种用于查询数据源的简单便捷的语言。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LINQ到SQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个数据库管理系统数据接入技术。这是用于处理数据的强大工具，其中查询是通过声明性语言构造的，然后</font><font style="vertical-align: inherit;">平台</font><font style="vertical-align: inherit;">会将其转换为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL查询</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并发送到已经执行的数据库服务器。在我们的例子中，DBMS是指</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MS SQL Server</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然而，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LINQ查询</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不会转换为最佳写入</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL查询</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是有经验的DBA可以用优化的所有细微差别写</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL查询</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最佳连接（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JOIN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）和结果过滤（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WHERE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用化合物和组条件时有许多细微差别</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在更换许多变化</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件</font><font style="vertical-align: inherit;">与</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXISTS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NOT IN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，&lt;&gt;与</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXISTS</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过临时表，CTE，表变量对结果进行中间缓存</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">带有说明和表提示</font><b><font style="vertical-align: inherit;">WITH</font></b><font style="vertical-align: inherit;">（...）</font><font style="vertical-align: inherit;">的子句（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OPTION</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用索引视图作为摆脱样本中多余数据读取的手段之一</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编译</font><b><font style="vertical-align: inherit;">LINQ查询</font></b><font style="vertical-align: inherit;">时</font><font style="vertical-align: inherit;">
，所产生的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL查询</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的主要性能瓶颈</font><font style="vertical-align: inherit;">是：</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将整个数据选择机制整合到一个请求中</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复制相同的代码块，最终导致多次读取数据</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的多组分条件组（逻辑“与”和“或”） - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AND</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在困难的条件相结合，导致一个事实，即优化器，其具有合适的非聚簇索引，通过必要的字段，最终开始由上述簇索引扫描（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INDEX SCAN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）按条件组</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子查询的深层嵌套使解析</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL语句</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和解析来自开发人员和</font><b><font style="vertical-align: inherit;">DBA的</font></b><font style="vertical-align: inherit;">查询计划</font><font style="vertical-align: inherit;">变得非常困难</font></font><b><font style="vertical-align: inherit;"></font></b></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优化方法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们直接传递给优化方法。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1）附加索引</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最好考虑在主采样表上使用过滤器，因为整个查询通常围绕一个或两个主表（应用程序-人员-操作）构建，并具有一组标准条件（IsClosed，Cancel，Enabled，Status）。对于确定的样本，创建相应的索引很重要。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从这些字段中进行选择时，此解决方案很有意义，从而可以将返回的集显着限制为查询。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，我们有500,000个应用程序。但是，只有2,000个活动条目。然后，正确选择的索引将使我们免于</font><font style="vertical-align: inherit;">在大型表上使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INDEX SCAN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并使我们能够通过非聚集索引快速选择数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也可以通过提示来分析查询计划或收集系统视图的统计信息来检测索引不足</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MS SQL Server</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sys.dm_db_missing_index_groups</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sys.dm_db_missing_index_group_stats</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sys.dm_db_missing_index_details</font></font></a></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除空间索引外，所有视图数据均包含有关缺失索引的信息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，索引和缓存通常是处理编写不佳的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LINQ查询</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL查询</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的影响的方法</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正如严酷的生活实践向企业展示的那样，在某个日期之前实现业务功能通常很重要。因此，经常将大量查询置于后台进行缓存。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这在一定程度上是合理的，因为用户并不总是需要最新数据，并且会发生可接受级别的用户界面响应。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种方法使您能够解决业务需求，但最终会降低信息系统的效率，只是延迟解决问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还应该记住，在添加新索引所必需的搜索过程中，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MS SQL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优化</font><font style="vertical-align: inherit;">建议</font><font style="vertical-align: inherit;">可能不正确，包括以下情况：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果已经存在具有相似字段集的索引</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果表中的字段由于索引限制而无法索引（有关更多信息，请参见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2）将属性合并为一个新属性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有时，可以通过引入一个新字段来替换同一表中发生一组条件的某些字段。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于状态字段而言尤其如此，状态字段按类型通常是按位或整数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
示例：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IsClosed = 0 AND Canceled = 0 AND Enabled = 0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">替换为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status = 1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，您可以输入整数属性Status，该属性是通过在表格中填写这些状态来提供的。</font><font style="vertical-align: inherit;">下一步是索引这个新属性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是性能问题的根本解决方案，因为我们需要的数据没有不必要的计算。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3）提交实现</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不幸的是，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LINQ查询</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不能直接使用临时表，CTE和表变量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，还有另一种针对这种情况进行优化的方法-这是索引视图。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一组条件（来自上面的示例）</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IsClosed = 0 AND Cancelled = 0 AND Enabled = 0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（或一组其他类似条件）成为在索引视图中使用它们的好选择，从而从大型集中缓存一小部分数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，在实现视图时有很多限制：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用子查询，</font><font style="vertical-align: inherit;">应使用</font><b><font style="vertical-align: inherit;">JOIN</font></b><font style="vertical-align: inherit;">替换</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXISTS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子句</font></font><b><font style="vertical-align: inherit;"></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不能使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNION</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNION ALL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXCEPTION</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INTERSECT子句</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您不能使用表提示和</font><b><font style="vertical-align: inherit;">OPTION</font></b><font style="vertical-align: inherit;">子句</font></font><b><font style="vertical-align: inherit;"></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无法循环工作</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不可能在一个视图中显示来自不同表的数据</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要的是要记住，使用索引视图的真正好处实际上只能通过对其进行索引来获得。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，在调用视图时，可能不会使用这些索引，并且要显式使用它们，必须指定</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WITH（NOEXPAND）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于</font><font style="vertical-align: inherit;">不可能</font><font style="vertical-align: inherit;">在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LINQ查询中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定义表提示，因此我们必须进行另一种表示-以下形式的“包装”：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> _ <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> MAT_VIEW <span class="hljs-keyword">WITH</span> (NOEXPAND);
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4）使用表格功能</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LINQ查询中，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大型子查询块或使用具有复杂结构的表示形式的块会形成具有非常复杂且不是最佳执行结构的最终查询。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LINQ查询</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中使用表函数的主要优点</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与视图一样，具有使用并指定为对象的能力，但是您可以传递一组输入参数：最后，</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从FROM FUNCTION（@ param1，@ param2 ...）</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
，可以实现灵活的数据采样</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用表函数时，没有上述索引视图这样的强限制：</font></font><br>
<br>
<ol>
<li> :<br>
 <b>LINQ</b>             .<br>
     .<br>
        ,          </li>
<li>  ,     , :<br>
<br>
<ul>
<li>    (   )</li>
<li>     </li>
<li> <b>UNION</b>  <b>EXISTS</b></li>
</ul></li>
</ol><br>
</li>
<li> <b>OPTION</b>  ,       <b>OPTION(MAXDOP N)</b>,    . :<br>
<br>
<ul>
<li>      <b>OPTION (RECOMPILE)</b></li>
<li>         ,    <b>OPTION (FORCE ORDER)</b></li>
</ul><br>
   <b>OPTION</b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>.<br>
</li>
<li>      :<br>
        (     ),         .<br>
,  ,     <b>WHERE</b>    <b>(a, b, c)</b>.<br>
<br>
       <b>a = 0 and b = 0</b>.<br>
<br>
,    <b>c</b>  .<br>
<br>
  <b>a = 0 and b = 0</b>          ,    <b></b>      .<br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此表功能可能是一个更好的选择。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，表函数更可预测，执行时间更恒定。</font></font><br>
</li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例子</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们考虑一个使用Questions数据库示例的示例实现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SELECT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查询</font><font style="vertical-align: inherit;">，它结合了多个表并使用一个视图（OperativeQuestions），该视图通过电子邮件验证</font><font style="vertical-align: inherit;">“活动查询”（[OperativeQuestions]）</font><font style="vertical-align: inherit;">的从属关系（通过</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXISTS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要求1</font></font></b><div class="spoiler_text"><pre><code class="sql hljs">(@p__linq__0 nvarchar(4000))<span class="hljs-keyword">SELECT</span>
<span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> [C1],<font></font>
[Extent1].[<span class="hljs-keyword">Id</span>] <span class="hljs-keyword">AS</span> [<span class="hljs-keyword">Id</span>],<font></font>
[Join2].[Object_Id] <span class="hljs-keyword">AS</span> [Object_Id],<font></font>
[Join2].[ObjectType_Id] <span class="hljs-keyword">AS</span> [ObjectType_Id],<font></font>
[Join2].[<span class="hljs-keyword">Name</span>] <span class="hljs-keyword">AS</span> [<span class="hljs-keyword">Name</span>],<font></font>
[Join2].[ExternalId] <span class="hljs-keyword">AS</span> [ExternalId]
<span class="hljs-keyword">FROM</span> [dbo].[Questions] <span class="hljs-keyword">AS</span> [Extent1]
<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> [Extent2].[Object_Id] <span class="hljs-keyword">AS</span> [Object_Id],<font></font>
[Extent2].[Question_Id] <span class="hljs-keyword">AS</span> [Question_Id], [Extent3].[ExternalId] <span class="hljs-keyword">AS</span> [ExternalId],<font></font>
[Extent3].[ObjectType_Id] <span class="hljs-keyword">AS</span> [ObjectType_Id], [Extent4].[<span class="hljs-keyword">Name</span>] <span class="hljs-keyword">AS</span> [<span class="hljs-keyword">Name</span>]
<span class="hljs-keyword">FROM</span> [dbo].[ObjectQuestions] <span class="hljs-keyword">AS</span> [Extent2]
<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> [dbo].[Objects] <span class="hljs-keyword">AS</span> [Extent3] <span class="hljs-keyword">ON</span> [Extent2].[Object_Id] = [Extent3].[<span class="hljs-keyword">Id</span>]
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> [dbo].[ObjectTypes] <span class="hljs-keyword">AS</span> [Extent4] 
<span class="hljs-keyword">ON</span> [Extent3].[ObjectType_Id] = [Extent4].[<span class="hljs-keyword">Id</span>] ) <span class="hljs-keyword">AS</span> [Join2] 
<span class="hljs-keyword">ON</span> [Extent1].[<span class="hljs-keyword">Id</span>] = [Join2].[Question_Id]
<span class="hljs-keyword">WHERE</span> ([Extent1].[AnswerId] <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">AND</span> (<span class="hljs-number">0</span> = [Extent1].[<span class="hljs-keyword">Exp</span>]) <span class="hljs-keyword">AND</span> ( <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span>
<span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> [C1]
<span class="hljs-keyword">FROM</span> [dbo].[OperativeQuestions] <span class="hljs-keyword">AS</span> [Extent5]
<span class="hljs-keyword">WHERE</span> (([Extent5].[Email] = @p__linq__0) <span class="hljs-keyword">OR</span> (([Extent5].[Email] <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>) 
<span class="hljs-keyword">AND</span> (@p__linq__0 <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>))) <span class="hljs-keyword">AND</span> ([Extent5].[<span class="hljs-keyword">Id</span>] = [Extent1].[<span class="hljs-keyword">Id</span>])<font></font>
));<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该视图具有相当复杂的结构：它具有子查询联接和使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DISTINCT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">排序的功能</font><font style="vertical-align: inherit;">，在一般情况下，这是一种相当耗费资源的操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从OperativeQuestions中选择了大约一万条记录。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该查询的主要问题是，对于来自外部查询的记录，在[OperativeQuestions]视图上执行内部子查询，这应将输出样本（通过</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXISTS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">限制为[Email] = @ p__linq__0的</font><font style="vertical-align: inherit;">数百条记录。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
似乎子查询应该一次通过[Email] = @ p__linq__0计算记录，然后应该通过id c Questions连接这几百条记录，查询将很快。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，所有表都是串联的：检查两个ID问题是否符合OperativeQuestions中的ID，并过滤电子邮件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，该请求适用于所有成千上万个OperativeQuestions记录，并且您仅需要在Email上关注的数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OperativeQuestions查看文本：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请求编号2</font></font></b><div class="spoiler_text"><pre><code class="sql hljs"> 
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> [dbo].[OperativeQuestions]
<span class="hljs-keyword">AS</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> Q.Id, USR.email <span class="hljs-keyword">AS</span> Email
<span class="hljs-keyword">FROM</span>            [dbo].Questions <span class="hljs-keyword">AS</span> Q <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span>
                         [dbo].ProcessUserAccesses <span class="hljs-keyword">AS</span> BPU <span class="hljs-keyword">ON</span> BPU.ProcessId = CQ.Process_Id 
<span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">APPLY</span>
                     (<span class="hljs-keyword">SELECT</span>   <span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> HasNoObjects
                      <span class="hljs-keyword">WHERE</span>   <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>
                                    (<span class="hljs-keyword">SELECT</span>   <span class="hljs-number">1</span>
                                     <span class="hljs-keyword">FROM</span>     [dbo].ObjectUserAccesses <span class="hljs-keyword">AS</span> BOU
                                     <span class="hljs-keyword">WHERE</span>   BOU.ProcessUserAccessId = BPU.[<span class="hljs-keyword">Id</span>] <span class="hljs-keyword">AND</span> BOU.[<span class="hljs-keyword">To</span>] <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>)<font></font>
) <span class="hljs-keyword">AS</span> BO <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span>
                         [dbo].Users <span class="hljs-keyword">AS</span> USR <span class="hljs-keyword">ON</span> USR.Id = BPU.UserId
<span class="hljs-keyword">WHERE</span>        CQ.[<span class="hljs-keyword">Exp</span>] = <span class="hljs-number">0</span> <span class="hljs-keyword">AND</span> CQ.AnswerId <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">AND</span> BPU.[<span class="hljs-keyword">To</span>] <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span> 
<span class="hljs-keyword">AND</span> (BO.HasNoObjects = <span class="hljs-number">1</span> <span class="hljs-keyword">OR</span>
              <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span>   <span class="hljs-number">1</span>
                           <span class="hljs-keyword">FROM</span>   [dbo].ObjectUserAccesses <span class="hljs-keyword">AS</span> BOU <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span>
                                      [dbo].ObjectQuestions <span class="hljs-keyword">AS</span> QBO 
                                                  <span class="hljs-keyword">ON</span> QBO.[Object_Id] =BOU.ObjectId
                               <span class="hljs-keyword">WHERE</span>  BOU.ProcessUserAccessId = BPU.Id 
                               <span class="hljs-keyword">AND</span> BOU.[<span class="hljs-keyword">To</span>] <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">AND</span> QBO.Question_Id = CQ.Id));
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DbContext中的原始映射表示（EF Core 2）</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">public class QuestionsDbContext : DbContext<font></font>
{<font></font>
    //...<font></font>
    public DbQuery&lt;OperativeQuestion&gt; OperativeQuestions { get; set; }<font></font>
    //...<font></font>
    protected override void OnModelCreating(ModelBuilder modelBuilder)<font></font>
    {<font></font>
        modelBuilder.Query&lt;OperativeQuestion&gt;().ToView("OperativeQuestions");<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原始LINQ查询</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">var businessObjectsData = await context<font></font>
    .OperativeQuestions<font></font>
    .Where(x =&gt; x.Email == Email)<font></font>
    .Include(x =&gt; x.Question)<font></font>
    .Select(x =&gt; x.Question)<font></font>
    .SelectMany(x =&gt; x.ObjectQuestions,<font></font>
                (x, bo) =&gt; new<font></font>
                {<font></font>
                    Id = x.Id,<font></font>
                    ObjectId = bo.Object.Id,<font></font>
                    ObjectTypeId = bo.Object.ObjectType.Id,<font></font>
                    ObjectTypeName = bo.Object.ObjectType.Name,<font></font>
                    ObjectExternalId = bo.Object.ExternalId<font></font>
                })<font></font>
    .ToListAsync();<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种特殊情况下，可以考虑在不进行基础结构更改的情况下解决此问题，而不引入带有现成结果的单独表（“活动查询”），为此需要一种机制来填充其数据并保持最新。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管这是一个很好的解决方案，但是还有另一种选项可以优化此任务。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主要目标是通过OperativeQuestions视图中的[Email] = @ p__linq__0来缓存条目。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们在数据库中输入表函数[dbo]。[OperativeQuestionsUserMail]。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
发送电子邮件作为输入参数，我们返回值表：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3号要求</font></font></b><div class="spoiler_text"><pre><code class="sql hljs">
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> [dbo].[OperativeQuestionsUserMail]<font></font>
(<font></font>
    @Email  <span class="hljs-keyword">nvarchar</span>(<span class="hljs-number">4000</span>)<font></font>
)<font></font>
<span class="hljs-keyword">RETURNS</span>
@tbl <span class="hljs-keyword">TABLE</span><font></font>
(<font></font>
    [<span class="hljs-keyword">Id</span>]           uniqueidentifier,<font></font>
    [Email]      <span class="hljs-keyword">nvarchar</span>(<span class="hljs-number">4000</span>)<font></font>
)<font></font>
<span class="hljs-keyword">AS</span>
<span class="hljs-keyword">BEGIN</span>
        <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> @tbl ([<span class="hljs-keyword">Id</span>], [Email])
        <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">Id</span>, @Email
        <span class="hljs-keyword">FROM</span> [OperativeQuestions]  <span class="hljs-keyword">AS</span> [x] <span class="hljs-keyword">WHERE</span> [x].[Email] = @Email;<font></font>
     <font></font>
    RETURN;<font></font>
<span class="hljs-keyword">END</span>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这将返回具有预定义数据结构的值表。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了使对OperativeQuestionsUserMail的查询达到最佳，具有最佳查询计划，需要严格的结构，而不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RETURNS TABLE AS RETURN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，所需的请求1转换为请求4：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请求编号4</font></font></b><div class="spoiler_text"><pre><code class="sql hljs">(@p__linq__0 nvarchar(4000))<span class="hljs-keyword">SELECT</span>
<span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> [C1],<font></font>
[Extent1].[<span class="hljs-keyword">Id</span>] <span class="hljs-keyword">AS</span> [<span class="hljs-keyword">Id</span>],<font></font>
[Join2].[Object_Id] <span class="hljs-keyword">AS</span> [Object_Id],<font></font>
[Join2].[ObjectType_Id] <span class="hljs-keyword">AS</span> [ObjectType_Id],<font></font>
[Join2].[<span class="hljs-keyword">Name</span>] <span class="hljs-keyword">AS</span> [<span class="hljs-keyword">Name</span>],<font></font>
[Join2].[ExternalId] <span class="hljs-keyword">AS</span> [ExternalId]
<span class="hljs-keyword">FROM</span> (
    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">Id</span>, Email <span class="hljs-keyword">FROM</span> [dbo].[OperativeQuestionsUserMail] (@p__linq__0)<font></font>
) <span class="hljs-keyword">AS</span> [Extent0]
<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> [dbo].[Questions] <span class="hljs-keyword">AS</span> [Extent1] <span class="hljs-keyword">ON</span>([Extent0].Id=[Extent1].Id)
<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> [Extent2].[Object_Id] <span class="hljs-keyword">AS</span> [Object_Id], [Extent2].[Question_Id] <span class="hljs-keyword">AS</span> [Question_Id], [Extent3].[ExternalId] <span class="hljs-keyword">AS</span> [ExternalId], [Extent3].[ObjectType_Id] <span class="hljs-keyword">AS</span> [ObjectType_Id], [Extent4].[<span class="hljs-keyword">Name</span>] <span class="hljs-keyword">AS</span> [<span class="hljs-keyword">Name</span>]
<span class="hljs-keyword">FROM</span> [dbo].[ObjectQuestions] <span class="hljs-keyword">AS</span> [Extent2]
<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> [dbo].[Objects] <span class="hljs-keyword">AS</span> [Extent3] <span class="hljs-keyword">ON</span> [Extent2].[Object_Id] = [Extent3].[<span class="hljs-keyword">Id</span>]
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> [dbo].[ObjectTypes] <span class="hljs-keyword">AS</span> [Extent4] 
<span class="hljs-keyword">ON</span> [Extent3].[ObjectType_Id] = [Extent4].[<span class="hljs-keyword">Id</span>] ) <span class="hljs-keyword">AS</span> [Join2] 
<span class="hljs-keyword">ON</span> [Extent1].[<span class="hljs-keyword">Id</span>] = [Join2].[Question_Id]
<span class="hljs-keyword">WHERE</span> ([Extent1].[AnswerId] <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">AND</span> (<span class="hljs-number">0</span> = [Extent1].[<span class="hljs-keyword">Exp</span>]);
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在DbContext（EF Core 2）中映射视图和函数</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">public class QuestionsDbContext : DbContext<font></font>
{<font></font>
    //...<font></font>
    public DbQuery&lt;OperativeQuestion&gt; OperativeQuestions { get; set; }<font></font>
    //...<font></font>
    protected override void OnModelCreating(ModelBuilder modelBuilder)<font></font>
    {<font></font>
        modelBuilder.Query&lt;OperativeQuestion&gt;().ToView("OperativeQuestions");<font></font>
    }<font></font>
}<font></font>
 <font></font>
public static class FromSqlQueries<font></font>
{<font></font>
    public static IQueryable&lt;OperativeQuestion&gt; GetByUserEmail(this DbQuery&lt;OperativeQuestion&gt; source, string Email)<font></font>
        =&gt; source.FromSql($"SELECT Id, Email FROM [dbo].[OperativeQuestionsUserMail] ({Email})");<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最终LINQ查询</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">var businessObjectsData = await context<font></font>
    .OperativeQuestions<font></font>
    .GetByUserEmail(Email)<font></font>
    .Include(x =&gt; x.Question)<font></font>
    .Select(x =&gt; x.Question)<font></font>
    .SelectMany(x =&gt; x.ObjectQuestions,<font></font>
                (x, bo) =&gt; new<font></font>
                {<font></font>
                    Id = x.Id,<font></font>
                    ObjectId = bo.Object.Id,<font></font>
                    ObjectTypeId = bo.Object.ObjectType.Id,<font></font>
                    ObjectTypeName = bo.Object.ObjectType.Name,<font></font>
                    ObjectExternalId = bo.Object.ExternalId<font></font>
                })<font></font>
    .ToListAsync();<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
执行时间的顺序从200-800 ms减少到2-20 ms等，即快了十倍。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们取更多的平均值，那么将得到8毫秒而不是350毫秒。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从明显的优点中，我们还得到：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总体上减少了阅读负荷，</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大大降低了阻止概率</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将平均阻塞时间减少到可接受的值</font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过</font><b><font style="vertical-align: inherit;">LINQ</font></b><font style="vertical-align: inherit;"> 
对</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MS SQL数据库</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的调用的优化和微调</font><font style="vertical-align: inherit;">是可以解决的问题。</font><font style="vertical-align: inherit;">
在这项工作中，注意和保持一致性非常重要。</font><font style="vertical-align: inherit;">
在过程开始时：</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有必要检查查询所使用的数据（值，所选数据类型）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确索引此数据</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查表之间连接条件的正确性</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在下一次迭代中，优化显示：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请求的依据，并确定请求的主过滤器</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重复类似的查询块和相交条件</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在用于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL Server</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的SSMS或其他GUI中</font><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL查询</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本身已进行了优化</font><font style="vertical-align: inherit;">（分配了中间数据存储，使用该存储构建了结果查询（可能有多个））</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在最后阶段，以生成的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL查询</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为基础</font><font style="vertical-align: inherit;">，重新构建</font><b><font style="vertical-align: inherit;">LINQ查询</font></b><font style="vertical-align: inherit;">结构</font></font><b><font style="vertical-align: inherit;"></font></b></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，生成的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LINQ查询的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构应与</font><font style="vertical-align: inherit;">第3段中</font><font style="vertical-align: inherit;">确定的最佳</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL查询的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构相同</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">致谢</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非常感谢同事 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工作机会</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 和 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alex_ozr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来自</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的文章帮助。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN489206/index.html">用Patroni崩溃的故事，或如何删除PostgreSQL集群</a></li>
<li><a href="../zh-CN489210/index.html">带有示例的Linux代码性能测试</a></li>
<li><a href="../zh-CN489212/index.html">1C-Bitrix通过要求提交其个人数据来防止退订新闻通讯</a></li>
<li><a href="../zh-CN489214/index.html">在iOS上测试本地化的现代方法</a></li>
<li><a href="../zh-CN489218/index.html">天真。超级：简单游戏的代码和架构</a></li>
<li><a href="../zh-CN489228/index.html">银行语音机器人-有史以来最糟糕的用户体验</a></li>
<li><a href="../zh-CN489230/index.html">Web应用程序的性能是什么？</a></li>
<li><a href="../zh-CN489232/index.html">回到手机的未来II</a></li>
<li><a href="../zh-CN489234/index.html">如何成功通过任何渗透测试（错误建议）</a></li>
<li><a href="../zh-CN489236/index.html">春季：寻找背景</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>