<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☎️ 🔌 🎮 穏やかな穏やかな争い 👩🏿‍⚕️ 🏨 🍀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="3年前、Swift言語のDIライブラリーに関する記事を書きました。その時以来、ライブラリは大きく変化し、Swinjectにとって最高の価値のある競争相手になり、多くの点でそれを超えています。この記事はライブラリーの機能を取り上げていますが、理論的な考慮事項もあります。したがって、DI、DIP、IoC...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>穏やかな穏やかな争い</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457188/"><img src="https://habrastorage.org/files/c6d/c89/5d0/c6dc895d02324b96bc679f41228ab6bf.png" align="right" width="140" alt="ライブラリアイコン"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3年前、</font><font style="vertical-align: inherit;">Swift言語のDIライブラリー</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に関する記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を書きまし</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">た</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">その時以来、ライブラリは大きく変化し、</font><font style="vertical-align: inherit;">Swinjectにとって</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最高の</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">価値のある競争相手になり、多くの点でそれを超えています。</font><font style="vertical-align: inherit;">この記事はライブラリーの機能を取り上げていますが、理論的な考慮事項もあります。</font><font style="vertical-align: inherit;">したがって、DI、DIP、IoCのトピックに興味がある人、またはSwinjectとSwinjectのどちらを選択するかについて、カットをお願いします。</font></font><br clear="all">
<a name="habracut"></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DIP、IoCとは何ですか。</font></font></h1><br>
<h2><font style="vertical-align: inherit;"></font><abbr title="依存関係の逆転の原則"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DIP</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><abbr title="Inversion of Control"><font style="vertical-align: inherit;">IoCの</font></abbr><font style="vertical-align: inherit;">理論</font></font><abbr title="制御の反転"><font style="vertical-align: inherit;"></font></abbr></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理論はプログラミングにおいて最も重要なコンポーネントの1つです。</font><font style="vertical-align: inherit;">はい、教育を受けなくてもコードを書くことができますが、それにもかかわらず、プログラマーは常に記事を読んだり、さまざまなプラクティスに興味を持っています。</font><font style="vertical-align: inherit;">つまり、何らかの方法でそれを実践するために理論的な知識を得ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人々がインタビューを求めるのを好むトピックの1つは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOLID</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">彼に関する記事はまったくありません。心配しないでください。</font><font style="vertical-align: inherit;">しかし、それは私の図書館と密接に関連しているので、私たちは一通の手紙が必要です。</font><font style="vertical-align: inherit;">これは「D」という文字-依存関係の逆転の原則です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
依存関係の逆転の原則は次のように述べています：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上位レベルのモジュールは、下位レベルのモジュールに依存するべきではありません。</font><font style="vertical-align: inherit;">どちらのタイプのモジュールも抽象化に依存する必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象化は詳細に依存すべきではありません。</font><font style="vertical-align: inherit;">詳細は抽象化に依存する必要があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの人々は、プロトコル/インターフェースを使用する場合、自動的にこの原則を順守すると誤解しますが、これは完全に真実ではありません。</font></font><br>
<br>
<abbr title="上位レベルのモジュールは、下位レベルのモジュールに依存するべきではありません。 どちらのタイプのモジュールも抽象化に依存する必要があります。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のステートメント</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、モジュール間の依存関係について何か</font><abbr title="         .       "><font style="vertical-align: inherit;">を</font></abbr><font style="vertical-align: inherit;">述べています-モジュールは抽象化に依存する必要があります。待って、抽象化とは何ですか？ -抽象化とは何かではなく、抽象化とは何かを自問することをお勧めします。つまり、プロセスとは何かを理解する必要があり、このプロセスの結果は抽象化されます。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象化</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、本質的で定期的な兆候を強調するために、必須ではない関係者、プロパティ、関係からの認識のプロセスにおける注意散漫です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じオブジェクトは、目的に応じて、異なる抽象化を持つことができます。たとえば、所有者の視点から見たマシンには、色、優雅さ、利便性という重要な特性があります。しかし、整備士の観点から見ると、ブランド、モデル、改造、燃費、事故への参加など、すべてが多少異なります。 1つのオブジェクトに対する2つの異なる抽象化、つまりマシンが指定されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Swiftでは抽象化にプロトコルを使用するのが慣例ですが、これは必須ではないことに注意してください。クラスを作成したり、クラスからパブリックメソッドのセットを割り当てたり、実装の詳細を非公開にしたりする必要はありません。抽象化に関しては、何も壊れていません。 「抽象化は言語に結び付けられていない」という重要な論文を覚えておく必要があります。これは頭の中で絶えず起こるプロセスであり、これがコードにどのように転送されるかはそれほど重要ではありません。ここでも言及できます</font></font><abbr title="データのマージと非表示"><font style="vertical-align: inherit;"></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">言語に関連付けられているものの例としての</font><abbr title="データのマージと非表示"><font style="vertical-align: inherit;">カプセル化</font></abbr><font style="vertical-align: inherit;">。各言語には、それを提供するための独自の手段があります。 Swiftでは、これらはクラス、アクセスフィールド、プロトコルです。 Obj-Cインターフェース、プロトコル、およびhファイルとmファイルの分離。</font></font><br>
<br>
<abbr title="抽象化は詳細に依存すべきではありません。 詳細は抽象化に依存する必要があります。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目のステートメントは</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、無視されるか誤解されているため、より興味深いものです。抽象化と詳細の相互作用について話しますが、詳細とは何ですか？詳細はプロトコルを実装するクラスであるという誤解があります-はい、これは真実ですが、完全ではありません。詳細はプログラミング言語に関連付けられていないことを理解する必要があります。C言語にはプロトコルもクラスもありませんが、この原則はそれにも作用します。キャッチとは何かを理論的に説明するのは難しいので、2つの例を挙げて、2番目の例の方が正しい理由を証明してみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスの車とクラスのエンジンがあるとします。たまたまそれらを接続する必要がありました-マシンにはエンジンが含まれています。私たちは有能なプログラマーとして、プロトコルエンジンを選択し、プロトコルを実装して、プロトコルの実装をマシンクラスに渡します。すべてが適切で適切なようです。これで、エンジンの実装を簡単に置き換えることができ、何かが壊れるとは思わないようにすることができます。次に、エンジンメカニックが回路に追加されます。彼は車とはまったく異なるエンジンの特性に興味を持っています。現在、プロトコルを拡張しており、当初よりも多くの機能が含まれています。自動車の所有者やエンジンを生産する工場などで、この話は繰り返されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yh/hh/v1/yhhhv1kv5yvffc1hcoqu489pfqi.png" alt="反転なし"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、推論のエラーはどこにありますか？問題は、プロトコルが利用可能であるにもかかわらず、説明された接続が実際には「詳細」-「詳細」であることです。むしろ、エンジンの名前とプロトコルの場所で。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、</font><font style="vertical-align: inherit;">他</font><font style="vertical-align: inherit;">の</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正しい</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプションを</font><font style="vertical-align: inherit;">検討し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前と同様に、エンジンと車の2つのクラスがあります。以前と同様に、それらは接続されている必要があります。しかし今、私たちはプロトコル「車のエンジン」または「車のハート」を発表しています。私たちは、自動車がエンジンから必要とする特性のみをそれに配置します。また、プロトコルを「エンジン」実装の隣ではなく、マシンの隣に配置します。さらに、メカニックが必要な場合は、別のプロトコルを作成してエンジンに実装する必要があります。何も変わっていないように見えますが、アプローチは根本的に異なります。問題は名前ではそれほど多くありませんが、プロトコルが誰に属し、プロトコルが何であるか-「抽象」または「詳細」です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wb/xl/qw/wbxlqwjb7ltz4pqvek-gybtxc00.png" alt="反転は"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの議論は明白でないかもしれないので、今度は別のケースとの類比を描きましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックエンドがあり、そこからいくつかの機能が必要です。</font><font style="vertical-align: inherit;">バックエンドは、大量のデータを含む大きなメソッドを提供し、「1000のうち3つのフィールドが必要です」と述べています。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小さな話</font></font></b><div class="spoiler_text">  ,    .     —  backend     .  ,       backend    10         API.             ,      .                   .     100 , 20%     ,       20-30     .    ,     800   ,        1000.</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あまり良くないと思いませんか？</font><font style="vertical-align: inherit;">通常、バックエンドはフロントエンドの特定のタスクのメソッドを記述し、フロントエンドはこれらのメソッドの顧客/ユーザーです。</font><font style="vertical-align: inherit;">うーん...しかし、あなたがそれについて考えるならば、バックエンドはエンジンであり、フロントエンドは車です-機械はいくつかのエンジン特性を必要とし、エンジンは車の特性を与える必要はありません。</font><font style="vertical-align: inherit;">それなのに、なぜそれでも、プロトコルエンジンを作成し続け、マシンではなくエンジンの実装の近くに配置するのでしょうか。</font><font style="vertical-align: inherit;">それはすべてスケールに関するものです。ほとんどのiOSプログラムでは、そのようなソリューションが問題になるほど機能を拡張しなければならないことは非常にまれです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、</font></font><abbr title="依存性注入"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DIとは</font></font></abbr></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
概念の置き換えがあります-DIはDIPと非常に密接に交差するという事実にもかかわらず、DIはDIPの省略形ではなく、完全に異なる省略形です。 DIは依存性注入または依存性注入であり、反転ではありません。反転は、クラスとプロトコルが互いにどのように相互作用するべきかについて話し、実装はそれらをどこから得るかを教えてくれます。一般的には、さまざまな方法で実装できます。依存関係が発生するところから始めます。コンストラクター、プロパティ、メソッド。最後に、それらを作成した人たちと、このプロセスがいかに自動化されているかについて説明します。アプローチは異なりますが、私の意見では、最も便利なのは依存関係注入のためのコンテナーです。要するに、それらの全体的な意味は単純なルールに要約されます。それを実装する場所と方法をコンテナに通知し、その後すべてが独立して実装されます。このアプローチは、「依存関係の実際の実装」に対応します。これは、依存関係が導入されたクラスが、これがどのように発生するかについて何も知らない、つまりパッシブである場合です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの言語では、この実装に次のアプローチが使用されます。個々のクラス/ファイルでは、言語構文を使用した実装ルールが記述され、その後、それらがコンパイルされて自動的に実装されます。魔法はありません-自動的には何も起こりません。ライブラリが言語の基本的な手段と密接に統合され、作成メソッドをオーバーロードするだけです。したがって、Swift / Obj-Cの場合、開始点はUIViewControllerであり、ライブラリはストーリーボードから作成されたViewControllerに簡単に統合できます。確かに、ストーリーボードを使用しない場合は、作業の一部をペンで行う必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ああそうです。ほとんど忘れていました。主な質問に対する答えです。「なぜこれが必要なのですか？」</font><font style="vertical-align: inherit;">疑いもなく、依存性注入を自分で処理し、すべてをペンで処方することができます。</font><font style="vertical-align: inherit;">しかし、グラフが大きくなると問題が発生します。クラス間の接続が多いことに言及する必要があります。コードが非常に大きくなり始めます。</font><font style="vertical-align: inherit;">したがって、再帰的に（さらには循環的に）依存関係を自動的に実装するライブラリは、この処理を自分自身で行い、おまけとしてその有効期間を制御します。</font><font style="vertical-align: inherit;">つまり、ライブラリは自然なことを超えて何もしません-それは単に開発者の生活を単純化します。</font><font style="vertical-align: inherit;">確かに、そのようなライブラリを1日で作成できるとは考えないでください。特定のケースのすべての依存関係をペンで書くことは1つであり、普遍的かつ正確に実装するようにコンピューターに教えることも1つのことです。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図書館の歴史</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
話を短くしなければ話は完成しません。ベータ版からライブラリをフォローする場合、それはあなたにとってそれほど興味深いものではありませんが、それを初めて見る人にとっては、それがどのように表示され、著者が遵守した目標（つまり）を理解する価値があると思います。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライブラリは私の2番目のプロジェクトで、自己教育の目的でSwiftで書くことにしました。それ以前は、ロガーをなんとか書くことができましたが、ロガーを公開することはしませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、DIを使用すると、この話はより興味深いものになります。</font><font style="vertical-align: inherit;">私がそれを始めたとき、私はSwiftで1つのライブラリー-Swinjectだけを見つけることができました。</font><font style="vertical-align: inherit;">当時、彼女には500個の星と、サイクルが通常は処理されないバグがありました。</font><font style="vertical-align: inherit;">私はこれをすべて見て、...私の行動は私のお気に入りのフレーズである「それからOstapは苦しみました」で最もよく説明されています。</font><font style="vertical-align: inherit;">そして今、ほぼ3年後、私は目標が達成されたと自信を持って言えます。現時点では、DITranquillityは私の世界観で最高です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
良いDIライブラリとは何かを理解しましょう：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての基本的な実装を提供する必要があります：コンストラクター、プロパティ、メソッド</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジネスコードには影響しません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼女は何が悪かったのかを明確に説明する必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼女は、実行時ではなく、エラーがある場所を事前に理解する必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本的なツール（ストーリーボード）と統合する必要があります</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡潔で簡潔な構文にする必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼女はすべてを迅速かつ効率的に行う必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（オプション）階層的である必要があります</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライブラリの開発を通じて私が遵守しようとするのは、これらの原則です。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリの機能と利点</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、リポジトリへのリンク：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/ivlevAstef/DITranquillity</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
私にとって非常に重要な主な競争上の利点は、ライブラリが起動時のエラーについて話し合うことです。アプリケーションを起動して目的の関数を呼び出した後、すべての既存および潜在的な問題が報告されます。これは、正確にライブラリの「穏やかな」という名前の意味です。実際、プログラムを起動した後、ライブラリは、必要なすべての依存関係が存在し、解決できないサイクルがないことを保証します。あいまいなところがある場合、ライブラリは潜在的な問題がある可能性があることを警告します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは私には問題なく聞こえます。プログラムの実行中にクラッシュは発生しません。プログラマが何かを忘れた場合は、すぐに報告されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ログ機能を使用して問題を記述します。これを使用することを強くお勧めします。</font><font style="vertical-align: inherit;">ロギングには、エラー、警告、情報、詳細の4つのレベルがあります。</font><font style="vertical-align: inherit;">最初の3つは非常に重要です。</font><font style="vertical-align: inherit;">後者はそれほど重要ではありません-彼は起こるすべてを書きます-どのオブジェクトが登録されたか、どのオブジェクトが導入され始めたか、どのオブジェクトが作成されたかなど。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これはライブラリが誇るすべてではありません。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全なスレッドセーフ-どの操作もどのスレッドからでも実行でき、すべてが機能します。</font><font style="vertical-align: inherit;">ほとんどの人はこれを必要としないため、スレッドセーフの観点から、実行速度を最適化するための作業が行われました。</font><font style="vertical-align: inherit;">しかし、競合他社のライブラリは、約束にかかわらず、同時にオブジェクトの登録と受信を開始すると機能しなくなります</font></font></li>
<li>  .    DITranquillity        .       . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  </a></li>
<li>  –     Swinject + SwinjectStoryboad + SwinjectAutoregistration,      </li>
<li>,  ,    </li>
<li>.   ,     ,    ,             .             ,        ,    </li>
</ul><br>
<h1></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは始めましょう。</font><font style="vertical-align: inherit;">前回のように、プロジェクトは考慮されます：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SampleHabr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">具体的には例を変更し始めなかったので、すべての変更点を比較できます。</font><font style="vertical-align: inherit;">また、サンプルにはライブラリの多くの機能が表示されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
万が一、誤解のないように、プロジェクトが展示されているため、多くの機能を利用しています。</font><font style="vertical-align: inherit;">しかし、ライブラリを簡単な方法で使用することに煩わされることはありません。ダウンロード、コンテナの作成、いくつかのクラスの登録、コンテナの使用などです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初にフレームワークを作成する必要があります（オプション）：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppFramework</span>: <span class="hljs-title">DIFramework</span> </span>{ <span class="hljs-comment">//  </span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">load</span><span class="hljs-params">(container: DIContainer)</span></span> {
     <span class="hljs-comment">//    </span><font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、プログラムの開始時に、このフレームワークを追加してコンテナを作成します。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">let</span> container = <span class="hljs-type">DIContainer</span>() <span class="hljs-comment">//  </span>
container.append(framework: <span class="hljs-type">AppFramework</span>.<span class="hljs-keyword">self</span>)<font></font>
<font></font>
<span class="hljs-comment">//     .</span>
<span class="hljs-comment">//          ifdef DEBUG      ,         ,     .</span>
<span class="hljs-keyword">if</span> !container.validate() { 
   <span class="hljs-built_in">fatalError</span>()<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストーリーボード</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、基本的な画面を作成する必要があります。</font><font style="vertical-align: inherit;">通常、これにはストーリーボードが使用され、この例ではそれを使用しますが、UIViewControllersを使用することに煩わされる人はいません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、ストーリーボードを登録する必要があります。</font><font style="vertical-align: inherit;">これを行うには、ストーリーボードが登録された「パーツ」（オプション-フレームワーク内のすべてのコードを記述できます）を作成します。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">import</span> DITranquillity<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppPart</span>: <span class="hljs-title">DIPart</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">load</span><span class="hljs-params">(container: DIContainer)</span></span> {<font></font>
    container.registerStoryboard(name: <span class="hljs-string">"Main"</span>, bundle: <span class="hljs-literal">nil</span>)<font></font>
      .lifetime(.single) <span class="hljs-comment">//   -    .</span><font></font>
  }<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてAppFrameworkにパーツを追加します：</font></font><br>
<pre><code class="swift hljs">container.append(part: <span class="hljs-type">AppPart</span>.<span class="hljs-keyword">self</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、ライブラリにはStoryboardを登録するための便利な構文があり、使用することを強くお勧めします。</font><font style="vertical-align: inherit;">原則として、このメソッドがなくても同等のコードを記述できますが、サイズが大きくなり、StoryboardReferencesをサポートできなくなります。</font><font style="vertical-align: inherit;">つまり、このストーリーボードは別のストーリーボードでは機能しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あとは、ストーリーボードを作成して開始画面を表示するだけです。</font><font style="vertical-align: inherit;">これは、コンテナをチェックした後、AppDelegateで行われます。</font></font><br>
<br>
<pre><code class="swift hljs">window = <span class="hljs-type">UIWindow</span>(frame: <span class="hljs-type">UIScreen</span>.main.bounds)<font></font>
<font></font>
<span class="hljs-comment">///  Storyboard</span>
<span class="hljs-keyword">let</span> storyboard: <span class="hljs-type">UIStoryboard</span> = container.resolve(name: <span class="hljs-string">"Main"</span>)<font></font>
<font></font>
window!.rootViewController = storyboard.instantiateInitialViewController()<font></font>
window!.makeKeyAndVisible()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライブラリを使用したスト​​ーリーボードの作成は、通常ほど複雑ではありません。</font><font style="vertical-align: inherit;">この例では、ストーリーボードが1つしかないため、名前を忘れてしまった可能性があります。ライブラリは、その名前を想定していると推測していました。</font><font style="vertical-align: inherit;">しかし、いくつかのプロジェクトではストーリーボードがたくさんあるので、もう一度名前を見逃さないでください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレゼンターとViewController</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画面自体に移動します。複雑なアーキテクチャでプロジェクトをロードするのではなく、通常のMVPを使用します。さらに、私はプレゼンターのためのプロトコルを作成しないので、私はとても怠惰です。プロトコルは別のクラスで少し遅れますが、PresenterとViewControllerを登録してリンクする方法を示すことが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、次のコードをAppPartに追加します。</font></font><br>
<br>
<pre><code class="swift hljs">container.register(<span class="hljs-type">YourPresenter</span>.<span class="hljs-keyword">init</span>)<font></font>
<font></font>
container.register(<span class="hljs-type">YourViewController</span>.<span class="hljs-keyword">self</span>)<font></font>
  .injection(\.presenter) <span class="hljs-comment">//  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの3行により、2つのクラスを登録し、それらの間の接続を確立できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好奇心旺盛な人は不思議に思うかもしれません-なぜSwinjectが別のライブラリーに持っている構文がプロジェクトの主なものになっているのですか？</font><font style="vertical-align: inherit;">答えは目標にあります。この構文のおかげで、ライブラリはすべてのリンクを実行時に計算するのではなく、事前に保存します。</font><font style="vertical-align: inherit;">この構文により、他のライブラリでは利用できない多くの機能にアクセスできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションを起動すると、すべてが機能し、すべてのクラスが作成されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーからデータを受信するためのクラスとプロトコルを追加する必要があります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Server</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">get</span><span class="hljs-params">(method: String)</span></span> -&gt; <span class="hljs-type">Data?</span><font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerImpl</span>: <span class="hljs-title">Server</span> </span>{<font></font>
  <font></font>
  <span class="hljs-keyword">init</span>(domain: <span class="hljs-type">String</span>) {<font></font>
    ...<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">get</span><span class="hljs-params">(method: String)</span></span> -&gt; <span class="hljs-type">Data?</span> {<font></font>
    ...<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
美しさのために、サーバー用に別個のServerPart DIクラスを作成し、そこに登録します。</font><font style="vertical-align: inherit;">これは必須ではなく、コンテナに直接登録できますが、簡単な方法を探しているわけではありません。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">import</span> DITranquillity<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerPart</span>: <span class="hljs-title">DIPart</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">load</span><span class="hljs-params">(container: DIContainer)</span></span> {<font></font>
    container.register{ <span class="hljs-type">ServerImpl</span>(domain: <span class="hljs-string">"https://github.com/"</span>) }<font></font>
      .<span class="hljs-keyword">as</span>(check: <span class="hljs-type">Server</span>.<span class="hljs-keyword">self</span>){$<span class="hljs-number">0</span>}<font></font>
      .lifetime(.single)<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードでは、すべてが前のコードほど透過的ではなく、明確にする必要があります。まず、関数レジスター内で、パラメーターを渡してクラスを作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二に、 `as`関数があります-それはクラスが別のタイプ-プロトコルによってアクセス可能になることを示します。 `{$ 0}`の形式でのこの操作の奇妙な終わりは、 `check：`という名前の一部です。つまり、このコードは、ServerImplがServerの後継であることを保証します。しかし、別の構文があります：同じことを行いますが、チェックを行わない `as（Server.self）`。どちらの場合でもコンパイラが出力する内容を確認するには、プロトコル実装を削除できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの「as」関数が存在する可能性があります。これは、型がこれらの名前のいずれかで使用できることを意味します。</font><font style="vertical-align: inherit;">これは1つの登録になることに注意してください。つまり、クラスがシングルトンの場合、同じインスタンスが指定されたすべてのタイプで利用可能になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原則として、実装のタイプによってクラスを作成する可能性から自分自身を保護したい場合、またはこの構文にまだ慣れていない場合は、次のように書くことができます。</font></font><br>
<br>
<pre><code class="swift hljs">container.register{ <span class="hljs-type">ServerImpl</span>(domain: <span class="hljs-string">"https://github.com/"</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">Server</span> }
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは同等の機能ですが、いくつかの個別のタイプを指定する機能はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、Presenterにサーバーを実装できます。これを行うために、Presenterがサーバーを受け入れるように修正します。</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YourPresenter</span> </span>{
        <span class="hljs-keyword">init</span>(server: <span class="hljs-type">Server</span>) {<font></font>
            ...<font></font>
        }<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムを開始すると、AppDelegateの `validate`関数に分類され、type` Server`が見つからなかったというメッセージが表示されますが、` YourPresenter`では必須です。</font><font style="vertical-align: inherit;">どうしたの？</font><font style="vertical-align: inherit;">エラーはプログラムの実行の最初に発生したものであり、事後ではありません。</font><font style="vertical-align: inherit;">そしてその理由は非常に簡単です-彼らは `AppPartwork`に` ServerPart`を追加するのを忘れました：</font></font><br>
<br>
<pre><code class="swift hljs">container.append(part: <span class="hljs-type">ServerPart</span>.<span class="hljs-keyword">self</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは始めます-すべてが機能します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロガー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これに先立って、あまり印象的ではなく、多くの人が持っている機会と知り合いがいました。</font><font style="vertical-align: inherit;">これで、Swiftの他のライブラリーがその方法を知らないというデモがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロガーの下に別の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が作成されました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、何がロガーになるかを理解しましょう。</font><font style="vertical-align: inherit;">教育目的では、高度なシステムは使用しないため、ロガーは1つの方法と複数の実装を持つプロトコルです。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Logger</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-number">_</span> msg: String)</span></span><font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsoleLogger</span>: <span class="hljs-title">Logger</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-number">_</span> msg: String)</span></span> { ... }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileLogger</span>: <span class="hljs-title">Logger</span> </span>{
  <span class="hljs-keyword">init</span>(file: <span class="hljs-type">String</span>) { ... }
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-number">_</span> msg: String)</span></span> { ... }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerLogger</span>: <span class="hljs-title">Logger</span> </span>{
  <span class="hljs-keyword">init</span>(server: <span class="hljs-type">String</span>) { ... }
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-number">_</span> msg: String)</span></span> { ... }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainLogger</span>: <span class="hljs-title">Logger</span> </span>{
  <span class="hljs-keyword">init</span>(loggers: [<span class="hljs-type">Logger</span>]) { ... }
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-number">_</span> msg: String)</span></span> { ... }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
合計：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公開プロトコル</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それぞれ異なる場所に書き込む3つの異なるロガー実装</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他のすべての人のためにロギング機能を呼び出す1つの中央ロガー</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトは `LoggerFramework`と` LoggerPart`を作成しました。</font><font style="vertical-align: inherit;">彼らのコードは書きませんが、 `LoggerPart`の内部のみを書きます：</font></font><br>
<br>
<pre><code class="swift hljs">container.register{ <span class="hljs-type">ConsoleLogger</span>() }<font></font>
  .<span class="hljs-keyword">as</span>(<span class="hljs-type">Logger</span>.<span class="hljs-keyword">self</span>)<font></font>
  .lifetime(.single)<font></font>
<font></font>
container.register{ <span class="hljs-type">FileLogger</span>(file: <span class="hljs-string">"file.log"</span>) }<font></font>
  .<span class="hljs-keyword">as</span>(<span class="hljs-type">Logger</span>.<span class="hljs-keyword">self</span>)<font></font>
  .lifetime(.single)<font></font>
<font></font>
container.register{ <span class="hljs-type">ServerLogger</span>(server: <span class="hljs-string">"http://server.com/"</span>) }<font></font>
  .<span class="hljs-keyword">as</span>(<span class="hljs-type">Logger</span>.<span class="hljs-keyword">self</span>)<font></font>
  .lifetime(.single)<font></font>
<font></font>
container.register{ <span class="hljs-type">MainLogger</span>(loggers: many($<span class="hljs-number">0</span>)) }<font></font>
  .<span class="hljs-keyword">as</span>(<span class="hljs-type">Logger</span>.<span class="hljs-keyword">self</span>)<font></font>
  .<span class="hljs-keyword">default</span>()<font></font>
  .lifetime(.single)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の3つの登録についてはすでに見てきましたが、最後の登録では疑問が生じます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラメータが入力に渡されます。</font><font style="vertical-align: inherit;">簡略化されたレコードがありましたが、プレゼンターが作成されたときに同様のものがすでに示されていました-`init`メソッドが使用されただけで、誰もこのように書くことを気にしませんでした：</font></font><br>
<br>
<pre><code class="swift hljs">container.register { <span class="hljs-type">YourPresenter</span>(server: $<span class="hljs-number">0</span>) }
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のパラメータがある場合、 `$ 1`、` $ 2`、 `$ 3`などを使用できます。</font><font style="vertical-align: inherit;">16。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、このパラメーターは `many`関数を呼び出します。</font><font style="vertical-align: inherit;">そして、ここから楽しみが始まります。</font><font style="vertical-align: inherit;">ライブラリには2つの修飾子 `many`と` tag`があります。</font></font><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隠しテキスト</font></font></b><div class="spoiler_text">   `arg`,    </div></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">`many`修飾子は、目的のタイプに対応するすべてのオブジェクトを取得する必要があることを示しています。この場合、Loggerプロトコルが想定されているため、このプロトコルを継承するすべてのクラスが見つかり、作成されますが、1つの例外-それ自体、つまり再帰的です。プロパティを介して実装される場合、これを安全に行うことができますが、初期化中にそれ自体は作成されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、タグは別のタイプであり、使用時と登録時の両方で指定する必要があります。つまり、十分な基本タイプがない場合、タグは追加の基準です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたはこれについてもっと読むことができます：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">修飾子</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
修飾子、特に「多数」の存在は、ライブラリを他よりも優れたものにします。</font><font style="vertical-align: inherit;">たとえば、まったく異なるレベルでObserverパターンを実装できます。</font><font style="vertical-align: inherit;">これらの4文字のため、プロジェクトでは、プロジェクトの各オブザーバーから30〜50行のコードを削除し、オブジェクトをオブザーバブルにいつどこに追加するかという質問で問題を解決することができました。</font><font style="vertical-align: inherit;">明確なビジネスだけがアプリケーションではありませんが、重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、YourPresenterにロガーを導入して、機能のプレゼンテーションを終了します。</font></font><br>
<br>
<pre><code class="swift hljs">container.register(<span class="hljs-type">YourPresenter</span>.<span class="hljs-keyword">init</span>)<font></font>
      .injection { $<span class="hljs-number">0</span>.logger = $<span class="hljs-number">1</span> }
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、たとえば、以前とは少し異なって書かれています-これは、異なる構文の例のために行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロガープロパティはオプションであることに注意してください。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> logger: <span class="hljs-type">Logger?</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これはライブラリの構文には現れません。</font><font style="vertical-align: inherit;">最初のバージョンとは異なり、通常のタイプ、オプション、強制オプションのすべての操作は同じに見えます。</font><font style="vertical-align: inherit;">さらに、内部のロジックは異なります。タイプがオプションで、コンテナに登録されていない場合、プログラムはクラッシュせず、実行を継続します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果は前回と似ていますが、構文だけが短く、機能的になっています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考慮されたもの：</font></font></h4><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単に登録</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Storyboardを操作しますが、ライブラリはStoryboardReferencesを操作できます</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化メソッドまたはプロパティによる登録</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数の実装</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フレームワークとパーツを操作する</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少し検証</font></font></a></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリが他にできること：</font></font></h4><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5ライフタイム：シングル、perRun（.weak / .strong）、perContainer（.weak / .strong）、objectGraph、prototype</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タグ名</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロギング</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">循環依存関係を処理する</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビューに根付く</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a></li>
<li> ,         </li>
</ul><br>
<h2></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、コンパイル段階でのグラフのチェック、つまりコンパイラとのより緊密な統合に切り替える予定です。 SourceKittenを使用した予備の実装がありますが、そのような実装には型推論に関する重大な問題があるため、ast-dumpに切り替える予定です。swift5では、大規模なプロジェクトで動作するようになりました。ここで、私</font><font style="vertical-align: inherit;">はこの方向で多大な貢献</font><font style="vertical-align: inherit;">をしてくれた</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nekitosss</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">感謝したいと思い</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、視覚化サービスと統合したいと思います。これは少し異なるプロジェクトですが、ライブラリと密接に関連しています。ポイントは何ですか？これで、ライブラリーはリンクのグラフ全体を保管します。つまり、理論的には、ライブラリーに登録されているすべてのものをUMLクラス/コンポーネント図として表示できます。そして、この図を見るのは時々悪くないでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この機能は2つの部分で計画されます。最初の部分はすべての情報を取得するためのAPIを追加し、2番目の部分はすでにさまざまなサービスとの統合です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も簡単なオプションは、リンクのグラフをテキスト形式で表示することですが、判読可能なオプションは見ていません。そうであれば、コメントでオプションを提案してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WatchOS-私自身は彼らのためにプロジェクトを書きません。</font><font style="vertical-align: inherit;">彼の人生のために、彼は一度だけ書いて、それから小さい。</font><font style="vertical-align: inherit;">ただし、ストーリーボードと同様に、緊密に統合したいと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
よろしくお願いします。</font><font style="vertical-align: inherit;">アンケートへのコメントと回答を期待しています。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自分自身について</font></font></b><div class="spoiler_text">   — senior/team lead  iOS .    7 ,  iOS 4.5  –    ++ .      15  –            ,   ,   <s>, , , </s>   .       ,     –          .  – - ,            –    ,         ,        ,    ,    .<br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja457178/index.html">プロセッサの設計と製造方法：CPU設計</a></li>
<li><a href="../ja457180/index.html">公式サイトNode.jsがロシア語になりました</a></li>
<li><a href="../ja457182/index.html">REXX言語、40周年</a></li>
<li><a href="../ja457184/index.html">ASP.NET Coreサイト用のrobots.txtを動的に作成する</a></li>
<li><a href="../ja457186/index.html">Visual Studio CodeのPython-6月のリリース</a></li>
<li><a href="../ja457190/index.html">CRMシステムの実装を通じてビジネスを扱います</a></li>
<li><a href="../ja457192/index.html">エアバスはマイクロソフトの複合現実感で新たな高みへ</a></li>
<li><a href="../ja457196/index.html">ささいな喜び＃5：Dynaconf-プロジェクトの設定の管理</a></li>
<li><a href="../ja457198/index.html">ニューラルネットワークは、テキスト記述から複雑なシーンを描くことを学びました</a></li>
<li><a href="../ja457202/index.html">製品開発のアイデアをどのように選択するか：ベンダーは聞くことができなければなりません...</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>