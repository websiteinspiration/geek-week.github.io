<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘🏼 🧒🏾 🔶 使用Python重复Power BI同类群组分析 👨🏾‍🔧 💆🏿 🌆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="下午好，亲爱的读者们！撰写此出版物的原因是一个网络研讨会，我在YouTube上看到过。他致力于队列销售分析。作者使用Power BI Desktop平台处理数据。我不会提供指向指定视频的链接，因此不会将此文章视为广告，但是在叙述过程中，我将尝试破坏原始来源，以便更好地解释我自己决定的逻辑。这次网络研...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>使用Python重复Power BI同类群组分析</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501492/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下午好，亲爱的读者们！</font><font style="vertical-align: inherit;">撰写此出版物的原因是一个网络研讨会，我在YouTube上看到过。</font><font style="vertical-align: inherit;">他致力于队列销售分析。</font><font style="vertical-align: inherit;">作者使用Power BI Desktop平台处理数据。</font><font style="vertical-align: inherit;">我不会提供指向指定视频的链接，因此不会将此文章视为广告，但是在叙述过程中，我将尝试破坏原始来源，以便更好地解释我自己决定的逻辑。</font><font style="vertical-align: inherit;">这次网络研讨会使我想到，利用Pandas库的功能重复DAX公式的可能性会很有趣。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我想重点谈两点。首先，本材料面向刚开始使用Python编程语言迈出第一步的初学者。如果读者熟悉Power BI BI分析平台，则是理想的选择。其次，由于DAX计算是灵感的来源，因此我将尽可能“复制”作者的算法，并且不可避免地会偏离主要的编程范例。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过介绍，仅此而已。让我们上路吧！</font></font><br>
<br>
<a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将在JupyterLab环境中执行所有计算。便携式计算机解决方案可在（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">找到</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用Power Query工具将数据加载到Power BI中（实际上，它是使用M语言生成查询的可视化编辑器）。在开发过程中应遵循以下规则：所有数据预处理都应使用Power Query完成，而度量应使用Power Pivot计算。由于我们的主要图书馆是熊猫，所以我们立即使用其功能。</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#   </span>
path_to_data = <span class="hljs-string">"C:/Users/Pavel/Documents/Demo/"</span>
<span class="hljs-comment"># </span>
df = pd.read_csv(os.path.join(path_to_data, <span class="hljs-string">"ohortAnalysis_2016_2018.csv"</span>), sep=<span class="hljs-string">";"</span>, parse_dates=[<span class="hljs-string">"date"</span>], dayfirst=<span class="hljs-literal">True</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将在运行时测试代码行，以便在将来建立最耗时的部分。要设置读取文件的完整路径，请使用os库。为了简化笔记本电脑的开发过程，您可以不用它。数据集本身是随机组成的。 CSV文件中有1,048,575行。使用read_csv（）函数读取数据通常很简单。在数组中指定列分隔符和带有日期（如果有）的列就足够了。如果信息是通过某些“功能”上传的，则您可能需要配置其他参数，例如，指定每列的编码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，经常使用head（）函数来直观地监视数据转换的进度。不能消除所有错误，但是可以当场修复明显的缺陷。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将数据加载到模型中后，网络研讨会的作者对数据数组进行排序。这样做是为了添加带有索引的辅助列。在我们的情况下，将不使用此列，但是也将对数据进行排序，以便更方便地控制表中字段的正确计算。</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#  ,      </span>
df.sort_values([<span class="hljs-string">"user_id"</span>,<span class="hljs-string">"date"</span>], inplace = <span class="hljs-literal">True</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/t7/ek/x9/t7ekx9mfwh5z7cahruxyrvlvetq.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下一步，Power BI平台上的解决方案建议创建一个辅助表，该表将从中被提取到主阵列中。使用SUMMARIZE（）函数创建表。它为选定的组创建一个汇总表的数据透视表：</font></font><code> df_groupby_user = SUMMARIZE(df;df[user_id];"first_date_transaction";MIN(df[date]);"total_amount_user";SUM(df[amount]);"count_transaction_user";COUNT(df[amount]))</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pandas库具有其对应项-groupby（）函数。要应用groupby（），只需指定必要的数据帧（可分组的列）就足够了，在末尾列表中将应用聚合功能的列。通过reset_index（）函数将获得的结果减小为常规数据帧的格式。最后，重命名字段。</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#       user_id. </span>
df_groupby_user = df.groupby(by = [<span class="hljs-string">"user_id"</span>]).agg({<span class="hljs-string">"date"</span>: <span class="hljs-string">"min"</span>, <span class="hljs-string">"amount"</span>: [<span class="hljs-string">"sum"</span>,<span class="hljs-string">"count"</span>]})<font></font>
df_groupby_user.reset_index(inplace = <span class="hljs-literal">True</span>)
<span class="hljs-comment"># </span>
new_columns = [<span class="hljs-string">"user_id"</span>,<span class="hljs-string">"first_date_transaction"</span>, <span class="hljs-string">"total_amount_user"</span>,<span class="hljs-string">"count_transaction_user"</span>]<font></font>
df_groupby_user.columns = new_columns</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了“首次购买日期”度量标准外，还计算了整个期间的客户交易次数和客户购买总金额。这些测量未在笔记本电脑中找到它们的应用程序，但我们不会删除它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们返回网络研讨会。计算新的指标“首次购买的年月”。 DAX公式：</font></font><code> first_transaction = FORMAT(df_groupby_user[first_date_transaction];"YYYY-MM")</code><br>
<br>
<img src="https://habrastorage.org/webt/4l/3n/xo/4l3nxosdn2pddiqx3pffvtrniec.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python使用语法dt.strftime（'％Y-％m'）。您可以在在线出版物中找到有关在Python中处理日期和时间的详细说明。在这一步，还有其他重要的事情。注意操作时间。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一点也不像大熊猫一样的表现（24.8秒）。代码行比以前的所有代码慢。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此清单成为可能进行重构的第一个候选对象。</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#  -</span>
df_groupby_user[<span class="hljs-string">"first_transaction"</span>] = df_groupby_user[<span class="hljs-string">"first_date_transaction"</span>].dt.strftime(<span class="hljs-string">'%Y-%m'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在是时候再次返回网络研讨会了。</font><font style="vertical-align: inherit;">有一个由关键字段组成的表联合。</font><font style="vertical-align: inherit;">然后，使用RELATED（）函数将必要的字段拉入主表。</font><font style="vertical-align: inherit;">熊猫没有此功能。</font><font style="vertical-align: inherit;">但是有merge（），join（），concat（）。</font><font style="vertical-align: inherit;">在这种情况下，最好应用第一个选项。</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment"># </span>
df_final = pd.merge(df, df_groupby_user, how = <span class="hljs-string">"left"</span>, on = <span class="hljs-string">"user_id"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将具有第一次交易日期的数据放入主表后，可以计算增量。</font><font style="vertical-align: inherit;">我们使用apply结构（lambda x：...）清楚地演示了此过程的资源密集程度（39.7秒）。</font><font style="vertical-align: inherit;">这是代码重写的另一个候选对象。</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#   "    "</span>
df_final[<span class="hljs-string">"delta_days"</span>] = df_final[<span class="hljs-string">"date"</span>] - df_final[<span class="hljs-string">"first_date_transaction"</span>]<font></font>
df_final[<span class="hljs-string">"delta_days"</span>] = df_final[<span class="hljs-string">"delta_days"</span>].apply(<span class="hljs-keyword">lambda</span> x: x.days)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主表已经有按天的增量，因此您可以将列数据划分为同类。原则：0（即首次销售给客户）-同类群组0；大于0但小于或等于30的值是30;大于30但小于或等于90的值是90等为此，在DAX中，可以使用CEILING（）函数。它将数字四舍五入到最接近的整数，该整数是第二个参数的值的倍数。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/mu/rh/sdmurhtsdqarznw92jwbklpvjvs.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Python中，虽然我计划在math模块中找到它（也许搜索不佳），但我没有找到类似的数学函数。因此，我不得不四处应用cut（）函数。将数据分散到队列中后，NaN映射到0的数值。由于我们正在处理分类数据，因此无法使用fillna（）函数解决此问题。首先，您需要为类别添加一个新值。在此代码清单的末尾，将数据类型更改为int。这样做是为了将来在使用数据框构造数据透视表时，新队列不会出现在一系列值的末尾。</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#  . </span>
cut_labels_days = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range (<span class="hljs-number">30</span>, <span class="hljs-number">1230</span>, <span class="hljs-number">30</span>)]<font></font>
cut_bins_days = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range (<span class="hljs-number">0</span>, <span class="hljs-number">1230</span>, <span class="hljs-number">30</span>)]<font></font>
df_final[<span class="hljs-string">"cohort_days"</span>] = pd.cut(df_final[<span class="hljs-string">"delta_days"</span>], bins = cut_bins_days, labels=cut_labels_days, right = <span class="hljs-literal">True</span>)<font></font>
%%time<font></font>
<span class="hljs-comment">#     .   fillna   !</span>
df_final[<span class="hljs-string">"cohort_days"</span>] = df_final[<span class="hljs-string">"cohort_days"</span>].cat.add_categories([<span class="hljs-number">0</span>])<font></font>
df_final[<span class="hljs-string">"cohort_days"</span>].fillna(<span class="hljs-number">0</span>, inplace = <span class="hljs-literal">True</span>)<font></font>
%%time<font></font>
<span class="hljs-comment">#     .   fillna   !</span>
df_final[<span class="hljs-string">"cohort_days"</span>] = df_final[<span class="hljs-string">"cohort_days"</span>].cat.add_categories([<span class="hljs-number">0</span>])<font></font>
df_final[<span class="hljs-string">"cohort_days"</span>].fillna(<span class="hljs-number">0</span>, inplace = <span class="hljs-literal">True</span>)
<span class="hljs-comment">#    .    ,  "0"        ,     </span>
<span class="hljs-comment">#    .</span>
df_final[<span class="hljs-string">"cohort_days"</span>] = df_final[<span class="hljs-string">"cohort_days"</span>].astype(int)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用pivot_table（）函数，我们可以获得所需的数据透视表。我们有很多同类，因此结果无法完全显示在屏幕上。为避免这种情况，在解决实际案例时，您可以花费更短的时间间隔进行分析或扩大同类群组本身的值范围。</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#  </span>
df_pivot_table = pd.pivot_table(df_final, values=[<span class="hljs-string">"amount"</span>], index=[<span class="hljs-string">"first_transaction"</span>], columns=[<span class="hljs-string">"cohort_days"</span>], aggfunc=np.sum, fill_value = <span class="hljs-number">0</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/e2/dn/u-/e2dnu-fry4n2hd4fl7_coqm_5mo.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Power BI中，您需要使用矩阵工具来构建这种可视化。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sx/qh/gh/sxqhghd3km7lwdo-aycsry8xnn4.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下一阶段是绘图。情况的细微差别是我们需要权责发生制。在Power BI中，只需选择所需的“快速操作”菜单项，就会自动生成必要的DAX公式。有了熊猫图书馆，情况就更加复杂了。我们对现有的数据帧进行双重排序，并应用cumsum（）函数。由于结果仍将使用，因此我们将复制数据框以构建图形。累计销售额非常大，因此我们将其除以1,000,000，然后将结果四舍五入到小数点后两位。</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#     amount</span>
df_pivot_table_cumsum = df_final.groupby(by = [<span class="hljs-string">"first_transaction"</span>,<span class="hljs-string">"cohort_days"</span>]).agg({<span class="hljs-string">"amount"</span>: [<span class="hljs-string">"sum"</span>]}).groupby(level=<span class="hljs-number">0</span>).cumsum().reset_index()<font></font>
df_pivot_table_cumsum.columns = [<span class="hljs-string">"first_transaction"</span>,<span class="hljs-string">"cohort_days"</span>,<span class="hljs-string">"cumsum_amount"</span>]<font></font>
%%time<font></font>
<span class="hljs-comment">#     </span><font></font>
df_pivot_table_cumsum_chart = copy.deepcopy(df_pivot_table_cumsum)<font></font>
<span class="hljs-comment">#     ,       Y.</span>
df_pivot_table_cumsum_chart[<span class="hljs-string">"cumsum_amount"</span>]=round(df_pivot_table_cumsum_chart[<span class="hljs-string">"cumsum_amount"</span>]/<span class="hljs-number">1000000</span>, <span class="hljs-number">2</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们使用库的功能来构建图形。图表仅用一行代码构建，但结果并不令人满意。该图显然不适合任何BI平台上的可视化。您可以连接Plotly库并使用附加组件来进行构想，但是与视频中显示的方法相比，这是完全不同的人工成本。</font></font><br>
<br>
<pre><code class="python hljs">%%time<font></font>
df_pivot_table_cumsum_chart.pivot(index=<span class="hljs-string">"cohort_days"</span>, columns=<span class="hljs-string">"first_transaction"</span>, values=<span class="hljs-string">"cumsum_amount"</span>).plot(figsize = (<span class="hljs-number">15</span>,<span class="hljs-number">11</span>))</code></pre><br>
<img src="https://habrastorage.org/webt/ya/2f/sj/ya2fsjju2epd-vvcn96gms0i5rm.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们做出简短的结论。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在计算方面，熊猫库很可能会取代Power Pivot（DAX）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种替换的可行性仍在讨论之外。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DAX和Python库函数一样，在对表的整个字段执行操作方面也做得很好。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在速度，简便性和可视化设计的简便性方面，Power BI优于Pandas。</font><font style="vertical-align: inherit;">我认为，内置图形（以及使用matplotlib，seaborn库创建的图形）适合在以下两种情况下使用：对异常值，局部最小值/最大值的大量数据进行快速分析，或准备幻灯片进行演示。</font><font style="vertical-align: inherit;">图形控制面板的开发最好留给BI解决方案。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就这样。</font><font style="vertical-align: inherit;">一切健康，祝您好运和专业成功！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN501480/index.html">Deno v1.0：JavaScript和TypeScript的安全运行时。功能概述</a></li>
<li><a href="../zh-CN501482/index.html">半人马座</a></li>
<li><a href="../zh-CN501484/index.html">程序员必须决定</a></li>
<li><a href="../zh-CN501488/index.html">从中高级到高级</a></li>
<li><a href="../zh-CN501490/index.html">Python 3.9的新变化</a></li>
<li><a href="../zh-CN501494/index.html">不是灵魂的克星：杜洛夫失败的加密货币的故事</a></li>
<li><a href="../zh-CN501496/index.html">彗星湖，迭代完成</a></li>
<li><a href="../zh-CN501498/index.html">使用RESTinio中的easy_parser，需要编写多少C ++代码来解析Authorization HTTP标头？</a></li>
<li><a href="../zh-CN501500/index.html">视觉黑客：什么构成威胁以及如何保护自己免受间谍侵害</a></li>
<li><a href="../zh-CN501502/index.html">新实验室数字综合继续哈里斯书并帮助制作FPGA视频游戏</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>