<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🏫 🖼️ 💜 Bagaimana cara menyebabkan kebocoran memori pada aplikasi Angular? 🥈 💂 🚍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kinerja adalah kunci keberhasilan aplikasi web. Oleh karena itu, pengembang perlu mengetahui bagaimana kebocoran memori terjadi dan cara menanganinya....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara menyebabkan kebocoran memori pada aplikasi Angular?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/503312/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kinerja adalah kunci keberhasilan aplikasi web. Oleh karena itu, pengembang perlu mengetahui bagaimana kebocoran memori terjadi dan cara menanganinya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengetahuan ini sangat penting ketika aplikasi yang ditangani pengembang mencapai ukuran tertentu. Jika Anda tidak cukup memperhatikan kebocoran memori, maka semuanya mungkin berakhir dengan pengembang masuk ke "tim untuk menghilangkan kebocoran memori" (saya harus menjadi bagian dari tim semacam itu). </font><font style="vertical-align: inherit;">
Kebocoran memori dapat terjadi karena berbagai alasan. Namun, saya percaya bahwa saat menggunakan Angular, Anda mungkin menemukan pola yang sesuai dengan penyebab paling umum dari kebocoran memori. Ada cara untuk mengatasi kebocoran memori tersebut. Dan hal terbaik, tentu saja, bukan untuk melawan masalah, tetapi untuk menghindarinya.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/bg/op/jz/bgopjzk2msaiedpikpoa1qcv2cm.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa itu manajemen memori?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript menggunakan sistem manajemen memori otomatis. </font><font style="vertical-align: inherit;">Daur hidup memori biasanya terdiri dari tiga langkah:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alokasi memori yang diperlukan.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bekerja dengan memori yang dialokasikan, melakukan operasi baca dan tulis.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melepaskan memori setelah itu tidak lagi diperlukan.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengatakan bahwa manajemen memori otomatis - itu adalah sumber potensi kebingungan. </font><font style="vertical-align: inherit;">Ini dapat memberi pengembang rasa salah bahwa mereka tidak perlu khawatir tentang manajemen memori. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda sama sekali tidak peduli dengan manajemen memori, ini berarti bahwa setelah aplikasi Anda tumbuh ke ukuran tertentu, Anda mungkin mengalami kebocoran memori. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, kebocoran memori dapat dianggap sebagai memori yang dialokasikan untuk aplikasi, yang tidak lagi dibutuhkan, tetapi tidak dirilis. </font><font style="vertical-align: inherit;">Dengan kata lain, ini adalah objek yang gagal menjalani operasi pengumpulan sampah.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana cara kerja pengumpulan sampah?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selama prosedur pengumpulan sampah, yang cukup logis, semua yang dapat dianggap "sampah" dibersihkan. </font><font style="vertical-align: inherit;">Pengumpul sampah membersihkan memori yang tidak lagi dibutuhkan aplikasi. </font><font style="vertical-align: inherit;">Untuk mengetahui area memori apa yang masih dibutuhkan aplikasi, pengumpul sampah menggunakan algoritme "mark and sweep" (algoritma penandaan). </font><font style="vertical-align: inherit;">Sesuai namanya, algoritma ini terdiri dari dua fase - fase penandaan dan fase sapuan.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Fase bendera</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Objek dan tautannya disajikan dalam bentuk pohon. </font><font style="vertical-align: inherit;">Akar pohon adalah, pada gambar berikut, sebuah simpul </font></font><code>root</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dalam JavaScript, ini adalah objek </font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Setiap objek memiliki bendera khusus. </font><font style="vertical-align: inherit;">Beri nama bendera ini </font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pada fase penandaan, pertama-tama, semua bendera </font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diatur ke nilai </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/433/436/b8a/433436b8a72bc7a207bd66c5b76788f5.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada awalnya, bendera dari objek yang ditandai disetel ke false,</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
kemudian pohon objek dilintasi. </font><font style="vertical-align: inherit;">Semua bendera</font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objek yang dapat dijangkau dari node</font></font><code>root</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diatur ke</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dan bendera dari benda-benda itu yang tidak bisa dijangkau, tetap nilainya</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suatu objek dianggap tidak terjangkau jika tidak dapat dijangkau dari objek root.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cf/d14/a50/1cfd14a50f9be4e7aa402052982eb253.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek yang dapat dijangkau ditandai sebagai ditandai = benar, objek yang tidak dapat dijangkau sebagai ditandai = false</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Akibatnya, semua bendera</font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objek yang tidak dapat dijangkau tetap berada dalam nilai</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Memori belum dibebaskan, tetapi, setelah selesainya fase penandaan, semuanya siap untuk fase pembersihan.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Tahap pembersihan</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memori dihapus tepat pada fase algoritma ini. Di sini, semua benda yang tidak dapat dijangkau (mereka yang benderanya </font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tetap nilainya </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) dihancurkan oleh pengumpul sampah.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a0/75f/f16/8a075ff162428195665afe583a85151f.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pohon objek setelah pengumpulan sampah. </font><font style="vertical-align: inherit;">Semua objek yang ditandai bendera disetel ke salah dihancurkan oleh pengumpul sampah.Pengumpulan</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
sampah dilakukan secara berkala saat program JavaScript berjalan. </font><font style="vertical-align: inherit;">Selama prosedur ini, memori dilepaskan yang dapat dibebaskan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin pertanyaan berikut muncul di sini: "Jika pengumpul sampah menghapus semua objek yang ditandai sebagai tidak dapat dijangkau - bagaimana cara membuat kebocoran memori?". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Intinya di sini adalah bahwa objek tidak akan diproses oleh pengumpul sampah jika aplikasi tidak membutuhkannya, tetapi Anda masih dapat mencapainya dari simpul akar dari pohon objek.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algoritma tidak dapat mengetahui apakah aplikasi akan menggunakan sebagian memori yang dapat diakses atau tidak. </font><font style="vertical-align: inherit;">Hanya seorang programmer yang memiliki pengetahuan seperti itu.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kebocoran memori sudut</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Paling sering, kebocoran memori terjadi seiring waktu ketika suatu komponen berulang kali dirender. </font><font style="vertical-align: inherit;">Misalnya - melalui perutean, atau sebagai akibat dari menggunakan arahan </font></font><code>*ngIf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Katakanlah, dalam situasi di mana beberapa pengguna tingkat lanjut bekerja dengan aplikasi sepanjang hari tanpa memperbarui halaman aplikasi di browser. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mereproduksi skenario ini, kami akan membuat konstruksi dua komponen. </font><font style="vertical-align: inherit;">Ini akan menjadi komponen </font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>SubComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;<span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
&nbsp;&nbsp;<span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;app-sub *ngIf="hide"&gt;&lt;/app-sub&gt;`</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppComponent</span> </span>{<font></font>
&nbsp;&nbsp;hide = <span class="hljs-literal">false</span>;<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.hide = !<span class="hljs-keyword">this</span>.hide, <span class="hljs-number">50</span>);<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Templat komponen </font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggunakan komponen </font></font><code>app-sub</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Yang paling menarik di sini adalah komponen kita menggunakan fungsi </font></font><code>setInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang mengganti flag </font></font><code>hide</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setiap 50 ms. Ini menghasilkan komponen yang dirender ulang setiap 50 ms </font></font><code>app-sub</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Artinya, penciptaan instance baru kelas dilakukan </font></font><code>SubComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kode ini meniru perilaku pengguna yang bekerja sepanjang hari dengan aplikasi web tanpa menyegarkan halaman di browser. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami, dalam </font></font><code>SubComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, telah menerapkan skenario yang berbeda, dalam penggunaannya, seiring waktu, perubahan dalam jumlah memori yang digunakan oleh aplikasi mulai muncul. Perhatikan bahwa komponen</font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selalu tetap sama. </font><font style="vertical-align: inherit;">Dalam setiap skenario, kita akan mengetahui apakah yang kita hadapi adalah kebocoran memori dengan menganalisis konsumsi memori dari proses browser. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika konsumsi memori dari proses meningkat dari waktu ke waktu, ini berarti bahwa kita dihadapkan dengan kebocoran memori. </font><font style="vertical-align: inherit;">Jika suatu proses menggunakan jumlah memori yang kurang lebih konstan, itu berarti bahwa tidak ada kebocoran memori, atau bahwa kebocoran, meskipun ada, tidak memanifestasikan dirinya dengan cara yang cukup jelas.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Skenario # 1: besar untuk loop</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skenario pertama kami diwakili oleh loop yang berjalan 100.000 kali. </font><font style="vertical-align: inherit;">Dalam loop, nilai acak ditambahkan ke array. </font><font style="vertical-align: inherit;">Jangan lupa bahwa komponen dirender ulang setiap 50 ms. </font><font style="vertical-align: inherit;">Lihatlah kodenya dan pikirkan apakah kita membuat kebocoran memori atau tidak.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;arr = [];<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; ++i) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.arr.push(<span class="hljs-built_in">Math</span>.random());<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meskipun kode tersebut tidak boleh dikirim ke produksi, itu tidak membuat kebocoran memori. </font><font style="vertical-align: inherit;">Yaitu, konsumsi memori tidak melampaui kisaran terbatas pada nilai 15 MB. </font><font style="vertical-align: inherit;">Akibatnya, tidak ada kebocoran memori. </font><font style="vertical-align: inherit;">Di bawah ini kita akan berbicara tentang mengapa demikian.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Skenario 2: Berlangganan BehaviorSubject</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam skenario ini, kami berlangganan </font></font><code>BehaviorSubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan menetapkan nilai ke konstanta. </font><font style="vertical-align: inherit;">Apakah ada kebocoran memori dalam kode ini? </font><font style="vertical-align: inherit;">Seperti sebelumnya, jangan lupa bahwa komponen diberikan setiap 50 ms.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;subject = <span class="hljs-keyword">new</span> BehaviorSubject(<span class="hljs-number">42</span>);<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.subject.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> foo = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini, seperti pada contoh sebelumnya, tidak ada kebocoran memori.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Skenario 3: menugaskan nilai ke bidang kelas di dalam langganan</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini, kode yang hampir sama disajikan seperti pada contoh sebelumnya. </font><font style="vertical-align: inherit;">Perbedaan utama adalah bahwa nilai diberikan bukan untuk konstanta, tetapi ke bidang kelas. </font><font style="vertical-align: inherit;">Dan sekarang, apakah Anda pikir ada kebocoran dalam kode?</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;subject = <span class="hljs-keyword">new</span> BehaviorSubject(<span class="hljs-number">42</span>);<font></font>
&nbsp;&nbsp;randomValue = <span class="hljs-number">0</span>;<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.subject.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.randomValue = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda yakin tidak ada kebocoran di sini - Anda memang benar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam skenario # 1 tidak ada berlangganan. </font><font style="vertical-align: inherit;">Dalam skenario No. 2 dan 3, kami berlangganan aliran objek yang diamati yang diinisialisasi dalam komponen kami. </font><font style="vertical-align: inherit;">Rasanya seperti kita aman dengan berlangganan aliran komponen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi bagaimana jika kita menambahkan layanan ke skema kita?</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skenario yang menggunakan layanan</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam skenario berikut, kami akan merevisi contoh di atas, tetapi kali ini kami akan berlangganan aliran yang disediakan oleh layanan </font></font><code>DummyService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini kode layanannya.</font></font><br>
<br>
<pre><code class="javascript hljs">@Injectable({
&nbsp;&nbsp;<span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DummyService</span> </span>{<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;some$ = <span class="hljs-keyword">new</span> BehaviorSubject&lt;number&gt;(<span class="hljs-number">42</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di depan kami adalah layanan sederhana. </font><font style="vertical-align: inherit;">Ini hanya layanan yang menyediakan aliran ( </font></font><code>some$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) dalam bentuk bidang kelas publik.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Skenario 4: Berlangganan aliran dan menetapkan nilai ke konstanta lokal</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan membuat ulang di sini skema yang sama yang sudah dijelaskan sebelumnya. </font><font style="vertical-align: inherit;">Tapi kali ini, kami berlangganan aliran </font></font><code>some$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari </font></font><code>DummyService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan bukan ke bidang komponen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apakah ada kebocoran memori? </font><font style="vertical-align: inherit;">Sekali lagi, ketika menjawab pertanyaan ini, ingatlah bahwa komponen digunakan </font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan dirender berkali-kali.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(private dummyService: DummyService) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.dummyService.some$.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> foo = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan sekarang kami akhirnya membuat kebocoran memori. </font><font style="vertical-align: inherit;">Tapi ini kebocoran kecil. </font><font style="vertical-align: inherit;">Yang saya maksud dengan "kebocoran kecil" yang seiring waktu, mengarah pada peningkatan lambat dalam jumlah memori yang dikonsumsi. </font><font style="vertical-align: inherit;">Peningkatan ini nyaris tidak terlihat, tetapi inspeksi sepintas dari snapshot tumpukan menunjukkan adanya banyak instance yang tidak terhapus </font></font><code>Subscriber</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Skenario 5: berlangganan layanan dan memberikan nilai ke bidang kelas</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kami berlangganan lagi untuk </font></font><code>dummyService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tapi kali ini kami menetapkan nilai yang dihasilkan ke bidang kelas, dan bukan konstanta lokal.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;randomValue = <span class="hljs-number">0</span>;<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(private dummyService: DummyService) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.dummyService.some$.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.randomValue = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan di sini kami akhirnya membuat kebocoran memori yang signifikan. </font><font style="vertical-align: inherit;">Konsumsi memori dengan cepat, dalam satu menit, melebihi 1 GB. </font><font style="vertical-align: inherit;">Mari kita bicarakan mengapa ini terjadi.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HenKetika kebocoran memori terjadi?</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda mungkin telah memperhatikan bahwa dalam tiga skenario pertama kami tidak dapat membuat kebocoran memori. </font><font style="vertical-align: inherit;">Tiga skenario ini memiliki kesamaan: semua tautan bersifat lokal ke komponen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika kami berlangganan objek yang dapat diamati, ia menyimpan daftar pelanggan. </font><font style="vertical-align: inherit;">Callback kami juga ada dalam daftar ini, dan callback dapat merujuk ke komponen kami.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/49f/92e/bda49f92eb184ad1eb78231a4144b71c.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada kebocoran memori</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ketika komponen dihancurkan, yaitu, ketika Angular tidak lagi memiliki tautan ke sana, yang berarti bahwa komponen tidak dapat dijangkau dari simpul akar, objek yang diamati dan daftar pelanggannya tidak dapat dijangkau dari simpul akar juga. Akibatnya, seluruh objek komponen adalah sampah yang dikumpulkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selama kita berlangganan objek yang dapat diamati, tautan yang hanya ada di dalam komponen, tidak ada masalah yang muncul. Tetapi ketika layanan mulai berlaku, situasinya berubah.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/454/6f7/b5b/4546f7b5b2ab2d2858f550740243189e.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory Leak</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Segera setelah kami berlangganan objek yang dapat diamati yang disediakan oleh layanan atau kelas lain, kami membuat kebocoran memori. </font><font style="vertical-align: inherit;">Ini karena objek yang diamati, karena daftar pelanggannya. </font><font style="vertical-align: inherit;">Karena itu, panggilan balik, dan oleh karena itu komponen, dapat diakses dari simpul akar, meskipun Angular tidak memiliki referensi langsung ke komponen. </font><font style="vertical-align: inherit;">Akibatnya, pengumpul sampah tidak menyentuh objek yang sesuai. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya akan mengklarifikasi: Anda dapat menggunakan konstruksi seperti itu, tetapi Anda harus bekerja dengan mereka dengan benar, dan tidak seperti kami.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pekerjaan Berlangganan yang Tepat</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menghindari kebocoran memori, penting untuk berhenti berlangganan dengan benar dari objek yang diamati, dengan melakukan ini ketika berlangganan tidak lagi diperlukan. Misalnya, ketika komponen dihancurkan. Ada banyak cara untuk berhenti berlangganan dari objek yang diamati. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengalaman menasihati pemilik proyek perusahaan besar menunjukkan bahwa dalam situasi ini yang terbaik adalah menggunakan entitas yang </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dibuat oleh tim </font></font><code>new Subject&lt;void&gt;()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam kombinasi dengan operator </font></font><code>takeUntil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnDestroy</span> </span>{<font></font>
<font></font>
&nbsp;&nbsp;private destroy$: Subject&lt;<span class="hljs-keyword">void</span>&gt; = <span class="hljs-keyword">new</span> Subject&lt;<span class="hljs-keyword">void</span>&gt;();<font></font>
&nbsp;&nbsp;randomNumber = <span class="hljs-number">0</span>;<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(private dummyService: DummyService) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dummyService.some$.pipe(<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;takeUntil(<span class="hljs-keyword">this</span>.destroy$)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;).subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-keyword">this</span>.randomNumber = value);<font></font>
&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;ngOnDestroy(): <span class="hljs-keyword">void</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.destroy$.next();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.destroy$.complete();<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kami berhenti berlangganan dengan menggunakan </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operator dan </font></font><code>takeUntil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setelah penghancuran komponen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menerapkan kait siklus hidup di komponen </font></font><code>ngOnDestroy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Setiap kali komponen dihancurkan, kami memanggil </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode </font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Panggilan ini </font></font><code>complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sangat penting karena panggilan ini menghapus langganan dari </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian kami menggunakan operator </font></font><code>takeUntil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan memberikannya aliran kami </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini memastikan bahwa langganan dihapus (yaitu, bahwa kami telah berhenti berlangganan dari langganan) setelah komponen dihancurkan.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana cara mengingat untuk menghapus langganan?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sangat mudah untuk lupa menambahkan komponen </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan lupa menelepon </font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan </font></font><code>complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam siklus hidup Hook </font></font><code>ngOnDestroy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Walaupun saya mengajarkan hal ini kepada tim yang mengerjakan proyek, saya sering melupakannya sendiri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untungnya, ada aturan linter yang luar biasa, yang merupakan bagian dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serangkaian aturan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang memungkinkan Anda untuk memastikan berhenti berlangganan dari langganan. </font><font style="vertical-align: inherit;">Anda dapat menetapkan aturan yang ditetapkan seperti ini:</font></font><br>
<br>
<pre><code class="javascript hljs">npm install @angular-extensions/lint-rules --save-dev
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maka itu harus terhubung ke </font></font><code>tslint.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs">{
&nbsp;&nbsp;<span class="hljs-string">"extends"</span>: [
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"tslint:recommended"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"@angular-extensions/lint-rules"</span><font></font>
&nbsp;&nbsp;]<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya sangat menyarankan Anda menggunakan seperangkat aturan ini dalam proyek Anda. </font><font style="vertical-align: inherit;">Ini akan menghemat waktu berjam-jam untuk mencari sumber kebocoran memori.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ringkasan</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di Angular, sangat mudah untuk menciptakan situasi yang mengarah pada kebocoran memori. </font><font style="vertical-align: inherit;">Bahkan perubahan kode kecil di tempat-tempat yang, tampaknya, tidak boleh dikaitkan dengan kebocoran memori, dapat menyebabkan konsekuensi buruk yang serius. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cara terbaik untuk menghindari kebocoran memori adalah mengelola langganan Anda dengan benar. </font><font style="vertical-align: inherit;">Sayangnya, pengoperasian langganan pembersihan membutuhkan akurasi yang tinggi dari pengembang. </font><font style="vertical-align: inherit;">Ini mudah dilupakan. </font><font style="vertical-align: inherit;">Karena itu, Anda disarankan untuk menerapkan aturan </font></font><code>@angular-extensions/lint-rules</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang membantu Anda mengatur pekerjaan yang tepat dengan langganan Anda. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> repositori dengan kode yang mendasari materi ini. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pernahkah Anda mengalami kebocoran memori di aplikasi Angular?</font></font></b><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/a_/bs/aa/a_bsaactpbr8fltzymtkhqbw1d4.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id503288/index.html">Bagaimana kami mencari kandidat menggunakan pembelajaran mesin</a></li>
<li><a href="../id503290/index.html">Ulasan quadrocopter industri DJI Matrice 300 RTK</a></li>
<li><a href="../id503300/index.html">Buku “Rick and Morty. Panduan untuk kartun paling cemerlang dari semua galaksi »</a></li>
<li><a href="../id503302/index.html">Mempercepat pembangunan proyek di CMake + GCC: prakompilasi file header</a></li>
<li><a href="../id503310/index.html">Apa yang dipikirkan programmer senior?</a></li>
<li><a href="../id503318/index.html">Profesi: Programmer. Tidak semuanya jelas</a></li>
<li><a href="../id503322/index.html">Pengembangan Firmware: Pendahuluan</a></li>
<li><a href="../id503324/index.html">"Di puncak" dari Brad Stalberg dan Steve Magness: pencegahan pembakaran spontan (bagian satu)</a></li>
<li><a href="../id503328/index.html">Kami mengkompilasi aplikasi Boot Spring menjadi asli menggunakan GraalVM</a></li>
<li><a href="../id503330/index.html">Cara Belajar dari Ilmuwan Data: Keterampilan Teknis Yang Paling Dicari</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>