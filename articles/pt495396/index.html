<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§πüèª üèπ üëàüèø Primeira impress√£o de conceitos ‚úçüèº üåâ üö∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Decidi lidar com o novo recurso C ++ 20 - conceitos. 
 
 Conceitos (ou conceitos , como escreve o Wiki de l√≠ngua russa) s√£o um recurso muito interessa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Primeira impress√£o de conceitos</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495396/"><img src="https://habrastorage.org/webt/qd/ja/kc/qdjakcxd4173w_juzv5fx3bf0_o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Decidi lidar com o novo recurso C ++ 20 - conceitos. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conceitos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conceitos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , como escreve o Wiki de l√≠ngua russa) s√£o um recurso muito interessante e √∫til que h√° muito falta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essencialmente, ele est√° digitando para argumentos de modelo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O principal problema dos modelos anteriores ao C ++ 20 √© que voc√™ pode substituir qualquer coisa neles, incluindo algo para o qual eles n√£o foram projetados. Ou seja, o sistema de gabaritos foi completamente n√£o digitado. Como resultado, ocorreram mensagens de erro incrivelmente longas e completamente ileg√≠veis ao passar o par√¢metro errado para o modelo. Eles tentaram combater isso com a ajuda de diferentes hacks de linguagem, que eu nem quero mencionar (embora eu tenha que lidar com isso).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os conceitos s√£o projetados para corrigir esse mal-entendido. </font><font style="vertical-align: inherit;">Eles adicionam um sistema de digita√ß√£o aos modelos e √© muito poderoso. </font><font style="vertical-align: inherit;">E agora, entendendo os recursos desse sistema, comecei a estudar os materiais dispon√≠veis na Internet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Francamente, estou um pouco chocado :) C ++ √© uma linguagem j√° complicada, mas pelo menos h√° uma desculpa: aconteceu. </font><font style="vertical-align: inherit;">A metaprograma√ß√£o de modelos foi descoberta, n√£o estabelecida, ao projetar uma linguagem. </font><font style="vertical-align: inherit;">E ent√£o, ao desenvolver as pr√≥ximas vers√µes da linguagem, eles foram for√ßados a se adaptar a essa "descoberta", pois muitos c√≥digos foram escritos no mundo. </font><font style="vertical-align: inherit;">Os conceitos s√£o uma oportunidade fundamentalmente nova. </font><font style="vertical-align: inherit;">E, parece-me, alguma opacidade j√° est√° presente em sua implementa√ß√£o. </font><font style="vertical-align: inherit;">Talvez isso seja uma consequ√™ncia da necessidade de levar em considera√ß√£o a enorme quantidade de recursos herdados? </font><font style="vertical-align: inherit;">Vamos tentar descobrir isso ...</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informa√ß√£o geral</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um conceito √© uma nova entidade de idioma baseada na sintaxe do modelo. </font><font style="vertical-align: inherit;">Um conceito tem um nome, par√¢metros e um corpo - um predicado que retorna um valor l√≥gico constante (isto √©, computado no est√°gio de compila√ß√£o), dependendo dos par√¢metros do conceito. </font><font style="vertical-align: inherit;">Como isso:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> I&gt; 
<span class="hljs-keyword">concept</span> Even = I % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;  <font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> FourByte = <span class="hljs-keyword">sizeof</span>(T)==<span class="hljs-number">4</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tecnicamente, os conceitos s√£o muito semelhantes √†s express√µes constexpr do modelo, como bool:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> I&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> EvenX = I % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; <font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> FourByteX = <span class="hljs-keyword">sizeof</span>(T)==<span class="hljs-number">4</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ pode at√© usar conceitos em express√µes comuns:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b1 = Even&lt;<span class="hljs-number">2</span>&gt;; </code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A id√©ia principal dos conceitos √© que eles podem ser usados ‚Äã‚Äãem vez das palavras-chave ou nome do tipo de classe nos modelos. </font><font style="vertical-align: inherit;">Como metatipos ("tipos para tipos"). </font><font style="vertical-align: inherit;">Assim, a digita√ß√£o est√°tica √© introduzida nos modelos.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;FourByte T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp; t)</span> </span>{}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, se usarmos int como par√¢metro de modelo, o c√≥digo na grande maioria dos casos ser√° compilado; </font><font style="vertical-align: inherit;">e se duplicar, ser√° emitida uma mensagem de erro curta e compreens√≠vel. </font><font style="vertical-align: inherit;">Digita√ß√£o simples e clara de modelos, at√© agora tudo est√° ok.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta √© uma nova palavra-chave ‚Äúcontextual‚Äù C ++ 20 com um objetivo duplo: requer cl√°usula e requer express√£o. </font><font style="vertical-align: inherit;">Como ser√° mostrado mais adiante, essa economia estranha de palavras-chave leva a alguma confus√£o.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requer express√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, considere requer express√£o. </font><font style="vertical-align: inherit;">A id√©ia √© boa: essa palavra tem um bloco entre chaves, cujo c√≥digo √© avaliado para compila√ß√£o. </font><font style="vertical-align: inherit;">√â verdade que o c√≥digo n√£o deve ser escrito </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em C ++, mas em uma linguagem especial, pr√≥xima ao C ++, mas com caracter√≠sticas pr√≥prias</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (essa √© a primeira estranheza, era poss√≠vel criar apenas c√≥digo C ++). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se o c√≥digo estiver correto - requer que a express√£o retorne verdadeiro, caso contr√°rio, falso. </font><font style="vertical-align: inherit;">O pr√≥prio c√≥digo, √© claro, nunca entra na gera√ß√£o de c√≥digo, como express√µes em sizeof ou decltype. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infelizmente, a palavra √© contextual e funciona apenas dentro de modelos, ou seja, fora do modelo, isso n√£o √© compilado:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b = <span class="hljs-keyword">requires</span> { <span class="hljs-number">3.14</span> &gt;&gt; <span class="hljs-number">1</span>; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E no modelo - por favor:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> Shiftable = <span class="hljs-keyword">requires</span>(T i) { i&gt;&gt;<span class="hljs-number">1</span>; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E vai funcionar:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b1 = Shiftable&lt;<span class="hljs-keyword">int</span>&gt;; <span class="hljs-comment">// true</span>
<span class="hljs-keyword">bool</span> b2 = Shiftable&lt;<span class="hljs-keyword">double</span>&gt;; <span class="hljs-comment">// false</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O principal uso de requer express√£o √© criar conceitos. </font><font style="vertical-align: inherit;">Por exemplo, √© assim que voc√™ pode verificar a presen√ßa de campos e m√©todos em um tipo. </font><font style="vertical-align: inherit;">Um caso muito popular.</font></font><br>
<br>
<pre><code class="plaintext hljs">template &lt;typename T&gt;<font></font>
concept Machine = <font></font>
  requires(T m) {  //   `m` ,   Machine<font></font>
	m.start();     //    `m.start()` <font></font>
	m.stop();      //   `m.stop()`<font></font>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A prop√≥sito, todas as vari√°veis ‚Äã‚Äãque podem ser necess√°rias no c√≥digo testado (n√£o apenas nos par√¢metros do modelo) devem ser declaradas entre par√™nteses, requer express√£o. </font><font style="vertical-align: inherit;">Por alguma raz√£o, declarar uma vari√°vel simplesmente n√£o √© poss√≠vel.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A verifica√ß√£o de tipo dentro requer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â aqui que as diferen√ßas entre requer c√≥digo e C ++ padr√£o come√ßam. </font><font style="vertical-align: inherit;">Para verificar os tipos retornados, uma sintaxe especial √© usada: o objeto √© colocado entre colchetes, uma seta √© colocada e, depois disso, √© escrito um conceito que o tipo deve satisfazer. </font><font style="vertical-align: inherit;">Al√©m disso, o uso de tipos diretamente n√£o √© permitido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verifique se o retorno da fun√ß√£o pode ser convertido para int:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(T v, <span class="hljs-keyword">int</span> i) {<font></font>
  { v.f(i) } -&gt; <span class="hljs-built_in">std</span>::convertible_to&lt;<span class="hljs-keyword">int</span>&gt;;<font></font>
}  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verifique se a fun√ß√£o de retorno √© exatamente int:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(T v, <span class="hljs-keyword">int</span> i) {<font></font>
  { v.f(i) } -&gt; <span class="hljs-built_in">std</span>::same_as&lt;<span class="hljs-keyword">int</span>&gt;; <font></font>
}  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(std :: same_as e std :: convertible_to s√£o conceitos da biblioteca padr√£o). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ n√£o incluir uma express√£o cujo tipo est√° marcado entre chaves, o compilador n√£o entender√° o que eles querem dele e interpretar√° a sequ√™ncia inteira como uma express√£o √∫nica que precisa ser verificada para compila√ß√£o.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requer dentro requer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A palavra-chave requer tem um significado especial dentro requer express√µes. </font><font style="vertical-align: inherit;">Express√µes requeridas aninhadas (j√° sem chaves) s√£o verificadas n√£o para compila√ß√£o, mas para igualdade verdadeira ou falsa. </font><font style="vertical-align: inherit;">Se essa express√£o for falsa, a express√£o anexa imediatamente ser√° falsa (e outras an√°lises de compila√ß√£o ser√£o interrompidas). </font><font style="vertical-align: inherit;">Forma geral:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> { <font></font>
  expression;         <span class="hljs-comment">// expression is valid</span>
  <span class="hljs-keyword">requires</span> predicate; <span class="hljs-comment">// predicate is true</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como predicado, por exemplo, conceitos previamente definidos ou caracter√≠sticas de tipo podem ser usados. </font><font style="vertical-align: inherit;">Exemplo:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(Iter it) {
  <span class="hljs-comment">//     (   Iter   *  ++)</span><font></font>
  *it++;<font></font>
 <font></font>
  <span class="hljs-comment">//    -  </span>
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::convertible_to&lt;<span class="hljs-keyword">decltype</span>(*it++), <span class="hljs-keyword">typename</span> Iter::value_type&gt;;<font></font>
 <font></font>
  <span class="hljs-comment">//    -  </span>
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::is_convertible_v&lt;<span class="hljs-keyword">decltype</span>(*it++), <span class="hljs-keyword">typename</span> Iter::value_type&gt;;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao mesmo tempo, express√µes requeridas aninhadas s√£o permitidas com c√≥digo entre colchetes, que √© verificado quanto √† validade. </font><font style="vertical-align: inherit;">No entanto, se voc√™ simplesmente escrever uma express√£o requerida dentro de outra, a express√£o aninhada (tudo como um todo, incluindo a palavra-chave requer aninhada) ser√° simplesmente verificada quanto √† validade:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> (T v) { 
  <span class="hljs-keyword">requires</span> (<span class="hljs-keyword">typename</span> T::value_type x) { ++x; }; <span class="hljs-comment">//     , </span>
												<span class="hljs-comment">//     !</span>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, surgiu uma forma estranha com duplo requer:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> (T v) { 
  <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span> <span class="hljs-params">(<span class="hljs-keyword">typename</span> T::value_type x)</span> </span>{ ++x; }; <span class="hljs-comment">//       "++x"</span>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√° uma sequ√™ncia de escape t√£o divertida de "requer". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A prop√≥sito, outra combina√ß√£o de dois requer √© esta cl√°usula de tempo (veja abaixo) e express√£o:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span><span class="hljs-params">(T x, T y)</span> </span>{ <span class="hljs-keyword">bool</span>(x &lt; y); }
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">equivalent</span><span class="hljs-params">(T <span class="hljs-keyword">const</span>&amp; x, T <span class="hljs-keyword">const</span>&amp; y)</span>
</span>{
  <span class="hljs-keyword">return</span> !(x &lt; y) &amp;&amp; !(y &lt; x);<font></font>
};</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requer cl√°usula</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos para outro uso da palavra requer - declarar restri√ß√µes de um tipo de modelo. </font><font style="vertical-align: inherit;">Esta √© uma alternativa ao uso de nomes de conceito em vez de nome de tipo. </font><font style="vertical-align: inherit;">No exemplo a seguir, todos os tr√™s m√©todos s√£o equivalentes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  require</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cont&gt;
	<span class="hljs-keyword">requires</span> Sortable&lt;Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span></span>;<font></font>
<font></font>
<span class="hljs-comment">//   require (  )</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span> <span class="hljs-keyword">requires</span> Sortable&lt;Cont&gt;</span>;<font></font>
<font></font>
<span class="hljs-comment">//    typename</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;Sortable Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span>  </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A declara√ß√£o de requisitos pode usar v√°rios predicados combinados por operadores l√≥gicos.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_standard_layout_v&lt;T&gt; &amp;&amp; is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; <font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s;<font></font>
 <font></font>
  fun(<span class="hljs-number">1</span>);  <span class="hljs-comment">// ok</span>
  fun(s);  <span class="hljs-comment">// compiler error</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, basta inverter uma das condi√ß√µes, pois ocorre um erro de compila√ß√£o:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_standard_layout_v&lt;T&gt; &amp;&amp; !is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√° um exemplo que n√£o ser√° compilado</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> !<span class="hljs-function">is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>;	</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A raz√£o para isso s√£o as ambiguidades que surgem ao analisar algumas express√µes. </font><font style="vertical-align: inherit;">Por exemplo, nesse modelo:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; 
  <span class="hljs-keyword">requires</span> (<span class="hljs-keyword">bool</span>)&amp;<span class="hljs-function">T::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
n√£o est√° claro o que atribuir sem assinatura - ao operador ou ao prot√≥tipo da fun√ß√£o foo (). </font><font style="vertical-align: inherit;">Portanto, os desenvolvedores decidiram que, sem par√™nteses, apenas pistas de literais verdadeiros ou falsos, nomes de campos do tipo bool do valor do formul√°rio, valor, T :: value, ns :: trait :: value, podem ser usados ‚Äã‚Äãcomo argumentos para requerer a cl√°usula. Nomes de conceito do tipo Conceito e requer express√µes. </font><font style="vertical-align: inherit;">Tudo o resto deve estar entre par√™nteses:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> (!is_trivial_v&lt;T&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, sobre os recursos predicados da cl√°usula</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere outro exemplo.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; 
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste exemplo, requer usa uma caracter√≠stica que depende do tipo value_type aninhado. </font><font style="vertical-align: inherit;">N√£o se sabe antecipadamente se um tipo arbitr√°rio possui um tipo aninhado que pode ser passado para o modelo. </font><font style="vertical-align: inherit;">Se voc√™ passar, por exemplo, um tipo int simples para esse modelo, haver√° um erro de compila√ß√£o; no entanto, se tivermos duas especializa√ß√µes do modelo, n√£o haver√° erro; </font><font style="vertical-align: inherit;">apenas outra especializa√ß√£o ser√° escolhida.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; 
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"1"</span>; } <font></font>
 <font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"2"</span>; } <font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
  fun(<span class="hljs-number">1</span>);  <span class="hljs-comment">// displays: "2"</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, a especializa√ß√£o √© descartada n√£o apenas quando o predicado da cl√°usula require retorna false, mas tamb√©m quando se mostra incorreto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os par√™nteses ao redor do predicado s√£o um lembrete importante de que na cl√°usula exige o inverso do predicado n√£o √© o oposto do pr√≥prio predicado. </font><font style="vertical-align: inherit;">Assim,</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
significa que a caracter√≠stica est√° correta e retorna verdadeira. </font><font style="vertical-align: inherit;">Em que</font></font><br>
<br>
<pre><code class="cpp hljs">!is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Significaria "a caracter√≠stica est√° correta e retorna falsa" A </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
invers√£o l√≥gica real do primeiro predicado N√ÉO √© ("a caracter√≠stica est√° correta e retorna verdadeira") == "a caracter√≠stica √© INCORRETA ou retorna falsa" - isso √© alcan√ßado de uma maneira um pouco mais complicada - atrav√©s de uma defini√ß√£o expl√≠cita do conceito:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> value_type_valid_and_trivial <font></font>
  = is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;; <font></font>
 <font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> (!value_type_valid_and_trivial&lt;T&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conjun√ß√£o e Disjun√ß√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os operadores l√≥gicos de conjun√ß√£o e disjun√ß√£o parecem normalmente, mas na verdade funcionam um pouco diferente do que no C ++ normal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere dois trechos de c√≥digo muito semelhantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O primeiro √© um predicado sem par√™nteses:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;<font></font>
		|| <span class="hljs-function"><span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> U::value_type&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v, U u)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O segundo √© com colchetes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-keyword">requires</span> (<span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;<font></font>
		 || <span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> U::value_type&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v, U u)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A diferen√ßa est√° apenas entre par√™nteses. </font><font style="vertical-align: inherit;">Mas, por causa disso, no segundo modelo, n√£o existem duas restri√ß√µes unidas por uma "cl√°usula de exig√™ncia", mas uma unida por uma OR l√≥gica usual. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa diferen√ßa √© a seguinte. </font><font style="vertical-align: inherit;">Considere o c√≥digo</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::optional&lt;<span class="hljs-keyword">int</span>&gt; oi {};
<span class="hljs-keyword">int</span> i {};<font></font>
fun(i, oi);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui, o modelo √© instanciado pelos tipos int e std :: optional. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No primeiro caso, o tipo int :: value_type √© inv√°lido e a primeira limita√ß√£o n√£o √© satisfeita. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas o tipo optional :: value_type √© v√°lido, o segundo tra√ßo retorna true e, como existe um operador OR entre as restri√ß√µes, todo o predicado √© satisfeito como um todo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No segundo caso, essa √© uma express√£o √∫nica que cont√©m um tipo inv√°lido, pelo qual √© inv√°lido em geral e o predicado n√£o √© satisfeito. </font><font style="vertical-align: inherit;">Ent√£o, colchetes simples mudam imperceptivelmente o significado do que est√° acontecendo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em conclus√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, nem todos os recursos dos conceitos s√£o mostrados aqui. Eu simplesmente n√£o fui mais longe. Mas como uma primeira impress√£o - uma ideia muito interessante e uma implementa√ß√£o confusa um tanto estranha. E uma sintaxe engra√ßada com repeti√ß√£o exige, o que realmente confunde. H√° realmente t√£o poucas palavras em ingl√™s que voc√™ teve que usar uma palavra para fins completamente diferentes? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A id√©ia com c√≥digo compilado √© definitivamente boa. √â at√© um pouco semelhante a "quase-cita√ß√£o" em macros de sintaxe. Mas valeu a pena misturar a sintaxe especial para verificar os tipos de retorno? IMHO, para isso, seria simplesmente necess√°rio criar uma palavra-chave separada.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A mistura impl√≠cita dos conceitos ‚Äúverdadeiro / falso‚Äù e ‚Äúcompila / n√£o compila‚Äù em uma pilha e, como resultado, piadas com colchetes tamb√©m est√£o erradas. </font><font style="vertical-align: inherit;">Esses s√£o conceitos diferentes e devem existir estritamente em diferentes contextos (embora eu entenda de onde veio - da regra SFINAE, onde c√≥digo n√£o compilado apenas excluiu silenciosamente a especializa√ß√£o da considera√ß√£o). </font><font style="vertical-align: inherit;">Mas se o objetivo dos conceitos √© tornar o c√≥digo o mais expl√≠cito poss√≠vel, valeu a pena arrastar todas essas coisas impl√≠citas para novos recursos? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O artigo foi escrito principalmente com base em </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akrzemi1.wordpress.com/2020/01/29/requires-expression </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akrzemi1.wordpress.com/2020/03/26/requires-clause</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
(h√° muito mais exemplos e recursos interessantes) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
com minhas adi√ß√µes de Em outras fontes, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
todos os exemplos podem ser verificados em</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wandbox.org</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt495380/index.html">Grande firewall eg√≠pcio</a></li>
<li><a href="../pt495384/index.html">Minha experi√™ncia de est√°gio na Microsoft Redmond e recebendo uma oferta</a></li>
<li><a href="../pt495388/index.html">Programa de televis√£o da d√©cada de 1970 que se tornou um ancestral dos eSports</a></li>
<li><a href="../pt495390/index.html">STM32CubeMonitor vale a pena tentar</a></li>
<li><a href="../pt495392/index.html">Como procurar bugs no front end: 4 est√°gios principais</a></li>
<li><a href="../pt495398/index.html">Ro.Ri.Re</a></li>
<li><a href="../pt495400/index.html">Trabalhe com cart√£o SD via interface SPI. Implementa√ß√£o de VHDL</a></li>
<li><a href="../pt495402/index.html">No ano passado, finalmente fotografamos um buraco negro. O que agora?</a></li>
<li><a href="../pt495404/index.html">As a√ß√µes ca√≠das s√£o promissoras? Vamos analisar com python</a></li>
<li><a href="../pt495408/index.html"># 02 - E um byte inteiro n√£o √© suficiente ... | A cruz das mudan√ßas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>