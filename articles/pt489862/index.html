<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëéüèæ üö∂üèæ ‚ò¶Ô∏è Planejando no Go: Parte II - O Agendador Go ü¶î üí≤ ‚è≠Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! Este √© o segundo post de uma s√©rie de tr√™s partes que fornecer√° uma id√©ia da mec√¢nica e da sem√¢ntica do trabalho do planejador no Go. Esta p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Planejando no Go: Parte II - O Agendador Go</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489862/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ol√° Habr! </font><font style="vertical-align: inherit;">Este √© o segundo post de uma s√©rie de tr√™s partes que fornecer√° uma id√©ia da mec√¢nica e da sem√¢ntica do trabalho do planejador no Go. </font><font style="vertical-align: inherit;">Esta postagem √© sobre o planejador Go. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primeira parte</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> desta s√©rie, expliquei aspectos do agendador do sistema operacional que, na minha opini√£o, s√£o importantes para entender e avaliar a sem√¢ntica do agendador Go. </font><font style="vertical-align: inherit;">Neste post, explicarei em um n√≠vel sem√¢ntico como o agendador Go funciona. </font><font style="vertical-align: inherit;">O Go Scheduler √© um sistema complexo e pequenos detalhes mec√¢nicos n√£o s√£o importantes. </font><font style="vertical-align: inherit;">√â importante ter um bom modelo de como tudo funciona e se comporta. </font><font style="vertical-align: inherit;">Isso permitir√° que voc√™ tome as melhores decis√µes de engenharia.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seu programa est√° iniciando</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando o seu programa Go √© iniciado, √© atribu√≠do um processador l√≥gico (P) para cada n√∫cleo virtual definido na m√°quina host. Se voc√™ tiver um processador com v√°rios threads de hardware por n√∫cleo f√≠sico (Hyper-Threading), cada thread de hardware ser√° apresentado ao seu programa como um n√∫cleo virtual. Para entender melhor isso, d√™ uma olhada no relat√≥rio do sistema para o meu MacBook Pro. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b6e/2de/4a8/b6e2de4a805c6a87c95aa0afcef436ac.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ pode ver que eu tenho um processador com 4 n√∫cleos f√≠sicos. Este relat√≥rio n√£o divulga o n√∫mero de threads de hardware por n√∫cleo f√≠sico. O processador Intel Core i7 possui a tecnologia Hyper-Threading, o que significa que o n√∫cleo f√≠sico possui 2 threads de hardware. Isso indica ao Go que 8 n√∫cleos virtuais est√£o dispon√≠veis para executar threads do SO em paralelo. Para verificar isso, considere o seguinte programa:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"runtime"</span><font></font>
)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
<font></font>
    <span class="hljs-comment">// NumCPU returns the number of logical</span>
    <span class="hljs-comment">// CPUs usable by the current process.</span><font></font>
    fmt.Println(runtime.NumCPU())<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando executo este programa no meu computador, o resultado da chamada da fun√ß√£o NumCPU () ser√° 8. Qualquer programa Go executado no meu computador ter√° 8 (P). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> recebe um fluxo do SO ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Esse encadeamento ainda √© gerenciado pelo sistema operacional, e o SO ainda √© respons√°vel por colocar o encadeamento no kernel para execu√ß√£o. Isso significa que, quando executo o Go no meu computador, tenho 8 threads dispon√≠veis para realizar meu trabalho, cada um vinculado individualmente ao P. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada programa Go tamb√©m recebe uma Goroutine inicial ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) A Goroutine √© essencialmente a Coroutine, mas √© Go, por isso substitu√≠mos a letra C por G e obtemos a palavra Goroutine. Voc√™ pode pensar nas Goroutines como threads no n√≠vel do aplicativo e s√£o muito parecidos com os threads do SO. Assim como os threads do sistema operacional s√£o ativados e desativados pelo kernel, os programas de contexto s√£o ativados e desativados pelo contexto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O √∫ltimo quebra-cabe√ßa s√£o as filas de execu√ß√£o. </font><font style="vertical-align: inherit;">Existem duas filas de execu√ß√£o diferentes no planejador Go: a fila de execu√ß√£o global (GRQ) e a fila de execu√ß√£o local (LRQ). </font><font style="vertical-align: inherit;">A cada P √© atribu√≠do um LRQ que controla as goroutinas atribu√≠das para execu√ß√£o no contexto de P. Essas goroutines s√£o ativadas e desativadas no contexto M atribu√≠do a esse P. GRQ √© para goroutines que n√£o foram atribu√≠das a P. Existe um processo para mover as goroutinas do GRQ para o LRQ, que discutiremos mais adiante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A imagem mostra todos esses componentes juntos.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/114/13e/494/11413e494428c2540e349637f34bbec3.png" alt="imagem"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Planejador cooperativo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como dissemos no primeiro post, o agendador do SO √© um agendador de prefer√™ncia. Essencialmente, isso significa que voc√™ n√£o pode prever o que o planejador far√° a qualquer momento. O kernel toma decis√µes e tudo √© n√£o determin√≠stico. Os aplicativos executados no topo do sistema operacional n√£o controlam o que acontece dentro do kernel com agendamento, a menos que usem primitivas de sincroniza√ß√£o, como instru√ß√µes at√¥micas e chamadas mutex.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Go Scheduler faz parte do Go Runtime e o Go Runtime √© incorporado ao seu aplicativo. Isso significa que o planejador Go funciona no espa√ßo do usu√°rio no kernel. A implementa√ß√£o atual do planejador Go n√£o √© preemptiva, mas um planejador interativo. Ser um planejador cooperativo significa que o planejador precisa de eventos claramente definidos no espa√ßo do usu√°rio que ocorrem em pontos seguros do c√≥digo para tomar decis√µes de planejamento.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que √© bom no planejador colaborativo da Go √© que ele parece e parece proativo. </font><font style="vertical-align: inherit;">Voc√™ n√£o pode prever o que o agendador Go far√°. </font><font style="vertical-align: inherit;">Isso se deve ao fato de que a tomada de decis√£o para esse planejador n√£o depende dos desenvolvedores, mas do tempo de execu√ß√£o do Go. </font><font style="vertical-align: inherit;">√â importante pensar no agendador Go como um agendador proativo e, como o agendador √© n√£o determin√≠stico, n√£o √© muito dif√≠cil.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estados de Gorutin</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim como os fluxos, as goroutines t√™m os mesmos tr√™s estados de alto n√≠vel. Eles determinam o papel que o planejador Go desempenha com qualquer goroutine. Goroutin pode estar em um dos tr√™s estados: Aguardando, Pronto ou Cumprindo. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aguardando</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Isso significa que a goroutine est√° parada e aguardando que algo continue. Isso pode ocorrer por motivos como espera pelo sistema operacional (chamadas do sistema) ou sincroniza√ß√£o de chamadas (opera√ß√µes at√¥micas e mutex). Esses tipos de atrasos s√£o a principal causa de baixo desempenho. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prontid√£o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: isso significa que a goroutine deseja tempo para seguir as instru√ß√µes atribu√≠das. </font><font style="vertical-align: inherit;">Se voc√™ tiver muitas goroutines que precisam de tempo, elas precisar√£o esperar mais para obter tempo. </font><font style="vertical-align: inherit;">Al√©m disso, a quantidade de tempo individual que qualquer goroutine recebe √© reduzida √† medida que mais goroutines competem pelo tempo. </font><font style="vertical-align: inherit;">Esse tipo de atraso de agendamento tamb√©m pode causar desempenho ruim. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cumprimento</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : significa que a goroutina foi colocada em M e est√° seguindo suas instru√ß√µes. </font><font style="vertical-align: inherit;">O trabalho associado ao aplicativo foi conclu√≠do. </font><font style="vertical-align: inherit;">√â isso que todo mundo quer.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mudan√ßa de contexto</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Go Scheduler requer eventos de espa√ßo do usu√°rio bem definidos que ocorrem em pontos seguros no c√≥digo para alternar o contexto. </font><font style="vertical-align: inherit;">Esses eventos e pontos seguros aparecem nas chamadas de fun√ß√£o. </font><font style="vertical-align: inherit;">As chamadas de fun√ß√£o s√£o cr√≠ticas para o desempenho do Go Scheduler. </font><font style="vertical-align: inherit;">Se voc√™ executar qualquer loop estreito que n√£o fa√ßa chamadas de fun√ß√£o, causar√° atrasos no planejador e na coleta de lixo. </font><font style="vertical-align: inherit;">√â imperativo que as chamadas de fun√ß√£o ocorram dentro de um per√≠odo de tempo razo√°vel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem quatro classes de eventos que ocorrem nos seus programas Go que permitem ao planejador tomar decis√µes de planejamento. </font><font style="vertical-align: inherit;">Isso n√£o significa que isso sempre aconte√ßa em um desses eventos. </font><font style="vertical-align: inherit;">Isso significa que o planejador obt√©m a oportunidade.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando a palavra-chave go</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coletor de lixo</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chamadas do sistema</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sincroniza√ß√£o</font></font></li>
</ul><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando a</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
palavra-chave </font><i><font style="vertical-align: inherit;">go</font></i><font style="vertical-align: inherit;"> A palavra-chave </font><i><font style="vertical-align: inherit;">go</font></i><font style="vertical-align: inherit;"> √© como voc√™ cria goroutine. </font><font style="vertical-align: inherit;">Assim que uma nova goroutine √© criada, ela oferece ao planejador a oportunidade de tomar uma decis√£o de planejamento. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Garbage Collector (GC)</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Como o GC trabalha com seu pr√≥prio conjunto de goroutines, essas gorutinas precisam de tempo em M para serem executadas. </font><font style="vertical-align: inherit;">Isso for√ßa o GC a criar muito caos no planejamento. </font><font style="vertical-align: inherit;">No entanto, o planejador √© muito inteligente no que a goroutine faz, e ele a usar√° para tomar decis√µes. </font><font style="vertical-align: inherit;">Uma solu√ß√£o razo√°vel √© mudar o contexto para a goroutine, que deseja acessar o recurso do sistema, e mais ningu√©m al√©m dele durante a coleta de lixo. </font><font style="vertical-align: inherit;">Quando o GC funciona, muitas decis√µes de planejamento s√£o tomadas. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chamadas do sistema</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se a goroutine fizer uma chamada do sistema que o far√° bloquear M, o agendador poder√° alternar o contexto para outra goroutine, para o mesmo M. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sincroniza√ß√£o</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Se uma chamada para uma opera√ß√£o at√¥mica, um mutex ou um canal fizer com que a goroutine seja bloqueada, o agendador poder√° alternar o contexto para iniciar uma nova goroutine. </font><font style="vertical-align: inherit;">Uma vez que a goroutine possa funcionar novamente, ela poder√° ser colocada na fila e, eventualmente, voltar para M.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chamadas ass√≠ncronas do sistema</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando o sistema operacional em que voc√™ est√° trabalhando tem a capacidade de processar uma chamada do sistema de forma ass√≠ncrona, o que √© chamado de poller de rede pode ser usado para processar a chamada do sistema com mais efici√™ncia. </font><font style="vertical-align: inherit;">Isso √© feito usando o kqueue (MacOS), epoll (Linux) ou iocp (Windows) nesses respectivos sistemas operacionais.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As chamadas do sistema de rede podem ser tratadas de forma ass√≠ncrona por muitos dos sistemas operacionais que usamos hoje. √â aqui que o pesquisador da rede se mostra, pois seu principal objetivo √© processar as opera√ß√µes da rede. Usando o pesquisador de rede para chamadas do sistema de rede, o planejador pode impedir que goroutines bloqueiem M durante essas chamadas do sistema. Isso ajuda a manter M dispon√≠vel para executar outras goroutines no LRQ P sem a necessidade de criar um novo M. Isso ajuda a reduzir a carga de planejamento no sistema operacional. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A melhor maneira de ver como isso funciona √© ver um exemplo. A figura mostra nosso esquema de planejamento b√°sico. Gorutin-1 √© executado em M, e mais 3 Gorutins est√£o esperando no LRQ para se dedicar a M. O pesquisador da rede est√° ocioso e ele n√£o tem nada para fazer.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d76/7cd/b0f/d767cdb0fd640db3a84e3c87d14f38e3.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na figura a seguir, Gorutin-1 (G1) deseja fazer uma chamada ao sistema de rede, de modo que G1 se move para o pesquisador de rede e √© tratado como uma chamada de sistema de rede ass√≠ncrona. </font><font style="vertical-align: inherit;">Depois que o G1 foi movido para o pesquisador de rede, M agora est√° dispon√≠vel para executar outra goroutine do LRQ. </font><font style="vertical-align: inherit;">Nesse caso, Gorutin-2 muda para M. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/764/93f/af0/76493faf0f599eefae69938878e4ceb1.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na figura a seguir, a chamada de rede do sistema termina com uma chamada de rede ass√≠ncrona e G1 volta para LRQ para P. Depois que G1 pode ser retornado para M, o c√≥digo associado a Go, para o qual Ele responde pode executar novamente. </font><font style="vertical-align: inherit;">A grande vit√≥ria √© que nenhuma Sra. Adicional √© necess√°ria para fazer chamadas ao sistema de rede. </font><font style="vertical-align: inherit;">O pesquisador de rede possui um encadeamento do SO e processa atrav√©s de um loop de eventos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chamadas s√≠ncronas do sistema</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que acontece quando a goroutine deseja fazer uma chamada do sistema que n√£o pode ser executada de forma ass√≠ncrona? </font><font style="vertical-align: inherit;">Nesse caso, o pesquisador da rede n√£o pode ser usado e a goroutine que faz a chamada do sistema bloquear√° M. Isso √© ruim, mas n√£o h√° como evitar isso. </font><font style="vertical-align: inherit;">Um exemplo de chamada de sistema que n√£o pode ser feita de forma ass√≠ncrona s√£o as chamadas de sistema baseadas em arquivo. </font><font style="vertical-align: inherit;">Se voc√™ usar o CGO, poder√° haver outras situa√ß√µes em que a chamada de fun√ß√µes C tamb√©m bloqueie M.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O sistema operacional Windows pode fazer chamadas ass√≠ncronas ao sistema com base em arquivo. </font><font style="vertical-align: inherit;">Tecnicamente, ao trabalhar no Windows, voc√™ pode usar o Poller de rede.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos ver o que acontece com uma chamada de sistema s√≠ncrona (por exemplo, arquivo de E / S) que bloqueia M. A figura mostra nosso diagrama de planejamento b√°sico, mas desta vez G1 far√° uma chamada de sistema s√≠ncrona que bloquear√° M1. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/747/549/a28/747549a28a7a627a3cbd98fffe728fad.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na figura a seguir, o planejador pode determinar que G1 causou um bloqueio M. Nesse momento, o planejador desconecta M1 de P com um G1 de bloqueio ainda anexado. O planejador introduz um novo M2 para servir P. Nesse ponto, o G2 pode ser selecionado no LRQ e inclu√≠do no contexto do M2. Se M j√° existe devido a uma troca anterior, essa transi√ß√£o √© mais r√°pida que a necessidade de criar um novo M.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/966/30c/3dd/96630c3dd34a06fbc5ed5f8b4c8bdfbc.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pr√≥xima etapa completa a chamada do sistema de bloqueio feita pelo G1. </font><font style="vertical-align: inherit;">Nesse ponto, G1 pode retornar ao LRQ e ser atendido novamente por P. M1, depois ser√° retirado para uso futuro se esse cen√°rio for repetido.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/553/0ed/f8c/5530edf8c481aee13a40ff0b55e8e1ed.png" alt="imagem"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roubo de trabalho</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro aspecto do planejador √© que ele √© um planejador de roubo de goroutine. Isso ajuda em v√°rias √°reas a apoiar um planejamento eficaz. Primeiramente, a √∫ltima coisa que voc√™ precisa √© que o M entre no estado de espera, porque assim que isso acontecer, o sistema operacional alternar√° o M do kernel usando o contexto. Isso significa que P n√£o pode fazer nenhum trabalho, mesmo que haja uma Goroutine em um estado √≠ntegro, at√© que M volte para o kernel. O Gorutin Theft tamb√©m ajuda a equilibrar os intervalos de tempo entre todos os Ps, para que o trabalho seja melhor distribu√≠do e executado com mais efici√™ncia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na figura, temos um programa Go multiencadeado com dois Ps servindo quatro Gs cada e um G no GRQ. O que acontece se um de P serve rapidamente todo o seu G?</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e1a/745/eaa/e1a745eaaeab4e91bf35e80d8f16ae34.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, P1 n√£o possui mais goroutines para executar. Mas existem goroutines em condi√ß√µes de trabalho, tanto no LRQ para P2 quanto no GRQ. Este √© o momento em que P1 precisa roubar goroutine. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6f6/190/ccc/6f6190cccec8213c27cadfbb03b67767.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As regras para roubar goroutines s√£o as seguintes. Todo o c√≥digo pode ser visualizado nas fontes de tempo de execu√ß√£o.</font></font><br>
<br>
<pre><code class="go hljs">runtime.schedule() {
    <span class="hljs-comment">// only 1/61 of the time, check the global runnable queue for a G.</span>
    <span class="hljs-comment">// if not found, check the local queue.</span>
    <span class="hljs-comment">// if not found,</span>
    <span class="hljs-comment">//     try to steal from other Ps.</span>
    <span class="hljs-comment">//     if not, check the global runnable queue.</span>
    <span class="hljs-comment">//     if not found, poll network.</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, com base nessas regras, P1 deve verificar P2 quanto √† presen√ßa de goroutines em seu LRQ e pegar metade do que encontrar. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/af2/b9b/ec2/af2b9bec21571656e051799fb3213020.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que acontece se o P2 terminar de servir todos os seus programas e o P1 n√£o tiver mais nada no LRQ? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P2 concluiu todo o seu trabalho e agora deve roubar as goroutines. </font><font style="vertical-align: inherit;">Primeiro, ele examinar√° o LRQ P1, mas n√£o encontrar√° nenhuma Goroutines. </font><font style="vertical-align: inherit;">Em seguida, ele analisar√° o GRQ. </font><font style="vertical-align: inherit;">L√° ele encontrar√° o G9. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4f8/2db/b86/4f82dbb86b9005e458097587792dd462.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P2 rouba G9 do GRQ e come√ßa a fazer o trabalho. </font><font style="vertical-align: inherit;">O bom de todo esse roubo √© que ele permite que M permane√ßa ocupado e n√£o fique inativo.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e12/221/a4a/e12221a4ad60695c5c5c97837e30cfbb.png" alt="imagem"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplo pr√°tico</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com mec√¢nica e sem√¢ntica, quero mostrar como tudo isso se ajusta para que o planejador Go possa fazer mais trabalho ao longo do tempo. Imagine um aplicativo multithread escrito em C, no qual o programa gerencia dois threads do SO que enviam mensagens um para o outro. Existem 2 t√≥picos na imagem que enviam a mensagem para frente e para tr√°s. O segmento 1 recebe o n√∫cleo 1 com altern√¢ncia de contexto e agora est√° em execu√ß√£o, o que permite que o segmento 1 envie sua mensagem ao segmento 2.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bb3/6fb/00d/bb36fb00db345441ca295dd01d153b2b.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, quando o encadeamento 1 termina de enviar a mensagem, agora √© necess√°rio aguardar uma resposta. Isso far√° com que o thread 1 seja desconectado do contexto do kernel 1 e colocado em um estado de espera. Assim que o segmento 2 recebe uma notifica√ß√£o de mensagem, ele entra em um estado √≠ntegro. Agora o sistema operacional pode executar uma altern√¢ncia de contexto e executar o thread 2 no kernel, que acaba sendo o kernel 2. Em seguida, o thread 2 processa a mensagem e envia uma nova mensagem de volta ao thread 1.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4af/66e/0fe/4af66e0fe8440f757063603b6bc161a2.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, o fluxo retorna ao contexto quando a mensagem do fluxo 2 √© recebida pelo fluxo 1. Agora, o fluxo 2 alterna do estado de execu√ß√£o para o estado em espera e o fluxo 1 alterna do estado de espera para o estado pronto e finalmente retorna ao estado de execu√ß√£o, o que permite processar e envie uma nova mensagem de volta. Todas essas altern√¢ncias de contexto e altera√ß√µes de estado levam tempo para serem conclu√≠das, o que limita a velocidade do trabalho. Como cada altern√¢ncia de contexto implica um atraso de ~ 1000 nanossegundos, e esperamos que o hardware execute 12 instru√ß√µes por nanossegundo, observe 12.000 instru√ß√µes que s√£o mais ou menos executadas durante essas altern√¢ncias de contexto. Como esses fluxos tamb√©m se cruzam entre diferentes n√∫cleos,A probabilidade de um atraso adicional na linha de cache tamb√©m √© alta.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a45/b47/127/a45b47127d054f2b56b6c2534c9150bf.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na figura h√° dois gorutins que est√£o em harmonia um com o outro, passando a mensagem para frente e para tr√°s. O G1 obt√©m a chave de contexto M1, que √© executada no Core 1, o que permite que o G1 fa√ßa seu trabalho. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/977/b59/78c/977b5978ca8daa9bfc186c77c901565a.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, quando G1 termina de enviar a mensagem, agora ele precisa aguardar uma resposta. Isso far√° com que G1 seja desconectado do contexto M1 e colocado no estado ocioso. Assim que o G2 √© notificado da mensagem, ela entra em um estado √≠ntegro. Agora, o planejador Go pode executar a altern√¢ncia de contexto e executar G2 no M1, que ainda √© executado no Core 1. Em seguida, o G2 processa a mensagem e envia uma nova mensagem de volta ao G1.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3e8/86c/003/3e886c003a64536731234abde2746ca2.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na pr√≥xima etapa, tudo muda novamente quando a mensagem enviada por G2 √© recebida por G1. Agora, o contexto G2 alterna do estado de execu√ß√£o para o estado de espera, e o contexto G1 alterna do estado de espera para o estado de execu√ß√£o e, finalmente, volta ao estado de execu√ß√£o, o que permite processar e enviar uma nova mensagem de volta. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4db/97b/a31/4db97ba314fa8b14bf6497dcaf15135a.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As coisas na superf√≠cie n√£o parecem ser diferentes. Todas as mesmas mudan√ßas de contexto e de estado ocorrem independentemente de voc√™ usar Streams ou Goroutines. No entanto, existe uma grande diferen√ßa entre o uso de Streams e Gorutin, o que pode n√£o ser √≥bvio √† primeira vista.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se a goroutine for usada, os mesmos threads e kernel do sistema operacional ser√£o usados ‚Äã‚Äãpara todo o processamento. Isso significa que, do ponto de vista do SO, o OS Flow nunca entra em um estado de espera; Nunca. Como resultado, todas as instru√ß√µes que perdemos ao alternar contextos ao usar fluxos n√£o s√£o perdidas ao usar goroutin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essencialmente, o Go transformou o trabalho de E / S / Bloqueio em um trabalho vinculado ao processador no n√≠vel do SO. Como toda altern√¢ncia de contexto ocorre no n√≠vel do aplicativo, n√£o perdemos as mesmas ~ 12 mil instru√ß√µes (em m√©dia) na altern√¢ncia de contexto que perdemos ao usar fluxos. No Go, as mesmas op√ß√µes de contexto custam ~ 200 nanossegundos ou ~ 2,4 mil comandos. O planejador tamb√©m ajuda a melhorar o desempenho das seq√º√™ncias de cache e do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUMA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">√â por isso que n√£o precisamos de mais threads do que os n√∫cleos virtuais. </font><font style="vertical-align: inherit;">O Go pode fazer mais trabalho com o tempo, porque o planejador Go tenta usar menos threads e fazer mais em cada thread, o que ajuda a reduzir a carga no SO e no hardware.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclus√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Go Scheduler √© realmente incr√≠vel na maneira como leva em considera√ß√£o os meandros do sistema operacional e do hardware. A capacidade de transformar a opera√ß√£o de E / S / bloqueio em uma opera√ß√£o ligada ao processador no n√≠vel do sistema operacional √© onde obtemos grandes ganhos no uso de mais energia do processador ao longo do tempo. √â por isso que voc√™ n√£o precisa de mais threads do SO do que dos kernels virtuais. Voc√™ pode esperar razoavelmente que todo o seu trabalho seja realizado (com liga√ß√£o √† CPU e E / S / bloqueios) com um encadeamento do SO por kernel virtual. Isso √© poss√≠vel para aplicativos de rede e outros aplicativos que n√£o precisam de chamadas do sistema que bloqueiam threads do SO.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como desenvolvedor, voc√™ ainda deve entender o que seu aplicativo faz em termos de tipo de trabalho. </font><font style="vertical-align: inherit;">Voc√™ n√£o pode criar uma quantidade ilimitada de goroutines e esperar um desempenho incr√≠vel. </font><font style="vertical-align: inherit;">Menos √© sempre mais, mas com um entendimento dessa sem√¢ntica do planejador Go, voc√™ pode tomar melhores decis√µes de engenharia.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt489852/index.html">Autentica√ß√£o transparente no ASP.Net Core no Linux</a></li>
<li><a href="../pt489854/index.html">Redux vs MobX sem confus√£o</a></li>
<li><a href="../pt489856/index.html">Paradoxo reverso de Banach-Tarski ou como reduzir o volume de dados armazenados em cinco vezes</a></li>
<li><a href="../pt489858/index.html">Internacionaliza√ß√£o: Tornando a Web Acess√≠vel a Todos</a></li>
<li><a href="../pt489860/index.html">A hist√≥ria da Telefunken: a f√™nix da eletr√¥nica alem√£, de Wilhelm II e Goebbels aos Beatles e hoje</a></li>
<li><a href="../pt489868/index.html">Congelando o Mozilla WebThings</a></li>
<li><a href="../pt489870/index.html">Intensivo offline gratuito por Node.js em N√≠jni Novgorod</a></li>
<li><a href="../pt489872/index.html">Como o sistema DLP e o m√≥dulo OCR impediram que os funcion√°rios falsificassem as varreduras de passaporte</a></li>
<li><a href="../pt489874/index.html">Compila√ß√£o cruzada de arquivos Rust para Windows execut√°veis ‚Äã‚Äãno Linux</a></li>
<li><a href="../pt489876/index.html">Como resolvemos o problema de tr√™s mon√≥litos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>