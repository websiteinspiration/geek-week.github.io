<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜🏿 🐏 🤚 Best Practices zur Verbesserung der Leistung in C # 🎃 🏿 🦄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo alle zusammen. Wir haben am Vorabend des Kursbeginns "C # Developer" eine Übersetzung eines weiteren nützlichen Materials vorbereitet . Viel Spa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Best Practices zur Verbesserung der Leistung in C #</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/502498/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo alle zusammen. </font><font style="vertical-align: inherit;">Wir haben am Vorabend des Kursbeginns </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"C # Developer"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Übersetzung eines weiteren nützlichen Materials vorbereitet </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Viel Spaß beim Lesen.</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/q4/xs/kv/q4xskv5-ia4gfwlhgm1hx5e1gdc.png"><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da ich kürzlich eine Liste mit Best Practices in C # für Criteo erstellt habe, dachte ich, es wäre schön, diese öffentlich zu teilen. Der Zweck dieses Artikels besteht darin, eine unvollständige Liste von Codevorlagen bereitzustellen, die vermieden werden sollten, entweder weil sie fragwürdig sind oder weil sie nur schlecht funktionieren. Die Liste mag etwas zufällig erscheinen, da sie leicht aus dem Kontext gerissen ist, aber </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alle</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ihre Elemente wurden irgendwann in unserem Code gefunden und verursachten Probleme in der Produktion. Ich hoffe, dies wird als gute Prävention dienen und Ihre Fehler in Zukunft verhindern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie auch, dass Criteo-Webdienste auf Hochleistungscode basieren, sodass ineffizienter Code vermieden werden muss. In den meisten Anwendungen ist kein spürbarer Unterschied zum Ersetzen einiger dieser Vorlagen erkennbar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und zu guter Letzt wurden einige Punkte (zum Beispiel </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) bereits in vielen Artikeln erörtert, daher werde ich nicht näher darauf eingehen. </font><font style="vertical-align: inherit;">Ziel ist es, eine kompakte Liste von Punkten zu erstellen, auf die Sie achten müssen, und keine detaillierte technische Beschreibung der einzelnen Punkte zu geben.</font></font><a name="habracut"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchrones Warten auf asynchronen Code</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erwarten Sie niemals synchron unfertige Aufgaben. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies gilt unter anderem für : </font></font><code>Task.Wait, Task.Result, Task.GetAwaiter().GetResult(), Task.WaitAny, Task.WaitAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Verallgemeinerung: Jede synchrone Beziehung zwischen zwei Pool-Threads kann zu einer Erschöpfung des Pools führen. </font><font style="vertical-align: inherit;">Die Ursachen dieses Phänomens werden in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem Artikel beschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConfigureAwait</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Ihr Code aus einem Synchronisationskontext aufgerufen werden kann, verwenden Sie ihn </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für jeden Ihrer erwarteten Anrufe. </font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass dies </font></font><code>ConfigureAwait</code> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur bei Verwendung eines Schlüsselworts nützlich ist </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der folgende Code ist beispielsweise bedeutungslos:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//  ConfigureAwait        </span>
<span class="hljs-keyword">var</span> result = ProcessAsync().ConfigureAwait(<span class="hljs-literal">false</span>).GetAwaiter().GetResult();</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asynchrone Leere</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Niemals benutzen</font></font><code>async void</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die in der </font></font><code>async void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">ausgelöste Ausnahme wird in den </font><font style="vertical-align: inherit;">Synchronisationskontext übertragen und führt normalerweise zum Absturz der gesamten Anwendung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie die Aufgabe in Ihrer Methode nicht zurückgeben können (z. B. weil Sie die Schnittstelle implementieren), verschieben Sie den asynchronen Code in eine andere Methode und rufen Sie ihn auf:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">interface</span> <span class="hljs-title">IInterface</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>(<span class="hljs-params"></span>)</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Implementation</span> : <span class="hljs-title">IInterface</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-comment">//      ,</span>
        <span class="hljs-comment">//      </span><font></font>
        _ = DoSomethingAsync();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">DoSomethingAsync</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">100</span>);<font></font>
    }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vermeiden Sie nach Möglichkeit Asynchronität </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus Gewohnheit oder wegen des Muskelgedächtnisses können Sie etwas schreiben wie:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">CallAsync</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> Client();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> client.GetAsync();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl der Code semantisch korrekt ist, ist die Verwendung eines Schlüsselworts </font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier nicht erforderlich und kann in einer stark belasteten Umgebung zu erheblichem Overhead führen. </font><font style="vertical-align: inherit;">Versuchen Sie es nach Möglichkeit zu vermeiden:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">CallAsync</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> Client();
    <span class="hljs-keyword">return</span> _client.GetAsync();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie jedoch, dass Sie nicht auf diese Optimierung zurückgreifen können, wenn Ihr Code in Blöcke eingeschlossen ist (z. B. </font></font><code> try/catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Correct</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> Client())<font></font>
    {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> client.GetAsync();<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">Incorrect</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> Client())<font></font>
    {<font></font>
        <span class="hljs-keyword">return</span> client.GetAsync();<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der falschen Version ( </font></font><code>Incorrect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) wird der Client möglicherweise gelöscht, bevor der </font></font><code>GetAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufruf </font><font style="vertical-align: inherit;">abgeschlossen ist </font><font style="vertical-align: inherit;">, da die Aufgabe innerhalb des using-Blocks nicht durch Warten erwartet wird.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regionale Vergleiche</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie keinen Grund haben, regionale Vergleiche zu verwenden, verwenden Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immer ordinale Vergleiche</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Obwohl dies aufgrund interner Optimierungen für die Datenpräsentationsformulare in den USA keine große Rolle spielt, ist der Vergleich für die Präsentationsformen anderer Regionen um eine Größenordnung langsamer (und unter Linux bis zu zwei Größenordnungen!). </font><font style="vertical-align: inherit;">Da der String-Vergleich in den meisten Anwendungen häufig vorkommt, steigt der Overhead erheblich.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConcurrentBag </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T.</font></font><code>&gt;</code></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Niemals </font></font><code><code>ConcurrentBag&lt;</code>T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ohne Benchmarking verwenden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Diese Sammlung wurde für ganz bestimmte Anwendungsfälle entwickelt (wenn das Element die meiste Zeit von dem Thread, der es in die Warteschlange gestellt hat, aus der Warteschlange ausgeschlossen wird) und unter schwerwiegenden Leistungsproblemen leidet, wenn es für andere Zwecke verwendet wird. Wenn Sie eine Thread-sichere Sammlung benötigen, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bevorzugen ConcurrentQueue </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font><code>&gt;</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReaderWriterLock / ReaderWriterLockSlim </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Niemals </font><font style="vertical-align: inherit;">ohne Benchmarking verwenden. </font></font><code><code>ReaderWriterLock&lt;T&gt;</code>/ReaderWriterLockSlim&lt;T<code>&gt;</code></code><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl die Verwendung dieser Art von spezialisiertem Synchronisationsprimitiv bei der Arbeit mit Lesern und Schreibern verlockend sein kann, sind die Kosten viel höher als bei einfachen </font></font><code>Monitor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(mit einem Schlüsselwort verwendeten </font></font><code>lock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Wenn die Anzahl der Leser, die gleichzeitig den kritischen Abschnitt ausführen, nicht sehr groß ist, reicht die Parallelität nicht aus, um den erhöhten Overhead zu absorbieren, und der Code funktioniert schlechter.</font></font><br>
<br>
</h3><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevorzugen Sie Lambda-Funktionen anstelle von Methodengruppen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie den folgenden Code:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetItems</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> _list.Where(i =&gt; Filter(i));<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Filter</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> element</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resharper schlägt vor, Code ohne Lambda-Funktion neu zu schreiben, was möglicherweise etwas sauberer aussieht:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetItems</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> _list.Where(Filter);<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Filter</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> element</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider führt dies zur Zuweisung von dynamischem Speicher für jeden Anruf. </font><font style="vertical-align: inherit;">Tatsächlich wird der Aufruf wie folgt kompiliert:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetItems</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> _list.Where(<span class="hljs-keyword">new</span> Predicate&lt;<span class="hljs-keyword">int</span>&gt;(Filter));<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Filter</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> element</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies kann erhebliche Auswirkungen auf die Leistung haben, wenn der Code in einem stark belasteten Abschnitt aufgerufen wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch die Verwendung von Lambda-Funktionen wird die Compileroptimierung gestartet, bei der der Delegat in einem statischen Feld zwischengespeichert wird, wodurch eine Zuordnung vermieden wird. </font><font style="vertical-align: inherit;">Dies funktioniert nur, wenn </font></font><code>Filter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">statisch. </font><font style="vertical-align: inherit;">Wenn nicht, können Sie den Delegaten selbst zwischenspeichern:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> Predicate&lt;<span class="hljs-keyword">int</span>&gt; _filter;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Constructor</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    _filter = <span class="hljs-keyword">new</span> Predicate&lt;<span class="hljs-keyword">int</span>&gt;(Filter);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetItems</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> _list.Where(_filter);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Filter</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> element</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufzählungen in Zeichenfolgen konvertieren</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Aufruf </font></font><code>Enum.ToString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>.net</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist recht teuer, weil Reflexion verwendet wird , nach </font><font style="vertical-align: inherit;">innen zu konvertieren, und die virtuelle Methode auf die Struktur provoziert Aufruf Verpackung. </font><font style="vertical-align: inherit;">Dies sollte so weit wie möglich vermieden werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufzählungen können oft durch konstante Zeichenfolgen ersetzt werden:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//       Numbers.One, Numbers.Two, ...</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Numbers<font></font>
{<font></font>
    One,<font></font>
    Two,<font></font>
    Three<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Numbers</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> One = <span class="hljs-string">"One"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> Two = <span class="hljs-string">"Two"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> Three = <span class="hljs-string">"Three"</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie wirklich eine Aufzählung verwenden müssen, sollten Sie den konvertierten Wert in einem Wörterbuch zwischenspeichern, um den Overhead zu amortisieren.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listenvergleich</font></font></h2><br>
<blockquote><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Dies ist in .net Core nicht mehr relevant, da die Optimierung ab Version 2.1 automatisch von JIT durchgeführt wird.</font></font></i></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie Aufzählungen als Flags verwenden, kann es verlockend sein, die folgende Methode zu verwenden </font></font><code>Enum.HasFlag</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">Flags</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Options<font></font>
{<font></font>
    Option1 = <span class="hljs-number">1</span>,<font></font>
    Option2 = <span class="hljs-number">2</span>,<font></font>
    Option3 = <span class="hljs-number">4</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> Options _option;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IsOption2Enabled</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> _option.HasFlag(Options.Option2);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code provoziert zwei Pakete mit Zuordnung: eines für die Konvertierung </font></font><code>Options.Option2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>Enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und das andere für einen virtuellen Aufruf </font></font><code>HasFlag</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Struktur. </font><font style="vertical-align: inherit;">Dies macht diesen Code unverhältnismäßig teuer. </font><font style="vertical-align: inherit;">Stattdessen sollten Sie die Lesbarkeit opfern und binäre Operatoren verwenden:</font></font><br>
 <br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IsOption2Enabled</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> (_option &amp; Options.Option2) == Options.Option2;<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierung von Vergleichsmethoden für Strukturen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie eine Struktur in Vergleichen verwenden (z. B. als Schlüssel für ein Wörterbuch), müssen Sie die Methoden überschreiben </font></font><code>Equals/GetHashCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Standardimplementierung verwendet Reflection und ist sehr langsam. </font><font style="vertical-align: inherit;">Die von Resharper generierte Implementierung ist normalerweise ziemlich gut. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Informationen</font></a><font style="vertical-align: inherit;"> hierzu finden Sie hier: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devblogs.microsoft.com/premier-developer/performance-implications-of-default-struct-equality-in-c</font></font></a></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vermeiden Sie ungeeignete Verpackungen, wenn Sie Strukturen mit Schnittstellen verwenden</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie den folgenden Code:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IntValue</span> : <span class="hljs-title">IValue</span><font></font>
{<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = <span class="hljs-keyword">new</span> IntValue();<font></font>
<font></font>
    LogValue(<span class="hljs-keyword">value</span>);<font></font>
    SendValue(<span class="hljs-keyword">value</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendValue</span>(<span class="hljs-params">IValue <span class="hljs-keyword">value</span></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">// ...</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LogValue</span>(<span class="hljs-params">IValue <span class="hljs-keyword">value</span></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Machen </font></font><code>IntValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strukturiert kann verlockend sein , </font><font style="vertical-align: inherit;">dynamische Zuweisung von </font><font style="vertical-align: inherit;">Speicher zu vermeiden. </font><font style="vertical-align: inherit;">Da </font></font><code>AddValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sie jedoch </font></font><code>SendValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Schnittstelle erwarten und die Schnittstellen eine Referenzsemantik aufweisen, wird der Wert bei jedem Aufruf gepackt, wodurch die Vorteile dieser "Optimierung" zunichte gemacht werden. </font><font style="vertical-align: inherit;">Tatsächlich gibt es sogar noch mehr Speicherzuweisungen als bei </font></font><code>IntValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einer Klasse, da der Wert für jeden Aufruf unabhängig gepackt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie eine API schreiben und erwarten, dass einige Werte Strukturen sind, verwenden Sie generische Methoden:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> IntValue : IValue<font></font>
{<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = <span class="hljs-keyword">new</span> IntValue();<font></font>
<font></font>
    LogValue(<span class="hljs-keyword">value</span>);<font></font>
    SendValue(<span class="hljs-keyword">value</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> SendValue&lt;T&gt;(T <span class="hljs-keyword">value</span>) <span class="hljs-keyword">where</span> T : IValue<font></font>
{<font></font>
    <span class="hljs-comment">// ...</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> LogValue&lt;T&gt;(T <span class="hljs-keyword">value</span>) <span class="hljs-keyword">where</span> T : IValue<font></font>
{<font></font>
    <span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl die Konvertierung dieser Methoden in Universal auf den ersten Blick nutzlos erscheint, können Sie in dem Fall, in dem es sich </font></font><code>IntValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um eine Struktur handelt </font><font style="vertical-align: inherit;">, das Verpacken mit Zuordnung vermeiden </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellationToken-Abonnements immer inline</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie kündigen </font></font><code>CancellationTokenSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, werden alle Abonnements im aktuellen Thread ausgeführt. </font><font style="vertical-align: inherit;">Dies kann zu ungeplanten Pausen oder sogar zu impliziten Deadlocks führen.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> cts = <span class="hljs-keyword">new</span> CancellationTokenSource();<font></font>
cts.Token.Register(() =&gt; Thread.Sleep(<span class="hljs-number">5000</span>));<font></font>
cts.Cancel(); <span class="hljs-comment">//     5 </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können sich diesem Verhalten nicht entziehen. </font></font><code>CancellationTokenSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragen Sie sich </font><font style="vertical-align: inherit;">daher beim Abbrechen </font><font style="vertical-align: inherit;">, ob Sie die Erfassung Ihres aktuellen Threads sicher zulassen können. </font><font style="vertical-align: inherit;">Wenn die Antwort nein ist, wickeln Sie </font><font style="vertical-align: inherit;">den Anruf </font></font><code>Cancel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">innerhalb </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es in dem Thread - </font><font style="vertical-align: inherit;">Pool auszuführen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCompletionSource-Fortsetzungen werden häufig inline ausgeführt</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bei Abonnements </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sind Fortsetzungen </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">häufig inline. </font><font style="vertical-align: inherit;">Dies ist eine gute Optimierung, kann jedoch implizite Fehler verursachen. </font><font style="vertical-align: inherit;">Betrachten Sie beispielsweise das folgende Programm:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><font></font>
{<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ManualResetEventSlim _mutex = <span class="hljs-keyword">new</span> ManualResetEventSlim();<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Deadlock</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">await</span> ProcessAsync();<font></font>
        _mutex.Wait();<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Task <span class="hljs-title">ProcessAsync</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> tcs = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-keyword">bool</span>&gt;();<font></font>
        <font></font>
        Task.Run(() =&gt;<font></font>
        {<font></font>
            Thread.Sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">//  - </span>
            tcs.SetResult(<span class="hljs-literal">true</span>);<font></font>
            _mutex.Set();<font></font>
        });<font></font>
        <font></font>
        <span class="hljs-keyword">return</span> tcs.Task;<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span><font></font>
    {<font></font>
        Deadlock().Wait();<font></font>
        Console.WriteLine(<span class="hljs-string">"Will never get there"</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Aufruf </font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bewirkt </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">dass die Fortsetzung </font></font><code>await ProcessAsync()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im aktuellen Thread ausgeführt wird. </font><font style="vertical-align: inherit;">Daher wird die Anweisung </font></font><code>_mutex.Wait()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von demselben Thread ausgeführt, den sie aufrufen soll </font></font><code>_mutex.Set()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was zu einem Deadlock führt. </font><font style="vertical-align: inherit;">Dies kann durch Übergabe des Parameters </font></font><code>TaskCreationsOptions.RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font><font style="vertical-align: inherit;">vermieden werden </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie keinen guten Grund haben, dies zu vernachlässigen, verwenden Sie </font></font><code>TaskCreationsOptions.RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beim Erstellen </font><font style="vertical-align: inherit;">immer die Option </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seien Sie vorsichtig: Der Code wird auch kompiliert, wenn Sie </font></font><code><b>TaskContinuationOptions</b>.RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stattdessen verwenden </font></font><code><b>TaskCreationOptions</b>.RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber die Parameter werden ignoriert und die Fortsetzungen bleiben weiterhin inline. </font><font style="vertical-align: inherit;">Dies ist ein überraschend häufiger Fehler, da er </font></font><code>TaskContinuationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der </font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">automatischen Vervollständigung </font><font style="vertical-align: inherit;">vorausgeht </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.Run / Task.Factory.StartNew</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie keinen Grund zur Verwendung haben </font></font><code>Task.Factory.StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wählen Sie immer </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Hintergrundaufgabe aus. </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendet sicherere Standardwerte und entpackt vor allem automatisch die zurückgegebene Aufgabe, wodurch nicht offensichtliche Fehler mit asynchronen Methoden verhindert werden können. </font><font style="vertical-align: inherit;">Betrachten Sie das folgende Programm:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">ProcessAsync</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">2000</span>);<font></font>
        Console.WriteLine(<span class="hljs-string">"Processing done"</span>);<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">await</span> Task.Factory.StartNew(ProcessAsync);<font></font>
        Console.WriteLine(<span class="hljs-string">"End of program"</span>);<font></font>
        Console.ReadLine();<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz seines Erscheinungsbilds wird das Programmende früher als die Verarbeitung angezeigt. </font><font style="vertical-align: inherit;">Dies liegt daran, dass es zurückgegeben </font></font><code>Task.Factory.StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird </font></font><code><code>Task&lt;Task&gt;</code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und der Code nur eine externe Aufgabe erwartet. </font><font style="vertical-align: inherit;">Der richtige Code könnte entweder </font></font><code>await Task.Factory.StartNew(ProcessAsync).Unwrap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder sein </font></font><code>await Task.Run(ProcessAsync)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt nur drei gültige Anwendungsfälle </font></font><code>Task.Factory.StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausführen einer Aufgabe in einem anderen Scheduler.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausführen einer Aufgabe in einem dedizierten Thread (mit </font></font><code>TaskCreationOptions.LongRunning</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li>
<li>       (  <code>TaskCreationOptions.PreferFairness</code>).</li>
</ul><br>
<hr><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   .</a><br>
<br>
<hr></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de502486/index.html">Das Buch "Rennen mit der Epidemie. Antibiotika gegen Superbugs "</a></li>
<li><a href="../de502490/index.html">Blinkende restriktive Überzeugungen. Für was und was gibt es</a></li>
<li><a href="../de502492/index.html">Innovationen in Zextras Suite und Zimbra OSE</a></li>
<li><a href="../de502494/index.html">7 Fehler eines Black Friday und wie Magento Cloud funktioniert - Video</a></li>
<li><a href="../de502496/index.html">Einfacher Webzugriff auf LabVIEW VI PHP-Anwendungen über ActiveX Server</a></li>
<li><a href="../de502500/index.html">Die Entwicklung eines Passscanners: vom Sperrholzhandwerk zum echten Geschäft</a></li>
<li><a href="../de502504/index.html">Umgeben Sie die Benutzerziffer</a></li>
<li><a href="../de502508/index.html">Trolley Robot 2.0. Teil 2. Management in rviz und ohne. Elemente der Schönheit in rviz</a></li>
<li><a href="../de502510/index.html">Was in der Cloud zu speichern</a></li>
<li><a href="../de502512/index.html">Ergebnisse des Wettbewerbs der Sofaexperten: die Regeln des wissenschaftlichen Stocherns</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>