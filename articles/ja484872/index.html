<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😨 👩🏼‍🏭 🤚🏽 物理レベルでのフラッシュメモリ内の消去された情報の回復 🆑 😔 👸🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="興味深い記事がHabréに掲載されました（たとえば、）、フラッシュSSDドライブの情報を消去して、実際に情報を消去する方法について。メーカーは、従来の消去では情報を復元できないことを保証しないと主張し、データブロック割り当てテーブルだけでなく、消去された情報を含むメモリ内の実際のデータブロックも消去...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>物理レベルでのフラッシュメモリ内の消去された情報の回復</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484872/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">興味深い記事がHabréに掲載されました（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、フラッシュSSDドライブの情報を消去して、実際に情報を消去する方法について。メーカーは、従来の消去では情報を復元できないことを保証しないと主張し、データブロック割り当てテーブルだけでなく、消去された情報を含むメモリ内の実際のデータブロックも消去する特別な消去機能の使用を推奨しています。完全に消去された情報をフラッシュメモリに復元することはできますか？不要になった（消去されたと思われる）情報の「欠陥」が保存されている未使用の領域を見つけるのは簡単ではありませんか？このトピックに対する私たちの関心は、何か秘密を見つけようとすることではなく、消去する方法を提案して、誰も見つけられないようにする（または正確に言うのがより困難になる）ことが原因です。現在、多くのデバイスに、10以上の複数消去手順のアルゴリズムが組み込まれています。これは、最初に時間がかかり、次にフラッシュメモリリソースを消費し、すぐにそれを無効にします。ただし、推奨事項が抽象的な「2回消去」または「消去、書き留めてから再度消去」するのではなく、特定の量的表現を使用するには、まず情報を回復する方法を学ぶ必要があります。面白い？次に行きましょう...</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zc/zi/6z/zczi6z_wc2d3s2n_jkr_7ykti5m.png" width="500" height="500" alt="画像"> <br>
<br>
<a name="habracut"></a><br>
<h2>.</h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"> </b>
                        <div class="spoiler_text">      ?    ,   100%,  ,  0%.    ,     «0»    «1»     ,   ,    100% ,    .           ,   50%     —     .   -   ? <br>
</div>
                    </div> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フラッシュメモリ内の情報のビットは、「フローティング」ゲートまたはMOSトランジスタのゲート誘電体の領域に電荷として格納されます。充電レベルが特定のレベルよりも高い場合、セルはプログラムされ、それより低い場合、クリーンであると見なされます。ここでは、1つのセルが1ビットをエンコードするときのSLCフラッシュメモリに焦点を当てます。 1つのセルの電荷レベルにいくつかのビットがエンコードされている場合、より複雑なタイプがあります。たとえば、MLC-セルあたり2ビット、条件付きで充電なし= "11"、充電の1/3 = "01"、充電の2/3 = "10"、フル充電はコード "00"に対応します。 QLCの場合、4つのビットがすでに1つのセルに格納されています。これに加えて、あらゆる種類のブロック修正コードが重ねられます。これにより、いくつかのセルに物理的な障害が発生した場合でも、かなり高いレベルの信頼性がすでに得られます。しかし、前述したように、メモリセルに焦点を当てます。1ビットをエンコードします。そして、特に、実験用ウサギは国内のマイクロ回路になります</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16364、16</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mbps。そして、認識を容易にするために、類推を使用します-フラッシュメモリセルを水の入ったグラスとして想像してください。ガラスが空の場合、これは「1」です。完了した場合-「0」。プログラミング操作中、電荷は「フローティングシャッター」に送られます-ガラスを水で満たします。電荷を消去すると、ガラスから水が注がれます。各消去操作の後、この電荷のほとんどが消えますが、小さな部分が残ります-ガラスは濡れたままです。そして、私たちのガラスが濡れている場合-それは以前に水があったことを意味します-セルがプログラムされました-消去された情報を復元する基本的な原理はこの効果に基づいています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ケンブリッジ大学のSergey Skorobogatov（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼から多くの興味深いことを読むことができます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）フローティングシャッター付きのセルで実験を行いました。彼は以前に「0」と「1」が書き込まれたセルに対して消去操作を実行しました。しきい値電圧差の傾向を次の図に示します。</font></font><br>
<img src="https://habrastorage.org/webt/uw/p4/tg/uwp4tgpo24zytx9wslnl4oxicgy.png" width="400" height="400" alt="画像"> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
消去操作が100回実行されるという事実にもかかわらず、プログラムされたセルと、プログラムされていないセルの消去されたセルのしきい値電圧には、明らかに違いがあります。それら。空の湿ったガラスから再び水を注ぐと、まだ湿ったままです。したがって、消去操作の複製は、消去された情報の復元から保護するための安全で効果的な方法ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全にクリーンな、以前は使用されていなかったメモリチップがあるとすると、そのメモリセルは次のようになります。</font></font><br>
<img src="https://habrastorage.org/webt/1r/tb/-m/1rtb-m_iiio6ob9vnilbmoj1fv4.png" alt="画像"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのセルは「1」として読み取られ</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">掃除。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それをプログラムします。</font></font><br>
<img src="https://habrastorage.org/webt/fl/_v/ys/fl_vysoyiynqxsy8qw3fxpx31ea.png" alt="画像"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セルの一部はプログラムされ（水で満たされ）、「0」として読み取られます。一部のセルはクリーンなままでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準の消去手順を実行します。</font></font><br>
<img src="https://habrastorage.org/webt/n8/c7/k1/n8c7k1vxvlv2cusuharlstxcngw.png" alt="画像"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのセルは、クリーンな「1」で読み取られます。残りの充電量は、しきい値を超えるには不十分です。しかし、以前に記録されたセルの過剰な電荷は残ります-ガラスは濡れています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、すべてのコップに水を徐々に加え始めると、以前に湿っていたコップは、常に乾燥していたコップよりもすぐにしきい値を超えます。</font></font><br>
<img src="https://habrastorage.org/webt/jp/8c/jh/jp8cjhind-cattqjve2w7tcg5wy.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下</font></font><br>
<img src="https://habrastorage.org/webt/js/jf/ng/jsjfngx9u8a5ow7pbh_rsv1a7a4.png" alt="画像"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、以前に記録されたすべてのセルがプログラムされた状態に戻るまで</font><font style="vertical-align: inherit;">徐々に追加し</font><font style="vertical-align: inherit;">ます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてがシンプルに見え、システムがハッキングされ、保護されたマイクロコントローラーのファームウェアを復元し、使用済みのメトロカードを「修正」します。そして、まあ、彼らはリバースエンジニアリングバンキングを開始します。</font><font style="vertical-align: inherit;">フラッシュメモリ市場はすべてのマイクロエレクトロニクスを破壊して吸収します...しかし、そうではありません。</font><font style="vertical-align: inherit;">すべてがはるかに複雑です。</font><font style="vertical-align: inherit;">プロセスを非常に複雑にする3つの側面があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.メモリセルを「プログラム」する方法</font></font></h2><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、フラッシュメモリチップでは、1ビットを書き込む標準的なプロセスには最大で数マイクロ秒かかります。特に、16364チップの場合、1バイトのプログラミング時間は200μs以下です。一方では、これはかなり長いプロセスであり、たとえば中断するなど、簡単に「短縮」することができます。しかし、その一方で、記録プロセスは非常に複雑です。まず、フラッシュセルをプログラミングするには、7〜15Vの高電圧が必要です。現代のマイクロ回路では、ユーザーの便宜のために、高圧ポンプユニットがマイクロ回路に統合されており、外部から高電圧を供給する必要がありません。ユニットは、記録動作の開始時に自動的にオンになり、メイン供給電圧から十分なレベルをポンプで送ります。その後、ゲートに高電圧を供給して電荷を導入するプロセスが開始されます。録音プロセスが完了したら、ポンピングユニットがオフになり、ポンピングされた高電圧が「マージ」して、次のメモリセルへの安全な切り替えが可能になります。これらすべてのプロセスについて、内部のデジタルマシンが責任を持ちます。これには、介入やその動作の変更は含まれません。リセットコマンドでさえ、書き込みまたは消去プロセスでは無視されます。電源を切る処理を完了するだけです。しかし、実際には、それがどのように機能するかを知っているマイクロチップ開発者は、さまざまな方法を利用できます。たとえば、より多くの制御機能を備えたテストで使用される方法などです。しかし、この情報は閉鎖されており、オープンソースでの公開は許可されていません。いずれの場合でも、用量追加（トッピング）量子を安全に管理でき、データ回復効果が発生する最小値を決定しました。そして、汲み上げられた高電圧は「マージ」して、次のメモリセルへの安全な切り替えを可能にします。これらすべてのプロセスについて、内部のデジタルマシンが責任を負います。これには、介入やその動作の変更は含まれません。リセットコマンドでさえ、書き込みまたは消去プロセスでは無視されます。電源を切る処理を完了するだけです。しかし、実際には、それがどのように機能するかを知っているマイクロチップ開発者は、さまざまな方法を利用できます。たとえば、より多くの制御機能を持つテストで使用される方法などです。しかし、この情報は閉鎖されており、オープンソースでの公開は許可されていません。いずれの場合でも、私たちは安全に線量追加（トッピング）量子を管理することができ、データ回復効果が発生する最小値を決定しました。そして、汲み上げられた高電圧は「マージ」して、次のメモリセルへの安全な切り替えを可能にします。これらすべてのプロセスについて、内部のデジタルマシンが責任を持ちます。これには、介入やその動作の変更は含まれません。リセットコマンドでさえ、書き込みまたは消去プロセスでは無視されます。電源を切る処理を完了するだけです。しかし、実際には、それがどのように機能するかを知っているマイクロチップ開発者は、さまざまな方法を利用できます。たとえば、より多くの制御機能を備えたテストで使用される方法などです。しかし、この情報は閉鎖されており、オープンソースでの公開は許可されていません。いずれの場合でも、私たちは安全に線量追加（トッピング）量子を管理することができ、データ回復効果が発生する最小値を決定しました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の図は、セルがしきい値を超える最小量子の投与量を示しています。</font></font><br>
<img src="https://habrastorage.org/webt/y7/v7/w-/y7v7w-qgsgmaejevsyxkn5rqdnu.png" alt="画像"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のように、最終的にはすべてのセルが「プログラムされた」しきい値を超えていますが、一部のセルではこれがすぐに行われ、一部のセルでは遅くなっています。そして、図はいくつかのレベルの残差データと事前に記録されたデータを示していますが、これは単なる抽象概念にすぎません。各セルについて、消去して最小の量子で記録を開始した後、ステップNでプログラムされたとしか言えないからです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大量のデータの処理に移りましょう。このため、大量のフラッシュメモリセルを操作できるプログラムが開発されました。</font></font><br>
<img src="https://habrastorage.org/webt/xk/by/mn/xkbymn61sfarrufb67p4e-0u9t4.png" alt="画像"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人間の目は純粋な数学では説明するのが難しいことに気づくので、このプログラムを使用すると、得られた結果をグラフィカルに表示できます。</font><font style="vertical-align: inherit;">さらに、プログラムはいくつかの統計処理操作を実行します。</font><font style="vertical-align: inherit;">たとえば、各上書きサイクルの後、いくつかの読み取りサイクルが実行され、セル値が算術平均として決定されます。</font><font style="vertical-align: inherit;">そして、はい、回復プロセスは非常に長く、自動化なしではそのような調査を実施することは非常に困難です。</font><font style="vertical-align: inherit;">しかし、残念ながら、複数のセルを操作すると、大きな配列を操作しているときに期待できる結果が得られなくなりました。</font><font style="vertical-align: inherit;">それで、第二の側面。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.すべてのメガネは異なります。</font></font></h2><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図からわかるように、調査中、「チェスコード」パターンを使用してメモリを満たし、情報を復元しました。次の図は、プログラミング後と標準の消去手順後のメモリの様子を示しています。</font></font><br>
<img src="https://habrastorage.org/webt/m_/zl/br/m_zlbrshmrnms0_jgkqkdqc383u.png" alt="画像"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
設定を試してみたところ、目で感じた画像を別の領域に復元することができましたが、別の領域に移動すると、画像が完全に破壊されました。これはセクターの境界で特に顕著でした。したがって、すべての細胞が異なるという理解が生まれました。マイクロエレクトロニクスでは、この効果は「ミスマッチ」または要素の再現性と呼ばれます。隣接する同一の要素は非常に類似しており、パラメータが非常に近く、十分な距離だけ離れている場合、完全に同一の要素を描画しても、パラメータが異なります。したがって、私たちのケースでは、一方で、すべてのセルは同じである必要がありますが、それらの動作は大きく異なります。その後の分析では、隣接するセルでも異なる場合があることが示されました。それら。メガネでの類推に戻ると、すべての細胞は次のようになります。</font></font><br>
<img src="https://habrastorage.org/webt/ki/uz/gd/kiuzgdxa6mazpwhiqj1daqoxdb4.png" alt="画像"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらのいくつかは、以前に記録されたことがわかっている場合でも、非常に長い間しきい値に注ぐことができません。逆に、クリーンであることがわかっている場合もありますが、最初の量子の後で記録されます。各セルについて、その動作を大まかに推定できます。しかし、このためには、モデルを作成するために、それを何度も消去し、量子で書き留める必要があります。さらに、マイクロ回路の異なるサンプルの各セルのモデルは異なります。それら。調査したサンプルごとにモデルが作成されます。明らかに、モデルの作成に必要な永続的な記録と消去により、攻撃された（復元された）情報の残りが最終的に消去されます。したがって、アプローチは次のとおりです</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。1.攻撃されたマイクロ回路のサンプルの「型」が作成されます。各セルでは、プログラムされたしきい値を超えたところで量子数が記録されます。</font></font><br>
<img src="https://habrastorage.org/webt/wc/l8/cl/wcl8cl2ykgt4p9pi3y2qymwy9vg.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.マイクロ回路のこのサンプルでは、​​そのバックグラウンドセルのモデルが形成されます。</font></font><br>
<img src="https://habrastorage.org/webt/hk/oj/w_/hkojw_9o9bnahhvtzrwaeabgrsm.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.結果は、「キャスト」と「背景」の違いです。</font></font><br>
<img src="https://habrastorage.org/webt/ir/wx/ia/irwxiabcl95evpnvyaz0itgp-ae.png" alt="画像"><br>
<img src="https://habrastorage.org/webt/kh/yl/3r/khyl3re66sh3qoe0aazsxoqefca.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、情報を十分に復元できることがわかりました。</font><font style="vertical-align: inherit;">統計処理の結果によると、復元された「0」と「1」の「こぶ」は明確に区別できます。</font></font><br>
<img src="https://habrastorage.org/webt/mi/xz/9-/mixz9-hr-ucjxzl5mtedgdlfxoq.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
情報の回復という事実の存在の基準であるのは、そのような「こぶ」の存在です。</font><font style="vertical-align: inherit;">ステップ数が少なく、ステップ数が多いビットのグループがあります。</font><font style="vertical-align: inherit;">こぶの面積の比率-ソース情報の「0」と「1」の比率を反映します。</font><font style="vertical-align: inherit;">これで、タスクの主要部分に進むことができます。</font><font style="vertical-align: inherit;">復元が困難になるようにソース情報を消去する方法。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消去する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この作業の目的は情報を復元することではなく、回復を最も困難にする消去方法を見つけることであったことを思い出してください。</font><font style="vertical-align: inherit;">最初に、標準の消去機能の複数の繰り返しがどのように機能するかを見てみましょう。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
99％マッチを</font><font style="vertical-align: inherit;">消去</font></font><br>
</th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100消去</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
98.6％一致</font></font><br>
</th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000消去</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
98.2％一致</font></font><br>
</th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10,000消去</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
98.1％一致</font></font><br>
</th>
</tr>
<tr>
<td><img src="https://habrastorage.org/webt/to/m5/y2/tom5y2rpqojs9uznli44osvkzjk.png"></td>
<td><img src="https://habrastorage.org/webt/lz/c1/z4/lzc1z4-vddcvpkybje-nimxtc3w.png"></td>
<td><img src="https://habrastorage.org/webt/mv/s2/6o/mvs26oyliupmgs_yubsdwxehmkg.png"></td>
<td><img src="https://habrastorage.org/webt/pk/kr/nh/pkkrnhp3539yb0n4yl1gsn5v9uy.png"></td>
</tr>
<tr>
<td><img src="https://habrastorage.org/webt/rc/ck/ix/rcckixexo7-cgzsecsm52hsfa6w.png"></td>
<td><img src="https://habrastorage.org/webt/ya/bq/uj/yabqujgg1tebbm0kgas_mtxr7xu.png"></td>
<td><img src="https://habrastorage.org/webt/6l/3e/vg/6l3evg0-1l1wptila2dfufpc19k.png"></td>
<td><img src="https://habrastorage.org/webt/_9/87/nl/_987nl0ejc9yj9yrdyvhfu1lwdy.png"></td>
</tr>
</tbody></table></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、標準関数によるメモリの通常の消去では、元の情報を復元する可能性があります。</font><font style="vertical-align: inherit;">消去するだけでは効果がないので、残っているのは1つだけです。消去する前に何かを書き留めてから消去するだけです。</font><font style="vertical-align: inherit;">何を書き留めることができますか？</font><font style="vertical-align: inherit;">以下のオプションが分析されまし</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 た。-疑似ランダムシーケンスの記録。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -以前にプログラムされたセルを含むすべてのセル「0」に記録します（もう一度、消去されたセルまたはクリーンなセル=「1」であることを思い出させます）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -逆データの記録、すなわち </font><font style="vertical-align: inherit;">セルをクリーンアップするには、「0」を追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、そのような結果が得られた。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準消去</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">疑似ランダムシーケンスの記録</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
と消去</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての「0」を記録して消去</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反転データを記録して消去</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回収率99.1％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回収率78.6％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回収率63.6％</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回収率50.1％</font></font></td>
</tr>
<tr>
<td><img src="https://habrastorage.org/webt/58/b4/_d/58b4_dxvpiqnesdvcpg5yrmtkxw.png" width="100"></td>
<td><img src="https://habrastorage.org/webt/nz/nc/0j/nznc0jwhdvjtu2acbuufmlj69h8.png" width="100"></td>
<td><img src="https://habrastorage.org/webt/ie/gj/9q/iegj9qr127vzolxlgzehsfwulho.png" width="100"></td>
<td><img src="https://habrastorage.org/webt/n6/1u/8e/n61u8evfcievjcvlxygtnexl14s.png" width="100"></td>
</tr>
</tbody></table></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
50％-シードの質問で述べたように、最低限の情報回復です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、フラッシュメモリ内の情報を安全に消去するには、以前にプログラムされていないすべてのセルを消去する前に消去し、その後に一般的な消去を実行する場合に、「反転データと消去の書き込み」方法が最適です。これは、顧客のパラノイアに応じて、さらに他のメソッドの実行を妨げるものではありません。しかし、一般的な推奨事項は、消去する前に、プログラムされていないすべてのセルをプログラムする必要があるということです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、このような最終的なスケジュールを取得しました。</font></font><br>
<img src="https://habrastorage.org/webt/b6/pu/lq/b6pulq-rsm70ulzl9qtiftwsdjs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読者の皆さんがこの長い話に飽きていなければ、このスケジュールには恥ずかしいことがあるはずです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X軸に沿った100、1000、10000の数字と混同してください！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らはどういう意味ですか？したがって、フラッシュメモリ内の初期情報が10,000（10,000）回書き込まれた場合にのみ、上記のすべてが有効になります。それら。復旧を試みる前は、「チェスコード」が10,000回記録および消去されていましたが、その後、復旧方法によって情報を復元できました。これが3つ目の側面です。回復レベルが1000および100レコードで減少する方法は、このグラフだけを示しています。 1回限りの記録では、情報を復元できませんでした。したがって、フラッシュメモリとマイクロエレクトロニクスの市場は落ち着くことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PSこの記事は大規模なチームの成果であり、参加者全員に深く感謝します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PPSそして、1つのチップ内の10,000レコードが、同じ情報を持つ10,000の異なるチップで置き換えられるとどうなりますか？</font><font style="vertical-align: inherit;">たとえば、「読み取り保護」ビットで閉じられたマイクロコントローラーにファームウェアがロックされていますか？</font><font style="vertical-align: inherit;">しかし、その次はもっと...</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja484862/index.html">ハイブリッドアプリケーションによるAngularJSからAngular7への移行</a></li>
<li><a href="../ja484864/index.html">Spring Bootによるマイクロサービス。パート2. Forexマイクロサービスの作成</a></li>
<li><a href="../ja484866/index.html">ARM組み込みコンピューターでのAstra Linuxの使用</a></li>
<li><a href="../ja484868/index.html">チームの改善を測定する方法は？パート2</a></li>
<li><a href="../ja484870/index.html">20年間で英語のイロナマスクがどのように変化したか</a></li>
<li><a href="../ja484874/index.html">「あなたのITスペシャリストは壊れています、新しいものを持参してください」：ITでキャリアを築き、夢中にならない方法</a></li>
<li><a href="../ja484876/index.html">修理、ハック、掘る。オンラインクエストDroid Missionの解決</a></li>
<li><a href="../ja484878/index.html">レベルデザインの基本：フロー効果、またはプレイヤーを飽きさせない方法</a></li>
<li><a href="../ja484882/index.html">Windowsターミナルプレビューv0.8がリリースされました</a></li>
<li><a href="../ja484884/index.html">HIPEC。腹腔の悪性腫瘍の数か月ではなく、生涯</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>