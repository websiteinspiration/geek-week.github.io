<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏾 ⛄️ 🕺🏽 STM32MP1: U-Boot, Buildroot, Arch Linux und ein bisschen Debian 👳🏿 👩🏼‍🚒 🧐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 
 
 Vor einiger Zeit hat STMicroelectronics interessante Prozessoren der STM32MP1-Serie auf den Markt gebracht. Als ich endlich das Debug-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>STM32MP1: U-Boot, Buildroot, Arch Linux und ein bisschen Debian</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503600/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor einiger Zeit hat STMicroelectronics interessante Prozessoren der STM32MP1-Serie auf den Markt gebracht. </font><font style="vertical-align: inherit;">Als ich endlich das Debug-Board auf der Basis dieses Prozessors in die Hände bekam, stellte ich überrascht fest, dass es keine Builds gibt, die auf gängigen Distributionen (Debian, Arch Linux usw.) basieren. </font><font style="vertical-align: inherit;">Alles, was blieb, war zu versuchen, ein Distributionskit für dieses Board selbst anzupassen. </font><font style="vertical-align: inherit;">Basierend auf den Ergebnissen dieses Artikels erschien dieser Artikel.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ws/zo/9c/wszo9cao_bq-m_5z9q9fk8moxls.jpeg"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was sind die Eigenschaften?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel wäre ohne einen kurzen Überblick über die Eigenschaften der Prozessoren der STM32MP1-Serie nicht vollständig. </font><font style="vertical-align: inherit;">Die STM32MP1-Serie umfasst drei Prozessorfamilien: STM32MP151, STM32MP153 und STM32MP157. </font><font style="vertical-align: inherit;">Ihre Hauptmerkmale sind in der Tabelle angegeben. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rf/ez/9u/rfez9ud26bcli38_4juxyx-byya.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie der Tabelle entnehmen können, besteht der Unterschied zwischen den Familien darin, dass STM32MP151 einen Kern von Cortex-A7 hat, während STM32MP153 und STM32MP157 zwei solche Kerne haben und STM32MP157 auch 3D-GPU-Unterstützung bietet. </font><font style="vertical-align: inherit;">Im Allgemeinen machen die Eigenschaften dieser Prozessoren im Jahr 2020 jedoch keinen Eindruck, sie sind eher bescheiden. </font><font style="vertical-align: inherit;">Warum habe ich immer noch auf sie geachtet?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum STM32MP1?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Tat kann sich eine völlig logische Frage stellen: Gibt es einen Himbeer-Pi, einen Bananen-Pi, einen Orange-Pi und schließlich - warum brauchen wir einen anderen STM32MP1? </font><font style="vertical-align: inherit;">Darüber hinaus weisen alle diese Boards in der Regel eine deutlich höhere Leistung auf als das Objekt unserer Studie. </font><font style="vertical-align: inherit;">Die Antwort ist einfach: Während Sie für den Heimgebrauch basteln, müssen Sie die Himbeere nehmen, und es wird richtig sein. </font><font style="vertical-align: inherit;">Wenn es sich jedoch um Massenprodukte für industrielle Anwendungen handelt, spielen hier andere Dinge eine entscheidende Rolle, dank derer der STM32MP1 der Gewinner ist:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betriebstemperaturbereich. </font><font style="vertical-align: inherit;">Für STM32MP1 beginnt es bei minus 40 Grad, während es für viele Prozessoren anderer Single-Board-Computer gut ist, wenn es minus 20 ist.</font></font></li>
<li>  .  STMicroelectronics      ,            .</li>
<li>      .   DigiKey  Mouser       STM32MP1,           .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich ist ST32MP1 nicht der einzige Prozessor auf dem Markt für industrielle Anwendungen. </font><font style="vertical-align: inherit;">Es gibt sowohl NXP als auch TI. </font><font style="vertical-align: inherit;">Was TI betrifft, hatte ich ein Projekt eines ziemlich komplexen Moduls, das darauf basierte, und es gab ein Sediment aus einer bemerkenswerten Anzahl von Hardwarefunktionen, die nicht in der Dokumentation behandelt wurden, aber wenn es nicht beachtet wurde, konnte der Prozessor vollständig ausfallen, und zwar nicht sofort, sondern im Laufe der Zeit und im ungünstigsten Moment. </font><font style="vertical-align: inherit;">Darüber hinaus handelte es sich um einen Single-Core-Prozessor, und mit zunehmender Anzahl der ihm zugewiesenen Aufgaben traten immer häufiger Leistungsprobleme auf. </font><font style="vertical-align: inherit;">Zur gleichen Zeit beschäftigte ich mich mit STMicroelectronics-Mikrocontrollern, und sie erwiesen sich als ziemlich gut, also entschied ich mich, diesen neuen Kleinen auszuwählen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug Board</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für Experimente habe ich ein STM32MP157A-DK1-Debugboard gekauft. </font><font style="vertical-align: inherit;">Diese Karte ist in Bezug auf die Ausstattung eher bescheiden: Sie verfügt nicht über ein LCD-Display wie das STM32MP157C-DK2 oder ein so reichhaltiges Peripheriegerät wie das STM32MP157A-EV1. </font><font style="vertical-align: inherit;">Es gibt jedoch einen microSD-Kartensteckplatz, eine USB-UART-Konsole, mehrere USB-Anschlüsse und Ethernet. </font><font style="vertical-align: inherit;">Für den ersten Start mehr als genug. </font><font style="vertical-align: inherit;">Und um die trockene Geschichte mit einem Bild zu verwässern, füge ich ein Foto dieses Debug-Boards bei.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jq/o9/ta/jqo9tap0mu2icbhbofhdjoocquk.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist von vorgefertigter Software?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei STMicroelectronics ist normalerweise alles in Bezug auf Hardware recht gut, aber in Bezug auf Software schrecklich. All diese Modifikationen von Atollic True Studio, CubeMX, CubeIDE, die mit jeder neuen Version mehr und mehr fehlerhaft sind, rufen einige Qualen hervor. Mit der Unterstützung von STM32MP1 ist die Situation etwas besser. STMicroelectronics bietet nur eine bestimmte Baugruppe von OpenSTLinux an. Diese Assembly ist eine Distribution, die mit dem Yocto-Projekt erstellt wurde. Natürlich kann all dies in dieser Form existieren, aber für mich war der Hauptnachteil der fehlende Zugang zu Repositories bekannter Distributionen. Dies bedeutet, dass Sie kein Dienstprogramm aus den Repositorys beliebter Distributionen auf Ihr Board setzen können, indem Sie einfach einen Befehl wie apt-get install ausführen. Oft ist dies für eingebettete Lösungen nicht erforderlich, aber Situationen sind möglich,wenn eine solche Gelegenheit definitiv nicht überflüssig sein wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was werden wir machen?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Aufgabe ist also klar: Wir müssen eine beliebte Distribution auf unserem Debugboard ausführen. </font><font style="vertical-align: inherit;">Meine Wahl fiel auf Arch Linux. </font><font style="vertical-align: inherit;">Dies ist nicht die einfachste Distribution, aber sie ist gut für ARM-Geräte geeignet: Es gibt fertige Baugruppen und eine offizielle </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Website,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die sich diesem </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Thema</font></a><font style="vertical-align: inherit;"> widmet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste, was ich versuchte, das Problem mit einem Snap zu lösen - ich habe gerade den Bootloader-fähigen Kern aus der Distribution von Arch Linux entfernt, die unter armv7 zusammengestellt wurde. </font><font style="vertical-align: inherit;">Dies funktionierte manchmal auf anderen Boards, aber es wartete ein Fiasko auf mich: Trotz der Tatsache, dass der Kernel für die richtige Architektur zusammengestellt wurde, startete er nicht. </font><font style="vertical-align: inherit;">Nun, dann müssen Sie Ihren Kernel und gleichzeitig Ihren Loader zusammenbauen. </font><font style="vertical-align: inherit;">Mein Aktionsplan war folgender:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie den U-Boot-Bootloader.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie den Linux-Kernel. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir markieren die microSD-Karte.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir schreiben den Bootloader, den Kernel und das Root-Dateisystem auf die microSD-Karte.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Profitieren</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Montagevorbereitung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diesen Plan umzusetzen, benötigen wir einen Computer mit Linux und einen Kartenleser für die Aufzeichnung auf einer microSD-Karte. </font><font style="vertical-align: inherit;">Ich habe einen Laptop mit Debian 10 verwendet, aber im Allgemeinen ist dies nicht wichtig, die Namen der Dienstprogramme können sich nur geringfügig unterscheiden. </font><font style="vertical-align: inherit;">Also setzen wir die erforderlichen Dienstprogramme. </font><font style="vertical-align: inherit;">Ich stelle sofort fest, dass ab und zu alle Befehle als root oder über sudo ausgeführt werden müssen.</font></font><br>
<br>
<pre><code class="cpp hljs">apt-get install git<font></font>
apt-get install make<font></font>
apt-get install gcc<font></font>
apt-get install gcc-arm-linux-gnueabihf<font></font>
apt-get install bison<font></font>
apt-get install flex<font></font>
apt-get install g++<font></font>
apt-get install rsync<font></font>
apt-get install libncurses-dev</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur Vorbereitung der Assembly erstellen wir drei Verzeichnisse im Arbeitsverzeichnis: u-boot (für den Bootloader), buildroot (für den Systembuild) und archlinux (für die Distribution):</font></font><br>
<br>
<pre><code class="cpp hljs">mkdir u-boot<font></font>
mkdir buildroot<font></font>
mkdir archlinux</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden diese Verzeichnisse weiter brauchen. </font><font style="vertical-align: inherit;">Ich werde später im Text des Artikels auf diese Namen verweisen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U-Boot-Baugruppe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wurden bereits viele Artikel über U-Boot geschrieben, und als Teil davon werde ich nicht näher darauf eingehen, was es ist, wofür es ist und wie es funktioniert. Ich kann nur sagen, dass dies ein Bootloader ist, der den Linux-Start auf ARM-Geräten ermöglicht. Der Quellcode für den U-Boot-Bootloader ist auf GitHub verfügbar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um U-Boot zu erstellen, klonen wir zunächst das U-Boot-Repository in das zuvor erstellte U-Boot-Verzeichnis:</font></font><br>
<br>
<pre><code class="cpp hljs">git clone https:<span class="hljs-comment">//github.com/u-boot/u-boot</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um U-Boot erfolgreich zu erstellen, benötigen wir eine Gerätebaumdatei und eine U-Boot-Konfigurationsdatei. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Gerätebaumdatei ist eine geräteabhängige Datei. Diese Datei beschreibt die Konfiguration des Prozessors für eine bestimmte Karte. Wenn Sie Ihre Hardware auf einem ARM-Prozessor basieren und Linux darauf ausführen möchten, müssen Sie Ihre Gerätebaumdatei dafür entwickeln (oder eine vorgefertigte anpassen). Viele Debug-Boards haben jedoch bereits vorgefertigte Dateien: Fürsorgliche U-Boot-Entwickler nehmen sie in ihr Repository auf. Schauen Sie sich also das Verzeichnis u-boot / arch / arm / dts an. Es sollte die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datei stm32mp157a-dk1.dtb enthalten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - dies ist die Gerätebaumdatei für unser Debugboard.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der U-Boot-Konfigurationsdatei werden die grundlegenden Bootloader-Einstellungen geschrieben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Konfigurieren von U-Boot von Grund auf ist ein ziemlich langer und mühsamer Prozess, da es so viele Einstellungen gibt. </font><font style="vertical-align: inherit;">Für diese Zwecke gibt es sowohl Konsolen- als auch Grafikkonfiguratoren. </font><font style="vertical-align: inherit;">Hier hatten wir jedoch Glück: Im Verzeichnis u-boot / configs befindet sich eine Datei </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp15_basic_defconfig</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies ist die U-Boot-Grundkonfigurationsdatei für die STM32MP15-Debugboards. </font><font style="vertical-align: inherit;">Wir öffnen diese Datei und sehen, dass es für einen schnellen Start ausreicht, nur eine Zeile zu ändern: stattdessen</font></font><br>
<br>
<pre><code class="cpp hljs">CONFIG_DEFAULT_DEVICE_TREE=”stm32mp157c-ev1”</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
schreiben</font></font><br>
<br>
<pre><code class="cpp hljs">CONFIG_DEFAULT_DEVICE_TREE=”stm32mp157a-dk1”</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dieser Zeile teilen wir dem Bootloader mit, dass wir die Gerätebaumdatei für unser Board verwenden müssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt können Sie U-Boot erstellen. </font><font style="vertical-align: inherit;">Wir verwenden unsere Konfiguration:</font></font><br>
<br>
<pre><code class="cpp hljs">make CROSS_COMPILE=arm-linux-gnueabihf- stm32mp15_basic_defconfig</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Führen Sie die Assembly aus:</font></font><br>
<br>
<pre><code class="cpp hljs">make CROSS_COMPILE=arm-linux-gnueabihf-</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn alles reibungslos lief, sollten wir im U-Boot-Verzeichnis eine Reihe von Dateien haben. </font><font style="vertical-align: inherit;">Von diesen sind zwei für uns von Interesse: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-boot-spl.stm32</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-boot.img</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erste Datei ist der sogenannte First Stage Boot Loader (FSBL). </font><font style="vertical-align: inherit;">Es befindet sich vor dem U-Boot, startet zuerst und initialisiert den DDR3-Speicher, der zum Starten von U-Boot erforderlich ist. </font><font style="vertical-align: inherit;">In anderen Boards wird FSBL häufig mit U-Boot zu einem Image kombiniert. Hier müssen Sie jedoch jedes Image separat auf ein USB-Flash-Laufwerk schreiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles mit U-Boot, speichern Sie die angegebenen Dateien und fahren Sie direkt mit der Linux-Kernel-Assembly fort.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux-Kernel-Assembly</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde Buildroot verwenden, um den Linux-Kernel zu erstellen. Für diese Zwecke können Sie natürlich das ebenso beliebte Yocto verwenden oder sogar versuchen, den Kernel aus der Quelle von kernel.org zu erstellen. Ich hatte jedoch einige Erfahrungen mit Buildroot und habe mich daher dafür entschieden. Darüber hinaus erstellt Buildroot auch das Root-Dateisystem (rootfs) und sogar den U-Boot-Loader. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Laden Sie nun mit allen verfügbaren Mitteln das Archiv von Buildroot von der offiziellen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Website herunter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , entpacken Sie es in das Buildroot-Verzeichnis und rufen Sie es auf. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bei U-Boot müssen Sie sich zunächst um die Konfigurationsdatei für unsere Hardware kümmern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir gehen zum Verzeichnis buildroot / configs und sehen, dass die Entwickler bereits eine Konfigurationsdatei für unser Board hinzugefügt haben: Es gibt eine Datei</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp157a_dk1_defconfig</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (true für Build Build Build-2020.05, in früheren Versionen dieser Datei war dies noch nicht der Fall). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe versucht, den 5.4.26-Kernel mit dieser Konfigurationsdatei zu erstellen, und er wurde im Allgemeinen erfolgreich auf meinem Board gestartet. Aus irgendeinem Grund wurde die Linux-Gerätebaumdatei in dieser Assembly jedoch abgeschnitten: Standardmäßig wurden USB-Anschlüsse nicht einmal unterstützt. Hoffen wir, dass dieser Fehler im Laufe der Zeit behoben wird, aber was tun jetzt?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe dieses Problem googelt und bin auf STMicroelectronics-Repositorys gestoßen, in denen ich Linux 4.19-Quellen mit Patches für ihre Produkte gefunden habe. </font><font style="vertical-align: inherit;">Einschließlich der richtigen DTB-Dateien waren auch da. </font><font style="vertical-align: inherit;">Es bleibt nur Buildroot anzuweisen, dieses Repository beim Erstellen des Kernels zu verwenden. </font><font style="vertical-align: inherit;">Kopieren Sie dazu die Datei stm32mp157a_dk1_defconfig und benennen Sie sie in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp157a_dk1_new_defconfig um</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Öffnen Sie es und nehmen Sie die folgenden Änderungen vor: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stattdessen</font></font><br>
<br>
<pre><code class="cpp hljs">BR2_PACKAGE_HOST_LINUX_HEADERS_CUSTOM_5_4=y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir schreiben </font></font><br>
<br>
<pre><code class="cpp hljs">BR2_PACKAGE_HOST_LINUX_HEADERS_CUSTOM_4_19=y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stattdessen </font></font><br>
<br>
<pre><code class="cpp hljs">BR2_LINUX_KERNEL_CUSTOM_VERSION=y<font></font>
BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE=<span class="hljs-string">"5.4.26"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir schreiben</font></font><br>
<br>
<pre><code class="cpp hljs">BR2_LINUX_KERNEL_CUSTOM_TARBALL=y<font></font>
BR2_LINUX_KERNEL_CUSTOM_TARBALL_LOCATION=<span class="hljs-string">"$(call github,STMicroelectronics,linux,v4.19-stm32mp-r1.2)/linux-v4.19-stm32mp-r1.2.tar.gz"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Speichern und schließen Sie die Datei. </font><font style="vertical-align: inherit;">Die Konfigurationsdatei ist fertig. Wenden wir sie an (Sie müssen sie aus dem Buildroot-Verzeichnis ausführen):</font></font><br>
<br>
<pre><code class="cpp hljs">make CROSS_COMPILE=arm-linux-gnueabihf- stm32mp157a_dk1_new_defconfig</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Befehl überträgt Informationen aus unserer Konfigurationsdatei stm32mp157a_dk1_defconfig in die .config-Datei, die sich im Buildroot-Verzeichnis befindet. In Zukunft wird die Assembly auf der Basis der .config-Datei erstellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt ist fast alles bereit, um den Build-Prozess zu starten, aber vorher müssen Sie unseren Kernel konfigurieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist anzumerken, dass standardmäßig minimale Funktionen im Kernel enthalten sind. Wenn wir es erweitern möchten, muss der Kernel für uns selbst konfiguriert werden. Zumindest müssen Sie dem Kernel Unterstützung für die Kontrollgruppe hinzufügen: Ohne dies wird unser Arch Linux nicht gestartet. Darüber hinaus werde ich als Beispiel zeigen, wie dem Kernel Unterstützung für USB-Flash-Laufwerke hinzugefügt wird: Dadurch kann unser Debug-Board mit Flash-Laufwerken arbeiten.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Führen Sie den Befehl aus, um den Kernel-Konfigurator über das Buildroot-Verzeichnis zu starten</font></font><br>
<br>
<pre><code class="cpp hljs">make linux-menuconfig</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und Tee trinken gehen. </font><font style="vertical-align: inherit;">Dieser Vorgang ist nicht schnell und kann je nach Leistung Ihres Computers zwischen fünfzehn Minuten und mehreren Stunden dauern. </font><font style="vertical-align: inherit;">Wichtig: Während der Arbeit von buildroot benötigen Sie eine stabile Verbindung zum Internet. Viele verschiedene Pakete werden heruntergeladen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn dabei ein Fehler auftritt</font></font><br>
<br>
<pre><code class="cpp hljs">configure: error: <span class="hljs-function">you should <span class="hljs-keyword">not</span> run configure as <span class="hljs-title">root</span> <span class="hljs-params">(<span class="hljs-built_in">set</span> FORCE_UNSAFE_CONFIGURE=<span class="hljs-number">1</span> in environment to bypass <span class="hljs-keyword">this</span> check)</span>
See `config.<span class="hljs-built_in">log</span>' <span class="hljs-keyword">for</span> more details</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
muss den Befehl ausführen</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">export</span> FORCE_UNSAFE_CONFIGURE=<span class="hljs-number">1</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und starten Sie den Kernel-Konfigurator neu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen sollte das Konfiguratorfenster angezeigt werden: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xs/ah/h7/xsahh7p0h-ee5ly4sz54vvg1gcc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unterstützung für Kontrollgruppen hinzufügen: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allgemeine Einrichtung -&gt; Unterstützung für Kontrollgruppen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und das Sternchen mit einem Leerzeichen versehen:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/x-/hu/lm/x-hulmm3zia2p1azslxcwuszfto.jpeg"><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wie füge ich Unterstützung für Flash-Laufwerke hinzu?</font></font></b>
                        <div class="spoiler_text">  SCSI .     80- ,  , ,     USB FLASH .   <b>Device Drivers -&gt; SCSI support</b>       :<br>
<br>
<img src="https://habrastorage.org/webt/kh/59/mq/kh59mqwq_7lppvsozcmqzq4pp94.jpeg"><br>
<br>
     USB FLASH .   <b>Device Drivers -&gt; USB support</b>    <b>USB Mass Storage support</b>:<br>
<br>
<img src="https://habrastorage.org/webt/ar/uu/qy/aruuqyuuanaakzw8mm1givi6yua.jpeg"><br>
<br>
,     FLASH     : <b>File systems -&gt; Native language support -&gt; Codepage 437</b>  <b>File systems -&gt; Native language support -&gt; NLS ISO 8859-1:</b><br>
<br>
<img src="https://habrastorage.org/webt/n2/mt/_x/n2mt_x_utdbu9zdr1dxcugqmaoy.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/0o/sy/f8/0osyf81e1zk8m8fyic9rhhh4yw0.jpeg"><br>
<br>
   ,  USB FLASH      . <br>
</div>
                    </div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem alle Einstellungen im Kernel-Konfigurator vorgenommen wurden, speichern Sie sie mit der Schaltfläche </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und beenden Sie den Konfigurator mit der Schaltfläche </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beenden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt muss der Erstellungsprozess nur noch mit dem folgenden Befehl gestartet werden:</font></font><br>
<br>
<pre><code class="cpp hljs">make CROSS_COMPILE=arm-linux-gnueabihf-</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und Sie können ein zweites Mal Tee trinken gehen, dieser Vorgang nimmt auch viel Zeit in Anspruch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn alles reibungslos verlief, sollten die folgenden Dateien im Verzeichnis buildroot / output / images angezeigt werden:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rootfs.ext2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein kompiliertes Root-Dateisystem mit ext2. </font><font style="vertical-align: inherit;">Es interessiert uns nicht;</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rootfs.ext4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein kompiliertes Root-Dateisystem mit ext4. </font><font style="vertical-align: inherit;">Es wird uns etwas später nützlich sein;</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdcard.img</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ein Image einer microSD-Karte, einschließlich FSBL + U-Boot + zImage + rootfs. </font><font style="vertical-align: inherit;">Als Datei für Faulenzer können Sie sich nicht die Mühe machen, eine microSD-Karte zu markieren und das gesamte System sofort darauf hochzuladen. </font><font style="vertical-align: inherit;">Das ist natürlich nicht unser Weg :).</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp157a-dk1.dtb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Gerätebaumdatei. </font><font style="vertical-align: inherit;">Stellen Sie sicher, dass Sie sich beim Starten des Systems als nützlich erweisen.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-boot.img</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-boot-spl.stm32</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Datei FSBL und U-Boot. </font><font style="vertical-align: inherit;">Da wir sie im letzten Schritt gesammelt haben, brauchen wir sie nicht.</font></font><br>
 <div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum haben wir sie separat gesammelt?</font></font></b>
                        <div class="spoiler_text"> , Buildroot             U-Boot.    ,       .                 U-Boot,        –     Linux.<br>
 </div>
                    </div></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zImage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - das Herzstück des gesamten Systems - eine komprimierte Linux- </font><b><font style="vertical-align: inherit;">Kerneldatei</font></b><font style="vertical-align: inherit;"> .</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit ist der Montageprozess abgeschlossen. Nun markieren wir die microSD-Speicherkarte und erstellen Partitionen darauf.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partitionierung und Abschnitte einer microSD-Karte</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Markieren einer microSD-Karte und das Erstellen von Partitionen ist eine sehr wichtige Phase, die stark an eine bestimmte Hardwareplattform gebunden ist. Leider sind Informationen zu diesem Problem auf einem bestimmten Prozessor nicht immer leicht zu finden, und selbst wenn Sie voll funktionsfähigen U-Boot und den Linux-Kernel sammeln, funktioniert nichts davon mit dem geringsten Fehler im Layout der microSD-Karte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich stelle sofort fest, dass die microSD-Karte, mit der das System auf dem STM32MP1 gestartet wird, über ein GPT-Markup verfügen muss. Das Dienstprogramm </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gdisk</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hilft uns dabei </font><font style="vertical-align: inherit;">, aber dazu später mehr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die microSD-Kartenabschnitte sollten folgendermaßen aussehen:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xs/-l/rr/xs-lrrpr3mi-vrdqemol2sy8szg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie der Abbildung entnehmen können, muss die Karte mindestens 5 Partitionen enthalten: fsbl1, fsbl2, ssbl, kernel, rootfs. </font><font style="vertical-align: inherit;">Darüber hinaus können Sie auch einen oder mehrere Datenabschnitte erstellen, um Informationen darüber zu speichern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die </font><b><font style="vertical-align: inherit;">Abschnitte </font></b></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fsbl1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fsbl2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind vollständig identisch und der primäre Bootloader wird in sie geschrieben (wie Sie sich erinnern, ist dies die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datei u-boot-spl.stm32</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die wir während des U-Boot-Montageprozesses erhalten haben). </font><font style="vertical-align: inherit;">Trotz der Tatsache, dass alles funktionieren sollte und nur ein solcher Abschnitt vorhanden ist, wird in der Dokumentation zu STM2MP1 empfohlen, zwei davon auszuführen. </font><font style="vertical-align: inherit;">Für diese Abschnitte gelten andere Anforderungen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Partition muss 256 KB groß sein.</font></font></li>
<li>    ,      <b>fsbl</b> (fsbl1  fsbl2).   :          ,     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Abschnitt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ssbl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dient zum Schreiben des U-Boot-Bootloaders (der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datei u-boot.img</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die wir während des U-Boot-Montageprozesses erhalten haben). Die empfohlene ssbl-Partitionsgröße beträgt 2 MB. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kernel-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abschnitt </font><font style="vertical-align: inherit;">dient zum Schreiben des Linux-Kernels ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zImage-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datei </font><font style="vertical-align: inherit;">), des Gerätebaums ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp157a-dk1.dtb-Datei</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) sowie des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skripts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für U-Boot, mit dem das System gestartet wird. Die empfohlene Kernel-Partitionsgröße beträgt 64 MB. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Abschnitt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rootfs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dient zum Schreiben des Root-Dateisystems. Wir werden versuchen, das von Buildroot kompilierte Root-Dateisystem sowie das Root-Dateisystem von Arch Linux darauf zu schreiben. Die empfohlene Rootfs-Partitionsgröße beträgt 1 GB oder mehr.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Datenbereich dient zum Speichern von Benutzerdaten. </font><font style="vertical-align: inherit;">Sie können einen solchen oder mehrere Abschnitte erstellen. </font><font style="vertical-align: inherit;">Und darauf können Sie überhaupt verzichten. </font><font style="vertical-align: inherit;">In diesem Artikel werde ich diesen Abschnitt nicht erstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also fangen wir an zu markieren. </font><font style="vertical-align: inherit;">Wir stecken die microSD-Karte mit Linux an Bord in den Kartenleser unseres Computers und bestimmen mit allen verfügbaren Mitteln (z. B. mit dmesg) den Namen des angezeigten Geräts. </font><font style="vertical-align: inherit;">In meinem Fall ist dies / dev / sdb. </font><font style="vertical-align: inherit;">In Ihrem Fall kann es sich um einen anderen Namen handeln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Führen Sie das Dienstprogramm gdisk aus und löschen Sie das Markup auf der microSD-Karte vollständig:</font></font><br>
<br>
<pre><code class="cpp hljs">root@debian:/home/myuser<span class="hljs-meta"># gdisk /dev/sdb</span>
<span class="hljs-function">GPT <span class="hljs-title">fdisk</span> <span class="hljs-params">(gdisk)</span> version 1.0.3
Partition table scan:
  MBR: protective
  BSD: <span class="hljs-keyword">not</span> present
  APM: <span class="hljs-keyword">not</span> present
  GPT: present
Found valid GPT with protective MBR</span>; <span class="hljs-keyword">using</span> GPT.<font></font>
Command (? <span class="hljs-keyword">for</span> help): <span class="hljs-function">x
Expert <span class="hljs-title">command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: z
About to wipe out GPT on /dev/sdb. Proceed? <span class="hljs-params">(Y/N)</span>: y
GPT data structures destroyed! You may now partition the disk <span class="hljs-keyword">using</span> fdisk <span class="hljs-keyword">or</span>
other utilities.
Blank out MBR? <span class="hljs-params">(Y/N)</span>: y</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für alle Fälle hämmern wir den Anfang der microSD-Karte mit Nullen. </font></font><br>
<br>
<pre><code class="cpp hljs">dd <span class="hljs-keyword">if</span>=/dev/zero of=/dev/sdb bs=<span class="hljs-number">1</span>M count=<span class="hljs-number">64</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Führen Sie nun gdisk erneut aus, fügen Sie das Markup hinzu und erstellen Sie 5 Partitionen auf der microSD-Karte gemäß der oben angegebenen Tabelle:</font></font><br>
<br>
<pre><code class="cpp hljs">root@debian:/home/myuser<span class="hljs-meta"># gdisk /dev/sdb</span>
<span class="hljs-function">GPT <span class="hljs-title">fdisk</span> <span class="hljs-params">(gdisk)</span> version 1.0.3

Partition table scan:
  MBR: <span class="hljs-keyword">not</span> present
  BSD: <span class="hljs-keyword">not</span> present
  APM: <span class="hljs-keyword">not</span> present
  GPT: <span class="hljs-keyword">not</span> present

Creating <span class="hljs-keyword">new</span> GPT entries.

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: o
This option deletes all partitions <span class="hljs-keyword">and</span> creates a <span class="hljs-keyword">new</span> protective MBR.
Proceed? <span class="hljs-params">(Y/N)</span>: y

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>)</span>: 1
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">2048</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">2048</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: +<span class="hljs-number">256</span>K<font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">2</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">2</span>)</span>: 2
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">4096</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">4096</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: +<span class="hljs-number">256</span>K<font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">3</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">3</span>)</span>: 3
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">6144</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">6144</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: +<span class="hljs-number">2</span>M<font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">4</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">4</span>)</span>: 4
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">10240</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">10240</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: +<span class="hljs-number">64</span>M<font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">5</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">5</span>)</span>: 5
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">141312</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">141312</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: <font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? <span class="hljs-params">(Y/N)</span>: y
OK</span>; <span class="hljs-function">writing <span class="hljs-keyword">new</span> GUID partition <span class="hljs-title">table</span> <span class="hljs-params">(GPT)</span> to /dev/sdb.
The operation has completed successfully.</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fügen Sie als Nächstes die Namen zu den Abschnitten auf der microSD-Karte hinzu. </font><font style="vertical-align: inherit;">Wie Sie sich erinnern, ist dies besonders wichtig für die ersten Abschnitte, in denen FSBL geschrieben wird: Wenn Sie ihnen nicht die erforderlichen Namen zuweisen, startet das System nicht:</font></font><br>
<br>
<pre><code class="cpp hljs">root@debian:/home/myuser<span class="hljs-meta"># gdisk /dev/sdb</span>
<span class="hljs-function">GPT <span class="hljs-title">fdisk</span> <span class="hljs-params">(gdisk)</span> version 1.0.3

Partition table scan:
  MBR: protective
  BSD: <span class="hljs-keyword">not</span> present
  APM: <span class="hljs-keyword">not</span> present
  GPT: present

Found valid GPT with protective MBR</span>; <span class="hljs-keyword">using</span> GPT.<font></font>
<font></font>
Command (? <span class="hljs-keyword">for</span> help): <span class="hljs-function">c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 1
Enter name: fsbl1

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 2
Enter name: fsbl2

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 3
Enter name: ssbl

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 4
Enter name: kernel

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 5
Enter name: roootfs

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? <span class="hljs-params">(Y/N)</span>: y
OK</span>; <span class="hljs-function">writing <span class="hljs-keyword">new</span> GUID partition <span class="hljs-title">table</span> <span class="hljs-params">(GPT)</span> to /dev/sdb.
The operation has completed successfully.</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende der Arbeit mit der microSD-Karte müssen wir </font><font style="vertical-align: inherit;">dem Abschnitt, in den wir den Linux-Kernel schreiben, das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alte bootfähige BIOS-Attribut</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hinzufügen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ohne dieses Attribut weigerte sich der Kernel zu starten:</font></font><br>
<br>
<pre><code class="cpp hljs">root@debian:/home/myuser<span class="hljs-meta"># gdisk /dev/sdb</span>
<span class="hljs-function">GPT <span class="hljs-title">fdisk</span> <span class="hljs-params">(gdisk)</span> version 1.0.3

Partition table scan:
  MBR: protective
  BSD: <span class="hljs-keyword">not</span> present
  APM: <span class="hljs-keyword">not</span> present
  GPT: present

Found valid GPT with protective MBR</span>; <span class="hljs-keyword">using</span> GPT.<font></font>
<font></font>
Command (? <span class="hljs-keyword">for</span> help): <span class="hljs-function">x

Expert <span class="hljs-title">command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: a
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 4
Known attributes are:
0: system partition
1: hide from EFI
2: legacy BIOS bootable
60: read-only
62: hidden
63: <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> automount

Attribute value is 0000000000000000. Set fields are:
  No fields <span class="hljs-built_in">set</span>

Toggle which attribute <span class="hljs-title">field</span> <span class="hljs-params">(<span class="hljs-number">0</span><span class="hljs-number">-63</span>, <span class="hljs-number">64</span> <span class="hljs-keyword">or</span> &lt;Enter&gt; to <span class="hljs-built_in">exit</span>)</span>: 2
Have enabled the 'legacy BIOS bootable' attribute.
Attribute value is 0000000000000004. Set fields are:
2 <span class="hljs-params">(legacy BIOS bootable)</span>

Toggle which attribute <span class="hljs-title">field</span> <span class="hljs-params">(<span class="hljs-number">0</span><span class="hljs-number">-63</span>, <span class="hljs-number">64</span> <span class="hljs-keyword">or</span> &lt;Enter&gt; to <span class="hljs-built_in">exit</span>)</span>: 

Expert <span class="hljs-title">command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? <span class="hljs-params">(Y/N)</span>: y
OK</span>; <span class="hljs-function">writing <span class="hljs-keyword">new</span> GUID partition <span class="hljs-title">table</span> <span class="hljs-params">(GPT)</span> to /dev/sdb.
The operation has completed successfully.</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles, das Layout der Speicherkarte ist fertig. </font><font style="vertical-align: inherit;">Überprüfen Sie für alle Fälle, ob alles so aufgezeichnet ist, wie es sollte. </font><font style="vertical-align: inherit;">Führen Sie dazu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gdisk</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erneut aus </font><font style="vertical-align: inherit;">und führen Sie den Befehl </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p aus</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Das Ergebnis sollte das Bild </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q9/ko/ff/q9koffmcelcxpna_qtwtfkdlzz8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
anzeigen: Erstellen Sie nun das ext4-Dateisystem unter / dev / sdb4 und / dev / sdb5:</font></font><br>
<br>
<pre><code class="cpp hljs">mkfs.ext4 /dev/sdb4<font></font>
mkfs.ext4 /dev/sdb5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wir schreiben Volumenbezeichnungen vor, damit später leichter darauf zugegriffen werden kann:</font></font><br>
<br>
<pre><code class="cpp hljs">e2label /dev/sdb4 kernel<font></font>
e2label /dev/sdb5 rootfs</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit ist die Erstellung von Abschnitten der Speicherkarte abgeschlossen. Sie können fortfahren, Dateien darauf zu schreiben.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroSD-Kartenaufzeichnung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum gegenwärtigen Zeitpunkt ist also alles für die Aufnahme auf einer microSD-Karte bereit. </font><font style="vertical-align: inherit;">Wir legen es in den Kartenleser des Linux-Computers ein und schreiben den primären Bootloader (FSBL) in den ersten und zweiten Abschnitt der mocroSD-Karte:</font></font><br>
<br>
<pre><code class="cpp hljs">dd <span class="hljs-keyword">if</span>=u-boot/u-boot-spl.stm32 of=/dev/sdb1<font></font>
dd <span class="hljs-keyword">if</span>=u-boot/u-boot-spl.stm32 of=/dev/sdb2</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schreiben Sie nun U-Boot in den dritten Abschnitt der microSD-Karte:</font></font><br>
<br>
<pre><code class="cpp hljs">dd <span class="hljs-keyword">if</span>=u-boot/u-boot.img of=/dev/sdb3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als nächstes müssen Sie den Kernel, die Gerätebaumdatei und das Boot-Skript in den vierten Abschnitt der microSD-Karte kopieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor Sie mit dem Kopieren von Dateien beginnen, benötigen Sie eine kurze Erläuterung des Download-Skripts. In diesem Skript werden tatsächlich verschiedene Informationen für U-Boot angegeben, mit deren Hilfe das System gestartet und die Steuerung an den Kernel übertragen werden kann. Es gibt verschiedene Möglichkeiten, diese Skripte zu schreiben, aber die einfachste (meiner Meinung nach) ist in der Dokumentation zu STM32MP1 beschrieben: Sie müssen das Verzeichnis </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ extlinux</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Stammverzeichnis des </font><b><font style="vertical-align: inherit;">Kernelabschnitts</font></b><font style="vertical-align: inherit;"> erstellen und eine Textdatei mit dem Namen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extlinux.conf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit den folgenden Inhalten </font><font style="vertical-align: inherit;">erstellen </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs">LABEL stm32mp157a-dk1<font></font>
KERNEL /zImage<font></font>
FDT /stm32mp157a-dk1.dtb<font></font>
APPEND root=/dev/mmcblk0p5 rootwait rw console=ttySTM0,<span class="hljs-number">115200</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist alles ganz einfach: Wir teilen dem Loader mit, wo er den Kernel, den Gerätebaum und das Root-Dateisystem erhalten soll, und sagen, dass wir den ttySTM0-Port als Arbeitskonsole haben werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kopieren Sie nun den Kernel:</font></font><br>
<br>
<pre><code class="cpp hljs">cp -a buildroot/output/images/zImage /media/myuser/kernel/</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Im Verzeichnis / media / myuser / mounte ich eine microSD-Karte, wenn sie im Kartenleser installiert ist. </font><font style="vertical-align: inherit;">In Ihrem Fall kann es sich um ein anderes Verzeichnis handeln. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kopieren Sie die Gerätebaumdatei:</font></font><br>
<br>
<pre><code class="cpp hljs">cp -a buildroot/output/images/stm32mp157a-dk1.dtb /media/myuser/kernel/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie ein Verzeichnis:</font></font><br>
<br>
<pre><code class="cpp hljs">mkdir /media/myuser/kernel/extlinux</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie eine Datei:</font></font><br>
<br>
<pre><code class="cpp hljs">nano /media/myuser/kernel/extlinux/extlinux.conf</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und fülle es mit dem Inhalt:</font></font><br>
<br>
<pre><code class="cpp hljs">LABEL stm32mp157a-dk1<font></font>
KERNEL /zImage<font></font>
FDT /stm32mp157a-dk1.dtb<font></font>
APPEND root=/dev/mmcblk0p5 rootwait rw console=ttySTM0,<span class="hljs-number">115200</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Speichern Sie die Datei und schließen Sie den Editor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hierzu ist der vierte Abschnitt der microSD-Karte fertig: Der Linux-Kernel und alle dazugehörigen Hilfsdateien sind bereits geschrieben. </font><font style="vertical-align: inherit;">Wenn Sie bereits zu diesem Zeitpunkt eine microSD-Karte in das Debugboard einlegen, sollte der Linux-Kernel geladen werden. Am Ende stürzt er jedoch in Kernel-Panik ab, da das Root-Dateisystem nicht gemountet werden kann. </font><font style="vertical-align: inherit;">Dies ist nicht überraschend, da wir es bisher aufgenommen haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt die letzte Phase, in der wir das Root-Dateisystem auf die microSD-Karte schreiben. </font><font style="vertical-align: inherit;">Und hier sind verschiedene Möglichkeiten möglich:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schreiben Sie das von Buildroot generierte Root-Dateisystem</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schreiben Sie das Arch Linux-Root-Dateisystem neu</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schreiben Sie zunächst das Root-Dateisystem auf, das Buildroot für uns generiert hat, und versuchen Sie, damit zu beginnen. Dies war nicht der Zweck dieses Artikels, aber es schien mir, dass es im Allgemeinen für alle Anwendungen nützlich sein könnte, zumal diese Aktion nicht viel Zeit in Anspruch nimmt. Das Root-Dateisystem wird mit nur einem Befehl in den fünften Abschnitt unserer microSD-Karte geschrieben:</font></font><br>
<br>
<pre><code class="cpp hljs">dd <span class="hljs-keyword">if</span>=buildroot/output/images/rootfs.ext4 of=/dev/sdb5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setzen Sie nun die Speicherkarte in die Debug-Karte ein und starten Sie das System. Wir werden die Ausgabe von Debugging-Informationen über die USB-UART-Konsole beobachten: Der Zugriff darauf erfolgt über einen Micro-USB-Anschluss auf der STM32MP157A-DK1-Karte. Das Anzeigen der angezeigten Informationen ist in jedem Terminalprogramm möglich, z. B. Putty oder Minicom. Für die Zwecke dieses Artikels habe ich letzteres verwendet, indem ich ein anderes Terminalfenster in Debian geöffnet habe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt setzen wir die microSD-Karte in die Debug-Karte ein, versorgen die Karte mit Strom und sehen uns das Terminal an. Wenn alles richtig gemacht wurde, sollten die FSBL-, U-Boot- und Kernel-Protokolle dort eingefügt werden und schließlich wird eine Einladung zur Eingabe des Logins angezeigt. Wir geben root ein und - voila - gelangen zur Konsole des Systems, das wir gerade gesammelt haben:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1q/hh/sz/1qhhszribllpziacncz6titn6bw.jpeg"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ja, es gibt nicht einmal einen Paketmanager, und im Allgemeinen ist die Funktionalität sehr schlecht, aber mit Hilfe von Buildroot können Sie es sehr cool erstellen und ein wirklich funktionierendes komplexes System erstellen. </font><font style="vertical-align: inherit;">In der Zwischenzeit beträgt seine Größe nur 7 Megabyte! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rq/e7/iv/rqe7iv12mmdleosrwxo8jb-rmj8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem Sie sichergestellt haben, dass das hausgemachte Root-Dateisystem erfolgreich gestartet wurde, ist es Zeit, Arch Linux zu starten. </font><font style="vertical-align: inherit;">Setzen Sie die microSD-Karte erneut in den Kartenleser unseres Computers ein und formatieren Sie den fünften Abschnitt der Speicherkarte erneut:</font></font><br>
<br>
<pre><code class="cpp hljs">mkfs.ext4 /dev/sdb5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Laden Sie das unter armv7 zusammengestellte Archiv mit Arch Linux von der offiziellen Website herunter. </font><font style="vertical-align: inherit;">Entpacken Sie das Archiv in das archlinux-Verzeichnis und verwenden Sie den folgenden Befehl:</font></font><br>
<br>
<pre><code class="cpp hljs">cp -a archlinux<span class="hljs-comment">/* /media/myuser/rootfs </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kopieren Sie es in den rootfs-Bereich der microSD-Karte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir bereinigen das Verzeichnis / media / myuser / rootfs / boot: Wir benötigen den Inhalt nicht, da sich der Kernel und der Gerätebaum in einem separaten Abschnitt der microSD-Karte befinden:</font></font><br>
<br>
<pre><code class="cpp hljs">rm –rf /media/myuser/rootfs/boot<span class="hljs-comment">/*</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Später können Sie die Partition / dev / sdb4 im Boot-Verzeichnis bereitstellen, in dem sich das Kernel-Image befindet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setzen Sie danach die microSD-Karte in das Debug-Board ein, aktivieren Sie die Arbeit und genießen Sie die Arbeit mit ArchLinux: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bj/n8/6i/bjn86iex090rkcggj7v5sz7yayg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem Arch Linux erfolgreich gestartet wurde, habe ich beschlossen, Debian auch auf dem Debug-Board auszuführen. </font><font style="vertical-align: inherit;">Mit absolut ähnlichen Manipulationen mit dem Root-Dateisystem hat es erfolgreich funktioniert:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8h/kg/1c/8hkg1c82dcu2ruov5fm7rdu-j-i.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel haben wir genug mit dem Debug-Board STM32MP157A-DK1 gespielt: Legen Sie U-Boot, den Linux-Kernel und unser eigenes Root-Dateisystem darunter und starten Sie Arch Linux und Debian. </font><font style="vertical-align: inherit;">Ich hoffe, dass dieses Material für jemanden nützlich ist, sowohl bei der Arbeit mit Prozessoren der STM32MP1-Familie als auch mit anderen Single-Boards auf ARM.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nützliche Links</font></font></b>
                        <div class="spoiler_text"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">www.st.com/en/microcontrollers-microprocessors/stm32mp1-series.html</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">wiki.st.com/stm32mpu/wiki/Category</a>:STM32_MPU_microprocessor_devices</div>
                    </div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de503578/index.html">Gute Programmierer kopieren, gute Programmierer stehlen</a></li>
<li><a href="../de503580/index.html">Was ist Big Data?</a></li>
<li><a href="../de503588/index.html">Bill Gates: Was Sie über COVID-19-Impfstoff wissen müssen</a></li>
<li><a href="../de503594/index.html">Fernbeobachter</a></li>
<li><a href="../de503598/index.html">FOSS News Nr. 17 - Überprüfung der kostenlosen und Open Source-Nachrichten für den 18. bis 24. Mai 2020</a></li>
<li><a href="../de503604/index.html">Sergey und "Programmieren ist besser als Sex"</a></li>
<li><a href="../de503606/index.html">Swift 5.3: Was ist neu?</a></li>
<li><a href="../de503608/index.html">Wie wir nach Virenfiltern gesucht haben</a></li>
<li><a href="../de503610/index.html">Warum nicht dein eigenes Lisp für das Web machen?</a></li>
<li><a href="../de503612/index.html">Best Practices von Kubernetes. Zuordnung externer Dienste</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>