<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçü§ù‚Äçüë®üèæ ‚õÑÔ∏è üï∫üèΩ STM32MP1: U-Boot, Buildroot, Arch Linux und ein bisschen Debian üë≥üèø üë©üèº‚Äçüöí üßê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 
 
 Vor einiger Zeit hat STMicroelectronics interessante Prozessoren der STM32MP1-Serie auf den Markt gebracht. Als ich endlich das Debug-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>STM32MP1: U-Boot, Buildroot, Arch Linux und ein bisschen Debian</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503600/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor einiger Zeit hat STMicroelectronics interessante Prozessoren der STM32MP1-Serie auf den Markt gebracht. </font><font style="vertical-align: inherit;">Als ich endlich das Debug-Board auf der Basis dieses Prozessors in die H√§nde bekam, stellte ich √ºberrascht fest, dass es keine Builds gibt, die auf g√§ngigen Distributionen (Debian, Arch Linux usw.) basieren. </font><font style="vertical-align: inherit;">Alles, was blieb, war zu versuchen, ein Distributionskit f√ºr dieses Board selbst anzupassen. </font><font style="vertical-align: inherit;">Basierend auf den Ergebnissen dieses Artikels erschien dieser Artikel.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ws/zo/9c/wszo9cao_bq-m_5z9q9fk8moxls.jpeg"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was sind die Eigenschaften?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel w√§re ohne einen kurzen √úberblick √ºber die Eigenschaften der Prozessoren der STM32MP1-Serie nicht vollst√§ndig. </font><font style="vertical-align: inherit;">Die STM32MP1-Serie umfasst drei Prozessorfamilien: STM32MP151, STM32MP153 und STM32MP157. </font><font style="vertical-align: inherit;">Ihre Hauptmerkmale sind in der Tabelle angegeben. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rf/ez/9u/rfez9ud26bcli38_4juxyx-byya.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie der Tabelle entnehmen k√∂nnen, besteht der Unterschied zwischen den Familien darin, dass STM32MP151 einen Kern von Cortex-A7 hat, w√§hrend STM32MP153 und STM32MP157 zwei solche Kerne haben und STM32MP157 auch 3D-GPU-Unterst√ºtzung bietet. </font><font style="vertical-align: inherit;">Im Allgemeinen machen die Eigenschaften dieser Prozessoren im Jahr 2020 jedoch keinen Eindruck, sie sind eher bescheiden. </font><font style="vertical-align: inherit;">Warum habe ich immer noch auf sie geachtet?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum STM32MP1?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Tat kann sich eine v√∂llig logische Frage stellen: Gibt es einen Himbeer-Pi, einen Bananen-Pi, einen Orange-Pi und schlie√ülich - warum brauchen wir einen anderen STM32MP1? </font><font style="vertical-align: inherit;">Dar√ºber hinaus weisen alle diese Boards in der Regel eine deutlich h√∂here Leistung auf als das Objekt unserer Studie. </font><font style="vertical-align: inherit;">Die Antwort ist einfach: W√§hrend Sie f√ºr den Heimgebrauch basteln, m√ºssen Sie die Himbeere nehmen, und es wird richtig sein. </font><font style="vertical-align: inherit;">Wenn es sich jedoch um Massenprodukte f√ºr industrielle Anwendungen handelt, spielen hier andere Dinge eine entscheidende Rolle, dank derer der STM32MP1 der Gewinner ist:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betriebstemperaturbereich. </font><font style="vertical-align: inherit;">F√ºr STM32MP1 beginnt es bei minus 40 Grad, w√§hrend es f√ºr viele Prozessoren anderer Single-Board-Computer gut ist, wenn es minus 20 ist.</font></font></li>
<li>  .  STMicroelectronics      ,            .</li>
<li>      .   DigiKey  Mouser       STM32MP1,           .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nat√ºrlich ist ST32MP1 nicht der einzige Prozessor auf dem Markt f√ºr industrielle Anwendungen. </font><font style="vertical-align: inherit;">Es gibt sowohl NXP als auch TI. </font><font style="vertical-align: inherit;">Was TI betrifft, hatte ich ein Projekt eines ziemlich komplexen Moduls, das darauf basierte, und es gab ein Sediment aus einer bemerkenswerten Anzahl von Hardwarefunktionen, die nicht in der Dokumentation behandelt wurden, aber wenn es nicht beachtet wurde, konnte der Prozessor vollst√§ndig ausfallen, und zwar nicht sofort, sondern im Laufe der Zeit und im ung√ºnstigsten Moment. </font><font style="vertical-align: inherit;">Dar√ºber hinaus handelte es sich um einen Single-Core-Prozessor, und mit zunehmender Anzahl der ihm zugewiesenen Aufgaben traten immer h√§ufiger Leistungsprobleme auf. </font><font style="vertical-align: inherit;">Zur gleichen Zeit besch√§ftigte ich mich mit STMicroelectronics-Mikrocontrollern, und sie erwiesen sich als ziemlich gut, also entschied ich mich, diesen neuen Kleinen auszuw√§hlen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug Board</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr Experimente habe ich ein STM32MP157A-DK1-Debugboard gekauft. </font><font style="vertical-align: inherit;">Diese Karte ist in Bezug auf die Ausstattung eher bescheiden: Sie verf√ºgt nicht √ºber ein LCD-Display wie das STM32MP157C-DK2 oder ein so reichhaltiges Peripherieger√§t wie das STM32MP157A-EV1. </font><font style="vertical-align: inherit;">Es gibt jedoch einen microSD-Kartensteckplatz, eine USB-UART-Konsole, mehrere USB-Anschl√ºsse und Ethernet. </font><font style="vertical-align: inherit;">F√ºr den ersten Start mehr als genug. </font><font style="vertical-align: inherit;">Und um die trockene Geschichte mit einem Bild zu verw√§ssern, f√ºge ich ein Foto dieses Debug-Boards bei.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jq/o9/ta/jqo9tap0mu2icbhbofhdjoocquk.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist von vorgefertigter Software?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei STMicroelectronics ist normalerweise alles in Bezug auf Hardware recht gut, aber in Bezug auf Software schrecklich. All diese Modifikationen von Atollic True Studio, CubeMX, CubeIDE, die mit jeder neuen Version mehr und mehr fehlerhaft sind, rufen einige Qualen hervor. Mit der Unterst√ºtzung von STM32MP1 ist die Situation etwas besser. STMicroelectronics bietet nur eine bestimmte Baugruppe von OpenSTLinux an. Diese Assembly ist eine Distribution, die mit dem Yocto-Projekt erstellt wurde. Nat√ºrlich kann all dies in dieser Form existieren, aber f√ºr mich war der Hauptnachteil der fehlende Zugang zu Repositories bekannter Distributionen. Dies bedeutet, dass Sie kein Dienstprogramm aus den Repositorys beliebter Distributionen auf Ihr Board setzen k√∂nnen, indem Sie einfach einen Befehl wie apt-get install ausf√ºhren. Oft ist dies f√ºr eingebettete L√∂sungen nicht erforderlich, aber Situationen sind m√∂glich,wenn eine solche Gelegenheit definitiv nicht √ºberfl√ºssig sein wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was werden wir machen?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Aufgabe ist also klar: Wir m√ºssen eine beliebte Distribution auf unserem Debugboard ausf√ºhren. </font><font style="vertical-align: inherit;">Meine Wahl fiel auf Arch Linux. </font><font style="vertical-align: inherit;">Dies ist nicht die einfachste Distribution, aber sie ist gut f√ºr ARM-Ger√§te geeignet: Es gibt fertige Baugruppen und eine offizielle </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Website,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die sich diesem </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Thema</font></a><font style="vertical-align: inherit;"> widmet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste, was ich versuchte, das Problem mit einem Snap zu l√∂sen - ich habe gerade den Bootloader-f√§higen Kern aus der Distribution von Arch Linux entfernt, die unter armv7 zusammengestellt wurde. </font><font style="vertical-align: inherit;">Dies funktionierte manchmal auf anderen Boards, aber es wartete ein Fiasko auf mich: Trotz der Tatsache, dass der Kernel f√ºr die richtige Architektur zusammengestellt wurde, startete er nicht. </font><font style="vertical-align: inherit;">Nun, dann m√ºssen Sie Ihren Kernel und gleichzeitig Ihren Loader zusammenbauen. </font><font style="vertical-align: inherit;">Mein Aktionsplan war folgender:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie den U-Boot-Bootloader.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie den Linux-Kernel. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir markieren die microSD-Karte.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir schreiben den Bootloader, den Kernel und das Root-Dateisystem auf die microSD-Karte.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Profitieren</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Montagevorbereitung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diesen Plan umzusetzen, ben√∂tigen wir einen Computer mit Linux und einen Kartenleser f√ºr die Aufzeichnung auf einer microSD-Karte. </font><font style="vertical-align: inherit;">Ich habe einen Laptop mit Debian 10 verwendet, aber im Allgemeinen ist dies nicht wichtig, die Namen der Dienstprogramme k√∂nnen sich nur geringf√ºgig unterscheiden. </font><font style="vertical-align: inherit;">Also setzen wir die erforderlichen Dienstprogramme. </font><font style="vertical-align: inherit;">Ich stelle sofort fest, dass ab und zu alle Befehle als root oder √ºber sudo ausgef√ºhrt werden m√ºssen.</font></font><br>
<br>
<pre><code class="cpp hljs">apt-get install git<font></font>
apt-get install make<font></font>
apt-get install gcc<font></font>
apt-get install gcc-arm-linux-gnueabihf<font></font>
apt-get install bison<font></font>
apt-get install flex<font></font>
apt-get install g++<font></font>
apt-get install rsync<font></font>
apt-get install libncurses-dev</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur Vorbereitung der Assembly erstellen wir drei Verzeichnisse im Arbeitsverzeichnis: u-boot (f√ºr den Bootloader), buildroot (f√ºr den Systembuild) und archlinux (f√ºr die Distribution):</font></font><br>
<br>
<pre><code class="cpp hljs">mkdir u-boot<font></font>
mkdir buildroot<font></font>
mkdir archlinux</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden diese Verzeichnisse weiter brauchen. </font><font style="vertical-align: inherit;">Ich werde sp√§ter im Text des Artikels auf diese Namen verweisen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U-Boot-Baugruppe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wurden bereits viele Artikel √ºber U-Boot geschrieben, und als Teil davon werde ich nicht n√§her darauf eingehen, was es ist, wof√ºr es ist und wie es funktioniert. Ich kann nur sagen, dass dies ein Bootloader ist, der den Linux-Start auf ARM-Ger√§ten erm√∂glicht. Der Quellcode f√ºr den U-Boot-Bootloader ist auf GitHub verf√ºgbar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um U-Boot zu erstellen, klonen wir zun√§chst das U-Boot-Repository in das zuvor erstellte U-Boot-Verzeichnis:</font></font><br>
<br>
<pre><code class="cpp hljs">git clone https:<span class="hljs-comment">//github.com/u-boot/u-boot</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um U-Boot erfolgreich zu erstellen, ben√∂tigen wir eine Ger√§tebaumdatei und eine U-Boot-Konfigurationsdatei. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ger√§tebaumdatei ist eine ger√§teabh√§ngige Datei. Diese Datei beschreibt die Konfiguration des Prozessors f√ºr eine bestimmte Karte. Wenn Sie Ihre Hardware auf einem ARM-Prozessor basieren und Linux darauf ausf√ºhren m√∂chten, m√ºssen Sie Ihre Ger√§tebaumdatei daf√ºr entwickeln (oder eine vorgefertigte anpassen). Viele Debug-Boards haben jedoch bereits vorgefertigte Dateien: F√ºrsorgliche U-Boot-Entwickler nehmen sie in ihr Repository auf. Schauen Sie sich also das Verzeichnis u-boot / arch / arm / dts an. Es sollte die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datei stm32mp157a-dk1.dtb enthalten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - dies ist die Ger√§tebaumdatei f√ºr unser Debugboard.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der U-Boot-Konfigurationsdatei werden die grundlegenden Bootloader-Einstellungen geschrieben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Konfigurieren von U-Boot von Grund auf ist ein ziemlich langer und m√ºhsamer Prozess, da es so viele Einstellungen gibt. </font><font style="vertical-align: inherit;">F√ºr diese Zwecke gibt es sowohl Konsolen- als auch Grafikkonfiguratoren. </font><font style="vertical-align: inherit;">Hier hatten wir jedoch Gl√ºck: Im Verzeichnis u-boot / configs befindet sich eine Datei </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp15_basic_defconfig</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies ist die U-Boot-Grundkonfigurationsdatei f√ºr die STM32MP15-Debugboards. </font><font style="vertical-align: inherit;">Wir √∂ffnen diese Datei und sehen, dass es f√ºr einen schnellen Start ausreicht, nur eine Zeile zu √§ndern: stattdessen</font></font><br>
<br>
<pre><code class="cpp hljs">CONFIG_DEFAULT_DEVICE_TREE=‚Äùstm32mp157c-ev1‚Äù</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
schreiben</font></font><br>
<br>
<pre><code class="cpp hljs">CONFIG_DEFAULT_DEVICE_TREE=‚Äùstm32mp157a-dk1‚Äù</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dieser Zeile teilen wir dem Bootloader mit, dass wir die Ger√§tebaumdatei f√ºr unser Board verwenden m√ºssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt k√∂nnen Sie U-Boot erstellen. </font><font style="vertical-align: inherit;">Wir verwenden unsere Konfiguration:</font></font><br>
<br>
<pre><code class="cpp hljs">make CROSS_COMPILE=arm-linux-gnueabihf- stm32mp15_basic_defconfig</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºhren Sie die Assembly aus:</font></font><br>
<br>
<pre><code class="cpp hljs">make CROSS_COMPILE=arm-linux-gnueabihf-</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn alles reibungslos lief, sollten wir im U-Boot-Verzeichnis eine Reihe von Dateien haben. </font><font style="vertical-align: inherit;">Von diesen sind zwei f√ºr uns von Interesse: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-boot-spl.stm32</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-boot.img</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erste Datei ist der sogenannte First Stage Boot Loader (FSBL). </font><font style="vertical-align: inherit;">Es befindet sich vor dem U-Boot, startet zuerst und initialisiert den DDR3-Speicher, der zum Starten von U-Boot erforderlich ist. </font><font style="vertical-align: inherit;">In anderen Boards wird FSBL h√§ufig mit U-Boot zu einem Image kombiniert. Hier m√ºssen Sie jedoch jedes Image separat auf ein USB-Flash-Laufwerk schreiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles mit U-Boot, speichern Sie die angegebenen Dateien und fahren Sie direkt mit der Linux-Kernel-Assembly fort.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux-Kernel-Assembly</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde Buildroot verwenden, um den Linux-Kernel zu erstellen. F√ºr diese Zwecke k√∂nnen Sie nat√ºrlich das ebenso beliebte Yocto verwenden oder sogar versuchen, den Kernel aus der Quelle von kernel.org zu erstellen. Ich hatte jedoch einige Erfahrungen mit Buildroot und habe mich daher daf√ºr entschieden. Dar√ºber hinaus erstellt Buildroot auch das Root-Dateisystem (rootfs) und sogar den U-Boot-Loader. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Laden Sie nun mit allen verf√ºgbaren Mitteln das Archiv von Buildroot von der offiziellen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Website herunter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , entpacken Sie es in das Buildroot-Verzeichnis und rufen Sie es auf. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bei U-Boot m√ºssen Sie sich zun√§chst um die Konfigurationsdatei f√ºr unsere Hardware k√ºmmern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir gehen zum Verzeichnis buildroot / configs und sehen, dass die Entwickler bereits eine Konfigurationsdatei f√ºr unser Board hinzugef√ºgt haben: Es gibt eine Datei</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp157a_dk1_defconfig</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (true f√ºr Build Build Build-2020.05, in fr√ºheren Versionen dieser Datei war dies noch nicht der Fall). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe versucht, den 5.4.26-Kernel mit dieser Konfigurationsdatei zu erstellen, und er wurde im Allgemeinen erfolgreich auf meinem Board gestartet. Aus irgendeinem Grund wurde die Linux-Ger√§tebaumdatei in dieser Assembly jedoch abgeschnitten: Standardm√§√üig wurden USB-Anschl√ºsse nicht einmal unterst√ºtzt. Hoffen wir, dass dieser Fehler im Laufe der Zeit behoben wird, aber was tun jetzt?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe dieses Problem googelt und bin auf STMicroelectronics-Repositorys gesto√üen, in denen ich Linux 4.19-Quellen mit Patches f√ºr ihre Produkte gefunden habe. </font><font style="vertical-align: inherit;">Einschlie√ülich der richtigen DTB-Dateien waren auch da. </font><font style="vertical-align: inherit;">Es bleibt nur Buildroot anzuweisen, dieses Repository beim Erstellen des Kernels zu verwenden. </font><font style="vertical-align: inherit;">Kopieren Sie dazu die Datei stm32mp157a_dk1_defconfig und benennen Sie sie in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp157a_dk1_new_defconfig um</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">√ñffnen Sie es und nehmen Sie die folgenden √Ñnderungen vor: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stattdessen</font></font><br>
<br>
<pre><code class="cpp hljs">BR2_PACKAGE_HOST_LINUX_HEADERS_CUSTOM_5_4=y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir schreiben </font></font><br>
<br>
<pre><code class="cpp hljs">BR2_PACKAGE_HOST_LINUX_HEADERS_CUSTOM_4_19=y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stattdessen </font></font><br>
<br>
<pre><code class="cpp hljs">BR2_LINUX_KERNEL_CUSTOM_VERSION=y<font></font>
BR2_LINUX_KERNEL_CUSTOM_VERSION_VALUE=<span class="hljs-string">"5.4.26"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir schreiben</font></font><br>
<br>
<pre><code class="cpp hljs">BR2_LINUX_KERNEL_CUSTOM_TARBALL=y<font></font>
BR2_LINUX_KERNEL_CUSTOM_TARBALL_LOCATION=<span class="hljs-string">"$(call github,STMicroelectronics,linux,v4.19-stm32mp-r1.2)/linux-v4.19-stm32mp-r1.2.tar.gz"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Speichern und schlie√üen Sie die Datei. </font><font style="vertical-align: inherit;">Die Konfigurationsdatei ist fertig. Wenden wir sie an (Sie m√ºssen sie aus dem Buildroot-Verzeichnis ausf√ºhren):</font></font><br>
<br>
<pre><code class="cpp hljs">make CROSS_COMPILE=arm-linux-gnueabihf- stm32mp157a_dk1_new_defconfig</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Befehl √ºbertr√§gt Informationen aus unserer Konfigurationsdatei stm32mp157a_dk1_defconfig in die .config-Datei, die sich im Buildroot-Verzeichnis befindet. In Zukunft wird die Assembly auf der Basis der .config-Datei erstellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt ist fast alles bereit, um den Build-Prozess zu starten, aber vorher m√ºssen Sie unseren Kernel konfigurieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist anzumerken, dass standardm√§√üig minimale Funktionen im Kernel enthalten sind. Wenn wir es erweitern m√∂chten, muss der Kernel f√ºr uns selbst konfiguriert werden. Zumindest m√ºssen Sie dem Kernel Unterst√ºtzung f√ºr die Kontrollgruppe hinzuf√ºgen: Ohne dies wird unser Arch Linux nicht gestartet. Dar√ºber hinaus werde ich als Beispiel zeigen, wie dem Kernel Unterst√ºtzung f√ºr USB-Flash-Laufwerke hinzugef√ºgt wird: Dadurch kann unser Debug-Board mit Flash-Laufwerken arbeiten.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºhren Sie den Befehl aus, um den Kernel-Konfigurator √ºber das Buildroot-Verzeichnis zu starten</font></font><br>
<br>
<pre><code class="cpp hljs">make linux-menuconfig</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und Tee trinken gehen. </font><font style="vertical-align: inherit;">Dieser Vorgang ist nicht schnell und kann je nach Leistung Ihres Computers zwischen f√ºnfzehn Minuten und mehreren Stunden dauern. </font><font style="vertical-align: inherit;">Wichtig: W√§hrend der Arbeit von buildroot ben√∂tigen Sie eine stabile Verbindung zum Internet. Viele verschiedene Pakete werden heruntergeladen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn dabei ein Fehler auftritt</font></font><br>
<br>
<pre><code class="cpp hljs">configure: error: <span class="hljs-function">you should <span class="hljs-keyword">not</span> run configure as <span class="hljs-title">root</span> <span class="hljs-params">(<span class="hljs-built_in">set</span> FORCE_UNSAFE_CONFIGURE=<span class="hljs-number">1</span> in environment to bypass <span class="hljs-keyword">this</span> check)</span>
See `config.<span class="hljs-built_in">log</span>' <span class="hljs-keyword">for</span> more details</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
muss den Befehl ausf√ºhren</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">export</span> FORCE_UNSAFE_CONFIGURE=<span class="hljs-number">1</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und starten Sie den Kernel-Konfigurator neu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen sollte das Konfiguratorfenster angezeigt werden: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xs/ah/h7/xsahh7p0h-ee5ly4sz54vvg1gcc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unterst√ºtzung f√ºr Kontrollgruppen hinzuf√ºgen: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allgemeine Einrichtung -&gt; Unterst√ºtzung f√ºr Kontrollgruppen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und das Sternchen mit einem Leerzeichen versehen:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/x-/hu/lm/x-hulmm3zia2p1azslxcwuszfto.jpeg"><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wie f√ºge ich Unterst√ºtzung f√ºr Flash-Laufwerke hinzu?</font></font></b>
                        <div class="spoiler_text">  SCSI .     80- ,  , ,     USB FLASH .   <b>Device Drivers -&gt; SCSI support</b>       :<br>
<br>
<img src="https://habrastorage.org/webt/kh/59/mq/kh59mqwq_7lppvsozcmqzq4pp94.jpeg"><br>
<br>
     USB FLASH .   <b>Device Drivers -&gt; USB support</b>    <b>USB Mass Storage support</b>:<br>
<br>
<img src="https://habrastorage.org/webt/ar/uu/qy/aruuqyuuanaakzw8mm1givi6yua.jpeg"><br>
<br>
,     FLASH     : <b>File systems -&gt; Native language support -&gt; Codepage 437</b>  <b>File systems -&gt; Native language support -&gt; NLS ISO 8859-1:</b><br>
<br>
<img src="https://habrastorage.org/webt/n2/mt/_x/n2mt_x_utdbu9zdr1dxcugqmaoy.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/0o/sy/f8/0osyf81e1zk8m8fyic9rhhh4yw0.jpeg"><br>
<br>
   ,  USB FLASH      . <br>
</div>
                    </div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem alle Einstellungen im Kernel-Konfigurator vorgenommen wurden, speichern Sie sie mit der Schaltfl√§che </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und beenden Sie den Konfigurator mit der Schaltfl√§che </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beenden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt muss der Erstellungsprozess nur noch mit dem folgenden Befehl gestartet werden:</font></font><br>
<br>
<pre><code class="cpp hljs">make CROSS_COMPILE=arm-linux-gnueabihf-</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und Sie k√∂nnen ein zweites Mal Tee trinken gehen, dieser Vorgang nimmt auch viel Zeit in Anspruch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn alles reibungslos verlief, sollten die folgenden Dateien im Verzeichnis buildroot / output / images angezeigt werden:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rootfs.ext2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein kompiliertes Root-Dateisystem mit ext2. </font><font style="vertical-align: inherit;">Es interessiert uns nicht;</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rootfs.ext4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein kompiliertes Root-Dateisystem mit ext4. </font><font style="vertical-align: inherit;">Es wird uns etwas sp√§ter n√ºtzlich sein;</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdcard.img</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ein Image einer microSD-Karte, einschlie√ülich FSBL + U-Boot + zImage + rootfs. </font><font style="vertical-align: inherit;">Als Datei f√ºr Faulenzer k√∂nnen Sie sich nicht die M√ºhe machen, eine microSD-Karte zu markieren und das gesamte System sofort darauf hochzuladen. </font><font style="vertical-align: inherit;">Das ist nat√ºrlich nicht unser Weg :).</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp157a-dk1.dtb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ger√§tebaumdatei. </font><font style="vertical-align: inherit;">Stellen Sie sicher, dass Sie sich beim Starten des Systems als n√ºtzlich erweisen.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-boot.img</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u-boot-spl.stm32</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Datei FSBL und U-Boot. </font><font style="vertical-align: inherit;">Da wir sie im letzten Schritt gesammelt haben, brauchen wir sie nicht.</font></font><br>
 <div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum haben wir sie separat gesammelt?</font></font></b>
                        <div class="spoiler_text"> , Buildroot             U-Boot.    ,       .                 U-Boot,        ‚Äì     Linux.<br>
 </div>
                    </div></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zImage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - das Herzst√ºck des gesamten Systems - eine komprimierte Linux- </font><b><font style="vertical-align: inherit;">Kerneldatei</font></b><font style="vertical-align: inherit;"> .</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit ist der Montageprozess abgeschlossen. Nun markieren wir die microSD-Speicherkarte und erstellen Partitionen darauf.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partitionierung und Abschnitte einer microSD-Karte</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Markieren einer microSD-Karte und das Erstellen von Partitionen ist eine sehr wichtige Phase, die stark an eine bestimmte Hardwareplattform gebunden ist. Leider sind Informationen zu diesem Problem auf einem bestimmten Prozessor nicht immer leicht zu finden, und selbst wenn Sie voll funktionsf√§higen U-Boot und den Linux-Kernel sammeln, funktioniert nichts davon mit dem geringsten Fehler im Layout der microSD-Karte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich stelle sofort fest, dass die microSD-Karte, mit der das System auf dem STM32MP1 gestartet wird, √ºber ein GPT-Markup verf√ºgen muss. Das Dienstprogramm </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gdisk</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hilft uns dabei </font><font style="vertical-align: inherit;">, aber dazu sp√§ter mehr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die microSD-Kartenabschnitte sollten folgenderma√üen aussehen:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xs/-l/rr/xs-lrrpr3mi-vrdqemol2sy8szg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie der Abbildung entnehmen k√∂nnen, muss die Karte mindestens 5 Partitionen enthalten: fsbl1, fsbl2, ssbl, kernel, rootfs. </font><font style="vertical-align: inherit;">Dar√ºber hinaus k√∂nnen Sie auch einen oder mehrere Datenabschnitte erstellen, um Informationen dar√ºber zu speichern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die </font><b><font style="vertical-align: inherit;">Abschnitte </font></b></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fsbl1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fsbl2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind vollst√§ndig identisch und der prim√§re Bootloader wird in sie geschrieben (wie Sie sich erinnern, ist dies die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datei u-boot-spl.stm32</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die wir w√§hrend des U-Boot-Montageprozesses erhalten haben). </font><font style="vertical-align: inherit;">Trotz der Tatsache, dass alles funktionieren sollte und nur ein solcher Abschnitt vorhanden ist, wird in der Dokumentation zu STM2MP1 empfohlen, zwei davon auszuf√ºhren. </font><font style="vertical-align: inherit;">F√ºr diese Abschnitte gelten andere Anforderungen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Partition muss 256 KB gro√ü sein.</font></font></li>
<li>    ,      <b>fsbl</b> (fsbl1  fsbl2).   :          ,     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Abschnitt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ssbl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dient zum Schreiben des U-Boot-Bootloaders (der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datei u-boot.img</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die wir w√§hrend des U-Boot-Montageprozesses erhalten haben). Die empfohlene ssbl-Partitionsgr√∂√üe betr√§gt 2 MB. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kernel-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abschnitt </font><font style="vertical-align: inherit;">dient zum Schreiben des Linux-Kernels ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zImage-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datei </font><font style="vertical-align: inherit;">), des Ger√§tebaums ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32mp157a-dk1.dtb-Datei</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) sowie des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skripts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr U-Boot, mit dem das System gestartet wird. Die empfohlene Kernel-Partitionsgr√∂√üe betr√§gt 64 MB. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Abschnitt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rootfs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dient zum Schreiben des Root-Dateisystems. Wir werden versuchen, das von Buildroot kompilierte Root-Dateisystem sowie das Root-Dateisystem von Arch Linux darauf zu schreiben. Die empfohlene Rootfs-Partitionsgr√∂√üe betr√§gt 1 GB oder mehr.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Datenbereich dient zum Speichern von Benutzerdaten. </font><font style="vertical-align: inherit;">Sie k√∂nnen einen solchen oder mehrere Abschnitte erstellen. </font><font style="vertical-align: inherit;">Und darauf k√∂nnen Sie √ºberhaupt verzichten. </font><font style="vertical-align: inherit;">In diesem Artikel werde ich diesen Abschnitt nicht erstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also fangen wir an zu markieren. </font><font style="vertical-align: inherit;">Wir stecken die microSD-Karte mit Linux an Bord in den Kartenleser unseres Computers und bestimmen mit allen verf√ºgbaren Mitteln (z. B. mit dmesg) den Namen des angezeigten Ger√§ts. </font><font style="vertical-align: inherit;">In meinem Fall ist dies / dev / sdb. </font><font style="vertical-align: inherit;">In Ihrem Fall kann es sich um einen anderen Namen handeln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºhren Sie das Dienstprogramm gdisk aus und l√∂schen Sie das Markup auf der microSD-Karte vollst√§ndig:</font></font><br>
<br>
<pre><code class="cpp hljs">root@debian:/home/myuser<span class="hljs-meta"># gdisk /dev/sdb</span>
<span class="hljs-function">GPT <span class="hljs-title">fdisk</span> <span class="hljs-params">(gdisk)</span> version 1.0.3
Partition table scan:
  MBR: protective
  BSD: <span class="hljs-keyword">not</span> present
  APM: <span class="hljs-keyword">not</span> present
  GPT: present
Found valid GPT with protective MBR</span>; <span class="hljs-keyword">using</span> GPT.<font></font>
Command (? <span class="hljs-keyword">for</span> help): <span class="hljs-function">x
Expert <span class="hljs-title">command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: z
About to wipe out GPT on /dev/sdb. Proceed? <span class="hljs-params">(Y/N)</span>: y
GPT data structures destroyed! You may now partition the disk <span class="hljs-keyword">using</span> fdisk <span class="hljs-keyword">or</span>
other utilities.
Blank out MBR? <span class="hljs-params">(Y/N)</span>: y</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr alle F√§lle h√§mmern wir den Anfang der microSD-Karte mit Nullen. </font></font><br>
<br>
<pre><code class="cpp hljs">dd <span class="hljs-keyword">if</span>=/dev/zero of=/dev/sdb bs=<span class="hljs-number">1</span>M count=<span class="hljs-number">64</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºhren Sie nun gdisk erneut aus, f√ºgen Sie das Markup hinzu und erstellen Sie 5 Partitionen auf der microSD-Karte gem√§√ü der oben angegebenen Tabelle:</font></font><br>
<br>
<pre><code class="cpp hljs">root@debian:/home/myuser<span class="hljs-meta"># gdisk /dev/sdb</span>
<span class="hljs-function">GPT <span class="hljs-title">fdisk</span> <span class="hljs-params">(gdisk)</span> version 1.0.3

Partition table scan:
  MBR: <span class="hljs-keyword">not</span> present
  BSD: <span class="hljs-keyword">not</span> present
  APM: <span class="hljs-keyword">not</span> present
  GPT: <span class="hljs-keyword">not</span> present

Creating <span class="hljs-keyword">new</span> GPT entries.

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: o
This option deletes all partitions <span class="hljs-keyword">and</span> creates a <span class="hljs-keyword">new</span> protective MBR.
Proceed? <span class="hljs-params">(Y/N)</span>: y

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>)</span>: 1
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">2048</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">2048</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: +<span class="hljs-number">256</span>K<font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">2</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">2</span>)</span>: 2
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">4096</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">4096</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: +<span class="hljs-number">256</span>K<font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">3</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">3</span>)</span>: 3
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">6144</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">6144</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: +<span class="hljs-number">2</span>M<font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">4</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">4</span>)</span>: 4
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">10240</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">10240</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: +<span class="hljs-number">64</span>M<font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: n
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">5</span><span class="hljs-number">-128</span>, <span class="hljs-keyword">default</span> <span class="hljs-number">5</span>)</span>: 5
First <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">34</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">141312</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: 
<span class="hljs-function">Last <span class="hljs-title">sector</span> <span class="hljs-params">(<span class="hljs-number">141312</span><span class="hljs-number">-30873566</span>, <span class="hljs-keyword">default</span> = <span class="hljs-number">30873566</span>)</span> <span class="hljs-keyword">or</span> </span>{+-}size{KMGTP}: <font></font>
Current type is <span class="hljs-string">'Linux filesystem'</span>
<span class="hljs-function">Hex code <span class="hljs-keyword">or</span> <span class="hljs-title">GUID</span> <span class="hljs-params">(L to show codes, Enter = <span class="hljs-number">8300</span>)</span>: 
Changed type of partition to 'Linux filesystem'

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? <span class="hljs-params">(Y/N)</span>: y
OK</span>; <span class="hljs-function">writing <span class="hljs-keyword">new</span> GUID partition <span class="hljs-title">table</span> <span class="hljs-params">(GPT)</span> to /dev/sdb.
The operation has completed successfully.</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºgen Sie als N√§chstes die Namen zu den Abschnitten auf der microSD-Karte hinzu. </font><font style="vertical-align: inherit;">Wie Sie sich erinnern, ist dies besonders wichtig f√ºr die ersten Abschnitte, in denen FSBL geschrieben wird: Wenn Sie ihnen nicht die erforderlichen Namen zuweisen, startet das System nicht:</font></font><br>
<br>
<pre><code class="cpp hljs">root@debian:/home/myuser<span class="hljs-meta"># gdisk /dev/sdb</span>
<span class="hljs-function">GPT <span class="hljs-title">fdisk</span> <span class="hljs-params">(gdisk)</span> version 1.0.3

Partition table scan:
  MBR: protective
  BSD: <span class="hljs-keyword">not</span> present
  APM: <span class="hljs-keyword">not</span> present
  GPT: present

Found valid GPT with protective MBR</span>; <span class="hljs-keyword">using</span> GPT.<font></font>
<font></font>
Command (? <span class="hljs-keyword">for</span> help): <span class="hljs-function">c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 1
Enter name: fsbl1

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 2
Enter name: fsbl2

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 3
Enter name: ssbl

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 4
Enter name: kernel

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: c
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 5
Enter name: roootfs

<span class="hljs-title">Command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? <span class="hljs-params">(Y/N)</span>: y
OK</span>; <span class="hljs-function">writing <span class="hljs-keyword">new</span> GUID partition <span class="hljs-title">table</span> <span class="hljs-params">(GPT)</span> to /dev/sdb.
The operation has completed successfully.</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende der Arbeit mit der microSD-Karte m√ºssen wir </font><font style="vertical-align: inherit;">dem Abschnitt, in den wir den Linux-Kernel schreiben, das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alte bootf√§hige BIOS-Attribut</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hinzuf√ºgen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ohne dieses Attribut weigerte sich der Kernel zu starten:</font></font><br>
<br>
<pre><code class="cpp hljs">root@debian:/home/myuser<span class="hljs-meta"># gdisk /dev/sdb</span>
<span class="hljs-function">GPT <span class="hljs-title">fdisk</span> <span class="hljs-params">(gdisk)</span> version 1.0.3

Partition table scan:
  MBR: protective
  BSD: <span class="hljs-keyword">not</span> present
  APM: <span class="hljs-keyword">not</span> present
  GPT: present

Found valid GPT with protective MBR</span>; <span class="hljs-keyword">using</span> GPT.<font></font>
<font></font>
Command (? <span class="hljs-keyword">for</span> help): <span class="hljs-function">x

Expert <span class="hljs-title">command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: a
Partition <span class="hljs-title">number</span> <span class="hljs-params">(<span class="hljs-number">1</span><span class="hljs-number">-5</span>)</span>: 4
Known attributes are:
0: system partition
1: hide from EFI
2: legacy BIOS bootable
60: read-only
62: hidden
63: <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> automount

Attribute value is 0000000000000000. Set fields are:
  No fields <span class="hljs-built_in">set</span>

Toggle which attribute <span class="hljs-title">field</span> <span class="hljs-params">(<span class="hljs-number">0</span><span class="hljs-number">-63</span>, <span class="hljs-number">64</span> <span class="hljs-keyword">or</span> &lt;Enter&gt; to <span class="hljs-built_in">exit</span>)</span>: 2
Have enabled the 'legacy BIOS bootable' attribute.
Attribute value is 0000000000000004. Set fields are:
2 <span class="hljs-params">(legacy BIOS bootable)</span>

Toggle which attribute <span class="hljs-title">field</span> <span class="hljs-params">(<span class="hljs-number">0</span><span class="hljs-number">-63</span>, <span class="hljs-number">64</span> <span class="hljs-keyword">or</span> &lt;Enter&gt; to <span class="hljs-built_in">exit</span>)</span>: 

Expert <span class="hljs-title">command</span> <span class="hljs-params">(? <span class="hljs-keyword">for</span> help)</span>: w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? <span class="hljs-params">(Y/N)</span>: y
OK</span>; <span class="hljs-function">writing <span class="hljs-keyword">new</span> GUID partition <span class="hljs-title">table</span> <span class="hljs-params">(GPT)</span> to /dev/sdb.
The operation has completed successfully.</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles, das Layout der Speicherkarte ist fertig. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie f√ºr alle F√§lle, ob alles so aufgezeichnet ist, wie es sollte. </font><font style="vertical-align: inherit;">F√ºhren Sie dazu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gdisk</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erneut aus </font><font style="vertical-align: inherit;">und f√ºhren Sie den Befehl </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p aus</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Das Ergebnis sollte das Bild </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q9/ko/ff/q9koffmcelcxpna_qtwtfkdlzz8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
anzeigen: Erstellen Sie nun das ext4-Dateisystem unter / dev / sdb4 und / dev / sdb5:</font></font><br>
<br>
<pre><code class="cpp hljs">mkfs.ext4 /dev/sdb4<font></font>
mkfs.ext4 /dev/sdb5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wir schreiben Volumenbezeichnungen vor, damit sp√§ter leichter darauf zugegriffen werden kann:</font></font><br>
<br>
<pre><code class="cpp hljs">e2label /dev/sdb4 kernel<font></font>
e2label /dev/sdb5 rootfs</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit ist die Erstellung von Abschnitten der Speicherkarte abgeschlossen. Sie k√∂nnen fortfahren, Dateien darauf zu schreiben.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MicroSD-Kartenaufzeichnung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum gegenw√§rtigen Zeitpunkt ist also alles f√ºr die Aufnahme auf einer microSD-Karte bereit. </font><font style="vertical-align: inherit;">Wir legen es in den Kartenleser des Linux-Computers ein und schreiben den prim√§ren Bootloader (FSBL) in den ersten und zweiten Abschnitt der mocroSD-Karte:</font></font><br>
<br>
<pre><code class="cpp hljs">dd <span class="hljs-keyword">if</span>=u-boot/u-boot-spl.stm32 of=/dev/sdb1<font></font>
dd <span class="hljs-keyword">if</span>=u-boot/u-boot-spl.stm32 of=/dev/sdb2</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schreiben Sie nun U-Boot in den dritten Abschnitt der microSD-Karte:</font></font><br>
<br>
<pre><code class="cpp hljs">dd <span class="hljs-keyword">if</span>=u-boot/u-boot.img of=/dev/sdb3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als n√§chstes m√ºssen Sie den Kernel, die Ger√§tebaumdatei und das Boot-Skript in den vierten Abschnitt der microSD-Karte kopieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor Sie mit dem Kopieren von Dateien beginnen, ben√∂tigen Sie eine kurze Erl√§uterung des Download-Skripts. In diesem Skript werden tats√§chlich verschiedene Informationen f√ºr U-Boot angegeben, mit deren Hilfe das System gestartet und die Steuerung an den Kernel √ºbertragen werden kann. Es gibt verschiedene M√∂glichkeiten, diese Skripte zu schreiben, aber die einfachste (meiner Meinung nach) ist in der Dokumentation zu STM32MP1 beschrieben: Sie m√ºssen das Verzeichnis </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ extlinux</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Stammverzeichnis des </font><b><font style="vertical-align: inherit;">Kernelabschnitts</font></b><font style="vertical-align: inherit;"> erstellen und eine Textdatei mit dem Namen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extlinux.conf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit den folgenden Inhalten </font><font style="vertical-align: inherit;">erstellen </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs">LABEL stm32mp157a-dk1<font></font>
KERNEL /zImage<font></font>
FDT /stm32mp157a-dk1.dtb<font></font>
APPEND root=/dev/mmcblk0p5 rootwait rw console=ttySTM0,<span class="hljs-number">115200</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist alles ganz einfach: Wir teilen dem Loader mit, wo er den Kernel, den Ger√§tebaum und das Root-Dateisystem erhalten soll, und sagen, dass wir den ttySTM0-Port als Arbeitskonsole haben werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kopieren Sie nun den Kernel:</font></font><br>
<br>
<pre><code class="cpp hljs">cp -a buildroot/output/images/zImage /media/myuser/kernel/</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Im Verzeichnis / media / myuser / mounte ich eine microSD-Karte, wenn sie im Kartenleser installiert ist. </font><font style="vertical-align: inherit;">In Ihrem Fall kann es sich um ein anderes Verzeichnis handeln. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kopieren Sie die Ger√§tebaumdatei:</font></font><br>
<br>
<pre><code class="cpp hljs">cp -a buildroot/output/images/stm32mp157a-dk1.dtb /media/myuser/kernel/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie ein Verzeichnis:</font></font><br>
<br>
<pre><code class="cpp hljs">mkdir /media/myuser/kernel/extlinux</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie eine Datei:</font></font><br>
<br>
<pre><code class="cpp hljs">nano /media/myuser/kernel/extlinux/extlinux.conf</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und f√ºlle es mit dem Inhalt:</font></font><br>
<br>
<pre><code class="cpp hljs">LABEL stm32mp157a-dk1<font></font>
KERNEL /zImage<font></font>
FDT /stm32mp157a-dk1.dtb<font></font>
APPEND root=/dev/mmcblk0p5 rootwait rw console=ttySTM0,<span class="hljs-number">115200</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Speichern Sie die Datei und schlie√üen Sie den Editor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hierzu ist der vierte Abschnitt der microSD-Karte fertig: Der Linux-Kernel und alle dazugeh√∂rigen Hilfsdateien sind bereits geschrieben. </font><font style="vertical-align: inherit;">Wenn Sie bereits zu diesem Zeitpunkt eine microSD-Karte in das Debugboard einlegen, sollte der Linux-Kernel geladen werden. Am Ende st√ºrzt er jedoch in Kernel-Panik ab, da das Root-Dateisystem nicht gemountet werden kann. </font><font style="vertical-align: inherit;">Dies ist nicht √ºberraschend, da wir es bisher aufgenommen haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt die letzte Phase, in der wir das Root-Dateisystem auf die microSD-Karte schreiben. </font><font style="vertical-align: inherit;">Und hier sind verschiedene M√∂glichkeiten m√∂glich:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schreiben Sie das von Buildroot generierte Root-Dateisystem</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schreiben Sie das Arch Linux-Root-Dateisystem neu</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schreiben Sie zun√§chst das Root-Dateisystem auf, das Buildroot f√ºr uns generiert hat, und versuchen Sie, damit zu beginnen. Dies war nicht der Zweck dieses Artikels, aber es schien mir, dass es im Allgemeinen f√ºr alle Anwendungen n√ºtzlich sein k√∂nnte, zumal diese Aktion nicht viel Zeit in Anspruch nimmt. Das Root-Dateisystem wird mit nur einem Befehl in den f√ºnften Abschnitt unserer microSD-Karte geschrieben:</font></font><br>
<br>
<pre><code class="cpp hljs">dd <span class="hljs-keyword">if</span>=buildroot/output/images/rootfs.ext4 of=/dev/sdb5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setzen Sie nun die Speicherkarte in die Debug-Karte ein und starten Sie das System. Wir werden die Ausgabe von Debugging-Informationen √ºber die USB-UART-Konsole beobachten: Der Zugriff darauf erfolgt √ºber einen Micro-USB-Anschluss auf der STM32MP157A-DK1-Karte. Das Anzeigen der angezeigten Informationen ist in jedem Terminalprogramm m√∂glich, z. B. Putty oder Minicom. F√ºr die Zwecke dieses Artikels habe ich letzteres verwendet, indem ich ein anderes Terminalfenster in Debian ge√∂ffnet habe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt setzen wir die microSD-Karte in die Debug-Karte ein, versorgen die Karte mit Strom und sehen uns das Terminal an. Wenn alles richtig gemacht wurde, sollten die FSBL-, U-Boot- und Kernel-Protokolle dort eingef√ºgt werden und schlie√ülich wird eine Einladung zur Eingabe des Logins angezeigt. Wir geben root ein und - voila - gelangen zur Konsole des Systems, das wir gerade gesammelt haben:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1q/hh/sz/1qhhszribllpziacncz6titn6bw.jpeg"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ja, es gibt nicht einmal einen Paketmanager, und im Allgemeinen ist die Funktionalit√§t sehr schlecht, aber mit Hilfe von Buildroot k√∂nnen Sie es sehr cool erstellen und ein wirklich funktionierendes komplexes System erstellen. </font><font style="vertical-align: inherit;">In der Zwischenzeit betr√§gt seine Gr√∂√üe nur 7 Megabyte! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rq/e7/iv/rqe7iv12mmdleosrwxo8jb-rmj8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem Sie sichergestellt haben, dass das hausgemachte Root-Dateisystem erfolgreich gestartet wurde, ist es Zeit, Arch Linux zu starten. </font><font style="vertical-align: inherit;">Setzen Sie die microSD-Karte erneut in den Kartenleser unseres Computers ein und formatieren Sie den f√ºnften Abschnitt der Speicherkarte erneut:</font></font><br>
<br>
<pre><code class="cpp hljs">mkfs.ext4 /dev/sdb5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Laden Sie das unter armv7 zusammengestellte Archiv mit Arch Linux von der offiziellen Website herunter. </font><font style="vertical-align: inherit;">Entpacken Sie das Archiv in das archlinux-Verzeichnis und verwenden Sie den folgenden Befehl:</font></font><br>
<br>
<pre><code class="cpp hljs">cp -a archlinux<span class="hljs-comment">/* /media/myuser/rootfs </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kopieren Sie es in den rootfs-Bereich der microSD-Karte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir bereinigen das Verzeichnis / media / myuser / rootfs / boot: Wir ben√∂tigen den Inhalt nicht, da sich der Kernel und der Ger√§tebaum in einem separaten Abschnitt der microSD-Karte befinden:</font></font><br>
<br>
<pre><code class="cpp hljs">rm ‚Äìrf /media/myuser/rootfs/boot<span class="hljs-comment">/*</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sp√§ter k√∂nnen Sie die Partition / dev / sdb4 im Boot-Verzeichnis bereitstellen, in dem sich das Kernel-Image befindet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setzen Sie danach die microSD-Karte in das Debug-Board ein, aktivieren Sie die Arbeit und genie√üen Sie die Arbeit mit ArchLinux: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bj/n8/6i/bjn86iex090rkcggj7v5sz7yayg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem Arch Linux erfolgreich gestartet wurde, habe ich beschlossen, Debian auch auf dem Debug-Board auszuf√ºhren. </font><font style="vertical-align: inherit;">Mit absolut √§hnlichen Manipulationen mit dem Root-Dateisystem hat es erfolgreich funktioniert:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8h/kg/1c/8hkg1c82dcu2ruov5fm7rdu-j-i.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel haben wir genug mit dem Debug-Board STM32MP157A-DK1 gespielt: Legen Sie U-Boot, den Linux-Kernel und unser eigenes Root-Dateisystem darunter und starten Sie Arch Linux und Debian. </font><font style="vertical-align: inherit;">Ich hoffe, dass dieses Material f√ºr jemanden n√ºtzlich ist, sowohl bei der Arbeit mit Prozessoren der STM32MP1-Familie als auch mit anderen Single-Boards auf ARM.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√ºtzliche Links</font></font></b>
                        <div class="spoiler_text"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">www.st.com/en/microcontrollers-microprocessors/stm32mp1-series.html</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">wiki.st.com/stm32mpu/wiki/Category</a>:STM32_MPU_microprocessor_devices</div>
                    </div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de503578/index.html">Gute Programmierer kopieren, gute Programmierer stehlen</a></li>
<li><a href="../de503580/index.html">Was ist Big Data?</a></li>
<li><a href="../de503588/index.html">Bill Gates: Was Sie √ºber COVID-19-Impfstoff wissen m√ºssen</a></li>
<li><a href="../de503594/index.html">Fernbeobachter</a></li>
<li><a href="../de503598/index.html">FOSS News Nr. 17 - √úberpr√ºfung der kostenlosen und Open Source-Nachrichten f√ºr den 18. bis 24. Mai 2020</a></li>
<li><a href="../de503604/index.html">Sergey und "Programmieren ist besser als Sex"</a></li>
<li><a href="../de503606/index.html">Swift 5.3: Was ist neu?</a></li>
<li><a href="../de503608/index.html">Wie wir nach Virenfiltern gesucht haben</a></li>
<li><a href="../de503610/index.html">Warum nicht dein eigenes Lisp f√ºr das Web machen?</a></li>
<li><a href="../de503612/index.html">Best Practices von Kubernetes. Zuordnung externer Dienste</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>