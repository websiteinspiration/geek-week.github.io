<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🏫 🧖🏽 🤛🏻 Pythonの最適化について学んだこと 🍤 🎃 👨🏽‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="みなさん、こんにちは。今日は、Python開発者コースの開始前日に準備された別の翻訳を共有したいと思います。行こう！
 
 
 
 私は過去4〜5年間、他のどのプログラミング言語よりもPythonを頻繁に使用していました。 Pythonは、Firefoxの下でのビルド、テスト、およびCIツールの主要...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Pythonの最適化について学んだこと</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/457942/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">みなさん、こんにちは。今日は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Python開発者</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コースの開始前日に準備された別の翻訳を共有したいと思い</font><font style="vertical-align: inherit;">ます。行こう！</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0-/xf/qt/0-xfqtj4sbazxamoeq0lzuaeor4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は過去4〜5年間、他のどのプログラミング言語よりもPythonを頻繁に使用していました。 Pythonは、Firefoxの下でのビルド、テスト、およびCIツールの主要な言語です。 MercurialもほとんどがPythonで書かれています。私はそれにサードパーティのプロジェクトもたくさん書いています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作業中に、Pythonのパフォーマンスとその最適化ツールについて少し知識を得ました。この記事では、この知識を共有したいと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のPythonでの経験は、主にCPythonインタープリター、特にCPython 2.7に関連しています。</font><font style="vertical-align: inherit;">私の観察結果のすべてがすべてのPythonディストリビューション、または同じバージョンのPythonで同じ特性を持つディストリビューションに共通であるとは限りません。</font><font style="vertical-align: inherit;">ナラティブの中で、これについて触れようと思います。</font><font style="vertical-align: inherit;">この記事はPythonパフォーマンスの詳細な概要ではないことに注意してください。</font><font style="vertical-align: inherit;">私が出会ったことについては自分で話すだけです。</font></font><a name="habracut"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュールの起動とインポートの特殊性による負荷</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Pythonインタープリターの開始とモジュールのインポートは、ミリ秒になるとかなり長いプロセスになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いずれかのプロジェクトで数百または数千のPythonプロセスを実行する必要がある場合、ミリ秒単位のこの遅延は最大数秒の遅延になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pythonを使用してCLIツールを提供する場合、オーバーヘッドにより、顕著なフリーズが発生する可能性があります。 CLIツールがすぐに必要な場合は、呼び出しごとにPythonインタープリターを実行すると、この複雑なツールを入手することが難しくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題についてはすでに書いた。私の過去のノートの数は、例えば、本の話を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2014年に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2018年5月に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2018年10月</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
起動の遅延を減らすためにできることは多くありません。時間がかかるのはコードの実行を制御するため、このケースを修正することはPythonインタープリターを操作することを指します。最善の方法は</font><font style="vertical-align: inherit;">、起動時に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュールのインポートを無効にして、</font><font style="vertical-align: inherit;">起動時に余分なPythonコードが実行されないようにすることです。一方、多くのアプリケーションはsite.pyモジュールの機能を使用するため、自己責任で使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モジュールのインポートの問題も考慮する必要があります。コードを処理しない場合、Pythonインタープリターはどのように役立ちますか？実際、コードはモジュールを使用することにより、インタープリターがより頻繁に使用できるようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モジュールをインポートするには、いくつかの手順を実行する必要があります。そして、それらのそれぞれに、負荷と遅延の潜在的な原因があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モジュールの検索とそのデータの読み取りにより、一定の遅延が発生します。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">PyOxidizerで</font></a><font style="vertical-align: inherit;">説明した</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ように</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイルシステムからのモジュールの検索と読み込みを、メモリ内のデータ構造からモジュールデータを読み取ることで構成される、アーキテクチャ的に単純なソリューションに置き換えることで、この問題を解決するために初期時間の70〜80％の標準Pythonライブラリをインポートできます。ファイルシステムファイルごとに1つのモジュールを使用すると、ファイルシステムの負荷が増加し、重要な最初の数ミリ秒の実行中にPythonアプリケーションの速度が低下する可能性があります。 PyOxidizerのようなソリューションは、これを回避するのに役立ちます。 Pythonコミュニティが現在のアプローチのこれらのコストを認識し、モジュール内の個々のファイルにあまり依存しないモジュールの配布メカニズムに切り替える可能性を検討していることを願っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モジュールの追加のインポートコストのもう1つの原因は、インポート中にそのモジュールのコードが実行されることです。一部のモジュールには、モジュールの関数とクラスの外側の領域にコードの一部が含まれており、モジュールのインポート時に実行されます。このようなコードを実行すると、インポートのコストが増加します。回避策：インポート時にすべてのコードを実行せず、必要な場合にのみ実行してください。 Python 3.7は、モジュール</font></font><code>__getattr__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の属性が見つからなかった場合に呼び出される</font><font style="vertical-align: inherit;">モジュール</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">サポートしています</font><font style="vertical-align: inherit;">。これを使用して、最初のアクセス時にモジュール属性を遅延して入力できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インポートの速度低下を解消する別の方法は、モジュールを遅延してインポートすることです。インポート中にモジュールを直接ロードする代わりに、代わりにスタブを返すカスタムインポートモジュールを登録します。このスタブに初めてアクセスすると、実際のモジュールが読み込まれ、このモジュールになるように「変更」されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルシステムをバイパスし、モジュールの不要な部分を実行しないようにすれば、数十のモジュールをインポートするアプリケーションで数十ミリ秒を節約できます（通常、モジュールはグローバルにインポートされますが、特定のモジュール関数のみが使用されます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モジュールの遅延インポートは壊れやすいものです。複数のモジュールは、次のものを持つテンプレート</font></font><code>try: import foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><code>except ImportError:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。怠惰なモジュールインポーターがImportErrorをスローすることは決してないかもしれません。もしそうなら、彼はファイルシステムを調べて、モジュールが原理的に存在するかどうかを確認する必要があるからです。これは余分な負荷を追加し、費やす時間を増やすため、遅延インポーターは原則としてこれを行いません！この問題はかなり厄介です。遅延モジュールのインポーターMercurialは、遅延インポートできないモジュールのリストを処理し、それらをバイパスする必要があります。もう1つの問題は構文です</font></font><code>from foo import x, y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、fooがモジュールではなく（パッケージではなく）モジュールである場合にも、遅延モジュールのインポートを中断し</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。これは、xおよびyへの参照を返すために、モジュールをインポートする必要があるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PyOxidizerには、バイナリに縫い込まれたモジュールの固定セットがあるため、ImportErrorの発生に効果的です。 Python 3.7の__getattr__モジュールは、遅延モジュールインポーターに追加の柔軟性を提供します。信頼できる遅延インポーターをPyOxidizerに統合して、いくつかのプロセスを自動化したいと思っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インタープリターの開始と時間遅延の発生を回避する最善の解決策は、Pythonでバックグラウンドプロセスを開始することです。 Pythonプロセスをデーモンプロセスとして、たとえばWebサーバーで実行すると、実行できます。 Mercurialが提供するソリューションは、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">コマンドサーバープロトコル</font></a><font style="vertical-align: inherit;">を提供するバックグラウンドプロセスを開始すること</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">hgは、このバックグラウンドプロセスに接続してコマンドを送信するC実行可能ファイル（またはRust）です。</font><font style="vertical-align: inherit;">コマンドサーバーへのアプローチを見つけるには、多くの作業を行う必要があります。非常に不安定で、セキュリティ上の問題があります。</font><font style="vertical-align: inherit;">PyOxidizerを使用してコマンドサーバーを提供し、実行可能ファイルに利点を持たせ、ソフトウェアソリューション自体のコストをPyOxidizerプロジェクトを作成することで解決するという考えを検討しています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数呼び出し遅延 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pythonでの関数の呼び出しは比較的遅いプロセスです。 （この観察は、JITコードを実行できるPyPyにはあまり当てはまりません。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mercurialには数十のパッチがあり、関数を呼び出すときに不要な負荷を回避するようにコードを整列および結合することができました。現在の開発サイクルでは、進行状況バーを更新するときに呼び出される関数の数を減らすために、いくつかの努力が払われています。 （ユーザーが何が起こっているのかを理解できるように、時間がかかる操作には進行状況バーを使用します）。呼び出しの結果の取得</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">との間で簡単な検索を回避</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能は、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我々は百万処刑について話すとき、たとえば、実行時に数百ミリ秒の数十を保存します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数十万以上の関数呼び出しが発生する可能性があるPythonでタイトなループまたは再帰関数がある場合、これは非常に重要であるため、単一の関数を呼び出すことのオーバーヘッドに注意する必要があります。</font><font style="vertical-align: inherit;">単純な組み込み関数と、関数を組み合わせてオーバーヘッドを回避する機能に留意してください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性ルックアップのオーバーヘッド</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 この問題は、意味がほとんど同じであるため、関数呼び出しによるオーバーヘッドに似ています。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Pythonで解決属性を見つけるのは遅い場合があります。</font><font style="vertical-align: inherit;">（そして、PyPyでは、これはより高速です）。</font><font style="vertical-align: inherit;">ただし、この問題の処理は、Mercurialでよく行うことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のコードがあるとします。</font></font><br>
<br>
<pre><code class="python hljs">obj = MyObject()<font></font>
total = <span class="hljs-number">0</span><font></font>
<font></font>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> len(obj.member):<font></font>
    total += obj.member[i]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 この例を書くためのより効率的な方法（たとえば</font></font><code>total = sum(obj.member)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">は省略し</font><font style="vertical-align: inherit;">、ループは各反復でobj.memberを定義する必要があることに注意してください。 Pythonには、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を定義するための比較的高度なメカニズムがあり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。単純型の場合は、十分に高速です。しかし、この洗練されたタイプの属性へのアクセスでは</font></font><code>__getattr__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>__getattribute__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまなメソッド</font></font><code>dunder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">やユーザー定義関数を</font><font style="vertical-align: inherit;">自動的に呼び出すことができます</font></font><code>@property</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、いくつかの関数呼び出しを行うことができる属性のクイック検索に似ており、追加の負荷が発生します。そして、このようなものを使用すると、この負荷が悪化する可能性があります</font></font><code>obj.member1.member2.member3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各属性定義により、追加の負荷が発生します。そして、Pythonのほとんどすべてが辞書であるため、すべての属性検索は辞書検索であると言えます。基本的なデータ構造に関する一般的な概念から、辞書検索は、たとえばインデックス検索ほど高速ではないことがわかります。もちろん、CPythonには、辞書検索によるオーバーヘッドを取り除くいくつかのトリックがあります。しかし、私が触れたい主なトピックは、属性ルックアップは潜在的なパフォーマンスリークであることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハードループ、特に数十万回の反復を超える可能性のあるループの場合、ローカル変数に値を割り当てて属性を見つけることにより、これらの測定可能なオーバーヘッドを回避できます。次の例を見てみましょう：</font></font><br>
<br>
<pre><code class="python hljs">obj = MyObject()<font></font>
total = <span class="hljs-number">0</span><font></font>
<font></font>
member = obj.member<font></font>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> len(member):<font></font>
    total += member[i]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 もちろん、これは、ループで置き換えられない場合にのみ安全に実行できます。</font><font style="vertical-align: inherit;">これが発生した場合、イテレータは古い要素へのリンクを保持し、すべてが爆発する可能性があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 同じ方法は、オブジェクトメソッドを呼び出すことで実行できます。</font><font style="vertical-align: inherit;">代わりに</font></font><br>
<br>
<pre><code class="python hljs">obj = MyObject()<font></font>
<font></font>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000000</span>):<font></font>
    obj.process(i)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 次のことができます。</font></font><br>
<br>
<pre><code class="python hljs">obj = MyObject()<font></font>
fn = obj.process<font></font>
<font></font>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000000</span>:)<font></font>
    fn(i)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 また、属性検索でメソッドを呼び出す必要がある場合（前の例のように）、Python 3.7は</font><font style="vertical-align: inherit;">以前のリリース</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">より</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も</font><font style="vertical-align: inherit;">比較的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">高速</font></a><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">あることにも注意してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、ここでは、過剰な負荷が、まず属性検索の負荷ではなく、関数呼び出しに関連付けられていると確信しています。</font><font style="vertical-align: inherit;">したがって、属性の余分な検索を中止すると、すべてがより速く機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、属性検索はこのために関数を呼び出すので、属性検索は一般に、関数呼び出しによる負荷よりも問題が少ないと言えます。</font><font style="vertical-align: inherit;">通常、パフォーマンスの大幅な変化に気づくには、多くの属性検索を排除する必要があります。</font><font style="vertical-align: inherit;">この場合、ループ内のすべての属性へのアクセスを許可するとすぐに、関数を呼び出す前に、ループ内でのみ10または20の属性について話すことができます。</font><font style="vertical-align: inherit;">また、数千回または数万回未満のループでは、数十万回または数百万回の属性検索をすばやく実行できます。</font><font style="vertical-align: inherit;">ので注意してください！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトの読み込み</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Pythonインタープリターの観点から見ると、すべての値はオブジェクトです。 CPythonでは、各要素はPyObject構造です。インタプリタによって制御される各オブジェクトはヒープ上にあり、参照カウント、オブジェクトタイプ、およびその他のパラメータを含む独自のメモリを持っています。各オブジェクトは、ガベージコレクターによって破棄されます。つまり、参照カウント、ガベージコレクションなどにより、新しいオブジェクトごとにオーバーヘッドが追加されます。 （そして繰り返しますが、PyPyはこの不要な負担を回避できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、</font><font style="vertical-align: inherit;">短期的な値の存続期間に対してより「注意深く」なるためです。）</font><font style="vertical-align: inherit;">原則として、作成する一意の値とPythonオブジェクトが多いほど、動作が遅くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
100万個のオブジェクトのコレクションを反復処理するとします。このオブジェクトをタプルに収集する関数を呼び出します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> my_collection:<font></font>
    a, b, c, d, e, f, g, h = process(x)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 この例で</font></font><code>process()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、8タプルのタプルを返します。戻り値を破棄するかどうかは関係ありません。このタプルでは、​​Pythonで少なくとも9つの値を作成する必要があります。タプル自体に1つ、内部メンバーに8つです。まあ、実際</font></font><code>process()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には、既存のオブジェクトへのリンクを返す</font><font style="vertical-align: inherit;">場合、値が少なくなる可能性があり</font><font style="vertical-align: inherit;">ます。あるいは、逆に、それらの型が単純ではなく、それらを表すために多くのPyObjectを必要とする場合は、さらに多くなることがあります。インタプリタの内部には、特定の構造を完全に表現するためのオブジェクトの実際のジャグリングがあるとだけ言いたいです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私自身の経験から、これらのオーバーヘッドは、CやRustなどのネイティブ言語で実装されたときに速度を向上させる操作にのみ関連していると言えます。問題は、CPythonインタープリターがバイトコードを非常に高速に実行できないため、オブジェクトの数による追加の負荷が問題になることです。代わりに、関数を呼び出すか、面倒な計算を行うなどして、パフォーマンスを低下させる可能性が最も高くなります。オブジェクトによる余分な負荷に気付く前に。もちろん、いくつかの例外があります。つまり、いくつかの値のタプルまたは辞書の構築です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オーバーヘッドの具体例として、低レベルのデータ構造を解析するCコードでMercurialを引用できます。解析速度を上げるために、CコードはCPythonよりも1桁速く実行されます。しかし、Cコードが結果を表すPyObjectを作成するとすぐに、速度は数倍低下します。つまり、ロードでは、Python要素を作成して管理し、コードで使用できるようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を回避する方法は、Pythonで生成する要素を少なくすることです。単一の要素を参照する必要がある場合は、関数を開始してそれを返します。タプルやN要素の辞書ではありません。ただし、関数呼び出しによって起こり得る負荷の監視を停止しないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CPython C APIを使用して十分に高速に動作する多くのコード、および異なるモジュール間で分散する必要がある要素がある場合は、C構造として異なるデータを表すPythonタイプを使用せず、これらの構造にアクセスするためのコードをコンパイル済みCPython C APIを経由する代わりに。データにアクセスするためのCPython C APIを回避することにより、大量の過剰な負荷を取り除くことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要素をデータとして扱うことは（連続してすべてにアクセスする関数を持つのではなく）、Pythonistにとって最良のアプローチです。既にコンパイルされたコードの別の回避策は、PyObjectを遅延してインスタンス化することです。 Pythonでカスタムタイプ（PyTypeObject）を作成して複雑な要素を表す場合は、フィールドを定義する必要があります</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tp_members</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tp_getset</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して、カスタムC関数を作成し、属性の値を検索します。</font><font style="vertical-align: inherit;">たとえば、パーサーを作成し、顧客が分析されたフィールドのサブセットにのみアクセスできることを知っている場合は、生データを含む型をすばやく作成し、この型を返し、C関数を呼び出して、PyObjectを処理するPython属性を検索できます。</font><font style="vertical-align: inherit;">解析が必要ない場合は、関数を呼び出してリソースを節約するまで解析を遅らせることもできます。</font><font style="vertical-align: inherit;">このテクニックは、重要なコードを書く必要があるため、非常にまれですが、良い結果が得られます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予備的な収集サイズの決定</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 これはCPython C APIに適用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リストや辞書などのコレクションを作成するとき</font><font style="vertical-align: inherit;">、サイズが作成時に既に決定されている場合は、</font></font><code>PyList_New()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font><code>PyList_SET_ITEM()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">して新しいコレクションに入力します。</font><font style="vertical-align: inherit;">これは、コレクション内に有限数の要素を保持できるように、コレクションのサイズを事前に決定します。</font><font style="vertical-align: inherit;">これにより、アイテムを挿入するときに十分なコレクションサイズのチェックをスキップできます。</font><font style="vertical-align: inherit;">何千ものアイテムのコレクションを作成するとき、これはいくつかのリソースを節約します！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C APIでのゼロコピーの使用</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Python C APIは、オブジェクトへの参照を返すのではなく、オブジェクトのコピーを作成することを好みます。たとえば、</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PyBytes_FromStringAndSize（）</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><code>char*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予約されたPythonをメモリに</font><font style="vertical-align: inherit;">コピー</font><font style="vertical-align: inherit;">します。多数の値またはビッグデータに対してこれを行うと、ギガバイトのメモリI / Oと、アロケーターの関連する負荷について説明できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C APIを使用せずに高性能のコードを記述する必要がある場合は、</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッファープロトコル</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memoryview</font></font></a><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの関連する型</font><font style="vertical-align: inherit;">について理解しておく必要があります</font><i><font style="vertical-align: inherit;">。</font></i></font><br>
<br>
<code> Buffer protocol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pythonの型に組み込まれ、インタプリタが型を/からバイトにキャストできるようにします。また、Cコードインタープリターがハンドルを受け取ることもできます。</font></font><code>void*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のサイズ。これにより、メモリ内の任意のアドレスをPyObjectに関連付けることができます。バイナリデータを扱う多くの関数は、を実装するオブジェクトを透過的に受け入れます</font></font><code>buffer protocol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。あなたがバイトとして考えることができる任意のオブジェクトを受け入れるようにしたい場合は、あなたが使用する必要がある</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形式の単位を</font></font></a> <code>s*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>y*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><code>w*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数の引数を受信したとき。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
を使用する</font></font><code>buffer protocol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、インタープリターに</font></font><code>zero-copy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作</font><font style="vertical-align: inherit;">を使用できる最高の機会を与え、</font><font style="vertical-align: inherit;">余分なバイトをメモリにコピーすることを拒否します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pythonビュー</font></font><code>memoryview</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">タイプを使用することにより</font><font style="vertical-align: inherit;">、コピーを作成する代わりに、Pythonが参照によってメモリレベルにアクセスできるようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pythonプログラムを通過するギガバイトのコードがある場合、ゼロコピーをサポートするPythonの型を洞察力のある方法で使用すると、パフォーマンスの違いから解放されます。</font><font style="vertical-align: inherit;">私はかつて気づい</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のpython-zstandardは、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私はあまり使用されているので、（それは他の方法で回避する必要がありますが）速い任意のPythonのLZ4バインディングよりもあることが判明</font></font><code>buffer protocol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、過度のメモリI / Oでを回避します</font></font><code>python-zstandard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 この記事では、Pythonプログラムを数年間最適化している間に学んだことのいくつかについて話そうとしました。繰り返しますが、Pythonのパフォーマンス向上方法の包括的な概要ではありません。私はおそらく他の人よりも厳しいPythonを使用していることを認め、私の推奨事項をすべてのプログラムに適用することはできません。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事を読んだ後、Pythonコードを大幅に修正したり、たとえば属性の検索を削除したりしてはなりません</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。いつものように、パフォーマンスの最適化に関しては、まずコードが特に遅い場所を修正します。私は</font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">py-spy</font></a></i><font style="vertical-align: inherit;">を強くお勧めします</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pythonアプリケーションのプロファイリング用。ただし、関数の呼び出しや属性の検索など、Pythonの低レベルのアクティビティに費やされる時間を忘れないでください。したがって、ハードサイクルがわかっている場合は、この記事の提案を試して、改善が見られるかどうかを確認してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、この記事はPythonとその全体的なパフォーマンスの実行として解釈されるべきではありません。はい、パフォーマンスの特性により、特定の状況ではPythonを使用する必要があるかどうかを論じることができます。ただし、これに加えて、Pythonは非常に普遍的です-特に動的プログラミング言語に卓越したパフォーマンスを提供するPyPyと組み合わせて。 Pythonのパフォーマンスは、ほとんどの人にとってかなり良いように見えるかもしれません。良くも悪くも、私は常に他の人から際立っているケースにPythonを使用してきました。ここで私は自分の経験を共有したかったので、他の人が「戦線」での人生がどうなるかが少し明確になるでしょう。たぶん、たぶん、たぶん、Pythonディストリビューションを使用している賢い人にプッシュできます。私が遭遇した問題をより詳細に考え、最善の解決策を提示します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
伝統的に、私たちはあなたのコメントを待っています;-)</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja457928/index.html">2つの画像を比較するための深いランキング</a></li>
<li><a href="../ja457930/index.html">Pythonで静的に安全な動的型付け</a></li>
<li><a href="../ja457932/index.html">Positive Hack Days 9でのIDSバイパスコンテストの分析</a></li>
<li><a href="../ja457936/index.html">ロシアでの最初のZabbixカンファレンスにあなたを招待します</a></li>
<li><a href="../ja457940/index.html">相手方をのぞく方法</a></li>
<li><a href="../ja457946/index.html">グラフとチャートでデータを視覚化するための10の最高のJavaScriptライブラリ</a></li>
<li><a href="../ja457948/index.html">頭をぶち壊さなければならないボードゲーム</a></li>
<li><a href="../ja457952/index.html">プロセッサの設計と製造方法：チップ製造</a></li>
<li><a href="../ja457954/index.html">Swiftがディープラーニングの大きなイベントになる理由</a></li>
<li><a href="../ja457956/index.html">自分の足を撃たずにストレージを選択する方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>