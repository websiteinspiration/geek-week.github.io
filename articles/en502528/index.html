<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëß üèáüèº üë¥üèø Programming a game for an embedded device on ESP32 üî∏ üëàüèΩ üë©üèæ‚Äçü§ù‚Äçüë®üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 0: motivation
 Introduction
 I was looking for a hobby project that I could work on outside my main tasks in order to escape from the situation i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programming a game for an embedded device on ESP32</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502528/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part 0: motivation</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introduction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I was looking for a hobby project that I could work on outside my main tasks in order to escape from the situation in the world. </font><font style="vertical-align: inherit;">I'm mostly interested in game programming, but I also like embedded systems. </font><font style="vertical-align: inherit;">Now I work in a gaming company, but before I was mainly engaged in microcontrollers. </font><font style="vertical-align: inherit;">Although in the end I decided to change my path and go into the game industry, I still like to experiment with them. </font><font style="vertical-align: inherit;">So why not combine both hobbies?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid go</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I had </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid Go lying around</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which would be interesting to play with. </font><font style="vertical-align: inherit;">Its core is ESP32 - a very popular microcontroller with standard MK functionality (SPI, I2C, GPIO, timers, etc.), but also with WiFi and Bluetooth, which makes it attractive for creating IoT devices. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go complements the ESP32 with a bunch of peripherals, turning it into a portable gaming machine reminiscent of Gameboy Color: an LCD display, a speaker, a control cross, two primary and four auxiliary buttons, a battery and an SD card reader. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mostly people buy Odroid Go to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">run emulators of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> old 8-bit systems. </font><font style="vertical-align: inherit;">If this thing is capable of emulating old games, it will also cope with the launch of a native game designed specifically for it.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/800/42e/44b80042e94aa2f2da9da2d2296461ad.jpg"></div><a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limitations</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resolution 320x240 The</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
display has a size of only 320x240, so we are very limited in the amount of information displayed on the screen at the same time. We need to carefully consider what game we will make and what resources to use. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16-bit color The</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
display supports 16-bit color per pixel: 5 bits for red, 6 bits for green, and 5 for blue. For obvious reasons, such a circuit is usually called RGB565. Green got one bit more red and blue, because the human eye better distinguishes between gradations of green than blue or red. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16-bit color means that we have access to only 65 thousand colors. Compare this with the standard 24-bit color (8 bits per color), providing 16 </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">million</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> colors. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lack of GPU</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Without a GPU, we cannot use an API like OpenGL. Today, the same GPUs are usually used for rendering 2D games as for 3D games. Just instead of objects, quadrangles are drawn, on which bit textures are superimposed. Without a GPU, we have to rasterize each pixel with a CPU, which is slower but simpler. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With a screen resolution of 320x240 and 16-bit color, the total frame buffer size is 153,600 bytes. This means that at least thirty times per second we will need to transmit 153,600 bytes to the display. This can ultimately cause problems, so we need to be smarter when rendering the screen. For example, you can convert an indexed color to a palette so that for each pixel you need to store one byte, which will be used as an index of a 256-color palette.</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 MB</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ESP32 has 520 KB of internal RAM, while Odroid Go adds another 4 MB of external RAM. But not all of this memory is available to us, because part is used by the ESP32 SDK (more on this later). After disabling all possible extraneous functions and entering my main function, ESP32 reports that we can use 4,494,848 bytes. If in the future we need more memory, then later we can return to trimming unnecessary functions. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">80-240 MHz processor</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The CPU is configured at three possible speeds: 80 MHz, 160 MHz and 240 MHz. Even a maximum of 240 MHz is far from the power of more than three gigahertz of modern computers with which we are used to working. We will start at 80 MHz and see how far we can go. If we want the game to work on battery power, then power consumption should be low. To do this, it would be nice to lower the frequency. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bad debugging</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are ways to use debuggers with embedded devices (JTAG), but, unfortunately, Odroid Go does not provide us with the necessary contacts, so we cannot step through the code in the debugger, as is usually the case. </font><font style="vertical-align: inherit;">This means that debugging can be a difficult process, and we will have to actively use on-screen debugging (using colors and text), and also output information to the debugging console (which, fortunately, is easily accessible via USB UART).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why all the trouble?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why even try to create a game for this weak device with all the limitations listed above, and just not write anything for a desktop PC? There are two reasons for this: </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limitations stimulate creativity.</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
When you work with a system that has a certain set of equipment, each of which has its own limitations, it makes you think over how to best use the advantages of these limitations. So we get closer to game developers of old systems, for example, Super Nintendo (but it‚Äôs still much easier for us than for them). </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Low-level development is fun</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To write a game from scratch for a regular desktop system, we have to work with standard low-level engine concepts: rendering, physics, collision recognition. </font><font style="vertical-align: inherit;">But when implementing all this on an embedded device, we also have to deal with low-level computer concepts, for example, writing an LCD driver.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How low will the development be?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When it comes to low level and creating your own code, you have to draw a border somewhere. If we are trying to write a game without libraries for the desktop, then the border is likely to be an operating system or a cross-platform API like SDL. In my project, I will draw a line on writing things like SPI drivers and bootloaders. With them much more torment than fun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we will use the ESP-IDF, which is essentially an SDK for ESP32. We can assume that it provides us with some utilities that the operating system usually provides, but the </font><font style="vertical-align: inherit;">operating system </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> work </font><font style="vertical-align: inherit;">in ESP32 </font><font style="vertical-align: inherit;">. Strictly speaking, this MK uses FreeRTOS, which is </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a real-time operating system</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">but this is not a real OS. </font><font style="vertical-align: inherit;">This is just a planner. </font><font style="vertical-align: inherit;">Most likely, we will not interact with it, but in its core ESP-IDF uses it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP-IDF provides us with an API for ESP32 peripherals such as SPI, I2C, and UART, as well as a C runtime library, so when we call something like printf, it actually transfers bytes via UART to be displayed on the serial interface monitor. </font><font style="vertical-align: inherit;">It also processes all the startup code needed to prepare the machine before it invokes the launch point of our game. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this post I will keep a development magazine in which I will talk about interesting points that seemed to me and explain the most difficult aspects. </font><font style="vertical-align: inherit;">I do not have a plan and most likely I will make many mistakes. </font><font style="vertical-align: inherit;">All this I create out of interest.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part 1: build system</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introduction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before we can start writing code for Odroid Go, we need to configure the ESP32 SDK. </font><font style="vertical-align: inherit;">It contains the code that starts ESP32 and calls our main function, as well as the peripheral code (for example, SPI) that we will need when we write the LCD driver. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espressif calls its </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SDK </font><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">we use the latest stable version </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v4.0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We can either clone the repository according to their instructions (with the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recursive</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> flag </font><font style="vertical-align: inherit;">), or simply download the zip from the releases page. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our first goal is a minimal Hello World-style application installed on Odroid Go that proves the correct setup of the build environment.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C or C ++</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP-IDF uses C99, so we will choose it too. </font><font style="vertical-align: inherit;">If desired, we could use C ++ (in the ESP32 toolchain there is a C ++ compiler), but for now we will stick to C. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Actually, I like C and its simplicity. </font><font style="vertical-align: inherit;">No matter how much I write code in C ++, I never managed to reach the moment of enjoying it. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This person sums up my thoughts pretty well. </font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, if necessary, we can switch to C ++ at any time.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimal project</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDF uses CMake to manage the build system. It also supports Makefile, but they are deprecated in v4.0, so we‚Äôll just use CMake. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At a minimum, we need a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMakeLists.txt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file </font><font style="vertical-align: inherit;">with a description of our project, a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> folder </font><font style="vertical-align: inherit;">with the source file of the entry point into the game, and another </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMakeLists.txt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file </font><font style="vertical-align: inherit;">inside </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which lists the source files. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CMake needs to reference environment variables that tell it where to look for IDF and toolchain. I was annoyed that I had to reinstall them each time I started a new terminal session, so I wrote the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">export.sh</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> script </font><font style="vertical-align: inherit;">. It sets </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDF_PATH</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDF_TOOLS_PATH</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and is also an IDF export source that sets other environment variables. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is enough for the script user to set the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDF_PATH</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDF_TOOLS_PATH variables</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="powershell hljs">IDF_PATH=<font></font>
IDF_TOOLS_PATH=<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">if</span> [ -<span class="hljs-type">z</span> <span class="hljs-string">"<span class="hljs-variable">$IDF_PATH</span>"</span> ]<font></font>
then<font></font>
	<span class="hljs-built_in">echo</span> <span class="hljs-string">"IDF_PATH not set"</span>
	<span class="hljs-keyword">return</span><font></font>
fi<font></font>
<font></font>
<span class="hljs-keyword">if</span> [ -<span class="hljs-type">z</span> <span class="hljs-string">"<span class="hljs-variable">$IDF_TOOLS_PATH</span>"</span> ]<font></font>
then<font></font>
	<span class="hljs-built_in">echo</span> <span class="hljs-string">"IDF_TOOLS_PATH not set"</span>
	<span class="hljs-keyword">return</span><font></font>
fi<font></font>
<font></font>
<font></font>
export IDF_PATH<font></font>
export IDF_TOOLS_PATH<font></font>
<font></font>
source <span class="hljs-variable">$IDF_PATH</span>/export.sh</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMakeLists.txt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the root:</font></font><br>
<br>
<pre><code class="cmake hljs"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)<font></font>
<font></font>
<span class="hljs-keyword">set</span>(COMPONENTS <span class="hljs-string">"esptool_py main"</span>)<font></font>
<font></font>
<span class="hljs-keyword">include</span>($ENV{IDF_PATH}/tools/cmake/<span class="hljs-keyword">project</span>.cmake)<font></font>
<font></font>
<span class="hljs-keyword">project</span>(game)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By default, the build system will build every possible component inside </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ ESP_IDF / components</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which will result in more compilation time. </font><font style="vertical-align: inherit;">We want to compile a minimal set of components to call our main function, and connect additional components later if necessary. </font><font style="vertical-align: inherit;">This is what the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COMPONENTS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> variable is for </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMakeLists.txt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inside </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cmake hljs">idf_component_register(<font></font>
	SRCS <span class="hljs-string">"main.c"</span>
    INCLUDE_DIRS <span class="hljs-string">""</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything that he does - infinitely once a second displays on the monitor the serial interface "Hello World". </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VTaskDelay</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uses FreeRTOS </font><font style="vertical-align: inherit;">to delay </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file is </font><font style="vertical-align: inherit;">very simple:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;freertos/FreeRTOS.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;freertos/task.h&gt;</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-keyword">for</span> (;;)<font></font>
	{<font></font>
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello World!\n"</span>);<font></font>
		vTaskDelay(<span class="hljs-number">1000</span> / portTICK_PERIOD_MS);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Should never get here</span><font></font>
	esp_restart();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note that our function is called </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">app_main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not </font></font></em> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function is </font><font style="vertical-align: inherit;">used by the IDF for the necessary preparation, and then it creates a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with our </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">app_main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">as an entry point. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A task is just an executable block that FreeRTOS can manage. While we should not worry about this (or maybe not at all), it is important to note here that our game runs in one core (ESP32 has two cores), and with each iteration of the for loop, the task delays execution for one second. During this delay, the FreeRTOS scheduler may execute other code that is waiting in line for execution (if any).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We can use both cores, but for now, let's limit ourselves to one.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Components</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Even if we reduce the list of components to the minimum required for the Hello World application (which are </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esptool_py</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), due to the configuration of the dependency chain, it still collects some other components that we do not need. </font><font style="vertical-align: inherit;">It collects all these components:</font></font><br>
<br>
<pre><code class="cmake hljs">app_trace app_update bootloader bootloader_support cxx driver efuse esp32 esp_common esp_eth esp_event esp_ringbuf<font></font>
esp_rom esp_wifi espcoredump esptool_py freertos heap log lwip main mbedtls newlib nvs_flash partition_table pthread<font></font>
soc spi_flash tcpip_adapter vfs wpa_supplicant xtensa</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Many of them are quite logical ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bootloader</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp32</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freertos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), but they are followed by unnecessary components because we do not use network functions: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_eth, esp_wifi, lwip, mbedtls, tcpip_adapter, wpa_supplicant</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Unfortunately, we are still forced to assemble these components. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortunately, the linker is smart enough and does not put unused components into a ready-made binary file of the game. </font><font style="vertical-align: inherit;">We can verify this with </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make size-components</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<code><pre>Total sizes:
 DRAM .data size:    8476 bytes
 DRAM .bss  size:    4144 bytes
Used static DRAM:   12620 bytes ( 168116 available, 7.0% used)
Used static IRAM:   56345 bytes (  74727 available, 43.0% used)
      Flash code:   95710 bytes
    Flash rodata:   40732 bytes
Total image size:~ 201263 bytes (.bin may be padded larger)
Per-archive contributions to ELF file:
            Archive File DRAM .data &amp; .bss   IRAM Flash code &amp; rodata   Total
                  libc.a        364      8   5975      63037     3833   73217
              libesp32.a       2110    151  15236      15415    21485   54397
           libfreertos.a       4148    776  14269          0     1972   21165
                libsoc.a        184      4   7909        875     4144   13116
          libspi_flash.a        714    294   5069       1320     1386    8783
                libvfs.a        308     48      0       5860      973    7189
         libesp_common.a         16   2240    521       1199     3060    7036
             libdriver.a         87     32      0       4335     2200    6654
               libheap.a        317      8   3150       1218      748    5441
             libnewlib.a        152    272    869        908       99    2300
        libesp_ringbuf.a          0      0    906          0      163    1069
                liblog.a          8    268    488         98        0     862
         libapp_update.a          0      4    127        159      486     776
 libbootloader_support.a          0      0      0        634        0     634
                libhal.a          0      0    519          0       32     551
            libpthread.a          8     12      0        288        0     308
             libxtensa.a          0      0    220          0        0     220
                libgcc.a          0      0      0          0      160     160
               libmain.a          0      0      0         22       13      35
                libcxx.a          0      0      0         11        0      11
                   (exe)          0      0      0          0        0       0
              libefuse.a          0      0      0          0        0       0
         libmbedcrypto.a          0      0      0          0        0       0
     libwpa_supplicant.a          0      0      0          0        0       0</pre></code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Most of all, libc affects the size of the binary, and that's fine.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Project configuration</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDF allows you to specify compile-time configuration parameters that it uses during assembly to enable or disable various functions. </font><font style="vertical-align: inherit;">We need to set parameters that will allow us to take advantage of the additional aspects of Odroid Go. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, you need to run the source script of </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">export.sh</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> so that CMake has access to the necessary environment variables. </font><font style="vertical-align: inherit;">Further, as for all CMake projects, we need to create an assembly folder and call CMake from it.</font></font><br>
<br>
<pre><code class="cmake hljs">source <span class="hljs-keyword">export</span>.sh<font></font>
mkdir build<font></font>
cd build<font></font>
cmake ..</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you run </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make menuconfig</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a window opens where you can configure project settings.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expanding flash memory up to 16 MB</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go expands the standard flash drive capacity to 16 MB. </font><font style="vertical-align: inherit;">You can enable this feature by going to </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serial flasher config -&gt; Flash size -&gt; 16MB</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Turn on external SPI RAM</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We also have access to an additional 4 MB of external RAM connected via SPI. </font><font style="vertical-align: inherit;">You can enable it by going to </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Component config -&gt; ESP32-specific -&gt; Support for external, SPI-connected RAM</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and pressing the space bar to enable it. </font><font style="vertical-align: inherit;">We also want to be able to explicitly allocate memory from SPI RAM; </font><font style="vertical-align: inherit;">this can be enabled by going to </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI RAM config -&gt; SPI RAM access method -&gt; Make RAM allocatable using heap_caps_malloc</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lower the frequency</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP32 works by default with a frequency of 160 MHz, but let's lower it to 80 MHz to see how far you can go with the lowest clock frequency. We want the game to work on battery power, and lowering the frequency will save power. You can change it by going to </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Component config -&gt; ESP32-specific -&gt; CPU frequency -&gt; 80MHz</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you select </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Save</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdkconfig</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file will be saved to the root of the project folder </font><font style="vertical-align: inherit;">. We can write this file in git, but it has a lot of parameters that are not important to us. So far, we are satisfied with the standard parameters, except for those that we just changed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can create the </font><strong><font style="vertical-align: inherit;">sdkconfig.defaults</font></strong><font style="vertical-align: inherit;"> file </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instead</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which will contain the values ‚Äã‚Äãchanged above. </font><font style="vertical-align: inherit;">Everything else will be configured by default. </font><font style="vertical-align: inherit;">During the build, the IDF will read </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdkconfig.defaults</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , override the values ‚Äã‚Äãwe set, and use the standard for all other parameters. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdkconfig.defaults</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> looks like this:</font></font><br>
<br>
<pre><code class="cpp hljs"># Set flash size to <span class="hljs-number">16</span>MB<font></font>
CONFIG_ESPTOOLPY_FLASHSIZE_16MB=y<font></font>
<font></font>
# Set CPU frequency to <span class="hljs-number">80</span>MHz<font></font>
CONFIG_ESP32_DEFAULT_CPU_FREQ_80=y<font></font>
<font></font>
# Enable SPI RAM <span class="hljs-keyword">and</span> allocate with heap_caps_malloc()<font></font>
CONFIG_ESP32_SPIRAM_SUPPORT=y<font></font>
CONFIG_SPIRAM_USE_CAPS_ALLOC=y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, the original structure of the game looks like this:</font></font><br>
<br>
<code><pre>game
‚îú‚îÄ‚îÄ CMakeLists.txt
‚îú‚îÄ‚îÄ export.sh
‚îú‚îÄ‚îÄ main
‚îÇ   ‚îú‚îÄ‚îÄ CMakeLists.txt
‚îÇ   ‚îî‚îÄ‚îÄ main.c
‚îî‚îÄ‚îÄ sdkconfig.defaults</pre></code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Build and flash</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The assembly and firmware process itself is quite simple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We run </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to compile (add </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-j4</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-j8</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for parallel builds </font><font style="vertical-align: inherit;">), </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make flash</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to write the image to Odroid Go, and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make monitor</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to see the output from the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> statements </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cmake hljs">make<font></font>
make flash<font></font>
make monitor</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We can also execute them in one line.</font></font><br>
<br>
<pre><code class="cmake hljs">make flash monitor</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The result is not particularly impressive, but it will become the basis for the rest of the project.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c2/329/62f/3c232962f8e782c9220b25b7e3c0df5e.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">References</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF Documentation: Build System</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FreeRTOS Documentation: vTaskDelay</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part 2: input</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introduction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We need to be able to read the buttons pressed by the player and the cross on Odroid Go.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buttons</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/142/ca2/106142ca2250eb9301215015b6f0bbad.png"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPIO</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go has six buttons: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Select</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volume</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each of the buttons is connected to a separate </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">General Purpose IO (GPIO) pin</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">GPIO pins can be used as inputs (for reading) or as outputs (we write to them). </font><font style="vertical-align: inherit;">In the case of buttons, we need a read. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First you need to configure the contacts as inputs, after which we can read their status. </font><font style="vertical-align: inherit;">The contacts inside have one of two voltages (3.3V or 0V), but when reading them using the IDF function, they are converted to integer values.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialization</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Elements marked as </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the diagram </font><font style="vertical-align: inherit;">are the physical buttons themselves. When not pressed, the ESP32 contacts ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO13</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , etc.) are connected to 3.3 V; i.e. 3.3 V means that the button is </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not pressed</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The logic here is the opposite of what is expected. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO39</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> have physical resistors on the board. If the button is not pressed, then the resistor </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pulls the</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contacts to a high voltage. If the button is pressed, then the current </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flowing</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> through the contacts goes to the ground instead, so the voltage 0 will be read from the contacts. </font><strong><font style="vertical-align: inherit;">IO13</font></strong><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO27</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO32</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO33</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do not have resistors, because the contact on the ESP32 has internal resistors, which we configured for pull-up mode. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Knowing this, we can configure six buttons using the GPIO API.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_A = GPIO_NUM_32;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_B = GPIO_NUM_33;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_START = GPIO_NUM_39;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_SELECT = GPIO_NUM_27;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_VOLUME = GPIO_NUM_0;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_MENU = GPIO_NUM_13;<font></font>
<font></font>
<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
gpioConfig.mode = GPIO_MODE_INPUT;<font></font>
gpioConfig.pull_up_en = GPIO_PULLUP_ENABLE;<font></font>
gpioConfig.pin_bit_mask =<font></font>
	  (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_A)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_B)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_START)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_SELECT)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_VOLUME)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_MENU);<font></font>
<font></font>
ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The constants specified at the beginning of the code correspond to each of the circuit contacts. We use the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gpio_config_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> structure </font><font style="vertical-align: inherit;">to configure each of the six buttons as pull-up input. In the case of </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO13</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO27</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO32</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO33,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we need to ask IDF to turn on the pull-up resistors of these contacts. For </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO39</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we don‚Äôt need to do this because they have physical resistors, but we will do it anyway to make the configuration beautiful. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP_ERROR_CHECK</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a helper macro from IDF that automatically checks the result of all functions that return </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_err_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(most of the IDF) and assert that the result is not equal to </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP_OK</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This macro is convenient to use for a function if its error is critical and after it makes no sense to continue execution. </font><font style="vertical-align: inherit;">In this game, a game without input is not a game, so this statement is true. </font><font style="vertical-align: inherit;">We will often use this macro.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reading buttons</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we configured all the contacts, and can finally read the values. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The number buttons are read by the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gpio_get_level</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">, but we need to invert the received values, because the contacts are pulled up, that is, a high signal actually means ‚Äúnot pressed‚Äù, and a low one means ‚Äúpressed‚Äù. </font><font style="vertical-align: inherit;">Inverting preserves the usual logic: 1 means ‚Äúpressed‚Äù, 0 - ‚Äúnot pressed‚Äù.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> a = !gpio_get_level(BUTTON_PIN_A);
<span class="hljs-keyword">int</span> b = !gpio_get_level(BUTTON_PIN_B);
<span class="hljs-keyword">int</span> select = !gpio_get_level(BUTTON_PIN_SELECT);
<span class="hljs-keyword">int</span> start = !gpio_get_level(BUTTON_PIN_START);
<span class="hljs-keyword">int</span> menu = !gpio_get_level(BUTTON_PIN_MENU);
<span class="hljs-keyword">int</span> volume = !gpio_get_level(BUTTON_PIN_VOLUME);</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crosspiece (D-pad)</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e8/d9e/a73/1e8d9ea7303257afd45846771726a275.png"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADC</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Connecting the cross is different from connecting the buttons. </font><font style="vertical-align: inherit;">The up and down buttons are connected to one pin of an </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analog-to-digital converter (ADC)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and the left and right buttons are </font><font style="vertical-align: inherit;">connected </font><font style="vertical-align: inherit;">to another ADC pin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unlike GPIO digital contacts, from which we could read one of two states (high or low), the ADC converts a continuous analog voltage (e.g., from 0 V to 3.3 V) into a discrete numerical value (e.g., from 0 to 4095 ) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I suppose the Odroid Go designers did so to save on GPIO pins (you only need two analog pins instead of four digital pins). </font><font style="vertical-align: inherit;">Be that as it may, this slightly complicates the configuration and reading from these contacts.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuration</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contact </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO35 is</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> connected to the Y axis of the </font><strong><font style="vertical-align: inherit;">spider</font></strong><font style="vertical-align: inherit;"> , and contact </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO34</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is </font><strong><font style="vertical-align: inherit;">connected</font></strong><font style="vertical-align: inherit;"> to the X axis of the </font><strong><font style="vertical-align: inherit;">spider</font></strong><font style="vertical-align: inherit;"> . We see that the joints of the cross are a little more complicated than the number buttons. Each axis has two switches ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the Y axis, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW4</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the X axis), each of which is connected to a set of resistors ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R4</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R5</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If neither ‚Äúup‚Äù nor ‚Äúdown‚Äù is pressed, the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO35 pin is</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pulled down to the ground via </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and we consider the value 0 V. If neither ‚Äúleft‚Äù nor ‚Äúright‚Äù is pressed, contact </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO34</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pulls down to the ground through </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R5</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and we count the value to 0 V. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW1 is</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pressed </font><strong><font style="vertical-align: inherit;">(‚Äúup‚Äù)</font></strong><font style="vertical-align: inherit;"> , then with </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO35</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we count 3.3 V. If </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW2 is</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pressed </font><strong><font style="vertical-align: inherit;">(‚Äúdown‚Äù)</font></strong><font style="vertical-align: inherit;"> , then with </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO35</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we count about 1, 65 V, because half the voltage will drop on resistor </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW3 (‚Äúleft‚Äù) is</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pressed </font><font style="vertical-align: inherit;">, then with </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO34</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we count 3.3 V. If </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW4 (‚Äúright‚Äù) is</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pressed </font><font style="vertical-align: inherit;">, then with </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO34</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we also count about 1.65 V, because half the voltage will drop on resistor </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R4</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Both cases are examples of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voltage dividers.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">When two resistors in the voltage divider have the same resistance (in our case - 100K), then the voltage drop will be half the input voltage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Knowing this, we can configure the crosspiece:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">adc1_channel_t</span> DPAD_PIN_X_AXIS = ADC1_GPIO34_CHANNEL;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">adc1_channel_t</span> DPAD_PIN_Y_AXIS = ADC1_GPIO35_CHANNEL;<font></font>
<font></font>
ESP_ERROR_CHECK(adc1_config_width(ADC_WIDTH_BIT_12));<font></font>
ESP_ERROR_CHECK(adc1_config_channel_atten(DPAD_PIN_X_AXIS,ADC_ATTEN_DB_11));<font></font>
ESP_ERROR_CHECK(adc1_config_channel_atten(DPAD_PIN_Y_AXIS,ADC_ATTEN_DB_11));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We set the ADC to 12 bits wide so that 0 V was read as 0, and 3.3 V as 4095 (2 ^ 12). </font><font style="vertical-align: inherit;">Attenuation reports that we don‚Äôt need to attenuate the signal so that we get the full voltage range from 0 V to 3.3 V. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At 12 bits, we can expect that if nothing is pressed, then 0 will be read, when pressed up and to the left - 4096, and approximately 2048 will be read when pressed down and to the right (because resistors reduce voltage by half).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cross reading</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reading the cross is more difficult than buttons, because we need to read the raw values ‚Äã‚Äã(from 0 to 4095) and interpret them.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> ADC_POSITIVE_LEVEL = <span class="hljs-number">3072</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> ADC_NEGATIVE_LEVEL = <span class="hljs-number">1024</span>;<font></font>
<font></font>
<span class="hljs-keyword">uint32_t</span> dpadX = adc1_get_raw(DPAD_PIN_X_AXIS);<font></font>
<font></font>
<span class="hljs-keyword">if</span> (dpadX &gt; ADC_POSITIVE_LEVEL)<font></font>
{<font></font>
	<span class="hljs-comment">// Left pressed</span><font></font>
}<font></font>
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dpadX &gt; ADC_NEGATIVE_LEVEL)<font></font>
{<font></font>
	<span class="hljs-comment">// Right pressed</span><font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">uint32_t</span> dpadY = adc1_get_raw(DPAD_PIN_Y_AXIS);<font></font>
<font></font>
<span class="hljs-keyword">if</span> (dpadY &gt; ADC_POSITIVE_LEVEL)<font></font>
{<font></font>
	<span class="hljs-comment">// Up pressed</span><font></font>
}<font></font>
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dpadY &gt; ADC_NEGATIVE_LEVEL)<font></font>
{<font></font>
	<span class="hljs-comment">// Down pressed</span>
}</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADC_POSITIVE_LEVEL</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADC_NEGATIVE_LEVEL</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are values ‚Äã‚Äãwith a margin, ensuring that we always read the correct values.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poll</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are two options for getting button values: polling or interrupts. We can create input processing functions and ask IDF to call these functions when buttons are pressed, or manually poll the state of the buttons when we need it. Interrupt-driven behavior makes things more complicated and difficult to understand. In addition, I always strive to make everything as simple as possible. If necessary, we can add interrupts later. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will create a structure that will store the state of six buttons and four directions of the cross. We can create a structure with 10 boolean, or 10 int, or 10 unsigned int. However, instead, we will create the structure using </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bit fields</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
	<span class="hljs-keyword">uint16_t</span> a : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> b : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> volume : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> menu : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> select : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> start : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> left : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> right : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> up : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> down : <span class="hljs-number">1</span>;<font></font>
} Odroid_Input;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When programming for desktop systems, bit fields are usually avoided because they are poorly ported to different machines, but we program for a specific machine and we don‚Äôt need to worry about that. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Instead of fields, a structure with 10 Boolean values ‚Äã‚Äãwith a total size of 10 bytes could be used. </font><font style="vertical-align: inherit;">Another option is one </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint16_t with</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bit shift and bit masking macros that can set, </font><strong><font style="vertical-align: inherit;">clear</font></strong><font style="vertical-align: inherit;"> , and check individual bits. </font><font style="vertical-align: inherit;">It will work, but it will not be very beautiful. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A simple bit field allows us to take advantage of both approaches: two bytes of data and named fields.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we can poll the state of inputs inside the main loop and display the result.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	Odroid_InitializeInput();<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (;;)<font></font>
	{<font></font>
		Odroid_Input input = Odroid_PollInput();<font></font>
<font></font>
		<span class="hljs-built_in">printf</span>(
			<span class="hljs-string">"\ra: %d  b: %d  start: %d  select: %d  vol: %d  menu: %d  up: %d  down: %d  left: %d  right: %d"</span>,<font></font>
			input.a, input.b, input.start, input.select, input.volume, input.menu,<font></font>
			input.up, input.down, input.left, input.right);<font></font>
<font></font>
		fflush(<span class="hljs-built_in">stdout</span>);<font></font>
<font></font>
		vTaskDelay(<span class="hljs-number">250</span> / portTICK_PERIOD_MS);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Should never get here</span><font></font>
	esp_restart();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">uses </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ r</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to overwrite the previous line instead of adding a new one. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fflush is</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> needed to display a line, because in the normal state it is reset by the newline character </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ n</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Your browser does not support HTML5 video.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_2/media/input.mp4" type="video/mp4"></video></div></div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">References</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid go schematic</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF Documentation: ADC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF Documentation: GPIO</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part 3: display</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introduction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We need to be able to render pixels on the Odroid Go LCD. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Displaying colors on the screen will be more difficult than reading the input status because the LCD has brains. </font><font style="vertical-align: inherit;">The screen is controlled by </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ILI9341</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a very popular TFT LCD driver on a single chip. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In other words, we are talking to ILI9341, which responds to our commands by controlling the pixels on the LCD. </font><font style="vertical-align: inherit;">When I say ‚Äúscreen‚Äù or ‚Äúdisplay‚Äù in this part, I will actually mean ILI9341. </font><font style="vertical-align: inherit;">We are dealing with ILI9341. </font><font style="vertical-align: inherit;">It controls the LCD.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The LCD is connected to the ESP32 via </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI (Serial Peripheral Interface)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SPI is a standard protocol used to exchange data between devices on a printed circuit board. It has four signals: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOSI (Master Out Slave In)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MISO (Master In Slave Out)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SCK (Clock)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CS (Chip Select)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A single master device on the bus coordinates data transfer by controlling SCK and CS. There can be several devices on one bus, each of which will have its own CS signals. When the CS signal of this device is activated, it can transmit and receive data.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The ESP32 will be the SPI master (master), and the LCD will be the slave SPI slave. </font><font style="vertical-align: inherit;">We need to configure the SPI bus with the required parameters and add an LCD display to the bus by configuring the corresponding contacts.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/60e/18c/7bc60e18c1b066ba7c22756464f92512.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f12/463/615/f124636158029efeab3259f299a2af36.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The names </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VSPI.XXXX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are just labels for the contacts in the diagram, but we can go through the contacts themselves by looking at the parts of the LCD and ESP32 diagrams.</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOSI</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; VSPI.MOSI -&gt; </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO23</font></font></strong></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MISO</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; VSPI.MISO -&gt; </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO19</font></font></strong></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SCK</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; VSPI.SCK -&gt; </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO18</font></font></strong></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CS0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; VSPI.CS0 -&gt; </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO5</font></font></strong></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We also have </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO14</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is the GPIO pin that is used to turn on the backlight, and also </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO21</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is connected to the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pin of the </font><font style="vertical-align: inherit;">LCD. This contact controls the type of information that we transmit to the display. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, configure the SPI bus.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_MISO = GPIO_NUM_19;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_MOSI = GPIO_NUM_23;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_SCLK = GPIO_NUM_18;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_CS = GPIO_NUM_5;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_DC = GPIO_NUM_21;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_BACKLIGHT = GPIO_NUM_14;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LCD_WIDTH = <span class="hljs-number">320</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LCD_HEIGHT = <span class="hljs-number">240</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LCD_DEPTH = <span class="hljs-number">2</span>;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">spi_bus_config_t</span> spiBusConfig = {};<font></font>
spiBusConfig.miso_io_num = LCD_PIN_MISO;<font></font>
spiBusConfig.mosi_io_num = LCD_PIN_MOSI;<font></font>
spiBusConfig.sclk_io_num = LCD_PIN_SCLK;<font></font>
spiBusConfig.quadwp_io_num = <span class="hljs-number">-1</span>; <span class="hljs-comment">// Unused</span>
spiBusConfig.quadhd_io_num = <span class="hljs-number">-1</span>; <span class="hljs-comment">// Unused</span><font></font>
spiBusConfig.max_transfer_sz = LCD_WIDTH * LCD_HEIGHT * LCD_DEPTH;<font></font>
<font></font>
ESP_ERROR_CHECK(spi_bus_initialize(VSPI_HOST, &amp;spiBusConfig, <span class="hljs-number">1</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We configure the bus using </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spi_bus_config_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It is necessary to communicate the contacts we use and the maximum size of one data transfer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For now, we will perform one SPI transmission for all frame buffer data, which is equal to the width of the LCD (in pixels) times its height (in pixels) times the number of bytes per pixel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The width is 320, the height is 240, and the color depth is 2 bytes (the display expects pixel colors to be 16 bits deep).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">spi_handle_t</span> gSpiHandle;<font></font>
<font></font>
<span class="hljs-keyword">spi_device_interface_config_t</span> spiDeviceConfig = {};<font></font>
spiDeviceConfig.clock_speed_hz = SPI_MASTER_FREQ_40M;<font></font>
spiDeviceConfig.spics_io_num = LCD_PIN_CS;<font></font>
spiDeviceConfig.queue_size = <span class="hljs-number">1</span>;<font></font>
spiDeviceConfig.flags = SPI_DEVICE_NO_DUMMY;<font></font>
<font></font>
ESP_ERROR_CHECK(spi_bus_add_device(VSPI_HOST, &amp;spiDeviceConfig, &amp;gSpiHandle));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After initializing the bus, we need to add an LCD device to the bus so that we can start talking to it.</font></font><br>
<br>
<ul>
<li><strong>clock_speed_hz</strong> ‚Äî   - ,      SPI   40 ,     .        80 ,         .</li>
<li><strong>spics_io_num</strong> ‚Äî    CS,  IDF     CS,        ( SD-     SPI).</li>
<li><strong>queue_size</strong> ‚Äî     1,           (  ).</li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flags</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the IDF SPI driver usually inserts empty bits in the transmission to avoid timing problems during reading from the SPI device, but we perform one-way transmission (we will not read from the display). </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI_DEVICE_NO_DUMMY</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reports that we confirm this one-way transmission and we do not need to insert empty bits.</font></font></li>
</ul><br>
<br>
<pre><code class="cpp hljs">gpio_set_direction(LCD_PIN_DC, GPIO_MODE_OUTPUT);<font></font>
gpio_set_direction(LCD_PIN_BACKLIGHT, GPIO_MODE_OUTPUT);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We also need to set the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and backlight pins as GPIO pins. </font><font style="vertical-align: inherit;">After switching </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC, the</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> backlight will be constantly on.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teams</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Communication with the LCD is in the form of commands. </font><font style="vertical-align: inherit;">First, we pass a byte denoting the command we want to send, and then we pass the command parameters (if any). </font><font style="vertical-align: inherit;">The display understands that the byte is a command if the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> signal is low. </font><font style="vertical-align: inherit;">If the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> signal is high, then the received data will be considered the parameters of the previously transmitted command. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, the stream looks like this:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We give a </font><font style="vertical-align: inherit;">low signal </font><font style="vertical-align: inherit;">to </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We send one byte of the command</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We give a </font><font style="vertical-align: inherit;">high signal </font><font style="vertical-align: inherit;">to </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Send zero or more bytes, depending on the requirements of the command</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repeat steps 1-4</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here our best friend is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the ILI9341 specification</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It lists all the possible commands, their parameters and how to use them.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68d/8d8/09c/68d8d809ceb9446142cd5c77bb78d0e2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An example of a command without parameters is </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Display ON</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The command byte is </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x29</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but no parameters are specified for it.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35a/4e0/446/35a4e04466c22aa6746fe441f345c02f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An example of a command with parameters is the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Column Address Set</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The command byte is </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x2A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but four required parameters are specified for it. </font><font style="vertical-align: inherit;">To use the command, you need to send a </font><font style="vertical-align: inherit;">low signal </font><font style="vertical-align: inherit;">to </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , send </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x2A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , send a </font><font style="vertical-align: inherit;">high signal </font><font style="vertical-align: inherit;">to </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and then transfer the bytes of four parameters. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The command codes themselves are listed.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span><font></font>
{<font></font>
	SOFTWARE_RESET = <span class="hljs-number">0x01</span>u,<font></font>
	SLEEP_OUT = <span class="hljs-number">0x11</span>u,<font></font>
	DISPLAY_ON = <span class="hljs-number">0x29</span>u,<font></font>
	COLUMN_ADDRESS_SET = <span class="hljs-number">0x2A</span>u,<font></font>
	PAGE_ADDRESS_SET = <span class="hljs-number">0x2B</span>u,<font></font>
	MEMORY_WRITE = <span class="hljs-number">0x2C</span>u,<font></font>
	MEMORY_ACCESS_CONTROL = <span class="hljs-number">0x36</span>u,<font></font>
	PIXEL_FORMAT_SET = <span class="hljs-number">0x3A</span>u,<font></font>
} CommandCode;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Instead, we could use a macro ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#define SOFTWARE_RESET (0x01u)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), but they do not have symbols in the debugger and they have no scope. </font><font style="vertical-align: inherit;">It would also be possible to use the integer static constants, as we did with the GPIO contacts, but thanks to enum, at a glance we can understand what data is passed to a function or member of the structure: they are of type </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CommandCode</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Otherwise, it could be raw </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that </font><strong><font style="vertical-align: inherit;">tells</font></strong><font style="vertical-align: inherit;"> nothing to the programmer reading the code.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Launch</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
During initialization, we can pass different commands to be able to draw something. </font><font style="vertical-align: inherit;">Each command has a command byte, which we will call </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Command Code</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will define a structure for storing the launch command so that you can specify their array.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span><font></font>
	CommandCode code;<font></font>
	<span class="hljs-keyword">uint8_t</span> parameters[<span class="hljs-number">15</span>];
	<span class="hljs-keyword">uint8_t</span> length;<font></font>
} StartupCommand;</code></pre><br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the command code.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameters</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is an array of command parameters (if any). </font><font style="vertical-align: inherit;">This is a static array of size 15, because this is the maximum number of parameters we need. </font><font style="vertical-align: inherit;">Due to the static nature of the array, we don‚Äôt have to worry about allocating a dynamic array for each command every time.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">length</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the number of parameters in the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameters</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> array </font><font style="vertical-align: inherit;">.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using this structure, we can specify a list of launch commands.</font></font><br>
<br>
<pre><code class="cpp hljs">StartupCommand gStartupCommands[] =<font></font>
{<font></font>
	<span class="hljs-comment">// Reset to defaults</span><font></font>
	{<font></font>
		SOFTWARE_RESET,<font></font>
		{},<font></font>
		<span class="hljs-number">0</span><font></font>
	},<font></font>
<font></font>
	<span class="hljs-comment">// Landscape Mode</span>
	<span class="hljs-comment">// Top-Left Origin</span>
	<span class="hljs-comment">// BGR Panel</span><font></font>
	{<font></font>
		MEMORY_ACCESS_CONTROL,<font></font>
		{<span class="hljs-number">0x20</span> | <span class="hljs-number">0xC0</span> | <span class="hljs-number">0x08</span>},
		<span class="hljs-number">1</span><font></font>
	},<font></font>
<font></font>
	<span class="hljs-comment">// 16 bits per pixel</span><font></font>
	{<font></font>
		PIXEL_FORMAT_SET,<font></font>
		{<span class="hljs-number">0x55</span>},
		<span class="hljs-number">1</span><font></font>
	},<font></font>
<font></font>
	<span class="hljs-comment">// Exit sleep mode</span><font></font>
	{<font></font>
		SLEEP_OUT,<font></font>
		{},<font></font>
		<span class="hljs-number">0</span><font></font>
	},<font></font>
<font></font>
	<span class="hljs-comment">// Turn on the display</span><font></font>
	{<font></font>
		DISPLAY_ON,<font></font>
		{},<font></font>
		<span class="hljs-number">0</span><font></font>
	},<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commands without parameters, for example, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOFTWARE_RESET</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , set the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameters</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> initializer list to </font><font style="vertical-align: inherit;">empty (that is, with one zeros) and length set to 0. Commands with parameters fill in the parameters and specify length. </font><font style="vertical-align: inherit;">It would be great if we could set length automatically, and not write numbers (in case we make a mistake or the parameters change), but I do not think that it is worth the trouble. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The purpose of most teams is clear from the name, with the exception of two. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MEMORY_ACCESS_CONTROL</font></font></strong><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Landscape Mode:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> By default, the display uses portrait orientation (240x320), but we want to use landscape (320x240).</font></font></li>
<li><strong>Top-Left Origin:</strong>      (0,0)     ,    ( )         .</li>
<li><strong>BGR Panel:</strong>  ,        BGR.   ,    , ,   ,     .</li>
</ul><br>
<strong>PIXEL_FORMAT_SET</strong><br>
<br>
<ul>
<li><strong>16 bits per pixel:</strong>   16- .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are many other commands that can be sent at startup to control various aspects, such as gamma. The necessary parameters are described in the specification of the LCD itself (and not the ILI9341 controller), to which we do not have access. If we do not transmit these commands, then the default display settings are used, which suits us perfectly. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having prepared an array of launch commands, we can begin to transfer them to the display. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, we need a function that sends one byte of command to the display. Do not forget that sending commands is different from sending parameters, because we need to send a </font><font style="vertical-align: inherit;">low signal </font><font style="vertical-align: inherit;">to </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BYTES_TO_BITS(value) ( (value) * 8 )</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SendCommandCode</span><span class="hljs-params">(CommandCode code)</span>
</span>{
	<span class="hljs-keyword">spi_transaction_t</span> transaction = {};<font></font>
<font></font>
	transaction.length = BYTES_TO_BITS(<span class="hljs-number">1</span>);<font></font>
	transaction.tx_data[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">uint8_t</span>)code;<font></font>
	transaction.flags = SPI_TRANS_USE_TXDATA;<font></font>
<font></font>
	gpio_set_level(LCD_PIN_DC, <span class="hljs-number">0</span>);<font></font>
	spi_device_transmit(gSpiHandle, &amp;transaction);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The IDF has a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spi_transaction_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> structure </font><font style="vertical-align: inherit;">, which we populate when we want to transfer something via the SPI bus. We know how many bits the payload is and transfer the load itself. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We can either pass a pointer to the payload, or use the internal struct </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tx_data</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> structure, which is only four bytes in size, but saves the driver from having to access external memory. If we use </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tx_data</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we must set the flag </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI_TRANS_USE_TXDATA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before transmitting data, we send a </font><font style="vertical-align: inherit;">low signal </font><font style="vertical-align: inherit;">to the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , indicating that this is a command code.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SendCommandParameters</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span>* data, <span class="hljs-keyword">int</span> length)</span>
</span>{
	<span class="hljs-keyword">spi_transaction_t</span> transaction = {};<font></font>
<font></font>
	transaction.length = BYTES_TO_BITS(length);<font></font>
	transaction.tx_buffer = data;<font></font>
	transaction.flags = <span class="hljs-number">0</span>;<font></font>
<font></font>
	gpio_set_level(LCD_PIN_DC, <span class="hljs-number">1</span>);<font></font>
	spi_device_transmit(SPIHANDLE, &amp;transaction);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passing parameters is similar to sending a command, only this time we use our own buffer ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) and send a </font><font style="vertical-align: inherit;">high signal </font><font style="vertical-align: inherit;">to </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to tell the display that the parameters are being transmitted. </font><font style="vertical-align: inherit;">In addition, we do not set the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI_TRANS_USE_TXDATA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> flag </font><font style="vertical-align: inherit;">because we are passing our own buffer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then you can send all the launch commands.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARRAY_COUNT(value) ( sizeof(value) / sizeof(value[0]) )</span><font></font>
<font></font>
<span class="hljs-keyword">int</span> commandCount = ARRAY_COUNT(gStartupCommands);<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> commandIndex = <span class="hljs-number">0</span>; commandIndex &lt; commandCount; ++commandIndex)<font></font>
{<font></font>
	StartupCommand* command = &amp;gStartupCommands[commandIndex];<font></font>
<font></font>
	SendCommandCode(command-&gt;code);<font></font>
<font></font>
	<span class="hljs-keyword">if</span> (command-&gt;length &gt; <span class="hljs-number">0</span>)<font></font>
	{<font></font>
		SendCommandData(command-&gt;parameters, command-&gt;length);<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We iteratively traverse the array of launch commands, passing the command code first, and then the parameters (if any).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frame drawing</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After initializing the display, you can start drawing on it.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UPPER_BYTE_16(value) ( (value) &gt;&gt; 8u )</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOWER_BYTE_16(value) ( (value) &amp; 0xFFu )</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_DrawFrame</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span>* buffer)</span>
</span>{
	<span class="hljs-comment">// Set drawing window width to (0, LCD_WIDTH)</span>
    <span class="hljs-keyword">uint8_t</span> drawWidth[] = { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, UPPER_BYTE_16(LCD_WIDTH), LOWER_BYTE_16(LCD_WIDTH) };<font></font>
	SendCommandCode(COLUMN_ADDRESS_SET);<font></font>
	SendCommandParameters(drawWidth, ARRAY_COUNT(drawWidth));<font></font>
<font></font>
	<span class="hljs-comment">// Set drawing window height to (0, LCD_HEIGHT)</span>
    <span class="hljs-keyword">uint8_t</span> drawHeight[] = { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, UPPER_BYTE_16(LCD_HEIGHT), LOWER_BYTE_16(LCD_HEIGHT) };<font></font>
	SendCommandCode(PAGE_ADDRESS_SET);<font></font>
	SendCommandParameters(drawHeight, ARRAY_COUNT(drawHeight));<font></font>
<font></font>
	<span class="hljs-comment">// Send the buffer to the display</span><font></font>
	SendCommandCode(MEMORY_WRITE);<font></font>
	SendCommandParameters(buffer, LCD_WIDTH * LCD_HEIGHT * LCD_DEPTH);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ILI9341 has the ability to redraw individual parts of the screen. This may come in handy in the future if we notice a drop in frame rate. In this case, it will be possible to update only the changed parts of the screen, but for now we will simply redraw the entire screen again. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To render a frame, it requires setting a render window. To do this, send the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COLUMN_ADDRESS_SET</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">with the window width and the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PAGE_ADDRESS_SET</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">with the window height. Each of the commands takes four bytes of the parameter that describe the window into which we will perform the rendering. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPPER_BYTE_16</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LOWER_BYTE_16</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- These are auxiliary macros for extracting the high and low bytes from a 16-bit value. </font><font style="vertical-align: inherit;">The parameters of these commands require us to split the 16-bit value into two 8-bit values, which is why we do this. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rendering is initiated by the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MEMORY_WRITE</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">and sending to the display all </font><strong><font style="vertical-align: inherit;">153,600</font></strong><font style="vertical-align: inherit;"> bytes of the frame buffer at a time. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are other ways to transfer the frame buffer to the display:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can create another FreeRTOS task (task), which is responsible for coordinating SPI transactions.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can transfer a frame not in one, but in several transactions.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can use non-blocking transmission, in which we initiate the sending, and then continue to perform other operations.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can use any combination of the above methods.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For now, we will use the simplest way: the only blocking transaction. </font><font style="vertical-align: inherit;">When </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DrawFrame is</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> called, the </font><font style="vertical-align: inherit;">transfer to the display is initiated and our task is paused until the transfer is completed. </font><font style="vertical-align: inherit;">If later we find out that we cannot achieve a good frame rate with this method, then we will return to this problem.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB565 and byte order</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A typical display (for example, your computer‚Äôs monitor) has a bit depth of 24 bits (1.6 million colors): 8 bits per red, green and blue. The pixel is written to memory as </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RRRRRRRRGGGGGGGGGBBBBBBBBB</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Odroid LCD has a bit depth of 16 bits (65 thousand colors): 5 bits of red, 6 bits of green and 5 bits of blue. The pixel is written to memory as </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RRRRRGGGGGGGBBBBB</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This format is called </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB565</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWAP_ENDIAN_16(value) ( (((value) &amp; 0xFFu) <span class="hljs-meta-string">&lt;&lt; 8u) | ((value) &gt;&gt; 8u)  )</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RGB565(red, green, blue) ( SWAP_ENDIAN_16( ((red) &lt;&lt; 11u) | ((green) &lt;&lt; 5u) | (blue) ) )</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Define a macro that creates a color in the RGB565 format. We will pass him a byte of red, a byte of green and a byte of blue. He will take the five most significant bits of red, the six most significant bits of green and the five most significant bits of blue. We chose high bits because they contain more information than low bits. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, the ESP32 stores the data in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Little Endian</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> order </font><font style="vertical-align: inherit;">, i.e. the least significant byte is stored in the lower memory address. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, the 32-bit value </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[0xDE 0xAD 0xBE 0xEF]</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will be stored in memory as </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[0xEF 0xBE 0xAD 0xDE]</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . When transferring data to the display, this becomes a problem because the least significant byte will be sent first, and the LCD expects to receive the most significant byte first. </font><strong><font style="vertical-align: inherit;">Set</font></strong></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
macro </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SWAP_ENDIAN_16</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to swap bytes and use it in the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB565</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> macro </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here's how each of the three primary colors is described in RGB565 and how they are stored in ESP32 memory if you don't change the byte order. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Red</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
11111 | 000000 | 00000? -&gt; 11111000 00000000 -&gt; 00000000 11111000 </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Green</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
00000 | 111111 | 00000? -&gt; 00000111 11100000 -&gt; 11100000 00000111 </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blue</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
00000 | 000000 | 11111? -&gt; 00000000 00011111 -&gt; 00011111 00000000</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We can create a simple demo to watch the LCD in action. </font><font style="vertical-align: inherit;">At the beginning of the frame, it flushes the frame buffer to black and draws a 50x50 square. </font><font style="vertical-align: inherit;">We can move the square with a cross and change its color with buttons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	Odroid_InitializeInput();<font></font>
	Odroid_InitializeDisplay();<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Odroid initialization complete - entering main loop"</span>);<font></font>
<font></font>
	<span class="hljs-keyword">uint16_t</span>* framebuffer = (<span class="hljs-keyword">uint16_t</span>*)heap_caps_malloc(<span class="hljs-number">320</span> * <span class="hljs-number">240</span> * <span class="hljs-number">2</span>, MALLOC_CAP_DMA);<font></font>
	assert(framebuffer);<font></font>
<font></font>
	<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">uint16_t</span> color = <span class="hljs-number">0xffff</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (;;)<font></font>
	{<font></font>
		<span class="hljs-built_in">memset</span>(framebuffer, <span class="hljs-number">0</span>, <span class="hljs-number">320</span> * <span class="hljs-number">240</span> * <span class="hljs-number">2</span>);<font></font>
<font></font>
		Odroid_Input input = Odroid_PollInput();<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (input.left) { x -= <span class="hljs-number">10</span>; }
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.right) { x += <span class="hljs-number">10</span>; }<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (input.up) { y -= <span class="hljs-number">10</span>; }
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.down) { y += <span class="hljs-number">10</span>; }<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (input.a) { color = RGB565(<span class="hljs-number">0xff</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); }
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.b) { color = RGB565(<span class="hljs-number">0</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0</span>); }
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.start) { color = RGB565(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xff</span>); }<font></font>
<font></font>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = y; row &lt; y + <span class="hljs-number">50</span>; ++row)<font></font>
		{<font></font>
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = x; col &lt; x + <span class="hljs-number">50</span>; ++col)<font></font>
			{<font></font>
				framebuffer[<span class="hljs-number">320</span> * row + col] = color;<font></font>
			}<font></font>
		}<font></font>
<font></font>
		Odroid_DrawFrame(framebuffer);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Should never get here</span><font></font>
	esp_restart();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We allocate the frame buffer according to the full size of the display: 320 x 240, two bytes per pixel (16-bit color). </font><font style="vertical-align: inherit;">We use </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">heap_caps_malloc</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> so that it is allocated in memory, which can be used for SPI transactions with </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direct Memory Access (DMA)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">DMA allows SPI peripherals to access the frame buffer without the need for CPU involvement. </font><font style="vertical-align: inherit;">Without DMA, SPI transactions take much longer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We do not perform checks to ensure that rendering does not occur outside the borders of the screen.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Your browser does not support HTML5 video.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_3/media/demo.mp4" type="video/mp4"></video></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Strong tearing is noticeable. In desktop applications, the standard way to eliminate tearing is to use multiple buffers. For example, when double buffering, there are two buffers: front and rear buffers. While the front buffer is displayed, recording is performed </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
in the rear. Then they change places and the process repeats. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP32 does not have enough RAM with DMA capabilities to store two frame buffers (4 MB of external SPI RAM, unfortunately, does not have DMA capabilities), so this option is not suitable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ILI9341 has a signal ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TE</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) that tells you when </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBLANK</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> occurs </font><strong><font style="vertical-align: inherit;">so</font></strong><font style="vertical-align: inherit;"> that we can write to the display until it is drawn. But with Odroid (or the display module) this signal is not connected, so we can‚Äôt access it.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhaps we could find a decent value, but for now we will not do it, because now our task is to simply display the pixels on the screen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All source code can be found </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">References</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid go schematic</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go play</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF Documentation: SPI Master</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LCD Driver Datasheet</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en502518/index.html">How to climb a tree</a></li>
<li><a href="../en502520/index.html">Video reports of mitap reports on product analytics</a></li>
<li><a href="../en502522/index.html">We open the galvanic isolation chip with a tiny transformer inside</a></li>
<li><a href="../en502524/index.html">Psychos make civilization</a></li>
<li><a href="../en502526/index.html">JUG Ru Group # 2 Online Stream Week</a></li>
<li><a href="../en502532/index.html">The revolution in the IT department (department). Is it necessary?</a></li>
<li><a href="../en502536/index.html">First impressions and key features of MIUI 12</a></li>
<li><a href="../en502538/index.html">How to build an old version of NGINX Ingress Controller and patch it</a></li>
<li><a href="../en502540/index.html">Alpine.js - continue dating</a></li>
<li><a href="../en502542/index.html">How we teach Yandex to answer questions and save users 20 thousand hours a day</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>