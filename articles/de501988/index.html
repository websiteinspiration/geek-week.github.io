<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰🏽 🧑🏾‍🤝‍🧑🏻 🤴🏼 Wie wird der VK-Nachrichtenbildschirm gerendert? 👩🏾‍🤝‍👩🏽 ✋🏼 ⌨️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was unternimmt VK, um Rendering-Verzögerungen zu reduzieren? Wie kann man eine sehr große Nachricht anzeigen und UiThread nicht beenden? Wie können Bi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Wie wird der VK-Nachrichtenbildschirm gerendert?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/501988/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was unternimmt VK, um Rendering-Verzögerungen zu reduzieren? </font><font style="vertical-align: inherit;">Wie kann man eine sehr große Nachricht anzeigen und UiThread nicht beenden? </font><font style="vertical-align: inherit;">Wie können Bildlaufverzögerungen in RecyclerView reduziert werden? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vs/2s/jg/vs2sjg1iyfq7cdkohrmgpuy5mla.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meine Erfahrung basiert auf der Arbeit beim Zeichnen eines Nachrichtenbildschirms in der VK-Android-Anwendung, in dem eine große Menge an Informationen mit einem Minimum an Bremsen auf der Benutzeroberfläche angezeigt werden muss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich programmiere seit fast zehn Jahren für Android, war zuvor freiberuflich für PHP / Node.js. </font><font style="vertical-align: inherit;">Jetzt - ein leitender Android-Entwickler VKontakte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter dem Schnitt - Video und Transkript meines Berichts von der Mobius 2019 Moskauer Konferenz.</font></font><a name="habracut"></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GZkTwgetUWI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Bericht enthält drei Themen</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardlösungen sind die Grundprinzipien für die Funktionsweise des VK-Nachrichtenbildschirms. </font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht standardmäßige Lösungen sind wenig bekannte oder originelle Lösungen, mit denen sich Verzögerungen der Benutzeroberfläche minimieren lassen.</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei Alternativen geht es um verschiedene Bibliotheken und Implementierungen sowie darum, warum VK-Entwickler sie nicht verwendet haben.</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schau auf den Bildschirm:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/he/h2/xj/heh2xjq-ij5pnzsu49cf11uuabu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Nachricht befindet sich irgendwo auf fünf Bildschirmen. </font><font style="vertical-align: inherit;">Und sie können durchaus bei uns sein (im Falle der Weiterleitung von Nachrichten). </font><font style="vertical-align: inherit;">Standardwerkzeuge funktionieren nicht mehr. </font><font style="vertical-align: inherit;">Selbst auf einem Top-Gerät kann alles zurückbleiben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus ist die Benutzeroberfläche selbst sehr unterschiedlich:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ladedaten und Indikatoren,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Servicemeldungen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Text (Emoji, Link, E-Mail, Hashtags),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bot-Tastatur</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">~ 40 Möglichkeiten zum Anzeigen von Anhängen,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baum der weitergeleiteten Nachrichten.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellt sich die Frage, wie die Anzahl der Verzögerungen so gering wie möglich gehalten werden kann. </font><font style="vertical-align: inherit;">Sowohl bei einfachen Nachrichten als auch bei Massennachrichten (Randfall aus dem obigen Video).</font></font><br>
<a name="ordinary"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardlösungen</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecyclerView und seine Add-Ons</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt verschiedene Add-Ons für RecyclerView.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setHasFixedSize ( </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viele Leute denken, dass dieses Flag benötigt wird, wenn die Listenelemente dieselbe Größe haben. </font><font style="vertical-align: inherit;">Nach der Dokumentation ist das Gegenteil der Fall. </font><font style="vertical-align: inherit;">In diesem Fall ist die Größe der RecyclerView konstant und unabhängig von den Elementen (ungefähr nicht wrap_content). </font><font style="vertical-align: inherit;">Durch Setzen des Flags kann die Geschwindigkeit von RecyclerView leicht erhöht werden, sodass unnötige Berechnungen vermieden werden.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setNestedScrollingEnabled ( </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kleinere Optimierung, die die NestedScroll-Unterstützung deaktiviert. </font><font style="vertical-align: inherit;">Wir haben keine CollapsingToolbar oder andere Funktionen in Abhängigkeit von NestedScroll auf diesem Bildschirm, daher können wir dieses Flag sicher auf false setzen.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setItemViewCacheSize ( </font></font><code>cache_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einrichten des internen RecyclerView-Cache. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viele Leute denken, dass die Mechanik von RecyclerView:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf dem Bildschirm wird ein ViewHolder angezeigt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt einen RecycledViewPool, in dem ViewHolder gespeichert ist.</font></font></li>
<li> ViewHolder    —    RecycledViewPool.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Praxis ist alles etwas komplizierter, da zwischen diesen beiden Dingen ein Zwischencache besteht. </font><font style="vertical-align: inherit;">Es heißt ItemViewCache. </font><font style="vertical-align: inherit;">Was ist seine Essenz? </font><font style="vertical-align: inherit;">Wenn der ViewHolder den Bildschirm verlässt, wird er nicht im RecycledViewPool, sondern im Zwischencache (ItemViewCache) abgelegt. </font><font style="vertical-align: inherit;">Alle Änderungen im Adapter gelten sowohl für den sichtbaren ViewHolder als auch für den ViewHolder im ItemViewCache. </font><font style="vertical-align: inherit;">Für den ViewHolder im RecycledViewPool werden die Änderungen nicht übernommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Über setItemViewCacheSize können wir die Größe dieses Zwischencaches festlegen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je größer es ist, desto schneller ist der Bildlauf über kurze Strecken, aber die Aktualisierungsvorgänge dauern länger (aufgrund von ViewHolder.onBind usw.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie RecyclerView implementiert wird und wie sein Cache strukturiert ist, ist ein ziemlich großes und komplexes Thema. </font><font style="vertical-align: inherit;">Sie können einen großartigen </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Artikel</font></a><font style="vertical-align: inherit;"> lesen</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wo sie ausführlich über alles sprechen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimierung OnCreate / OnBind</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine weitere klassische Lösung ist die Optimierung von onCreateViewHolder / onBindViewHolder:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einfaches Layout (wir versuchen, FrameLayout oder Custom ViewGroup so oft wie möglich zu verwenden),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwere Operationen (Parsing Links / Emoji) werden asynchron in der Phase des Ladens von Nachrichten ausgeführt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StringBuilder zum Formatieren von Name, Datum usw.,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und andere Lösungen, die die Arbeitszeit dieser Methoden verkürzen.</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tracking Adapter.onFailedToRecyclerView ()</font></font></h3><br>
<img src="https://habrastorage.org/webt/8l/eo/1n/8leo1nki7gxrit4wg8mhhv0q3ua.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie haben eine Liste, in der einige Elemente (oder Teile davon) mit Alpha animiert sind. </font><font style="vertical-align: inherit;">In dem Moment, in dem View, der gerade animiert wird, den Bildschirm verlässt, wird es nicht zu RecycledViewPool weitergeleitet. </font><font style="vertical-align: inherit;">Warum? </font><font style="vertical-align: inherit;">RecycledViewPool erkennt, dass die Ansicht jetzt durch das Flag View.hasTransientState animiert wird, und ignoriert sie einfach. </font><font style="vertical-align: inherit;">Wenn Sie das nächste Mal nach oben und unten scrollen, wird das Bild daher nicht aus RecycledViewPool aufgenommen, sondern neu erstellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die richtigste Entscheidung ist, wenn ViewHolder den Bildschirm verlässt, müssen Sie alle Animationen abbrechen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-7/1r/rh/-71rrhbw5idwburnf60gtfllcau.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie so schnell wie möglich einen Hotfix benötigen oder ein fauler Entwickler sind, können Sie in der onFailedToRecycle-Methode einfach immer true zurückgeben und alles wird funktionieren, aber ich würde nicht raten, dies zu tun.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/iu/se/ha/iusehamefbgzcvc6miixbtfmfoy.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tracking Overdraw und Profiler</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die klassische Methode zur Erkennung von Problemen ist das Überziehen und das Nachverfolgen von Profilern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Überzeichnen - Die Anzahl der Neuzeichnungen des Pixels: Je weniger Ebenen und je weniger Neuzeichnungen des Pixels, desto schneller. Aber nach meinen Beobachtungen wirkt sich dies in der modernen Realität nicht so sehr auf die Leistung aus. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/0h/-d/fh/0h-dfhogberhs_hsy1eseaexkwa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Profiler - auch bekannt als Android Monitor, der sich in Android Studio befindet. Darin können Sie alle aufgerufenen Methoden analysieren. Öffnen Sie beispielsweise Nachrichten, scrollen Sie nach oben und unten und sehen Sie, welche Methoden aufgerufen wurden und wie lange sie gedauert haben. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dz/la/wy/dzlawyqmpqtzxbnpcbezvfoq_ww.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der linken Hälfte befinden sich lediglich die Android-Systemaufrufe, die zum Erstellen / Rendern eines View / ViewHolder erforderlich sind. Entweder können wir sie nicht beeinflussen, oder wir müssen uns viel Mühe geben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die rechte Hälfte ist unser Code, der in ViewHolder ausgeführt wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Aufrufblock bei Nummer 1 ist ein Aufruf von regulären Ausdrücken: Irgendwo haben sie übersehen und vergessen, die Operation auf den Hintergrund-Thread zu übertragen, wodurch der Bildlauf um ~ 20% verlangsamt wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anrufblock unter Nummer 2 - Fresco, eine Bibliothek zur Anzeige von Bildern. </font><font style="vertical-align: inherit;">Es ist an einigen Stellen nicht optimal. Es ist noch nicht klar, was mit dieser Verzögerung zu tun ist, aber wenn wir sie lösen können, werden wir weitere ~ 15% einsparen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, wenn wir diese Probleme beheben, können wir eine Steigerung von ~ 35% erzielen, was ziemlich cool ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diffiff</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viele von Ihnen verwenden DiffUtil in seiner Standardform: Es gibt zwei Listen - aufgerufene, verglichene und gepusste Änderungen. All dies im Haupt-Thread zu tun ist etwas teuer, da die Liste sehr groß sein kann. Daher wird die DiffUtil-Berechnung normalerweise in einem Hintergrundthread ausgeführt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ListAdapter und AsyncListDiffer erledigen dies für Sie. Der ListAdapter erweitert den regulären Adapter und startet alles asynchron - erstellen Sie einfach eine SubmitList und die gesamte Berechnung der Änderungen wird in den internen Hintergrund-Thread übertragen. Der ListAdapter kann den Fall häufiger Aktualisierungen berücksichtigen: Wenn Sie ihn dreimal hintereinander aufrufen, wird nur das letzte Ergebnis angezeigt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DiffUtil selbst verwenden wir nur für einige strukturelle Änderungen - das Erscheinungsbild der Nachricht, ihre Änderung und Löschung. </font><font style="vertical-align: inherit;">Für einige Schnellwechseldaten ist es nicht geeignet. </font><font style="vertical-align: inherit;">Zum Beispiel, wenn wir ein Foto hochladen oder Audio abspielen. </font><font style="vertical-align: inherit;">Solche Ereignisse treten häufig auf - mehrmals pro Sekunde. Wenn Sie DiffUtil jedes Mal ausführen, erhalten Sie viel zusätzliche Arbeit.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animationen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es war einmal ein Animations-Framework - eher dürftig, aber immer noch etwas. </font><font style="vertical-align: inherit;">Wir haben so mit ihm gearbeitet:</font></font><br>
<br>
<pre><code class="java hljs">view.startAnimation(TranslateAnimation(fromX = <span class="hljs-number">0</span>, toX = <span class="hljs-number">300</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem ist, dass der Parameter getTranslationX () vor und nach der Animation denselben Wert zurückgibt. </font><font style="vertical-align: inherit;">Dies liegt daran, dass Animation die visuelle Darstellung geändert hat, aber die physikalischen Eigenschaften nicht geändert hat. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/f0/uu/tw/f0uutwhihhopkcfvps8itszyt_a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Android 3.0 wurde das Animator-Framework angezeigt, das korrekter ist, da es die spezifischen physischen Eigenschaften des Objekts geändert hat. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q2/ib/qy/q2ibqywrlcla5cxqpslznxbxxm0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Später erschien ViewPropertyAnimator und jeder versteht den Unterschied zu Animator immer noch nicht wirklich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde erklären. </font><font style="vertical-align: inherit;">Angenommen, Sie müssen die Übersetzung diagonal ausführen - verschieben Sie die Ansicht entlang der x- und y-Achse. </font><font style="vertical-align: inherit;">Höchstwahrscheinlich würden Sie typischen Code schreiben:</font></font><br>
<br>
<pre><code class="java hljs">val animX = ObjectAnimator.ofFloat(view, “translationX”, <span class="hljs-number">100f</span>)<font></font>
val animY = ObjectAnimator.ofFloat(view, “translationY”, <span class="hljs-number">200f</span>)<font></font>
AnimatorSet().apply {<font></font>
    playTogether(animX, animY)<font></font>
    start()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und Sie können es kürzer machen:</font></font><br>
<br>
<pre><code class="java hljs">view.animate().translationX(<span class="hljs-number">100f</span>).translationY(<span class="hljs-number">200f</span>) </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie view.animate () ausführen, starten Sie ViewPropertyAnimator implizit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum wird es benötigt?</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfacher zu lesen und zu pflegen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animation der Stapeloperationen.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem letzten Fall haben wir zwei Eigenschaften geändert. Wenn wir dies über Animatoren tun, werden Animations-Ticks für jeden Animator separat aufgerufen. Das heißt, setTranslationX und setTranslationY werden separat aufgerufen, und View führt Aktualisierungsvorgänge separat aus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Fall von ViewPropertyAnimator erfolgt die Änderung gleichzeitig, sodass aufgrund weniger Vorgänge Einsparungen erzielt werden und die Änderung der Eigenschaften selbst besser optimiert wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können dies mit Animator erreichen, müssen jedoch mehr Code schreiben. </font><font style="vertical-align: inherit;">Darüber hinaus können Sie mit ViewPropertyAnimator sicher sein, dass die Animationen so weit wie möglich optimiert werden. </font><font style="vertical-align: inherit;">Warum? </font><font style="vertical-align: inherit;">Android hat einen RenderNode (DisplayList). </font><font style="vertical-align: inherit;">Sehr grob zwischenspeichern sie das Ergebnis von onDraw und verwenden es beim Neuzeichnen. </font><font style="vertical-align: inherit;">ViewPropertyAnimator arbeitet direkt mit RenderNode zusammen und wendet Animationen darauf an, um OnDraw-Aufrufe zu vermeiden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viele View-Eigenschaften können sich auch direkt auf den RenderNode auswirken, jedoch nicht auf alle. </font><font style="vertical-align: inherit;">Das heißt, wenn Sie ViewPropertyAnimator verwenden, wird garantiert, dass Sie den effizientesten Weg verwenden. </font><font style="vertical-align: inherit;">Wenn Sie plötzlich eine Animation haben, die mit ViewPropertyAnimator nicht mehr möglich ist, sollten Sie vielleicht darüber nachdenken und sie ändern.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animationen: TransitionManager</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Normalerweise assoziieren die Leute, dass dieses Framework verwendet wird, um von einer Aktivität zu einer anderen zu wechseln. Tatsächlich kann es anders verwendet werden und die Implementierung der Animation von Strukturänderungen erheblich vereinfachen. Angenommen, wir haben einen Bildschirm, auf dem eine Sprachnachricht abgespielt wird. Wir schließen es mit einem Kreuz und der Würfel geht hoch. Wie kann man das machen? Die Animation ist ziemlich kompliziert: Der Player schließt mit Alpha, während er sich nicht durch die Übersetzung bewegt, sondern seine Höhe ändert. Gleichzeitig steigt unsere Liste und ändert auch die Höhe. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mv/ff/kh/mvffkhe5udzkypeumimmusvhiig.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Player Teil der Liste wäre, wäre die Animation recht einfach. Bei uns ist der Player jedoch kein Element der Liste, sondern eine völlig unabhängige Ansicht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielleicht würden wir anfangen, eine Art Animator zu schreiben, dann würden wir auf Probleme stoßen, abstürzen, Krücken sägen und den Code verdoppeln. </font><font style="vertical-align: inherit;">Und würde so etwas wie den Bildschirm unten bekommen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wd/0d/k-/wd0dk-urz2lfr6xugvvpmp16rdk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit TransitionManager können Sie alles einfacher machen:</font></font><br>
<br>
<pre><code class="java hljs">TransitionManager.beginDelayedTransition(<font></font>
        viewGroup = &lt;LinearLayoutManager&gt;,<font></font>
        transition = AutoTransition())<font></font>
playerView.visibility = View.GONE</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Animationen erfolgen automatisch unter der Haube. </font><font style="vertical-align: inherit;">Es sieht nach Magie aus, aber wenn Sie tief in das Innere gehen und sehen, wie es funktioniert, stellt sich heraus, dass der TransitionManager einfach alle Ansichten abonniert, die Änderungen in ihren Eigenschaften erfasst, den Diff berechnet, die erforderlichen Animatoren oder ViewPropertyAnimator erstellt und bei Bedarf alles so effizient wie möglich erledigt. </font><font style="vertical-align: inherit;">Mit TransitionManager können wir Animationen im Nachrichtenbereich schnell und einfach implementieren.</font></font><a name="extrodinary"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kundenspezifische Lösungen</font></font></h2><br>
<img src="https://habrastorage.org/webt/u2/rx/ji/u2rxjicmid-zkuhvqsxc4kxbeem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist die grundlegendste Sache, auf der die Leistung und die folgenden Probleme beruhen. Was tun, wenn Ihre Nachricht auf 10 Bildschirmen angezeigt wird? Wenn Sie darauf achten, befinden sich alle unsere Elemente genau untereinander. Wenn wir akzeptieren, dass ViewHolder nicht eine Nachricht ist, sondern Dutzende verschiedener ViewHolder, wird alles viel einfacher. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für uns ist es kein Problem, dass die Nachricht zu 10 Bildschirmen geworden ist, da jetzt nur sechs ViewHolders in einem konkreten Beispiel angezeigt werden. Wir haben ein einfaches Layout, der Code ist einfacher zu pflegen und es gibt keine besonderen Probleme, außer einem - wie geht das?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ho/gh/ui/hoghuifbuntyzu3uszyjr6vij_0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt einfache ViewHolders - dies sind klassische Datumstrennzeichen, Mehr laden und so weiter. </font><font style="vertical-align: inherit;">Und BaseViewHolder - bedingt grundlegender ViewHolder für die Nachricht. </font><font style="vertical-align: inherit;">Es hat eine grundlegende Implementierung und mehrere spezifische - TextViewHolder, PhotoViewHolder, AudioViewHolder, ReplyViewHolder und so weiter. </font><font style="vertical-align: inherit;">Es gibt ungefähr 70 von ihnen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wofür ist BaseViewHolder verantwortlich?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BaseViewHolder ist nur für das Zeichnen des Avatars und des gewünschten Blasenstücks sowie der Linie für weitergeleitete Nachrichten verantwortlich - blau links. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6o/yh/ia/6oyhiaag8f94wm6s69vskpv6r4u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die konkrete Implementierung des Inhalts wird bereits von anderen BaseViewHolder-Erben durchgeführt: TextViewHolder zeigt nur Text an, FwdSenderViewHolder - der Autor der weitergeleiteten Nachricht, AudioMsgViewHolder - die Sprachnachricht usw. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/th/wi/sdthwihnbm9jm4xehrbh4mmrv20.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt ein Problem: Was tun mit der Breite? Stellen Sie sich eine Nachricht auf mindestens zwei Bildschirmen vor. Es ist nicht sehr klar, welche Breite eingestellt werden soll, da die Hälfte sichtbar ist, die Hälfte nicht sichtbar ist (und noch nicht einmal erstellt wurde). Absolut alles kann nicht gemessen werden, weil es liegt. Ich muss leider ein wenig krücken. Es gibt einfache Fälle, in denen die Nachricht sehr einfach ist: Nur Text oder Sprache - besteht im Allgemeinen aus einem Element.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_q/i0/ov/_qi0ovd7qibtvqzcya0tzv_o4vq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie in diesem Fall den klassischen wrap_content. </font><font style="vertical-align: inherit;">In einem komplexen Fall, wenn eine Nachricht aus mehreren Teilen besteht, nehmen wir jedem ViewHolder eine feste Breite und erzwingen sie. </font><font style="vertical-align: inherit;">Speziell hier - 220 dp. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yi/fa/5t/yifa5tx6chfyxf2c26zeak-kaeu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Text sehr kurz ist und die Nachricht weitergeleitet wird, befindet sich rechts ein leeres Feld. </font><font style="vertical-align: inherit;">Dem entgeht nichts, denn Leistung ist wichtiger. </font><font style="vertical-align: inherit;">Mehrere Jahre lang gab es keine Beschwerden - vielleicht hat es jemand bemerkt, aber im Allgemeinen haben sich alle daran gewöhnt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/mz/0l/qbmz0lzz-o_lvhongodanb3fh1m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt Randfälle. </font><font style="vertical-align: inherit;">Wenn wir auf eine Nachricht mit einem Aufkleber antworten, können wir die Breite speziell für einen solchen Fall angeben, damit sie hübscher aussieht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir teilen uns beim Laden von Nachrichten in ViewHolders auf: Wir starten das Laden der Nachricht im Hintergrund, konvertieren sie in ein Element und sie werden direkt in ViewHolders angezeigt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/12/w_/x7/12w_x7wp4a4a4s5f_dqeqrevlbc.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Global RecycledViewPool</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Mechanik der Verwendung unseres Messenger ist so, dass die Leute nicht im selben Chat sitzen, sondern ständig zwischen ihnen wechseln. </font><font style="vertical-align: inherit;">Beim Standardansatz werden der RecycledViewPool (und der darin enthaltene ViewHolder) einfach zerstört, wenn wir in den Chat gegangen sind und ihn verlassen haben, und jedes Mal, wenn wir Ressourcen für die Erstellung des ViewHolder aufwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies kann durch den globalen RecycledViewPool gelöst werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecycledViewPool lebt im Rahmen von Application als Singleton.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf dem Nachrichtenbildschirm wiederverwendet, wenn der Benutzer zwischen den Bildschirmen wechselt;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als RecyclerView.setRecycledViewPool (Pool) festlegen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt Fallstricke, es ist wichtig, sich an zwei Dinge zu erinnern:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie gehen zum Bildschirm, klicken zurück, beenden. </font><font style="vertical-align: inherit;">Das Problem ist, dass die auf dem Bildschirm angezeigten ViewHolders weggeworfen und nicht in den Pool zurückgegeben werden. </font><font style="vertical-align: inherit;">Dies wird wie folgt behoben:</font></font><br>
<pre><code class="java hljs">LinearLayoutManager.recycleChildrenOnDetach = <span class="hljs-keyword">true</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecycledViewPool unterliegt Einschränkungen: Für jeden ViewType können nicht mehr als fünf ViewHolders gespeichert werden.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn 9 Textansichten auf dem Bildschirm angezeigt werden, werden nur fünf Elemente an den RecycledViewPool zurückgegeben, und der Rest wird weggeworfen. </font><font style="vertical-align: inherit;">Sie können die Größe des RecycledViewPool ändern: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RecycledViewPool.setMaxRecycledViews (viewType, size) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist jedoch traurig, mit den Händen auf jeden ViewType zu schreiben, da Sie Ihren RecycledViewPool schreiben, den Standard erweitern und NoLimit erstellen können. </font><font style="vertical-align: inherit;">Über den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link können</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie die fertige Implementierung herunterladen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DiffUtil ist nicht immer nützlich</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein klassischer Fall: Herunterladen, Abspielen einer Audiospur und einer Sprachnachricht. </font><font style="vertical-align: inherit;">In diesem Fall ruft DiffUtil Spam auf. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ho/3o/lt/ho3oltgo6763hgc65xxel-ccopa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser BaseViewHolder verfügt über eine abstrakte updateUploadProgress-Methode.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseViewHolder</span> : <span class="hljs-title">ViewHolder</span> </span>{<font></font>
    …<font></font>
    <span class="hljs-function">fun <span class="hljs-title">updateUploadProgress</span><span class="hljs-params">(attachId: Int, progress: Float)</span>
    …        
}
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um ein Ereignis auszulösen, müssen wir alle sichtbaren ViewHolder umgehen:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">fun <span class="hljs-title">onUploadProgress</span><span class="hljs-params">(attachId: Int, progress: Float)</span> </span>{<font></font>
    forEachActiveViewHolder {<font></font>
        it.updateUploadProgress(attachId, progress)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist eine einfache Operation. Es ist unwahrscheinlich, dass mehr als zehn ViewHolder auf dem Bildschirm angezeigt werden. </font><font style="vertical-align: inherit;">Ein solcher Ansatz kann grundsätzlich nicht zurückbleiben. </font><font style="vertical-align: inherit;">Wie finde ich sichtbaren ViewHolder? </font><font style="vertical-align: inherit;">Eine naive Implementierung wäre ungefähr so:</font></font><br>
<br>
<pre><code class="java hljs">val firstVisiblePosition = &lt;...&gt;<font></font>
val lastVisiblePosition = &lt;...&gt;<font></font>
<span class="hljs-keyword">for</span> (i in firstVisiblePosition.. lastVisiblePosition) {<font></font>
    val viewHolder = recycler.View.findViewHolderForAdapterPosition(i)<font></font>
    viewHolder.updateUploadProgress(..)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber es gibt ein Problem. </font><font style="vertical-align: inherit;">Der zuvor erwähnte Zwischencache, ItemViewCache, enthält aktive ViewHolders, die einfach nicht auf dem Bildschirm angezeigt werden. </font><font style="vertical-align: inherit;">Der obige Code hat keine Auswirkungen auf sie. </font><font style="vertical-align: inherit;">Auch wir können sie nicht direkt ansprechen. </font><font style="vertical-align: inherit;">Und dann helfen uns Krücken. </font><font style="vertical-align: inherit;">Erstellen Sie ein WeakSet, in dem Links zu ViewHolder gespeichert sind. </font><font style="vertical-align: inherit;">Außerdem reicht es uns, dieses WeakSet einfach zu umgehen.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> : <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">Adapter</span> </span>{<font></font>
    val activeViewHolders = WeakSet&lt;ViewHolder&gt;()<font></font>
        <font></font>
    <span class="hljs-function">fun <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: ViewHolder, position: Int)</span> </span>{<font></font>
        activeViewHolders.add(holder)<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">fun <span class="hljs-title">onViewRecycled</span><span class="hljs-params">(holder: ViewHolder)</span> </span>{<font></font>
        activeViewHolders.remove(holder)<font></font>
    }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ViewHolder-Überlagerung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie das Beispiel von Geschichten. Wenn eine Person zuvor auf eine Geschichte mit einem Aufkleber reagiert hat, haben wir sie folgendermaßen angezeigt: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rc/kd/z1/rckdz16ebmfwftxzfpql2lwmsko.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie sieht ziemlich hässlich aus. Ich wollte es besser machen, weil die Geschichten hell sind und wir dort ein kleines Quadrat haben. Wir wollten so etwas bekommen: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vj/ma/51/vjma51z9m4eqwlhiagc7xvu2kg0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt ein Problem: Unsere Nachricht ist in ViewHolder aufgeteilt, sie befinden sich streng untereinander, aber hier überlappen sie sich. Sofort ist nicht klar, wie dies zu lösen ist. Sie können einen anderen ViewType "Verlauf + Aufkleber" oder "Verlauf + Sprachnachricht" erstellen. Anstelle von 70 ViewType hätten wir also 140 ... Nein, wir müssen uns etwas Bequemeres einfallen lassen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/01/mr/5j/01mr5jqsfdpq_zcq4s3b-vf9pyq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Ihrer Lieblingskrücken in Android fällt Ihnen ein. </font><font style="vertical-align: inherit;">Zum Beispiel haben wir etwas getan, aber Pixel Perfect konvergiert nicht. </font><font style="vertical-align: inherit;">Um dies zu beheben, müssen Sie alles löschen und von Grund auf neu schreiben, aber Faulheit. </font><font style="vertical-align: inherit;">Infolgedessen können wir margin = -2dp (negativ) machen, und jetzt passt alles zusammen. </font><font style="vertical-align: inherit;">Ein solcher Ansatz kann hier jedoch nicht angewendet werden. </font><font style="vertical-align: inherit;">Wenn Sie einen negativen Rand festlegen, wird der Aufkleber verschoben, aber der Platz, den er belegt, bleibt leer. </font><font style="vertical-align: inherit;">Aber wir haben ItemDecoration, wo itemOffset wir eine negative Zahl machen können. </font><font style="vertical-align: inherit;">Und es funktioniert! </font><font style="vertical-align: inherit;">Als Ergebnis erhalten wir die erwartete Überlagerung und gleichzeitig bleibt ein Paradigma bestehen, in dem jeder ViewHolder befreundet ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine schöne Lösung in einer Zeile.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OffsetItemDecoration</span> : <span class="hljs-title">RecyclerViewItemDecoration</span>() </span>{
    <span class="hljs-function">overrride fun <span class="hljs-title">getItemOffsets</span><span class="hljs-params">(offset: Rect, …)</span> </span>{<font></font>
        offset.top = -<span class="hljs-number">100</span>dp<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idlehandler</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist ein Fall mit einem Sternchen, es ist komplex und wird in der Praxis nicht so oft benötigt, aber es ist wichtig, über die Existenz einer solchen Methode Bescheid zu wissen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst erkläre ich Ihnen, wie der Haupt-UiThread-Thread funktioniert. Das allgemeine Schema: Es gibt eine Aufgabenereigniswarteschlange, in der Aufgaben über handler.post festgelegt werden, und eine Endlosschleife, die diese Warteschlange durchläuft. Das heißt, UiThread ist nur während (wahr). Wenn es Aufgaben gibt, führen wir sie aus. Wenn nicht, warten wir, bis sie angezeigt werden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y3/ee/nn/y3eennjezxs29i4lkbvggnqkgjw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserer üblichen Realität ist Handler dafür verantwortlich, Aufgaben in die Warteschlange zu stellen, und Looper umgeht die Warteschlange endlos. </font><font style="vertical-align: inherit;">Es gibt Aufgaben, die für die Benutzeroberfläche nicht sehr wichtig sind. </font><font style="vertical-align: inherit;">Zum Beispiel liest ein Benutzer eine Nachricht - es ist für uns nicht so wichtig, wenn wir sie jetzt oder nach 20 ms auf der Benutzeroberfläche anzeigen. </font><font style="vertical-align: inherit;">Der Benutzer wird den Unterschied nicht bemerken. </font><font style="vertical-align: inherit;">Dann lohnt es sich vielleicht, diese Aufgabe nur dann im Hauptthread auszuführen, wenn sie kostenlos ist? </font><font style="vertical-align: inherit;">Das heißt, es wäre schön zu wissen, wann die Linie awaitNewTask aufgerufen wird. </font><font style="vertical-align: inherit;">In diesem Fall verfügt Looper über einen addIdleHandler, der ausgelöst wird, wenn der Code task.isEmpty ausgelöst wird. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Looper.myQueue (). AddIdleHandler ()</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Und dann sieht die einfachste Implementierung von IdleHandler folgendermaßen aus:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@AnyThread</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdleHandler</span> </span>{
    <span class="hljs-keyword">private</span> val handler = Handler(Looper.getMainLooper())<font></font>
<font></font>
    <span class="hljs-function">fun <span class="hljs-title">post</span><span class="hljs-params">(task: Runnable)</span> </span>{<font></font>
        handler.post {<font></font>
            Looper.myQueue().addIdleHandler {<font></font>
                task.run()<font></font>
                <span class="hljs-keyword">return</span><span class="hljs-meta">@addIdleHandler</span> <span class="hljs-keyword">false</span><font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf die gleiche Weise können Sie einen ehrlichen Kaltstart der Anwendung messen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Emoji</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir verwenden unsere benutzerdefinierten Emoji anstelle von System-Emoji. Hier ist ein Beispiel dafür, wie Emojis in verschiedenen Jahren auf verschiedenen Plattformen aussahen. Das linke und rechte Emoji sind ziemlich nett, aber in der Mitte ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bv/71/m3/bv71m3d7rginefvtev6ogcgwess.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt ein zweites Problem: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dw/-1/nx/dw-1nxxjfpggaxcjo_-idb0ofce.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jede Reihe ist das gleiche Emoji, aber die Emotionen, die sie reproduzieren, sind unterschiedlich. Ich mag das Bild unten rechts am meisten, ich verstehe immer noch nicht, was es bedeutet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt ein Fahrrad von VKontakte. In ~ 2014 haben wir ein Emoji leicht verändert. Vielleicht erinnert sich jemand - "Marshmallow" war. Nach seinem Wechsel begann ein Mini-Aufstand. Natürlich erreichte er nicht das Level „Return the Wall“, aber die Reaktion war ziemlich interessant. Und dies sagt uns, wie wichtig es ist, Emoji zu interpretieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Emojis hergestellt werden: Wir haben eine große Bitmap, in der sie alle in einem großen „Atlas“ zusammengefasst sind. </font><font style="vertical-align: inherit;">Es gibt mehrere davon - unter verschiedenen DPI. </font><font style="vertical-align: inherit;">Und es gibt ein EmojiSpan, das Informationen enthält: Ich zeichne "so und so" Emoji, es befindet sich in so und so einer Bitmap an so und so Ort (x, y). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und es gibt eine ReplacementSpan, mit der Sie unter Span etwas anstelle von Text anzeigen können. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, Sie finden Emoji im Text, umschließen es mit EmojiSpan, und das System zeichnet das gewünschte Emoji anstelle des System-Emoji.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/y5/tq/agy5tq5wl0ys8vbwuqgwhpfeoli.png"><a name="alt"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternativen</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufblasen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jemand könnte sagen, da das Aufblasen langsam ist, warum nicht einfach ein Layout mit Ihren Händen erstellen und das Aufblasen vermeiden. </font><font style="vertical-align: inherit;">Und beschleunigen Sie damit alles, indem Sie den 100500 ViewHolder meiden. </font><font style="vertical-align: inherit;">Es ist eine Täuschung. </font><font style="vertical-align: inherit;">Bevor Sie etwas tun, lohnt es sich, es zu messen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android hat eine Debug-Klasse, es hat startMethodTracing und stopMethodTracing.</font></font><br>
<br>
<pre><code class="java hljs">Debug.startMethodTracing(“trace»)<font></font>
inflate(...)<font></font>
Debug.stopMethodTracing()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise können wir Informationen über die Ausführungszeit eines bestimmten Codeteils sammeln. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ea/hz/wa/eahzwatykq-cflwr2ul3qnwbvq4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wir sehen, dass hier das Aufblasen als solches sogar unsichtbar ist. </font><font style="vertical-align: inherit;">Ein Viertel der Zeit wurde mit dem Laden von Zeichenmaterial verbracht, ein Viertel mit dem Laden von Farben. </font><font style="vertical-align: inherit;">Und nur irgendwo im etc-Teil ist unser Aufblasen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe versucht, das XML-Layout in Code zu übersetzen und etwa 0,5 ms gespeichert. </font><font style="vertical-align: inherit;">Der Anstieg ist in der Tat nicht der beeindruckendste. </font><font style="vertical-align: inherit;">Und der Code ist viel komplizierter geworden. </font><font style="vertical-align: inherit;">Das heißt, das Umschreiben macht nicht viel Sinn.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus werden in der Praxis viele überhaupt nicht auf dieses Problem stoßen, da ein langes Aufblasen normalerweise nur dann auftritt, wenn die Anwendung sehr groß wird. </font><font style="vertical-align: inherit;">In unserer VKontakte-Anwendung gibt es beispielsweise ungefähr 200 bis 300 verschiedene Bildschirme, und das Laden aller Ressourcen stürzt ab. </font><font style="vertical-align: inherit;">Was damit zu tun ist, ist noch unklar. </font><font style="vertical-align: inherit;">Höchstwahrscheinlich müssen Sie Ihren eigenen Ressourcenmanager schreiben.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anko</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anko ist vor kurzem veraltet. </font><font style="vertical-align: inherit;">Wie auch immer, Anko ist keine Magie, sondern einfacher syntaktischer Zucker. </font><font style="vertical-align: inherit;">Es übersetzt alles auf die gleiche Weise in die bedingte neue Ansicht (). </font><font style="vertical-align: inherit;">Daher gibt es keinen Vorteil von Anko.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Litho / Flattern</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum habe ich zwei völlig unabhängige Dinge kombiniert? </font><font style="vertical-align: inherit;">Denn hier geht es nicht um Technologie, sondern um die Komplexität der Migration dorthin. </font><font style="vertical-align: inherit;">Sie können nicht einfach ausleihen und in eine neue Bibliothek wechseln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist unklar, ob dies uns zu einer Leistungssteigerung führen wird. </font><font style="vertical-align: inherit;">Und wir werden keine neuen Probleme bekommen, da Millionen von Menschen mit völlig unterschiedlichen Geräten jede Minute unsere Anwendung verwenden (Sie haben wahrscheinlich noch nicht einmal von einem Viertel davon gehört). </font><font style="vertical-align: inherit;">Darüber hinaus sind Nachrichten eine sehr große Codebasis. </font><font style="vertical-align: inherit;">Es ist unmöglich, alles sofort neu zu schreiben. </font><font style="vertical-align: inherit;">Und es wegen des Hype der Technologie zu tun, ist dumm. </font><font style="vertical-align: inherit;">Besonders wenn das Jetpack Compose irgendwo weit weg auftaucht.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetpack komponieren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Google verspricht uns alle Manna vom Himmel in Form dieser Bibliothek, aber es ist immer noch in Alpha. </font><font style="vertical-align: inherit;">Und wann es in der Veröffentlichung sein wird - es ist nicht klar. </font><font style="vertical-align: inherit;">Ob wir es in seiner jetzigen Form bekommen können, ist ebenfalls unklar. </font><font style="vertical-align: inherit;">Zum Experimentieren ist es noch zu früh. </font><font style="vertical-align: inherit;">Lassen Sie es im Stall herauskommen, lassen Sie die Hauptfehler schließen. </font><font style="vertical-align: inherit;">Und nur dann werden wir in seine Richtung schauen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine große benutzerdefinierte Ansicht</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt einen anderen Ansatz, über den diejenigen, die verschiedene Instant Messenger verwenden, sprechen: "Nehmen und schreiben Sie eine große benutzerdefinierte Ansicht, keine komplizierte Hierarchie." </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was sind die Nachteile?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist schwer zu pflegen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der gegenwärtigen Realität macht es keinen Sinn.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Android 4.3 wurde das interne Caching-System in View gepumpt. </font><font style="vertical-align: inherit;">Beispielsweise wird onMeasure nicht aufgerufen, wenn sich die Ansicht nicht geändert hat. </font><font style="vertical-align: inherit;">Und die Ergebnisse der vorherigen Messung werden verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter Android 4.3-4.4 wurde ein RenderNode (DisplayList) angezeigt, der das Rendern zwischenspeichert. </font><font style="vertical-align: inherit;">Schauen wir uns ein Beispiel an. </font><font style="vertical-align: inherit;">Angenommen, die Liste der Dialoge enthält eine Zelle: Avatar, Titel, Untertitel, Lesestatus, Uhrzeit, einen anderen Avatar. </font><font style="vertical-align: inherit;">Bedingt - 10 Elemente. </font><font style="vertical-align: inherit;">Und wir haben Custom View geschrieben. </font><font style="vertical-align: inherit;">In diesem Fall werden beim Ändern einer Eigenschaft alle Elemente neu gemessen. </font><font style="vertical-align: inherit;">Das heißt, geben Sie einfach die zusätzlichen Ressourcen aus. </font><font style="vertical-align: inherit;">Im Fall der ViewGroup, in der jedes Element eine separate Ansicht ist, wird beim Ändern einer Ansicht nur eine Ansicht ungültig (außer wenn diese Ansicht die Größe anderer beeinflusst).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie haben also gelernt, dass wir den klassischen RecyclerView mit Standardoptimierungen verwenden. Es gibt einen Teil von nicht standardmäßigen, bei denen die Aufteilung der Nachricht in ViewHolder am wichtigsten und grundlegendsten ist. Natürlich kann man sagen, dass dies eng anwendbar ist, aber dieser Ansatz kann auch auf andere Dinge projiziert werden, beispielsweise auf einen großen Text von 10.000 Zeichen. Es kann in Absätze unterteilt werden, wobei jeder Absatz ein separater ViewHolder ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es lohnt sich auch, alles auf @WorkerThread zu maximieren: Parsen von Links, DiffUtils - und dabei @UiThead so weit wie möglich entladen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dem globalen RecycledViewPool können Sie zwischen Nachrichtenbildschirmen wechseln und nicht jedes Mal einen ViewHolder erstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber es gibt noch andere wichtige Dinge, die wir noch nicht entschieden haben, zum Beispiel ein langes Aufblasen oder vielmehr das Laden von Daten aus Ressourcen.</font></font><br>
<br>
<blockquote>    ,   Mobius 2019 Piter  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>,     .     ,     ,  SQLite,     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mobius 2020 Piter</a>     .</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de501978/index.html">Wie funktioniert das Prometheus-Histogramm?</a></li>
<li><a href="../de501980/index.html">Die Geschichte eines Projekts oder wie ich 7 Jahre PBX basierend auf Asterisk und Php erstellt habe</a></li>
<li><a href="../de501982/index.html">So übertragen Sie einen Shader von einer Spiel-Engine auf Substance Painter</a></li>
<li><a href="../de501984/index.html">Was gibt es in Quarantäne zu sehen? Eine Auswahl von Materialien aus Technostream (Teil 4)</a></li>
<li><a href="../de501986/index.html">Geheimnisse des unglaublichen Erfolgs von Apple AirPods</a></li>
<li><a href="../de501990/index.html">Nützlicher Beitrag: 4 Ereignisse, um die Probleme des zweiten Tages in OpenShift zu lösen und Operatoren zu erstellen</a></li>
<li><a href="../de501992/index.html">So organisieren Sie Tests, um Produktfreigaben zu beschleunigen und zu stabilisieren. Teil 1</a></li>
<li><a href="../de501994/index.html">Orchestrator für MySQL: Warum kann ein fehlersicheres Projekt ohne es nicht erstellt werden?</a></li>
<li><a href="../de501996/index.html">Zen Go (Taschenversion)</a></li>
<li><a href="../de501998/index.html">Teurer Preis für Stile. Yandex-Bericht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>