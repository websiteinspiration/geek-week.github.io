<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐾 ↩️ 👨🏽‍🚒 Panduan Kompresi Animasi Kerangka 🔊 🧑🏽‍🤝‍🧑🏽 👇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini akan menjadi tinjauan singkat tentang bagaimana menerapkan skema kompresi animasi sederhana dan beberapa konsep terkait. Saya sama sekali ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Panduan Kompresi Animasi Kerangka</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491958/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/o1/6v/gp/o16vgpz4u-9_ntko92qweoxqzx0.png" height="50%" width="50%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ini akan menjadi tinjauan singkat tentang bagaimana menerapkan skema kompresi animasi sederhana dan beberapa konsep terkait. </font><font style="vertical-align: inherit;">Saya sama sekali tidak ahli dalam hal ini, tetapi ada sangat sedikit informasi tentang topik ini, dan itu cukup terfragmentasi. </font><font style="vertical-align: inherit;">Jika Anda ingin membaca artikel yang lebih dalam tentang topik ini, maka saya sarankan Anda pergi ke tautan berikut:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://nfrechette.github.io/2016/10/21/anim_compression_toc/</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://technology.riotgames.com/news/compressing-skeletal-animation-data</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://bitsquid.blogspot.com/2009/11/bitsquid-low-level-animation-system.html</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://bitsquid.blogspot.com/2011/10/low-level-animation-part-2.html</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum kita mulai, ada baiknya memberikan pengantar singkat tentang animasi kerangka dan beberapa konsep dasarnya.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dasar-dasar Animasi dan Kompresi</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Animasi kerangka adalah topik yang cukup sederhana, jika Anda lupa menguliti. Kami memiliki konsep kerangka yang berisi transformasi tulang karakter. Transformasi tulang ini disimpan dalam format hierarkis; pada kenyataannya, mereka disimpan sebagai delta antara posisi global mereka dan posisi orang tua. Terminologi di sini membingungkan, karena dalam mesin permainan lokal sering disebut model / karakter ruang, dan global adalah ruang dunia. Dalam terminologi animasi, lokal disebut sebagai ruang induk tulang, dan global adalah ruang karakter atau ruang dunia, tergantung pada apakah ada pergerakan tulang akar; tapi jangan khawatir tentang itu. Yang penting adalah bahwa transformasi tulang disimpan secara lokal relatif terhadap orang tua mereka. Ini memiliki banyak keuntungan, dan terutama saat pencampuran (blending):jika pencampuran kedua posisi bersifat global, maka keduanya akan diinterpolasi secara linear dalam posisi tersebut, yang akan mengarah pada peningkatan dan penurunan tulang dan deformasi karakter.</font></font><a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan jika Anda menggunakan delta, pencampuran dilakukan dari satu perbedaan ke yang lain, jadi jika transformasi delta untuk satu tulang antara dua pose adalah sama, maka panjang tulang tetap konstan. Saya pikir ini paling mudah (tapi tidak sepenuhnya akurat) untuk mengambilnya dengan cara ini: penggunaan delta mengarah pada gerakan "bola" posisi tulang selama pencampuran, dan pencampuran transformasi global mengarah ke gerakan linear posisi tulang.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Animasi kerangka hanyalah daftar kerangka kunci yang teratur dengan laju bingkai konstan (biasanya). Bingkai kuncinya adalah pose kerangka. Jika kami ingin berpose di antara kerangka kunci, kami mencicipi kerangka kunci kedua dan mencampur di antara mereka, menggunakan sebagian kecil dari waktu di antara mereka sebagai berat campuran. Gambar di bawah ini menunjukkan animasi yang dibuat pada 30fps. Animasi ini memiliki total 5 frame dan kita perlu mendapatkan pose 0,52 s setelah memulai. Oleh karena itu, kita perlu mengambil sampel pose dalam bingkai 1 dan pose dalam bingkai 2, dan kemudian mencampurnya dengan berat campuran sekitar 57%.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/733/f11/c43/733f11c43022b935901e6f20f8a70fab.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh animasi 5 bingkai dan permintaan pose pada waktu frame menengah.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Setelah informasi di atas dan mengingat bahwa memori bukan masalah bagi kami, penghematan urutan pose akan menjadi cara ideal untuk menyimpan animasi, seperti yang ditunjukkan di bawah ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d28/7c5/f3c/d287c5f3cbfd9a8144d20432c3a258dc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penyimpanan data animasi sederhana</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa ini sempurna? Sampling keyframe apa saja datang ke operasi memcpy sederhana. Mengambil sampel pose perantara membutuhkan dua operasi memcpy dan satu operasi mixing. Dari sudut pandang cache, kami menyalin menggunakan memcpy dua blok data secara berurutan, yaitu, setelah menyalin frame pertama, salah satu cache sudah memiliki frame kedua. Anda dapat mengatakan: tunggu, ketika kita melakukan pencampuran, kita perlu mencampur semua tulang; Bagaimana jika kebanyakan dari mereka tidak berubah di antara frame? Bukankah lebih baik menyimpan tulang sebagai catatan dan hanya mencampur transformasi yang berubah? Nah, jika ini diterapkan, maka sedikit lebih banyak cache yang meleset berpotensi terjadi ketika membaca catatan individual, dan kemudian Anda perlu melacak konversi mana yang perlu Anda campur, dan seterusnya ... Mencampur mungkin tampak seperti pekerjaan yang menghabiskan banyak waktu,tetapi pada dasarnya itu adalah aplikasi dari satu instruksi ke dua blok memori yang sudah ada dalam cache. Selain itu, kode pencampuran relatif sederhana, seringkali hanya satu set instruksi SIMD tanpa bercabang, dan prosesor modern akan memprosesnya dalam beberapa saat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah dengan pendekatan ini adalah dibutuhkan sejumlah besar memori, terutama di game di mana kondisi berikut berlaku untuk 95% dari data.</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tulang memiliki panjang yang konstan</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karakter di sebagian besar permainan tidak meregangkan tulang, oleh karena itu, dalam animasi yang sama, catatan transformasi konstan.</font></font></li>
</ul></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami biasanya tidak mengukur tulang.</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skala jarang digunakan dalam animasi game. </font><font style="vertical-align: inherit;">Ini cukup aktif digunakan dalam film dan VFX, tetapi sangat sedikit dalam game. </font><font style="vertical-align: inherit;">Bahkan ketika digunakan, skala yang sama biasanya digunakan.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahkan, di sebagian besar animasi yang saya buat saat runtime, saya mengambil keuntungan dari fakta ini dan menjaga seluruh transformasi tulang dalam 8 variabel float: 4 untuk memutar angka empat, 3 untuk bergerak dan 1 untuk skala. </font><font style="vertical-align: inherit;">Ini secara signifikan mengurangi ukuran pose pada saat run time, memberikan peningkatan produktivitas saat pencampuran dan penyalinan.</font></font></li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan semua ini dalam pikiran, jika Anda melihat format data asli, Anda dapat melihat betapa tidak efisiennya menghabiskan memori. </font><font style="vertical-align: inherit;">Kami menduplikasi nilai perpindahan dan skala masing-masing tulang, bahkan jika mereka tidak berubah. </font><font style="vertical-align: inherit;">Dan situasinya cepat lepas kendali. </font><font style="vertical-align: inherit;">Biasanya, animator membuat animasi pada frekuensi 30fps, dan di game level AAA, karakter biasanya memiliki sekitar 100 tulang. </font><font style="vertical-align: inherit;">Berdasarkan jumlah informasi ini dan format 8 float, kita membutuhkan sekitar 3 KB per pose dan 94 KB per detik animasi sebagai hasilnya. </font><font style="vertical-align: inherit;">Nilai cepat menumpuk dan pada beberapa platform dapat dengan mudah menyumbat semua memori. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi mari kita bicara tentang kompresi; </font><font style="vertical-align: inherit;">Saat mencoba mengompres data, ada beberapa aspek yang perlu dipertimbangkan:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rasio kompresi</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berapa banyak yang kami kelola untuk mengurangi jumlah memori yang digunakan</font></font></li>
</ul></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kualitas</font></font></strong><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berapa banyak informasi yang kami kehilangan dari sumber data</font></font></li>
</ul></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tingkat kompresi</font></font></strong><ul>
<li>     </li>
</ul></li>
<li><strong> </strong><ul>
<li>           .</li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya terutama mementingkan kualitas dan kecepatan, dan kurang memperhatikan memori. Selain itu, saya bekerja dengan animasi game, dan saya dapat mengambil keuntungan dari kenyataan bahwa pada kenyataannya, untuk mengurangi beban pada memori, kita tidak harus menggunakan perpindahan dan skala dalam data. Karena ini, kita dapat menghindari penurunan kualitas yang disebabkan oleh penurunan jumlah bingkai dan solusi lain dengan kerugian. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penting juga untuk dicatat bahwa Anda tidak boleh meremehkan efek kompresi animasi terhadap kinerja: di salah satu proyek saya sebelumnya, laju pengambilan sampel menurun sekitar 35%, dan ada juga beberapa masalah kualitas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat kami mulai bekerja dengan kompresi data animasi, ada dua bidang penting utama yang perlu dipertimbangkan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seberapa cepat kita dapat mengompres elemen-elemen informasi individual dalam bingkai kunci (angka empat, float, dll.).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana kita bisa mengompresi urutan frame kunci untuk menghapus informasi yang berlebihan.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diskritisasi data</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hampir semua bagian ini dapat direduksi menjadi satu prinsip: diskritkan data. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diskretisasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah cara yang sulit untuk mengatakan bahwa kami ingin mengonversi nilai dari interval kontinu ke serangkaian nilai terpisah.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Float Diskretisasi</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika datang ke pengambilan sampel nilai float, kami berusaha untuk mengambil nilai float dan mewakilinya sebagai integer menggunakan bit lebih sedikit. Kuncinya adalah bilangan bulat mungkin tidak benar-benar mewakili nomor sumber, tetapi nilai dalam interval diskrit dipetakan ke interval kontinu. Biasanya pendekatan yang sangat sederhana digunakan. Untuk mencicipi suatu nilai, pertama-tama kita perlu interval untuk nilai aslinya; Setelah menerima interval ini, kami menormalkan nilai awal untuk interval ini. Kemudian nilai normal ini dikalikan dengan nilai maksimum yang mungkin untuk ukuran output yang diinginkan yang diberikan dalam bit. Yaitu, untuk 16 bit kita mengalikan nilainya dengan 65535. Kemudian nilai yang dihasilkan dibulatkan ke bilangan bulat terdekat dan disimpan. Ini jelas ditunjukkan pada gambar:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e73/827/f7be73827067126fd51c0bf6f2396b10.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh pengambilan sampel float 32-bit ke integer 16-bit yang tidak ditandatangani</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Untuk mendapatkan nilai asli lagi, kami cukup melakukan operasi dalam urutan terbalik. Penting untuk dicatat di sini bahwa kita perlu merekam suatu interval awal dari suatu nilai; jika tidak, kami tidak akan dapat men-decode nilai sampel. Jumlah bit dalam nilai sampel menentukan ukuran langkah dalam interval yang dinormalisasi, dan oleh karena itu ukuran langkah dalam interval asli: nilai yang didekodekan akan menjadi kelipatan dari ukuran langkah ini, yang memungkinkan kita untuk dengan mudah menghitung kesalahan maksimum yang terjadi karena proses pengambilan sampel, sehingga kita dapat menentukan jumlah bit diperlukan untuk aplikasi kita.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak akan memberikan contoh kode sumber, karena ada perpustakaan yang cukup nyaman dan sederhana untuk melakukan operasi pengambilan sampel dasar, yang merupakan sumber yang baik tentang topik ini: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/r-lyeh-archived/quant</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (saya akan mengatakan Anda tidak boleh menggunakan fungsi diskretisasi angka empat, tetapi lebih lanjut tentang ini nanti).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompresi Quaternion</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompresi Quaternion adalah topik yang dipelajari dengan baik, jadi saya tidak akan mengulangi apa yang orang lain jelaskan dengan lebih baik. </font><font style="vertical-align: inherit;">Berikut ini tautan ke pos kompresi snapshot yang memberikan deskripsi terbaik tentang topik ini: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://gafferongames.com/post/snapshot_compression/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, saya memiliki sesuatu untuk dikatakan pada topik. </font><font style="vertical-align: inherit;">Posting bitsquid, yang berbicara tentang kompresi angka empat, menyarankan mengompresi angka empat menjadi 32 bit menggunakan sekitar 10 bit data untuk setiap komponen angka empat. </font><font style="vertical-align: inherit;">Inilah yang dilakukan Quant, karena didasarkan pada posting bitsquid. </font><font style="vertical-align: inherit;">Menurut pendapat saya, kompresi seperti itu terlalu hebat dan dalam pengujian saya itu menyebabkan getaran yang kuat. </font><font style="vertical-align: inherit;">Mungkin penulis menggunakan hierarki karakter yang kurang dalam, tetapi jika Anda mengalikan 15 plus angka empat dari contoh animasi saya, kesalahan gabungan tersebut ternyata cukup serius. </font><font style="vertical-align: inherit;">Menurut pendapat saya, </font><font style="vertical-align: inherit;">akurasi minimum </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">absolut</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah 48 bit per angka empat.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perampingan karena pengambilan sampel</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum kita mulai mempertimbangkan berbagai metode kompresi dan pengaturan catatan, mari kita lihat jenis kompresi apa yang kita dapatkan jika kita menerapkan diskretisasi di sirkuit asli. Kami akan menggunakan contoh yang sama seperti sebelumnya (kerangka 100 tulang), jadi jika Anda menggunakan 48 bit (3 x 16 bit) per angka empat, 48 bit (3 × 16) untuk bergerak dan 16 bit untuk skala, maka total untuk konversi kita membutuhkan 14 byte, bukan 32 byte. Ini adalah 43,75% dari ukuran aslinya. Artinya, untuk 1 detik animasi dengan frekuensi 30FPS, kami mengurangi volume dari sekitar 94 KB menjadi sekitar 41 KB.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini tidak buruk sama sekali, diskritisasi adalah operasi yang relatif murah, sehingga ini tidak akan terlalu banyak mempengaruhi waktu pembongkaran. </font><font style="vertical-align: inherit;">Kami menemukan titik awal yang baik untuk memulai, dan dalam beberapa kasus ini bahkan akan cukup untuk menerapkan animasi dalam anggaran sumber daya dan memastikan kualitas dan kinerja yang sangat baik.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rekam kompresi</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya menjadi sangat rumit di sini, terutama ketika pengembang mulai mencoba teknik seperti mengurangi bingkai kunci, pemasangan kurva, dll. </font><font style="vertical-align: inherit;">Juga pada tahap ini kami benar-benar mulai mengurangi kualitas animasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hampir semua keputusan seperti itu, diasumsikan bahwa karakteristik setiap tulang (rotasi, perpindahan, dan skala) disimpan sebagai catatan terpisah. </font><font style="vertical-align: inherit;">Karena itu, kita dapat membalik sirkuit, seperti yang saya tunjukkan sebelumnya:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f64/752/16a/f6475216adb6ac795e1737de30aef6af.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menyimpan data tulang sebagai catatan</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Di sini kita hanya menyimpan semua catatan secara berurutan, tetapi juga dapat mengelompokkan semua catatan rotasi, perpindahan, dan skala. Ide dasarnya adalah bahwa kita beralih dari menyimpan data dari setiap pose ke menyimpan catatan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah melakukan ini, kita dapat menggunakan cara lain untuk mengurangi memori yang digunakan. Yang pertama adalah mulai menjatuhkan frame. Catatan: ini tidak memerlukan format rekaman dan metode ini dapat diterapkan dalam skema sebelumnya. Metode ini berfungsi, tetapi menyebabkan hilangnya gerakan kecil dalam animasi, karena kami membuang sebagian besar data. Teknik ini secara aktif digunakan pada PS3, dan kadang-kadang kami harus membungkuk ke frekuensi pengambilan sampel yang sangat rendah, misalnya, hingga 7 frame per detik (biasanya untuk animasi yang tidak terlalu penting). Saya masih memiliki kenangan buruk dari ini, sebagai seorang programmer animasi saya dengan jelas melihat rincian yang hilang dan ekspresif, tetapi jika Anda melihat dari sudut pandang programmer sistem, kita dapat mengatakan bahwa animasi itu "hampir" sama, karena secara umum gerakan itu tetap ada, tetapi pada saat yang sama kita menghemat banyak memori.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita hilangkan pendekatan ini (menurut saya, itu terlalu merusak) dan mempertimbangkan opsi lain yang mungkin. Pendekatan populer lainnya adalah membuat kurva untuk setiap catatan dan melakukan pengurangan bingkai kunci pada kurva, mis. menghapus duplikat keyframe. Dari sudut pandang animasi game, dengan pendekatan ini, rekaman gerakan dan skala dikompresi dengan sempurna, kadang-kadang dikurangi menjadi satu kerangka kunci. Solusi ini tidak merusak, tetapi membutuhkan pembongkaran, karena setiap kali kita perlu mendapatkan transformasi, kita harus menghitung kurva, karena kita tidak bisa lagi hanya pergi ke data dalam memori. Situasi dapat ditingkatkan sedikit jika Anda </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menghitung animasi hanya dalam satu arah.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan menyimpan status sampler dari setiap animasi untuk setiap tulang (yaitu dari mana mendapatkan perhitungan kurva), tetapi Anda harus membayar untuk ini dengan peningkatan memori dan peningkatan signifikan dalam kompleksitas kode. Dalam sistem animasi modern, kita sering tidak memainkan animasi dari awal hingga akhir. Seringkali pada offset waktu tertentu, mereka membuat transisi ke animasi baru berkat hal-hal seperti pencampuran yang disinkronkan atau pencocokan fase. Seringkali kita mengambil sampel secara individu tetapi tidak secara berurutan untuk mengimplementasikan hal-hal seperti mencampurkan membidik / melihat suatu objek, dan seringkali animasi dimainkan dalam urutan terbalik. Oleh karena itu, saya tidak merekomendasikan menggunakan solusi seperti itu, hanya saja tidak sebanding dengan kerumitan yang disebabkan oleh kompleksitas dan potensi bug.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada juga konsep tidak hanya menghapus kunci identik pada kurva, tetapi juga menentukan ambang di mana kunci yang sama dihapus; ini mengarah pada fakta bahwa animasi menjadi lebih pudar, mirip dengan metode menjatuhkan frame, karena hasil akhirnya sama dalam hal data. Skema kompresi animasi sering digunakan, di mana parameter kompresi ditetapkan untuk setiap catatan, dan animator terus-menerus tersiksa dengan nilai-nilai ini, berusaha mempertahankan kualitas dan mengurangi ukuran pada saat yang sama. Ini adalah alur kerja yang menyakitkan dan menegangkan, tetapi perlu jika Anda bekerja dengan memori terbatas dari generasi konsol yang lebih tua. Untungnya, hari ini kami memiliki anggaran memori yang besar dan kami tidak perlu hal-hal buruk seperti itu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua aspek ini diungkapkan dalam tulisan Riot / BitSquid dan Nicholas (lihat tautan di awal artikel saya). Saya tidak akan membicarakannya secara rinci. Sebaliknya, saya akan berbicara tentang apa yang saya putuskan tentang mengompresi catatan ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya ... memutuskan untuk tidak mengompresi catatan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum Anda mulai melambaikan tangan, izinkan saya menjelaskan ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika saya menyimpan data dalam catatan, saya menyimpan data rotasi untuk semua frame. Ketika datang ke gerakan dan skala, saya melacak apakah gerakan dan skala statis selama kompresi, dan jika demikian, saya hanya menyimpan satu nilai per catatan. Yaitu, jika catatan bergerak sepanjang X, tetapi tidak sepanjang Y dan Z, maka saya menyimpan semua nilai memindahkan catatan sepanjang X, tetapi hanya satu nilai memindahkan catatan sepanjang Y dan Z.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Situasi ini muncul untuk sebagian besar tulang di sekitar 95% dari animasi kita, jadi pada akhirnya kita dapat secara signifikan mengurangi memori yang ditempati, benar-benar tanpa kehilangan kualitas. Ini membutuhkan kerja dari sudut pandang pembuatan konten (DCC): kami tidak ingin tulang memiliki sedikit gerakan dan memperbesar alur kerja pembuatan animasi, tetapi manfaat seperti itu sepadan dengan biaya tambahan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh animasi kami, hanya ada dua catatan dengan bergerak dan tidak ada catatan dengan skala. Kemudian untuk 1 detik animasi, volume data berkurang dari 41 KB menjadi 18,6 KB (yaitu, hingga 20% dari volume data asli). Situasi menjadi lebih baik ketika durasi animasi meningkat, kita hanya menghabiskan sumber daya untuk merekam giliran dan gerakan dinamis, dan biaya rekaman statis tetap konstan, yang menghemat lebih banyak dalam animasi yang panjang. Dan kita tidak harus mengalami kehilangan kualitas yang disebabkan oleh pengambilan sampel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan semua informasi ini dalam pikiran, skema data akhir saya terlihat seperti ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f5/347/eb0/9f5347eb09718967ebacbe89d443e992.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh skema data animasi terkompresi (3 frame per record)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Selain itu, saya menyimpan offset di blok data untuk memulai data setiap tulang. </font><font style="vertical-align: inherit;">Ini perlu karena kadang-kadang kita perlu sampel data hanya untuk satu tulang tanpa membaca seluruh pose. </font><font style="vertical-align: inherit;">Ini memberi kami cara cepat untuk langsung mengakses data rekaman. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain data animasi yang disimpan dalam satu blok memori, saya juga memiliki opsi kompresi untuk setiap catatan:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d7/b3d/7a3/4d7b3d7a3f1362c0429d72591268dbce.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh parameter kompresi untuk catatan dari mesin Kruger saya</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
. Parameter ini menyimpan semua data yang saya perlukan untuk mendekode nilai sampel dari setiap catatan. </font><font style="vertical-align: inherit;">Mereka juga memantau catatan statis sehingga saya tahu bagaimana menangani data terkompresi ketika saya menemukan catatan statis saat pengambilan sampel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda juga dapat melihat bahwa diskritisasi untuk setiap record adalah individual: selama kompresi, saya melacak nilai minimum dan maksimum dari setiap karakteristik (misalnya, bergerak di sepanjang X) dari setiap record untuk memastikan bahwa data tersebut diskritisasi dalam interval minimum / maksimum dan menjaga akurasi maksimum. </font><font style="vertical-align: inherit;">Saya tidak berpikir bahwa secara umum dimungkinkan untuk membuat interval pengambilan sampel global tanpa merusak data Anda (ketika nilainya berada di luar interval) dan tanpa membuat kesalahan signifikan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimanapun, inilah ringkasan singkat dari upaya bodoh saya untuk menerapkan kompresi animasi: pada akhirnya, saya hampir menggunakan kompresi.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id491942/index.html">Bagaimana kami menggunakan item2vec untuk merekomendasikan produk serupa</a></li>
<li><a href="../id491944/index.html">Cara menggabungkan dua platform menjadi satu dan tidak menyinggung pengguna. Pengalaman Pengembang Yandex.Kew</a></li>
<li><a href="../id491946/index.html">Hukum pemrograman</a></li>
<li><a href="../id491948/index.html">Token desain dapat berbuat lebih banyak: membuat satu sumber informasi tentang komponen UI</a></li>
<li><a href="../id491956/index.html">Rilis Rust 1.42.0: template slice dan pesan panik yang lebih nyaman</a></li>
<li><a href="../id491960/index.html">Era ketika sulit tersesat</a></li>
<li><a href="../id491962/index.html">Pembunuh VPN. Akses jarak jauh yang tepat ke server pertempuran</a></li>
<li><a href="../id491964/index.html">Eksekusi Kode Jarak Jauh di SMB v3: CVE-2020-0796</a></li>
<li><a href="../id491974/index.html">Coronavirus: mengapa Anda harus bertindak sekarang</a></li>
<li><a href="../id491976/index.html">Kami mengubah ekonomi UNIT menjadi toko atau produksi online</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>