<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📀 👲🏽 👾 Tale of how to make a time machine for a database and accidentally write an exploit 👌🏽 🤶🏿 🌁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, Habr. 
 
 Have you ever wondered how to change the time inside the database? Easy? Well, in some cases, yes, it’s easy - the linux command i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Tale of how to make a time machine for a database and accidentally write an exploit</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503804/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Good day, Habr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Have you ever wondered how to change the time inside the database? </font><font style="vertical-align: inherit;">Easy? </font><font style="vertical-align: inherit;">Well, in some cases, yes, it’s easy - the linux command is date and the point is in the hat. </font><font style="vertical-align: inherit;">And if you need to change the time only inside one instance of the database if there are several of them on the server? </font><font style="vertical-align: inherit;">And for a single database process? </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AND? </font><font style="vertical-align: inherit;">Uh, that's it, my friend, that's the whole point.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Someone will say that this is another sur, not related to reality, which is periodically laid out on Habré. </font><font style="vertical-align: inherit;">But no, the task is quite real and is dictated by production necessity - code testing. </font><font style="vertical-align: inherit;">Although I agree, the test case can be quite exotic - check how the code behaves for a certain date in the future. </font><font style="vertical-align: inherit;">In this article, I will examine in detail how this task was solved, and at the same time capture a little the process of organizing test and dev stands for the Oracle base. </font><font style="vertical-align: inherit;">Ahead of a long reading, get comfortable and ask for a cat.</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Background</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start with a short introduction to show why this is necessary. As already announced, we write tests when implementing edits in the database. The system under which these tests are done was developed at the beginning (or maybe a little before the start) of the zero ones, so all business logic is inside the database and written in the form of stored procedures in the pl / sql language. And yes, it brings us pain and suffering. But this is legacy, and you have to live with it. In the code and the tabular model, it is possible to specify how the parameters inside the system evolve over time, in other words, set the activity from which date and to what date they can be applied. What to go far - the recent change in the VAT rate is a vivid example of this. And so that such changes in the system can be checked in advance,a database with such changes needs to be transferred to a certain date in the future, the code parameters in the tables will become active at the "current moment". And due to the specifics of the supported system, you cannot use mock tests that would simply change the return value of the current system date in the language when the test session starts.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we determined why, then we need to determine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">how the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> goal </font><i><font style="vertical-align: inherit;">is</font></i><font style="vertical-align: inherit;"> achieved. </font><font style="vertical-align: inherit;">To do this, I will make a small retrospective of the options for building test benches for developers and how each test session started.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stone Age</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Once upon a time, when the trees were small, and the mainframes were large, there was only 1 server for development and it was also conducting tests. </font><font style="vertical-align: inherit;">And in principle, all this was enough for everyone ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">640K is enough for everyone!</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cons: for the task of changing the time, it was necessary to involve many related departments - system administrators (doing the time change on the subd server from root), DBMS administrators (doing the database restart), programmers ( it was necessary to notify that a time change would occur, because part of the code stopped working, for example, web tokens previously issued for calling api methods ceased to be valid and this could come as a surprise), testers (testing itself) ... When you return the time to the present everything was repeated in reverse order.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Middle Ages</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Over time, the number of developers in the department grew and at some point 1 server ceased to be enough. Mainly due to the fact that different developers want to change the same pl / sql package and conduct testing for it (even without changing the time). More and more indignation was heard: “How long! Enough tolerating this! Factories to workers, land to peasants! Every programmer has a database! ” However, if you have a few terabytes of product database, and 50-100 developers, then honestly in this form, the requirement is not very real. And still everyone wants the test and dev base not to lag very much behind the sales, both in structure and in the data inside the tables. So there was a separate server for testing, let's call it pre-production. It was built from 2 identical servers,where the sale was made to restore the database from RMAN bucks and it took about 2-2.5 days. After recovery, the database made anonymization of personal and other important data and the load from the test applications was applied to this server (as well as the programmers themselves always worked with the recently restored server). The work with the required server was ensured using the cluster ip-resource supported through corosync (pacemaker). While everyone is working with the active server, on the 2nd node, the database recovery starts again and after 2-3 days they again change places.The work with the required server was ensured using the cluster ip-resource supported through corosync (pacemaker). While everyone is working with the active server, on the 2nd node, the database recovery starts again and after 2-3 days they again change places.The work with the required server was ensured using the cluster ip-resource supported through corosync (pacemaker). While everyone is working with the active server, on the 2nd node, the database recovery starts again and after 2-3 days they again change places.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of the obvious disadvantages: you need 2 servers and 2 times more resources (mainly disk) than prod. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pros: time change operation and testing - it can be performed on the 2nd server, on the main server at this time developers live and go about their business. </font><font style="vertical-align: inherit;">Server change occurs only when the database is ready, and downtime of the test environment is minimal.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The era of scientific and technological progress</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When we switched to the 11g Release 2 database, we read about an interesting technology that Oracle provides under the name CloneDB. The bottom line is that the product database back-ups (there is a directly bit copy of the product data files) are stored on a special server, which then publishes this set of data files via DNFS (direct NFS) to basically any number of servers, and you don’t need to have one on the server the same volume of disks, because the Copy-On-Write approach is implemented: the database uses a network share with data files from the back-up server for reading data in tables, and changes are written to local data files on the dev server itself. Periodically, “zeroing the deadlines” is done for the server so that the local data files do not grow very much and the place does not end. When updating the server, data is also depersonalized in the tables,in this case, all table updates fall into local data files and those tables are read from the local server, all other tables are read over the network.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cons: there are still 2 servers (to ensure smooth updates with minimal downtime for consumers), but now the volume of disks is greatly reduced. To store bucks on an nfs ball, you need 1 more server in size + - as a prod, but the update execution time itself is reduced (especially when using incremental bucks). Networking with an nfs ball noticeably slows down IO read operations. To use the CloneDB technology, the base must be an Enterprise Edition; in our case, we had to carry out the upgrade procedure on test bases each time. Fortunately, test databases are exempted from Oracle licensing policies. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pros: the operation to restore a base from a bakup takes less than 1 day (I don’t remember the exact time).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Change of time: no major changes. </font><font style="vertical-align: inherit;">Although by this time scripts had already been made to change the time on the server and restart the database in order to do this without attracting the </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attention of the orderlies of the</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> administrators.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Era of New History</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to save disk space even more and make data reading offline, we decided to implement our CloneDB version (with flashback and snapshots) using a file system with compression. </font><font style="vertical-align: inherit;">During the preliminary tests, the choice fell on ZFS, although there is no official support for it in the Linux kernel (quote from the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) For comparison, we also looked at BTRFS (b-tree fs), which Oracle is promoting, but the compression ratio was less with the same CPU and RAM consumption in the tests. To enable ZFS support on RHEL5, its own kernel based on UEK (unbreakable enterprise kernel) was built, and on newer axes and kernels you can simply use the ready-made UEK kernel. The implementation of such a test base is also based on the COW mechanism, but at the level of file system snapshots. 2 disk devices are supplied to the server, on one, the zfs pool is made, where through RMAN an additional standby database is made from the sale, and since we use compression, the partition takes up less than production.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The system is installed on the second disk device and the rest is necessary for the server and the database itself to work, for example, partitions for undo and temp. At any time, you can make a snapshot from the zfs pool, which then opens as a separate database. Creating a snapshot takes a couple of seconds. It's magic! And such databases can be tilted in principle quite a lot, if only the server had enough RAM for all instances and the zfs pool size itself (for storing changes in data files during depersonalization and during the life cycle of the database clone). The main time for updating the test base is the operation of data depersonalization, but it also fits in 15-20 minutes. There is significant acceleration.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cons: on the server you can’t change the time simply by translating the system time, because then all database instances running on this server will fall into this time at once. A solution to this problem has been found and will be described in the appropriate section. Looking ahead, I’ll say that it allows you to change the time inside only 1 instance of the database ( </font><i><font style="vertical-align: inherit;">per instance</font></i><font style="vertical-align: inherit;"> time change approach</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) without affecting the rest on the same server. </font><font style="vertical-align: inherit;">And the time on the server itself does not change either. </font><font style="vertical-align: inherit;">This eliminates the need for a root script to change the time on the server. </font><font style="vertical-align: inherit;">Also at this stage, time change automation for instances via Jenkins CI is implemented and users (relatively speaking development teams) who own their booth are given rights to the jobs through which they themselves can change the time, update the booth to the current state with sales, make snapshots and restoration (rollback) of the base to the previously created snapshot.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Era of Recent History</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With the advent of Oracle 12c, a new technology appeared - pluggable databases and, as a result, container databases (cdb). With this technology, within one physical instance, several “virtual” databases can be made that share a common memory area of ​​the instance. Pros: you can save memory for the server (and increase the overall performance of our database, because all the memory that was occupied before, for example, 5 different instances, can be shared for all deployed pdb containers inside cdb, and they will only use it when they really need it, and not as it was in the previous phase, when each instance “blocked” the memory allocated to it for itself and when the activity of one of the clones was low, the memory was not used effectively, in other words, it was idle).The data files of different pdb still lie in the zfs pool, and when deploying clones, they use the same zfs snapshot mech. At this stage, we came close enough to the ability to give almost every developer their own database. Changing the time at this stage does not require a restart of the database and works very accurately only for those processes that need a time change; all other users working with this database are not affected in any way.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Minus: you cannot use the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">per instance</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> time change approach </font><font style="vertical-align: inherit;">from the previous phase, because we have one instance now. However, a solution for this case was found. And it was precisely this that served as the impetus for writing this article. Looking ahead, I will say that it is a time change </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">per process</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> approach </font><font style="vertical-align: inherit;">i.e. in each database process, you can set your own unique time in general.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, a typical testing session immediately after connecting to the database sets the right time at the beginning of its work, conducts tests and returns the time back at the end. Returning the time is necessary for one simple reason: some Oracle database processes do not end when the database client disconnects from the server, these are server processes called shared servers, which, unlike dedicated processes, run when the database server starts and live almost indefinitely (in ideal picture of the world). If you leave the time changed in such a server process, then another connection that will be served in this process will receive the wrong time.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our system, shared servers are used a lot, because up to 11g there was practically no adequate solution for our system to withstand high load (in 11g DRCP appeared - database resident connection pooling). And here's why - in sub there is a limit on the total number of server processes that it can create in both dedicated and shared mode. Dedicated processes are generated more slowly than the database can issue an already ready shared process from the pool of shared processes, which means that when new connections are constantly arriving (especially if the process does some other slow operations), the total number of processes will increase. When the limit of sessions / processes is reached, the database ceases to service new connections and collapse occurs.The transition to the use of a pool of shared processes allowed us to reduce the number of new processes on the server when connecting.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That’s where the review of the technologies for building test databases is completed, and we can finally begin to implement the time-change algorithms for the database itself.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fake per instance approach</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How to change the time inside the database? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first thing that came to mind was to create in a scheme that contains all the business logic code, its own function, which overlaps the language functions that work with time (sysdate, current_date, etc.) and, under certain conditions, begins to give other values, for example, you could set values ​​through the session context at the beginning of the test run. It didn’t work out, the built-in language functions did not overlap with the user ones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then, light virtualization systems (Vserver, OpenVZ) and containerization via docker were tested. It doesn’t work either, they use the same kernel as the host system, which means they use the same system timer values. Falling out again.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And here I am not afraid to come to the rescue of this word, a brilliant invention of the Linux world - redefinition / interception of functions at the stage of dynamic loading of shared objects. It is known to many as tricks with LD_PRELOAD. In the environment variable LD_PRELOAD, you can specify the library that will be loaded before all the others that the process needs, and if this library contains characters with the same name as for example in the standard libc, which will be loaded later, then the symbol import table for the application will look like a function provides our replacement module. And that’s exactly what the </font><i><font style="vertical-align: inherit;">libfaketime</font></i><font style="vertical-align: inherit;"> project library </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which we began to use in order to start the database at a different time separately from the system one. The library misses calls that concern working with the system timer and getting the system time and date. To control how much time moves relative to the current server date or from what point in time the time should go inside the process - everything is controlled by environment variables that must be set together with LD_PRELOAD. To implement the time change, we implemented a job on the Jenkins server, which enters the database server and restarts the DBMS either with or without environment variables set for libfaketime. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An example algorithm for starting a database with a substitution time:</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-built_in">export</span> LD_PRELOAD=/usr/<span class="hljs-built_in">local</span>/lib/faketime/libfaketime.so
<span class="hljs-built_in">export</span> FAKETIME=<span class="hljs-string">"+1d"</span>
<span class="hljs-built_in">export</span> FAKETIME_NO_CACHE=1<font></font>
<font></font>
<span class="hljs-variable">$ORACLE_HOME</span>/bin/sqlplus @/home/oracle/scripts/restart_db.sql
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And if you think up that everything worked right away, then you are deeply mistaken. </font><font style="vertical-align: inherit;">Because, as it turned out, validates those libraries that are loaded into the process when the DBMS starts. </font><font style="vertical-align: inherit;">And in the alertlog, he begins to resent the noticed forgery, while the base does not start. </font><font style="vertical-align: inherit;">Now I don’t remember exactly how to get rid of it, there is some parameter that can disable the execution of sanity-checks at startup.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fake per process approach</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The general idea of ​​changing the time only within 1 process remained the same - use libfaketime. </font><font style="vertical-align: inherit;">We start the database with a library preloaded into it, but set a zero time offset at startup, which is then propagated to all DBMS processes. </font><font style="vertical-align: inherit;">And then, inside the test session, set the environment variable for this process only. </font><font style="vertical-align: inherit;">Pff, business something.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, for those who are familiar with the pl / sql language, the whole doom of this idea is immediately clear. Because the language is very limited and basically suitable for high-level tasks. No system programming can be implemented there. Although some low-level operations (for example, working with a network, working with files) are present in the form of pre-installed system dbms / utl packages. For the entire time I worked with Oracle, I did reverse engineering of pre-installed packages several times, the code of some of them is hidden from the eyes of strangers (they are called wrapped). If you are forbidden to watch something, then the temptation to find out how it is arranged inside only increases. But often, even after the anvrapper, there is not always something to see, because the functions of such packages are implemented as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c interface</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to so-libraries on disk.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In total, we approached one candidate for implementation - technology </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with external procedures</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The library designed in a special way can export methods, which then the Oracle database can call via pl / sql. Seems promising. Only once I met this in Advanced plsql courses, so I remembered very remotely how to cook it. And it means it is necessary to read documentation. I read it - and immediately became depressed. Because the loading of such a custom so-library goes in a separate agent process through a database listener, and communication with this agent goes through dlink. So our idea cried to set an environment variable inside the database process itself. And this is all done for security reasons. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A picture from the documentation that shows how it works:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pu/1h/07/pu1h07d6fvy1wwetq4deujbpnga.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The type of the so / dll library is not so important, but for some reason the picture is only for Windows. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhaps someone noticed here another 1 potential opportunity. Yes, yes, this is Java. Oracle allows you to write stored procedure code not only in plsql, but also in java, which nevertheless are exported the same way as plsql methods. Periodically, I did this, so there should not be a problem with this. But then another pitfall was hidden. Java works with a copy of the environment, and allows you to only get the environment variables that the JVM process had at startup. The built-in JVM inherits the environment variables of the database process, but that’s all. I saw tips on the Internet how to change the readonly map through reflection, but what's the point, because it's still just a copy. That is, the woman was again left with nothing.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, Java is not only valuable fur. Using it, you can spawn processes from within a database process. Although all unsafe operations must be resolved separately through the java grants mechanism, which are done using the dbms_java package. From inside the plsql code, you can get the process pid of the current server process in which the code is running, using the system views v $ session and v $ process. Further we can spawn some child process from our session to do something with this pid. To get started, I simply deduced all the environment variables that are inside the database process (to test the hypothesis)</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/sh
</span>
pid=<span class="hljs-variable">$1</span><font></font>
<font></font>
awk <span class="hljs-string">'BEGIN {RS="\0"; ORS="\n"} $0'</span> <span class="hljs-string">"/proc/<span class="hljs-variable">$pid</span>/environ"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well deduced, and then what. It’s still impossible to change the variables in the environ file, this is the data that was transferred to the process when it started and they are read only. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I searched the Internet on stackoverflow "How to change an environment variable in another process." Most of the answers were that it was impossible, but there was one answer that described this opportunity as a substandard and dirty hack. And that answer was </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Albert Einstein</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gdb. The debugger can hook onto any process knowing its pid and execute any function / procedure in it that exists in it as a publicly exported symbol, for example, from some library. In libc, there are functions for working with environment variables, and libc is loaded into any process of the Oracle database (and practically any program on linux).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is how the environment variable is set in a foreign process (you need to call it from root because of the used ptrace):</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/sh
</span>
pid=<span class="hljs-variable">$1</span>
env_name=<span class="hljs-variable">$2</span>
env_val=<span class="hljs-string">"<span class="hljs-variable">$3</span>"</span><font></font>
<font></font>
out=`gdb -q -batch -ex <span class="hljs-string">"attach <span class="hljs-variable">$pid</span>"</span> -ex <span class="hljs-string">'call (int) setenv("'</span><span class="hljs-variable">$env_name</span><span class="hljs-string">'", "'</span><span class="hljs-string">"<span class="hljs-variable">$env_val</span>"</span><span class="hljs-string">'", 1)'</span> -ex <span class="hljs-string">"detach"</span> 2&gt;&amp;1`
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also, to see the environment variables inside the gdb process is also suitable. </font><font style="vertical-align: inherit;">As mentioned earlier, the environ file from / proc / pid / shows only the variables that existed at the start of the process. </font><font style="vertical-align: inherit;">And if the process created something in the course of its work, then this can only be seen through the debugger:</font></font><br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/sh
</span>
pid=<span class="hljs-variable">$1</span>
var_name=<span class="hljs-variable">$2</span><font></font>
<font></font>
var_value=`gdb -q -batch -ex <span class="hljs-string">"attach <span class="hljs-variable">$pid</span>"</span> -ex <span class="hljs-string">'call (char*) getenv("'</span><span class="hljs-variable">$var_name</span><span class="hljs-string">'")'</span> -ex <span class="hljs-string">'detach'</span> | egrep <span class="hljs-string">'^\$1 ='</span>`<font></font>
<font></font>
<span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span> == <span class="hljs-string">'$1 = 0x0'</span> ]
<span class="hljs-keyword">then</span>
  <span class="hljs-comment"># variable empty or does not exist</span>
  <span class="hljs-built_in">echo</span> -n
<span class="hljs-keyword">else</span>
  <span class="hljs-comment"># gdb returns $1 = hex_value "string value"</span>
  var_hex=`<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span> | awk <span class="hljs-string">'{print $3}'</span>`<font></font>
  var_value=`<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span> | sed -r -e <span class="hljs-string">'s/^\$1 = '</span><span class="hljs-variable">$var_hex</span><span class="hljs-string">' //;s/^"//;s/"$//'</span>`<font></font>
  <font></font>
  <span class="hljs-built_in">echo</span> -n <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span>
<span class="hljs-keyword">fi</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, the solution is already in our pocket - through java we spawn the debugger process, which goes to the process that generated it and sets the desired environment variable for it and then ends (the Moor has done his job - the Moor can leave). </font><font style="vertical-align: inherit;">But there was a feeling that it was some kind of crutch. </font><font style="vertical-align: inherit;">I wanted something more elegant. </font><font style="vertical-align: inherit;">It would be somehow all the same to force the database process itself to set environment variables without external assault.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An egg in a duck, a duck in a hare ...</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And then someone comes to the rescue, yes, you guessed it right, again Java, namely JNI (java native interface). </font><font style="vertical-align: inherit;">JNI allows you to call native C methods inside the JVM. </font><font style="vertical-align: inherit;">The code is issued in a special way in the form of a shared object of the library, which the JVM then loads, while the methods that were in the library map to the java methods inside the class declared with the native modifier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, ok, we are writing a class (in fact, this is only a workpiece):</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Posix</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">setenv</span><span class="hljs-params">(String key, String value, <span class="hljs-keyword">boolean</span> overwrite)</span></span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> String <span class="hljs-title">getenv</span><span class="hljs-params">(String key)</span></span>;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stub</span><span class="hljs-params">()</span> 
    </span>{<font></font>
        <font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After that, compile it and get the generated h-file of the future library:</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-comment">#  </span><font></font>
javac Posix.java<font></font>
<font></font>
<span class="hljs-comment">#   Posix.h        JNI</span><font></font>
javah Posix<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having received the header file, we write the body for each method:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Posix.h"</span></span><font></font>
<font></font>
<span class="hljs-function">JNIEXPORT jint JNICALL <span class="hljs-title">Java_Posix_setenv</span><span class="hljs-params">(JNIEnv *env, jclass cls, jstring key, jstring value, jboolean overwrite)</span>
</span>{
    <span class="hljs-keyword">char</span>* k = (<span class="hljs-keyword">char</span> *) (*env)-&gt;GetStringUTFChars(env, key, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">char</span>* v = (<span class="hljs-keyword">char</span> *) (*env)-&gt;GetStringUTFChars(env, value, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
    <span class="hljs-keyword">int</span> err = setenv(k, v, overwrite);<font></font>
<font></font>
    (*env)-&gt;ReleaseStringUTFChars(env, key, k);<font></font>
    (*env)-&gt;ReleaseStringUTFChars(env, value, v);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> err;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">JNIEXPORT jstring JNICALL <span class="hljs-title">Java_Posix_getenv</span><span class="hljs-params">(JNIEnv *env, jclass cls, jstring key)</span>
</span>{
    <span class="hljs-keyword">char</span>* k = (<span class="hljs-keyword">char</span> *) (*env)-&gt;GetStringUTFChars(env, key, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">char</span>* v = getenv(k);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> (*env)-&gt;NewStringUTF(env, v);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
and compile the library</font></font><br>
<br>
<pre><code class="bash hljs">gcc -I<span class="hljs-string">"<span class="hljs-variable">$JAVA_HOME</span>/include"</span> -I<span class="hljs-string">"<span class="hljs-variable">$JAVA_HOME</span>/include/linux"</span> -fPIC Posix.c -shared -o libPosix.so -Wl,-soname -Wl,--no-whole-archive<font></font>
<font></font>
strip libPosix.so<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order for Java to load the native library, it must be found by the system ld according to all Linux rules. </font><font style="vertical-align: inherit;">Additionally, Java has a set of properties that contain the paths where the library searches take place. </font><font style="vertical-align: inherit;">The easiest way to work inside Oracle is to put our library in $ ORACLE_HOME / lib. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And after we have created the library, we need to compile the class inside the database and publish it as a plsql package. </font><font style="vertical-align: inherit;">There are 2 options for creating Java classes inside the database:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> load binary class-file via loadjava utility</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compile class code from source using sqlplus</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will use the second method, although they are basically equal. </font><font style="vertical-align: inherit;">For the first case, it was necessary to immediately write all the class code in stage 1, when we received a stub class for the h-file. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To create a class in subd, a special syntax is used:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">REPLACE</span> <span class="hljs-keyword">AND</span> RESOLVE <span class="hljs-keyword">JAVA</span> <span class="hljs-keyword">SOURCE</span> NAMED <span class="hljs-string">"Posix"</span> <span class="hljs-keyword">AS</span><font></font>
...<font></font>
...<font></font>
/<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When the class is created, it needs to be published as plsql methods, and here again the special syntax:</font></font><br>
<br>
<pre><code class="sql hljs">procedure set_env(var_name varchar2, var_value varchar2)<font></font>
is<font></font>
language java name 'Posix.set_env(java.lang.String, java.lang.String)';<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When you try to call potentially unsafe methods inside Java, an execution is raised that says that no java grant has been issued for the user. </font><font style="vertical-align: inherit;">Loading native methods is another unsafe operation, because we inject extraneous code directly into the database process (the same exploit that was announced in the header). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But since the database is test, we give a grant without any concern connecting from sys:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">begin</span>
dbms_java.grant_permission( <span class="hljs-string">'SYSTEM'</span>, <span class="hljs-string">'SYS:java.lang.RuntimePermission'</span>, <span class="hljs-string">'loadLibrary.Posix'</span>, <span class="hljs-string">''</span>);
<span class="hljs-keyword">commit</span>;
<span class="hljs-keyword">end</span>;<font></font>
/<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The system username is the one where I compiled the java code and plsql wrapper package. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is important to note that when loading a library through a call to System.loadLibrary, we omit the lib prefix and the so extension (as described in the documentation) and do not pass any path where to look. There is a similar System.load method that can only load a library using an absolute path. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And then 2 unpleasant surprise awaits us - I landed in the next rabbit hole of Oracle. When issuing a grant, an error occurs with a rather foggy message:</font></font><br>
<br>
<pre><code class="plaintext hljs">ORA-29532: Java call terminated by uncaught Java exception: java.lang.SecurityException: policy table update
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The problem is googled on the Internet and leads to My Oracle Support (aka Metalink). </font><font style="vertical-align: inherit;">Because </font><font style="vertical-align: inherit;">According to the Oracle rules, publishing articles from a metalink is not allowed in open sources, I’ll only mention the document number - 259471.1 (those who have access will be able to read for themselves). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The essence of the problem is that Oracle will not let us just allow the loading of suspicious third-party code into our process. </font><font style="vertical-align: inherit;">Which is logical. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But since the base is test and we are confident in our code, we allow the download without special fears. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fuh, misadventures are all over.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's alive, alive</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With bated breath, I decided to try to breathe life into my Frankenstein. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We start the database with the preloaded libfaketime and 0 offset. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Connect to the database and make a call to the code that simply displays the time before and after changing the environment variable:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">begin</span>
dbms_output.enable(<span class="hljs-number">100000</span>);<font></font>
dbms_java.set_output(100000);<font></font>
dbms_output.put_line('old time: '||to_char(sysdate, 'dd.mm.yyyy hh24:mi:ss'));<font></font>
system.posix.set_env('FAKETIME','+1d');<font></font>
dbms_output.put_line('new time: '||to_char(sysdate, 'dd.mm.yyyy hh24:mi:ss'));<font></font>
<span class="hljs-keyword">end</span>;<font></font>
/<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It works, damn it! </font><font style="vertical-align: inherit;">Honestly, I was expecting some more surprises, such as ORA-600 errors. </font><font style="vertical-align: inherit;">However, the alert had the whole number and the code continued to work. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is important to note that if the connection to the database is done as dedicated, then after the connection is completed, the process will be destroyed and there will be no trace. </font><font style="vertical-align: inherit;">But if we use shared connections, then in this case a ready-made process is allocated from the server pool, we change the time in it through environment variables and when it is disconnected it will remain changed inside the process. </font><font style="vertical-align: inherit;">And when then another database session falls into the same server process, it will receive the wrong time to its considerable surprise. </font><font style="vertical-align: inherit;">Therefore, at the end of the test session, it is better to always return the time back to zero offset.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I hope the story was interesting (and maybe even useful to someone). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Source codes are all available on </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The libfaketime documentation </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">too</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How do you do testing? </font><font style="vertical-align: inherit;">And how do you create dev and test databases in a company?</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonus for those who read to the end</font></font></b>
                        <div class="spoiler_text"><img src="https://habrastorage.org/webt/wd/m1/s9/wdm1s9kk6_kckj-xf5amc_o6wjq.jpeg"><br>
</div>
                    </div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en503782/index.html">How to make an interactive table with a working surface in the form of a circle?</a></li>
<li><a href="../en503786/index.html">Digital representation of analog audio. Brief educational program</a></li>
<li><a href="../en503788/index.html">Dynamic email :: security</a></li>
<li><a href="../en503790/index.html">Permutations. 9th grade. Parity task</a></li>
<li><a href="../en503796/index.html">Making support cheaper, trying not to lose quality</a></li>
<li><a href="../en503812/index.html">Agile pirate and some laws of dialectics</a></li>
<li><a href="../en503826/index.html">Symmetric and asymmetric DDoS protection - what is the difference?</a></li>
<li><a href="../en503830/index.html">Amazon has opened a large shelter for the homeless</a></li>
<li><a href="../en503832/index.html">PostgreSQL recipes: mustach template engine</a></li>
<li><a href="../en503836/index.html">Pros and cons of comment moderation technologies (+ Poll)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>