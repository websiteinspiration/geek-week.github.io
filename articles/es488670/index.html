<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úäüèø üìÆ ‚öΩÔ∏è Acerca de los registros de m√°scara ‚úåÔ∏è üçÄ üíΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El conjunto de instrucciones AVX-512 inclu√≠a ocho llamados registros de m√°scara [1], desde k0 [2] hasta k7 . Son adecuados para su uso con la mayor√≠a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Acerca de los registros de m√°scara</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/488670/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El conjunto de instrucciones AVX-512 inclu√≠a ocho llamados registros de m√°scara [1], desde </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [2] hasta </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k7</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Son adecuados para su uso con la mayor√≠a de las operaciones de ALU y le permiten realizar operaciones de m√°scara en elementos vectoriales con puesta a cero o fusi√≥n de datos en el registro de destino [3], acelerando as√≠ el c√≥digo, lo que requerir√≠a operaciones de fusi√≥n adicionales en el conjunto de instrucciones AVX2 y versiones anteriores . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si lo anterior no es suficiente para convertirte en un seguidor del culto a los registros de m√°scaras, citar√© un extracto del </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo de Wikipedia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que, espero, te ayudar√° finalmente a resolverlo:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mayor√≠a de los comandos AVX-512 pueden usar la m√°scara de operando correspondiente a uno de los 8 registros de m√°scara (k0 - k7). Si el registro de m√°scara se usa como la m√°scara de la operaci√≥n, el registro k0 se comporta de manera diferente que el resto de los registros de m√°scara: en este caso, act√∫a como una constante codificada que indica que la m√°scara no se usa con esta operaci√≥n. Sin embargo, en operaciones aritm√©ticas y l√≥gicas y al escribir valores para enmascarar registros, k0 se comporta como un registro de trabajo normal. En la mayor√≠a de los comandos, los registros de m√°scara se usan como una m√°scara que determina qu√© elementos deben escribirse en el registro de salida. El comportamiento de la m√°scara de operando depende del indicador: si se establece, todos los elementos no seleccionados se restablecer√°n (modo "puesta a cero", </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cero</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), si no, todos los elementos no seleccionados conservan su estado anterior (modo de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fusi√≥n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><i><font style="vertical-align: inherit;">fusi√≥n</font></i><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">El modo de fusi√≥n tiene el mismo efecto que las </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instrucciones de mezcla</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, los registros de m√°scara [4] son ‚Äã‚Äãuna innovaci√≥n importante, pero rara vez se recuerdan en contraste con, por ejemplo, registros de prop√≥sito general ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eax</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rsi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y otros) o registros SIMD ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xmm0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ymm5</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , etc.). </font><font style="vertical-align: inherit;">En las presentaciones de Intel, que muestran los tama√±os de los recursos de microarquitectura, no se mencionan los registros de m√°scara:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xa/ty/eq/xatyeq9cozm0-7xfqmlxg4caffo.png" alt="imagen"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasta donde yo s√©, </font><font style="vertical-align: inherit;">nunca se ha publicado </font><font style="vertical-align: inherit;">informaci√≥n sobre el tama√±o del archivo de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registro f√≠sico</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><i><font style="vertical-align: inherit;">archivo de registro f√≠sico, PRF</font></i><font style="vertical-align: inherit;"> ) de los registros de m√°scara. Ahora lo arreglaremos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilic√© una versi√≥n modificada de la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">herramienta para medir el</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tama√±o del b√∫fer de reordenamiento de comandos ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ROB</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), que fue creado y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descrito por Henry Wong</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [5] (en adelante, simplemente Henry). Usando esta herramienta, calcul√≥ el tama√±o de las estructuras documentadas y no documentadas de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ejecuci√≥n extraordinaria</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en arquitecturas anteriores. Si no ha le√≠do la nota de Henry, det√©ngase y vuelva a leerla. Y mi art√≠culo esperar√°. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno, lee? Por da√±o, aqu√≠ hay un resumen del art√≠culo de Henry:</font></font><br>
<br>
<h2>     ROB</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se insertan varias </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instrucciones</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><i><font style="vertical-align: inherit;">balasto</font></i><font style="vertical-align: inherit;"> entre dos instrucciones de lectura con un error de cach√© [6] </font><font style="vertical-align: inherit;">; su n√∫mero exacto depender√° del recurso del procesador que queramos medir. Si no hay muchos comandos de balasto, ambas fallas de cach√© se procesar√°n en paralelo, por lo que sus retrasos se superponen y el tiempo de ejecuci√≥n total ser√° aproximadamente [7] igual al que tomar√≠a una falla de cach√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, si el n√∫mero de comandos de lastre supera un cierto umbral cr√≠tico, el recurso correspondiente se agotar√° por completo y la ubicaci√≥n de los equipos en el ROB cesar√° antes de que se emita el segundo comando con una falta de cach√©. En este caso, su procesamiento paralelo ser√° imposible y el tiempo total casi duplicar√° el tiempo de una de esas operaciones, lo que se reflejar√° en el gr√°fico como un salto brusco.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, la prueba se escribe para que los equipos usen exactamente una unidad del recurso que se est√° verificando; en este caso, el pico m√°ximo en el gr√°fico indicar√° su volumen total. </font><font style="vertical-align: inherit;">Por lo tanto, los comandos est√°ndar de prop√≥sito general, como regla, usan un registro f√≠sico de registros PRF de prop√≥sito general y, por lo tanto, son ideales para medir el volumen de un recurso dado.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tama√±o del archivo de registro f√≠sico de registros de m√°scara</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En esta prueba, ejecutaremos comandos que escriben el valor para enmascarar registros para averiguar el tama√±o PRF de estos registros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comencemos con una serie de equipos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaddd k1, k2, k3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (se </font><i><font style="vertical-align: inherit;">muestran</font></i><font style="vertical-align: inherit;"> 16 equipos de lastre):</font></font><br>
<br>
<pre><code class="cpp hljs">mov    rcx,QWORD PTR [rcx]  ;    -<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
mov    rdx,QWORD PTR [rdx]  ;    -<font></font>
lfence                      ;      ,    <font></font>
                            ;   <font></font>
;     <span class="hljs-number">16</span> </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada comando </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaddd</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> consume un registro de m√°scara f√≠sica. Si el n√∫mero de comandos de balasto es menor o igual que el n√∫mero de registros de m√°scara, los errores de cach√© se procesar√°n en modo paralelo, de lo contrario, en modo secuencial. Entonces, al cambiar del modo paralelo al serial, deber√≠amos ver un salto brusco en el gr√°fico, lo que indica un aumento en el tiempo de ejecuci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto es exactamente lo que estamos observando: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gu/0u/0s/gu0u0s6phxsglrya170shjhls30.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
echemos un vistazo m√°s de cerca al aumento: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ix/ve/yl/ixveylwsz7jjcbdwnoxcfqynjbu.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
como vemos ahora, el salto </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es </font><i><font style="vertical-align: inherit;">tan agudo</font></i><font style="vertical-align: inherit;"> : con el n√∫mero de comandos de lastre de 130 a 134, la velocidad de ejecuci√≥n toma valores intermedios entre los niveles m√≠nimo y m√°ximo. Henry llama a este comportamiento </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">imperfecto</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; Lo observ√© en muchas de estas pruebas, aunque no en todas. El hecho es que la implementaci√≥n del hardware no siempre permite un agotamiento completo del recurso a medida que se acerca al l√≠mite [8]; en algunos casos esto tiene √©xito, en otros solo faltan algunos equipos hasta un m√°ximo te√≥rico. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este sentido, estamos interesados ‚Äã‚Äãen el pen√∫ltimo punto de ascenso, en el que la velocidad es a√∫n mayor que en el modo lento. Este punto indica el n√∫mero de unidades de recursos disponibles para nosotros, lo que significa que hay al menos tantos registros f√≠sicos. Como puede ver, en este caso es de alrededor de 134. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, SKX </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiene 134 registros f√≠sicos capaces de almacenar valores especulativos (obtenidos con ejecuci√≥n anticipada) de registros de m√°scara</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Henry sugiere que se usen 8 m√°s para almacenar el estado arquitect√≥nico actual de ocho registros de m√°scara, por lo que la cantidad total de su PRF se puede estimar en 142. Esto es ligeramente m√°s peque√±o que el tama√±o de los archivos para registros de prop√≥sito general (180) y registros SIMD (168), pero a√∫n as√≠ bastante (ver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tabla de tama√±os de recursos de ejecuci√≥n extraordinaria</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para otras plataformas). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos que este archivo es lo suficientemente grande como para que en la pr√°ctica no tengamos tiempo para ocuparlo por completo: es dif√≠cil imaginar un c√≥digo real en el que casi el 60% [9] de los comandos escriben [10] para enmascarar registros, es decir, se requerir√° que muchos de ellos agoten este recurso .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øSon estos diferentes archivos de registro?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como debe haber notado, hasta ahora he </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asumido por defecto</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que los PRF de registro de m√°scara son un archivo separado que no se cruza con otros tipos de archivos de registro. Creo que esto se basa muy probablemente en el principio de funcionamiento de los registros de m√°scara y en el hecho de que forman parte de un dominio separado para cambiar el nombre de los registros [11]. Otro argumento a favor de mi suposici√≥n es el hecho de que el tama√±o observado de los registros de m√°scara PRF no coincide con el tama√±o del archivo de registro de prop√≥sito general o el archivo de registro SIMD. En realidad, ¬°podemos tomar y probar esto con una prueba! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta prueba es similar a la anterior, pero ahora los </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comandos kaddd</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se alternar√° con comandos que usan registros de prop√≥sito general o registros SIMD. Si los registros de m√°scara se combinan con el primero o el segundo en el mismo archivo de registro, el salto en el gr√°fico debe indicar el tama√±o del PRF correspondiente. Si los archivos de registro no se fusionan, encontraremos alg√∫n otro l√≠mite, que no ser√° igual al tama√±o de ninguno de los dos archivos de registro, pero ser√° igual, por ejemplo, al tama√±o de ROB. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prueba 29</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , los </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comandos kaddd</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y los comandos de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> escalares se </font><font style="vertical-align: inherit;">alternan </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs">mov    rcx,QWORD PTR [rcx]<font></font>
add    ebx,ebx<font></font>
kaddd  k1,k2,k3<font></font>
add    esi,esi<font></font>
kaddd  k1,k2,k3<font></font>
add    ebx,ebx<font></font>
kaddd  k1,k2,k3<font></font>
add    esi,esi<font></font>
kaddd  k1,k2,k3<font></font>
add    ebx,ebx<font></font>
kaddd  k1,k2,k3<font></font>
add    esi,esi<font></font>
kaddd  k1,k2,k3<font></font>
add    ebx,ebx<font></font>
kaddd  k1,k2,k3<font></font>
mov    rdx,QWORD PTR [rdx]<font></font>
lfence</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observamos el gr√°fico: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vh/ew/hc/vhewhcthcquksk66f8wircsk6n4.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
como puede ver, el n√∫mero de equipos de lastre, que representa el pico, es mayor que el tama√±o de los registros de prop√≥sito general de PRF y los registros de m√°scara. </font><font style="vertical-align: inherit;">De esto concluimos que los registros de m√°scara no est√°n incluidos en el archivo de registro de prop√≥sito general. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, ¬øtal vez est√°n incluidos en el archivo de registro SIMD? </font><font style="vertical-align: inherit;">Despu√©s de todo, los registros de m√°scara est√°n m√°s asociados con los comandos SIMD que con los comandos de prop√≥sito general. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para averiguarlo, usaremos la prueba 35, que es id√©ntica a la prueba 29 con la diferencia de que aqu√≠ los </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comandos kaddd se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alternan con los comandos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vxorps</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">mov    rcx,QWORD PTR [rcx]<font></font>
vxorps ymm0,ymm0,ymm1<font></font>
kaddd  k1,k2,k3<font></font>
vxorps ymm2,ymm2,ymm3<font></font>
kaddd  k1,k2,k3<font></font>
vxorps ymm4,ymm4,ymm5<font></font>
kaddd  k1,k2,k3<font></font>
vxorps ymm6,ymm6,ymm7<font></font>
kaddd  k1,k2,k3<font></font>
vxorps ymm0,ymm0,ymm1<font></font>
kaddd  k1,k2,k3<font></font>
vxorps ymm2,ymm2,ymm3<font></font>
kaddd  k1,k2,k3<font></font>
vxorps ymm4,ymm4,ymm5<font></font>
kaddd  k1,k2,k3<font></font>
mov    rdx,QWORD PTR [rdx]<font></font>
lfence</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gr√°fico: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/66/r4/zj/66r4zjzixtvauqfascucqdqk5tq.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En esta prueba, se observa el mismo comportamiento que en la anterior, por lo que concluimos que los archivos de registro de registros de m√°scara y registros SIMD tambi√©n est√°n separados.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misterio sin resolver</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, en ambas pruebas, el final del pico cae en aproximadamente 212 comandos, mientras que el tama√±o de ROB para esta microarquitectura es 224. ¬øQuiz√°s es solo un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comportamiento imperfecto</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que ya observamos anteriormente? Bueno, verifiquemos esto: compare los resultados de estas dos pruebas con los resultados de la prueba 4, en la que solo los comandos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nop</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se usan como comandos de lastre </font><font style="vertical-align: inherit;">: a excepci√≥n de ROB, no deber√≠an consumir ning√∫n otro recurso. Compare las gr√°ficas de la prueba 4 ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nop</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) y la prueba 29 ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaddd</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y scalar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alternate </font><font style="vertical-align: inherit;">): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ch/1y/re/ch1yream9tyqh6opy8t2343ai0q.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
en la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prueba 4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El comienzo del modo lento cae exactamente en la marca 224 (im√°genes vectoriales, por lo que puede aumentarlas y verlo usted mismo). Resulta que 212 (a partir de este punto, el modo lento comienza cuando se alternan registros de m√°scara con registros generales o registros SIMD): este es el l√≠mite de alg√∫n otro recurso. De hecho, encontramos la misma limitaci√≥n incluso cuando alternamos registros generales y registros SIMD: compare la prueba 4 y la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prueba 21</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (combina la adici√≥n de registros generales y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comandos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SIMD </font><i><font style="vertical-align: inherit;">vxorps</font></i><font style="vertical-align: inherit;"> ): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fg/ha/2r/fgha2rlaljpa5z1qrazmq3eb8am.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
en su </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en con el mismo t√≠tulo ("Misterio sin resolver") Henry describe el mismo efecto, pero a√∫n m√°s pronunciado:</font></font><br>
<blockquote>  ,     AVS  SSE  Sandy Bridge      147 ,       ROB.    (,     ,   AVX-   ,  NOP-),    ,    SSE/AVX,     ,   -   ,        147,        ‚Äì  ,       .</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para m√°s detalles, lo remito al art√≠culo de Henry. </font><font style="vertical-align: inherit;">Observamos un efecto similar, pero menos pronunciado: al menos logramos ocupar el 95% del volumen ROB, pero a√∫n no lo agotamos por completo. </font><font style="vertical-align: inherit;">Quiz√°s ese misterioso grupo com√∫n de registros est√° asociado con el mecanismo de su lanzamiento, por ejemplo, una tabla PRRT [12], que realiza un seguimiento de los registros disponibles para su liberaci√≥n una vez que se completa el comando. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, hablemos sobre algunas caracter√≠sticas m√°s de los registros de m√°scara y verifiquemos si los mecanismos de optimizaci√≥n disponibles para los registros de prop√≥sito general y los registros SIMD son aplicables a ellos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Copia de reemplazo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para fines generales o comandos SIMD, se puede aplicar la llamada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eliminaci√≥n de movimiento</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Con esta optimizaci√≥n, el mecanismo de cambio de nombre del registro permite no ejecutar comandos que copian el valor de un registro a otro, por ejemplo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mov eax</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">edx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vmovdqu ymm1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ymm2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; en cambio </font><font style="vertical-align: inherit;">, el </font><font style="vertical-align: inherit;">registro de </font><i><font style="vertical-align: inherit;">destino</font></i><font style="vertical-align: inherit;"> se reasigna "simplemente" [13] al registro de origen en RAT, lo que le permite hacerlo sin involucrar a ALU. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compruebe si el reemplazo de la copia es aplicable, por ejemplo, al </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comando kmov k1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Primero, mire el gr√°fico de la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prueba 28</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , donde </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kmovd k1 es el</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> equipo de lastre </font><font style="vertical-align: inherit;">,</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<img src="https://habrastorage.org/webt/wc/s3/jc/wcs3jcnzmjp4pffpopov47ybtg4.png" alt="imagen"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este gr√°fico se ve exactamente igual que en la prueba 27 discutida anteriormente con los comandos de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaddd</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Por lo tanto, es razonable suponer que se completan los registros f√≠sicos, a menos que accidentalmente agotemos alg√∫n otro recurso utilizado al reemplazar la copia, que se comporta igual y tiene el mismo tama√±o [14]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encontramos confirmaci√≥n adicional en el sitio web uops.info: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dice</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que todas las variantes del </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comando kmov</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> copy </font><font style="vertical-align: inherit;">entre registros de m√°scara ocupan una microoperaci√≥n ejecutada en el puerto </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si hubiera una copia de reemplazo, no observar√≠amos actividad en los puertos.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De esto concluyo que los comandos de copia que usan registros de m√°scara [15] no se reemplazan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modismos de adicci√≥n</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mejor manera de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> anular el registro de prop√≥sito general en la arquitectura x86 es usar un idioma OR exclusivo (xor): </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xor reg</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reg</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Su acci√≥n se basa en el hecho de que comparar cualquier valor consigo mismo utilizando esta operaci√≥n produce cero. </font><font style="vertical-align: inherit;">Este comando es m√°s corto (toma menos bytes) que el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mov eax</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> m√°s obvio </font><font style="vertical-align: inherit;">, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y tambi√©n m√°s r√°pido, porque el procesador comprende que es un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idioma de reinicio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y realiza el cambio de nombre necesario de los registros [16], lo que elimina la necesidad de ALU y carga de puertos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, este modismo elimina las dependencias de datos: generalmente el resultado del comando </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xor reg1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reg2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depende de los valores en los </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registros reg1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reg2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero en el caso especial cuando reg1 y reg2 contienen el mismo valor, no hay dependencia, ya que para cualquier valor de entrada la salida ser√° cero. Todos los procesadores x86 modernos reconocen este caso especial [17]. Lo mismo es cierto para aquellas versiones del lenguaje xor que usan registros SIMD, es </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decir,</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operaciones </font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">vpxor</font></a></i><font style="vertical-align: inherit;"> en enteros y </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vxorps</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operaciones vxorpd</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en n√∫meros reales. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠, un lector curioso puede preguntar: ¬øfunciona este idioma con </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variantes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> similares </font><font style="vertical-align: inherit;">del </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comando kxor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? Por ejemplo, ¬øse considerar√≠a el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comando kxorb k1, k1, k1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [18] como un idioma de reinicio?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, estas son dos preguntas diferentes, ya que el efecto de usar un idioma de reinicio se compone de dos componentes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejecuci√≥n con retraso cero sin pasar por el m√≥dulo de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ejecuci√≥n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><i><font style="vertical-align: inherit;">eliminaci√≥n de ejecuci√≥n</font></i><font style="vertical-align: inherit;"> )</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminaci√≥n de dependencia</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trataremos cada pregunta por separado.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejecuci√≥n de reemplazo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, ¬øse </font><font style="vertical-align: inherit;">pueden reemplazar los </font><font style="vertical-align: inherit;">comandos con xor, por ejemplo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxorb k1, k1, k1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , reasignando registros sin colocarlos en el m√≥dulo de ejecuci√≥n? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ni siquiera tengo que hacer nada para demostrarlo: toda la informaci√≥n est√° en el sitio web uops.info, ya que realizaron </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una prueba de este tipo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y mostraron que este comando se ejecuta con un retraso de 1 ciclo de reloj y toma una microoperaci√≥n en el puerto </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">De ello se deduce que los modismos xor reset para los registros de m√°scara no funcionan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminaci√≥n de dependencia</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero, ¬øqu√© pasa si los modismos de reinicio con kxor a√∫n eliminan las dependencias de datos, incluso si requieren colocaci√≥n en el m√≥dulo de ejecuci√≥n? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ uops.info no nos ayudar√°. El comando </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tiene un retraso de 1 ciclo de reloj y se ejecuta en un solo puerto ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), por lo tanto, existe una situaci√≥n interesante (?) En la que la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cadena de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comandos </font><i><font style="vertical-align: inherit;">kxor</font></i><font style="vertical-align: inherit;"> se ejecuta a la misma velocidad, independientemente de si hay dependencias entre ellos o no: ancho de banda la habilidad 1 comando / ciclo da la misma disminuci√≥n de rendimiento que el retraso 1 comando / ciclo! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nada, todav√≠a tenemos un par de trucos en stock. La siguiente prueba nos ayudar√° a responder esta pregunta. Incrustar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en una cadena de comandos, en la que cada comando posterior depende del anterior, y el tiempo de ejecuci√≥n total de esta cadena debe ser lo suficientemente grande como para formar un cuello de botella. Si el comando </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no elimina la dependencia, el tiempo total de ejecuci√≥n de la cadena ser√° igual a la suma de los retrasos de sus comandos constituyentes. Si la dependencia desaparece, la cadena se divide en secuencias m√°s cortas, cuyos retrasos se superponen, y luego la velocidad de su ejecuci√≥n estar√° limitada por alg√∫n valor l√≠mite de rendimiento (asociado, por ejemplo, a la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">competencia por los puertos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Esto podr√≠a mostrarse claramente usando el esquema, pero no soy fuerte en esto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todas estas pruebas se pueden encontrar en el </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">banco de</font></a><font style="vertical-align: inherit;"> referencia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uarch</font></font></i><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pero los puntos clave que dar√© a continuaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, mida el tiempo de copia est√°ndar del registro general y viceversa:</font></font><br>
<br>
<pre><code class="cpp hljs">kmovb k0, eax<font></font>
kmovb eax, k0<font></font>
;   <span class="hljs-number">127</span> </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un par de estos comandos se ejecuta [19] en 4 medidas. No se sabe exactamente cu√°nto tiempo pasa en cada una de ellas: 2 medidas o una medida, y 3 medidas en la otra [20]? Sin embargo, para nuestra tarea esto es irrelevante, porque estamos interesados ‚Äã‚Äãen el tiempo total de copiado de un lado a otro. Es de destacar que el ancho de banda de esta secuencia es 1 ciclo de reloj, que es 4 veces m√°s r√°pido que el retraso, ya que cada comando se ejecuta en su propio puerto ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p5</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , respectivamente). Esto significa que podemos separar el efecto del retraso del efecto del ancho de banda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci√≥n, en nuestra cadena, incluimos el comando </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que garantiza que no </font><i><font style="vertical-align: inherit;">dar√°</font></i><font style="vertical-align: inherit;"> lugar a un restablecimiento de may√∫sculas y min√∫sculas:</font></font><br>
<br>
<pre><code class="cpp hljs">kmovb k0, eax<font></font>
kxorb k0, k0, k1<font></font>
kmovb eax, k0<font></font>
;   <span class="hljs-number">127</span> </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sabemos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxorb</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tiene un retraso de 1 ciclo de reloj, el tiempo de ejecuci√≥n total deber√≠a aumentar a 5 ciclos; esto es lo que muestra la prueba (se muestran los resultados de las dos primeras pruebas):</font></font><br>
<br>
<pre><code class="cpp hljs">**   avx512 :  AVX512 **<font></font>
                                       <font></font>
mov  GP  kreg                    <span class="hljs-number">4.00</span>         <span class="hljs-number">1.25</span><font></font>
mov  GP  kreg   + <font></font>
kxorb                              <span class="hljs-number">5.00</span>         <span class="hljs-number">1.57</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y finalmente, la prueba principal:</font></font><br>
<pre><code class="cpp hljs">kmovb k0, eax<font></font>
kxorb k0, k0, k0<font></font>
kmovb eax, k0<font></font>
;   <span class="hljs-number">127</span> </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta vez usamos el comando </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxorb</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con restablecimiento de may√∫sculas y min√∫sculas: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxorb k0, k0, k0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si la dependencia del valor en el registro k0 desaparece, esto significar√° que el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comando kmovb eax, k0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ya no depende del </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comando kmovb k0, eax anterior</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y que la cadena se ha roto y el tiempo total de ejecuci√≥n deber√≠a disminuir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redoble de tambor ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obtuvimos las mismas 5.0 medidas, como en el ejemplo anterior:</font></font><br>
<br>
<pre><code class="cpp hljs">**   avx512 :  AVX512 **<font></font>
                                     <font></font>
mov  GP  kreg                   <span class="hljs-number">4.00</span>         <span class="hljs-number">1.25</span><font></font>
mov  GP  kreg   + <font></font>
kxorb                             <span class="hljs-number">5.00</span>         <span class="hljs-number">1.57</span><font></font>
mov  GP  kreg   + <font></font>
kxorb                             <span class="hljs-number">5.00</span>         <span class="hljs-number">1.57</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La conclusi√≥n preliminar es la siguiente: el procesador no reconoce los modismos de reinicio si se aplican a los registros de m√°scara. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conclusi√≥n, realizaremos otra prueba para asegurarnos de que nuestro razonamiento sea correcto: reemplazamos el </font><font style="vertical-align: inherit;">comando </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con el comando </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kmov</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que, como saben, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siempre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elimina las dependencias:</font></font><br>
<br>
<pre><code class="cpp hljs">kmovb k0, eax<font></font>
kmovb k0, ecx<font></font>
kmovb eax, k0<font></font>
;   <span class="hljs-number">127</span> </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La respuesta final se presenta a continuaci√≥n. </font><font style="vertical-align: inherit;">La √∫ltima prueba es mucho m√°s r√°pida: solo 2 ciclos de reloj y el cuello de botella es el puerto </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p5</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ambos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comandos kmov k, r32</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se ejecutan solo en este puerto):</font></font><br>
<br>
<pre><code class="cpp hljs">**   avx512 :  AVX512 **<font></font>
                                       <font></font>
mov  GP  kreg                   <span class="hljs-number">4.00</span>            <span class="hljs-number">1.25</span><font></font>
mov  GP  kreg   + <font></font>
kxorb                             <span class="hljs-number">5.00</span>            <span class="hljs-number">1.57</span><font></font>
mov  GP  kreg   + <font></font>
kxorb                             <span class="hljs-number">5.00</span>            <span class="hljs-number">1.57</span><font></font>
mov  GP  kreg   + <font></font>
mov  GP                                  <span class="hljs-number">2.00</span>            <span class="hljs-number">0.63</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resulta que nuestra suposici√≥n es correcta.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultados de reproducci√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede reproducir todos los resultados presentados en este art√≠culo usted mismo ejecutando el archivo ejecutable </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">robsize</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en Linux o Windows (bajo WSL). </font><font style="vertical-align: inherit;">Tambi√©n est√°n </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disponibles en el repositorio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , al igual que los </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scripts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para recopilarlos y trazarlos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recomendaciones</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los registros de m√°scara de arquitectura SKX se encuentran en un archivo de registro f√≠sico separado; </font><font style="vertical-align: inherit;">134 de ellos est√°n dise√±ados para almacenar valores especulativos, el n√∫mero total de registros de m√°scara es 142</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este n√∫mero es comparable al tama√±o de otros tipos de archivos de registro, as√≠ como al b√∫fer ROB, y es lo suficientemente grande como para no experimentar una degradaci√≥n del rendimiento cuando se trabaja con registros de m√°scara</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los comandos de copia con registros de m√°scara no se reemplazan</font></font></li>
<li>  [21]               </li>
</ul><br>
<ol>
<li>   <i>k-</i>   <i>kregs</i> ‚Äì  -. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a>,  <i>k</i>     ‚Äì           ¬´¬ª (<i>m</i>)   ¬´¬ª (<i>f</i>). </li>
<li>   (             AVX-512  ),  <i>k0</i> ‚Äì     ,      , ,    .    : <i>k0</i> ‚Äì   ,     ,     ,     <i>k</i>,   SIMD-,     (,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>   AVX-512).    SIMD-  <i>k0</i>    ,                . </li>
<li>        ,        -,        0,  ,          .  , ,    ,  ,  -   -      . </li>
<li>       ¬´ ¬ª,     <i>kreg</i> ‚Äì        (  <i>k0</i>, <i>k1</i>  ..), ‚Äì    ¬´kreg¬ª  ¬´ ¬ª ( ). </li>
<li>H. Wong, <i>Measuring Reorder Buffer Capacity</i>, May, 2013. [Online]. (. , ¬´    ¬ª,  2013. -.) : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">blog.stuffedcow.net/2013/05/measuring-rob-capacity</a></li>
<li>        100  300 .     ,              -    2     50  100 ,     ‚Äì   2,5 (,  2   5 ).     TLB-/               .</li>
<li> ¬´¬ª     .   ,       ,  .            . ,   29       104,    ,    ‚Äì  ,     200.      ,   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a>)    ‚Äì   ,   -           (         ),        . </li>
<li> , , ,                 (<i>register alias table, RAT</i>),      .  RAT  ,     ,        ,        ,       .     RAT      ,                ,    . </li>
<li> 60%   134  224, ..    PRF     ROB.   ,      ROB   224  ,        ,   ,      [10]   60% ,   ROB. ,       -  ,   60%   ,       ROB,    <i></i>.</li>
<li> ,        ,    . ,      (, SIMD-   ),     . [2]</li>
<li>    ,          .  ,   2      2  SIMD- (    ),  4   . </li>
<li>    <i>Physical Register Reclaim Table</i> (   )  <i>Post Retirement Reclaim Table</i> (     ).</li>
<li>        ‚Äì   ,    ¬´  ¬ª, ..   ,        ,        .        ,    .     :       ,       . </li>
<li> ,        ( 7)   ,      PRF         ROB. </li>
<li> ,           ,     ,     .  ,             ( ,  ,      ,       ‚Äì      ). </li>
<li>        RAT  ,           RAT  , ,     . </li>
<li>      <i>xor</i>,              ,  <i>sub reg,reg</i>   <i>sbb reg, reg</i>.     ,      <i>reg</i>  0  -1 (  )     .    ,     <i>reg</i>, ‚Äì     ,            .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>           . </li>
<li> ,      :   <i>kxorb k1, k1, k1</i>   ,        <i>kxorb k1, k2, k2</i>. </li>
<li> ,    ,      <br>
<br>
<pre><code class="cpp hljs">./uarch-bench.sh --test-name=avx512<span class="hljs-comment">/*. </span></code></pre><br>
</li>
<li>  uops.info   <i>kmov r32, k,</i>   <i>kmov k, 32</i>    <i>&lt;= 3</i>.  ,       4 .          1 , ,         3 . </li>
<li>,      xor,      , , -, ,         .  ,    :     ,            . </li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es488660/index.html">¬øEs hora de olvidarse de React y actualizar a Svelte?</a></li>
<li><a href="../es488662/index.html">Extensiones de navegador requeridas por cada desarrollador web</a></li>
<li><a href="../es488664/index.html">Encontrar el kit de herramientas perfecto: analizar plantillas de proyectos de Python populares</a></li>
<li><a href="../es488666/index.html">10 componentes de reacci√≥n para todas las ocasiones</a></li>
<li><a href="../es488668/index.html">Encadenamiento de CI / CD y automatizaci√≥n de Docker</a></li>
<li><a href="../es488672/index.html">Depuraci√≥n de microcontroladores ARM Cortex-M por UART</a></li>
<li><a href="../es488674/index.html">Infograf√≠a con Excel y PowerPoint</a></li>
<li><a href="../es488678/index.html">Grandes apetitos para peque√±os buffers en Node.js</a></li>
<li><a href="../es488682/index.html">¬øC√≥mo probar las habilidades de programaci√≥n de Python? Tareas de Yandex</a></li>
<li><a href="../es488686/index.html">Uso de redes Flowmon para monitorear el rendimiento de aplicaciones distribuidas y bases de datos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>