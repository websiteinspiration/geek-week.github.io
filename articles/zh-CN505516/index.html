<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🏭 🔁 🔮 机器学习：从哪里开始或如何建立第一个模型 ⛄️ 🈚️ 💕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="作为机器学习的首要任务，我们采取一些简单明了的方法，例如，对房屋成本的预测。可以在kaggle网站上找到就绪的数据集。在培训的第一步中，您不应使用包含大量变量的数据集，例如，“房价：高级回归技术”包含80个变量和高级回归，我们将在“美国金县的房屋销售”中使用21个参数。下载数据并分析提供的描述。可用...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>机器学习：从哪里开始或如何建立第一个模型</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505516/"><img src="https://habrastorage.org/webt/cn/mg/fr/cnmgfrvs-ej5ldlqz9cmmdjdcrk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为机器学习的首要任务，我们采取一些简单明了的方法，例如，对房屋成本的预测。可以在kaggle网站上找到就绪的数据集。在培训的第一步中，您不应使用包含大量变量的数据集，例如，“房价：高级回归技术”包含80个变量和高级回归，我们将在“美国金县的房屋销售”中使用21个参数。下载数据并分析提供的描述。可用日期，价格，卧室，浴室数量，总居住面积，层数，景观评估，海景，总体状况评估，等级（建筑和设计评估），地上和地下的面积，建筑年份，最后年份维修，区号，坐标（经度和纬度），有关15个邻居房屋面积的数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们选择了一项任务，并准备开始解决它。该解决方案将包括两个阶段：数据分析和模型构建。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.处理数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们离题并分别注意数据分析的重要性。当前，所有或多或少流行的算法已经以库的形式编写，并且模型的直接构建已简化为几行代码，例如python中sklearn的k个近邻：</font></font><a name="habracut"></a><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> sklearn .neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<font></font>
clf_KNN = KNeighborsClassifier()       <span class="hljs-comment"># </span>
clf_KNN.fit(X_train, Y_train)          <span class="hljs-comment"># </span>
Y_KNN = clf_KNN.predict(X_test)        <span class="hljs-comment">#    </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
只有四行代码才能得到结果。那么困难是什么？困难在于获得非常X_train的数据-馈送到模型输入的数据。建模中众所周知的原理“ garbage in” =“ garbage in”（英语为Garbage in-垃圾输出（GIGO））的工作原理超过100％，并且所获得的机器学习问题解决方案的质量很大程度上取决于处理数据的能力。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在-战斗！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于数据分析，我们将使用大熊猫，对于“肉眼”的理解和评估，我们将使用seaborn的简单图形。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们导入库，读取数据，从数据数组派生几条记录，查看其中的数据类型和遗漏。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代码输出</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<font></font>
df = pd.read_csv(<span class="hljs-string">'…/train.csv'</span>)<font></font>
df.head(<span class="hljs-number">5</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/1q/cy/og/1qcyogx0fmdgtibrhx1l2b5mdty.png"><br>
<br>
<pre><code class="python hljs">df.info()</code></pre><br>
<pre><code class="plaintext hljs">RangeIndex: 21613 entries, 0 to 21612<font></font>
Data columns (total 21 columns):<font></font>
id 21613 non-null int64<font></font>
date 21613 non-null object<font></font>
price 21613 non-null float64<font></font>
bedrooms 21613 non-null int64<font></font>
bathrooms 21613 non-null float64<font></font>
sqft_living 21613 non-null int64<font></font>
sqft_lot 21613 non-null int64<font></font>
floors 21613 non-null float64<font></font>
waterfront 21613 non-null int64<font></font>
view 21613 non-null int64<font></font>
condition 21613 non-null int64<font></font>
grade 21613 non-null int64<font></font>
sqft_above 21613 non-null int64<font></font>
sqft_basement 21613 non-null int64<font></font>
yr_built 21613 non-null int64<font></font>
yr_renovated 21613 non-null int64<font></font>
zipcode 21613 non-null int64<font></font>
lat 21613 non-null float64<font></font>
long 21613 non-null float64<font></font>
sqft_living15 21613 non-null int64<font></font>
sqft_lot15 21613 non-null int64<font></font>
dtypes: float64(5), int64(15), object(1)<font></font>
memory usage: 3.5+ MB</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数据数组由21613条记录组成，数据中没有间隙，并且仅包含1个文本字段日期。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将更详细地处理每个标志，并以最简单的一个标志开始-丢弃ID（不携带有用的信息），邮政编码（房屋所在区域的代码）和坐标（经纬度），因为我们只熟悉机器学习以及正确的地理转换该数据对于新手专家来说太具体了。</font></font><br>
<br>
<pre><code class="python hljs">df=df.drop([<span class="hljs-string">'id'</span>,<span class="hljs-string">'zipcode'</span>,<span class="hljs-string">'lat'</span>,<span class="hljs-string">'long'</span>], axis=<span class="hljs-number">1</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在让我们看一下公告的日期。日期格式设置为YYYYMMDDTT000000，通常也可以从数据集中删除日期格式，但是我们有建造年份（yr_built）和最后维修年份（yr_renovated）字段，它们以年份格式（YYYY）指定，但信息不多。使用公告日期，您可以通过减法将年份转换为年龄（公告年份-施工年份/维修年份）。我们注意到房屋的一部分，维修年份为0，并假设这意味着建筑物没有维修，在确保数据不包含不正确的记录（维修年份少于施工年份）之后，我们将维修年份的零替换为施工年份。</font></font><br>
<br>
<pre><code class="python hljs">df[(df[<span class="hljs-string">'yr_renovated'</span>]&lt;df[<span class="hljs-string">'yr_built'</span>])&amp;df[<span class="hljs-string">'yr_renovated'</span>]!=<span class="hljs-number">0</span>]</code></pre><br>
<img src="https://habrastorage.org/webt/l7/wo/ii/l7woii1rk3buxzexbab2i4uokmq.png"><br>
<br>
<pre><code class="python hljs">df.loc[df[<span class="hljs-string">'yr_renovated'</span>]==<span class="hljs-number">0</span>, [<span class="hljs-string">'yr_renovated'</span>]]=df[<span class="hljs-string">'yr_built'</span>]<font></font>
df[<span class="hljs-string">'yr_built'</span>]=df[<span class="hljs-string">'date'</span>].str[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>].astype(int)-df[<span class="hljs-string">'yr_built'</span>]<font></font>
df[<span class="hljs-string">'yr_renovated'</span>]=df[<span class="hljs-string">'date'</span>].str[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>].astype(int)-df[<span class="hljs-string">'yr_renovated'</span>]<font></font>
df=df.drop(<span class="hljs-string">'date'</span>, axis=<span class="hljs-number">1</span>)<font></font>
df.head(<span class="hljs-number">5</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/4z/za/uw/4zzauwyidq18e0lq_8x5-up5e88.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将使用下一个参数分析价格，并为此使用“箱形图”。胡子框是一种简单方便的图形，显示一维概率分布，或更简单地说，是数据集中。绘制中位数（中心线），上四分位数和下四分位数（框的侧面），具有统计意义的样本的边缘（“胡子”）和异常值（“胡子”后面的点）。从正态分布图（右）很容易理解。该图可让您快速评估大多数数据的位置（50％位于盒子内部），它们的对称性（盒子一侧的中位偏移量和/或“胡子”的长度）以及分散程度-方差（盒子大小，胡子大小和点数-排放）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bi/bh/uw/bibhuwyeeexpszcl7sahfpdo8le.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以在整个阵列中仅建立此特性的分布，但是使用2个轴会更有用-例如，价格和卧室数，这反过来也将显示出标志之间存在联系：</font></font><br>
<br>
<pre><code class="python hljs">sns.boxplot(y=<span class="hljs-string">'price'</span>, data=df)			<span class="hljs-comment"># price</span>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'bedrooms'</span>, data=df)	<span class="hljs-comment">#price &amp; bedrooms</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
价格和卧室数：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/za/oh/ta/zaohtajsfsedoz8lagkzjto-oa0.png"><br>
<br>
<img src="https://habrastorage.org/webt/fn/em/4g/fnem4gwwbubwzkrhi25i4ly3j4k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该图立即显示了价格和卧室数的极高价值（假设有33间卧室的房子！J）。目标属性价格中存在此类值（也称为离群值）通常会导致模型重新训练，因为它们会产生较大的误差，算法会尝试将其最小化。从图中可以看出，大多数（如果计算得出-93.22％）在0-1mn范围内，并且超过200万-仅198个值（0.92％）。您几乎可以轻松摆脱数据集的1％，因此，在调用了217条记录的简单视图之后，先前已按价格对它们进行了排序，我们将看到所需的价格标记965.000万，并删除所有高于此价格的价格。</font></font><br>
<br>
<pre><code class="python hljs">df.sort_values (by=<span class="hljs-string">'price'</span>, ascending=<span class="hljs-literal">False</span>).head(<span class="hljs-number">217</span>) <font></font>
df=df[df[<span class="hljs-string">'price'</span>]&lt;=<span class="hljs-number">1965000</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们考虑一下卧室的标志。</font><font style="vertical-align: inherit;">我们看到13个卧室的房屋= 0，以及一个有33个卧室的房屋的奇怪记录。</font><font style="vertical-align: inherit;">我们将执行与价格相同的操作，从Bedrom（以及浴室）中删除零：</font></font><br>
<br>
<pre><code class="python hljs">df=df[(df[<span class="hljs-string">'bedrooms'</span>]!=<span class="hljs-number">0</span>)&amp;(df[<span class="hljs-string">'bathrooms'</span>]!=<span class="hljs-number">0</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关于有33间卧室的房子-考虑到价格，我们可以假设这是一个错字，而卧室实际上是3个。让我们将这所房子（1620）的居住面积与3卧室房屋的平均居住面积（1798.2）进行比较，这可能是我们的猜测，因此，只需将此值更改为3并再次构建上一个箱形图即可：</font></font><br>
<br>
<pre><code class="python hljs">df.loc[df[<span class="hljs-string">'bedrooms'</span>]==<span class="hljs-number">33</span>,[<span class="hljs-string">'bedrooms'</span>]]=<span class="hljs-number">3</span> 
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'bedrooms'</span>, data=df)</code></pre><br>
<img src="https://habrastorage.org/webt/qi/wd/fs/qiwdfscthapolbucfyjqy-uoggc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，好多了。</font><font style="vertical-align: inherit;">同样，卧室看浴室。</font><font style="vertical-align: inherit;">我们删除了零值，该字段中没有其他极值：</font></font><br>
<br>
<pre><code class="python hljs">sns.boxplot(y=<span class="hljs-string">'bathrooms'</span>, x=<span class="hljs-string">'bedrooms'</span>, data=df)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在sqft_living，楼层，海滨，视图，条件，等级，sqft_living15字段中，所有值或多或少都是真实的，我们不会去碰它们：</font></font><br>
<br>
<pre><code class="python hljs">plt.rcParams[<span class="hljs-string">'figure.figsize'</span>]=<span class="hljs-number">2</span>,<span class="hljs-number">3</span> 			<span class="hljs-comment"># </span>
sns.boxplot(y=<span class="hljs-string">'sqft_living'</span>, data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'floors'</span>,color=<span class="hljs-string">'#2ecc71'</span>, data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'sqft_living15'</span>,color=<span class="hljs-string">'#9b59b6'</span>, data=df) <font></font>
plt.rcParams[<span class="hljs-string">'figure.figsize'</span>]=<span class="hljs-number">4</span>,<span class="hljs-number">4</span>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'waterfront'</span>, data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'view'</span> , data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'condition'</span> , data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'grade'</span> , data=df)</code></pre><br>
<img src="https://habrastorage.org/webt/oq/uw/h8/oquwh8x-cln4tbaz9xrzqyk9szs.png"><br>
<br>
<img src="https://habrastorage.org/webt/yl/ns/bz/ylnsbzq_kx2dtvrvjy8iytxudve.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是对于sqft_lot和sqft_lot15，您需要提出一些建议，并且由于值较大，对数非常适合：</font></font><br>
<br>
<pre><code class="python hljs">df[<span class="hljs-string">'sqft_lot'</span>]=np.log(df[<span class="hljs-string">'sqft_lot'</span>])<font></font>
df[<span class="hljs-string">'sqft_lot15'</span>]=np.log(df[<span class="hljs-string">'sqft_lot15'</span>])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sqft_lot之前和之后：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yr/up/g2/yrupg24jwmfsptci9hf8uaq6wmu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sqft_above和sqft_basement是sqft_living的组成部分，因此我们也不会涉及它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
至此，我们将进行初步分析并看一下相关的热图：</font></font><br>
<br>
<pre><code class="python hljs">sns.heatmap(df.corr(),  cmap = <span class="hljs-string">'viridis'</span>,annot = <span class="hljs-literal">True</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/ny/yi/uq/nyyiuqa9zbilc9l6gqzljfe35xu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在检查了关联图之后，我们发现有时属性之间具有很强的关联性，因此我们删除了一些具有高相关性的属性-sqft_lot15（保留sqft_lot），yr_built（保留yr_renovated），sft_above（保留sqft_living）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样就完成了使用数据的工作，并继续创建模型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.建模</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这一部分中，我们将构建2个模型：线性回归和决策树。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们需要的所有模型都包含在sklearn库中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们将目标变量与其余训练数据分开，还将样本分为训练（70％）和测试（30％，我们将在这些样本上检查模型的工作方式）：</font></font><br>
<br>
<pre><code class="python hljs">Y=df[<span class="hljs-string">'price'</span>]<font></font>
X=df.drop (<span class="hljs-string">'price'</span>,axis=<span class="hljs-number">1</span>) 
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<font></font>
X_train, X_test, Y_train, Y_test  = train_test_split(X, Y, test_size = <span class="hljs-number">0.3</span>, shuffle = <span class="hljs-literal">True</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，从sklearn评估模型，我们上传了3个指标-mean_absolute_error（平均绝对误差），mean_squared_error（标准差），r2_score（确定系数）：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_absolute_error, mean_squared_error, r2_score</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们从线性回归开始：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<font></font>
LR = LinearRegression() 				<span class="hljs-comment"># </span>
LR.fit(X_train, Y_train)				<span class="hljs-comment"># </span>
Y_LR = LR.predict(X_test)				<span class="hljs-comment">#       </span>
<span class="hljs-keyword">print</span> (<span class="hljs-string">'MAE:'</span>, round (mean_absolute_error(Y_test, Y_LR),<span class="hljs-number">3</span>))		<span class="hljs-comment">#</span>
<span class="hljs-keyword">print</span> (<span class="hljs-string">'√MSE:'</span>, round (mean_squared_error(Y_test, Y_LR)**(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>),<span class="hljs-number">3</span>))
<span class="hljs-keyword">print</span> (<span class="hljs-string">'R2_score:'</span>, round (r2_score(Y_test, Y_LR),<span class="hljs-number">3</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MAE：124477.452√MSE175205.645 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
R2得分</font><font style="vertical-align: inherit;">：0.627 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
决策树</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeRegressor<font></font>
TR = DecisionTreeRegressor()				<span class="hljs-comment"># </span>
TR.fit(X_train, Y_train)				<span class="hljs-comment"># </span>
Y_TR=TR.predict(X_test)  				<span class="hljs-comment">#   </span>
<span class="hljs-keyword">print</span> (<span class="hljs-string">'MAE:'</span>, round (mean_absolute_error(Y_test, Y_TR),<span class="hljs-number">3</span>))		<span class="hljs-comment">#</span>
<span class="hljs-keyword">print</span> (<span class="hljs-string">'√MSE:'</span>, round (mean_squared_error(Y_test, Y_TR)**(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>),<span class="hljs-number">3</span>))
<span class="hljs-keyword">print</span> (<span class="hljs-string">'R2_score:'</span>, round (r2_score(Y_test, Y_TR),<span class="hljs-number">3</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MAE：151734.906√MSE220856.721 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
R2_score </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
：0.407 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据这些指标，我们可以得出结论：线性回归显示了最佳结果，因此选择它更合乎逻辑。但是，我们没有询问模型错误包括什么，是否对模型进行了重新训练等。很有可能是重新训练导致了DecisionTreeRegressor结果的恶化，因为我们甚至没有在模型参数中限制树的深度。我们可以通过在短周期内对树的深度进行排序来轻松地检查这一点：</font></font><br>
<br>
<pre><code class="python hljs">dep,score=[],[]
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>,<span class="hljs-number">16</span>):<font></font>
    TR = DecisionTreeRegressor(max_depth=i)<font></font>
    TR.fit(X_train, Y_train)<font></font>
    Y_TR=TR.predict(X_test)<font></font>
    dep.append(i)<font></font>
    score.append(mean_squared_error(Y_test, Y_TR)**(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>))	<span class="hljs-comment">#  √MSE</span>
		plt.rcParams[<span class="hljs-string">'figure.figsize'</span>]=<span class="hljs-number">6</span>,<span class="hljs-number">3</span>
		plt.plot(dep, score)</code></pre><br>
<img src="https://habrastorage.org/webt/ar/fn/yt/arfnytm068lhpknk_ifnpshupgq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
显然，最好的指标是max_depth = 7，再看一下指标（MAE：124861.441，√MSE175322.737，R2_score：0.626），很明显，受此限制的模型类似于质量的线性回归。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们还可以尝试评估哪些属性对于预测成本的模型最重要：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/x1/qx/qw/x1qxqwlhqbfotpp45hhyr4nz0uc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从图中可以看出，等级对成本的影响最大-房地产公司对房屋进行的一般主观评估（顺便指出评估的能力:-)）），第二名是房屋面积，第三名是最后一次维修的年份。指标考虑了卧室，浴室，楼层的数量，该模型被认为对预测不重要。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了更好地理解结果，我们以％为单位计算平均误差-根据线性回归，平均误差为27.5％，也就是说，在预测房屋成本时，该模型比四分之一的误差要大得多。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果可以改善吗？</font><font style="vertical-align: inherit;">是的，当然，在当前阶段，我们仅收到了一个基本的解决方案-比较的起点将是更好或更坏的模型，我们可以使用更复杂的方法或更复杂的数据处理来创建模型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们仅稍微谈及了再培训问题，而根本没有涉及模型错误和模型创建的许多其他方面所包含的内容。</font><font style="vertical-align: inherit;">通常，使用各种模型验证方法来回答这些问题并找到最佳解决方案，但是我们将在以下文章中对此进行介绍。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN505498/index.html">我们如何解决Windows中未初始化的堆栈内存的问题</a></li>
<li><a href="../zh-CN505502/index.html">客户服务中的全渠道：寻找什么以及如何正确地做所有事情？</a></li>
<li><a href="../zh-CN505506/index.html">他不咬人：如何使工业机器人对工人安全</a></li>
<li><a href="../zh-CN505508/index.html">不仅无人技术：汽车行业的未来</a></li>
<li><a href="../zh-CN505510/index.html">使用Python SDK简化Check Point API</a></li>
<li><a href="../zh-CN505522/index.html">在线游戏中的获利：如何利用他人的经验来满足自己的需求</a></li>
<li><a href="../zh-CN505528/index.html">Wi-Fi 6中最重要的事情。</a></li>
<li><a href="../zh-CN505530/index.html">Google制造处理器，AMD准备摧毁高通</a></li>
<li><a href="../zh-CN505532/index.html">有关游戏开发的电报频道：第2部分</a></li>
<li><a href="../zh-CN505536/index.html">如何烹饪电话追踪：青色体验</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>