<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ¥ üôçüèº ‚å®Ô∏è Programmieren einer Videoebene in einem Raspberry Pi mithilfe der DispmanX-API üö£üèª üèáüèª ü§∏üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel m√∂chte ich die Verwendung der DispmanX-API von Raspberry Single Board-Computern demonstrieren. Die DispmanX-API bietet die M√∂glichke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programmieren einer Videoebene in einem Raspberry Pi mithilfe der DispmanX-API</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/493610/"><iframe width="560" height="315" src="https://www.youtube.com/embed/05cqFhJtHaA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel m√∂chte ich die Verwendung der DispmanX-API von Raspberry Single Board-Computern demonstrieren. Die DispmanX-API bietet die M√∂glichkeit, neue gerenderte Ebenen auf dem Raspberry-Desktop zu erstellen. Ebenen h√§ngen √ºber Ebenen. Sie k√∂nnen dynamisch erstellt, gel√∂scht, verschoben und skaliert werden. Gleichzeitig kombiniert der Videocontroller sie und zeigt sie auf dem Monitorbildschirm an. Interessanterweise k√∂nnen die Ebenen einen Alphakanal haben, und dann werden die Bilder aller Ebenen von selbst gemischt. Zus√§tzlich zu 32 Zwei-Bit-ARGB-Layern k√∂nnen Sie beispielsweise YUV420-Layer oder Layer anderer Typen erstellen. Himbeere hat standardm√§√üig bereits zwei Schichten. Das unterste enth√§lt ein Desktop-Image. Alle Ausgaben √ºber das X gehen an diese Ebene. Und es gibt eine zweite, oberste Ebene, in der das Bild des Mauszeigers lebt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde zeigen, wie man eine neue Ebene erstellt, ein Bild hineinschreibt und wie man es auf dem Bildschirm bewegt. Das obige Demo-Video zeigt den Betrieb eines solchen Programms. Hier werden vier neue 32-Bit-ARGB-Ebenen erstellt. In jede der Ebenen schreibe ich Pixel aus vorbereiteten Bitmaps. Meine Bitmaps sind Bilder von Wolken, Sonne und Luftballons. Ebenen bewegen sich mit unterschiedlichen Geschwindigkeiten √ºber den Bildschirm und h√§ngen √ºber der untersten X-Ebene.</font></font><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also die DispmanX-API. Dies ist eine eher niedrige Sache, die f√ºr Raspberry und seine Videocontroller spezifisch ist. Und das ist eine "nicht standardm√§√üige" Sache. Im Allgemeinen haben der Linux-Kernel und das Linux-Grafiksubsystem einen Platz zum Programmieren von Videoebenen √ºber DRM, Direct Rendering Manager, aber aus irgendeinem Grund haben die Entwickler von Raspberry beschlossen, ihr eigenes Fahrrad zu erstellen. Auf der anderen Seite ist dies kein kompliziertes Fahrrad, das durchaus zu fahren ist. DispmanX l√§uft auf Pi-Zero, auf Raspberry Pi / Pi2 / Pi3 und Pi4. Im Allgemeinen auf allen Himbeeren. Obwohl Pi4 in Wahrheit bereits normales OpenGLESv3 hat. Hier werden solche Tamburine m√∂glicherweise nicht mehr ben√∂tigt. Andererseits ist DispmanX viel einfacher (wenn auch weniger Funktionen) als OpenGLES.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um Programme mit dieser DispmanX-API zu schreiben, m√ºssen Sie die Header-Datei /opt/vc/include/bcm_host.h einf√ºgen. </font><font style="vertical-align: inherit;">Dar√ºber hinaus m√ºssen Sie das Programm mit der Bibliothek libbcm_host.so verkn√ºpfen, die sich im Ordner / opt / vc / lib befindet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Funktionen der API, die wir ben√∂tigen, beginnen mit vc_dispmanx_ * ... Um </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
neue Ebenen zu erstellen, m√ºssen Sie zun√§chst mit den folgenden Funktionen auf die Anzeige zugreifen:</font></font><br>
<br>
<pre><code class="cpp hljs">bcm_host_init();<font></font>
DISPMANX_DISPLAY_HANDLE_T display = vc_dispmanx_display_open( <span class="hljs-number">0</span> );
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt k√∂nnen Sie eine ‚ÄûRessource‚Äú erstellen, die das Bild der Ebene enth√§lt:</font></font><br>
<br>
<pre><code class="cpp hljs">VC_IMAGE_TYPE_T type = VC_IMAGE_ARGB8888;
<span class="hljs-keyword">uint32_t</span> UnusedImagePtr;
<span class="hljs-keyword">int</span> SrcImageWidth = <span class="hljs-number">512</span>; <span class="hljs-comment">//image must be 32 bytes aligned size</span>
<span class="hljs-keyword">int</span> SrcImageWidth = <span class="hljs-number">196</span>;<font></font>
DISPMANX_RESOURCE_HANDLE_T resource = vc_dispmanx_resource_create( type, SrcImageWidth, SrcImageHeight,  &amp;UnusedImagePtr );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist der Layertyp 32-Bit mit dem Alpha-Kanal. </font><font style="vertical-align: inherit;">Aber es kann andere Typen geben, wie ich bereits schrieb, sogar YUV. </font><font style="vertical-align: inherit;">Die Verwendung einer YUV-Ebene ist f√ºr dynamische Ebenen sinnvoll, z. B. beim Abspielen eines Videos. </font><font style="vertical-align: inherit;">Dann wird die auf den Bildschirm geschriebene Datenmenge erheblich reduziert, und Sie m√ºssen YUV nicht in RGB umcodieren, wodurch wertvolle Prozessortaktzyklen eingespart werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Erstellen einer neuen Ressource kann der zuvor erhaltene Anzeigehandler verwendet werden, um der Anzeige eine neue Elementebene hinzuzuf√ºgen:</font></font><br>
<br>
<pre><code class="cpp hljs">VC_DISPMANX_ALPHA_T alpha;<font></font>
	alpha.flags =<font></font>
		(DISPMANX_FLAGS_ALPHA_T)(DISPMANX_FLAGS_ALPHA_FROM_SOURCE | DISPMANX_FLAGS_ALPHA_MIX);<font></font>
	alpha.opacity = <span class="hljs-number">255</span>;<font></font>
	alpha.mask = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> OutLayer = <span class="hljs-number">200</span>;<font></font>
DISPMANX_ELEMENT_HANDLE_T vc_element = vc_dispmanx_element_add(<font></font>
		update,<font></font>
		display,<font></font>
		OutLayer,<font></font>
		&amp;dst_rect, resource, &amp;src_rect, DISPMANX_PROTECTION_NONE, &amp;alpha, <span class="hljs-literal">NULL</span>, DISPMANX_NO_ROTATE );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt einen weiteren sehr wichtigen Aktualisierungsparameter. </font><font style="vertical-align: inherit;">Jedes Mal, wenn Sie den Inhalt der Anzeige √§ndern, eine Ebene hinzuf√ºgen oder entfernen oder verschieben oder ein neues Bild in eine Ebene schreiben m√ºssen, m√ºssen Sie den Beginn der √Ñnderungen und das Ende der √Ñnderungen markieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Elemente auf dem Display zu √§ndern, m√ºssen Sie Folgendes tun:</font></font><br>
<br>
<pre><code class="cpp hljs">DISPMANX_UPDATE_HANDLE_T update =  vc_dispmanx_update_start( Priority );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ñndern Sie dann alles, was Sie ben√∂tigen, erstellen Sie eine Ebene oder verschieben Sie sie, schreiben Sie neue Pixel in die Ebene und schlie√üen Sie die √Ñnderungen mit der folgenden Funktion:</font></font><br>
<br>
<pre><code class="cpp hljs">vc_dispmanx_update_submit_sync( update );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie dem Namen der Funktion entnehmen k√∂nnen, werden die √Ñnderungen nach dem n√§chsten Bildimpuls des Videoscans wirksam. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Schreiben von Pixeln in eine Ebene wird durch die folgende Funktion ausgef√ºhrt:</font></font><br>
<br>
<pre><code class="cpp hljs">vc_dispmanx_resource_write_data(<font></font>
		resource,<font></font>
		type,<font></font>
		pitch,<font></font>
		Pixels, <span class="hljs-comment">//pointer to ARGB pixels</span>
		&amp;rect );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider ist es trotz des Vorhandenseins des Parameters rect nicht m√∂glich, ein beliebiges Fragment im Bild zu aktualisieren. </font><font style="vertical-align: inherit;">Es kann nur der ‚ÄûStreifen‚Äú aktualisiert werden, dh der obere und untere Rand des Rechtecks ‚Äã‚Äãk√∂nnen angegeben werden, aber links ist immer 0 und rechts ist immer die Breite des Bildes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seltsamerweise ist dies m√∂glicherweise das gesamte Minimum an Wissen, das zum Manipulieren von Ebenen erforderlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In meinem Programm habe ich einen kleinen Wrapper √ºber die DispmanX-API geschrieben. </font><font style="vertical-align: inherit;">Dadurch kann ich jede Schicht in einer separaten Struktur beschreiben:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DISPMANX_ELEMENT</span> {</span><font></font>
    DISPMANX_RESOURCE_HANDLE_T  res_;<font></font>
    DISPMANX_ELEMENT_HANDLE_T   vc_element_;<font></font>
    VC_IMAGE_TYPE_T type_;<font></font>
    <span class="hljs-keyword">uint32_t</span> src_width_;
    <span class="hljs-keyword">uint32_t</span> src_height_;
    <span class="hljs-keyword">uint32_t</span> dst_layer_;
    <span class="hljs-keyword">uint32_t</span> dst_width_;
    <span class="hljs-keyword">uint32_t</span> dst_height_;
    <span class="hljs-keyword">int32_t</span>  dst_x_;
    <span class="hljs-keyword">int32_t</span>  dst_y_;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, viele meiner Wrapper-Funktionen nehmen einen Zeiger auf eine solche Struktur als Parameter: </font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispmanx_init</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispmanx_element_init</span><span class="hljs-params">(struct DISPMANX_ELEMENT* Element)</span></span>;
<span class="hljs-function">struct DISPMANX_ELEMENT <span class="hljs-title">dispmanx_element_create</span><span class="hljs-params">( VC_IMAGE_TYPE_T type, <span class="hljs-keyword">int</span> SrcW, <span class="hljs-keyword">int</span> SrcH, <span class="hljs-keyword">int</span> OutX, <span class="hljs-keyword">int</span> OutY, <span class="hljs-keyword">int</span> OutW, <span class="hljs-keyword">int</span> OutH, <span class="hljs-keyword">int</span> OutLayer )</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispmanx_element_delete</span><span class="hljs-params">(struct DISPMANX_ELEMENT* Element)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispmanx_element_write</span><span class="hljs-params">(struct DISPMANX_ELEMENT* Element, <span class="hljs-keyword">char</span>* Pixels)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispmanx_element_move</span><span class="hljs-params">( DISPMANX_UPDATE_HANDLE_T update, struct DISPMANX_ELEMENT* Element, <span class="hljs-keyword">int32_t</span> NewX, <span class="hljs-keyword">int32_t</span> NewY )</span></span>;
<span class="hljs-function">DISPMANX_UPDATE_HANDLE_T <span class="hljs-title">dispmanx_start_update</span><span class="hljs-params">( <span class="hljs-keyword">int</span> Priority )</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispmanx_sync</span><span class="hljs-params">( DISPMANX_UPDATE_HANDLE_T Update )</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise kann ich mehrere Ebenen erstellen und diese einfach bearbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe auch eine Funktion zum Lesen einer Bitmap geschrieben. </font><font style="vertical-align: inherit;">Dar√ºber hinaus ist die Funktion schwierig - wenn in der Bitmap ein reines gr√ºnes Pixel 0x00FF00 gefunden wird, betrachte ich es als transparentes Pixel in meinem Bild und setze das Alpha-Byte dieses Pixels entsprechend auf Null. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Farbe habe ich drei Bilder gemalt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wolken: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d2/67/bj/d267bjptz5o4trqey6sl_npz2fm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sonne: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/ni/e6/hxnie6k12u7n5jep_sae5e_z-qu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luftballons: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pw/6h/d1/pw6hd11k8jwwojd2ti_mkgfdzaw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Programm erstellt vier Ebenen. </font><font style="vertical-align: inherit;">Die ersten beiden Ebenen werden aus derselben Bitmap der Wolke erstellt, aber ich mache die Ebenengr√∂√üe unterschiedlich, ich verwende Skalierung, die zweiten Wolken sind gr√∂√üer als die erste. </font><font style="vertical-align: inherit;">Die dritte Schicht sind Luftballons und in der vierten Schicht lade ich die Sonne:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OBJ</span>{</span>
	<span class="hljs-keyword">int</span> width_;
	<span class="hljs-keyword">int</span> height_;
	<span class="hljs-keyword">int</span> x_;
	<span class="hljs-keyword">int</span> y_;
	<span class="hljs-keyword">int</span> layer_;
	<span class="hljs-keyword">int</span> speed_;
	<span class="hljs-keyword">char</span>* pixels_;<font></font>
} OBJ_;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc , <span class="hljs-keyword">char</span> *argv[])</span>
</span>{
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello Raspberry DispmanX API!\n"</span>;<font></font>
	dispmanx_init();<font></font>
<font></font>
	OBJ_ cloud1;<font></font>
	cloud1.pixels_ = LoadBitmap( (<span class="hljs-keyword">char</span>*)<span class="hljs-string">"clouds.bmp"</span>, &amp;cloud1.width_, &amp;cloud1.height_ );<font></font>
	cloud1.layer_ = <span class="hljs-number">100</span>;<font></font>
	cloud1.x_ = <span class="hljs-number">100</span>;<font></font>
	cloud1.y_ = <span class="hljs-number">120</span>;<font></font>
	cloud1.speed_ = <span class="hljs-number">3</span>;<font></font>
<font></font>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DISPMANX_ELEMENT</span> <span class="hljs-title">cloud1_element</span> = <span class="hljs-title">dispmanx_element_create</span>(
		<span class="hljs-title">VC_IMAGE_ARGB8888</span>, <span class="hljs-title">cloud1</span>.<span class="hljs-title">width_</span>, <span class="hljs-title">cloud1</span>.<span class="hljs-title">height_</span>, <span class="hljs-title">cloud1</span>.<span class="hljs-title">x_</span>, <span class="hljs-title">cloud1</span>.<span class="hljs-title">y_</span>, <span class="hljs-title">cloud1</span>.<span class="hljs-title">width_</span>, <span class="hljs-title">cloud1</span>.<span class="hljs-title">height_</span>, <span class="hljs-title">cloud1</span>.<span class="hljs-title">layer_</span> );</span><font></font>
	dispmanx_element_write( &amp;cloud1_element, cloud1.pixels_ );<font></font>
<font></font>
	OBJ_ cloud2;<font></font>
	cloud2.pixels_ = LoadBitmap( (<span class="hljs-keyword">char</span>*)<span class="hljs-string">"clouds.bmp"</span>, &amp;cloud2.width_, &amp;cloud2.height_ );<font></font>
	cloud2.layer_ = <span class="hljs-number">101</span>;<font></font>
	cloud2.x_ = <span class="hljs-number">10</span>;<font></font>
	cloud2.y_ = <span class="hljs-number">230</span>;<font></font>
	cloud2.speed_ = <span class="hljs-number">2</span>;<font></font>
<font></font>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DISPMANX_ELEMENT</span> <span class="hljs-title">cloud2_element</span> = <span class="hljs-title">dispmanx_element_create</span>(
		<span class="hljs-title">VC_IMAGE_ARGB8888</span>, <span class="hljs-title">cloud2</span>.<span class="hljs-title">width_</span>, <span class="hljs-title">cloud2</span>.<span class="hljs-title">height_</span>, <span class="hljs-title">cloud2</span>.<span class="hljs-title">x_</span>, <span class="hljs-title">cloud2</span>.<span class="hljs-title">y_</span>, <span class="hljs-title">cloud2</span>.<span class="hljs-title">width_</span>*1.3, <span class="hljs-title">cloud2</span>.<span class="hljs-title">height_</span>*1.4, <span class="hljs-title">cloud2</span>.<span class="hljs-title">layer_</span> );</span><font></font>
	dispmanx_element_write( &amp;cloud2_element, cloud2.pixels_ );<font></font>
<font></font>
	OBJ_ balls;<font></font>
	balls.pixels_ = LoadBitmap( (<span class="hljs-keyword">char</span>*)<span class="hljs-string">"balls.bmp"</span>, &amp;balls.width_, &amp;balls.height_ );<font></font>
	balls.layer_ = <span class="hljs-number">102</span>;<font></font>
	balls.x_ = <span class="hljs-number">-100</span>;<font></font>
	balls.y_ = <span class="hljs-number">351</span>;<font></font>
	balls.speed_ = <span class="hljs-number">5</span>;<font></font>
<font></font>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DISPMANX_ELEMENT</span> <span class="hljs-title">balls_element</span> = <span class="hljs-title">dispmanx_element_create</span>(
		<span class="hljs-title">VC_IMAGE_ARGB8888</span>, <span class="hljs-title">balls</span>.<span class="hljs-title">width_</span>, <span class="hljs-title">balls</span>.<span class="hljs-title">height_</span>, <span class="hljs-title">balls</span>.<span class="hljs-title">x_</span>, <span class="hljs-title">balls</span>.<span class="hljs-title">y_</span>, <span class="hljs-title">balls</span>.<span class="hljs-title">width_</span>, <span class="hljs-title">balls</span>.<span class="hljs-title">height_</span>, <span class="hljs-title">balls</span>.<span class="hljs-title">layer_</span> );</span><font></font>
	dispmanx_element_write( &amp;balls_element, balls.pixels_ );<font></font>
<font></font>
	OBJ_ sun;<font></font>
	sun.pixels_ = LoadBitmap( (<span class="hljs-keyword">char</span>*)<span class="hljs-string">"sun.bmp"</span>, &amp;sun.width_, &amp;sun.height_ );<font></font>
	sun.layer_ = <span class="hljs-number">99</span>;<font></font>
	sun.x_ = <span class="hljs-number">-250</span>;<font></font>
	sun.y_ = <span class="hljs-number">10</span>;<font></font>
	sun.speed_ = <span class="hljs-number">1</span>;<font></font>
<font></font>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DISPMANX_ELEMENT</span> <span class="hljs-title">sun_element</span> = <span class="hljs-title">dispmanx_element_create</span>(
		<span class="hljs-title">VC_IMAGE_ARGB8888</span>, <span class="hljs-title">sun</span>.<span class="hljs-title">width_</span>, <span class="hljs-title">sun</span>.<span class="hljs-title">height_</span>, <span class="hljs-title">sun</span>.<span class="hljs-title">x_</span>, <span class="hljs-title">sun</span>.<span class="hljs-title">y_</span>, <span class="hljs-title">sun</span>.<span class="hljs-title">width_</span>, <span class="hljs-title">sun</span>.<span class="hljs-title">height_</span>, <span class="hljs-title">sun</span>.<span class="hljs-title">layer_</span> );</span><font></font>
	dispmanx_element_write( &amp;sun_element, sun.pixels_ );<font></font>
.......................<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im ewigen Zyklus bewege ich die Ebenen mit unterschiedlichen Geschwindigkeiten √ºber den Bildschirm:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<font></font>
	{<font></font>
		this_thread::sleep_for( chrono::milliseconds(<span class="hljs-number">20</span>) );<font></font>
		cloud1.x_ += cloud1.speed_;<font></font>
		<span class="hljs-keyword">if</span>( cloud1.x_&gt;= <span class="hljs-number">1920</span> )<font></font>
			cloud1.x_ = <span class="hljs-number">10</span> - cloud1.width_;<font></font>
<font></font>
		cloud2.x_ += cloud2.speed_;<font></font>
		<span class="hljs-keyword">if</span>( cloud2.x_&gt;= <span class="hljs-number">1920</span> )<font></font>
			cloud2.x_ = <span class="hljs-number">133</span> - cloud2.width_;<font></font>
<font></font>
		balls.x_ += balls.speed_;<font></font>
		<span class="hljs-keyword">if</span>( balls.x_&gt;= <span class="hljs-number">1920</span> )<font></font>
			balls.x_ = <span class="hljs-number">200</span> - balls.width_;<font></font>
<font></font>
		sun.x_ += sun.speed_;<font></font>
		<span class="hljs-keyword">if</span>( sun.x_&gt;= <span class="hljs-number">1920</span> )<font></font>
			sun.x_ = <span class="hljs-number">250</span> - sun.width_;<font></font>
<font></font>
		DISPMANX_UPDATE_HANDLE_T update = dispmanx_start_update(<span class="hljs-number">10</span>);<font></font>
		dispmanx_element_move( update, &amp;cloud1_element, cloud1.x_, cloud1.y_ );<font></font>
		dispmanx_element_move( update, &amp;cloud2_element, cloud2.x_, cloud2.y_ );<font></font>
		dispmanx_element_move( update, &amp;balls_element, balls.x_, balls.y_ );<font></font>
		dispmanx_element_move( update, &amp;sun_element,   sun.x_,   sun.y_ );<font></font>
		dispmanx_sync( update );<font></font>
	}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der gesamte Code meines Programms kann auf Github √ºbernommen werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompilieren Sie das Programm auf Himbeere - mit dem Befehl make. </font><font style="vertical-align: inherit;">F√ºhren Sie dann die Befehlszeile aus: ./demo und Sie erhalten das, was Sie oben in der Videodemonstration sehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf Raspberry sehen Sie √ºbrigens eine Liste aller Videoebenen mit dem Befehl vcgencmd mit dem Parameter dispmanx_list. </font><font style="vertical-align: inherit;">Hier ist die Ausgabe dieses Befehls auf Pi4, bevor ich meine Demo starte: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/33/mz/0d/33mz0dtr_honwwqorlt-wori6ie.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie ich geschrieben habe, gibt es bereits zwei Ebenen: eine Ebene f√ºr Xorg und eine Ebene f√ºr eine Maus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und hier ist die Liste der Ebenen nach dem Start meiner Demo:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1i/ln/zy/1ilnzyta7p3l5jcrznrcp8owsjk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist ersichtlich, dass vier neue Ebenen hinzugef√ºgt wurden. </font><font style="vertical-align: inherit;">Ich habe Screenshots im Scrot-Team gemacht. </font><font style="vertical-align: inherit;">Es ist interessant, dass nur die untere x-Ebene erfasst wird. Im Screenshot sind daher weder Wolken noch Luftballons in anderen Ebenen sichtbar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich wei√ü, dass Himbeer-Mikrocomputer manchmal verwendet werden, um verschiedene St√§nde zu erstellen. </font><font style="vertical-align: inherit;">Und f√ºr Kioske m√ºssen Sie manchmal OSD (On Screen Display) ausf√ºhren, dh ein Bild √ºber ein anderes legen. </font><font style="vertical-align: inherit;">Mir scheint, dass die DispmanX-API perfekt f√ºr diese Anwendungen ist. </font><font style="vertical-align: inherit;">Vielleicht wird jemand diese L√∂sung m√∂gen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de493594/index.html">PHP Digest Nr. 176 (11. - 23. M√§rz 2020)</a></li>
<li><a href="../de493596/index.html">Der Mann, der es nicht eilig hatte</a></li>
<li><a href="../de493598/index.html">Verstecke einen Teil der Telefonnummer</a></li>
<li><a href="../de493604/index.html">Digitale Veranstaltungen in Moskau vom 23. bis 29. M√§rz</a></li>
<li><a href="../de493606/index.html">Die Geschichte der Erstellung eines Cloud-Dienstes mit Cyberpunk</a></li>
<li><a href="../de493614/index.html">Erkennen Sie COVID-19 in R√∂ntgenstrahlen mit Keras, TensorFlow und Deep Learning</a></li>
<li><a href="../de493616/index.html">Bilder wie Kisten - was ist drin? Bericht in Yandex</a></li>
<li><a href="../de493618/index.html">(Nicht) offensichtliche OSINT auf Twitter</a></li>
<li><a href="../de493620/index.html">Logistische Kurve. Wann endet die Epidemie?</a></li>
<li><a href="../de493622/index.html">Schreiben einer Retrowave in Angular</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>