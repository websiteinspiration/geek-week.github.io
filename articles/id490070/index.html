<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏸️ 👯 ♣️ Saat saya menulis utusan saya 🐫 🍛 🙎🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suatu malam, setelah hari yang frustasi lainnya, penuh dengan upaya untuk menyeimbangkan permainan, saya memutuskan bahwa saya sangat membutuhkan isti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Saat saya menulis utusan saya</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490070/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suatu malam, setelah hari yang frustasi lainnya, penuh dengan upaya untuk menyeimbangkan permainan, saya memutuskan bahwa saya sangat membutuhkan istirahat. </font><font style="vertical-align: inherit;">Saya akan beralih ke proyek lain, lakukan dengan cepat, kembalikan harga diri yang telah bergulir selama pengembangan game dan akan mengambil game dengan badai dengan semangat baru! </font><font style="vertical-align: inherit;">Yang utama adalah memilih proyek yang menyenangkan dan santai ... Tulis pesan Anda sendiri? </font><font style="vertical-align: inherit;">Ha! </font><font style="vertical-align: inherit;">Seberapa sulitkah itu? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode dapat ditemukan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><img src="https://habrastorage.org/webt/_b/cw/av/_bcwavbn-h0r3vgv8zzhdkaq09y.jpeg"></td>
<td><img src="https://habrastorage.org/webt/97/4x/qd/974xqd470ltfwu6gge0hfnaqry4.jpeg"></td>
</tr>
</tbody></table></div><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latar Belakang Singkat</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selama hampir setahun sebelum mulai bekerja pada messenger, ia telah mengerjakan game Line Tower Wars multiplayer online. </font><font style="vertical-align: inherit;">Pemrograman berjalan dengan baik, segalanya (keseimbangan dan visual khususnya) tidak terlalu baik. </font><font style="vertical-align: inherit;">Tiba-tiba ternyata membuat permainan dan membuat permainan yang menyenangkan (kesenangan untuk orang lain selain dirinya sendiri) adalah dua hal yang berbeda. </font><font style="vertical-align: inherit;">Setelah satu tahun cobaan, saya perlu terganggu, jadi saya memutuskan untuk mencoba sesuatu yang lain. </font><font style="vertical-align: inherit;">Pilihan jatuh pada pengembangan ponsel, yaitu Flutter. </font><font style="vertical-align: inherit;">Saya mendengar banyak hal baik tentang Flutter, dan saya menyukai panah setelah percobaan singkat. </font><font style="vertical-align: inherit;">Saya memutuskan untuk menulis utusan saya sendiri. </font><font style="vertical-align: inherit;">Pertama, praktik yang baik untuk mengimplementasikan klien dan server. </font><font style="vertical-align: inherit;">Kedua, akan ada sesuatu yang signifikan untuk dimasukkan ke dalam portofolio untuk mencari pekerjaan, saya hanya dalam proses.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi Terjadwal</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obrolan pribadi dan grup</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengirim teks, gambar, dan video</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggilan audio dan video</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfirmasi tanda terima dan bacaan (kutu dari Votsap)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Cetakan ..."</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notifikasi</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cari berdasarkan kode QR dan geolokasi</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ke depan, saya dapat dengan bangga (dan dengan lega) mengatakan bahwa hampir semua yang direncanakan telah dilaksanakan, dan yang belum dilaksanakan - akan dilaksanakan dalam waktu dekat.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://player.vimeo.com/video/393246625" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilihan bahasa</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak berpikir lama dengan pilihan bahasa. </font><font style="vertical-align: inherit;">Pada awalnya, tergoda untuk menggunakan panah untuk klien dan server, tetapi pemeriksaan yang lebih rinci menunjukkan bahwa tidak ada banyak driver untuk panah yang tersedia, dan mereka yang tidak menginspirasi banyak kepercayaan diri. </font><font style="vertical-align: inherit;">Meskipun saya tidak akan menjamin untuk berbicara tentang momen saat ini, situasinya mungkin telah membaik. </font><font style="vertical-align: inherit;">Jadi pilihan saya jatuh pada C #, dengan mana saya bekerja di Unity.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arsitektur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dia mulai dengan memikirkan arsitektur. </font><font style="vertical-align: inherit;">Tentu saja, mengingat bahwa 3 setengah orang kemungkinan besar akan menggunakan messenger saya, orang tidak perlu repot dengan arsitektur secara umum. </font><font style="vertical-align: inherit;">Anda mengambil dan melakukan seperti dalam tutorial yang tak terhitung jumlahnya. </font><font style="vertical-align: inherit;">Inilah simpulnya, inilah mongo, di sini adalah soket web. </font><font style="vertical-align: inherit;">Selesai </font><font style="vertical-align: inherit;">Dan Firebase ada di sekitar sini. </font><font style="vertical-align: inherit;">Tapi itu tidak menarik. </font><font style="vertical-align: inherit;">Saya memutuskan untuk membuat messenger yang dapat dengan mudah skala horizontal, seolah-olah saya mengharapkan jutaan klien simultan. </font><font style="vertical-align: inherit;">Namun, karena saya tidak punya pengalaman di bidang ini, saya harus mempelajari semuanya dalam praktik dengan metode kesalahan dan kesalahan lagi.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arsitektur terakhir terlihat seperti ini</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/xp/jc/n7/xpjcn7otuw8am5jv9yztpp1sgyu.png"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak mengklaim bahwa arsitektur seperti itu sangat keren dan dapat diandalkan, tetapi itu layak dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">secara teori</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> harus menahan beban berat dan skala secara horizontal, tetapi saya tidak benar-benar mengerti cara memeriksa. </font><font style="vertical-align: inherit;">Dan saya harap saya tidak melewatkan momen yang sudah diketahui semua orang kecuali saya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di bawah ini adalah penjelasan rinci tentang masing-masing komponen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Server frontend</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan sebelum saya mulai membuat game, saya terpesona oleh konsep server single-threaded asynchronous. </font><font style="vertical-align: inherit;">Secara efektif dan tanpa potensi race'ov - apa lagi yang bisa Anda minta. </font><font style="vertical-align: inherit;">Untuk memahami bagaimana server tersebut diatur, saya mulai mempelajari modul </font></font><code>asyncio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bahasa python. </font><font style="vertical-align: inherit;">Solusi yang saya lihat tampak sangat elegan. </font><font style="vertical-align: inherit;">Singkatnya, solusi pseudo-code terlihat seperti ini.</font></font><br>
<pre><code class="cs hljs"><span class="hljs-comment">//  ,      ,    </span>
<span class="hljs-comment">//       .      socket.Receive</span>
<span class="hljs-comment">//     , :</span>
<span class="hljs-keyword">var</span> bytesReceived = Completer&lt;<span class="hljs-keyword">object</span>&gt;();<font></font>
selector.Register(<font></font>
    socket,<font></font>
    SocketEvent.Receive,<font></font>
    () =&gt; bytesReceived.Complete(<span class="hljs-literal">null</span>)<font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">await</span> bytesReceived.Future;<font></font>
<font></font>
<span class="hljs-keyword">int</span> n = socket.Receive(...); <span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-comment">// selector -     poll.   </span>
<span class="hljs-comment">//        (Receive </span>
<span class="hljs-comment">//  ), ,    ,  .</span>
<span class="hljs-comment">//   completer,      ,</span>
<span class="hljs-comment">//        , ,     .</span>
<span class="hljs-comment">//     ,       .</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan menggunakan teknik sederhana ini, kami dapat melayani sejumlah besar soket dalam satu utas. </font><font style="vertical-align: inherit;">Kami tidak pernah memblokir aliran sembari menunggu byte diterima atau dikirim. </font><font style="vertical-align: inherit;">Aliran selalu sibuk dengan pekerjaan yang bermanfaat. </font><font style="vertical-align: inherit;">Concurrency, singkatnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Frontend server diimplementasikan dengan cara itu. </font><font style="vertical-align: inherit;">Semuanya single-threaded dan asinkron. </font><font style="vertical-align: inherit;">Oleh karena itu, untuk kinerja maksimum, Anda perlu menjalankan server sebanyak pada satu mesin karena memiliki core (4 dalam gambar). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Server Frontend membaca pesan dari klien dan, berdasarkan pada kode pesan, mengirimkannya ke salah satu topik di Kafka.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catatan kaki kecil untuk mereka yang tidak terbiasa dengan kafa</font></font></b><div class="spoiler_text">   ,          RabbitMQ.    .       ,              (   authentication backend     authentication, ).  ?      -  ,         (partition).      ,      .      ,   ,       . ,             ( ,   ,  ,     (headers)).<br>
<br>
  ?     ?      .   (consumer)         (  consumer'),    ( )      . , ,      ,    2 ,       .   3 —     2.                .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Server frontend mengirim pesan ke kafka tanpa kunci (ketika tidak ada kunci, kafka hanya mengirim pesan ke pesta secara bergantian). Pesan ditarik dari topik oleh salah satu server backend yang sesuai. Server memproses pesan dan ... selanjutnya apa? Dan apa yang selanjutnya tergantung pada jenis pesan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus yang paling umum, siklus permintaan-respons terjadi. Misalnya, untuk permintaan registrasi, kami hanya perlu memberikan jawaban kepada klien ( </font></font><code>Success</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font><code>EmailAlreadyInUse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dll). Tetapi untuk pesan yang berisi undangan ke obrolan anggota baru yang sudah ada (Vasya, Emil dan Julia), kita perlu segera merespons dengan tiga jenis pesan yang berbeda. Jenis pertama - Anda perlu memberi tahu pengguna undangan tentang hasil operasi (tiba-tiba terjadi kesalahan server). Jenis kedua - Anda perlu memberi tahu semua anggota obrolan saat ini bahwa ada anggota baru ini dan itu di dalam obrolan. Yang ketiga adalah mengirim undangan ke Vasya, Emil dan Yulia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oke, itu kedengarannya tidak sulit, tetapi untuk mengirim pesan ke klien mana pun kita perlu: 1) mencari tahu server ujung mana yang terhubung dengan klien ini (kami tidak memilih server mana yang akan disambungkan klien, penyeimbang memutuskan untuk kami); 2) mengirim pesan dari server backend ke server frontend yang diinginkan; 3) sebenarnya, mengirim pesan ke klien.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menerapkan poin 1 dan 2, saya memutuskan untuk menggunakan topik yang terpisah (topik "server frontend"). Pemisahan otentikasi, sesi, dan topik panggilan ke dalam partisi berfungsi sebagai mekanisme paralelisasi. Kami melihat bahwa server sesi banyak dimuat? Kami hanya menambahkan beberapa server partisi dan sesi baru, dan Kafka akan mendistribusikan kembali beban untuk kami, menurunkan server sesi yang ada. Pemisahan topik "server frontend" ke dalam partisi berfungsi sebagai mekanisme </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perutean</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap server frontend berhubungan dengan satu bagian dari topik "server frontend" (dengan indeks yang sama dengan server itu sendiri). Yaitu, server 0 - partisi 0, dan seterusnya. Kafka memungkinkan untuk berlangganan tidak hanya ke topik tertentu, tetapi juga ke bagian tertentu dari topik tertentu. Semua server frontend saat start-up berlangganan partisi yang sesuai. Dengan demikian, server backend dapat mengirim pesan ke server frontend tertentu dengan mengirim pesan ke partisi tertentu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oke, sekarang ketika klien bergabung, Anda hanya perlu menyimpan sepasang UserId - Frontend Server Index. Dalam hal putuskan - hapus. Untuk tujuan ini, salah satu dari banyak basis data nilai kunci dalam memori akan melakukannya. Saya memilih lobak.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana tampilannya dalam praktik. </font><font style="vertical-align: inherit;">Pertama-tama, setelah koneksi dibuat, klien Andrey mengirim pesan ke server </font></font><code>Join</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Server Frontend menerima pesan dan meneruskannya ke topik sesi, sebelum menambahkan header "Server Frontend": {index}. </font><font style="vertical-align: inherit;">Salah satu server sesi backend akan menerima pesan, membaca token otorisasi, menentukan jenis pengguna yang telah bergabung, membaca indeks yang ditambahkan oleh server frontend dan menulis UserId - Index ke lobak. </font><font style="vertical-align: inherit;">Dari saat ini, klien dianggap online, dan sekarang kita tahu melalui server frontend mana (dan, dengan demikian, melalui bagian mana dari topik "server frontend") kita dapat "menjangkau" ketika klien lain mengirim pesan ke Andrey. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
* Sebenarnya, prosesnya sedikit lebih rumit dari yang saya jelaskan. </font><font style="vertical-align: inherit;">Anda dapat menemukannya di kode sumber.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode pseudo server frontend</font></font></h4><br>
<pre><code class="cs hljs"><span class="hljs-comment">// Frontend Server 6</span>
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-comment">// Consume from "Frontend Servers" topic, partition 6</span>
    <span class="hljs-keyword">var</span> messageToClient = consumer.Consume();
    <span class="hljs-keyword">if</span> (message != <span class="hljs-literal">null</span>) {<font></font>
        relayMessageToClient(messageToClient);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">var</span> callbacks = selector.Poll();
    <span class="hljs-keyword">while</span> (callbacks.TryDequeue(<span class="hljs-keyword">out</span> callback)) {<font></font>
        callback();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">long</span> now = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
    <span class="hljs-keyword">while</span> (!callAtQueue.IsEmpty &amp;&amp; callAtQueue.PeekPriority() &lt;= now) {<font></font>
        callAtQueue.Dequeue()();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (messagesToRelayToBackendServers.TryDequeue(<span class="hljs-keyword">out</span> messageFromClient)) {
        <span class="hljs-comment">// choose topic</span><font></font>
        producer.Produce(topic, messageFromClient);<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada beberapa trik di sini. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) </font></font><code>relayMessageToClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini akan menjadi kesalahan untuk hanya mengambil soket yang Anda inginkan dan segera mulai mengirim pesan ke sana, karena mungkin kami </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sudah</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengirim beberapa pesan lain ke klien. Jika kita mulai mengirim byte tanpa memeriksa apakah soket sedang sibuk, pesan akan tercampur. Seperti di banyak tempat lain di mana pemrosesan data yang tertib diperlukan, triknya adalah menggunakan antrian, yaitu antrian dari Completers ( </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam C #).</font></font><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">async</span> <span class="hljs-title">relayMessageToClient</span>(<span class="hljs-params">message</span>)</span> {
    <span class="hljs-comment">// find client</span>
    <span class="hljs-keyword">await</span> client.ReadyToSend();
    <span class="hljs-keyword">await</span> sendMessage(client, message);<font></font>
    client.CompleteSend();<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> {
    <span class="hljs-comment">// ...</span>
    sendMessageQueue = <span class="hljs-keyword">new</span> LinkedList&lt;Completer&lt;<span class="hljs-keyword">object</span>&gt;&gt;();<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">async</span> Future <span class="hljs-title">ReadyToSend</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">var</span> sendMessage = Completer&lt;<span class="hljs-keyword">object</span>&gt;();
	<span class="hljs-keyword">if</span> (sendMessageQueue.IsEmpty) {<font></font>
	    sendMessageQueue.AddLast(sendMessage);<font></font>
	} <span class="hljs-keyword">else</span> {
	    <span class="hljs-keyword">var</span> prevSendMessage = sendMessageQueue.Last;<font></font>
	    sendMessageQueue.AddLast(sendMessage);<font></font>
	    <span class="hljs-keyword">await</span> prevSendMessage.Future;<font></font>
	}<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CompleteSend</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">var</span> sendMessage = sendMessageQueue.RemoveFirst();<font></font>
	sendMessage.Complete(<span class="hljs-literal">null</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika antrian tidak kosong, maka soket sudah terisi saat ini. Buat yang baru </font></font><code>completer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tambahkan ke antrian dan </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebelumnya</font></font></i> <code>completer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jadi, ketika pesan sebelumnya dikirim, itu </font></font><code>CompleteSend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan selesai </font></font><code>completer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang akan menyebabkan server mulai mengirim pesan berikutnya. Antrian seperti itu juga memungkinkan perkembangbiakan pengecualian dengan lancar. Misalkan terjadi kesalahan saat mengirim pesan ke klien. Dalam hal ini, kita perlu menyelesaikan, dengan pengecualian mengirim tidak hanya pesan ini, tetapi juga semua pesan yang sedang menunggu dalam antrian (tunggu </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'ah). Jika tidak, maka mereka akan terus hang, dan kami akan menerima kebocoran memori. Untuk singkatnya, kode yang melakukan ini tidak ditampilkan di sini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2)</font></font><code>selector.Poll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sebenarnya, ini bahkan bukan tipuan, tetapi hanya upaya untuk memuluskan kekurangan dari implementasi metode </font></font><code>Socket.Select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><code>selector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- hanya penutup metode ini). Tergantung pada OS di bawah tenda, metode ini menggunakan salah satu </font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau </font></font><code>poll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tapi ini tidak penting di sini. Yang penting adalah bagaimana metode ini bekerja dengan daftar yang kami masukkan ke input (daftar soket untuk membaca, menulis, memeriksa kesalahan). Metode ini mengambil daftar, polling soket dan hanya menyisakan soket dalam daftar yang siap untuk melakukan operasi yang diperlukan. Semua soket lainnya dikeluarkan dari daftar. "Tendangan" terjadi</font></font><code>RemoveAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(yaitu, semua elemen berikutnya digeser, yang tidak efisien). Plus, karena kita perlu mensurvei semua soket terdaftar setiap iterasi siklus, "pembersihan" seperti itu umumnya berbahaya, kita harus mengisi ulang daftar setiap waktu. Kami dapat mengatasi semua masalah ini menggunakan masalah khusus </font></font><code>List</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>RemoveAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang </font><font style="vertical-align: inherit;">metodenya </font><font style="vertical-align: inherit;">tidak menghapus item dari daftar, tetapi cukup menandainya sebagai dihapus. Kelas </font></font><code>ListForPolling</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah implementasi saya dari daftar semacam itu. </font></font><code>ListForPolling</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya bekerja dengan metode ini </font></font><code>Socket.Select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan tidak cocok untuk hal lain. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3)</font></font><code>callAtQueue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dalam kebanyakan kasus, server frontend, setelah mengirim pesan klien ke server backend, mengharapkan respons (konfirmasi bahwa operasi berhasil, atau kesalahan jika terjadi kesalahan). Jika dia tidak menunggu jawaban dalam periode waktu yang dapat dikonfigurasi, dia mengirim kesalahan kepada klien sehingga dia tidak menunggu jawaban yang tidak akan pernah datang. </font></font><code>callAtQueue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merupakan antrian prioritas. Segera setelah server mengirim pesan ke Kafka, ia melakukan sesuatu seperti ini:</font></font><br>
<pre><code class="cs hljs"><span class="hljs-keyword">long</span> now = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();<font></font>
callAtQueue.Enqueue(callback, now + config.WaitForReplyMSec);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam panggilan balik, menunggu respons dibatalkan dan pengiriman kesalahan server dimulai. Jika respons dari server backend diterima, panggilan balik tidak melakukan apa pun. </font><font style="vertical-align: inherit;">Tidak ada cara untuk </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
menggunakannya </font></font><code>await Task.WhenAny(answerReceivedTask, Task.Delay(x))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena kode setelah </font></font><code>Task.Delay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dijalankan pada utas dari kolam. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini, pada kenyataannya, segala sesuatu tentang server frontend. Diperlukan sedikit koreksi di sini. Padahal, server tidak </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sepenuhnya</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berulir tunggal. Tentu saja, kafka di bawah tenda menggunakan utas, tapi maksud saya kode aplikasi. Faktanya adalah bahwa mengirim pesan ke topik kafka (hasil) mungkin tidak berhasil. Jika terjadi kegagalan, Kafka mengulangi pengiriman beberapa kali yang dapat dikonfigurasi, tetapi, jika keberangkatan berulang gagal, Kafka meninggalkan bisnis ini tanpa harapan. Anda dapat memeriksa apakah pesan telah berhasil dikirim atau tidak di </font></font><code>deliveryHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mana kami meneruskan ke metode </font></font><code>Produce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kafka menyebut penangan ini di utas I / O produsen (utas yang mengirim pesan). Kami harus memastikan bahwa pesan telah berhasil dikirim, dan jika tidak, batalkan menunggu jawaban dari server backend (respons tidak akan datang karena permintaan tidak terkirim) dan mengirim kesalahan ke klien. Artinya, kami tidak dapat menghindari berinteraksi dengan utas lainnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
* Ketika menulis artikel, tiba-tiba saya menyadari bahwa kita tidak dapat meneruskan </font></font><code>deliveryHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke metode </font></font><code>Produce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau mengabaikan semua kesalahan kafka (kesalahan masih akan dikirim ke klien dengan batas waktu yang saya jelaskan sebelumnya) - maka semua kode kita akan berurutan tunggal. </font><font style="vertical-align: inherit;">Sekarang saya berpikir bagaimana melakukannya dengan lebih baik.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebenarnya, kafka, bukan kelinci?</font></font></b><div class="spoiler_text">,        ,   ,  , ,   RabbitMQ?        .  , ,   .     ?    ,         frontend .   ,     backend ,      ,          .    ,       ,     .   ,       error-prone.  ,     <code>basicGet</code> ,    ,   ,      .     .      <code>basicGet</code>,      ,       .          .<br>
</div></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Server backend</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dibandingkan dengan server frontend, praktis tidak ada poin menarik di sini. </font><font style="vertical-align: inherit;">Semua server backend bekerja dengan cara yang sama. </font><font style="vertical-align: inherit;">Pada saat startup, server berlangganan ke topik (otentikasi, sesi atau panggilan tergantung pada peran), dan kafka menetapkan satu atau lebih partisi untuknya. </font><font style="vertical-align: inherit;">Server menerima pesan dari Kafka, memproses dan biasanya mengirim satu atau lebih pesan sebagai tanggapan. </font><font style="vertical-align: inherit;">Kode yang hampir nyata:</font></font><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">long</span> lastCommitTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">var</span> consumeResult = consumer.Consume(<font></font>
            TimeSpan.FromMilliseconds(config.Consumer.PollTimeoutMSec)<font></font>
        );<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (consumeResult != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> workUnit = <span class="hljs-keyword">new</span> WorkUnit() {<font></font>
                ConsumeResult = consumeResult,<font></font>
            };<font></font>
<font></font>
            LinkedList&lt;WorkUnit&gt; workUnits;<font></font>
            <span class="hljs-keyword">if</span> (partitionToWorkUnits.ContainsKey(consumeResult.Partition)) {<font></font>
                workUnits = partitionToWorkUnits[consumeResult.Partition];<font></font>
            } <span class="hljs-keyword">else</span> {<font></font>
                workUnits = partitionToWorkUnits[consumeResult.Partition] =<font></font>
                    <span class="hljs-keyword">new</span> LinkedList&lt;WorkUnit&gt;();<font></font>
            }<font></font>
<font></font>
            workUnits.AddLast(workUnit);<font></font>
<font></font>
            handleWorkUnit(workUnit);<font></font>
        }<font></font>
<font></font>
	<span class="hljs-keyword">if</span> (<font></font>
            DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() - lastCommitTime &gt;=<font></font>
            config.Consumer.CommitIntervalMSec<font></font>
        ) {<font></font>
            commitOffsets();<font></font>
	    lastCommitTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();<font></font>
	}<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jenis offset apa yang harus dikomit?</font></font></b><div class="spoiler_text">       .   —   (offset)    (0, 1  ).         0.        <code>TopicPartitionOffset</code>.    (consume)   ,   <code>ConsumeResult</code>, ,   ,   <code>TopicPartitionOffset</code>.     ?<br>
<br>
  at least once delivery,  ,              (    ).     ,           (commited) . ,  consumer         16,  ,  16 ,   ,      ,   .     -  consumer'     consumer'        ,    16 + 1 (   + 1).    17   .        N ,       .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya menonaktifkan komitmen otomatis dan mengikat diri saya sendiri. Ini diperlukan karena </font></font><code>handleWorkUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, di mana pemrosesan pesan sebenarnya dilakukan, ini adalah </font></font><code>async void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode, oleh karena itu tidak ada jaminan bahwa pesan 5 akan diproses sebelum pesan 6. Kafka menyimpan masing-masing satu offset yang dilakukan (dan bukan satu set offset), masing-masing, sebelum melakukan offset 6, kita perlu memastikan bahwa semua pesan sebelumnya telah diproses juga. Selain itu, satu server backend dapat menggunakan pesan dari beberapa partisi pada saat yang bersamaan, dan, karenanya, harus memastikan bahwa ia melakukan offset yang benar ke partisi yang sesuai. Untuk ini, kami menggunakan peta hash dari partisi bentuk: unit kerja. Seperti apa kode ini </font></font><code>commitOffsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(kode sebenarnya saat ini):</font></font><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commitOffsets</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">foreach</span> (LinkedList&lt;WorkUnit&gt; workUnits <span class="hljs-keyword">in</span> partitionToWorkUnits.Values) {<font></font>
        WorkUnit lastFinishedWorkUnit = <span class="hljs-literal">null</span>;<font></font>
        LinkedListNode&lt;WorkUnit&gt; workUnit;<font></font>
        <span class="hljs-keyword">while</span> ((workUnit = workUnits.First) != <span class="hljs-literal">null</span> &amp;&amp; workUnit.Value.IsFinished) {<font></font>
            lastFinishedWorkUnit = workUnit.Value;<font></font>
            workUnits.RemoveFirst();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (lastFinishedWorkUnit != <span class="hljs-literal">null</span>) {<font></font>
            offsets.Add(lastFinishedWorkUnit.ConsumeResult.TopicPartitionOffset);<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (offsets.Count &gt; <span class="hljs-number">0</span>) {<font></font>
        consumer.Commit(offsets);<font></font>
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> offset <span class="hljs-keyword">in</span> offsets) {<font></font>
            logger.Debug(<font></font>
                <span class="hljs-string">"{Identifier}: Commited offset {TopicPartitionOffset}"</span>,<font></font>
                identifier,<font></font>
                offset<font></font>
            );<font></font>
        }<font></font>
        offsets.Clear();<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, kami beralih pada unit, menemukan unit terakhir selesai saat ini, setelah itu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak ada yang tidak lengkap</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan melakukan offset yang sesuai. </font><font style="vertical-align: inherit;">Perulangan semacam itu memungkinkan kita untuk menghindari komit "berlubang". </font><font style="vertical-align: inherit;">Misalnya, jika saat ini kami memiliki 4 unit ( </font></font><code>0: Finished, 1: Not Finished, 2: Finished, 3: Finished</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), kami hanya dapat melakukan unit ke-0, karena jika kami langsung berkomitmen ke-3, ini dapat menyebabkan potensi hilangnya unit ke-1 jika server mati saat ini.</font></font><br>
<pre><code class="cs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkUnit</span> {
    <span class="hljs-keyword">public</span> ConsumeResult&lt;Null, <span class="hljs-keyword">byte</span>[]&gt; ConsumeResult { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> finished = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> IsFinished =&gt; finished == <span class="hljs-number">1</span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Finish</span>(<span class="hljs-params"></span>)</span> {<font></font>
        Interlocked.Increment(<span class="hljs-keyword">ref</span> finished);<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<br>
<code>handleWorkUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seperti yang dikatakan, </font></font><code>async void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode, dan karenanya, sepenuhnya dibungkus </font></font><code>try-catch-finally</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dalam </font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ia memanggil layanan yang diperlukan, dan di </font></font><code>finally</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>workUnit.Finish()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Layanannya cukup sepele. </font><font style="vertical-align: inherit;">Di sini, misalnya, kode apa yang dieksekusi ketika pengguna mengirim pesan baru:</font></font><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task&lt;ServiceResult&gt; <span class="hljs-title">createShareItem</span>(<span class="hljs-params">CreateShareItemMessage msg</span>)</span> {
    <span class="hljs-keyword">byte</span>[] message;
    <span class="hljs-keyword">byte</span>[] messageToPals1 = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">int</span>?[] partitions1 = <span class="hljs-literal">null</span>;<font></font>
<font></font>
    <span class="hljs-comment">//  UserId  .</span>
    <span class="hljs-keyword">long</span>? userId = hashService.ValidateSessionIdentifier(msg.SessionIdentifier);
    <span class="hljs-keyword">if</span> (userId != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> shareItem = <span class="hljs-keyword">new</span> ShareItemModel(<font></font>
            requestIdentifier: msg.RequestIdentifier,<font></font>
            roomIdentifier: msg.RoomIdentifier,<font></font>
            creatorId: userId,<font></font>
            timeOfCreation: <span class="hljs-literal">null</span>,<font></font>
            type: msg.ShareItemType,<font></font>
            content: msg.Content<font></font>
        );<font></font>
<font></font>
        <span class="hljs-comment">//      null,</span>
        <span class="hljs-comment">//     .</span>
        <span class="hljs-keyword">long</span>? timeOfCreation = <span class="hljs-keyword">await</span> storageService.CreateShareItem(shareItem);
        <span class="hljs-keyword">if</span> (timeOfCreation != <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">//      .</span>
            List&lt;<span class="hljs-keyword">long</span>&gt; pals = <span class="hljs-keyword">await</span> inMemoryStorageService.GetRoomPals(<font></font>
                msg.RoomIdentifier<font></font>
            );<font></font>
            <span class="hljs-keyword">if</span> (pals == <span class="hljs-literal">null</span>) {
            	<span class="hljs-comment">//     -       .</span>
                pals = <span class="hljs-keyword">await</span> storageService.GetRoomPals(msg.RoomIdentifier);
                <span class="hljs-keyword">await</span> inMemoryStorageService.SaveRoomPals(msg.RoomIdentifier, pals);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-comment">//    ,  .</span><font></font>
            pals.Remove(userId.Value);<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (pals.Count &gt; <span class="hljs-number">0</span>) {
            	<span class="hljs-comment">//  ack,  ,    </span>
                <span class="hljs-comment">//    .</span>
                <span class="hljs-keyword">await</span> storageService.CreateAck(<font></font>
                    msg.RequestIdentifier, userId.Value, msg.RoomIdentifier,<font></font>
                    timeOfCreation.Value, pals<font></font>
                );<font></font>
<font></font>
                <span class="hljs-comment">// in -  UserId, out -   frontend ,</span>
                <span class="hljs-comment">//    .  -   -</span>
                <span class="hljs-comment">//   null.</span>
                partitions1 = <span class="hljs-keyword">await</span> inMemoryStorageService.GetUserPartitions(pals);<font></font>
<font></font>
                List&lt;<span class="hljs-keyword">long</span>&gt; onlinePals = getOnlinePals(pals, partitions1);<font></font>
<font></font>
                <span class="hljs-comment">//    ,       .</span>
                <span class="hljs-comment">//         .</span>
                <span class="hljs-keyword">if</span> (onlinePals.Count &gt; <span class="hljs-number">0</span>) {<font></font>
                    messageToPals1 = converterService.EncodeNewShareItemMessage(<font></font>
                        userId.Value, timeOfCreation.Value, onlinePals, shareItem<font></font>
                    );<font></font>
                    nullRepeatedPartitions(partitions1);<font></font>
                    <span class="hljs-comment">// -         </span>
                    <span class="hljs-comment">// frontend ,    null' .</span><font></font>
                }<font></font>
            }<font></font>
<font></font>
            message = converterService.EncodeSuccessfulShareItemCreationMessage(<font></font>
                msg.RequestIdentifier, timeOfCreation.Value<font></font>
            );<font></font>
        } <span class="hljs-keyword">else</span> {<font></font>
            message = converterService.EncodeMessage(<font></font>
                MessageCode.RoomNotFound, msg.RequestIdentifier<font></font>
            );<font></font>
        }<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        message = converterService.EncodeMessage(<font></font>
            MessageCode.UserNotFound, msg.RequestIdentifier<font></font>
        );<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServiceResult(<font></font>
        message: message, <span class="hljs-comment">//    .</span>
        messageToPals1: messageToPals1, <span class="hljs-comment">//  -    .</span><font></font>
        partitions1: partitions1<font></font>
    );<font></font>
}<font></font>
</code></pre><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basis data</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagian besar fungsionalitas layanan yang disebut oleh server backend hanya menambahkan data baru ke database dan memproses yang sudah ada. Jelas, bagaimana database diorganisasikan dan bagaimana kami beroperasi sangat penting bagi messenger, dan di sini saya ingin mengatakan bahwa saya mendekati masalah memilih database dengan sangat hati-hati setelah mempelajari semua opsi dengan hati-hati, tetapi tidak demikian halnya. Saya baru saja memilih CockroachDb karena menjanjikan banyak dengan usaha minimal dan memiliki sintaks yang kompatibel postgres (saya pernah bekerja dengan postgres sebelumnya). Ada pemikiran untuk menggunakan Cassandra, tetapi pada akhirnya saya memutuskan untuk memikirkan sesuatu yang akrab. Saya belum pernah bekerja dengan Kafka, atau dengan Kelinci, atau dengan Flutter dan Dart, atau dengan WebRtc, jadi saya memutuskan untuk tidak menyeret Cassandra juga, karena saya takut menenggelamkan sejumlah besar teknologi baru untuk saya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dari semua bagian proyek saya, desain basis data adalah hal yang paling saya ragukan. Saya tidak yakin bahwa keputusan yang saya buat adalah </font><font style="vertical-align: inherit;">keputusan </font><font style="vertical-align: inherit;">yang benar-benar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baik</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Semuanya berfungsi, tetapi bisa dilakukan dengan lebih baik. Misalnya, ada tabel ShareRooms (seperti yang saya sebut obrolan) dan ShareItems (seperti yang saya sebut pesan). Jadi semua pengguna yang memasuki ruangan dicatat di bidang jsonb ruangan ini. Ini nyaman, tapi jelas sangat lambat, jadi saya mungkin akan mengulanginya menggunakan kunci asing. Atau, misalnya, tabel ShareItems menyimpan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semua</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pesan. Yang juga nyaman, tetapi karena ShareItems adalah salah satu tabel paling banyak dimuat (persisten </font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan</font></font><code>insert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), mungkin ada baiknya membuat tabel baru untuk setiap kamar atau sesuatu seperti itu. Kokroach menyebarkan rekaman pada node yang berbeda, oleh karena itu, Anda harus hati-hati memikirkan catatan mana yang akan digunakan untuk mencapai kinerja maksimum, tetapi saya tidak melakukannya. Secara umum, seperti dapat dipahami dari semua hal di atas, basis data bukan titik terkuat saya. Saat ini saya umumnya menguji segala sesuatu untuk postgres, dan bukan kokroach, karena ada lebih sedikit beban pada mesin saya, sudah sangat buruk dari beban sehingga akan segera lepas landas. Untungnya, kode untuk postgres dan kokroach sedikit berbeda, jadi beralih tidak sulit.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang saya sedang dalam proses mempelajari bagaimana cocroach sebenarnya bekerja (bagaimana pemetaan terjadi antara SQL dan nilai kunci (cocroach menggunakan RocksDb di bawah tenda), bagaimana ia mendistribusikan data antara node, ulangan, dll.). Tentu saja bermanfaat untuk mempelajari cocroach sebelum menggunakannya, tetapi lebih baik terlambat daripada tidak sama sekali.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya pikir basis akan mengalami perubahan besar ketika saya menjadi lebih baik dalam memahami masalah ini. Saat ini, meja Acks menghantui saya. Dalam tabel ini, saya menyimpan data tentang siapa yang belum menerima dan siapa yang belum membaca pesan (untuk menunjukkan tanda centang pengguna). Mudah untuk memberi tahu pengguna bahwa pesannya telah dibaca jika pengguna sedang online sekarang, tetapi jika tidak, kita perlu menyimpan informasi ini untuk memberi tahu pengguna nanti. Dan karena obrolan grup tersedia, tidak cukup hanya untuk menyimpan benderanya, Anda memerlukan data tentang pengguna perorangan. Jadi di sini kami langsung meminta penggunaan string bit (satu baris untuk pengguna yang belum menerima, yang kedua - bagi mereka yang belum membaca). Terutama dukungan kokroach </font></font><code>bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan</font></font><code>bit varying</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Namun, saya tidak pernah menemukan cara untuk mengimplementasikan bisnis ini, mengingat bahwa komposisi kamar dapat terus berubah. Agar string bit tetap mempertahankan maknanya, pengguna di dalam ruangan harus tetap dalam urutan yang sama, yang cukup sulit dilakukan ketika, misalnya, beberapa pengguna meninggalkan ruangan. Ada opsi di sini. Mungkin ada baiknya menulis -1 daripada menghapus pengguna dari bidang jsonb sehingga pesanan dipertahankan, atau menggunakan beberapa metode versi, sehingga kami tahu bahwa string bit ini mengacu pada urutan pengguna, yang saat itu, dan tidak pada urutan pengguna saat ini. Saya masih dalam proses berpikir tentang bagaimana menerapkan bisnis ini dengan lebih baik, tetapi untuk saat ini, mereka yang belum menerima dan belum membaca pengguna juga hanya bidang jsonb. Mengingat bahwa tabel Acks ditulis dengan setiap pesan, jumlah datanya besar.Meskipun catatan, tentu saja, dihapus ketika pesan diterima dan dibaca oleh semua orang.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berdebar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk waktu yang lama saya bekerja di sisi server dan menggunakan klien konsol sederhana untuk pengujian, jadi saya bahkan tidak membuat proyek Flutter. </font><font style="vertical-align: inherit;">Dan ketika saya membuatnya, saya berpikir bahwa bagian server adalah bagian yang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kompleks</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan aplikasinya seperti itu, sampah, saya akan mengetahuinya dalam beberapa hari. </font><font style="vertical-align: inherit;">Saat bekerja di server, saya membuat Hello Worlds untuk bergetar beberapa kali untuk merasakan kerangka, dan karena kurir itu tidak memerlukan UI yang rumit, saya pikir itu benar-benar siap. </font><font style="vertical-align: inherit;">Jadi UI, benar-benar, adalah sampah, tetapi penerapan fungsi memberi saya masalah (dan itu masih akan menghasilkan, karena tidak semuanya siap).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manajemen negara</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Topik paling populer. Ada ribuan cara untuk mengelola kondisi Anda, dan pendekatan yang disarankan diubah setiap enam bulan. Sekarang arus utama adalah penyedia. Secara pribadi, saya memilih 2 cara untuk diri saya sendiri: blok dan redux. Blok (Komponen Logika Bisnis) untuk mengelola negara bagian dan redux untuk mengelola global. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Blok bukan semacam perpustakaan (walaupun, tentu saja, ada juga perpustakaan yang mengurangi boilerplate, tapi saya tidak menggunakannya). Blok adalah pendekatan berbasis aliran. Secara umum, panah adalah bahasa yang cukup bagus, dan aliran pada umumnya sangat manis. Inti dari pendekatan ini adalah kami mendorong seluruh logika bisnis ke dalam layanan, dan kami berkomunikasi antara UI dan layanan melalui pengontrol yang memberi kami berbagai aliran. Apakah pengguna mengklik tombol “temukan kontak”? Menggunakan</font></font><code>sink</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ujung lain dari aliran) kami mengirim acara ke controller </font></font><code>SearchContactsEvent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, controller akan memanggil layanan yang diinginkan, menunggu hasilnya dan mengembalikan daftar pengguna kembali ke UI melalui stream juga. UI menunggu hasil menggunakan </font></font><code>StreamBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(widget yang dibangun kembali setiap kali data baru tiba di aliran tempat berlangganannya). Faktanya, itu saja. Dalam beberapa kasus, kami perlu memperbarui UI tanpa keterlibatan pengguna (misalnya, ketika pesan baru tiba), tetapi ini juga mudah dilakukan melalui streaming. Bahkan, MVC sederhana dengan aliran, tanpa sihir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dibandingkan dengan beberapa pendekatan lain, blok membutuhkan lebih banyak boilerplate, tetapi, menurut saya, lebih baik menggunakan solusi asli tanpa partisipasi perpustakaan pihak ketiga, kecuali menggunakan solusi pihak ketiga memberikan beberapa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">signifikan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keuntungan. </font><font style="vertical-align: inherit;">Semakin banyak abstraksi di atas, semakin sulit untuk memahami apa kesalahannya ketika kesalahan terjadi. </font><font style="vertical-align: inherit;">Saya tidak menganggap kelebihan penyedia cukup signifikan untuk beralih ke itu. </font><font style="vertical-align: inherit;">Tetapi saya memiliki sedikit pengalaman di bidang ini, sehingga kemungkinan saya akan mengubah kamp di masa depan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya, tentang redux, dan semua orang tahu segalanya, jadi tidak ada yang perlu dikatakan. </font><font style="vertical-align: inherit;">Selain itu, saya hentikan itu dari aplikasi :) Saya menggunakannya untuk mengelola akun saya, tetapi kemudian, menyadari bahwa dalam kasus ini tidak ada keuntungan khusus atas blokir, saya hentikan agar tidak terlalu banyak menarik. </font><font style="vertical-align: inherit;">Tetapi secara umum saya menganggap redux hal yang berguna untuk mengelola negara global.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian yang paling menyiksa</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang harus saya lakukan jika pengguna mengirim pesan, tetapi sebelum dikirim, koneksi Internet terputus? Apa yang harus saya lakukan jika pengguna menerima konfirmasi baca, tetapi ia menutup aplikasi sebelum catatan terkait dalam database diperbarui? Apa yang harus saya lakukan jika pengguna mengundang temannya ke kamar, tetapi sebelum undangan dikirim, baterainya mati? Pernahkah Anda menanyakan pertanyaan serupa? Saya disini. Sebelum. Tetapi dalam proses pengembangan saya mulai bertanya-tanya. Karena koneksi dapat menghilang kapan saja, dan telepon mati kapan saja, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semuanya</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> harus </font><b><font style="vertical-align: inherit;">dikonfirmasi</font></b><font style="vertical-align: inherit;"> . Tidak menyenangkan. Oleh karena itu, pesan pertama yang dikirim klien ke server ( </font></font><code>Join</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jika Anda ingat) bukan hanya </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Halo saya sedang online"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , itu adalah</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Halo, saya sedang online dan ini kamar yang belum dikonfirmasi, ini acks yang belum dikonfirmasi, ini operasi keanggotaan kamar yang belum dikonfirmasi, dan ini pesan terakhir yang diterima per kamar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><i><font style="vertical-align: inherit;">" </font></i><font style="vertical-align: inherit;">Dan server merespons dengan lembar serupa: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Ketika Anda sedang offline, pesan ini dan itu dibaca oleh pengguna ini dan itu, dan mereka juga mengundang Petya ke ruangan ini, dan Sveta meninggalkan ruangan ini, dan Anda diundang ke ruangan ini, tetapi untuk dua kamar ini memiliki 40 pos baru</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><i><font style="vertical-align: inherit;">" </font></i><font style="vertical-align: inherit;">Saya benar-benar ingin tahu bagaimana hal serupa dilakukan pada utusan lain, karena implementasi saya tidak bersinar dengan anggun.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar-gambar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat ini, Anda dapat mengirim teks, teks + gambar dan hanya gambar. </font><font style="vertical-align: inherit;">Upload video belum diimplementasikan. </font><font style="vertical-align: inherit;">Gambar dikompresi sedikit dan disimpan dalam penyimpanan Firebase. </font><font style="vertical-align: inherit;">Pesan itu sendiri berisi tautan. </font><font style="vertical-align: inherit;">Setelah menerima pesan, klien mengunduh gambar, menghasilkan thumbnail dan menyimpan semuanya ke sistem file. </font><font style="vertical-align: inherit;">Jalur file ditulis ke database. </font><font style="vertical-align: inherit;">Omong-omong, pembuatan thumbnail adalah satu-satunya kode yang dieksekusi pada utas terpisah, karena ini adalah operasi yang sangat berat. </font><font style="vertical-align: inherit;">Saya baru memulai satu stream pekerja, berikan gambar dan sebagai imbalannya saya mendapatkan thumbnail. </font><font style="vertical-align: inherit;">Kode ini sangat sederhana, karena panah memberikan abstraksi yang nyaman untuk bekerja dengan stream.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThumbnailGeneratorService</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThumbnailGeneratorService</span> </span>{<font></font>
  SendPort _sendPort;<font></font>
  final Queue&lt;Completer&lt;Uint8List&gt;&gt; _completerQueue =<font></font>
      Queue&lt;Completer&lt;Uint8List&gt;&gt;();<font></font>
<font></font>
  ThumbnailGeneratorService() {<font></font>
    <span class="hljs-keyword">var</span> receivePort = ReceivePort();<font></font>
    Isolate.spawn(startWorker, receivePort.sendPort);<font></font>
<font></font>
    receivePort.listen((data) {<font></font>
      <span class="hljs-keyword">if</span> (data is SendPort) {<font></font>
        _sendPort = data;<font></font>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> completer = _completerQueue.removeFirst();<font></font>
        completer.complete(data);<font></font>
      }<font></font>
    });<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> startWorker(SendPort sendPort) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">var</span> receivePort = ReceivePort();<font></font>
    sendPort.send(receivePort.sendPort);<font></font>
<font></font>
    receivePort.listen((imageBytes) {<font></font>
      Image image = decodeImage(imageBytes);<font></font>
      Image thumbnail = copyResize(image, <span class="hljs-attr">width</span>: min(image.width, <span class="hljs-number">200</span>));<font></font>
<font></font>
      sendPort.send(Uint8List.fromList(encodePng(thumbnail)));<font></font>
    });<font></font>
  }<font></font>
<font></font>
  Future&lt;Uint8List&gt; generate(Uint8List imageBytes) {<font></font>
    <span class="hljs-keyword">var</span> completer = Completer&lt;Uint8List&gt;();<font></font>
    _completerQueue.add(completer);<font></font>
    <font></font>
    _sendPort.send(imageBytes);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> completer.future;<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Firebase authase juga digunakan, tetapi hanya untuk otorisasi akses ke penyimpanan Firebase (sehingga pengguna tidak dapat, misalnya, mengisi gambar profil dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">orang lain</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Semua otorisasi lain dilakukan melalui server saya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Format pesan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda mungkin ngeri di sini, karena saya menggunakan array byte biasa. Json menghilang karena efisiensi diperlukan, dan saya tidak tahu tentang protobuf ketika saya mulai. Menggunakan array memerlukan banyak perhatian karena satu indeks salah dan semuanya serba salah. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 byte pertama</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah panjang pesan. </font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte berikutnya</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah kode pesan. </font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16 byte berikutnya</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah pengidentifikasi permintaan (uuid). </font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">40 byte berikutnya</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah token otorisasi. </font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sisa pesan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panjang Pesan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diperlukan, karena saya tidak menggunakan http atau soket web, atau protokol lain yang menyediakan pemisahan satu pesan dari yang lain. Server frontend saya hanya melihat stream byte, dan mereka perlu tahu di mana satu pesan berakhir dan yang lainnya dimulai. Ada beberapa cara untuk memisahkan pesan (misalnya, menggunakan beberapa jenis karakter yang tidak pernah ditemukan dalam pesan sebagai pemisah), tetapi saya lebih suka menentukan panjangnya, karena metode ini paling mudah, meskipun memerlukan overhead, karena sebagian besar pesan hilang dan satu byte untuk menunjukkan panjangnya. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode pesan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hanyalah salah satu anggota enum</font></font><code>MessageCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Routing dilakukan sesuai dengan kode, dan karena kita dapat mengekstrak kode dari array tanpa deserialization awal, server frontend memutuskan di mana topik kafka untuk mengirim pesan alih-alih mendelegasikan tanggung jawab ini kepada orang lain. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ID Permintaan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hadir di sebagian besar pos, tetapi tidak di semua. Itu melakukan 2 fungsi: oleh pengidentifikasi ini, klien membuat korespondensi antara permintaan yang dikirim dan respons yang diterima (jika klien mengirim pesan A, B, C dalam urutan ini, ini tidak berarti bahwa jawaban juga akan datang secara berurutan). Fungsi kedua adalah untuk menghindari duplikat. Seperti disebutkan sebelumnya, kafka menjamin setidaknya satu kali pengiriman. Artinya, dalam kasus yang jarang terjadi, pesan masih dapat diduplikasi. Dengan menambahkan kolom RequestIdentifier dengan batasan unik ke tabel database yang diinginkan, kita dapat menghindari memasukkan duplikat. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Token Otorisasi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adalah tanda tangan UserId (8 byte) + 32 byte HmacSha256. </font><font style="vertical-align: inherit;">Saya tidak berpikir itu layak menggunakan Jwt di sini. </font><font style="vertical-align: inherit;">Jwt sekitar 7-8 kali lebih besar untuk apa? </font><font style="vertical-align: inherit;">Pengguna saya tidak memiliki klaim, jadi tanda tangan hmac sederhana tidak masalah. </font><font style="vertical-align: inherit;">Otorisasi melalui layanan lain tidak dan tidak direncanakan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggilan audio dan video</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lucu bahwa saya sengaja menunda implementasi panggilan audio dan video, karena saya yakin saya tidak akan bisa menyelesaikan masalah, tetapi ternyata itu menjadi salah satu fitur yang paling mudah untuk diterapkan. </font><font style="vertical-align: inherit;">Setidaknya fungsionalitas dasar. </font><font style="vertical-align: inherit;">Secara umum, hanya menambahkan WebRtc ke aplikasi dan mendapatkan sesi video pertama hanya butuh beberapa jam, dan, secara ajaib, tes pertama berhasil. </font><font style="vertical-align: inherit;">Sebelum itu, saya berpikir bahwa kode yang berfungsi pertama kali adalah mitos. </font><font style="vertical-align: inherit;">Biasanya pengujian pertama dari fitur baru selalu gagal karena beberapa jenis kesalahan bodoh seperti "menambahkan layanan, tetapi tidak mendaftarkannya dalam wadah DI".</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak terlalu singkat tentang WebRtc untuk yang belum tahu</font></font></b><div class="spoiler_text">WebRtc —  ,   peer-to-peer    , ,    peer-to-peer  ,     .   - ,     ,      .      ,      .<br>
<br>
          (peer-to-peer),     <i></i> ,  3   (     <i></i> ,  3  .           3 ).<br>
<br>
    — stun .   stun  ,    —  Source IP  Source Port      ,    <i></i> .    ?        - .       IP .      - , ,    ,   Source IP  Source Port    IP  -        NAT  [ Source IP | Source Port | Router External IP | Router Port ].     - ,   Dest IP  Dest Port     Router External IP  Router Port  NAT, ,    Source IP — Source Port     ,   .   , ,       ,      , ,    ,      NAT .       stun     NAT .     stun     Router External IP — Router Port.   — <i></i>   .     ,  «»    NAT (NAT traversal)  ,      NAT  ,     stun .<br>
*  NAT ,      . ,     ,  WebRtc    .<br>
<br>
  — turn.  ,       ,   peer-to-peer . Fallback .    , ,  ,  ,   ,   peer-to-peer     .    turn  — coturn,      .<br>
<br>
  — .    <i> </i>  ,    .       ,    .   —           .       .    ,          , ,     :)       —   .<br>
<br>
 WebRtc  3   : offer, answer  candidate.    offer     ,    answer,       .    , ,  ,    ,       .    (     )   ,  .<br>
</div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teknologi WebRtc sendiri membangun koneksi dan terlibat dalam mentransfer arus bolak-balik, tetapi ini bukan kerangka kerja untuk membuat panggilan penuh. Melalui panggilan, maksud saya sesi komunikasi dengan kemampuan untuk membatalkan, menolak dan menerima panggilan, serta menutup telepon. Selain itu, Anda harus memberi tahu penelepon jika pihak lain sudah diambil. Dan juga untuk mengimplementasikan hal-hal kecil seperti "tunggu jawaban panggilan N detik, lalu reset." Jika Anda hanya mengimplementasikan WebRtc dalam aplikasi dalam bentuk kosong, maka dengan panggilan masuk, kamera dan video akan menyala secara spontan, yang tentu saja tidak dapat diterima. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam bentuknya yang murni, WebRtc biasanya menyiratkan pengiriman kandidat ke pihak lain sesegera mungkin sehingga negosiasi dimulai secepat mungkin, yang logis. Dalam tes saya, kandidat untuk partai penerima umumnya </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selalu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mulai datang bahkan sebelum penawaran datang. Calon "awal" seperti itu tidak dapat dibuang, mereka harus diingat, sehingga nanti, ketika penawaran datang dan </font></font><code>RTCPeerConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dibuat, tambahkan mereka ke koneksi. Fakta bahwa kandidat dapat mulai datang bahkan sebelum penawaran, serta beberapa alasan lainnya, menjadikan pelaksanaan panggilan penuh menjadi tugas yang tidak sepele. Apa yang harus dilakukan jika beberapa pengguna menghubungi kami sekaligus? Kami akan menerima kandidat dari semua, dan meskipun kami dapat memisahkan kandidat dari satu pengguna dari pengguna lain, menjadi tidak jelas kandidat mana yang akan ditolak, karena kami tidak tahu penawaran siapa yang akan datang lebih awal. Juga akan ada masalah jika kandidat mulai datang kepada kita dan kemudian tawaran pada saat ketika kita </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sendiri</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memanggil seseorang.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah menguji beberapa opsi dengan WebRtc kosong, saya sampai pada kesimpulan bahwa mencoba membuat panggilan dalam bentuk ini akan bermasalah dan penuh dengan kebocoran memori, jadi saya memutuskan untuk menambahkan tahap lain ke proses negosiasi WebRtc. Saya menyebut tahap ini </font></font><code>Inquire - Grant/Refuse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Idenya sangat sederhana, tetapi butuh waktu cukup lama untuk mencapainya. Penelepon bahkan sebelum membuat aliran dan </font></font><code>RTCPeerConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dan umumnya sebelum menjalankan </font><font style="vertical-align: inherit;">kode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apa pun yang</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terkait dengan WebRtc) mengirim pesan melalui server sinyal ke sisi lain </font></font><code>Inquire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Di sisi penerima, diperiksa apakah pengguna sedang dalam sesi komunikasi lain saat ini ( </font></font><code>bool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bidang </font><font style="vertical-align: inherit;">sederhana </font><font style="vertical-align: inherit;">). Jika ya, maka pesan dikirim kembali.</font></font><code>Refuse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan dengan cara ini kami memberi tahu penelepon bahwa pengguna sedang sibuk, dan penerima - bahwa telepon ini dan itu dipanggil saat ia sibuk dengan percakapan lain. Jika pengguna saat ini gratis, maka itu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dicadangkan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><code>Inquire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengidentifikasi sesi dikirim </font><font style="vertical-align: inherit;">dalam pesan </font><font style="vertical-align: inherit;">, dan pengidentifikasi ini ditetapkan sebagai pengidentifikasi </font><font style="vertical-align: inherit;">sesi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saat ini</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jika pengguna dicadangkan, ia akan menolak semua </font></font><code>Inquire/Offer/Candidate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pesan dengan pengidentifikasi sesi selain yang sekarang. Setelah pemesanan, penerima mengirim pesan melalui server sinyal ke pemanggil </font></font><code>Grant</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Patut dikatakan bahwa proses ini tidak terlihat oleh pengguna penerima, karena belum ada panggilan. Dan hal utama di sini adalah jangan lupa untuk menutup waktu tunggu di sisi penerima. Tiba-tiba kami akan memesan satu sesi, dan tidak ada penawaran yang akan mengikuti.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penelepon menerima </font></font><code>Grant</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan di sinilah WebRtc dimulai dengan penawaran, kandidat, dan ini untuk semua orang. </font><font style="vertical-align: inherit;">Penawaran terbang ke penerima, dan dia, setelah diterima, menampilkan layar dengan tombol Jawab / Tolak. </font><font style="vertical-align: inherit;">Tetapi para kandidat, seperti biasa, tidak mengharapkan siapa pun. </font><font style="vertical-align: inherit;">Mereka kembali mulai datang bahkan lebih awal daripada penawaran, karena tidak ada alasan untuk menunggu pengguna menjawab panggilan. </font><font style="vertical-align: inherit;">Dia mungkin tidak menjawab, tetapi menolak atau menunggu sampai batas waktu berakhir - maka para kandidat akan diusir begitu saja.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status saat ini dan rencana masa depan</font></font></h2><br>
<ul>
<li><font color="#009c50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obrolan pribadi dan grup</font></font></font></li>
<li><font color="#009c50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengirim teks, gambar,</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan video</font></font></li>
<li><font color="#009c50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggilan audio dan video</font></font></font></li>
<li><font color="#009c50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfirmasi tanda terima dan bacaan</font></font></font></li>
<li><font color="#009c50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Cetakan ..."</font></font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notifikasi</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cari berdasarkan kode QR dan geolokasi</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pencarian dengan kode QR, secara tak terduga, cukup bermasalah untuk diterapkan, karena hampir semua plugin untuk pemindaian kode yang saya coba tolak untuk memulai atau tidak berfungsi dengan benar. </font><font style="vertical-align: inherit;">Tapi saya pikir masalahnya akan diselesaikan di sini. </font><font style="vertical-align: inherit;">Dan untuk implementasi pencarian geolokasi, saya belum mengambil. </font><font style="vertical-align: inherit;">Secara teori, seharusnya tidak ada masalah khusus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pemberitahuan sedang berlangsung, serta mengirim video.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa lagi yang perlu dilakukan?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oh, banyak. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak ada tes. Rekan kerja dulu menulis tes, jadi saya benar-benar santai. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengundang pengguna ke obrolan yang ada dan meninggalkan obrolan saat ini tidak memungkinkan. Kode server siap untuk ini, kode klien tidak. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketiga,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jika penanganan kesalahan pada server lebih atau kurang, maka tidak ada penanganan kesalahan pada klien. Tidak cukup hanya dengan membuat entri log, Anda harus mencoba kembali operasi. Sekarang, misalnya, mekanisme pengiriman ulang pesan tidak diterapkan. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keempat,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> server tidak melakukan ping klien, jadi putuskan sambungan tidak terdeteksi jika, misalnya, klien telah kehilangan Internet. Putuskan sambungan terdeteksi hanya ketika klien menutup aplikasi. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelima,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> indeks tidak digunakan dalam database.</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keenam,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> optimasi. Kode memiliki sejumlah besar tempat di mana sesuatu seperti ditulis </font></font><code>// @@TODO: Pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kebanyakan array hanya </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itu. Server backend menciptakan banyak array dengan panjang tetap, jadi di sini Anda dapat dan harus menggunakan kumpulan. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketujuh,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ada banyak tempat di klien tempat kode </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berakhir, meskipun ini tidak perlu. Mengirim gambar, misalnya, karena itu tampaknya lambat karena kodenya</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini menyimpan gambar ke sistem file dan menghasilkan thumbnail sebelum menampilkan pesan, meskipun tidak ada yang perlu dilakukan. Atau, misalnya, jika Anda membuka aplikasi dan selama Anda tidak ada, mereka mengirim gambar kepada Anda, startup akan lambat, karena sekali lagi semua gambar ini diunduh, disimpan ke sistem, thumbnail dihasilkan, dan hanya setelah itu startup berakhir dan Anda terlempar dari layar splash di layar beranda. Semua ini berlebihan </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dibuat untuk memudahkan debugging, tetapi, tentu saja, Anda harus menyingkirkan menunggu yang tidak perlu sebelum rilis. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedelapan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UI sekarang setengah siap, karena saya belum memutuskan bagaimana saya ingin melihatnya. Karena itu, sekarang semuanya tidak intuitif, setengah dari tombol tidak jelas apa yang mereka lakukan. Dan tombol sering kali tidak ditekan pertama kali, karena sekarang mereka hanya ikon dengan </font></font><code>GestureDetector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan tanpa bantalan, jadi tidak selalu mungkin untuk masuk ke dalamnya. Ditambah di beberapa tempat, pixel overflow tidak diperbaiki. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesembilan,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sekarang bahkan tidak mungkin untuk Masuk ke akun, hanya Mendaftar. Karenanya, jika Anda menghapus aplikasi dan menginstalnya kembali, Anda tidak akan dapat masuk ke akun Anda :) </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesepuluh,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kode verifikasi tidak dikirim ke surat. Sekarang kode umumnya selalu sama, lagi karena lebih mudah untuk di-debug. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesebelas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prinsip tanggung jawab tunggal dilanggar di banyak tempat. Butuh refactor. Kelas-kelas yang bertanggung jawab untuk berinteraksi dengan database (baik pada klien dan di server) umumnya sangat membengkak, karena mereka terlibat dalam </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semua</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operasi database. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keduabelas,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> server frontend sekarang selalu mengharapkan respons dari server backend, bahkan jika pesan tidak menyiratkan mengirim respons (misalnya, pesan dengan kode </font></font><code>IsTyping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan beberapa pesan yang berhubungan dengan WebRtc). Karena itu, tanpa menunggu jawaban, ia menulis kesalahan ke konsol, meskipun ini bukan kesalahan. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketigabelas,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gambar penuh tidak terbuka saat diketuk. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seratus juta perlima</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beberapa pesan yang perlu dikirim dalam batch dikirim secara terpisah. Hal yang sama berlaku untuk beberapa operasi basis data. Alih-alih mengeksekusi satu perintah, perintah dieksekusi dalam satu lingkaran dengan </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(brr ..). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seratus juta keenam,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beberapa nilai di-hardcode, alih-alih dapat dikonfigurasi. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seratus satu juta tujuh</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">logging di server sekarang hanya untuk konsol, dan pada klien secara umum, langsung ke widget. Di layar utama ada tab Log, di mana semua log di tekan dijatuhkan. Faktanya adalah bahwa mesin saya menolak untuk menjalankan emulator dan semua yang diperlukan untuk server (kafka, database, lobak dan semua server). Debit dengan perangkat yang terhubung juga tidak berhasil, semuanya hanya tergantung erat pada separuh kasing, karena komputer tidak dapat mengatasi bebannya. Karena itu, Anda harus membuat build setiap saat, memasukkannya ke perangkat, menginstal dan menguji seperti ini. Untuk melihat log, saya taruh di widget. Penyimpangan, saya tahu, tetapi tidak ada pilihan. Untuk alasan yang sama, banyak metode kembali </font></font><code>Future</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mereka (untuk menangkap pengecualian dan melempar ke widget), meskipun seharusnya tidak. Jika Anda melihat kode, Anda akan melihat </font></font><code>_logError</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode </font><font style="vertical-align: inherit;">jelek </font><font style="vertical-align: inherit;">di banyak kelas yang melakukan ini. Ini, tentu saja, juga akan dibuang ke tempat sampah. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seratus juta delapan,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak ada suara. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seratus juta sembilan,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda perlu menggunakan caching lebih banyak. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seratus juta persepuluh,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> banyak kode berulang. Misalnya, banyak tindakan pertama-tama memeriksa validitas token, dan jika tidak valid, mereka mengirim kesalahan. Saya pikir Anda perlu menerapkan middleware-pipeline sederhana. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan banyak hal-hal kecil, seperti string gabungan daripada menggunakan </font></font><code>StringBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'a,</font></font><code>Dispose</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak di mana-mana disebut di mana seharusnya, dan seterusnya dan seterusnya. </font><font style="vertical-align: inherit;">Secara umum, keadaan normal proyek sedang dalam pengembangan. </font><font style="vertical-align: inherit;">Semua hal di atas dapat diselesaikan, tetapi ada satu masalah mendasar yang tidak saya pikirkan sampai saat terakhir, karena itu keluar dari kepala saya - messenger harus bekerja bahkan ketika aplikasi tidak terbuka, dan milik saya tidak berfungsi. </font><font style="vertical-align: inherit;">Sejujurnya, solusi untuk masalah ini belum terlintas di pikiran saya. </font><font style="vertical-align: inherit;">Di sini, tampaknya, Anda tidak dapat melakukannya tanpa kode asli. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya akan menilai kesiapan proyek di 70%.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ringkasan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enam bulan telah berlalu sejak awal pengerjaan proyek. </font><font style="vertical-align: inherit;">Dikombinasikan dengan pekerjaan paruh waktu dan mengambil istirahat panjang, tetapi masih membutuhkan waktu dan energi yang cukup. </font><font style="vertical-align: inherit;">Saya berencana untuk mengimplementasikan semua fitur yang dideklarasikan + menambahkan sesuatu yang tidak biasa seperti tic-tac-toe atau draft tepat di ruangan. </font><font style="vertical-align: inherit;">Tanpa alasan, hanya karena itu menarik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda memiliki pertanyaan, tulis. </font><font style="vertical-align: inherit;">Mail ada di github.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id490052/index.html">Aplikasi iOS dapat mencuri data dari clipboard perangkat + survei pemantauan ancaman MacOS</a></li>
<li><a href="../id490056/index.html">Black Box: lupakan tentang logging</a></li>
<li><a href="../id490060/index.html">Grafik pencarian pengetahuan: membangun dari berbagai sumber</a></li>
<li><a href="../id490066/index.html">Dari Cina ke Kutub Selatan: Menggabungkan kekuatan untuk memecahkan teka-teki massa neutrino</a></li>
<li><a href="../id490068/index.html">Pemalsuan keacakan dan transformasi dengan menyortir urutan pseudo-acak</a></li>
<li><a href="../id490076/index.html">Klasifikasi olahraga disiplin e-sports</a></li>
<li><a href="../id490080/index.html">Bagaimana pesaing dapat dengan mudah memblokir situs Anda</a></li>
<li><a href="../id490082/index.html">Analisis Kode Genetik I</a></li>
<li><a href="../id490084/index.html">Memahami Spesifikasi Naskah ECMAS, Bagian 1</a></li>
<li><a href="../id490086/index.html">Panduan Surf Pemula atau Programmer's Life di Portugal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>