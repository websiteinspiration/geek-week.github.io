<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêí üë®‚Äçüëß‚Äçüëß üíÄ Multithreaded Linear List: Element Existence Problem, Productivity Improvement, and STL Relation ‚å®Ô∏è ‚úäüèæ üëà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear visitors of Habr! 
 
 This article will focus on a linked list, multithreading, and C ++. I note right away that there was every chance to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Multithreaded Linear List: Element Existence Problem, Productivity Improvement, and STL Relation</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506716/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello, dear visitors of Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This article will focus on a linked list, multithreading, and C ++. I note right away that there was every chance to put this work on the shelf and use it in a small number of personal projects. Instead, I still decided to put it on the court of the public - all of a sudden it really seems useful or interesting to someone. Moreover, if it turns out that someone has already managed to do something like this, please indicate these materials to me, please. However, no matter how I tried to google on this topic, all attempts were unsuccessful.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I also note that this will not be about the classic linked list, but about my creative rethinking of the use of this data structure in a multi-threaded environment. I was considering a scenario of unordered intensive multi-threaded list access. This means that any thread at any time, regardless of others, can access the list and perform the required operations. If he only adds or changes elements, this is not so bad. If he also removes the elements, various interesting features may arise.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This project, which I was engaged in as a hobby and self-development, for a number of reasons lasted for a very long time. </font><font style="vertical-align: inherit;">In addition, as I worked on it, I studied intensively: the project started without the knowledge and understanding of STL and was designed accordingly, using only the internal means of the C ++ language itself. </font><font style="vertical-align: inherit;">However, then I very seriously modified it taking into account STL and even under STL. </font><font style="vertical-align: inherit;">What I got out of this, judge you, dear readers.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the most complete understanding of the material described here, you will need to read the following books:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexandrescu A. - ‚ÄúModern Design in C ++‚Äù.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richter D., Nazar K. - ‚ÄúWindows via C / C ++, Visual C ++ Programming‚Äù.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josattis N. - ‚ÄúC ++ Standard Library. </font><font style="vertical-align: inherit;">Reference guide. </font><font style="vertical-align: inherit;">Second Edition ‚Äùor similar book on STL.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Line list</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A linear list is a well-known data structure that has been used since the time of the C language and earlier. Its element is a certain object in memory that has connections with one or two neighboring similar elements - here is an example for a doubly linked list:</font></font><br>
<br>
<pre><code class="plaintext hljs">struct ListItem<font></font>
{<font></font>
    &lt;‚Ä¶   ‚Ä¶&gt;<font></font>
    List *pNext;<font></font>
    List *pPrev;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Accordingly, the list itself is a certain (sub) program that performs manipulations with these elements. </font><font style="vertical-align: inherit;">As a rule, a pointer to the beginning and, optionally, to the end of the list is known: this is enough to, starting from the first element, go through all its elements to the end. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, I am describing already well-studied and well-known information: it was an educational program for those who were completely unaware. </font><font style="vertical-align: inherit;">For details, for example, you can contact here: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linear list (Wikipedia)</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
The STL library has such a wonderful container std :: list (doubly linked list), as well as its twin - std :: forward_list (singly linked list). </font><font style="vertical-align: inherit;">That is, if you are not interested in how the list is organized and functions inside, and you want to just use it for your tasks, the proposed containers are your option.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But there is one thing but ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multithreading issues</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I repeat that when I started to analyze this topic, I was going to do everything, relying only on C ++ internal tools without any STL support. </font><font style="vertical-align: inherit;">The value of what would happen would be lower if I still decided to talk about it here. </font><font style="vertical-align: inherit;">But on the other hand, I was completely free from any concepts or limitations of the library, and therefore was not bound by anything and looked for approaches with an open mind and independence.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Previously, in the distant, distant past, the vast majority of computers were single-core and single-processor. The linear list was a relatively simple and transparent data structure, and working with it did not cause any particular difficulties. Now even smartphones have become multi-core. Under multithreading conditions, even such a simple structure as a linked list is seriously complicated. Ensuring the correct operation in multi-threaded mode generally seriously complicates any program, this is a known fact.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Take an abstract scenario of intensive work with a list of different threads: each of them can add, delete, change elements, etc. at a completely arbitrary point in time. On the one hand, the work with the list in this case should be primarily safe: if there are any data violations and undefined behavior of the program, this will be a completely inappropriate solution. On the other hand, I would very much like to work with him as quickly as possible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To solve the first problem, the list will obviously have to be blocked somehow, as well as synchronize access to it. The second problem - performance - is deferred for now.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This article only considers blocking the entire list by a stream for exclusive access of the stream to it. Other options seemed dubious, for example, for the following reasons. Suppose we have a doubly linked list, and we decided to remove the item from it. To do this, you must block the node itself, as well as the previous and next. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At this very time, before the start of the operation, another thread deletes just, for example, the previous node. We block the removed one and stop waiting for the release of the previous node blocked by another thread. And he is blocked on waiting for the next for him, i.e. our deleted node. That's it, it's a deadlock. So this method is not reliable.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If your threads do not store any pointers (or iterators) to specific nodes, then the task is extremely simplified. In fact, you can only do with STL tools. The stream blocks the list, refers to any element in it (for example, from the beginning, from the end, or by searching in it according to some criteria), processes or removes this element, adds any new ones without saving links to them, and then completes the list. All this - exclusively blocking access to the list in one thread, owning it for the duration of the required operations. In this case, it is perfectly logical to use std :: list and library locking facilities. For all this, it should be noted that while your thread does all the required work, other threads will stop waiting, i.e. work with the list will be carried out in single-threaded mode.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I considered another, more complex scenario, when a thread stores a pointer or iterator to the element it needs. </font><font style="vertical-align: inherit;">For example, your program works on some complex calculations, taking the initial data from the list item, and then, after processing, updates its value, adding the calculation results there. </font><font style="vertical-align: inherit;">However, other threads also have access to the same list. </font><font style="vertical-align: inherit;">I did not make any assumptions about the nature of the application: another thread can easily delete this element for some reason. </font><font style="vertical-align: inherit;">Or move it to another place. </font><font style="vertical-align: inherit;">Thus, working with a list becomes problematic not only for the usual reasons of multithreading and synchronization.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem of the existence of an element</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is the fundamental difference between a list and, say, an array? In a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">distributed</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arrangement of list items. All elements of the array are located in a single memory area. Even if you store a pointer to some of its elements, you are sure that access to its address will be correct (of course, if the array was not moved in memory to another location with an extension of its size, for example). If the element you need is deleted or moved to another thread, you simply go to the previous address, you will understand by some signs that the element you need is not here, then try to search for it, etc. Of course, the program must support such an opportunity in advance. But, in any case, its operation will remain correct as long as you are in the correct memory limits.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A completely different situation is in the case of a list (as well as in the case of a tree, graph - any data structure with distributed elements). If an element according to your pointer was deleted in another thread, you won‚Äôt even know about it, and if you try to access its address, you will receive an access violation (at best). Even if it is not actually deleted from the memory (for example, if smart pointers are used), it will be deleted from the list, i.e. will not be part of it. You will not know about this either. Correct work with the list is broken. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the same time, intensive multi-threaded work with the list creates absolutely fantastic scenarios. You can even be sure that everything is fine with your element and a pointer to it - up to accessing some list function for working with it.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Example. Let there be a part of the list, and a pointer to the node, which we denote as (#), is transferred to some function-list method, while the nodes associated with it will be denoted by relative numbers relative to it. At the time the function is called, it is known that this element exists and the pointer to it is correct, that is, the state of the list in this area is: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now, let the node (#) be passed as a parameter to some list function. This function, as usual, is blocked while waiting for access to it. While she waited, three threads worked before her, deleting the node (#) together with the adjacent ones so that it happened: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yx/cx/x8/yxcxx8a21cbn2zlzko2uxgfzsb8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then another 5 threads inserted 5 more elements into the list, starting with (-2). We denote the new elements as (nN), where N is the relative number among the five, starting from zero:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then finally our stream gets called, which was called with (#). The question is: what should he do in this case, after all (#) has long been gone? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Answer: it all depends on the operation, as well as on the scenario for using the list. However, since we are considering the most general case without any restrictions, some general assumptions can be made.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If this is a delete operation, then it is enough to simply check whether the specified item is present in the list. If not, then it has already been deleted, and nothing else needs to be done. If yes, then delete. Similarly, for the operation of reading / changing the contents of the node: if the node is deleted, then there is already nothing to read / modify. But the biggest problems arise with the operations of inserting a new node, as well as when moving to the next / previous. On the one hand, the specified node is no longer there, and failure can be returned. On the other hand, the node must be inserted, and such a situation can occur at any time.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since the priority (for the general case) is still safety and reliability, and only then speed, it is obvious that when the thread finally got the operating time inside the function, you have to establish the fact of the presence of an element in the list: does it even exist there or not already? This solves one problem: at least we will not disrupt the entire list if there is no requested node there and we will avoid memory access errors in this regard. But it does not solve the problem of insertion and transitions: it is not clear where to insert a new node and go from an already deleted one.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The solution to the problem of the existence of the element will be discussed in detail below. </font><font style="vertical-align: inherit;">The question of what to do when we find that the element is no longer there, but it is really needed, is beyond the scope of this article, since it entirely depends on the algorithm of the list-using program. </font><font style="vertical-align: inherit;">Of course, it should include such scenarios and corresponding reactions to them: for example, if there is no element, then go to the top of the list or perform some other operation. </font><font style="vertical-align: inherit;">The main thing that needs to be ensured in this situation is the correct and safe operation of the list, as well as notification of such situations.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direct item search</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The simplest and most straightforward approach is to check the presence of an element in the list by sequentially passing through it in search of a given element. Those. just looking for the given element. If he is on the list, we work with him. If not, then, depending on the function, we exit with success or failure, and let the calling program decide what to do in this situation. The main thing is that the work with the list in any case will be correct. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This method is safe and fully functional, but, especially for large lists, it leads to a catastrophic drop in performance. In fact, working with a list turns out to be single-threaded: the list is blocked for the duration of the search for a given element in it, and other threads cannot access it. Secondly, overheads increase sharply - in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">each</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operations with the list have to check whether there is an element that is needed at the time of the operation, and a huge fraction of the time is spent not on useful work, but on checking the presence of an element. </font><font style="vertical-align: inherit;">Nevertheless, this simple, straightforward approach is quite suitable for lists of small volume and not too intensive operations with it, as well as a first approximation to solving the problem of the existence of an element. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But what if we have a list with a large number of elements, and work with it is very intensive: do many threads constantly add, change and delete elements from it? </font><font style="vertical-align: inherit;">Is there any way to speed it up somehow?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory or performance</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is a well-known fact that an increase in the memory used by the program can increase the speed of the program. For example, a program makes heavy use of the results of some calculations. Instead of executing them all over again, you can calculate everything in advance and save their results in some table or array. Then the program simply accesses the desired cell in the table and immediately receives the desired value, which significantly speeds up its work.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is this approach that I used in the case of the list. Create a bitmap. Add to the service information of each of its elements, in addition to the required pointer to the next and, optionally, the previous element, two more new fields: the first is its unique number within this list, and the second is a pointer to the list itself. Now, when an element is created, it is assigned a unique number, and sets the unit in the bitmap at the corresponding index. When an element is deleted, this bit is reset. The number of the created element is constantly increasing each time a new element is created - already used zeroed bits are not reused.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now, when you need to check for the presence of a given element, instead of searching it linearly in the entire list, you simply access the bitmap by the index of this element in it, and the fact of its presence is immediately established, and for a constant time, independent of the size of the list. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This method allows you to achieve maximum performance, however, it has its serious drawbacks. First, you will have to allocate memory for the entire array at once, part of the bits of which may not be needed at all during the program, but this memory could be used for other needs. This problem and a way to smooth out memory overruns will be discussed below.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second drawback is more serious and interesting - each new list item is created by a monotonously increasing number. This means that sooner or later the free bits of the array will be exhausted. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At this point, unfortunately, you have to stop, block the list and start serving it. Those. compress the bits of this array, removing all zero bits from intermediate previously deleted list elements, leaving only bits for the elements that actually exist at the moment, shifting all these bits to the beginning of the array. We'll have to go through the entire list again, and in single-threaded mode, rewriting all the indices for each element. The obvious benefit of this compared to the previous approach is that in this case only </font><b><font style="vertical-align: inherit;">one</font></b><font style="vertical-align: inherit;"> will be done.</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">times over a long period of time. </font><font style="vertical-align: inherit;">Further, the list can continue to work as before in extremely fast mode. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, I do not mean that the nodes were only added to the list, because </font><font style="vertical-align: inherit;">in this case, all bits of the array will be single. </font><font style="vertical-align: inherit;">I am considering a scenario where items are intensively and arbitrarily deleted and added. </font><font style="vertical-align: inherit;">Those. </font><font style="vertical-align: inherit;">the total number of list items from the beginning of its work may change slightly. </font><font style="vertical-align: inherit;">Naturally, the question of choosing the size of the array depends on the nature of the program. </font><font style="vertical-align: inherit;">You can also always create a new array of a larger volume if the size of the current one is not enough.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using zero bits from previously deleted elements</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can do it in another way: when creating an element, look for the first zero bit from the beginning of the bitmap. This optimizes memory consumption, but will lead to a drop in performance: now again each time you create a new element, you will have to do additional work - look through the array in search of a free bit. But in comparison with checking for the presence of an element by directly viewing the list, the gain is obvious: we will look at the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">array</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adjacent elements, and each element of such an array contains many bits, i.e. </font><font style="vertical-align: inherit;">we process many list nodes at a time (64 bits for modern systems or even 128/256/512 if using SSE / AVX). </font><font style="vertical-align: inherit;">We are looking for the first word that is not equal to the word with all unit bits, then we are looking for the first zero bit in this word. </font><font style="vertical-align: inherit;">In fact, this method is intermediate in speed between the previous one and the direct viewing method.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory consumption optimization for unoccupied array bits</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suppose we assume a long and intensive work with the list, allocating a huge array of bits for it. But it so happened that in fact the program worked differently: it accessed the list rarely, performed other operations that also required memory. As a result, we get an almost unused array of bits of huge volume and memory problems in other parts of the program. Sheer inconvenience! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linux, as far as I can tell, automatically solves this problem (although experienced Linux developers let me fix it, if that). You allocate memory for the array, but in fact the system </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not transfer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> this memory to the array </font><font style="vertical-align: inherit;">until it is really needed. There is an optimization of memory usage. Windows does not allow this. Rather, it allows, but you have to do it yourself.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For those who are not at all up to date, I‚Äôll explain: your application (more precisely, the process corresponding to it), the system allocates a </font><font style="vertical-align: inherit;">large </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtual address space</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - up to 8 TB for 64-bit Windows. The physical memory in the system can be much less - 8 or 16 GB at the moment for mass computers. Operating system </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">displays</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">addresses of your virtual process space to physical memory addresses, doing this in a transparent manner without your direct involvement. Naturally, most of the free virtual memory of a process is usually unoccupied. So, when you ask Windows to allocate memory by conventional means, it simultaneously allocates this memory both in your virtual space and in physical memory. If you allocate a large volume bitmap, you run the risk of immediately occupying all available memory on your machine without guaranteeing that this memory may be needed at all.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, one can act differently: mark up a huge portion of memory in the virtual space of the process, but transfer physical to it only when it is really needed. </font><font style="vertical-align: inherit;">This can be done through structural exception handling in Windows; for details, please refer to the book by Richter D., Nazar K. - ‚ÄúWindows via C / C ++, Visual C ++ Programming‚Äù.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This would be only an idea and a theory if I had not put all these ideas into practice, and not in the form of a simple experimental program: I did it as carefully as possible for production, intending to use it in my real projects, therefore it is in this form that you need it and imagine. </font><font style="vertical-align: inherit;">I thought that it would be unfair and too selfish to apply what was done in my limited number of projects if this could be useful or at least just interesting to a wide circle of developers. </font><font style="vertical-align: inherit;">On the other hand, the creators of the Boost library and other more specialized libraries offer their work to everyone absolutely free. </font><font style="vertical-align: inherit;">Why can't I do the same?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstraction - a list without data</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I divided the list into two logical levels. The first level is a list, each element of which does not contain any useful data, but contains only auxiliary information: pointers to neighboring elements, and, optionally, those two additional fields to speed up the check for the presence of an element in the list. However, already at this level it is possible to perform all basic operations on a list: adding and deleting elements, splitting and merging lists, etc. In fact, I focused primarily on this level. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second level is adding actual data to the list item, as well as adding new operations to the list to work with this data. All this is provided in C ++ by inheritance. But the details will be discussed below.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Such a breakdown of the implementation into two levels made sense: why take into account the availability of specific data if a number of operations are completely independent of this data? For any given list items, you still have to delete them and add new ones to the list, as well as perform other typical operations. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I started with an extremely simple and uncomplicated concept, taken from the C language construction at the beginning of the article. Both C and C ++ internal pointers are used both inside and outside the list. The only difference was that the addition of data, as indicated above, was postponed to a later date. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let there be an element of the list without data, containing only a pointer (or pointers) to the neighboring element (s). Then the corresponding code for it can be schematically represented as follows:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span>	<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListElement_OneLinked</span>			//   ( )
{</span>
	ListElement_OneLinked *pNext;	<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>		// 
{</span>
	<span class="hljs-comment">//</span><font></font>
<font></font>
        <span class="hljs-comment">//   </span>
	ListElement *pFirst = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span>
	ListElement *pLast = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span><font></font>
<font></font>
	SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//    </span><font></font>
<font></font>
	&lt;‚Ä¶m- () &gt;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An element for a singly linked list contains inside itself a pointer to the next element, and nothing more. The list class is parameterized by the type of this element, implying that this type will be changed at the stage of adding data. It contains pointers to the first and last elements inside. Since I originally targeted this project for Windows only, a critical section like SRWLock is also included to block the list. Next, the constructors, the destructor, as well as all the necessary functions for working with the list are defined. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This implementation contains two problems at once. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first is open access to the content of the service information of the element. This means that, having gained access to some node, i.e. having a pointer to this node, we can directly refer to the next or previous element.</font></font><br>
<br>
<i>       <b></b>.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is unacceptable mainly because this transition is bypassing the lock and, therefore, protecting the list. In fact, suppose that having a pointer to some pCurr element, we saved the value to the next element relative to it in the pNext pointer as follows: pNext = pCurr-&gt; pNext. After that, we perform some lengthy operation on this pCurr node. At the same time, other threads removed the following list items regarding pCurr. Having finished working with pCurr, the current thread moves to the next element using the old value stored in the local pNext and receives an access error or undefined behavior, since the element at the local pNext address no longer exists, and you need to access the updated value pCurr-&gt; pNext, if the current item at pCurr, in turn,also still exists.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Two conclusions can be drawn from this example to prevent this situation:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from outside the list, go to the next / previous node and generally do any work with list elements only through functions (methods) of the list class that lock the list and make access to the list safe;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to get access to elements as soon as possible immediately before accessing them (for example, to get a pointer to the next element pNext = list.GetNext (pCurr) not in advance, but immediately before the need to move to the next node appears).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is why in order to implement the conclusion from the first paragraph, access to pointers to adjacent elements from the outside should be prohibited:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement_OneLinked *pNext;		<span class="hljs-comment">//    	</span><font></font>
<font></font>
<span class="hljs-keyword">friend</span> List_OneLinked;    <span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second problem is a bit more delicate. To understand it, the structure of classes should be described in more detail. The list class is defined as template and does not work with elements of the ListElement_OneLinked type, but with the ListElement type, passed as a template parameter. This is done in order to be able to create new nodes with data inside the class. In order to do this, you need to know the exact type of node being created. The exact type of the list node is not yet known: it will be determined later along with the data. The element creation function allocates memory for it, initializes pointers, and then returns a pointer to the created element in the calling function. So in the calling function of the derived class it will be possible to initialize other properties of the element that are specific to this class and are later defined. In other words,an exact definition of the type of the list node is left for the future, and in order for the list to function correctly, it is only important that its elements contain the pNext pointer, the rest does not matter so far.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, based on ListElement_OneLinked, subsequently by inheritance, a new class will be created for the element with specific data and passed to the List_OneLinked class through the template parameter. At the same time, a new derived class will be created based on List_OneLinked that further defines operations with this new data. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, even this option is not entirely correct. In earlier versions of the list class, an explicit conversion operation of the reinterpret_cast &lt;ListElement *&gt; (...) type was used several times. The fact is that the template class works with the ListElement template parameter type, which is derived from ListElement_OneLinked / ListElement_TwoLinked. And in class functions, variables are created in expressions of the type: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ListElement * pNext = pCurr-&gt; pNext;</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And pCurr-&gt; pNext here is a pointer to ListElement_OneLinked / ListElement_TwoLinked, as members of the base classes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Output: Either declare a variable indicating the explicit base type ListElement_OneLinked / ListElement_TwoLinked, or cast it to the derived type explicitly. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, even an explicit definition of the base type is not correct, for example, in the list deletion (cleaning) function:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   </span><font></font>
ListElement *pCurr = pFirst;<font></font>
ListElement *pNext = <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
{<font></font>
	pNext = <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr-&gt;pNext);
	<span class="hljs-keyword">delete</span> pCurr;<font></font>
	pCurr = pNext;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you change the type of pointers:</font></font><br>
<br>
<pre><code class="cpp hljs">ListElement_OneLinked *pCurr = pFirst;<font></font>
ListElement_OneLinked *pNext = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
this will mean that they will be deleted by the operation</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> pCurr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
only the base parts of each node in the list, which is wrong. </font><font style="vertical-align: inherit;">Or, as an option, the pCurr pointer will have to be converted to its derived type:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, in any case, one cannot get rid of the explicit reinterpret_cast transformation with such a class structure, which is not the best solution (more precisely, which is really bad). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For this reason, in order to get rid of such explicit transformations, it was decided to change the base class for the element (for a doubly linked list - similarly):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement *pNext;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">friend</span> List_OneLinked&lt;ListElement&gt;;	<span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Briefly, this can be described as follows: the basic element of the list contains a pointer to another element, but the type of this pointer is not yet known, because it is passed by the template parameter (an exact definition of this type is left for the future). In other words: at this stage, the type of list node (i.e. what it will be in the end) has not yet been determined, it will be determined later. But now we keep the pointer to an element of the future, not yet known type. The resulting type of the list node is passed here as a template parameter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now, no conversions are needed, since pointers of the same ListElement type are used everywhere - both in the list class and in the class for nodes. The ListElement here and in the list class is the final class for the item with specific data.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This means that now the list class has become as abstract as possible from its specific contents: it is only known that its nodes contain pointers to other such nodes, and using this information, all basic operations on them with the corresponding multi-threaded lock are performed in the list class.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solving the problem of the existence of an element - a simple search (version 01.03.2018)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first version was extremely simple and straightforward and did not go beyond the framework described above. </font><font style="vertical-align: inherit;">C ++ internal pointers were used, memory for elements was allocated using the new operation and deleted using delete, the list was blocked on the critical section contained in it. </font><font style="vertical-align: inherit;">I did not know or suspect about the means of the STL library, and also about the level at which they bring programming in C ++.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Already at this stage, in practice, I ran into the problem of the existence of an element described earlier and realized that simply locking the list is not enough. </font><font style="vertical-align: inherit;">I navigated the list using the appropriate functions with all the precautions, the list was correctly blocked, but the program still successfully crashed at different intervals. </font><font style="vertical-align: inherit;">It was then that I found out that the presence of an element would have to be checked, which led to a change in the logic of key functions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let me give an example of the function of adding an element after a given one:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">ListElement* <span class="hljs-title">AddAfter</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-title">throw</span> <span class="hljs-params">(FailElemCreation, Nullptr, NotPartOfList)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();			<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListExclusive();<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (!FindElement(pElem, <span class="hljs-literal">true</span>))<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
	}<font></font>
<font></font>
	ListElement *pCurr = <span class="hljs-keyword">new</span> ListElement;
	<span class="hljs-keyword">if</span> (!pCurr)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> FailElemCreation();		<span class="hljs-comment">//        </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (pFirst == <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		pFirst = pLast = pCurr;<font></font>
		pCurr-&gt;pNext = <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
	<span class="hljs-keyword">else</span><font></font>
	{<font></font>
		<span class="hljs-comment">//         </span><font></font>
		ListElement *pNext = pElem-&gt;pNext;<font></font>
		pElem-&gt;pNext = pCurr;<font></font>
		pCurr-&gt;pNext = pNext;<font></font>
		<span class="hljs-comment">//,     </span>
		<span class="hljs-keyword">if</span> (pElem == pLast)<font></font>
			pLast = pCurr;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListExclusive();<font></font>
<font></font>
	<span class="hljs-keyword">return</span> pCurr;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is seen that before creating a new element, it checks whether the specified element is present in the list by calling the FindElement (...) function:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FindElement</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-title">throw</span> <span class="hljs-params">(Nullptr)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();	<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span><font></font>
	ListElement *pCurr = pFirst;<font></font>
	<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (pCurr == pElem)<font></font>
		{<font></font>
			bResult = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">break</span>;<font></font>
		}<font></font>
		pCurr = pCurr-&gt;pNext;<font></font>
	}<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">return</span> bResult;<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further complication of multithreaded list classes - strategy classes (version 18.02.2019, 11.27.2019)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initially, the project aimed strictly at Windows. But at some point I thought, why not add flexibility to it? Why only windows? After all, the list was essentially implemented in pure C ++, from Windows it had only one thing: the critical section of SRWLock. By that time, I had already become familiar with the concept of strategy classes. You can read about this in detail in the book Alexandrescu A. - "Modern design in C ++." It describes many unusual and amazing things that can be useful even now, despite the fact that the book is already 12 years old. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of them is the classes of strategies. Classes of strategies, in fact, are changes in the behavior of a class through templates, as B. Straustrup mentioned in his famous book. Only in the book of Alexandrescu, this topic is widely disclosed.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suppose your class performs one specific action. </font><font style="vertical-align: inherit;">You can take the definition of this action outside the class, create a separate class based on this action and pass it to your source class as a template parameter. </font><font style="vertical-align: inherit;">This complicates the code, its reading and understanding, but significantly adds flexibility to your class: to replace this particular action with some other, similar one, you just need to write another similar strategy and pass it to your class as a template parameter. </font><font style="vertical-align: inherit;">The rest of the work will be done by the compiler.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lock strategy</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Applying this to the described list, I took the lock through SRWLock into a separate strategy, and then wrote several other strategies: through the usual critical section of Windows, through C ++ STL mutexes, etc. </font><font style="vertical-align: inherit;">Then it will be possible to add purely Linux-specific methods. </font><font style="vertical-align: inherit;">Thus, the class has become suitable not only for Windows, but I can always very quickly reconfigure it back for Windows in an optimal way, just by specifying the desired strategy.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//    SRWLock</span>
<span class="hljs-comment">//     SRWLock -   ,      (      </span>
<span class="hljs-comment">//   : ++11)</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLockingWin_SRWLock</span>			//    <span class="hljs-title">SRWLock</span>
{</span>
	<span class="hljs-keyword">mutable</span> SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//     SRWLock</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ThreadLockingWin_SRWLock(<span class="hljs-keyword">bool</span> bInitialize = <span class="hljs-literal">true</span>)<font></font>
	{<font></font>
		<span class="hljs-comment">//; bInitialize -  ,     </span>
		<span class="hljs-keyword">if</span>(bInitialize)<font></font>
			InitializeSRWLock(&amp;csSRW);		<span class="hljs-comment">//   SRWLock</span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Lock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>						<span class="hljs-comment">//  </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Unlock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//  </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory strategy</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Around this point, I also seriously began to study STL and among the first tools of this library I got acquainted with smart pointers. </font><font style="vertical-align: inherit;">And then I thought: why can't I add smart pointer support to my list? </font><font style="vertical-align: inherit;">Then I took out the type of pointer, as well as creating and deleting the data of the list item in a separate strategy:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        C/++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>   <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type[]&gt;   //   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type[size];
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>	  <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span> ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span>[] ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = Type * ;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;			<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = ptrType;		<span class="hljs-comment">//   </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-comment">// : Args - -     Type</span>
		<span class="hljs-comment">// :      Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//   ,       </span>
		<span class="hljs-comment">// : pObject -      , DeleterFunc -   -</span><font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pObject)<font></font>
		{<font></font>
			Deleter::Delete(pObject);		<span class="hljs-comment">//     </span>
			pObject = <span class="hljs-literal">nullptr</span>;<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> &amp;obj;<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A similar strategy for smart pointers:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        shared_ptr/weak_ptr ++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type&gt;(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type[]&gt;(size);
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;					<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;						<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;				<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = <span class="hljs-built_in">std</span>::weak_ptr&lt;Type&gt;;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      ;   -  ,    ,    </span>
		<span class="hljs-comment">// </span>
		Deleter::Delete(pObject);	<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;(&amp;obj);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The memory strategy takes three parameters: the type of the Type object, as well as a memory allocator and remover. Based on the type of the object, the strategy creates a type of a pointer to this type - either Type * or std :: shared_ptr, depending on the strategy, and also offers the corresponding functions for creating and deleting the object. These functions, if we talk about distributors and deletors by default, create an object either through the new Type operation or through the std :: make_shared (...) function. All this works due to the fact that pointer dereferencing is the same for both the C ++ built-in pointer and the smart std :: shared_ptr. Of course, in the case of a doubly linked list and smart pointers, to avoid the unpleasant feature of looping pointers, std :: weak_ptr is used for pointers to the previous element,and at compile time for a doubly linked list, depending on the selected memory strategy, you choose how to dereference it (this is a new feature of C ++ 17):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  pPrev  weak_ptr,          shared_ptr    lock()</span>
<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, SmartSharedPointer&lt;ListElement&gt;&gt;)</span>		<span class="hljs-comment">//C++17: if constexpr</span>
	pFirst-&gt;pPrev.<span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>= <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">else</span>
	pFirst-&gt;pPrev = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, now the list does not create its own elements: it redirects the call to the corresponding strategy.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Item Availability Strategy</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, I put the solution to the problem of the existence of the element into a separate strategy: if the list needs to check for the presence of some of its elements, it simply redirects the call to the corresponding strategy. The very first, straightforward and clumsy approach has become a DirectSearch direct search strategy. Next, I developed two more strategies based on the two approaches described earlier with a bitmap in the order of their description: SearchByIndex_BitArray and SearchByIndex_BitArray2. For Windows, for the possibility of gradually occupying the memory with a bitmap as it is filling, he also added two more strategies: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SearchByIndex_BitArray_MemoryOnRequestLocal and SearchByIndex_BitArray2_MemoryOnRequestLocal.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As noted earlier, for these advanced strategies to work, the list item must contain an index in the bitmap and a pointer to the base class of the list (see below), i.e. </font><font style="vertical-align: inherit;">was defined as follows:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//          </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked_CP</span>			//   ( )
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext;	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex;	<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt; *pList;		<span class="hljs-comment">//  - </span><font></font>
<font></font>
	<span class="hljs-comment">//          ;    ,   </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span><font></font>
<font></font>
	<span class="hljs-comment">//    "+" </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt; <span class="hljs-title">operator</span>+&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;(<span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;, <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;) <span class="hljs-title">noexcept</span>;</span>	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-comment">//        </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">DirectSearch</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray2</span>;</span>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correlation between memory strategies and element check strategies</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Upon a detailed examination, it turned out that there is a pitfall in the relationship between memory strategies and strategies for checking for the presence of an element. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suppose you use smart pointers as a memory strategy, as well as a strategy using a bitmap to quickly check for an item in a list. You delete an item, the memory strategy resets its pointer. However, this element is not actually deleted from memory, since you have another smart pointer to it in your calling program. In the future, you turn to the list with this element, and it does the check correctly, referring to its data - the index in the bitmap and the pointer to the list. An element is actually deleted from memory only when there is no longer any link to it.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is not the case when using C ++ built-in pointers. In this case, the memory strategy </font><font style="vertical-align: inherit;">will </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actually</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> delete this item from memory using the delete operation. In the future, you, as in the previous case, refer to the list with this element, and it will try </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to access</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the element at this address in order to read the index of the bitmap and a pointer to the list. But you can‚Äôt do this: an element has already been deleted from memory! In the best case, you will receive an access violation, in the worst, undefined behavior when the C ++ library, the runtime library, or just the operating system writes there a completely arbitrary value that the list considers and tries to establish from them the fact of the presence of an element in the list.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, it turns out that internal pointers are compatible only with the DirectSearch direct check strategy, and smart pointers in this case offer not only their inherent security, but also performance increase: only with their use can bit arrays be used that significantly increase the work of the list in multithreaded mode! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To ensure consistency and eliminate incompatible strategy configurations, I included the following check in each list class:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,    ++ (Type *)          (DirectSearch)</span>
<span class="hljs-keyword">static_assert</span>(!(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, InternalPointer&lt;ListElement&gt;&gt; == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElement, <span class="hljs-literal">false</span>&gt;, DirectSearch&lt;ListElement, <span class="hljs-literal">false</span>&gt;&gt; == <span class="hljs-literal">false</span>), <span class="hljs-string">"Internal C++ pointer memory policy can be used only with DirectSearch policy."</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It compares the strategy classes passed to the list and, if they are incompatible, stops compilation with the corresponding error message output.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exceptions or Error Returns</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initially, the list error handling was carried out only through exceptions. </font><font style="vertical-align: inherit;">But somehow, on some forum I don‚Äôt remember, I read that exceptions slow down the program, and for maximum performance you should use the traditional error return. </font><font style="vertical-align: inherit;">He did so by creating two new classes based on the original ones, only rewriting them to return errors.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List Base Class</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The implementation of the above strategies for checking the presence of elements has revealed one important problem. The list element, as we recall, contains, in addition to the number unique in this list, also a pointer to this list: after all, we can have two or more lists in the program, each of which contains its own bit array of flags for the presence of the element. How to make sure that this element belongs to this particular list and not to another? Only by storing a pointer to the entire list inside each element. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The problem is that now, by adding a variety of strategies to our list class, we have significantly complicated its </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Suppose we have two different lists with the same type of element and the same memory strategies, but with different strategies for locking and checking for the presence of elements in them. For the compiler, these will be two different </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">types of</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lists. Pointer to what type to store in the element? Moreover, the class for the element does not know in advance which strategy will be applied, it must take into account </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">all of</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> them </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recall also that the blocking strategy, the strategy for checking for the presence of an element, and even the connectivity (simply connected or doubly connected) of the list refer only to the behavior of the list itself, but in no way relate to the </font><b><font style="vertical-align: inherit;">data</font></b><font style="vertical-align: inherit;"> it stores</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">But we, as end users of this class, are interested in the data! </font><font style="vertical-align: inherit;">So, on the one hand, using the classes of strategies, we added flexibility to ourselves, and on the other hand, we complicated our lives and added problems. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Is it possible to somehow make the wolves full and the sheep safe? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Can. </font><font style="vertical-align: inherit;">You can infer pointers to data from a class (i.e., from a type) of a list. </font><font style="vertical-align: inherit;">In addition to the two levels of organization of the list indicated above, one more appeared - zero:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListBase</span>
{</span>
	<span class="hljs-keyword">using</span> ptrListElement = <span class="hljs-keyword">typename</span> ListElement::MemoryPolicy::ptrType;		<span class="hljs-comment">//             </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:<font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	ptrListElement pFirst{ <span class="hljs-literal">nullptr</span> };<font></font>
	ptrListElement pLast{ <span class="hljs-literal">nullptr</span> };<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now, because </font><font style="vertical-align: inherit;">real classes of lists are inherited from it, if we want to access the list data regardless of its real type, we should refer to its base class ListBase. </font><font style="vertical-align: inherit;">We get access to the beginning and end of the list, and then work with its data as we want. </font><font style="vertical-align: inherit;">The specific type of list, as well as the combination of strategies used in it, does not matter.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterators</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Already in full swing working closely with STL in a real project (not mine :)), as well as continuing to study it in books, I drew attention to the for loop on the collection. </font><font style="vertical-align: inherit;">After all, this cycle is not just part of the STL, it has already become an internal part of the language. </font><font style="vertical-align: inherit;">I thought that I could also add support for it in my project. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To do this, you need to add support for iterators, abstracting from the specific way of working with pointers and navigating through the list. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An iterator example:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListIterator</span>		//    
{</span>
	ptrListElement pCurrElement{ <span class="hljs-literal">nullptr</span> };					<span class="hljs-comment">// ,    </span>
	<span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//  ,    </span>
	<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>;								<span class="hljs-comment">// ,     </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListIterator() {}<font></font>
	ListIterator(ptrListElement pElem, <span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>)
		<span class="hljs-keyword">noexcept</span> : pCurrElement(pElem), pList(pList), bProtected(bProtected) {}<font></font>
	ListIterator(<span class="hljs-keyword">const</span> ListIterator&amp; li) <span class="hljs-keyword">noexcept</span> : pCurrElement(li.pCurrElement), pList(li.pList) {}<font></font>
<font></font>
	ptrListElement&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		ptrListElement&amp; pli = pCurrElement;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> pli;<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement != <span class="hljs-literal">nullptr</span>; }
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ptrListElement</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement; }<font></font>
<font></font>
	<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>++()		<span class="hljs-comment">// : ++it</span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
	}<font></font>
<font></font>
	ListIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span>								<span class="hljs-comment">// : it++</span><font></font>
	{<font></font>
		ListIterator itPrev = *<span class="hljs-keyword">this</span>;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> itPrev;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = (pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">if</span> (pList == <span class="hljs-literal">nullptr</span> || li.pList == <span class="hljs-literal">nullptr</span>)<font></font>
			bResult = !(pCurrElement == li.pCurrElement);<font></font>
		<span class="hljs-keyword">else</span><font></font>
			bResult = !(pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
};<font></font>
 ,       <span class="hljs-keyword">for</span>  ,       begin()  end():<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">begin</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">if</span>(!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span>
	<span class="hljs-function">ListIterator <span class="hljs-title">lit</span><span class="hljs-params">(ListBase&lt;ListElement&gt;::pFirst, <span class="hljs-keyword">this</span>)</span></span>;
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">return</span> lit;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">return</span> ListIterator();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now it has become possible to write as follows:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">using</span> List = ListData&lt;List_TwoLinked&lt;ListElement, ThreadLockingWin_SRWLock, SearchByIndex_BitArray, <span class="hljs-literal">true</span>&gt;, <span class="hljs-literal">true</span>&gt;;<font></font>
List <span class="hljs-built_in">list</span>;
<span class="hljs-keyword">try</span><font></font>
{<font></font>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; leValue : <span class="hljs-built_in">list</span>)<font></font>
          _tprintf_s(TEXT(<span class="hljs-string">"%I64u\n"</span>), leValue-&gt;u64Value);<font></font>
}<font></font>
<span class="hljs-keyword">catch</span>(‚Ä¶)<font></font>
{<font></font>
      ‚Ä¶<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
leValue has a pointer type to a list item. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initially, I included iterator support only on exception-supported lists. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The reason was simple: since the code inside the loop is not available, it is not possible to correctly handle errors. </font><font style="vertical-align: inherit;">All that remains is to handle the exceptions by wrapping the loop in a try block. </font><font style="vertical-align: inherit;">In general, walking the list in such a way when other threads are intensively working with it is not a good idea: it is better to block the list yourself, and then calmly go through it in single-threaded mode. </font><font style="vertical-align: inherit;">But still, if for some reason you want to do exactly the same as in the example above, then now there is an opportunity for this.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A generalization of the strategy for checking the presence of an element on an arbitrary container; </font><font style="vertical-align: inherit;">iterators for lists with no exceptions</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, I originally planned (and still plan) to make not only a multi-threaded list, but also a tree. For some of their needs. The graph is also possible, but firstly, I did not need it, and secondly, the graph is a complicated thing with very non-trivial algorithms, and I did not want to dive into it without special need. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the initial version, the strategy for checking for the presence of an element was oriented only to the list, and its functions accepted a pointer to an element and a pointer to the base class of the list (ListBase *). Subsequently, I thought: but in the case of a tree, you have to do exactly the same thing! Do a separate, but essentially the exact same strategy?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The solution was simple: ignore the list. </font><font style="vertical-align: inherit;">This meant that now the input would be received not by pointers to elements, but by iterators. </font><font style="vertical-align: inherit;">And functions will become boilerplate to accept pointers to a container of any suitable type. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So now the original function, for example registering a list in a bitmap</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RegisterList</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ListBase&lt;ListElement&gt;* <span class="hljs-keyword">const</span> pList, ptrListElement <span class="hljs-keyword">const</span> pStart, ptrListElement <span class="hljs-keyword">const</span> pEnd = <span class="hljs-literal">nullptr</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pList -   ,       , pStart -   ,</span>
	<span class="hljs-comment">//pEnd -   </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		ptrListElement pCurr = pStart;<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">while</span> (pCurr != pEnd &amp;&amp; pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
		{<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pList-&gt;pFirst);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pList = <span class="hljs-keyword">const_cast</span>&lt;ListBase&lt;ListElement&gt; *&gt;(pList);<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
			pCurr = pCurr-&gt;pNext;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Turned into a container registration function:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Container, class Iterator&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterContainer</span><span class="hljs-params">(Container* <span class="hljs-keyword">const</span> pContainer, Iterator itStart, Iterator itEnd = Iterator{})</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pContainer -   ,       ; itStart -   </span>
	<span class="hljs-comment">//, itEnd -    </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = itStart; it != itEnd; ++it)<font></font>
		{<font></font>
			ptrElementType&amp; pCurr = *it;<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pContainer);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pContainer = pContainer;<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The transition through the list by pointers was transformed into a transition through an abstract container using iterators. </font><font style="vertical-align: inherit;">Now it will be enough for the tree to implement its iterators, and its support with these strategies will already be provided. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This required returning iterators to the lists without exceptions, but making them inaccessible from the outside and intended only for internal use.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data adapter</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having worked quite intensively with STL, as well as typing, launching and studying training programs from books, I drew attention to the simplicity of working with STL containers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, pay attention to the following code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = { <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : v)<font></font>
     i = <span class="hljs-number">1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I create a vector by passing it the type int I need, and that‚Äôs it! The container is immediately ready to work, if I do not need to change some additional parameters that are set by default, which most often does not happen! For me, proceeding from the three-level organization of the list, in each case I would have to first create a new class for the element, and then write a class for the list with data, implementing operations specific to the final list. Imagine how much work! And if you need to create another list for other data, you have to do it all over again or, in extreme cases, copy the previous code, slightly changing it. This already resembles the same fuss with the C language and the Windows API, where for each elementary action you have to fill in all the necessary data for the structure, and then call the desired function. And either keep it all in mindOr also constantly read MSDN, studying arguments of each new function! Routine and terribly uncomfortable!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I began to look for ways to get the opportunity to create my list by analogy with STL containers so that I would not have to do the same chore every time: create a separate class for any new item, and then a separate list class for working with elements of this type. </font><font style="vertical-align: inherit;">So there was an adapter for a list with data data. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An adapter for a list with data is a class, in the template parameters of which you pass immediately the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> type you need </font><font style="vertical-align: inherit;">, and not the element. </font><font style="vertical-align: inherit;">The type of element, which I called the composite type of the element, on the basis of this data it creates on </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">its own</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementCompound_OneLinked_CP</span>
{</span>
	ElementData ed;		<span class="hljs-comment">//</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> ListElement = ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;;
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... Args&gt; <span class="hljs-title">ListElementCompound_OneLinked_CP</span><span class="hljs-params">(Args... args)</span> : <span class="hljs-title">ed</span><span class="hljs-params">(args...)</span> </span>{}<font></font>
	ListElementCompound_OneLinked_CP(<span class="hljs-keyword">const</span> ElementData&amp; ed) : ed(ed) {}<font></font>
<font></font>
	ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ElementData</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex = <span class="hljs-number">0</span>;			<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt;* pContainer = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">//  - </span><font></font>
<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A separate point worth mentioning is access to the item‚Äôs data. </font><font style="vertical-align: inherit;">The element type contains the operation "*":</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> ed;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This means that if there is a pointer to the pElement element, then to access the data stored in it, it must be dereferenced twice:</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; li = **pCurrElement;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Once - to access an object of type ListElementCompound_OneLinked by its pointer: ListElementCompound_OneLinked &amp; le = * pCurrElement, and a second time - to access data through the operation '*': ElementData &amp; li = * le. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This looks very strange and atypical, but it is assumed that you will work not through pointers (for this, the initial version was already ready), but through iterators. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, when creating a list based on the adapter, you specify the strategies you need, as it was before. </font><font style="vertical-align: inherit;">Based on all your parameters, the adapter automatically creates the necessary types and passes them to the base internal list, from which it is inherited. </font><font style="vertical-align: inherit;">General class definition:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span> = <span class="hljs-title">SmartSharedPointer</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span> = <span class="hljs-title">ThreadLocking_STDMutex</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span> = <span class="hljs-title">DirectSearch</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span> = <span class="hljs-title">true</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Specialization for the list with exceptions:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>&lt;ElementData, _MemoryPolicy, LockingPolicy, CheckingPresenceElementPolicy, true&gt; :</span> 
<span class="hljs-keyword">public</span> List_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;, DirectSearch&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;&gt;, ListElementCompound_OneLinked&lt;ElementData, _MemoryPolicy&gt;, ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;&gt;, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">true</span>&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It looks very bulky, multi-storey and ugly. I know. But then this definition automatically does everything that is needed, without the direct participation of the programmer who plans to use it. With the help of std :: conditional_t ‚Äã‚Äãand std :: is_same_v, the strategy of checking for the presence of an element that you submitted is compared with direct search strategies and, depending on the result, the corresponding type of the list element is selected: with an index in the bitmap and a pointer to the list or without . This will save you memory due to unnecessary additional data inside each node if you use a direct search strategy.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inside the class, iterators specific to it are only implemented, as well as the push_back () / push_front () functions required by analogy with STL, which redirect calls to the base multi-threaded list. </font><font style="vertical-align: inherit;">You can add other functions later, so that the list becomes very similar to STL's. </font><font style="vertical-align: inherit;">But at the same time it will be with all the necessary protections and options for increasing productivity in a multi-threaded environment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Working with a data adapter began to look like this. </font><font style="vertical-align: inherit;">Creating list objects:</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;<font></font>
List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you are satisfied with all the default strategies and parameters, then creating a list becomes very brief:</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>&gt; list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see, outwardly there is absolutely no difference compared to STL, except that the name of the list class is different. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now you can work with it as in the old way, through the functions of the base class:</font></font><br>
<br>
<pre><code class="cpp hljs">list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">2</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here, numbers from 0 to 3 are added sequentially to the end of the list. To get to the argument passed to the constructor of the created type when it is created, you have to explicitly put down the values ‚Äã‚Äãof the first three arguments.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> x = *list0.GetLast();			<span class="hljs-comment">//   ,   auto    ListElementCompound_TwoLinked_CP&lt;...&gt;</span>
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"x = "</span> &lt;&lt; x &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yes, there is a certain inconvenience in explicitly indicating the type, but this is a consequence of an attempt to access the list again through the previous function for working with pointers. </font><font style="vertical-align: inherit;">If you add the back () function to the adapter, which returns an iterator, then working through it will not have such a problem:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> x = *list0.back();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After adjusting the iterators to the requirements of STL:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   STL</span>
<span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;
<span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">const</span> ElementData;
<span class="hljs-keyword">using</span> difference_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">ptrdiff_t</span>;
<span class="hljs-keyword">using</span> pointer = <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> List::ptrListElement;
<span class="hljs-keyword">using</span> reference = <span class="hljs-keyword">const</span> ElementData&amp;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
it becomes possible to use the list in library algorithms:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; dElem : list1)
	<span class="hljs-built_in">cout</span> &lt;&lt; i++ &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; dElem &lt;&lt; <span class="hljs-built_in">endl</span>;<font></font>
transform(list1.begin(), list1.end(), list1.begin(), [](<span class="hljs-keyword">double</span>&amp; dElem1)<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> dElem1 * dElem1;<font></font>
});<font></font>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(list1.cbegin(), list1.cend())</span></span>;<font></font>
‚Ä¶<font></font>
copy(v.begin(), v.end(), list1.begin());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, you will have to organize the interception and handling of exceptions: all the examples above are for working in one thread in order to test compatibility with STL.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The use of STL algorithms makes an interesting point possible: you can use several algorithms at once, running them in several threads in parallel. This cannot be done by conventional means (for example, using std :: list and blocking means) without having access to the internal contents of the list class. It was only possible to block the entire list for the duration of the entire algorithm. Of course, this will speed up the work for the thread executing the algorithm, but will make the list inaccessible to other threads. However, if you apply the same ‚Äúthin‚Äù SRWLock lock, you can execute several algorithms on the list at the same time, if they do not modify this list. But the first thread to write will stand up waiting for the completion of the read operation of the list by all other threads.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The proposed list option allows you to organize work with it more flexibly. </font><font style="vertical-align: inherit;">For example, you can organize the work with the list so that non-modifying algorithms in the first half of the list are executed by several threads at the same time, while a number of other threads can add or change something in the second half of the list. </font><font style="vertical-align: inherit;">The fact that the list is blocked for the duration of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operation, and not the entire algorithm, will allow the "write" of write operations through the sequence of operations of reading the list, which will make working with it more flexible, productive and efficient.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combining two variants of list classes with and without exception support into one with a boolean parameter</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Initially, the lists were only with exceptions. </font><font style="vertical-align: inherit;">Then I added new ones - no exceptions with error return, and renamed the old ones with the addition of the letter ‚ÄúE‚Äù in the class name: List_OneLinked_E and List_TwoLinked_E. </font><font style="vertical-align: inherit;">This required to indicate four declarations of the list class everywhere. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then I decided that it was inconvenient for many reasons. </font><font style="vertical-align: inherit;">Why do we need two completely different classes if this is the same list with or without exception support? </font><font style="vertical-align: inherit;">I combined both lists of each type into a single class with an additional Boolean parameter, and their specific implementation with and without exceptions are two specializations of a single class for the specified Boolean parameter.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Template List Merge Operation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The template operation of combining lists previously worked only with lists of the same type. It combined either only singly connected lists or only doubly connected lists. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, if you think about it, it doesn‚Äôt really matter what type of lists are involved in the operation: simply connected or doubly connected. Their blocking strategies are also unimportant, what is their strategy for checking for the existence of elements, and whether they support exception handling or not. All this applies only to the organization of the list, but not to the data contained in it. It is important that only the data type and memory strategy for the elements match. Accordingly, now, after combining lists with a Boolean parameter regarding exceptions, the input operation accepts lists of any type with all variants of their parameters:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy1</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy2</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy1</span>,
<span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy2</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions1</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions2</span>,
<span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType1</span>, <span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType2</span>&gt;
<span class="hljs-title">auto</span> <span class="hljs-title">operator</span>+(<span class="hljs-title">ListType1</span>&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;&amp; <span class="hljs-title">list1</span>, <span class="hljs-title">ListType2</span>&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&amp; <span class="hljs-title">list2</span>) <span class="hljs-title">noexcept</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now, as a result of the list type, the compiler selects, depending on the setting of the external parameter ce_bGetMinLinksList, a list with either minimum or maximum connectivity and, depending on this solution, its corresponding parameters are used:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMinLinksNumber = <span class="hljs-built_in">std</span>::min(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(), <font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMaxLinksNumber = <span class="hljs-built_in">std</span>::max(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(),<font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<font></font>
<span class="hljs-keyword">using</span> ListTypeResultMinLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResultMaxLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResult = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ce_bGetMinLinksList, ListTypeResultMinLinks, ListTypeResultMaxLinks&gt;;<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMinLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMaxLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResult = ce_bGetMinLinksList ? bExceptionsResultMinLinks : bExceptionsResultMaxLinks;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Based on the selected parameters, a result list is created:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">ListTypeResult <span class="hljs-title">list</span><span class="hljs-params">(list1.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>) + list2.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>), <span class="hljs-literal">false</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then, on this list, the pointers are set to the beginning of the first and the end of the second list:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// ,   (       ,   )</span>
<span class="hljs-keyword">if</span> (list1.GetFirst(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list1.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list1.GetLast(<span class="hljs-literal">true</span>))<font></font>
	list1.GetLast(<span class="hljs-literal">true</span>)-&gt;pNext = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list2.GetLast(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list2.GetLast(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list1.GetLast(<span class="hljs-literal">true</span>);<font></font>
<font></font>
<span class="hljs-comment">//       </span>
<span class="hljs-built_in">list</span>.CheckingPresenceElementPolicyResult::RegisterContainer(&amp;<span class="hljs-built_in">list</span>, <span class="hljs-keyword">typename</span> ListTypeResult::iterator{ <span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst, &amp;<span class="hljs-built_in">list</span> });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, the previous lists are cleared and the function exits. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The weak point of this function is the double locking of lists with potential deadlocks:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// :  -   ;            std::lock(mutex1, mutex2)</span><font></font>
list1.LockListExclusive();<font></font>
list2.LockListExclusive();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can introduce some function to simultaneously lock two lists in a single atomic operation like std :: lock (mutex1, mutex2), however, not all locking strategies support simultaneous locking of two synchronization objects, like std :: lock (...). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, two lists may have different locking strategies. </font><font style="vertical-align: inherit;">The solution to this problem (if it exists at all) is left to the future.</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux compilation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The compilation was checked through the ListDataAdapterTest project, originally written in pure C ++ without Windows-specific features, on Linux Ubuntu 16.04 LTS, the g ++ 8.2.0 compiler. Most of the minor nuances were easy to fix, and the project was successfully compiled, and the output of the program coincided with the same output under Windows. However, this is the case if you comment out the line of combining lists through the operation "+":</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> list3 = list00 + list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you leave it as it is, a compilation error will occur in the ‚Äú+‚Äù operation described above, as if it had not been declared privileged in the class of the composite element of the list. A similar error occurs in the direct checking strategy for the presence of the DirectSearch element. In Visual C ++, everything is fine here, however, these same errors appear if in the composite element class and in the list class the comment on declaring the operation of combining lists and DirectSearch as privileged is commented out. It seems that g ++ simply skips these declarations and complains about the private / protected members of the corresponding classes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(In g ++ version 9 (Ubuntu 20.04), the same errors.)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why privilege announcements are skipped and how to fix it, I did not understand. </font><font style="vertical-align: inherit;">I am not good at the features of the GCC compiler. </font><font style="vertical-align: inherit;">Left this moment also for the future. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Except for this nuance, there are no other serious compilation errors.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Description of the header file structure</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dear readers, I published a full-fledged project under the LGPL 3.0 license on GitHub at: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/SkyCloud555/ListMT</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
This is one solution consisting of several test projects. </font><font style="vertical-align: inherit;">The main code of a multithreaded list, by virtue of its implementation through templates, is located in several header files:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List.h - the base class of a list without data, which implements all the basic operations with a list, possible without defining specific data, as well as similar STL adapters for data.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListE.h - versions of the list with exception support.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListElement.h - definition of base classes for a list item.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListErrors.h - definition of codes and error classes for exceptions.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to the listed main files, the following are also implemented:</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MemoryPolicy.h - strategies for working with memory;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadLocking.h - blocking strategies.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SearchContainerElement.h - strategies for checking for the presence of an element in the list, abstractly described for any container with iterators.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition to the final project, I also added three old versions in the ‚ÄúOld versions‚Äù folder, so that you can briefly evaluate how the project changed as it developed.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testing</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main project, called List, is a program with an interface for Windows that is hardcore implemented through the Windows API (I don‚Äôt know how else). In this program, you select the type of list (simply connected or doubly connected), and also indicate the initial number of elements and the desired number of threads. List items contain a single 64-bit value. After creating a list, the program in each thread in the loop jumps forward or backward through the list to a random number of elements, and then adds or removes an element. No real useful work is done through this list, and all the energy is spent on heating the atmosphere, but this is not necessary: ‚Äã‚Äãwe only need to evaluate the operability and performance of the list in an intensive multi-threaded environment.The measure of performance is the number of iterations of the above cycle per second, performed by all threads.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The list is set up by indicating the appropriate strategies in the program code and then recompiling. All strategies for the main program are specified in the main module ListMain.cpp, the memory strategy is selected in ListDataExample.h.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Generally speaking, I experimented a bit with experiments. I honestly admit. Mainly because there in a number of cases the list of elements changes significantly. For the purity of the experiment to measure performance, it would be necessary to put a test in such a way that the number of elements on average does not change over the study period or changes extremely insignificantly. Only under such conditions would it be fair to evaluate the value of productivity based on the average value. If anyone is interested, I propose to organize such experiments on their own. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I did not correct the initial organization of the tests for the following reasons. </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First of all, I was just lazy.</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Firstly, in my opinion, nobody is interested in the exact quantitative values ‚Äã‚Äãof performance</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with calculated error</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : it is important to evaluate the performance and performance of the list in a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quality manner</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Secondly, this allows you to evaluate the change in the performance of the list with the growth of its volume, which is also quite important and interesting information. </font><font style="vertical-align: inherit;">For these reasons, I did not change the original experiments. </font><font style="vertical-align: inherit;">Thirdly, the same test code is performed on all variants of the list, which in this sense puts them in the same conditions: the fact that they behave differently in this case allows us to judge the quality of the changes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To enable performance metering, set the ce_bPerformanceMeasure flag in the ListMain.cpp module to true. </font><font style="vertical-align: inherit;">The program will create a file ‚ÄúPerformanceMeasure.txt‚Äù with pairs ‚Äúnumber of elements - number of cycles / sec‚Äù, separated by a ‚Äú:‚Äù symbol.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance Measurement Results</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, I did not conduct tests for all possible configurations of the list, because there are a lot of them. </font><font style="vertical-align: inherit;">I focused only on the key ones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Testing was carried out on my order of the already outdated, but still very peppy configuration Intel Core i7-3930K, DDR3-1333, 4-channel memory controller. </font><font style="vertical-align: inherit;">Compilation was carried out through Visual Studio 2019 for Release x64 mode, the operating system Windows 7 x64. </font><font style="vertical-align: inherit;">I did not play with the number of threads, so in all tests, the maximum 12 threads available in this system were always used. </font><font style="vertical-align: inherit;">A list has always been created with 10,000 randomly selected items, with the exception of the last test.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory Strategy Testing</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using built-in pointers, as I mentioned earlier, only a direct search strategy can be used to check for the presence of an item in the list. Accordingly, so that the comparison is correct, and for smart pointers, only this strategy will be applied in this test. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a blocking strategy, a critical section with a thin lock was selected as the most productive in Windows (see below): ThreadLockingWin_SRWLock. Error handling is carried out by returning an error code, i.e. option without exceptions. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fr/pu/f0/frpuf0zcgkd3dep1rbzgtpk3ciq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This graph shows the number of cycles performed by all threads in total per second, depending on the duration of the test (in seconds). Obviously, performance is inconsistent due to the random nature of threads accessing the list.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pz/km/sw/pzkmsw49rqqqihzv-poyko_co-w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second graph shows how the number of list items changes during the test. I will not make any thoughtful statements about this schedule, except for the obvious: it is clear that they work in slightly different ways, and the connectivity of the list together with the memory strategy has an effect. A doubly linked list with internal pointers is the only one that unexpectedly does not change in average size over the entire duration of the test. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Average productivity (cycles / s) for the measured period:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ky/ux/kd/kyuxkd-1_uzoxhu65prxxyvfcfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At least it can be argued that the list option with smart pointers is slower than the version with built-in pointers, which is to be expected. </font><font style="vertical-align: inherit;">In both cases, somehow it turns out that a singly connected one is faster than a doubly connected one, which once again shows that in multi-threaded mode, many familiar things can change.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testing for item availability strategies</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The most interesting is testing on strategies for checking the presence of an element. As a memory strategy, smart pointers are naturally indicated for the reasons previously described. The rest is the same: locking with ThreadLockingWin_SRWLock and handling errors by returning an error code. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ua/lp/ck/ualpckuzqwqhhsdq9o8oqtljtfa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We can say for sure that all strategies work approximately the same. This is understandable: in a singly linked list, when you delete its item, you have to look at the list each time to the item that indicates the item to be deleted. This nullifies all efforts to optimize access to the list and speed up checking for the presence of an element in it. Therefore, a singly linked list is not the best choice for intensive disordered multithreaded work with it.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will not give a graph on the number of elements: there is nothing interesting there. I only note that now the number of elements in all lists is increasing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A completely different situation arises for a doubly linked list. To make the graphs look beautiful, I even excluded the strategy of direct viewing of the DirectSearch list from it, because by the results it clearly ‚Äúfalls out‚Äù from the rest. In addition, I increased the limit number of elements by 4 times, reaching which, the test stops.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/th/hd/9x/thhd9xyuvi7avo9gmcscfra0tp0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First of all, the performance of accessing the list (as well as the processor load, becoming 99-100%) has increased dramatically and significantly! Secondly, a pair of strategies with sequential filling of array bits have approximately the same performance that does not change during the test. The speed of the second pair of strategies decreases nonlinearly. Why this is so, it will become clear from the graph for the number of nodes in the list.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/ge/mi/bugemimboyskkxkygick6axhxls.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lists with the first pair of strategies grow in the number of elements, and linearly. The second pair gives significantly nonlinear growth, and the greater the number of elements has a list, the slower it grows. This is understandable since with an increase in the number of elements when creating a new one, on average it is necessary to look through a larger number of bits of the array in search of free. The first pair of strategies does not deal with this, it uses a new bit for each new element. Thus, a list with such a strategy has maximum access performance and is closest to the classical list: both creating and deleting elements is performed in a constant time, independent of the number of elements. However, it does provide some guarantees of integrity and security in a multi-threaded environment, albeit at the cost of a certain amount of memory.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The list with the second pair of strategies, of course, is noticeably slower. However, it is still significantly faster than direct checking options. So you can really recommend it as some intermediate in performance, but more optimal in terms of memory consumption. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, lists with a direct search strategy will also work more slowly with an increase in the number of elements in them: a greater number of elements will have to be viewed each time. It‚Äôs just that during the test the list doesn‚Äôt manage to grow so much that it becomes noticeable despite the chaotic performance fluctuations.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vw/ck/_p/vwck_pj1r6wmaxgowihhqbzltq8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Averaged performance values ‚Äã‚Äãshow that strategies with a bitmap during its sequential filling allowed to increase the productivity of accessing the list by about 200 times, i.e. </font><font style="vertical-align: inherit;">2 orders of magnitude compared to direct search strategies. </font><font style="vertical-align: inherit;">This is a very radical change. </font><font style="vertical-align: inherit;">The performance of options with memory-optimal bit filling, as noted above, is of course noticeably slower, but still much faster than options with direct verification. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is also worth noting that the use of a memory transfer mechanism on demand somewhat slows down access to the list. </font><font style="vertical-align: inherit;">Not too critical, but the effect is present and noticeable, especially - in the variant with the economical use of memory (yellow line on the graphs).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blocking Strategy Testing</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's see how the performance of the list will change when choosing different locking strategies. </font><font style="vertical-align: inherit;">I used three types of locks: SRWLock ‚Äúthin‚Äù lock, regular Windows critical section, and STL mutex. </font><font style="vertical-align: inherit;">For the rest of the settings, the fastest version of the list was used: biconnected, smart pointers, the strategy for checking for the presence of an element - SearchByIndex_BitArray, a variant without exceptions. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6a/jb/pz/6ajbpzqugu7mgtv9mtcim4y221w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you would expect, a ‚Äúthin‚Äù lock increases performance by almost 25%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The speed of work with the critical section of Windows and the STL mutex is about the same.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6n/qz/wv/6nqzwvldymyqvb-rt1dgjgigwdm.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exceptions</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To evaluate the impact of exceptions on performance, I conducted three tests. </font><font style="vertical-align: inherit;">The first two used a doubly linked list, smart pointers, an element presence checking strategy - SearchByIndex_BitArray, and a critical section of SRWLock. </font><font style="vertical-align: inherit;">The same test was used for the last test, only the lock was replaced with the usual critical section for comparison. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7_/at/9u/7_at9uiygpgn_mnrznps8yjwbp0.png"><br>
<br>
<img src="https://habrastorage.org/webt/pf/ac/e9/pface9frjlrsbtcbc9ryxnqv8we.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It can be seen that support for exceptions can really reduce the speed of work, especially if you use a more ‚Äúcrude‚Äù blocking option. </font><font style="vertical-align: inherit;">However, remember that in this case, support for STL and for loops in the collection will not be available.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findings</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It was a very large-scale experiment for me. I mean not the tests above, but the whole project. He did not expect himself to be so dragged on. Nevertheless, I carried it out completely and to the extent that I planned. Of course, in the end, this is still not the final version, but only some working prototype, the implementation of the ideas described at the beginning of the article.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
According to the test results, it is clear that under Windows it turned out to be the fastest doubly linked list with smart pointers, a strategy for checking for the presence of the SearchByIndex_BitArray element, the critical section of SRWLock and without exceptions. In this configuration, the list provides maximum performance with intensive chaotic access to it from various streams and the behavior is closest to the classic list with security guarantees in multithreaded mode. The option with a more economical memory consumption is also very productive (compared to DirectSearch direct verification), but it is still noticeably slower than the previous one, and its performance decreases with an increase in the number of elements.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you think that I will be campaigning here for what a cool thing I did and how great it is to use it, then no: in fact, I will start by discouraging you. </font><font style="vertical-align: inherit;">Indeed:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Think about whether it is possible to use a container with a different arrangement of elements: for example, an array. </font><font style="vertical-align: inherit;">It does not have problems like a list.</font></font></li>
<li>          ,      std::list    .            .    ,        ,          .      ,   <s>,     </s>.    , <s>    ,</s>       <s>,    </s>.</li>
<li> ,    .       :    ,  ,  ,    ,        . ,    ‚Äì       ,      ,    .</li>
<li>                ,      .   ,       ,               .</li>
<li>   ,    ,     ,            .  ,             .              . ,    ,       ,   ‚Äì     .    . ,   ‚Äì          .     ,        ,    .           ,        .. ,          ,            , ,     ,          ,   :   .                       .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strategies with transferring memory to a bit array on demand also at least partially bring a multi-threaded list closer to a classic one: at least until the memory array is completely full, it will take exactly as much as is actually required. </font><font style="vertical-align: inherit;">However, this entails a reduction in performance.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Disadvantages of the project:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The previously noted possibility of mutual blocking in the operation of combining lists.</font></font></li>
<li>       ,    . ,     :   ,     RAII:          .       ,      ,   -  ,       .   ,     . ,   ,      - .</li>
<li>         ,    .     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hope this was interesting. Beginners can be useful, because everything is considered from simple to complex. I ask professionals to say how much, in your opinion, the ideas described here are applicable in practice in real projects? Has there been a case in your activity when, according to the meaning, you needed a list or tree, and not another container, but it became a bottleneck in your program due to the problems described here? Or you had to change or complicate the program greatly. If you have met this before, then how did you solve this?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, in essence, this project is only the realization of my own view on the solution of this problem. </font><font style="vertical-align: inherit;">It is likely that there is some better option. </font><font style="vertical-align: inherit;">I repeat the thought from the beginning that I did it initially for myself and did not plan to put it on public display. </font><font style="vertical-align: inherit;">But still, I did it for the reasons described there, so I will be glad to constructive criticism. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> With a careful review of the code, you may come across such a design:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  (        )</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};			<span class="hljs-comment">//-,       ,   ListElementData_OneLinked/ListElementData_TwoLinked</span><font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked1</span> :</span> <span class="hljs-keyword">public</span> ListElement_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked1&lt;&gt;, DerivedListElement&gt;, MemoryPolicy&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>;						<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked1(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : u64Value(u64Value) {}		<span class="hljs-comment">//</span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked2</span> :</span> <span class="hljs-keyword">public</span> ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">using</span> ListElementBase = ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;;<font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ucSomeData[<span class="hljs-number">1024</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">decltype</span>(ListElementBase::u64Value))];	<span class="hljs-comment">//     </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked2(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : ListElementBase(u64Value) {}		<span class="hljs-comment">//</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This black magic deserves a separate article. </font><font style="vertical-align: inherit;">True, this is an even less practical thing than the multi-threaded list described here, but it has its own curious features. </font><font style="vertical-align: inherit;">If you are interested in where it came from and why it appeared, and you want me to talk about it later in detail, write in the comments.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en506702/index.html">The most reliable HDDs according to Backblaze Q1 2020</a></li>
<li><a href="../en506704/index.html">Why write in PHP in 2020? Holivarim is an interactive podcast on Youtube this Thursday</a></li>
<li><a href="../en506706/index.html">The performance of modern Java when working with large amounts of data, part 1</a></li>
<li><a href="../en506708/index.html">VPN / Mikrotik two-factor authentication - simple and scalable</a></li>
<li><a href="../en506710/index.html">Manage multiple address books in the Zimbra Collaboration Suite Open-Source Edition</a></li>
<li><a href="../en506726/index.html">Experience in using Rutoken technology for registration and authorization of users in the system (part 2)</a></li>
<li><a href="../en506730/index.html">Snort or Suricata. Part 1: choose a free IDS / IPS to protect the corporate network</a></li>
<li><a href="../en506732/index.html">Organization-wide reuse of UI components</a></li>
<li><a href="../en506734/index.html">Transient calculations in electrical networks</a></li>
<li><a href="../en506736/index.html">How many methods should be in a class?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>