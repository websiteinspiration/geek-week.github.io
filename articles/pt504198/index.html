<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêà üçë üïµüèæ SwiftUI nas prateleiras: Anima√ß√£o. Parte 1 üññüèª üîû üñ•Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente me deparei com um artigo novo, no qual os caras tentavam reproduzir um conceito interessante usando o SwiftUI. Aqui est√° o que eles fizer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SwiftUI nas prateleiras: Anima√ß√£o. Parte 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504198/"><img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recentemente me deparei com um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> novo, </font><font style="vertical-align: inherit;">no qual os caras tentavam reproduzir um conceito interessante usando o SwiftUI. Aqui est√° o que eles fizeram: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7a7/cbf/7a0/7a7cbf7a05561123ceff4be47fff5ed6.gif" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
estudei o c√≥digo com interesse, mas experimentei alguma frustra√ß√£o. N√£o, n√£o no sentido de que eles fizeram algo errado, de maneira alguma. Eu simplesmente n√£o aprendi com o c√≥digo deles praticamente nada de novo. Sua implementa√ß√£o √© mais sobre Combinar do que sobre anima√ß√£o. E eu decidi </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">construir meu lunopark</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para escrever meu artigo sobre anima√ß√£o no SwiftUI, implementando sobre o mesmo conceito, mas usando 100% dos recursos da anima√ß√£o interna, mesmo que n√£o seja muito eficaz. Estudar - at√© o fim. Para experimentar - ent√£o com um brilho :) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√° o que eu tenho:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, para uma divulga√ß√£o completa do t√≥pico, tive que falar com alguns detalhes sobre o b√°sico. O texto acabou sendo volumoso e, portanto, eu o dividi em dois artigos. Aqui est√° a primeira parte - em vez disso, um tutorial sobre anima√ß√£o em geral, n√£o diretamente relacionado √† anima√ß√£o arco-√≠ris, que discutirei em detalhes no pr√≥ximo artigo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste artigo, falarei sobre o b√°sico, sem o qual voc√™ pode facilmente se confundir em exemplos mais complexos. Muito do que vou falar, de uma forma ou de outra, j√° foi descrito em artigos em ingl√™s como esta s√©rie ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Por outro lado, concentrei-me n√£o apenas em enumerar as maneiras de trabalhar, mas em descrever exatamente como isso funciona. </font><font style="vertical-align: inherit;">E como sempre, eu experimentei muito, ent√£o me apressei em compartilhar os resultados mais interessantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aviso: sob o gato h√° muitas fotos e anima√ß√µes gif.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLDR</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O projeto est√° dispon√≠vel no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Voc√™ pode ver o resultado atual com a anima√ß√£o do arco-√≠ris em TransitionRainbowView (), mas eu n√£o me apressei em seu lugar, mas esperei pelo pr√≥ximo artigo. </font><font style="vertical-align: inherit;">Al√©m disso, ao prepar√°-lo, eu penteio um pouco o c√≥digo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste artigo, discutiremos apenas o b√°sico e afetamos apenas o conte√∫do da pasta Bases.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introdu√ß√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu admito, n√£o ia escrever este artigo agora. Eu tinha um plano segundo o qual um artigo sobre anima√ß√£o deveria ser o terceiro ou mesmo o quarto consecutivo. No entanto, eu n√£o pude resistir, eu realmente queria fornecer um ponto de vista alternativo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quero fazer uma reserva imediatamente. N√£o acredito que tenham sido cometidos erros no artigo mencionado ou que a abordagem usada esteja incorreta. De modo nenhum. Ele constr√≥i um modelo de objeto do processo (anima√ß√£o) que, respondendo ao sinal recebido, come√ßa a fazer alguma coisa. No entanto, quanto a mim, este artigo provavelmente revela trabalho com a estrutura Combine. Sim, essa estrutura √© uma parte importante do SwiftUI, mas √© mais sobre o estilo de rea√ß√£o em geral do que sobre anima√ß√£o.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Minha op√ß√£o certamente n√£o √© mais elegante, mais r√°pida e mais f√°cil de manter. No entanto, ele revela muito melhor o que est√° sob o cap√¥ do SwiftUI e, de fato, esse era o objetivo do artigo - descobrir primeiro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como eu disse em um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo anterior</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pela SwiftUI, comecei meu mergulho no mundo do desenvolvimento m√≥vel imediatamente com o SwiftUI, ignorando o UIKit. Obviamente, isso tem um pre√ßo, mas h√° vantagens. N√£o estou tentando morar em um novo mosteiro, de acordo com a antiga Carta. Honestamente, ainda n√£o conhe√ßo nenhuma carta, ent√£o n√£o rejeito a nova. √â por isso que, parece-me, este artigo pode ser √∫til n√£o apenas para iniciantes, como eu, mas tamb√©m para aqueles que estudam o SwiftUI que j√° t√™m experi√™ncia na forma de desenvolvimento no UIKit. Parece-me que muitas pessoas n√£o t√™m um visual renovado. N√£o fa√ßa o mesmo, tentando encaixar uma nova ferramenta nos desenhos antigos, mas mude sua vis√£o de acordo com novas possibilidades.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√≥s 1c-nicks passamos por isso com "formas controladas". Esse √© um tipo de SwiftUI no mundo dos 1s, que aconteceu mais de 10 anos atr√°s. De fato, a analogia √© bastante precisa, porque os formul√°rios gerenciados s√£o apenas uma nova maneira de desenhar uma interface. No entanto, ele mudou completamente a intera√ß√£o cliente-servidor do aplicativo como um todo, e a imagem do mundo nas mentes dos desenvolvedores em particular. Isso n√£o foi f√°cil, eu mesmo n√£o quis estud√°-lo por cerca de 5 anos, porque Eu pensei que muitas das oportunidades que foram cortadas l√° eram simplesmente necess√°rias para mim. Mas, como a pr√°tica demonstrou, a codifica√ß√£o em formul√°rios gerenciados n√£o √© apenas poss√≠vel, mas apenas necess√°ria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, n√£o vamos mais falar sobre isso. </font><font style="vertical-align: inherit;">Eu recebi um guia detalhado e independente que n√£o tem nenhuma refer√™ncia ou outros links para o artigo mencionado ou o 1¬∫ passado. </font><font style="vertical-align: inherit;">Passo a passo, vamos mergulhar nos detalhes, caracter√≠sticas, princ√≠pios e limita√ß√µes. </font><font style="vertical-align: inherit;">Vai.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forma de anima√ß√£o</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como a anima√ß√£o funciona em geral</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, a id√©ia principal da anima√ß√£o √© a transforma√ß√£o de uma mudan√ßa espec√≠fica e discreta em um processo cont√≠nuo. Por exemplo, o raio do c√≠rculo era de 100 unidades, tornou-se 50 unidades. Sem anima√ß√£o, a mudan√ßa acontecer√° instantaneamente, com anima√ß√£o - sem problemas. Como funciona? Muito simples. Para mudan√ßas suaves, precisamos interpolar v√°rios valores dentro do segmento ‚ÄúEra ... Tornou-se‚Äù. No caso do raio, teremos que desenhar v√°rios c√≠rculos intermedi√°rios com um raio de 98 unidades, 95 unidades, 90 unidades ... 53 unidades e, finalmente, 50 unidades. O SwiftUI pode fazer isso de maneira f√°cil e natural, basta agrupar o c√≥digo que executa essa altera√ß√£o com Anima√ß√£o {...}. Parece m√°gico ... At√© que voc√™ queira implementar algo um pouco mais complicado do que "ol√° mundo".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos seguir para os exemplos. O objeto mais simples e compreens√≠vel para anima√ß√£o √© considerado anima√ß√£o de formul√°rios. Forma (ainda chamarei a estrutura em conformidade com o protocolo de forma) no SwiftUI √© uma estrutura com par√¢metros que podem se ajustar a esses limites. Essa. √© uma estrutura que possui o corpo da fun√ß√£o (em rect: CGRect) -&gt; Caminho. Todo o tempo de execu√ß√£o necess√°rio para desenhar esse formul√°rio √© solicitar seu contorno (o resultado da fun√ß√£o √© um objeto do tipo Path, na verdade, √© uma curva de Bezier) para o tamanho necess√°rio (especificado como um par√¢metro da fun√ß√£o, um ret√¢ngulo do tipo CGRect).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Forma √© uma estrutura armazenada. Ao inicializ√°-lo, voc√™ armazena nos par√¢metros tudo o que precisa para desenhar seu contorno. O tamanho da sele√ß√£o para este formul√°rio pode mudar, ent√£o tudo o que √© necess√°rio √© obter um novo valor de caminho para o novo quadro CGRect e pronto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos come√ßar a codificar j√°:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">Circle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.green)<font></font>
            .frame(height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habra"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.gray)<font></font>
                )<font></font>
<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)<font></font>
            .frame(width: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>, height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habr"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.green)<font></font>
                )<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleTestView</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">50</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">CircleView</span>(radius: radius)<font></font>
               .frame(height: <span class="hljs-number">200</span>)
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$radius, <span class="hljs-keyword">in</span>: <span class="hljs-number">42</span>...<span class="hljs-number">100</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.radius = <span class="hljs-number">50</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set default radius"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/pf/3j/eo/pf3jeo651jcwbhazddldv-rgxhy.gif"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, temos um c√≠rculo (Circle ()), cujo raio podemos mudar usando o controle deslizante. Isso acontece sem problemas, pois o controle deslizante nos fornece todos os valores intermedi√°rios. No entanto, quando voc√™ clica no bot√£o "definir raio padr√£o", a altera√ß√£o tamb√©m n√£o ocorre instantaneamente, mas de acordo com a instru√ß√£o withAnimation (.linear (duration: 1)). Linearmente, sem acelera√ß√£o, esticada por 1 segundo. Classe! N√≥s dominamos a anima√ß√£o! Discordamos :) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas e se quisermos implementar nossa pr√≥pria forma e animar suas mudan√ßas? √â dif√≠cil fazer isso? Vamos checar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fiz uma c√≥pia do Circle da seguinte maneira:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span></span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{
        <span class="hljs-keyword">let</span> radius = <span class="hljs-built_in">min</span>(rect.width, rect.height) / <span class="hljs-number">2</span>
        <span class="hljs-keyword">let</span> center = <span class="hljs-type">CGPoint</span>(x: rect.width / <span class="hljs-number">2</span>, y: rect.height / <span class="hljs-number">2</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-type">Path</span>(){path <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">if</span> rect.width &gt; rect.height{<font></font>
                path.move(to: <span class="hljs-type">CGPoint</span>(x: center.x, y: <span class="hljs-number">0</span>))
                <span class="hljs-keyword">let</span> startAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>)<font></font>
                path.addArc(center: center, radius: radius, startAngle: startAngle, endAngle:  startAngle + <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>), clockwise: <span class="hljs-literal">false</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                path.move(to: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: center.y))
                <span class="hljs-keyword">let</span> startAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)<font></font>
                path.addArc(center: center, radius: radius, startAngle: startAngle, endAngle:  startAngle + <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>), clockwise: <span class="hljs-literal">false</span>)<font></font>
            }<font></font>
            path.closeSubpath()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O raio do c√≠rculo √© calculado como a metade da largura e altura da borda da √°rea da tela alocada para n√≥s. </font><font style="vertical-align: inherit;">Se a largura for maior que a altura, partimos do meio da borda superior (Nota 1), descrevemos o c√≠rculo completo no sentido hor√°rio (Nota 2) e fechamos nosso esbo√ßo. </font><font style="vertical-align: inherit;">Se a altura for maior que a largura, partimos do meio da borda direita, tamb√©m descrevemos o c√≠rculo completo no sentido hor√°rio e fechamos o contorno.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota 1</font></font></b>
                        <div class="spoiler_text">Apple     (  )  .  ,      (0, 0),         (x, y),  x ‚Äî  ,  y ‚Äî  . ..        y.   y ‚Äî   .  ,        .  90    , 180  ‚Äî , 270  ‚Äî .</div>
                    </div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota 2</font></font></b>
                        <div class="spoiler_text">   1   ,   ‚Äú ‚Äù  ‚Äú ‚Äù         .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"></a>  Core Graphics (SwiftUI      ):<br>
<blockquote>In a flipped coordinate system (the default for UIView drawing methods in iOS), specifying a clockwise arc results in a counterclockwise arc after the transformation is applied.</blockquote></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos verificar como nosso novo c√≠rculo responder√° √†s altera√ß√µes no bloco withAnimation:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)<font></font>
            .frame(width: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>, height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habr"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.green)<font></font>
                )<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleTestView</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">50</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
                <span class="hljs-type">HStack</span>{
                <span class="hljs-type">CircleView</span>(radius: radius)<font></font>
                    .frame(height: <span class="hljs-number">200</span>)
                <span class="hljs-type">CustomCircleView</span>(radius: radius)<font></font>
                    .frame(height: <span class="hljs-number">200</span>)<font></font>
            }<font></font>
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$radius, <span class="hljs-keyword">in</span>: <span class="hljs-number">42</span>...<span class="hljs-number">100</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.radius = <span class="hljs-number">50</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set default radius"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/ba/qp/5obaqpgty5ckwvic5uxzscqtix4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uau! </font><font style="vertical-align: inherit;">Aprendemos como criar nossas pr√≥prias imagens de forma livre e anim√°-las! </font><font style="vertical-align: inherit;">√â assim? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na verdade n√£o. </font><font style="vertical-align: inherit;">Todo o trabalho aqui √© feito pelo modificador .frame (width: self.radius * 2, height: self.radius * 2). </font><font style="vertical-align: inherit;">Dentro do bloco withAnimation {...} mudamos</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estado</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uma vari√°vel, ele envia um sinal para reinicializar CustomCircleView () com um novo valor de raio, esse novo valor cai no modificador .frame () e esse modificador j√° pode animar altera√ß√µes de par√¢metro. Nosso formul√°rio CustomCircle () reage a isso com anima√ß√£o, porque n√£o depende de nada al√©m do tamanho da √°rea selecionada para ele. A altera√ß√£o da √°rea ocorre com a anima√ß√£o (ou seja, gradualmente, interpolando os valores intermedi√°rios entre o que foi e se tornou), portanto, nosso c√≠rculo √© desenhado com a mesma anima√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos simplificar (ou ainda complicar?) Nossa forma um pouco. N√£o calcularemos o raio com base no tamanho da √°rea dispon√≠vel, mas transferiremos o raio na forma final, ou seja, torn√°-lo um par√¢metro de estrutura armazenada.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{
        <span class="hljs-comment">//let radius = min(rect.width, rect.height) / 2</span><font></font>
...<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>(radius: radius)<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)
            <span class="hljs-comment">//.frame(height: self.radius * 2)</span><font></font>
...<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/g9/ju/pp/g9juppbsuti7iazguvffuy02fiu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, a magia est√° irremediavelmente perdida. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exclu√≠mos o modificador frame () de nosso CustomCircleView (), transferindo a responsabilidade pelo tamanho do c√≠rculo para a pr√≥pria forma e a anima√ß√£o desapareceu. </font><font style="vertical-align: inherit;">Mas isso n√£o importa; ensinar um formul√°rio para animar altera√ß√µes em seus par√¢metros n√£o √© muito dif√≠cil. </font><font style="vertical-align: inherit;">Para fazer isso, voc√™ precisa implementar os requisitos do protocolo Animatable:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span>, <span class="hljs-title">Animatable</span></span>{
    <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span>{
         <span class="hljs-keyword">get</span>{<font></font>
             radius<font></font>
         }<font></font>
         <span class="hljs-keyword">set</span>{
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"new radius is \(newValue)"</span>)<font></font>
            radius = newValue<font></font>
         }<font></font>
     }<font></font>
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{<font></font>
	...<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/f1/1-/xs/f11-xshpugfdigdwhnle4nupbek.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voila! </font><font style="vertical-align: inherit;">A magia est√° de volta! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E agora podemos dizer com seguran√ßa que nosso formul√°rio √© realmente animado - pode refletir altera√ß√µes em seus par√¢metros com anima√ß√£o. </font><font style="vertical-align: inherit;">Demos ao sistema uma janela onde ele pode compactar os valores interpolados necess√°rios para a anima√ß√£o. </font><font style="vertical-align: inherit;">Se houver uma janela, as altera√ß√µes ser√£o animadas. </font><font style="vertical-align: inherit;">Caso contr√°rio, as altera√ß√µes ocorrem sem anima√ß√£o, ou seja, </font><font style="vertical-align: inherit;">imediatamente. </font><font style="vertical-align: inherit;">Nada complicado, certo?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AnimatableModifier</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como animar altera√ß√µes dentro de uma Visualiza√ß√£o</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas vamos diretamente para o View. </font><font style="vertical-align: inherit;">Suponha que desejemos animar a posi√ß√£o de um elemento dentro de um cont√™iner. </font><font style="vertical-align: inherit;">No nosso caso, ser√° um ret√¢ngulo simples de cor verde e uma largura de 10 unidades. </font><font style="vertical-align: inherit;">Vamos animar sua posi√ß√£o horizontal.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SimpleView</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">ZStack</span>{
                <span class="hljs-type">Rectangle</span>()<font></font>
                    .fill(<span class="hljs-type">Color</span>.gray)
                <span class="hljs-type">BorderView</span>(position: position)<font></font>
            }<font></font>
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$position, <span class="hljs-keyword">in</span>: <span class="hljs-number">0</span>...<span class="hljs-number">1</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.position = <span class="hljs-number">0</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set to 0"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderView</span>: <span class="hljs-title">View</span>,  <span class="hljs-title">Animatable</span></span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Reding position: \(position)"</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.position<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>.position = newValue
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"setting position: \(position)"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">let</span> borderWidth: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">init</span>(position: <span class="hljs-type">CGFloat</span>, borderWidth: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">10</span>){
        <span class="hljs-keyword">self</span>.position = position
        <span class="hljs-keyword">self</span>.borderWidth = borderWidth
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"BorderView init"</span>)<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span>
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-keyword">self</span>.borderWidth)<font></font>
                .offset(x: <span class="hljs-keyword">self</span>.getXOffset(inSize: geometry.size), y: <span class="hljs-number">0</span>)
                <span class="hljs-comment">// .borderIn(position: position)</span><font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getXOffset</span><span class="hljs-params">(inSize: CGSize)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"calculating position: \(position)"</span>)
        <span class="hljs-keyword">return</span> -inSize.width / <span class="hljs-number">2</span> + inSize.width * position<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/7l/b-/pr/7lb-pry2ta71tvntbemngt8duts.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Classe! </font><font style="vertical-align: inherit;">Trabalho! </font><font style="vertical-align: inherit;">Agora sabemos tudo sobre anima√ß√£o! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na verdade n√£o. </font><font style="vertical-align: inherit;">Se voc√™ olhar para o console, veremos o seguinte:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Posi√ß√£o de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
c√°lculo do </font><font style="vertical-align: inherit;">init do BorderView </font><font style="vertical-align: inherit;">: 0.4595176577568054 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Posi√ß√£o de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
c√°lculo do </font><font style="vertical-align: inherit;">init do </font><font style="vertical-align: inherit;">BorderView: 0.468130886554718 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Posi√ß√£o de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
c√°lculo do </font><font style="vertical-align: inherit;">init do BorderView </font><font style="vertical-align: inherit;">: 0.0</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em primeiro lugar, cada altera√ß√£o no valor da posi√ß√£o usando o controle deslizante faz com que o BorderView seja reinicializado com o novo valor. √â por isso que vemos um movimento suave da linha verde ap√≥s o controle deslizante, o controle deslizante simplesmente relata com frequ√™ncia uma altera√ß√£o na vari√°vel e parece uma anima√ß√£o, mas n√£o √©. Usar o controle deslizante √© realmente conveniente quando voc√™ depura a anima√ß√£o. Voc√™ pode us√°-lo para rastrear alguns estados de transi√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em segundo lugar, vemos que a posi√ß√£o de c√°lculo simplesmente se tornou igual a 0, e n√£o h√° registros intermedi√°rios, como foi o caso da anima√ß√£o correta do c√≠rculo. Por qu√™?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A coisa, como no exemplo anterior, est√° no modificador. </font><font style="vertical-align: inherit;">Dessa vez, o modificador .offset () obt√©m o novo valor de indenta√ß√£o e anima a altera√ß√£o em si. </font><font style="vertical-align: inherit;">Essa. </font><font style="vertical-align: inherit;">na verdade, n√£o √© a altera√ß√£o no par√¢metro position que pretendemos ser animados, mas a altera√ß√£o horizontal do recuo no modificador .offset () derivado dele. </font><font style="vertical-align: inherit;">Nesse caso, √© uma substitui√ß√£o inofensiva, o resultado √© o mesmo. </font><font style="vertical-align: inherit;">Mas desde que eles chegaram, vamos nos aprofundar. </font><font style="vertical-align: inherit;">Vamos fazer nosso pr√≥prio modificador, que receber√° a posi√ß√£o (de 0 a 1) na entrada, receber√° o tamanho da √°rea dispon√≠vel e calcular√° o recuo.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderPosition</span>: <span class="hljs-title">ViewModifier</span></span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span><font></font>
            content<font></font>
            .offset(x: <span class="hljs-keyword">self</span>.getXOffset(inSize: geometry.size), y: <span class="hljs-number">0</span>)<font></font>
            .animation(<span class="hljs-literal">nil</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getXOffset</span><span class="hljs-params">(inSize: CGSize)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-keyword">let</span> offset = -inSize.width / <span class="hljs-number">2</span> + inSize.width * position
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"at position  \(position) offset is \(offset)"</span>)
        <span class="hljs-keyword">return</span> offset<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">borderIn</span><span class="hljs-params">(position: CGFloat)</span></span> -&gt; some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">BorderPosition</span>(position: position))<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No BorderView original, respectivamente, o GeometryReader n√£o √© mais necess√°rio, bem como a fun√ß√£o para calcular o recuo:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderView</span>: <span class="hljs-title">View</span>,  <span class="hljs-title">Animatable</span></span>{<font></font>
    ...<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-keyword">self</span>.borderWidth)<font></font>
                .borderIn(position: position)<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hd/3i/r0/hd3ir0e-_jji7qwiasacdwpnpx4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sim, ainda usamos o modificador .offset () dentro do nosso modificador, mas depois adicionamos o modificador .animation (nil), que bloqueia nossa pr√≥pria anima√ß√£o de deslocamento. </font><font style="vertical-align: inherit;">Entendo que, nesse est√°gio, voc√™ possa decidir que basta remover esse bloqueio, mas n√£o chegaremos ao fundo da verdade. </font><font style="vertical-align: inherit;">E a verdade √© que nosso truque com animatableData for BorderView n√£o funciona. </font><font style="vertical-align: inherit;">De fato, se voc√™ examinar a documenta√ß√£o do protocolo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animatable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , notar√° que a implementa√ß√£o deste protocolo √© suportada apenas para AnimatableModifier, GeometryEffect e Shape. </font><font style="vertical-align: inherit;">Vista n√£o est√° entre eles.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A abordagem correta √© animar modifica√ß√µes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A abordagem em si, quando pedimos ao View para animar algumas altera√ß√µes, estava incorreta. </font><font style="vertical-align: inherit;">Para o View, voc√™ n√£o pode usar a mesma abordagem dos formul√°rios. </font><font style="vertical-align: inherit;">Em vez disso, a anima√ß√£o precisa ser incorporada em cada modificador. </font><font style="vertical-align: inherit;">A maioria dos modificadores internos j√° suporta anima√ß√£o pronta para uso. </font><font style="vertical-align: inherit;">Se voc√™ deseja anima√ß√£o para seus pr√≥prios modificadores, pode usar o protocolo AnimatableModifier em vez de ViewModifier. </font><font style="vertical-align: inherit;">E a√≠ voc√™ pode implementar a mesma coisa que ao animar altera√ß√µes de forma, como fizemos acima.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderPosition</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">let</span> startDate: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"reading position: \(position) at time \(Date().timeIntervalSince(startDate))"</span>)
            <span class="hljs-keyword">return</span> position<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {<font></font>
            position = newValue<font></font>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"setting position: \(position) at time \(Date().timeIntervalSince(startDate))"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
...<font></font>
    }<font></font>
    ...<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/p2/l3/ys/p2l3yslis_hirenud-lpkt8xaoa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora est√° tudo certo. </font><font style="vertical-align: inherit;">As mensagens no console ajudam a entender que nossa anima√ß√£o realmente funciona e a anima√ß√£o. (Nil) dentro do modificador n√£o interfere em nada. </font><font style="vertical-align: inherit;">Mas ainda vamos descobrir exatamente como isso funciona.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, voc√™ precisa entender o que √© um modificador.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui temos uma vista. Como eu disse na parte anterior, esta √© uma estrutura com par√¢metros armazenados e instru√ß√µes de montagem. Essa instru√ß√£o, em geral, n√£o cont√©m uma sequ√™ncia de a√ß√µes, que √© o c√≥digo usual que escrevemos em um estilo n√£o declarativo, mas uma lista simples. Ele lista a outra Visualiza√ß√£o, os modificadores aplicados a eles e os cont√™ineres nos quais est√£o inclu√≠dos. Ainda n√£o estamos interessados ‚Äã‚Äãem cont√™ineres, mas vamos falar mais sobre modificadores.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um modificador √© novamente uma estrutura com par√¢metros armazenados e Exibir instru√ß√µes de processamento. </font><font style="vertical-align: inherit;">Esta √© realmente a mesma instru√ß√£o que a View - podemos usar outros modificadores, usar cont√™ineres (por exemplo, usei o GeometryReader um pouco mais alto) e at√© outra View. </font><font style="vertical-align: inherit;">Mas s√≥ temos conte√∫do recebido e precisamos alter√°-lo de alguma forma usando esta instru√ß√£o. </font><font style="vertical-align: inherit;">Os par√¢metros do modificador fazem parte da instru√ß√£o. </font><font style="vertical-align: inherit;">Mas o mais interessante √© que eles s√£o armazenados.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em um artigo anterior, eu disse que a instru√ß√£o em si n√£o √© armazenada, que √© lan√ßada toda vez ap√≥s a atualiza√ß√£o da Visualiza√ß√£o. </font><font style="vertical-align: inherit;">Tudo √© assim, mas h√° uma nuance. </font><font style="vertical-align: inherit;">Como resultado do trabalho desta instru√ß√£o, n√£o temos uma imagem completa, como eu disse anteriormente - foi uma simplifica√ß√£o. </font><font style="vertical-align: inherit;">Os modificadores n√£o desaparecem ap√≥s a opera√ß√£o desta instru√ß√£o. </font><font style="vertical-align: inherit;">Eles permanecem assim enquanto a Visualiza√ß√£o pai existe.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algumas analogias primitivas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como descrever√≠amos uma tabela em um estilo declarativo? </font><font style="vertical-align: inherit;">Bem, listar√≠amos 4 pernas e uma bancada. </font><font style="vertical-align: inherit;">Eles os combinariam em algum tipo de cont√™iner e, com a ajuda de alguns modificadores, prescreveriam como eles s√£o presos um ao outro. </font><font style="vertical-align: inherit;">Por exemplo, cada perna indicaria a orienta√ß√£o em rela√ß√£o √† bancada e a posi√ß√£o - qual perna est√° presa em qual canto. </font><font style="vertical-align: inherit;">Sim, podemos descartar as instru√ß√µes ap√≥s a montagem, mas os pregos permanecer√£o na mesa. </font><font style="vertical-align: inherit;">O mesmo acontece com os modificadores. </font><font style="vertical-align: inherit;">Na sa√≠da da fun√ß√£o do corpo, n√£o temos uma tabela completa. </font><font style="vertical-align: inherit;">Usando body, criamos elementos de tabela (visualiza√ß√£o) e elementos de fixa√ß√£o (modificadores) e colocamos tudo em gavetas. </font><font style="vertical-align: inherit;">A mesa em si √© montada por um rob√¥. </font><font style="vertical-align: inherit;">Quais fixadores voc√™ colocar em uma caixa para cada perna, voc√™ ter√° uma mesa dessas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A fun√ß√£o .modifier (BorderPosition (position: position)), com a qual transformamos a estrutura BorderPosition em um modificador, apenas coloca um parafuso adicional na gaveta na perna da mesa. A estrutura BorderPosition √© esse parafuso. A renderiza√ß√£o, no momento da renderiza√ß√£o, pega essa caixa, tira uma perna dela (Rectangle () no nosso caso) e obt√©m sequencialmente todos os modificadores da lista, com os valores armazenados nelas. A fun√ß√£o do corpo de cada modificador √© uma instru√ß√£o sobre como aparafusar uma perna em uma mesa com esse parafuso, e a pr√≥pria estrutura com propriedades armazenadas, esse √© o parafuso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que √© importante entender isso no contexto da anima√ß√£o? Porque a anima√ß√£o permite alterar os par√¢metros de um modificador sem afetar os outros e, em seguida, renderizar novamente a imagem. Se voc√™ fizer o mesmo, alterando algumas</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par√¢metros - isso causar√° a reinicializa√ß√£o da Vista aninhada, estruturas modificadoras etc., ao longo de toda a cadeia. Mas a anima√ß√£o n√£o √©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, quando alteramos o valor da posi√ß√£o quando pressionamos um bot√£o, ele muda. At√© o fim. Nenhum estado intermedi√°rio √© armazenado na pr√≥pria vari√°vel, o que n√£o pode ser dito sobre o modificador. Para cada novo quadro, os valores dos par√¢metros do modificador mudam de acordo com o progresso da anima√ß√£o atual. Se a anima√ß√£o durar 1 segundo, a cada 1/60 de segundo (o iphone mostra exatamente esse n√∫mero de quadros por segundo), o valor animatableData dentro do modificador ser√° alterado, e ser√° lido pela renderiza√ß√£o para renderiza√ß√£o, ap√≥s o que, ap√≥s outros 1/60 de segundo, ser√° alterado novamente e lido novamente pela renderiza√ß√£o.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que √© caracter√≠stico, primeiro obtemos o estado final de toda a visualiza√ß√£o, lembre-se, e s√≥ ent√£o o mecanismo de anima√ß√£o come√ßa a colocar os valores de posi√ß√£o interpolados no modificador. O estado inicial n√£o √© armazenado em nenhum lugar. Em algum lugar nas entranhas do SwiftUI, apenas a diferen√ßa entre o estado inicial e o final √© armazenada. Essa diferen√ßa √© sempre multiplicada pela fra√ß√£o do tempo decorrido. √â assim que o valor interpolado √© calculado, que √© subsequentemente substitu√≠do em animatableData. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferen√ßa = </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a√ßo </font></font><br><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">- era o </font></i><i><font style="vertical-align: inherit;">valor atual = a√ßo - diferen√ßa * (1 - tempo decorrido) </font></i><i><font style="vertical-align: inherit;">
tempo decorrido = tempo desde o in√≠cioAnimations / DurationAnimations O</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
valor atual precisa ser calculado quantas vezes o n√∫mero de quadros que precisamos mostrar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que n√£o √© usado explicitamente? O fato √© que o SwiftUI n√£o armazena o estado inicial. Somente a diferen√ßa √© armazenada: portanto, no caso de algum tipo de falha, voc√™ pode simplesmente desligar a anima√ß√£o e ir para o estado atual de "tornar-se". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa abordagem permite que voc√™ fa√ßa a anima√ß√£o revers√≠vel. Suponha que, em algum lugar no meio de uma anima√ß√£o, o usu√°rio pressione um bot√£o novamente e alteremos novamente o valor da mesma vari√°vel. Nesse caso, tudo o que precisamos fazer para vencer essa mudan√ßa lindamente √© pegar "Atual" dentro da anima√ß√£o no momento da nova mudan√ßa como "It", lembrar a nova Diferen√ßa e iniciar uma nova anima√ß√£o baseada no novo "Tornou-se" e na nova "Diferen√ßa" . Sim, de fato, essas transi√ß√µes de uma anima√ß√£o para outra podem ser um pouco mais dif√≠ceis de simular a in√©rcia, mas acho que o significado √© compreens√≠vel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O interessante √© que a anima√ß√£o de cada quadro solicita o valor atual dentro do modificador (usando um getter). Isso, como voc√™ pode ver nos registros de servi√ßo no log, √© respons√°vel pelo status de "A√ßo". Em seguida, usando o configurador, definimos o novo estado atual para esse quadro. Depois disso, para o pr√≥ximo quadro, o valor atual do modificador √© novamente solicitado - e novamente "Tornou-se", ou seja, O valor final para o qual a anima√ß√£o est√° se movendo. √â prov√°vel que c√≥pias de estruturas modificadoras sejam usadas para anima√ß√£o, e um getter de uma estrutura (um modificador real da Visualiza√ß√£o real) seja usado para obter o valor "Steel", e um setter de outro (um modificador tempor√°rio usado para anima√ß√£o) √© usado. Eu n√£o criei uma maneira de garantir isso, mas por indica√ß√µes indiretas tudo parece exatamente assim. De qualquer forma,As altera√ß√µes na anima√ß√£o n√£o afetam o valor armazenado da estrutura modificadora da Visualiza√ß√£o atual. Se voc√™ tiver id√©ias sobre como descobrir exatamente o que exatamente acontece com o getter e o setter, escreva sobre isso nos coment√°rios, atualizarei o artigo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V√°rios par√¢metros</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At√© o momento, t√≠nhamos apenas um par√¢metro para anima√ß√£o. </font><font style="vertical-align: inherit;">A quest√£o pode surgir, mas e se mais de um par√¢metro for passado para o modificador? </font><font style="vertical-align: inherit;">E se os dois precisam ser animados ao mesmo tempo? </font><font style="vertical-align: inherit;">Veja como, com o modificador de quadro (width: height :), por exemplo. </font><font style="vertical-align: inherit;">Afinal, podemos alterar simultaneamente a largura e a altura dessa visualiza√ß√£o, e queremos que a altera√ß√£o ocorra em uma anima√ß√£o, como faz√™-lo? </font><font style="vertical-align: inherit;">Afinal, o par√¢metro AnimatableData √© um, o que posso substituir nele?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ olhar, a Apple tem apenas um requisito para dados animable. O tipo de dados que voc√™ substitui deve satisfazer o protocolo VectorArithmetic. Esse protocolo requer que o objeto garanta as opera√ß√µes aritm√©ticas m√≠nimas necess√°rias para formar um segmento de dois valores e interpolar os pontos dentro desse segmento. As opera√ß√µes necess√°rias para isso s√£o adi√ß√£o, subtra√ß√£o e multiplica√ß√£o. A dificuldade √© que devemos executar essas opera√ß√µes com um √∫nico objeto que armazena v√°rios par√¢metros. Essa. devemos empacotar a lista inteira de nossos par√¢metros em um cont√™iner que ser√° um vetor. A Apple fornece esse objeto imediatamente e nos oferece uma solu√ß√£o pronta para uso em casos n√£o muito dif√≠ceis. √â chamado AnimatablePair.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos mudar um pouco a tarefa. </font><font style="vertical-align: inherit;">Precisamos de um novo modificador que n√£o apenas mova a barra verde, mas tamb√©m mude sua altura. </font><font style="vertical-align: inherit;">Estes ser√£o dois par√¢metros modificadores independentes. </font><font style="vertical-align: inherit;">N√£o darei o c√≥digo completo de todas as altera√ß√µes que precisam ser feitas, voc√™ pode v√™-lo no github no arquivo SimpleBorderMove. </font><font style="vertical-align: inherit;">Vou mostrar apenas o modificador em si:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TwoParameterBorder</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> height: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">let</span> startDate: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">AnimatablePair</span>&lt;<span class="hljs-type">CGFloat</span>, <span class="hljs-type">CGFloat</span>&gt; {
        <span class="hljs-keyword">get</span> {
           <span class="hljs-built_in">print</span>(<span class="hljs-string">"animation read position: \(position), height: \(height)"</span>)
           <span class="hljs-keyword">return</span> <span class="hljs-type">AnimatablePair</span>(position, height)<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>.position = newValue.first
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"animating position at \(position)"</span>)
            <span class="hljs-keyword">self</span>.height = newValue.second
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"animating height at \(height)"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">init</span>(position: <span class="hljs-type">CGFloat</span>, height: <span class="hljs-type">CGFloat</span>){
        <span class="hljs-keyword">self</span>.position = position
        <span class="hljs-keyword">self</span>.height = height<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span><font></font>
            content<font></font>
                .animation(<span class="hljs-literal">nil</span>)<font></font>
                .offset(x: -geometry.size.width / <span class="hljs-number">2</span> + geometry.size.width * <span class="hljs-keyword">self</span>.position, y: <span class="hljs-number">0</span>)<font></font>
                .frame(height: <span class="hljs-keyword">self</span>.height * (geometry.size.height - <span class="hljs-number">20</span>) + <span class="hljs-number">20</span>)<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vn/0q/mi/vn0qmirl31w63mzgjvijsw-f-ps.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adicionei outro controle deslizante e um bot√£o para alterar aleatoriamente os dois par√¢metros de uma s√≥ vez na visualiza√ß√£o pai do SimpleView, mas n√£o h√° nada interessante, portanto, para o c√≥digo completo, seja bem-vindo ao github. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo funciona, n√≥s realmente temos uma mudan√ßa consistente no par de par√¢metros compactados na tupla AnimatablePair. </font><font style="vertical-align: inherit;">N√£o √© ruim. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nada confunde nesta implementa√ß√£o? </font><font style="vertical-align: inherit;">Pessoalmente, fiquei tenso quando vi esse design:</font></font><br>
<br>
<pre><code class="swift hljs">        
<span class="hljs-keyword">self</span>.position = newValue.first
<span class="hljs-keyword">self</span>.height = newValue.second
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o indiquei em nenhum lugar qual desses par√¢metros deve ir primeiro e qual segundo. Como o SwiftUI decide qual valor colocar em primeiro e qual valor em segundo? Bem, ele n√£o corresponde aos nomes dos par√¢metros da fun√ß√£o com os nomes dos atributos da estrutura?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira ideia foi a ordem dos atributos nos par√¢metros da fun√ß√£o e seus tipos, como acontece com @EnvironmentObject. L√°, simplesmente colocamos os valores na caixa, sem atribuir nenhum r√≥tulo a eles, e ent√£o os tiramos de l√°, tamb√©m sem indicar nenhum r√≥tulo. L√°, o tipo importa e, em um tipo, a ordem. Em que ordem eles colocam na caixa, da mesma maneira e a recebem. Tentei uma ordem diferente dos argumentos da fun√ß√£o, a ordem dos argumentos para inicializar a estrutura, a ordem dos atributos da pr√≥pria estrutura, geralmente batia minha cabe√ßa contra a parede, mas n√£o conseguia confundir o SwiftUI, de modo que ele come√ßou a animar a posi√ß√£o com valores de altura e vice-versa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o me dei conta. Eu pr√≥prio indico qual par√¢metro ser√° o primeiro e qual segundo no getter. O SwiftUI n√£o precisa saber exatamente como inicializamos essa estrutura. Ele pode obter o valor animatableData antes da altera√ß√£o, obt√™-lo ap√≥s a altera√ß√£o, calcular a diferen√ßa entre eles e retornar a mesma diferen√ßa, dimensionada proporcionalmente ao intervalo de tempo decorrido, ao nosso setter. Geralmente, n√£o √© necess√°rio saber nada sobre o valor em si dentro do AnimatableData. E se voc√™ n√£o confundir a ordem das vari√°veis ‚Äã‚Äãem duas linhas adjacentes, tudo estar√° em ordem, n√£o importa qu√£o complicada seja a estrutura do restante do c√≥digo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas vamos dar uma olhada. Afinal, podemos criar nosso pr√≥prio vetor de cont√™iner (ah, adoro isso, criar nossa pr√≥pria implementa√ß√£o de objetos existentes, voc√™ deve ter notado isso em um artigo anterior).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ao/v4/an/aov4an8tjqou27syes6klcckwy0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Descrevemos a estrutura elementar, declaramos suporte ao protocolo VectorArithmetic, abrimos o erro sobre o protocolo n√£o conforme, clicamos em corre√ß√£o e obtemos a declara√ß√£o de todas as fun√ß√µes necess√°rias e par√¢metros calculados. </font><font style="vertical-align: inherit;">Resta apenas preench√™-los. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da mesma forma, preenchemos nosso objeto com os m√©todos necess√°rios para o protocolo AdditiveArithmetic (o VectorArithmetic inclui seu suporte).</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyAnimatableVector</span>: <span class="hljs-title">VectorArithmetic</span></span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> - <span class="hljs-params">(lhs: MyAnimatableVector, rhs: MyAnimatableVector)</span></span> -&gt; <span class="hljs-type">MyAnimatableVector</span> {
        <span class="hljs-type">MyAnimatableVector</span>(position: lhs.position - rhs.position, height: lhs.height - rhs.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> + <span class="hljs-params">(lhs: MyAnimatableVector, rhs: MyAnimatableVector)</span></span> -&gt; <span class="hljs-type">MyAnimatableVector</span> {
        <span class="hljs-type">MyAnimatableVector</span>(position: lhs.position + rhs.position, height: lhs.height + rhs.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scale</span><span class="hljs-params">(by rhs: Double)</span></span> {
        <span class="hljs-keyword">self</span>.position = <span class="hljs-keyword">self</span>.position * <span class="hljs-type">CGFloat</span>(rhs)
        <span class="hljs-keyword">self</span>.height = <span class="hljs-keyword">self</span>.height * <span class="hljs-type">CGFloat</span>(rhs)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> magnitudeSquared: <span class="hljs-type">Double</span>{
         <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.position * <span class="hljs-keyword">self</span>.position) + <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.height * <span class="hljs-keyword">self</span>.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> zero: <span class="hljs-type">MyAnimatableVector</span>{
        <span class="hljs-type">MyAnimatableVector</span>(position: <span class="hljs-number">0</span>, height: <span class="hljs-number">0</span>)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> height: <span class="hljs-type">CGFloat</span>
}</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penso porque precisamos de + e - obviamente. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escala √© uma fun√ß√£o da escala. </font><font style="vertical-align: inherit;">Pegamos a diferen√ßa ‚ÄúEra - Tornou-se‚Äù e a multiplicamos pelo est√°gio atual da anima√ß√£o (de 0 a 1). </font><font style="vertical-align: inherit;">‚ÄúTornou-se + Diferen√ßa * (1 - Est√°gio)‚Äù e haver√° um valor atual que deveremos excluir em dados</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Provavelmente √© necess√°rio zero para inicializar novos objetos cujos valores ser√£o usados ‚Äã‚Äãpara anima√ß√£o. </font><font style="vertical-align: inherit;">A anima√ß√£o usa .zero logo no in√≠cio, mas n√£o consegui descobrir exatamente como. </font><font style="vertical-align: inherit;">No entanto, n√£o acho que isso seja importante.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">magnitudeSquared √© um produto escalar de um determinado vetor consigo mesmo. </font><font style="vertical-align: inherit;">Para espa√ßo bidimensional, isso significa o comprimento do vetor ao quadrado. </font><font style="vertical-align: inherit;">Provavelmente, isso √© usado para comparar dois objetos entre si, n√£o por elementos, mas como um todo. </font><font style="vertical-align: inherit;">Parece n√£o ser usado para fins de anima√ß√£o.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De um modo geral, as fun√ß√µes ‚Äú- =‚Äù ‚Äú+ =‚Äù tamb√©m est√£o inclu√≠das no suporte ao protocolo, mas para a estrutura elas podem ser geradas automaticamente neste formul√°rio</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> -= <span class="hljs-params">(lhs: <span class="hljs-keyword">inout</span> MyAnimatableVector, rhs: MyAnimatableVector)</span></span> {<font></font>
        lhs = lhs - rhs<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> += <span class="hljs-params">(lhs: <span class="hljs-keyword">inout</span> MyAnimatableVector, rhs: MyAnimatableVector)</span></span> {<font></font>
        lhs = lhs + rhs<font></font>
    }<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para maior clareza, expus toda essa l√≥gica na forma de um diagrama. </font><font style="vertical-align: inherit;">
A imagem √© clic√°vel. </font><font style="vertical-align: inherit;">
O que obtemos durante a anima√ß√£o √© destacado em vermelho - a cada pr√≥ximo tick (1/60 segundo), o timer fornece um novo valor de t, e n√≥s, no setter do nosso modificador, obtemos um novo valor de animatableData. </font><font style="vertical-align: inherit;">√â assim que a anima√ß√£o funciona sob o cap√¥. </font><font style="vertical-align: inherit;">Ao mesmo tempo, √© importante entender que um modificador √© uma estrutura armazenada e uma c√≥pia do modificador atual com um novo estado atual √© usada para exibir a anima√ß√£o.</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/zl/ag/q4/zlagq42atcapum-br2sj00ikubu.png"></a><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que o AnimatableData pode ser apenas uma estrutura</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° mais um ponto. Voc√™ n√£o pode usar classes como um objeto AnimatableData. Formalmente, voc√™ pode descrever para uma classe todos os m√©todos necess√°rios do protocolo correspondente, mas isso n√£o decola, e aqui est√° o porqu√™. Como voc√™ sabe, uma classe √© um tipo de dados de refer√™ncia e uma estrutura √© um tipo de dados baseado em valor. Quando voc√™ cria uma vari√°vel com base em outra, no caso de uma classe, copia um link para esse objeto e, no caso de uma estrutura, cria um novo objeto com base nos valores da existente. Aqui est√° um pequeno exemplo que ilustra essa diferen√ßa:</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TestStruct</span></span>{
        <span class="hljs-keyword">var</span> value: <span class="hljs-type">CGFloat</span>
        <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scaled</span><span class="hljs-params">(by: CGFloat)</span></span>{
            <span class="hljs-keyword">self</span>.value = <span class="hljs-keyword">self</span>.value * by<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span></span>{
        <span class="hljs-keyword">var</span> value: <span class="hljs-type">CGFloat</span>
        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scaled</span><span class="hljs-params">(by: CGFloat)</span></span>{
             <span class="hljs-keyword">self</span>.value = <span class="hljs-keyword">self</span>.value * by<font></font>
        }<font></font>
        <span class="hljs-keyword">init</span>(value: <span class="hljs-type">CGFloat</span>){
            <span class="hljs-keyword">self</span>.value = value<font></font>
        }<font></font>
    }<font></font>
        <span class="hljs-keyword">var</span> stA = <span class="hljs-type">TestStruct</span>(value: <span class="hljs-number">5</span>)
        <span class="hljs-keyword">var</span> stB = stA<font></font>
        stB.scaled(by: <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"structs: a = \(stA.value), b = \(stB.value))"</span>) <span class="hljs-comment">//structs: a = 5.0, b = 10.0)</span>
        <span class="hljs-keyword">var</span> clA = <span class="hljs-type">TestClass</span>(value: <span class="hljs-number">5</span>)
        <span class="hljs-keyword">var</span> clB = clA<font></font>
        clB.scaled(by: <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"classes: a = \(clA.value), b = \(clB.value))"</span>) <span class="hljs-comment">//classes: a = 10.0, b = 10.0)</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com anima√ß√£o, exatamente a mesma coisa acontece. Temos um objeto AnimatableData que representa a diferen√ßa entre "was" e "tornou-se". Precisamos calcular parte dessa diferen√ßa para refletir na tela. Para fazer isso, devemos copiar essa diferen√ßa e multiplic√°-la por um n√∫mero que represente o est√°gio atual da anima√ß√£o. No caso da estrutura, isso n√£o afetar√° a diferen√ßa em si, mas no caso da classe, afetar√°. O primeiro quadro que desenhamos √© o estado "era". Para fazer isso, precisamos calcular A√ßo + Diferen√ßa * Est√°gio Atual - Diferen√ßa. No caso da classe, no primeiro quadro multiplicamos a diferen√ßa por 0, zerando-o e todos os quadros subsequentes s√£o desenhados para que a diferen√ßa = 0. a anima√ß√£o parece ter sido desenhada corretamente, mas, de fato, vemos uma transi√ß√£o instant√¢nea de um estado para outro, como se n√£o houvesse anima√ß√£o.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ provavelmente pode escrever algum tipo de c√≥digo de baixo n√≠vel que crie novos endere√ßos de mem√≥ria para o resultado da multiplica√ß√£o - mas por qu√™? </font><font style="vertical-align: inherit;">Voc√™ pode simplesmente usar estruturas - elas s√£o criadas para isso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para aqueles que querem entender completamente como o SwiftUI calcula valores intermedi√°rios, por quais opera√ß√µes e em que momento, as </font><font style="vertical-align: inherit;">mensagens s√£o enviadas ao console </font><font style="vertical-align: inherit;">no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projeto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Al√©m disso, eu inseri o sono 0,1 segundo l√° para simular c√°lculos com muitos recursos dentro da anima√ß√£o, divirta-se :)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anima√ß√£o de tela: .transition ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At√© esse ponto, falamos sobre animar uma altera√ß√£o em um valor passado para um modificador ou formul√°rio. Essas s√£o ferramentas bastante poderosas. Mas h√° outra ferramenta que tamb√©m usa anima√ß√£o - essa √© a anima√ß√£o da apar√™ncia e desaparecimento da Visualiza√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No √∫ltimo artigo, falamos sobre o fato de que, no estilo declarativo de if-else, isso n√£o √© controle sobre o fluxo de c√≥digo no tempo de execu√ß√£o, mas uma vis√£o de Schrodinger. Este √© um cont√™iner que cont√©m duas visualiza√ß√µes ao mesmo tempo, que decide qual delas mostrar de acordo com uma determinada condi√ß√£o. Se voc√™ perder o bloco else, o EmptyView ser√° exibido em vez da segunda exibi√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A altern√¢ncia entre as duas visualiza√ß√µes tamb√©m pode ser animada. Para fazer isso, use o modificador .transition ().</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TransitionView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">let</span> views: [<span class="hljs-type">AnyView</span>] = [<span class="hljs-type">AnyView</span>(<span class="hljs-type">CustomCircleTestView</span>()), <span class="hljs-type">AnyView</span>(<span class="hljs-type">SimpleBorderMove</span>())]<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> currentViewInd = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">ZStack</span>{
                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                        }<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-type">HStack</span>{
                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">10</span>)<font></font>
                        .fill(ind == <span class="hljs-keyword">self</span>.currentViewInd ? <span class="hljs-type">Color</span>.green : <span class="hljs-type">Color</span>.gray)<font></font>
                        .overlay(<font></font>
                            <span class="hljs-type">Text</span>(<span class="hljs-string">"\(ind + Int(1))"</span>))<font></font>
                        .onTapGesture{<font></font>
                            withAnimation{<font></font>
                                <span class="hljs-keyword">self</span>.currentViewInd = ind<font></font>
                            }<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
                .frame(height: <span class="hljs-number">50</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos ver como isso funciona. Antes de mais nada, mesmo no est√°gio de inicializa√ß√£o da visualiza√ß√£o pai, criamos e colocamos v√°rias visualiza√ß√µes na matriz. A matriz √© do tipo AnyView, porque os elementos da matriz devem ter o mesmo tipo, caso contr√°rio, eles n√£o podem ser usados ‚Äã‚Äãno ForEach. Tipo de resultado opaco do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> anterior </font><font style="vertical-align: inherit;">, lembra? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, prescrevemos a enumera√ß√£o dos √≠ndices dessa matriz e para cada um deles exibimos a visualiza√ß√£o por esse √≠ndice. Somos for√ßados a fazer isso, e n√£o iteramos sobre o View imediatamente, porque, para trabalhar com o ForEach, precisamos atribuir um identificador interno a cada elemento, para que o SwiftUI possa interagir com o conte√∫do da cole√ß√£o. Como alternativa, ter√≠amos que criar um identificador de proxy em cada Visualiza√ß√£o, mas por que, se √≠ndices podem ser usados?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Envolvemos cada visualiza√ß√£o da cole√ß√£o em uma condi√ß√£o e a mostramos apenas se estiver ativa. No entanto, a constru√ß√£o if-else simplesmente n√£o pode existir aqui, o compilador a utiliza para controle de fluxo, por isso colocamos tudo isso em Group para que o compilador compreenda exatamente o que √© View, ou mais precisamente, instru√ß√µes para o ViewBuilder criar um cont√™iner ConditionalContent opcional &lt;Vis√£o1, Vis√£o2&gt;. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, ao alterar o valor de currentViewInd, o SwiftUI oculta a visualiza√ß√£o ativa anterior e mostra a atual. Como voc√™ gosta dessa navega√ß√£o dentro do aplicativo?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ua/kr/gd/uakrgd2tzwv9hik_egmn1fglsfw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo o que falta fazer √© colocar a altera√ß√£o currentViewInd no wrapper withAnimation, e a altern√¢ncia entre janelas ficar√° suave. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adicione o modificador .transition, especificando .scale como o par√¢metro. </font><font style="vertical-align: inherit;">Isso tornar√° a anima√ß√£o da apar√™ncia e do desaparecimento de cada uma dessas visualiza√ß√µes diferentes - usando o dimensionamento em vez da transpar√™ncia usada pelo SwiftUI padr√£o.</font></font><br>
<br>
<pre><code class="swift hljs">                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                                .transition(.scale)<font></font>
                        }<font></font>
                    }<font></font>
                }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/l5/ib/d-/l5ibd-y7m986miqinbv56qaslfc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe que a exibi√ß√£o aparece e desaparece com a mesma anima√ß√£o, apenas o desaparecimento rola na ordem inversa. </font><font style="vertical-align: inherit;">De fato, podemos atribuir anima√ß√µes individualmente para a apar√™ncia e o desaparecimento de uma exibi√ß√£o. </font><font style="vertical-align: inherit;">Uma transi√ß√£o assim√©trica √© usada para isso.</font></font><br>
<br>
<pre><code class="swift hljs">                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                               .transition(.asymmetric(<font></font>
                                    insertion: insertion: <span class="hljs-type">AnyTransition</span>.scale(scale: <span class="hljs-number">0.1</span>, anchor: .leading).combined(with: .opacity),<font></font>
                                    removal: .move(edge: .trailing)))<font></font>
                        }<font></font>
                    }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mq/xg/ji/mqxgji1ton95qn6ywl23xhl2mzm.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A mesma anima√ß√£o .scale √© usada para aparecer na tela, mas agora especificamos os par√¢metros para seu uso. N√£o come√ßa com um tamanho zero (ponto), mas com um tamanho de 0,1 do normal. E a posi√ß√£o inicial da pequena janela n√£o est√° no centro da tela, mas mudou para a borda esquerda. Al√©m disso, nenhuma transi√ß√£o √© respons√°vel pela apar√™ncia, mas duas. Eles podem ser combinados com .combined (com :). Nesse caso, adicionamos transpar√™ncia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O desaparecimento da visualiza√ß√£o agora √© renderizado por outra anima√ß√£o - varrendo a borda direita da tela. Eu fiz a anima√ß√£o um pouco mais lenta para que voc√™ possa dar uma olhada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E como sempre, mal posso esperar para escrever minha pr√≥pria vers√£o da anima√ß√£o de transporte p√∫blico. Isso √© ainda mais simples que formul√°rios ou modificadores animados.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SpinTransitionModifier</span>: <span class="hljs-title">ViewModifier</span> </span>{
    <span class="hljs-keyword">let</span> angle: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> anchor: <span class="hljs-type">UnitPoint</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        content<font></font>
            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle), anchor: anchor)<font></font>
            .clipped()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">AnyTransition</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinIn</span><span class="hljs-params">(anchor: UnitPoint)</span></span> -&gt; <span class="hljs-type">AnyTransition</span> {<font></font>
        .modifier(<font></font>
            active: <span class="hljs-type">SpinTransitionModifier</span>(angle: -<span class="hljs-number">90</span>, anchor: anchor),<font></font>
            identity: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">0</span>, anchor: anchor))<font></font>
    }<font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinOut</span><span class="hljs-params">(anchor: UnitPoint)</span></span> -&gt; <span class="hljs-type">AnyTransition</span> {<font></font>
        .modifier(<font></font>
            active: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">90</span>, anchor: anchor),<font></font>
            identity: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">0</span>, anchor: anchor))<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/k-/mu/eck-muqydvucs1o59dkbnzpnw6e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para come√ßar, escrevemos o modificador usual no qual transferimos um certo n√∫mero - o √¢ngulo de rota√ß√£o em graus, bem como o ponto em rela√ß√£o ao qual essa rota√ß√£o ocorre. Em seguida, estendemos o tipo AnyTransition com duas fun√ß√µes. Poderia ter sido um, mas me pareceu mais conveniente. Achei mais f√°cil atribuir nomes falados a cada um deles do que controlar graus de rota√ß√£o diretamente na pr√≥pria Visualiza√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O tipo AnyTransition possui um m√©todo de modificador est√°tico, no qual passamos dois modificadores e obtemos um objeto AnyTransition que descreve uma transi√ß√£o suave de um estado para outro. identidade √© o modificador de estado normal da vista animada. Ativo √© o estado do in√≠cio da anima√ß√£o para a apar√™ncia da exibi√ß√£o ou o final da anima√ß√£o para o desaparecimento, ou seja, a outra extremidade do segmento, os estados nos quais ser√£o interpolados.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, spinIn implica que eu a usarei para fazer com que a visualiza√ß√£o apare√ßa fora da tela (ou o espa√ßo alocado para a visualiza√ß√£o) girando no sentido hor√°rio em torno do ponto especificado. spinOut significa que a visualiza√ß√£o desaparecer√° da mesma maneira, girando em torno do mesmo ponto, tamb√©m no sentido hor√°rio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De acordo com a minha ideia, se voc√™ usar o mesmo ponto para a apar√™ncia e o desaparecimento da Visualiza√ß√£o, ter√° o efeito de girar a tela inteira em torno desse ponto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toda anima√ß√£o √© baseada na mec√¢nica modificadora padr√£o. Se voc√™ escrever um modificador totalmente personalizado, dever√° implementar os requisitos do protocolo AnimatableModifier, como fizemos anteriormente com o TwoParameterBorder, ou usar os modificadores internos que fornecem sua pr√≥pria anima√ß√£o padr√£o. Nesse caso, contei com a anima√ß√£o interna .rotationEffect () dentro do meu modificador SpinTransitionModifier.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O modificador .transition () apenas esclarece o que considerar como o ponto inicial e final da anima√ß√£o. Se precisarmos solicitar o estado AnimatableData antes de iniciar a anima√ß√£o, solicitar o modificador AnimatableData do estado atual, calcular a diferen√ßa e animar a diminui√ß√£o de 1 a 0, ent√£o .transition () apenas altera os dados originais. Voc√™ n√£o est√° apegado ao estado da sua Visualiza√ß√£o; n√£o se baseia nela. Voc√™ mesmo especifica explicitamente o estado inicial e final; a partir deles, obt√©m AnimatableData, calcula a diferen√ßa e a anima. Ent√£o, no final da anima√ß√£o, sua vis√£o atual √© destacada.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A prop√≥sito, a identidade √© um modificador que permanecer√° aplicado √† sua Visualiza√ß√£o no final da anima√ß√£o. Caso contr√°rio, um erro aqui levaria a saltos no final da anima√ß√£o de apar√™ncia e no in√≠cio da anima√ß√£o de desaparecimento. Portanto, a transi√ß√£o pode ser considerada como "dois em um" - aplicando um modificador espec√≠fico diretamente ao View + a capacidade de animar suas altera√ß√µes quando o View aparecer e desaparecer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Honestamente, esse mecanismo de controle de anima√ß√£o me parece muito forte e lamento n√£o podermos us√°-lo para qualquer anima√ß√£o. Eu n√£o recusaria isso por criar infinitas anima√ß√µes fechadas. No entanto, falaremos sobre isso no pr√≥ximo artigo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para ver melhor como a mudan√ßa ocorre, substitu√≠ nossa visualiza√ß√£o de teste por quadrados elementares, assinados com n√∫meros e emoldurados.</font></font><br>
<br>
<pre><code class="swift hljs">                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-comment">//self.views[ind]</span>
                            <span class="hljs-type">Rectangle</span>()<font></font>
                                .fill(<span class="hljs-type">Color</span>.gray)<font></font>
                                .frame(width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)<font></font>
                                .border(<span class="hljs-type">Color</span>.black, width: <span class="hljs-number">2</span>)<font></font>
                                .overlay(<span class="hljs-type">Text</span>(<span class="hljs-string">"\(ind + 1)"</span>))<font></font>
                              .transition(.asymmetric(<font></font>
                                  insertion: .spinIn(anchor: .bottomTrailing),<font></font>
                                  removal: .spinOut(anchor: .bottomTrailing)))<font></font>
                        }<font></font>
                    }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vx/4s/u9/vx4su9aoaqzuqzi2wq8uctpxe7c.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E para tornar esse movimento ainda melhor, eu removi .clipped () do modificador SpinTransitionModifier:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SpinTransitionModifier</span>: <span class="hljs-title">ViewModifier</span> </span>{
    <span class="hljs-keyword">let</span> angle: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> anchor: <span class="hljs-type">UnitPoint</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        content<font></font>
            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle), anchor: anchor)
            <span class="hljs-comment">//.clipped()</span><font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ih/ml/0i/ihml0id6hnttwuhbjuv5s28jhaa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A prop√≥sito, agora precisamos do SpinTransitionModifier em nosso pr√≥prio modificador. </font><font style="vertical-align: inherit;">Ele foi criado apenas para combinar os dois modificadores, rotationEffect e clipped () em um, para que a anima√ß√£o de rota√ß√£o n√£o ultrapasse o escopo selecionado para a nossa Visualiza√ß√£o. </font><font style="vertical-align: inherit;">Agora, podemos usar .rotationEffect () diretamente dentro de .modifier (), n√£o precisamos de um intermedi√°rio na forma de SpinTransitionModifier.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando a vista morre</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um ponto interessante √© o ciclo de vida da exibi√ß√£o, se for colocado em um if-else. </font><font style="vertical-align: inherit;">A exibi√ß√£o, embora iniciada e registrada como um elemento da matriz, n√£o √© armazenada na mem√≥ria. </font><font style="vertical-align: inherit;">Toda ela</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estado</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">os par√¢metros s√£o redefinidos para o padr√£o na pr√≥xima vez que aparecerem na tela. Isso √© quase o mesmo que inicializa√ß√£o. Apesar do fato de que a pr√≥pria estrutura de objetos ainda existe, a renderiza√ß√£o a removeu de seu campo de vis√£o, pois n√£o existe. Por um lado, isso reduz o uso de mem√≥ria. Se voc√™ tiver um grande n√∫mero de visualiza√ß√µes complexas na matriz, a renderiza√ß√£o precisar√° desenh√°-las todas constantemente, reagindo a altera√ß√µes - isso afetou negativamente o desempenho. Se n√£o me engano, esse foi o caso antes da atualiza√ß√£o do Xcode 11.3. Agora, visualiza√ß√µes inativas s√£o descarregadas da mem√≥ria de renderiza√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por outro lado, devemos mover todos os estados importantes al√©m do escopo desta vis√£o. Para isso, √© melhor usar as vari√°veis ‚Äã‚Äã@EnvironmentObject.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Retornando ao ciclo de vida, tamb√©m deve ser observado que o modificador .onAppear {}, se houver um registrado nesta Visualiza√ß√£o, funciona imediatamente ap√≥s alterar a condi√ß√£o e a apar√™ncia da Visualiza√ß√£o na tela, mesmo antes do in√≠cio da anima√ß√£o. </font><font style="vertical-align: inherit;">Assim, onDisappear {} √© acionado ap√≥s o final da anima√ß√£o de desaparecimento. </font><font style="vertical-align: inherit;">Lembre-se disso se planeja us√°-los com anima√ß√£o de transi√ß√£o.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qual √© o pr√≥ximo? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ufa </font><font style="vertical-align: inherit;">Foi bastante volumoso, mas em detalhes e, espero, intelig√≠vel. </font><font style="vertical-align: inherit;">Honestamente, eu esperava falar sobre anima√ß√£o arco-√≠ris como parte de um artigo, mas n√£o conseguia parar no tempo com os detalhes. </font><font style="vertical-align: inherit;">Ent√£o aguarde a continua√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A seguinte parte nos espera:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uso de gradientes: linear, circular e angular - tudo ser√° √∫til</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cor n√£o √© cor: escolha sabiamente.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anima√ß√£o em loop: como iniciar e como parar e como parar imediatamente (sem anima√ß√£o, alterando a anima√ß√£o - sim, tamb√©m existe uma)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anima√ß√£o atual do fluxo: prioridades, substitui√ß√µes, anima√ß√£o diferente para objetos diferentes</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">detalhes sobre os tempos de anima√ß√£o: orientaremos os tempos na cauda e na crina, at√© nossa pr√≥pria implementa√ß√£o do timingCurve (oh, mantenha-me sete :))</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como descobrir o momento atual da anima√ß√£o reproduzida</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o SwiftUI n√£o for suficiente</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vou falar sobre tudo isso em detalhes usando o exemplo da cria√ß√£o de anima√ß√£o em arco-√≠ris, como na figura:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu n√£o segui o caminho mais f√°cil, mas colecionei todos os ancinhos que pude alcan√ßar, incorporando esta anima√ß√£o nos princ√≠pios descritos acima. </font><font style="vertical-align: inherit;">A hist√≥ria sobre isso deve ser muito informativa e rica em truques e todos os tipos de hacks, sobre os quais houve poucos relat√≥rios e que ser√£o √∫teis para aqueles que decidirem se tornar pioneiros no SwiftUI. </font><font style="vertical-align: inherit;">Aparecer√° aproximadamente em uma semana ou duas. </font><font style="vertical-align: inherit;">A prop√≥sito, voc√™ pode se inscrever para n√£o perder. </font><font style="vertical-align: inherit;">Mas isso, √© claro, somente se o material lhe parecer √∫til e o m√©todo de apresenta√ß√£o for aprovado. </font><font style="vertical-align: inherit;">Em seguida, sua assinatura ajudar√° a trazer rapidamente novos artigos para o topo, levando-os a um p√∫blico mais amplo mais cedo. </font><font style="vertical-align: inherit;">Caso contr√°rio, escreva nos coment√°rios o que est√° errado.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt504186/index.html">Paul Graham: Como Escrever Textos √öteis (Completo)</a></li>
<li><a href="../pt504188/index.html">Quarentena, sistemas online e ci√™ncia de dados. Quem pensa em reten√ß√£o de clientes?</a></li>
<li><a href="../pt504190/index.html">MVCC como uma maneira de garantir o isolamento da transa√ß√£o</a></li>
<li><a href="../pt504194/index.html">O resultado de uma pesquisa de desenvolvedores no Stack Overflow 2020 (+ habraopros)</a></li>
<li><a href="../pt504196/index.html">NFC: Analisando a tecnologia de comunica√ß√£o de campo pr√≥ximo</a></li>
<li><a href="../pt504204/index.html">Workshops da IBM: Quarkus (Java ultra-r√°pido para microsservi√ßos), Jakarta EE e OpenShift</a></li>
<li><a href="../pt504208/index.html">Como automatizar um centro de servi√ßo compartilhado</a></li>
<li><a href="../pt504210/index.html">O que √© o Deno e ele substituir√° o Node.js?</a></li>
<li><a href="../pt504214/index.html">O desenvolvimento do DATA VAULT e a transi√ß√£o para o BUSINESS DATA VAULT</a></li>
<li><a href="../pt504216/index.html">Quantos anos tem esta casa? Como eu fiz um mapa da idade das casas em S√£o Petersburgo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>