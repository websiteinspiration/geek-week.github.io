<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüëß üëí üòÄ Bases de ZFS: stockage et performances üê∞ üôÜüèø üò°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce printemps, nous avons d√©j√† discut√© de quelques sujets d'introduction, tels que la fa√ßon de v√©rifier la vitesse de vos disques et ce qu'est le RAID ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Bases de ZFS: stockage et performances</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504692/"><img src="https://habrastorage.org/getpro/habr/post_images/abf/883/e96/abf883e96b01dbc78420e0dc1a158460.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce printemps, nous avons d√©j√† discut√© de quelques sujets d'introduction, tels </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que la fa√ßon de v√©rifier la vitesse de vos disques</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce qu'est le RAID</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dans le second d'entre eux, nous avons m√™me promis de continuer √† √©tudier les performances de diff√©rentes topologies multi-disques dans ZFS. </font><font style="vertical-align: inherit;">Il s'agit du syst√®me de fichiers de nouvelle g√©n√©ration qui est impl√©ment√© partout: d' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apple</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubuntu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, aujourd'hui est le meilleur jour pour d√©couvrir ZFS, lecteurs curieux. </font><font style="vertical-align: inherit;">Sachez simplement que, selon une √©valuation prudente du d√©veloppeur d'OpenZFS Matt Arens, "c'est vraiment compliqu√©". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais avant d'en arriver aux chiffres - et ils le feront, je le promets - pour toutes les variantes de configuration de vosmidiskovoy ZFS, vous devez parler de la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fa√ßon dont</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ZFS stocke les donn√©es sur le disque.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zpool, vdev et appareil</font></font></h1><br>
<img src="https://habrastorage.org/getpro/habr/post_images/674/1c6/ab3/6741c6ab310f4e0edf2adf7e2ca4c6bb.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce diagramme de pool complet comprend trois vdev auxiliaires, un pour chaque classe et quatre pour RAIDz2. </font></font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b9f/82c/887/b9f82c88748c44d1f86cc412a053bf94.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il n'y a g√©n√©ralement aucune raison de cr√©er un pool de types et de tailles de </font></font></font></i><font style="vertical-align: inherit;"><i><font color="gray"><font style="vertical-align: inherit;">vdev </font></font></i><i><font color="gray"><font style="vertical-align: inherit;">inappropri√©s - mais si vous le souhaitez, rien ne vous emp√™che de le faire.</font></font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pour vraiment comprendre le syst√®me de fichiers ZFS , vous devez examiner attentivement sa structure r√©elle. </font><font style="vertical-align: inherit;">Premi√®rement, ZFS combine les niveaux traditionnels de gestion des volumes et le syst√®me de fichiers. </font><font style="vertical-align: inherit;">Deuxi√®mement, il utilise un m√©canisme de copie transactionnelle lors de l'√©criture. </font><font style="vertical-align: inherit;">Ces caract√©ristiques signifient que le syst√®me est structurellement tr√®s diff√©rent des syst√®mes de fichiers ordinaires et des matrices RAID. </font><font style="vertical-align: inherit;">Le premier ensemble de blocs de construction de base √† comprendre: un pool de stockage (zpool), un p√©riph√©rique virtuel (vdev) et un p√©riph√©rique r√©el (p√©riph√©rique).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zpool</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le pool de stockage zpool est la structure ZFS la plus √©lev√©e. Chaque pool contient un ou plusieurs p√©riph√©riques virtuels. √Ä leur tour, chacun d'eux contient un ou plusieurs appareils r√©els (appareil). Les pools virtuels sont des blocs autonomes. Un ordinateur physique peut contenir deux ou plusieurs pools distincts, mais chacun est compl√®tement ind√©pendant des autres. Les pools ne peuvent pas partager de p√©riph√©riques virtuels. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La redondance de ZFS se situe au niveau des p√©riph√©riques virtuels, mais pas au niveau des pools. Au niveau du pool, il n'y a absolument aucune redondance - si un lecteur vdev ou un vdev sp√©cial est perdu, alors le pool entier est perdu avec lui.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les pools de stockage modernes peuvent survivre √† la perte d'un cache ou d'un journal de p√©riph√©rique virtuel - bien qu'ils puissent perdre une petite quantit√© de donn√©es sales s'ils perdent le journal vdev lors d'une panne de courant ou d'un crash syst√®me. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe une id√©e fausse commune selon laquelle des ¬´bandes de donn√©es¬ª (bandes) de ZFS sont enregistr√©es sur l'ensemble du pool. Ce n'est pas vrai. Zpool n'est pas du tout un RAID0 amusant, c'est plut√¥t un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JBOD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> amusant </font><font style="vertical-align: inherit;">avec un m√©canisme de distribution modifiable complexe.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour la plupart, les entr√©es sont r√©parties entre les p√©riph√©riques virtuels disponibles en fonction de l'espace disponible, donc th√©oriquement, elles seront toutes remplies en m√™me temps. Dans les versions ult√©rieures de ZFS, l'utilisation actuelle (l'√©limination) de vdev est prise en compte - si un p√©riph√©rique virtuel est nettement plus charg√© que l'autre (par exemple, en raison de la charge de lecture), il sera temporairement ignor√© pour l'√©criture, malgr√© la pr√©sence du coefficient d'espace libre le plus √©lev√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un m√©canisme de d√©tection du recyclage int√©gr√© aux m√©thodes modernes de distribution des enregistrements ZFS peut r√©duire la latence et augmenter le d√©bit pendant les p√©riodes de charge inhabituellement √©lev√©e - mais ce n'est pas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">carte blanche</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©lange involontaire de disques durs lents et de disques SSD rapides dans un seul pool. </font><font style="vertical-align: inherit;">Une telle piscine in√©gale fonctionnera toujours √† la vitesse de l'appareil le plus lent, c'est-√†-dire comme s'il √©tait enti√®rement compos√© de tels appareils.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vdev</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque pool de stockage se compose d'un ou plusieurs p√©riph√©riques virtuels (p√©riph√©rique virtuel, vdev). </font><font style="vertical-align: inherit;">√Ä son tour, chaque vdev comprend un ou plusieurs appareils r√©els. </font><font style="vertical-align: inherit;">La plupart des p√©riph√©riques virtuels sont utilis√©s pour stocker facilement des donn√©es, mais il existe plusieurs classes d'assistance vdev, notamment CACHE, LOG et SPECIAL. </font><font style="vertical-align: inherit;">Chacun de ces types de vdev peut avoir l'une des cinq topologies: mono-p√©riph√©rique, RAIDz1, RAIDz2, RAIDz3 ou miroir.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAIDz1, RAIDz2 et RAIDz3 sont des variations sp√©ciales de ce que les anciens appellent la parit√© double (diagonale) RAID. 1, 2 et 3 font r√©f√©rence au nombre de blocs de parit√© allou√©s pour chaque bande de donn√©es. Au lieu de disques s√©par√©s pour la parit√©, les p√©riph√©riques RAIDz virtuels r√©partissent uniform√©ment cette parit√© sur les disques. Une matrice RAIDz peut perdre autant de disques qu'elle a de blocs de parit√©; s'il en perd un autre, il √©chouera et emportera le pool de stockage avec lui.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les p√©riph√©riques virtuels en miroir (miroir vdev), chaque bloc est stock√© sur chaque p√©riph√©rique dans vdev. Bien qu'il s'agisse des miroirs double largeur les plus courants, il peut y avoir un nombre arbitraire de p√©riph√©riques dans le miroir - dans les grandes installations, les triples sont souvent utilis√©s pour augmenter les performances de lecture et la tol√©rance aux pannes. Le miroir vdev peut survivre √† toute panne pendant qu'au moins un p√©riph√©rique dans vdev continue de fonctionner. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les vdev uniques sont intrins√®quement dangereux. Un tel p√©riph√©rique virtuel ne survivra pas √† une seule d√©faillance - et s'il est utilis√© comme stockage ou un vdev sp√©cial, sa d√©faillance entra√Ænera la destruction de l'ensemble du pool. Soyez tr√®s, tr√®s prudent ici.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les appliances virtuelles CACHE, LOG et SPECIAL peuvent √™tre cr√©√©es √† l'aide de l'une des topologies ci-dessus - mais n'oubliez pas que la perte d'une appliance virtuelle SPECIAL signifie la perte d'un pool, donc une topologie excessive est fortement recommand√©e.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dispositif</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est probablement le terme le plus facile √† comprendre dans ZFS - c'est litt√©ralement un p√©riph√©rique √† acc√®s al√©atoire par blocs. N'oubliez pas que les p√©riph√©riques virtuels sont constitu√©s de p√©riph√©riques individuels et que le pool est compos√© de p√©riph√©riques virtuels. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les disques - magn√©tiques ou √† semi-conducteurs - sont les unit√©s de blocs les plus courantes utilis√©es comme blocs de construction vdev. Cependant, tout p√©riph√©rique avec une poign√©e dans / dev convient - vous pouvez donc utiliser des matrices RAID mat√©rielles enti√®res en tant que p√©riph√©riques s√©par√©s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un fichier brut simple est l'un des p√©riph√©riques de blocs alternatifs les plus importants √† partir desquels vdev peut √™tre construit. Pools de tests √† partir de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fichiers √©pars</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;- Un moyen tr√®s pratique de v√©rifier les commandes du pool et de voir combien d'espace est disponible dans le pool ou le p√©riph√©rique virtuel de cette topologie. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5cf/aa5/62c/5cfaa562cb208b654af113f7535b8f57.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez cr√©er un pool de test √† partir de fichiers √©pars en quelques secondes - mais n'oubliez pas de supprimer le pool entier et ses composants plus tard.</font></font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Supposons que vous souhaitiez mettre un serveur sur huit disques et pr√©voyez d'utiliser des disques de 10 To (~ 9300 Gio) - mais vous ne savez pas exactement La topologie correspond le mieux √† vos besoins. Dans l'exemple ci-dessus, en quelques secondes, nous construisons un pool de test √† partir de fichiers √©pars - et nous savons maintenant que RAIDz2 vdev √† partir de huit disques de 10 To fournit 50 TiB de capacit√© utile.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une autre classe sp√©ciale d'appareils est SPARE (rechange). Les p√©riph√©riques rempla√ßables √† chaud, contrairement aux p√©riph√©riques conventionnels, appartiennent √† l'ensemble du pool, pas √† un seul p√©riph√©rique virtuel. Si certains vdev du pool √©chouent et qu'un p√©riph√©rique de rechange est connect√© au pool et accessible, il rejoindra automatiquement le vdev affect√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s la connexion au vdev affect√©, le p√©riph√©rique de rechange commence √† recevoir des copies ou la reconstruction des donn√©es qui devraient se trouver sur le p√©riph√©rique manquant. Dans le RAID traditionnel, cela s'appelle la reconstruction, tandis que dans ZFS, il est appel√© ¬´resilvering¬ª.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est important de noter que les appareils de remplacement ne remplacent pas d√©finitivement les appareils d√©fectueux. </font><font style="vertical-align: inherit;">Il ne s'agit que d'un remplacement temporaire pour r√©duire le temps pendant lequel une d√©gradation de vdev est observ√©e. </font><font style="vertical-align: inherit;">Une fois que l'administrateur a remplac√© le p√©riph√©rique vdev d√©fectueux, la redondance est restaur√©e sur ce p√©riph√©rique permanent et SPARE se d√©connecte de vdev et retourne au travail en tant que pi√®ce de rechange pour l'ensemble du pool.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensembles de donn√©es, blocs et secteurs</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le prochain ensemble de blocs de construction que vous devez comprendre lors de notre voyage √† travers ZFS n'est pas tant le mat√©riel, mais la fa√ßon dont les donn√©es sont organis√©es et stock√©es. </font><font style="vertical-align: inherit;">Nous sautons plusieurs niveaux ici - comme le m√©taslab - afin de ne pas empiler les d√©tails tout en maintenant une compr√©hension de la structure globale.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Base de donn√©es</font></font></h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/bd3/c48/d9d/bd3c48d9dff6e0f493a5d90d1dca6d1d.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque nous cr√©ons un ensemble de donn√©es pour la premi√®re fois, il affiche tout l'espace de pool disponible. Ensuite, nous d√©finissons le quota - et modifions le point de montage. La magie! </font></font></font></i> <br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a18/3de/210/a183de210cdc57cd1421652201cbf2c3.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zvol n'est pour la plupart qu'un ensemble de donn√©es, d√©pourvu de sa couche de syst√®me de fichiers, que nous rempla√ßons ici par un</font></font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
syst√®me de fichiers</font><i><font color="gray"><font style="vertical-align: inherit;"> ext4 tout √† fait normal</font></font></i><font style="vertical-align: inherit;"> . L'ensemble de donn√©es ZFS est √† peu pr√®s le m√™me qu'un syst√®me de fichiers mont√© standard. Comme un syst√®me de fichiers classique, il semble √† premi√®re vue √™tre ¬´juste un autre dossier¬ª. Mais aussi, comme les syst√®mes de fichiers mont√©s conventionnels, chaque jeu de donn√©es ZFS a son propre ensemble de propri√©t√©s de base.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, un ensemble de donn√©es peut avoir un quota attribu√©. S'il est install√©</font></font><code>zfs set quota=100G poolname/datasetname</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous ne pouvez pas √©crire dans le dossier mont√©</font></font><code>/poolname/datasetname</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plus de 100 Gio.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous remarquez la pr√©sence - et l'absence - de barres obliques au d√©but de chaque ligne? Chaque ensemble de donn√©es a sa propre place √† la fois dans la hi√©rarchie ZFS et dans la hi√©rarchie de montage syst√®me. Il n'y a pas de barre oblique dans la hi√©rarchie ZFS - vous commencez avec le nom du pool, puis le chemin d'un ensemble de donn√©es au suivant. Par exemple, </font></font><code>pool/parent/child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour un ensemble de donn√©es nomm√© </font></font><code>child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sous l'ensemble </font></font><code>parent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font><font style="vertical-align: inherit;">donn√©es parent </font><font style="vertical-align: inherit;">dans un pool avec un nom de cr√©ation </font></font><code>pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par d√©faut, le point de montage de l'ensemble de donn√©es sera √©quivalent √† son nom dans la hi√©rarchie ZFS, avec une barre oblique au d√©but - le pool avec le nom est </font></font><code>pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mont√© en tant que </font></font><code>/pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, l'ensemble de donn√©es est </font></font><code>parent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mont√© dans </font></font><code>/pool/parent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et l' </font><font style="vertical-align: inherit;">ensemble de donn√©es </font><font style="vertical-align: inherit;">enfant </font><font style="vertical-align: inherit;">est mont√© </font></font><code>child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans </font></font><code>/pool/parent/child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cependant, le point de montage syst√®me de l'ensemble de donn√©es peut √™tre modifi√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous indiquons</font></font><code>zfs set mountpoint=/lol pool/parent/child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis l'ensemble de donn√©es est </font></font><code>pool/parent/child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mont√© dans le syst√®me en tant que </font></font><code>/lol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus des ensembles de donn√©es, nous devons mentionner les volumes (zvols). </font><font style="vertical-align: inherit;">Un volume est √† peu pr√®s similaire √† un ensemble de donn√©es, sauf qu'il n'a en fait pas de syst√®me de fichiers - c'est juste un p√©riph√©rique bloc. </font><font style="vertical-align: inherit;">Vous pouvez, par exemple, cr√©er </font></font><code>zvol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec un nom </font></font><code>mypool/myzvol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis le formater avec le syst√®me de fichiers ext4, puis monter ce syst√®me de fichiers - vous avez maintenant le syst√®me de fichiers ext4, mais avec la prise en charge de toutes les fonctionnalit√©s de s√©curit√© ZFS! </font><font style="vertical-align: inherit;">Cela peut sembler idiot sur un ordinateur, mais cela a beaucoup plus de sens en tant que backend lors de l'exportation d'un p√©riph√©rique iSCSI.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blocs</font></font></h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/74b/4dd/d00/74b4ddd009e67db1b1b6c4467bcf6fa3.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un fichier est repr√©sent√© par un ou plusieurs blocs. Chaque bloc est stock√© sur un appareil virtuel. La taille du bloc est g√©n√©ralement √©gale au param√®tre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recordsize</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais peut √™tre r√©duite √† </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 ^ ashift</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s'il contient des m√©tadonn√©es ou un petit fichier. </font></font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8d1/7fd/ad2/8d17fdad2eda641c801e5e6a302f6e38.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous </font><font style="vertical-align: inherit;">ne plaisantons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vraiment</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pas sur les √©normes dommages aux performances si vous installez trop petit ashift</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dans le pool ZFS, toutes les donn√©es, y compris les m√©tadonn√©es, sont stock√©es dans des blocs. La taille de bloc maximale pour chaque ensemble de donn√©es est d√©finie dans la propri√©t√©</font></font><code>recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(taille d'enregistrement). La taille de l'enregistrement peut varier, mais cela ne changera pas la taille ou l'emplacement des blocs qui ont d√©j√† √©t√© √©crits dans l'ensemble de donn√©es - cela ne fonctionne que pour les nouveaux blocs au fur et √† mesure qu'ils sont √©crits.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sauf indication contraire, la taille d'enregistrement actuelle est de 128 Ko par d√©faut. C'est une sorte de compromis difficile dans lequel les performances ne seront pas id√©ales, mais pas terribles dans la plupart des cas. </font></font><code>Recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut √™tre r√©gl√© sur n'importe quelle valeur de 4K √† 1M (avec des param√®tres suppl√©mentaires, </font></font><code>recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous pouvez d√©finir encore plus, mais c'est rarement une bonne id√©e). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout bloc fait r√©f√©rence aux donn√©es d'un seul fichier - vous ne pouvez pas compresser deux fichiers diff√©rents en un seul bloc. Chaque fichier se compose d'un ou plusieurs blocs, selon la taille. Si la taille du fichier est inf√©rieure √† la taille de l'enregistrement, elle sera enregistr√©e dans un bloc plus petit - par exemple, un bloc avec un fichier de 2 Ko n'occupera qu'un seul secteur de 4 Ko sur le disque. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si le fichier est suffisamment volumineux et n√©cessite plusieurs blocs, tous les enregistrements avec ce fichier auront une taille</font></font><code>recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;- y compris le dernier enregistrement, dont la partie principale peut s'av√©rer √™tre de l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espace inutilis√©</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les volumes Zvol n'ont pas de propri√©t√© </font></font><code>recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;- ils ont plut√¥t une propri√©t√© √©quivalente </font></font><code>volblocksize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les secteurs</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le dernier √©l√©ment de construction le plus fondamental est le secteur. Il s'agit de la plus petite unit√© physique pouvant √™tre √©crite ou lue sur l'unit√© de base. Pendant plusieurs d√©cennies, la plupart des disques ont utilis√© des secteurs de 512 octets. R√©cemment, la plupart des disques sont configur√©s pour 4 secteurs KiB, et dans certains - en particulier les SSD - 8 secteurs KiB ou m√™me plus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFS poss√®de une propri√©t√© qui vous permet de d√©finir manuellement la taille du secteur. Ceci est une propri√©t√© </font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il est quelque peu d√©routant que ashift soit une puissance de deux. Par exemple, cela </font></font><code>ashift=9</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">signifie une taille de secteur de 2 ^ 9, ou 512 octets.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFS demande au syst√®me d'exploitation des informations d√©taill√©es sur chaque p√©riph√©rique de bloc lorsqu'il est ajout√© au nouveau vdev et th√©oriquement d√©finit automatiquement ashift correctement sur la base de ces informations. Malheureusement, de nombreux disques mentent sur leur taille de secteur afin de maintenir la compatibilit√© avec Windows XP (qui n'a pas pu comprendre les disques avec d'autres tailles de secteur). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela signifie que l'administrateur ZFS est fortement conseill√© de conna√Ætre la taille r√©elle du secteur de leurs appareils et d'installer manuellement</font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si un d√©calage trop petit est d√©fini, le nombre d'op√©rations de lecture / √©criture augmente astronomiquement. Donc, √©crire des ¬´secteurs¬ª de 512 octets dans le vrai secteur de 4 Ko signifie √©crire le premier ¬´secteur¬ª, puis lire le secteur de 4 Ko, le changer avec le deuxi√®me ¬´secteur¬ª de 512 octets, le r√©√©crire dans le nouveau secteur de 4 Ko, etc. pour chaque entr√©e. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le monde r√©el, une telle p√©nalit√© bat les </font></font><code>ashift=13</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSD </font><font style="vertical-align: inherit;">Samsung EVO, pour lesquels elle doit agir </font><font style="vertical-align: inherit;">, mais ces SSD reposent sur la taille de leur secteur, et par cons√©quent, elle est d√©finie par d√©faut </font></font><code>ashift=9</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si un administrateur syst√®me exp√©riment√© ne modifie pas ce param√®tre, ce SSD est </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plus lent qu'un</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> disque dur magn√©tique classique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A titre de comparaison, pour une taille trop grande</font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il n'y a pratiquement pas de p√©nalit√©. </font><font style="vertical-align: inherit;">Il n'y a pas de r√©elle diminution de la productivit√© et l'augmentation de l'espace inutilis√© est infiniment petite (ou √©gale √† z√©ro avec la compression activ√©e). </font><font style="vertical-align: inherit;">Par cons√©quent, nous recommandons fortement que m√™me les disques qui utilisent r√©ellement des secteurs de 512 octets soient install√©s </font></font><code>ashift=12</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou m√™me </font></font><code>ashift=13</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de regarder l'avenir avec confiance. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La propri√©t√© est </font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©finie pour chaque p√©riph√©rique virtuel vdev, et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">non pour le pool</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , comme beaucoup le pensent par erreur - et ne change pas apr√®s l'installation. </font><font style="vertical-align: inherit;">Si vous avez accidentellement renvers√© </font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lors de l'ajout d'un nouveau vdev √† la piscine, vous avez irr√©m√©diablement contamin√© cette piscine avec un appareil √† faible performance et, en r√®gle g√©n√©rale, il n'y a pas d'autre moyen que de d√©truire la piscine et de tout recommencer. </font><font style="vertical-align: inherit;">M√™me la suppression de vdev ne vous sauvera pas d'une configuration cass√©e</font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">!</font></font><br>
<br>
<h3>   </h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/38b/a1e/4a8/38ba1e4a8fa0e255081ed8db259a302f.gif"><br>
<i><font color="gray">      &nbsp;‚Äî     ,   </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/90d/4cb/a35/90d4cba35ffa5a3e44a7ca5f61d4491b.gif"><br>
<i><font color="gray">         ,     </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c8b/2af/ffb/c8b2afffbc46f63f6a7fe1167edf5dcb.gif"><br>
<i><font color="gray">  ,      ,   ¬´ ¬ª   ¬´ ¬ª,        </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4c1/e2b/818/4c1e2b818077cb07d651527e214363fe.gif"><br>
<i><font color="gray">     ,       ‚Äî      ,     ,       </font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La copie sur √©criture (CoW) est le fondement fondamental de ce qui rend ZFS si g√©nial. Le concept de base est simple - si vous demandez au syst√®me de fichiers traditionnel de modifier le fichier, il fera exactement ce que vous avez demand√©. Si vous demandez au syst√®me de fichiers avec copie pendant l'enregistrement de faire de m√™me, il vous r√©pondra ¬´bien¬ª - mais cela vous ment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au lieu de cela, le syst√®me de fichiers copie-√©criture √©crit la nouvelle version du bloc modifi√©, puis met √† jour les m√©tadonn√©es du fichier pour rompre le lien avec l'ancien bloc et associer le nouveau bloc que vous venez d'√©crire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D√©connecter l'ancienne unit√© et relier la nouvelle se fait en une seule op√©ration, donc elle ne peut pas √™tre interrompue - si vous r√©initialisez l'alimentation apr√®s cela, vous avez une nouvelle version du fichier, et si vous r√©initialisez l'alimentation plus t√¥t, alors vous avez l'ancienne version. </font><font style="vertical-align: inherit;">Dans tous les cas, il n'y aura pas de conflit dans le syst√®me de fichiers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La copie lors de l'√©criture dans ZFS s'effectue non seulement au niveau du syst√®me de fichiers, mais √©galement au niveau de la gestion des disques. </font><font style="vertical-align: inherit;">Cela signifie que ZFS n'est pas soumis √† un espace dans l'enregistrement (un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trou dans le RAID</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - un ph√©nom√®ne lorsque la bande n'a r√©ussi qu'√† enregistrer partiellement avant que le syst√®me ne plante, avec la baie endommag√©e apr√®s un red√©marrage. </font><font style="vertical-align: inherit;">Ici, la bande est atomique, vdev est toujours coh√©rent et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bob est votre oncle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZIL: Journal d'intention ZFS</font></font></h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/567/71c/73f/56771c73f9a28ebaed161e02313deadb.png"><br>
<i><font color="gray"> ZFS     &nbsp;‚Äî  ,      ZIL,            </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/cec/7c5/437/cec7c5437087f6816f9cdea5f6829820.png"><br>
<i><font color="gray"> ,   ZIL,    .      </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/075/65a/d6b/07565ad6b2f431db3e6bc20cd24a653b.png"><br>
<i><font color="gray">SLOG,   LOG-, ‚Äî   &nbsp;‚Äî , ,  &nbsp;‚Äî&nbsp;vdev,  ZIL      </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/927/0f7/539/9270f7539b759aa37896d41e04c4ec47.png"><br>
<i><font color="gray">      ZIL &nbsp;‚Äî    ZIL   SLOG,      </font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe deux cat√©gories principales d'op√©rations d'√©criture: synchrones (sync) et asynchrones (async). Pour la plupart des charges de travail, la grande majorit√© des op√©rations d'√©criture sont asynchrones - le syst√®me de fichiers vous permet de les agr√©ger et de les livrer par lots, r√©duisant la fragmentation et augmentant consid√©rablement le d√©bit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les enregistrements synchrones sont une tout autre affaire. Lorsqu'une application demande une √©criture synchrone, elle indique au syst√®me de fichiers: "Vous devez valider ceci dans la m√©moire non volatile </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√®s maintenant</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et d'ici l√†, je ne peux rien faire de plus." Par cons√©quent, les enregistrements synchrones doivent √™tre imm√©diatement valid√©s sur le disque - et si cela augmente la fragmentation ou r√©duit la bande passante, qu'il en soit ainsi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFS traite les enregistrements synchrones diff√©remment des syst√®mes de fichiers standard - au lieu de les t√©l√©charger imm√©diatement dans un stockage normal, ZFS les enregistre dans une zone de stockage sp√©ciale appel√©e journal d'intention ZFS - Journal d'intention ZFS ou ZIL. L'astuce est que ces enregistrements </font><font style="vertical-align: inherit;">restent </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©galement</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en m√©moire, √©tant agr√©g√©s avec des demandes d'√©criture asynchrones r√©guli√®res, pour √™tre ensuite transf√©r√©s dans le stockage en tant que TXG parfaitement normaux (groupes de transactions, groupes de transactions). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fonctionnement normal, le ZIL est enregistr√© et jamais lu √† nouveau. Lorsque, apr√®s quelques instants, les enregistrements de ZIL sont fix√©s dans le stockage principal dans le TXG ordinaire de la RAM, ils sont d√©connect√©s de ZIL. La seule chose quand quelque chose est lu depuis ZIL est lors de l'importation du pool.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si ZFS se bloque - le syst√®me d'exploitation se bloque ou des pannes de courant - lorsqu'il y a des donn√©es dans ZIL, ces donn√©es seront lues lors de la prochaine importation du pool (par exemple, lorsque le syst√®me d'urgence red√©marre). Tout ce qui se trouve dans le ZIL sera lu, combin√© en groupes TXG, engag√© dans le stockage principal, puis d√©connect√© du ZIL pendant le processus d'importation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'une des classes d'assistance vdev est appel√©e LOG ou SLOG, le p√©riph√©rique LOG secondaire. Il a une t√¢che - fournir au pool un p√©riph√©rique vdev s√©par√© et, de pr√©f√©rence beaucoup plus rapide, avec une r√©sistance √† l'√©criture tr√®s √©lev√©e, pour stocker ZIL, au lieu de stocker ZIL dans le stockage vdev principal. ZIL lui-m√™me se comporte de la m√™me mani√®re quel que soit l'emplacement de stockage, mais si vdev avec LOG a des performances d'√©criture tr√®s √©lev√©es, les √©critures synchrones seront plus rapides.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'ajout de vdev avec LOG au pool </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne peut pas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> am√©liorer les performances d'√©criture asynchrone - m√™me si vous forcez toutes les √©critures dans ZIL √† l'aide </font></font><code>zfs set sync=always</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, elles seront toujours li√©es au r√©f√©rentiel principal dans TXG de la m√™me mani√®re et au m√™me rythme que sans journal. </font><font style="vertical-align: inherit;">La seule am√©lioration directe des performances est le retard de l'enregistrement synchrone (car une vitesse d'enregistrement plus √©lev√©e acc√©l√®re les op√©rations </font></font><code>sync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, dans un environnement qui n√©cessite d√©j√† un grand nombre d'√©critures synchrones, vdev LOG peut indirectement acc√©l√©rer les √©critures asynchrones et les lectures non mises en cache. </font><font style="vertical-align: inherit;">Le t√©l√©chargement d'enregistrements ZIL vers un journal vdev s√©par√© signifie moins de concurrence pour les IOPS dans le stockage principal, ce qui am√©liore dans une certaine mesure les performances de toutes les op√©rations de lecture et d'√©criture.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instantan√©s</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le m√©canisme de copie en √©criture est √©galement une base essentielle pour les instantan√©s ZFS atomiques et la r√©plication asynchrone incr√©mentielle. </font><font style="vertical-align: inherit;">Le syst√®me de fichiers actif a une arborescence de pointeurs qui marque tous les enregistrements avec les donn√©es actuelles - lorsque vous prenez un instantan√©, vous faites simplement une copie de cette arborescence de pointeurs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsqu'un enregistrement est √©cras√© dans le syst√®me de fichiers actif, ZFS √©crit d'abord la nouvelle version du bloc dans l'espace inutilis√©. </font><font style="vertical-align: inherit;">Il d√©tache ensuite l'ancienne version du bloc du syst√®me de fichiers actuel. </font><font style="vertical-align: inherit;">Mais si un instantan√© fait r√©f√©rence √† l'ancien bloc, il reste inchang√©. </font><font style="vertical-align: inherit;">L'ancien bloc ne sera pas restaur√© en tant qu'espace libre jusqu'√† ce que tous les instantan√©s li√©s √† ce bloc soient d√©truits!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La r√©plication</font></font></h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/e69/167/01d/e6916701d4aa3ff27bb42efc43be60da.png"><br>
<i><font color="gray">  Steam  2015   158&nbsp;   126&nbsp;927 .        rsync&nbsp;‚Äî  ZFS    ¬´ ¬ª  750% .</font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/25f/376/0ab/25f3760ab64d6647571b9c02804b39f0.png"><br>
<i><font color="gray">      40-     Windows 7&nbsp;‚Äî   .  ZFS   289  ,  rsync&nbsp;‚Äî  ¬´¬ª  161  ,    ,   rsync   --inplace.</font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/776/46b/a3a/77646ba3ac20eeb0933d7dc7d644296c.png"><br>
<i><font color="gray">    ,  rsync    .  1,9         &nbsp;‚Äî    ,   ZFS   1148  ,  rsync,    rsync --inplace</font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fois que vous comprenez le fonctionnement des instantan√©s, il est facile de saisir l'essence de la r√©plication. Puisqu'un instantan√© n'est qu'un arbre de pointeurs vers des enregistrements, il s'ensuit que si nous faisons un </font></font><code>zfs send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instantan√©, nous envoyons cet arbre et tous les enregistrements qui lui sont associ√©s. Lorsque nous passons ce </font></font><code>zfs send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans </font></font><code>zfs receive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'objet cible, il √©crit deux le contenu r√©el du bloc et l'arbre des pointeurs qui font </font><font style="vertical-align: inherit;">r√©f√©rence √† des </font><font style="vertical-align: inherit;">blocs √† l'ensemble de donn√©es cible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout devient encore plus int√©ressant dans la seconde </font></font><code>zfs send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nous avons maintenant deux syst√®mes, chacun contenant </font></font><code>poolname/datasetname@1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et vous prenez un nouveau clich√© </font></font><code>poolname/datasetname@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Par cons√©quent, dans le pool source que vous avez </font></font><code>datasetname@1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>datasetname@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et dans le pool cible jusqu'√† pr√©sent, seul le premier instantan√© </font></font><code>datasetname@1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisque nous avons un instantan√© commun entre la source et la cible</font></font><code>datasetname@1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous pouvons faire </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incr√©mentiel</font></font></i> <code>zfs send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> par-dessus. Lorsque nous disons au syst√®me </font></font><code>zfs send -i poolname/datasetname@1 poolname/datasetname@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il compare deux arbres de pointeurs. Tous les pointeurs qui n'existent que dans </font></font><code>@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, √©videmment, se r√©f√®rent √† de nouveaux blocs - nous avons donc besoin du contenu de ces blocs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur un syst√®me distant, le traitement incr√©mentiel est </font></font><code>send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tout aussi simple. Tout d'abord, nous enregistrons toutes les nouvelles entr√©es incluses dans le flux </font></font><code>send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis ajoutons des pointeurs √† ces blocs. Voila, dans notre </font></font><code>@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nouveau syst√®me! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La r√©plication incr√©mentielle asynchrone ZFS est une √©norme am√©lioration par rapport aux m√©thodes non instantan√©es ant√©rieures comme rsync. Dans les deux cas, seules les donn√©es modifi√©es sont transmises - mais rsync doit d'abord </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lire</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">du disque toutes les donn√©es des deux c√¥t√©s pour v√©rifier le montant et le comparer. </font><font style="vertical-align: inherit;">En revanche, la r√©plication ZFS ne lit rien, sauf les arborescences de pointeurs - et les blocs qui ne sont pas repr√©sent√©s dans l'instantan√© g√©n√©ral.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compression en ligne</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le m√©canisme de copie sur √©criture simplifie √©galement le syst√®me de compression int√©gr√©. Dans un syst√®me de fichiers traditionnel, la compression est probl√©matique - l'ancienne version et la nouvelle version des donn√©es modifi√©es se trouvent dans le m√™me espace. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous consid√©rez un morceau de donn√©es au milieu d'un fichier qui commence sa vie comme un m√©gaoctet de z√©ros √† partir de 0x00000000 et ainsi de suite - il est tr√®s facile de le compresser en un secteur sur le disque. Mais que se passe-t-il si nous rempla√ßons ce m√©gaoctet de z√©ros par un m√©gaoctet de donn√©es incompressibles comme le JPEG ou le bruit pseudo-al√©atoire? Du coup, ce m√©gaoctet de donn√©es ne n√©cessitera pas un, mais 256 secteurs de 4 Ko, et √† cet endroit sur le disque un seul secteur est r√©serv√©.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFS n'a pas un tel probl√®me, car les enregistrements modifi√©s sont toujours √©crits dans l'espace inutilis√© - le bloc d'origine n'occupe qu'un seul secteur de 4 Ko, et un nouvel enregistrement prendra 256, mais ce n'est pas un probl√®me - un fragment r√©cemment modifi√© du ¬´milieu¬ª du fichier serait √©crit dans l'espace inutilis√© ind√©pendamment du fait que sa taille ait chang√© ou non, donc pour ZFS, c'est une situation normale. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La compression ZFS int√©gr√©e est d√©sactiv√©e par d√©faut, et le syst√®me propose des algorithmes de plug-in - maintenant parmi eux sont LZ4, gzip (1-9), LZJB et ZLE.</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LZ4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un algorithme de streaming qui offre une compression et une d√©compression extr√™mement rapides et des gains de performances pour la plupart des cas d'utilisation - m√™me sur des processeurs assez lents.</font></font><br>
</li>
<li><b>GZIP</b> ‚Äî  ,       Unix-.        1-9,       CPU      9.       (   )  ,    &nbsp;   c CPU&nbsp;‚Äî    ,     .<br>
</li>
<li><b>LZJB</b> ‚Äî    ZFS.       , LZ4     .<br>
</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZLE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - encodage de niveau z√©ro, encodage de niveau z√©ro. </font><font style="vertical-align: inherit;">Il ne touche pas du tout aux donn√©es normales, mais compresse de grandes s√©quences de z√©ros. </font><font style="vertical-align: inherit;">Utile pour les ensembles de donn√©es compl√®tement incompressibles (par exemple, JPEG, MP4 ou d'autres formats d√©j√† compress√©s), car il ignore les donn√©es incompressibles, mais compresse l'espace inutilis√© dans les enregistrements r√©sultants.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous recommandons la compression LZ4 pour presque tous les cas d'utilisation; </font><font style="vertical-align: inherit;">La p√©nalit√© de performances pour rencontrer des donn√©es incompressibles est tr√®s faible et le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gain de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> performances pour les donn√©es typiques est significatif. </font><font style="vertical-align: inherit;">Copier une image de machine virtuelle pour une nouvelle installation du syst√®me d'exploitation Windows (syst√®me d'exploitation fra√Æchement install√©, aucune donn√©e √† l'int√©rieur pour l'instant) avec </font></font><code>compression=lz4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pass√© 27% plus rapidement qu'avec </font></font><code>compression=none</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce test de 2015</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARC - cache de remplacement adaptatif</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFS est le seul syst√®me de fichiers moderne √† notre connaissance qui utilise son propre m√©canisme de mise en cache de lecture et ne s'appuie pas sur le cache de pages du syst√®me d'exploitation pour stocker des copies des blocs r√©cemment lus dans la RAM. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien que son propre cache ne soit pas sans probl√®mes - ZFS ne peut pas r√©pondre aux nouvelles demandes d'allocation de m√©moire aussi rapidement que le noyau, donc un nouvel appel d' </font></font><code>malloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allocation de m√©moire peut √©chouer s'il a besoin de RAM actuellement occup√©e par ARC. </font><font style="vertical-align: inherit;">Mais il y a de bonnes raisons d'utiliser votre propre cache, du moins pour l'instant.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tous les syst√®mes d'exploitation modernes bien connus, y compris MacOS, Windows, Linux et BSD, utilisent l'algorithme LRU (le moins r√©cemment utilis√©) pour impl√©menter le cache de pages. Il s'agit d'un algorithme primitif qui soul√®ve le bloc mis en cache ¬´en haut de la file d'attente¬ª apr√®s chaque lecture et pousse les blocs ¬´en file d'attente¬ª au besoin pour ajouter de nouveaux √©checs de cache (blocs qui auraient d√ª √™tre lus √† partir du disque, pas √† partir du cache). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Habituellement, l'algorithme fonctionne bien, mais sur les syst√®mes avec de grands ensembles de donn√©es de travail, LRU m√®ne facilement √† la destruction - √©vincant les blocs fr√©quemment n√©cessaires pour faire de la place pour les blocs qui ne seront plus jamais lus dans le cache. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;- un algorithme beaucoup moins na√Øf, qui peut √™tre consid√©r√© comme un cache "pond√©r√©". Apr√®s chaque lecture du bloc mis en cache, il devient un peu ¬´plus lourd¬ª et il devient plus difficile √† √©vincer - et m√™me apr√®s avoir √©vinc√© le bloc est </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suivi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pendant une certaine p√©riode de temps. Un bloc qui a √©t√© √©limin√© mais qui doit ensuite √™tre relu dans le cache deviendra √©galement ¬´plus lourd¬ª.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le r√©sultat final de tout cela est un cache avec un taux de r√©ussite beaucoup plus √©lev√© - le rapport entre les succ√®s dans le cache (lus dans le cache) et les rat√©s (lus sur le disque). </font><font style="vertical-align: inherit;">Il s'agit de statistiques extr√™mement importantes - non seulement le cache atteint lui-m√™me des ordres de grandeur de service plus rapides, mais les √©checs de cache peuvent √©galement √™tre trait√©s plus rapidement, car plus il y a d'occurrences de cache, moins il y a de demandes de disque simultan√©es et moins le d√©lai pour les autres manquants qui doivent √™tre trait√©s avec conduire.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s avoir √©tudi√© la s√©mantique de base de ZFS - comment fonctionne la copie pendant l'√©criture, ainsi que les relations entre les pools de stockage, les p√©riph√©riques virtuels, les blocs, les secteurs et les fichiers - nous sommes pr√™ts √† discuter des performances r√©elles avec des nombres r√©els. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la partie suivante, nous examinerons les performances r√©elles des pools avec vdev en miroir et RAIDz, en comparaison les uns avec les autres, ainsi qu'en comparaison avec les topologies RAID traditionnelles du noyau Linux, que nous avons examin√©es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pr√©c√©demment</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au d√©but, nous voulions consid√©rer uniquement les bases - les topologies ZFS elles-m√™mes - mais apr√®s </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cela,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous serons pr√™ts √† parler d'un r√©glage et d'un r√©glage ZFS plus avanc√©s, y compris l'utilisation de types de vdev auxiliaires tels que L2ARC, SLOG et allocation sp√©ciale.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr504680/index.html">Pr√©sentation de la biblioth√®que NLP de SpaL</a></li>
<li><a href="../fr504682/index.html">Nostalgia Post: j2me, Gravity Defied, 64kb</a></li>
<li><a href="../fr504686/index.html">Comment dessiner un chat</a></li>
<li><a href="../fr504688/index.html">Les masques sont inutiles: critique scientifique de la politique sociale √† KOVID-19</a></li>
<li><a href="../fr504690/index.html">L'histoire de la fa√ßon dont j'ai configur√© Azure AD B2C sur React et React Native, partie 3 (didacticiel)</a></li>
<li><a href="../fr504694/index.html">Comment compiler un d√©corateur - C ++, Python et sa propre impl√©mentation. Partie 1</a></li>
<li><a href="../fr504696/index.html">Nouvelles du monde d'OpenStreetMap n ¬∞ 513 (12.05.2020-18.05.2020)</a></li>
<li><a href="../fr504698/index.html">Int√©gration sur un site distant</a></li>
<li><a href="../fr504700/index.html">Tablette graphique sovi√©tique "sketch"</a></li>
<li><a href="../fr504702/index.html">Les gens ne veulent pas conna√Ætre l'anglais</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>