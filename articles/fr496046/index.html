<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👟 👵🏾 👨‍👧‍👦 Graphiques 3D sur le STM32F103 📥 👩🏽‍🤝‍👨🏾 👨🏽‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une courte histoire sur la façon de pousser le non modifiable et d'afficher des graphiques tridimensionnels en temps réel à l'aide d'un contrôleur qui...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Graphiques 3D sur le STM32F103</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496046/"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/cf8/e1c/7e5cf8e1c0fbc2ee47c87c71d72e865f.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une courte histoire sur la façon de pousser le non modifiable et d'afficher des graphiques tridimensionnels en temps réel à l'aide d'un contrôleur qui n'a ni vitesse ni mémoire pour cela.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En 2017 (à en juger par la date de modification du fichier), j'ai décidé de passer des contrôleurs AVR à des STM32 plus puissants. Naturellement, le premier contrôleur était le F103, largement diffusé. Il n'est pas moins naturel que l'utilisation de cartes de débogage standard ait été rejetée au profit de la fabrication à partir de zéro selon ses besoins. Curieusement, il n'y avait presque pas de jambages (sauf que l'UART1 devrait être amené à un connecteur normal et non béquillé par le câblage).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par rapport à l'AVR, les caractéristiques de la pierre sont assez décentes: horloge à 72 MHz (en pratique, vous pouvez overclocker à 100 MHz, voire plus, mais uniquement à vos risques et périls!), 20 Ko de RAM et 64 Ko de flash. De plus, une tonne de périphériques, lors de l'utilisation dont le principal problème est de ne pas avoir peur de cette abondance et de réaliser que vous n'avez pas besoin de pelleter les dix registres pour commencer, il suffit de définir trois bits dans les bons. Au moins jusqu'à ce que vous vouliez quelque chose d'étrange.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque la première euphorie de la possession d'un tel pouvoir est passée, un désir a surgi de sonder ses limites. Comme exemple efficace, j'ai choisi le calcul de graphiques en trois dimensions avec toutes ces matrices, l'éclairage, les modèles polygonaux et un Z-buffer avec un affichage 320x240 sur le contrôleur ili9341. Les deux problèmes les plus évidents à résoudre sont la vitesse et le volume. Une taille d'écran de 320x240 à 16 bits par couleur donne 150 Ko par image. Mais la RAM totale que nous avons n'est que de 20 Ko ... Et ces 150 Ko doivent être transférés à l'écran au moins 10 fois par seconde, c'est-à-dire que le taux de change devrait être d'au moins 1,5 Mo / s ou 12 Mo / s, ce qui ressemble déjà à une charge importante sur le cœur. Heureusement, dans ce contrôleur, il existe un module RAP (accès direct à la mémoire, alias Direct Memory Access, DMA), qui vous permet de ne pas charger le noyau avec des opérations de transfusion de vide en vide.Autrement dit, vous pouvez préparer le tampon, dire au module «ici vous avez le tampon de données, travaillez!», Et à ce moment préparer les données pour le prochain transfert. Et en tenant compte de la capacité de l'écran à recevoir des données dans un flux, l'algorithme suivant émerge: le tampon avant est mis en évidence, à partir duquel le DMA transfère les données à l'écran, le tampon arrière dans lequel le rendu a lieu et le tampon Z utilisé pour la découpe en profondeur. Les tampons sont une seule ligne (ou colonne, peu importe) de l'affichage. Et au lieu de 150 Ko, nous n'avons besoin que de 1920 octets (320 pixels par ligne * 3 tampons * 2 octets par point), ce qui tient parfaitement en mémoire. Le deuxième hack est basé sur le fait que le calcul des matrices de transformation et des coordonnées des sommets ne peut pas être effectué pour chaque ligne, sinon l'image sera déformée de la manière la plus bizarre et sa vitesse est désavantageuse. Au lieu de cela, des calculs "externes",c'est-à-dire que la multiplication des matrices de transformation et leur application aux sommets sont recalculées sur chaque image, puis converties en une représentation intermédiaire, qui est optimisée pour le rendu en une image 320x1.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour des raisons de hooligan, la bibliothèque ressemblera à OpenGL de l'extérieur. Comme dans l'OpenGL d'origine, le rendu commence par la formation de la matrice de transformation - la suppression de glLoadIdentity () crée l'unité de matrice actuelle, puis un ensemble de transformations glRotateXY (...), glTranslate (...), chacune étant multipliée par la matrice actuelle. Étant donné que ces calculs ne seront effectués qu'une fois par image, il n'y a pas d'exigences particulières de vitesse, vous pouvez le faire avec des flotteurs simples, sans perversions avec des nombres à virgule fixe. La matrice elle-même est un tableau de float [4] [4], mappé sur un tableau unidimensionnel de float [16] - en fait, cette méthode est généralement utilisée pour les tableaux dynamiques, mais vous pouvez tirer un petit avantage des statiques. Un autre hack standard: au lieu de calculer constamment les sinus et les cosinus, qui sont nombreux dans les matrices de rotation,comptez-les à l'avance et écrivez-les sur la tablette. Pour ce faire, divisez le cercle complet en 256 parties, calculez la valeur du sinus pour chacune et transférez-la dans le tableau sin_table []. Eh bien, n'importe qui de l'école peut obtenir le cosinus du sinus. Il convient de noter que les fonctions de rotation prennent un angle non pas en radians, mais en fractions de tour complet, après réduction à la plage [0 ... 255]. Cependant, des fonctions «honnêtes» ont été mises en œuvre pour effectuer la conversion de l'angle en lobes sous le capot.effectuer la conversion de l'angle en lobes sous le capot.effectuer la conversion de l'angle en lobes sous le capot.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque la matrice est prête, vous pouvez commencer à dessiner les primitives. En général, dans les graphiques en trois dimensions, il existe trois types de primitives - un point, une ligne et un triangle. Mais si nous nous intéressons aux modèles polygonaux, il ne faut s'intéresser qu'au triangle. Son "rendu" se produit dans la fonction glDrawTriangle () ou glDrawTriangleV (). Le mot «rendu» est placé entre guillemets car aucun rendu ne se produit à ce stade. Nous multiplions simplement tous les points de la primitive par la matrice de transformation, puis nous en extrayons les formules analytiques des arêtes y = ky * x + par, ce qui nous permet de trouver les intersections des trois arêtes du triangle avec la ligne de sortie actuelle. Nous en écartons un, car il ne repose pas sur l'intervalle entre les sommets, mais sur sa continuation.Autrement dit, pour dessiner un cadre, il vous suffit de parcourir toutes les lignes et pour chaque peinture la zone entre les points d'intersection. Mais si vous appliquez cet algorithme de front, chaque primitive chevauchera celles qui ont été dessinées précédemment. Nous devons considérer la coordonnée Z (profondeur) afin que les triangles se croisent magnifiquement. Au lieu d'imprimer simplement point par point, nous considérerons sa coordonnée Z et, en comparaison avec la coordonnée Z stockée dans le tampon de profondeur, soit en sortie (en mettant à jour le tampon Z) soit en l'ignorant. Et pour calculer la coordonnée Z de chaque point de la ligne qui nous intéresse, nous utilisons la même formule de ligne droite z = kz * y + bz calculée par les deux mêmes points d'intersection avec des bords. Par conséquent, l'objet du triangle "semi-fini" struct glTriangle se compose de trois coordonnées X des sommets (il n'y a aucun sens à stocker les coordonnées Y et Z, elles seront calculées) et k,b coefficients directs, eh bien, couleur au tas. Ici, contrairement au calcul des matrices de transformation, la vitesse est critique, nous utilisons donc déjà des nombres à virgule fixe. De plus, si pour le terme b, la même précision est suffisante que pour les coordonnées (2 octets), alors la précision du facteur k, plus grande est la meilleure, on prend donc 4 octets. Mais pas un flottant, car travailler avec des entiers est encore plus rapide, même avec la même taille.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, en appelant un groupe de glDrawTriangle (), nous avons préparé un tableau de triangles semi-finis. Dans mon implémentation, les triangles sont déduits un à la fois par des appels de fonction explicites. En fait, il serait logique d'avoir un tableau de triangles avec les adresses des sommets, mais ici j'ai décidé de ne pas compliquer. Quoi qu'il en soit, la fonction de rendu est écrite par des robots et peu leur importe de remplir un tableau constant ou d'écrire trois cents appels identiques. Il est temps de traduire les produits semi-finis des triangles en une belle image à l'écran. Pour ce faire, la fonction glSwapBuffers () est appelée. Comme décrit ci-dessus, il parcourt les lignes de l'affichage, recherche chaque point d'intersection avec tous les triangles et dessine des segments en fonction du filtrage par profondeur. Après avoir rendu chaque ligne, vous devez envoyer cette ligne à l'écran. Pour ce faire, DMA est lancé, ce qui indique l'adresse de la chaîne et sa taille.En attendant, DMA fonctionne, vous pouvez basculer vers un autre tampon et afficher la ligne suivante. L'essentiel est de ne pas oublier d'attendre la fin du transfert si vous avez soudainement terminé le rendu plus tôt. Pour visualiser le rapport des vitesses, j'ai ajouté l'inclusion d'une LED rouge après la fin du rendu et éteinte après la fin de l'attente DMA. Il s'avère quelque chose comme PWM, qui ajuste la luminosité en fonction de la latence. Théoriquement, au lieu d'une attente «stupide», des interruptions DMA pourraient être utilisées, mais je ne pourrais pas les utiliser, et l'algorithme serait devenu beaucoup plus compliqué. Pour un programme de démonstration, c'est redondant.Pour visualiser le rapport des vitesses, j'ai ajouté l'inclusion d'une LED rouge après la fin du rendu et éteinte après la fin de l'attente DMA. Il s'avère quelque chose comme PWM, qui ajuste la luminosité en fonction de la latence. Théoriquement, au lieu d'une attente «stupide», des interruptions DMA pourraient être utilisées, mais je ne pourrais pas les utiliser, et l'algorithme serait devenu beaucoup plus compliqué. Pour un programme de démonstration, c'est redondant.Pour visualiser le rapport des vitesses, j'ai ajouté l'inclusion d'une LED rouge après la fin du rendu et éteinte après la fin de l'attente DMA. Il s'avère quelque chose comme PWM, qui ajuste la luminosité en fonction de la latence. Théoriquement, au lieu d'une attente «stupide», des interruptions DMA pourraient être utilisées, mais je ne pourrais pas les utiliser, et l'algorithme serait devenu beaucoup plus compliqué. Pour un programme de démonstration, c'est redondant.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le résultat des procédures ci-dessus a été une image tournante de trois plans qui se croisent de couleurs différentes, et avec une vitesse assez décente: la luminosité de la LED rouge est assez élevée, ce qui indique une grande marge dans les performances du noyau.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, si le noyau est inactif, vous devez le charger. Et nous le chargerons avec de meilleurs modèles. Cependant, n'oubliez pas que la mémoire est encore très limitée, donc le contrôleur ne tirera pas trop de polygones physiquement. Le calcul le plus simple a montré qu'après soustraction de la mémoire sur le tampon de ligne et autres, il y avait une place pour 378 triangles. Comme la pratique l'a montré, les modèles de l'ancien mais intéressant jeu gothique sont parfaits pour cette taille. En fait, les modèles d'un serpent et d'une mouche de sang ont été retirés de là (et déjà au moment de la rédaction de cet article et d'un glocoor, affichant sur KDPV), après quoi le contrôleur a manqué de mémoire flash. Mais les modèles de jeux ne sont pas destinés à être utilisés par un microcontrôleur.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Disons qu'ils contiennent des animations, des textures et similaires, ce qui ne nous est pas utile et ne tient pas en mémoire. Heureusement, Blender permet non seulement de les enregistrer dans * .obj, ce qui est plus adapté à l'analyse, mais également de réduire le nombre de polygones si nécessaire. De plus, à l'aide d'un simple programme auto-écrit obj2arr * .obj, les fichiers sont triés en coordonnées, à partir desquelles un fichier * .h est ensuite formé pour une inclusion directe dans le firmware.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais pour l'instant, les modèles ressemblent à de simples taches bouclées. Sur le modèle de test, cela ne nous a pas dérangés, car tous les visages ont été peints dans leurs propres couleurs, mais ne prescrivent pas les mêmes couleurs à chaque polygone du modèle. Non, vous pouvez, bien sûr, peindre une mouche dans des couleurs aléatoires, mais elle aura l'air assez à l'improviste, j'ai vérifié. Surtout lorsque les couleurs changent également sur chaque image ... Au lieu de cela, appliquez une autre goutte de magie vectorielle et ajoutez de l'éclairage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le calcul de l'éclairage dans sa version primitive consiste à calculer le produit scalaire de la normale et de la direction de la source lumineuse, puis à multiplier par la couleur «native» du visage.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons maintenant trois modèles - deux du jeu et un test, à partir duquel nous avons commencé. Pour les commuter, nous utiliserons l'un des deux boutons soudés sur la carte. En même temps, vous pouvez ajouter un contrôle sur le processeur. Nous avons déjà un contrôle - une LED rouge associée à la latence DMA. Et la deuxième, verte, LED, nous clignotera à chaque mise à jour de trame - afin que nous puissions estimer la fréquence d'images. Pour l'œil nu, c'était environ 15 fps.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/afyTgpuA6sc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, je suis satisfait du résultat: c'est bien d'implémenter quelque chose qui est fondamentalement impossible à résoudre de front. </font><font style="vertical-align: inherit;">Bien sûr, il reste encore beaucoup à optimiser et à améliorer, mais cela ne sert à rien. </font><font style="vertical-align: inherit;">Objectivement, le contrôleur pour les graphiques en trois dimensions est faible, et ce n'est même pas la vitesse, mais plutôt la RAM. </font><font style="vertical-align: inherit;">Cependant, comme tout échantillon de demoscene, ce projet est précieux non pas par le résultat, mais par le processus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si quelqu'un est soudain intéressé, le code source est disponible </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr496036/index.html">Open source: infrastructure de test CI / CD et Avito pour Android</a></li>
<li><a href="../fr496038/index.html">Bilirubine - la molécule responsable de l'ictère</a></li>
<li><a href="../fr496040/index.html">10 Lifehacks zen</a></li>
<li><a href="../fr496042/index.html">Habr, je ne vous informerai pas des erreurs sur votre site</a></li>
<li><a href="../fr496044/index.html">Lancement de vaisseaux spatiaux et ... météo dans les régions</a></li>
<li><a href="../fr496050/index.html">Des tigres et des lions contractent un coronavirus à New York</a></li>
<li><a href="../fr496052/index.html">Comment une entreprise de services peut-elle éviter des amendes à un client? Quelques avantages évidents de l'automatisation des processus</a></li>
<li><a href="../fr496056/index.html">Numérique: comment les chiffres et les termes nous trompent</a></li>
<li><a href="../fr496058/index.html">Pourquoi est-il nécessaire de combiner des robots agricoles, quelles sont les difficultés et comment nous l'avons fait en deux ans</a></li>
<li><a href="../fr496080/index.html">Création d'interactions IA simples avec des objets d'environnement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>