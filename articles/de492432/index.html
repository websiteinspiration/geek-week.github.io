<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🌾 🤹🏼 👩🏽‍🎤 FastText: Code-Rezept 🙊 🤶🏽 ✖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag, Freunde! Ich präsentiere Ihnen eine Amateurübersetzung des Originalartikels: FastText: Schritt durch den Code von Maria Mestre. 
 
 Eine kl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>FastText: Code-Rezept</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492432/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guten Tag, Freunde! Ich präsentiere Ihnen eine Amateurübersetzung des Originalartikels: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FastText: Schritt durch den Code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von Maria Mestre. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine kleine Warnung: Einige der bereitgestellten Informationen sind aufgrund des Zeitablaufs und zufälliger Fehler des Autors möglicherweise nicht vollständig wahr. In jedem Fall ist jedes Feedback wünschenswert!</font></font></i><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Möglicherweise sind Sie auf ein Tool wie FastText gestoßen, mit dem Sie Ihren Textkörper vektorisieren können. Wussten Sie jedoch, dass FastText auch mit deren Klassifizierung umgehen kann? Oder vielleicht wussten sie es, aber wusste er, wie er es macht? Schauen wir es uns von innen an ... ich meine, durch den Bildschirm.</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die FastText-Bibliothek wurde hauptsächlich vom Facebook-Team zur Klassifizierung von Texten entwickelt, kann aber auch zum Trainieren von Worteinbettungen verwendet werden. Seit FastText ein Produkt ist, das für jedermann zugänglich ist (2016), ist es aufgrund seiner guten Trainingsgeschwindigkeit und hervorragenden Leistung weit verbreitet.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als ich die offizielle Dokumentation las (sehr wenig zu erklären), stellte ich fest, dass sie einen ziemlich großen Teil der Algorithmen enthält, die möglicherweise nicht vollständig transparent sind. Daher wurde beschlossen, unabhängig herauszufinden, wie alles funktioniert und womit es isst. Ich begann mit dem Lesen des Hauptartikels der Autoren und einem kurzen Blick auf den Stanford Deep Learning-Kurs in NLP. Während all dieser Freude habe ich nur die Fragen erhöht. Zum Beispiel: dass sie im Verlauf von Stanfords Vorlesungen und in einem Teil des Artikels über die Verwendung von N-Gramm sprechen, aber keine Merkmale in ihrer Anwendung angeben. Zu den in der Befehlszeile angegebenen Parametern gehört auch ein bestimmter Bucket, dessen einzige Kommentare wie "die Anzahl der Container (Buckets)" klingen. Wie werden diese N-Gramm berechnet? Eimer? Es ist nicht klar ... Eine Option bleibt, sehen Sie sich den Code an</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem ich all das Gute gesehen hatte, wurde Folgendes herausgefunden</font></font></h4><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FastText verwendet sicher N-Gramm Zeichen mit dem gleichen Erfolg wie N-Gramm Wörter.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FastText unterstützt die Klassifizierung mehrerer Klassen, was beim ersten Mal möglicherweise nicht so offensichtlich ist.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anzahl der Modellparameter</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modell Einführung</font></font></h4><br>
<img src="https://habrastorage.org/getpro/habr/post_images/1f2/9c1/c4a/1f29c1c4a8cf961b0b1a87bfeb64817f.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Laut einem Artikel von Entwicklern ist das Modell ein einfaches neuronales Netzwerk mit einer verborgenen Schicht. Der durch die Worttasche (BOW) dargestellte Text wird durch die erste Ebene geleitet, in der er in Worteinbettungen umgewandelt wird. Anschließend werden die resultierenden Einbettungen über den gesamten Text gemittelt und auf die einzige reduziert, die im gesamten Text anwendbar ist. In der verborgenen Ebene arbeiten wir mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n_words * dim anhand der</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anzahl der Parameter, wobei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dim</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Größe der Einbettung und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n_words die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Größe des für Text verwendeten Wörterbuchs ist. Nach der Mittelwertbildung erhalten wir einen einzelnen Vektor, der einen recht beliebten Klassifikator durchläuft: Die </font><i><font style="vertical-align: inherit;">Softmax-</font></i><font style="vertical-align: inherit;"> Funktion wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zur linearen Abbildung (Konvertierung) der Eingabedaten der ersten bis zur letzten Schicht. </font><font style="vertical-align: inherit;">Eine Matrix der Dimension </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dim * n_output</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fungiert als lineare Transformation </font><font style="vertical-align: inherit;">, wobei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n_output</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unsere Anzahl realer Klassen ist. </font><font style="vertical-align: inherit;">Im Originalartikel wird die endgültige Wahrscheinlichkeit als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">logarithmische</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wahrscheinlichkeit betrachtet </font><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bda/562/e9f/bda562e9f48277570c5ee94c33cbf6c8.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
wobei:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x_n ist die Darstellung eines Wortes in n-Gramm. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und dies ist eine Look_up-Matrix, die die Einbettung eines Wortes extrahiert.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist eine lineare Transformation der Ausgabe.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f direkt die Softmax-Funktion selbst.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles im Allgemeinen ist nicht so schlecht, aber schauen wir uns trotzdem den Code an:</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code als Ideenübersetzung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Datei mit den Quelldaten, die wir für unseren Klassifikator anwenden können, muss eine bestimmte Form haben: __label__0 (Text). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Beispiele: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
__label__cat In diesem Text geht es um Katzen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
__label__dog In diesem Text geht es um Hunde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Quelldatei wird als Argument für die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zugfunktion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zug</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Funktion </font><font style="vertical-align: inherit;">beginnt mit der Initialisierung und anschließenden Füllen der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dict_</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> variable </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FastText::train</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Args args)</span> </span>{<font></font>
  args_ = <span class="hljs-built_in">std</span>::make_shared&lt;Args&gt;(args);<font></font>
  dict_ = <span class="hljs-built_in">std</span>::make_shared&lt;Dictionary&gt;(args_);
  <span class="hljs-keyword">if</span> (args_-&gt;input == <span class="hljs-string">"-"</span>) {
    <span class="hljs-comment">// manage expectations</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::invalid_argument(<span class="hljs-string">"Cannot use stdin for training!"</span>);<font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-built_in">std</span>::ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(args_-&gt;input)</span></span>;
  <span class="hljs-keyword">if</span> (!ifs.is_open()) {
    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::invalid_argument(<font></font>
        args_-&gt;input + <span class="hljs-string">" cannot be opened for training!"</span>);<font></font>
  }<font></font>
  dict_-&gt;readFromFile(ifs);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dict_ ist eine Instanz der Dictionary-Klasse.</font></font><br>
<br>
<pre><code class="cpp hljs">
Dictionary::Dictionary(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Args&gt; args) : args_(args),<font></font>
  word2int_(MAX_VOCAB_SIZE, <span class="hljs-number">-1</span>), size_(<span class="hljs-number">0</span>), nwords_(<span class="hljs-number">0</span>), nlabels_(<span class="hljs-number">0</span>),<font></font>
  ntokens_(<span class="hljs-number">0</span>), pruneidx_size_(<span class="hljs-number">-1</span>) {}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir die Sätze der Quelldatei gelesen und analysiert haben, füllen wir zwei Vektoren:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> words_ enthält eindeutige Wörter, die aus Text extrahiert wurden</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">word2int_ enthält Hashes für jedes Wort entsprechend seiner Position im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wortvektor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies ist tatsächlich sehr wichtig, da es bestimmt, welche zur Suche nach Einbettungen der Matrix A verwendet werden</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wortvektor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enthält Eintrittsinstanzen. </font><font style="vertical-align: inherit;">Jedes davon kann ein Worttyp für </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Label sein</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und einen Zähler für Anrufe haben. </font><font style="vertical-align: inherit;">Es gibt auch ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterwortfeld</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aber wir werden es uns etwas genauer ansehen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">entry</span> {</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> word;
  <span class="hljs-keyword">int64_t</span> count;<font></font>
  entry_type type;<font></font>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int32_t</span>&gt; subwords;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch Hinzufügen von Wörtern oder Tags zur </font><font style="vertical-align: inherit;">Variablen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">word2int_</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden Kollisionen notwendigerweise so aufgelöst, dass wir niemals auf zwei verschiedene Wörter mit demselben Index verweisen. </font><font style="vertical-align: inherit;">Es wird einfach keine geben.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int32_t</span> <span class="hljs-title">Dictionary::find</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; w, <span class="hljs-keyword">uint32_t</span> h)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">int32_t</span> word2intsize = word2int_.size();
  <span class="hljs-keyword">int32_t</span> id = h % word2intsize;
  <span class="hljs-keyword">while</span> (word2int_[id] != <span class="hljs-number">-1</span> &amp;&amp; words_[word2int_[id]].word != w) {<font></font>
    id = (id + <span class="hljs-number">1</span>) % word2intsize;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> id;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int32_t</span> <span class="hljs-title">Dictionary::find</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; w)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">return</span> find(w, hash(w));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dictionary::add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; w)</span> </span>{
  <span class="hljs-keyword">int32_t</span> h = find(w);<font></font>
  ntokens_++;<font></font>
  <span class="hljs-keyword">if</span> (word2int_[h] == <span class="hljs-number">-1</span>) {<font></font>
    entry e;<font></font>
    e.word = w;<font></font>
    e.count = <span class="hljs-number">1</span>;<font></font>
    e.type = getType(w);<font></font>
    words_.push_back(e);<font></font>
    word2int_[h] = size_++;<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    words_[word2int_[h]].count++;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beide Vektoren werden gefiltert, um sicherzustellen, dass Wörter und Tags, die mindestens einmal erwähnt werden, enthalten sind. Nachdem wir zu dem Teil </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">übergegangen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind, </font><font style="vertical-align: inherit;">in </font><font style="vertical-align: inherit;">dem wir die Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">readFromFile</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwenden, in der </font><i><font style="vertical-align: inherit;">initNgrams </font></i><i><font style="vertical-align: inherit;">aufgerufen</font></i><font style="vertical-align: inherit;"> wird </font><font style="vertical-align: inherit;">. Wir sind fast zum Mystiker gekommen, N-Gramm zu verwenden.</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dictionary::readFromFile</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::istream&amp; in)</span> </span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> word;
  <span class="hljs-keyword">int64_t</span> minThreshold = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">while</span> (readWord(in, word)) {<font></font>
    add(word);<font></font>
    <span class="hljs-keyword">if</span> (ntokens_ % <span class="hljs-number">1000000</span> == <span class="hljs-number">0</span> &amp;&amp; args_-&gt;verbose &gt; <span class="hljs-number">1</span>) {
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"\rRead "</span> &lt;&lt; ntokens_  / <span class="hljs-number">1000000</span> &lt;&lt; <span class="hljs-string">"M words"</span> &lt;&lt; <span class="hljs-built_in">std</span>::flush;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (size_ &gt; <span class="hljs-number">0.75</span> * MAX_VOCAB_SIZE) {<font></font>
      minThreshold++;<font></font>
      threshold(minThreshold, minThreshold);<font></font>
    }<font></font>
  }<font></font>
  threshold(args_-&gt;minCount, args_-&gt;minCountLabel);<font></font>
  initTableDiscard();<font></font>
  initNgrams();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initNgrams</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definiert alle Kombinationen von N-Gramm-Zeichen und fügt sie dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngram-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vektor hinzu </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Am Ende werden alle Hashes für N-Gramm berechnet und im n-Gramm-Vektor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">addiert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wodurch die Größe des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eimers gebildet wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mit anderen Worten, Hashes von N-Gramm-Zeichen werden hinzugefügt, nachdem Hashes von N-Gramm-Wörtern hinzugefügt wurden. </font><font style="vertical-align: inherit;">Infolgedessen überlappen sich ihre Indizes nicht mit den Indizes von Wörtern, sondern können sich überlappen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen können Sie für jedes Wort im Text </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterwörter angeben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... N-Gramm Zeichen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Einbetten der Matrix A zeigt Folgendes an:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die anfänglichen nwords_-Zeilen enthalten Einbettungen für jedes Wort aus dem Wörterbuch, das für den Text verfügbar ist.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folgen Sie dem Zeilenumfang mit Einbettungen für jedes N-Gramm Zeichen</font></font></li>
</ul> <br>
<pre><code class="cpp hljs">
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dictionary::initNgrams</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size_; i++) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> word = BOW + words_[i].word + EOW;<font></font>
    words_[i].subwords.clear();<font></font>
    words_[i].subwords.push_back(i);<font></font>
    <span class="hljs-keyword">if</span> (words_[i].word != EOS) {<font></font>
      computeSubwords(word, words_[i].subwords);<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dictionary::computeSubwords</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; word,
                               <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int32_t</span>&gt;&amp; ngrams)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; word.size(); i++) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ngram;
    <span class="hljs-keyword">if</span> ((word[i] &amp; <span class="hljs-number">0xC0</span>) == <span class="hljs-number">0x80</span>) <span class="hljs-keyword">continue</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> j = i, n = <span class="hljs-number">1</span>; j &lt; word.size() &amp;&amp; n &lt;= args_-&gt;maxn; n++) {<font></font>
      ngram.push_back(word[j++]);<font></font>
      <span class="hljs-keyword">while</span> (j &lt; word.size() &amp;&amp; (word[j] &amp; <span class="hljs-number">0xC0</span>) == <span class="hljs-number">0x80</span>) {<font></font>
        ngram.push_back(word[j++]);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span> (n &gt;= args_-&gt;minn &amp;&amp; !(n == <span class="hljs-number">1</span> &amp;&amp; (i == <span class="hljs-number">0</span> || j == word.size()))) {
        <span class="hljs-keyword">int32_t</span> h = hash(ngram) % args_-&gt;bucket;<font></font>
        pushHash(ngrams, h);<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dictionary::pushHash</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int32_t</span>&gt;&amp; hashes, <span class="hljs-keyword">int32_t</span> id)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">if</span> (pruneidx_size_ == <span class="hljs-number">0</span> || id &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">if</span> (pruneidx_size_ &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span> (pruneidx_.count(id)) {<font></font>
      id = pruneidx_.at(id);<font></font>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span>;<font></font>
    }<font></font>
  }<font></font>
  hashes.push_back(nwords_ + id);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also haben wir die mystischen N-Gramm-Zeichen erraten. Lassen Sie uns nun mit N-Gramm Wörtern umgehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zurück zur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zugfunktion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden </font><font style="vertical-align: inherit;">folgende Anweisungen ausgeführt:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">if</span> (args_-&gt;pretrainedVectors.size() != <span class="hljs-number">0</span>) {<font></font>
    loadVectors(args_-&gt;pretrainedVectors);<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    input_ = <span class="hljs-built_in">std</span>::make_shared&lt;Matrix&gt;(dict_-&gt;nwords()+args_-&gt;bucket, args_-&gt;dim);<font></font>
    input_-&gt;uniform(<span class="hljs-number">1.0</span> / args_-&gt;dim);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (args_-&gt;model == model_name::sup) {<font></font>
    output_ = <span class="hljs-built_in">std</span>::make_shared&lt;Matrix&gt;(dict_-&gt;nlabels(), args_-&gt;dim);<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    output_ = <span class="hljs-built_in">std</span>::make_shared&lt;Matrix&gt;(dict_-&gt;nwords(), args_-&gt;dim);<font></font>
  }<font></font>
  output_-&gt;zero();<font></font>
  startThreads();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier wird die Einbettungsmatrix A initialisiert. Es muss darauf hingewiesen werden, dass </font><font style="vertical-align: inherit;">diese Variable als voll betrachtet </font><font style="vertical-align: inherit;">wird, wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pretrainedVectors</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit dieser Funktion arbeiten. Geschieht dies nicht, wird die Matrix mit den Zufallszahlen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-1 / dim</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 / dim</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> initialisiert </font><font style="vertical-align: inherit;">, wobei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dim</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Größe unserer Einbettung ist. Dimension der Matrix A ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n_words_</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bucket</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dim</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), d.h. Wir werden alle diese Einbettungen für jedes Wort einrichten. In diesem Schritt wird auch die Ausgabe initialisiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Ergebnis erhalten wir den Teil, in dem wir mit dem Training unseres Modells beginnen.</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FastText::trainThread</span><span class="hljs-params">(<span class="hljs-keyword">int32_t</span> threadId)</span> </span>{
  <span class="hljs-function"><span class="hljs-built_in">std</span>::ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(args_-&gt;input)</span></span>;<font></font>
  utils::seek(ifs, threadId * utils::size(ifs) / args_-&gt;thread);<font></font>
<font></font>
  <span class="hljs-function">Model <span class="hljs-title">model</span><span class="hljs-params">(input_, output_, args_, threadId)</span></span>;
  <span class="hljs-keyword">if</span> (args_-&gt;model == model_name::sup) {<font></font>
    model.setTargetCounts(dict_-&gt;getCounts(entry_type::label));<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    model.setTargetCounts(dict_-&gt;getCounts(entry_type::word));<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> ntokens = dict_-&gt;ntokens();
  <span class="hljs-keyword">int64_t</span> localTokenCount = <span class="hljs-number">0</span>;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int32_t</span>&gt; line, labels;
  <span class="hljs-keyword">while</span> (tokenCount_ &lt; args_-&gt;epoch * ntokens) {<font></font>
    real progress = real(tokenCount_) / (args_-&gt;epoch * ntokens);<font></font>
    real lr = args_-&gt;lr * (<span class="hljs-number">1.0</span> - progress);
    <span class="hljs-keyword">if</span> (args_-&gt;model == model_name::sup) {<font></font>
      localTokenCount += dict_-&gt;getLine(ifs, line, labels);<font></font>
      supervised(model, lr, line, labels);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args_-&gt;model == model_name::cbow) {<font></font>
      localTokenCount += dict_-&gt;getLine(ifs, line, model.rng);<font></font>
      cbow(model, lr, line);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args_-&gt;model == model_name::sg) {<font></font>
      localTokenCount += dict_-&gt;getLine(ifs, line, model.rng);<font></font>
      skipgram(model, lr, line);<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (localTokenCount &gt; args_-&gt;lrUpdateRate) {<font></font>
      tokenCount_ += localTokenCount;<font></font>
      localTokenCount = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (threadId == <span class="hljs-number">0</span> &amp;&amp; args_-&gt;verbose &gt; <span class="hljs-number">1</span>)<font></font>
        loss_ = model.getLoss();<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span> (threadId == <span class="hljs-number">0</span>)<font></font>
    loss_ = model.getLoss();<font></font>
  ifs.close();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Teil des Codes gibt es zwei Hauptpunkte. </font><font style="vertical-align: inherit;">Zunächst wird die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getLine</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">ruft die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dict_</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variable </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zweitens wird die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">überwachte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion aufgerufen </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int32_t</span> <span class="hljs-title">Dictionary::getLine</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::istream&amp; in,
                            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int32_t</span>&gt;&amp; words,
                            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int32_t</span>&gt;&amp; labels)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int32_t</span>&gt; word_hashes;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> token;
  <span class="hljs-keyword">int32_t</span> ntokens = <span class="hljs-number">0</span>;<font></font>
<font></font>
  reset(in);<font></font>
  words.clear();<font></font>
  labels.clear();<font></font>
  <span class="hljs-keyword">while</span> (readWord(in, token)) {
    <span class="hljs-keyword">uint32_t</span> h = hash(token);
    <span class="hljs-keyword">int32_t</span> wid = getId(token, h);<font></font>
    entry_type type = wid &lt; <span class="hljs-number">0</span> ? getType(token) : getType(wid);<font></font>
<font></font>
    ntokens++;<font></font>
    <span class="hljs-keyword">if</span> (type == entry_type::word) {<font></font>
      addSubwords(words, token, wid);<font></font>
      word_hashes.push_back(h);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == entry_type::label &amp;&amp; wid &gt;= <span class="hljs-number">0</span>) {<font></font>
      labels.push_back(wid - nwords_);<font></font>
    }&lt;source lang=<span class="hljs-string">"cpp"</span>&gt;
    <span class="hljs-keyword">if</span> (token == EOS) <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
  addWordNgrams(words, word_hashes, args_-&gt;wordNgrams);<font></font>
  <span class="hljs-keyword">return</span> ntokens;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der obigen Funktion lesen wir die Texte aus den Eingabedaten und bestimmen die Indizes für jedes Wort nacheinander mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">word2int_</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wir fügen Sie </font><font style="vertical-align: inherit;">das N-Gramm , </font><font style="vertical-align: inherit;">die diese Worte zu dem bilden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Worten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variable </font><font style="vertical-align: inherit;">, wie in dem Code angegeben. </font><font style="vertical-align: inherit;">Und am Ende fügen wir Beschriftungen direkt zum </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschriftungsvektor hinzu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir den Text (Sätze aus dem Korpus) vollständig gelesen und direkt zu den für sie erstellten Vektoren hinzugefügt haben, erhalten wir einen Teil des Codes, der N-Gramm verarbeitet. </font><font style="vertical-align: inherit;">Dies ist die Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">addWordNgrams</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dictionary::addWordNgrams</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int32_t</span>&gt;&amp; line,
                               <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int32_t</span>&gt;&amp; hashes,
                               <span class="hljs-keyword">int32_t</span> n)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; hashes.size(); i++) {
    <span class="hljs-keyword">uint64_t</span> h = hashes[i];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int32_t</span> j = i + <span class="hljs-number">1</span>; j &lt; hashes.size() &amp;&amp; j &lt; i + n; j++) {<font></font>
      h = h * <span class="hljs-number">116049371</span> + hashes[j];<font></font>
      pushHash(line, h % args_-&gt;bucket);<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir schauen weiter. Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hashes-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variable </font><font style="vertical-align: inherit;">ist eine Reihe von Hashes für jedes Wort im Text, wobei die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeile</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Anzahl der Wörter im Satz und die Anzahl der verwendeten N-Gramm enthält. Der Parameter </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der Parameter </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wordNgrams</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und gibt die maximale Länge der N-Gramm von Wörtern an. Jedes N-Gramm Wörter erhält einen eigenen Hash, der durch eine rekursive Formel berechnet wird</font></font><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>h</mi><mo>=</mo><mi>h</mi><mo>&amp;#x2217;</mo><mn>116049371</mn><mo>+</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi>e</mi><mi>s</mi><mo stretchy=&quot;false&quot;>[</mo><mi>j</mi><mo stretchy=&quot;false&quot;>]</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="30.698ex" height="2.634ex" viewBox="0 -809.3 13216.9 1134.2" role="img" focusable="false" style="vertical-align: -0.755ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMATHI-68" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-3D" x="854" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMATHI-68" x="1910" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-2217" x="2709" y="0"></use><g transform="translate(3432,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-31" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-36" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="1501" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-34" x="2002" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-39" x="2502" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-33" x="3003" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-37" x="3503" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-31" x="4004" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-2B" x="8158" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMATHI-68" x="9159" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMATHI-61" x="9735" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMATHI-73" x="10265" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMATHI-68" x="10734" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMATHI-65" x="11311" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMATHI-73" x="11777" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-5B" x="12247" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMATHI-6A" x="12525" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-5D" x="12938" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>h</mi><mo>=</mo><mi>h</mi><mo>∗</mo><mn>116049371</mn><mo>+</mo><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1">h = h*116049371+hashes[j]</script></p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Formel ist ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FNV-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hash- </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Algorithmus</font></a><font style="vertical-align: inherit;"> , der auf eine Zeichenfolge angewendet wird: Er nimmt den Hash jedes Wortes im N-Gramm der Wörter und fügt sie hinzu. </font><font style="vertical-align: inherit;">Auf diese Weise wird ein Satz eindeutiger Hashes erhalten. </font><font style="vertical-align: inherit;">Infolgedessen wird dieser Wert (der sich als ziemlich groß herausstellen kann) modulo übertragen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher werden N-Gramm Wörter ungefähr auf die gleiche Weise berechnet wie N-Gramm Zeichen, jedoch mit einem geringfügigen Unterschied - wir haben kein bestimmtes Wort. </font><font style="vertical-align: inherit;">Erstaunlicher Zug. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Lesen des Satzes wird die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">überwachte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion aufgerufen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn das Angebot mehrere Tags enthält, wählen wir zufällig eines davon aus.</font></font><br>
 <br>
<pre><code class="cpp hljs">
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FastText::supervised</span><span class="hljs-params">(
    Model&amp; model,
    real lr,
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int32_t</span>&gt;&amp; line,
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int32_t</span>&gt;&amp; labels)</span> </span>{
  <span class="hljs-keyword">if</span> (labels.size() == <span class="hljs-number">0</span> || line.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
  <span class="hljs-function"><span class="hljs-built_in">std</span>::uniform_int_distribution&lt;&gt; <span class="hljs-title">uniform</span><span class="hljs-params">(<span class="hljs-number">0</span>, labels.size() - <span class="hljs-number">1</span>)</span></span>;
  <span class="hljs-keyword">int32_t</span> i = uniform(model.rng);<font></font>
  model.update(line, labels[i], lr);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und schließlich die Modellaktualisierungsfunktion.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Model::computeHidden</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int32_t</span>&gt;&amp; input, Vector&amp; hidden)</span> <span class="hljs-keyword">const</span> </span>{<font></font>
  assert(hidden.size() == hsz_);<font></font>
  hidden.zero();<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = input.cbegin(); it != input.cend(); ++it) {
    <span class="hljs-keyword">if</span>(quant_) {<font></font>
      hidden.addRow(*qwi_, *it);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      hidden.addRow(*wi_, *it);<font></font>
    }<font></font>
  }<font></font>
  hidden.mul(<span class="hljs-number">1.0</span> / input.size());<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Model::update</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int32_t</span>&gt;&amp; input, <span class="hljs-keyword">int32_t</span> target, real lr)</span> </span>{<font></font>
  assert(target &gt;= <span class="hljs-number">0</span>);<font></font>
  assert(target &lt; osz_);<font></font>
  <span class="hljs-keyword">if</span> (input.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<font></font>
  computeHidden(input, hidden_);<font></font>
  <span class="hljs-keyword">if</span> (args_-&gt;loss == loss_name::ns) {<font></font>
    loss_ += negativeSampling(target, lr);<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args_-&gt;loss == loss_name::hs) {<font></font>
    loss_ += hierarchicalSoftmax(target, lr);<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    loss_ += softmax(target, lr);<font></font>
  }<font></font>
  nexamples_ += <span class="hljs-number">1</span>;<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (args_-&gt;model == model_name::sup) {<font></font>
    grad_.mul(<span class="hljs-number">1.0</span> / input.size());<font></font>
  }<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = input.cbegin(); it != input.cend(); ++it) {<font></font>
    wi_-&gt;addRow(grad_, *it, <span class="hljs-number">1.0</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eingangsvariablen, die die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">überwachte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion durchlaufen </font><font style="vertical-align: inherit;">, enthalten eine Liste von Indizes aller ihrer Komponenten (Wörter, N-Gramm Wörter und Symbole) des Satzes. Ziel ist es, eine Klasse für die Ausgabe zu definieren. Die Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">computeHidden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ermittelt alle Einbettungen für jede Komponente der Eingabe, indem sie in der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wi_-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Matrix nach ihnen </font><i><font style="vertical-align: inherit;">sucht</font></i><font style="vertical-align: inherit;"> und gemittelt wird ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">addRow</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird </font><font style="vertical-align: inherit;">summiert </font><font style="vertical-align: inherit;">und durch ihre Größe geteilt). Nachdem Sie den Vektor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hidden_ ​​geändert haben,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> senden Sie ihn zur Aktivierung über </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">softmax</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und definieren Sie eine Bezeichnung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Codeabschnitt zeigt die Verwendung der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Softmax-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aktivierungsfunktion </font><font style="vertical-align: inherit;">. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Protokollverlust wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ebenfalls berechnet </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Model::computeOutputSoftmax</span><span class="hljs-params">(Vector&amp; hidden, Vector&amp; output)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">if</span> (quant_ &amp;&amp; args_-&gt;qout) {<font></font>
    output.mul(*qwo_, hidden);<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    output.mul(*wo_, hidden);<font></font>
  }<font></font>
  real max = output[<span class="hljs-number">0</span>], z = <span class="hljs-number">0.0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; osz_; i++) {<font></font>
    max = <span class="hljs-built_in">std</span>::max(output[i], max);<font></font>
  }<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; osz_; i++) {<font></font>
    output[i] = <span class="hljs-built_in">exp</span>(output[i] - max);<font></font>
    z += output[i];<font></font>
  }<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; osz_; i++) {<font></font>
    output[i] /= z;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Model::computeOutputSoftmax</span><span class="hljs-params">()</span> </span>{<font></font>
  computeOutputSoftmax(hidden_, output_);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">real <span class="hljs-title">Model::softmax</span><span class="hljs-params">(<span class="hljs-keyword">int32_t</span> target, real lr)</span> </span>{<font></font>
  grad_.zero();<font></font>
  computeOutputSoftmax();<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; osz_; i++) {<font></font>
    real label = (i == target) ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;<font></font>
    real alpha = lr * (label - output_[i]);<font></font>
    grad_.addRow(*wo_, i, alpha);<font></font>
    wo_-&gt;addRow(hidden_, i, alpha);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> -<span class="hljs-built_in">log</span>(output_[target]);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dieser Methode wird die Größe von N-Gramm Wörtern und Zeichen nicht erhöht. </font><font style="vertical-align: inherit;">Das Wachstum wird durch die Anzahl der bereits verfügbaren </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eimer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> begrenzt </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Standardmäßig verwendet FastText keine N-Gramm, wir empfehlen jedoch die folgenden Optionen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bucker = 2.000.000; </font><font style="vertical-align: inherit;">wordNgrams&gt; 1 oder maxn&gt; 0</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dim = 100</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n_output = 2</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n_words = 500000</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Insgesamt erhalten wir eine ziemlich große Anzahl von Parametern für das Training </font></font><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mo stretchy=&quot;false&quot;>(</mo><mn>5000000</mn><mo>+</mo><mn>2000000</mn><mo stretchy=&quot;false&quot;>)</mo><mo>&amp;#x2217;</mo><mn>100</mn><mo>+</mo><mo stretchy=&quot;false&quot;>(</mo><mn>2</mn><mo>&amp;#x2217;</mo><mn>100</mn><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mn>250</mn><mo>,</mo><mn>000</mn><mo>,</mo><mn>000</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="53.729ex" height="2.634ex" viewBox="0 -809.3 23133.2 1134.2" role="img" focusable="false" style="vertical-align: -0.755ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-28" x="0" y="0"></use><g transform="translate(389,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-35"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="1501" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="2002" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="2502" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="3003" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-2B" x="4115" y="0"></use><g transform="translate(5115,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-32"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="1501" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="2002" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="2502" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="3003" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-29" x="8619" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-2217" x="9231" y="0"></use><g transform="translate(9953,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="1001" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-2B" x="11677" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-28" x="12678" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-32" x="13067" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-2217" x="13790" y="0"></use><g transform="translate(14513,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="1001" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-29" x="16014" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-3D" x="16682" y="0"></use><g transform="translate(17738,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-32"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-35" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="1001" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-2C" x="19239" y="0"></use><g transform="translate(19685,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="1001" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-2C" x="21186" y="0"></use><g transform="translate(21631,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/492432/&amp;usg=ALkJrhj6jBrvXm8kyG-9I-IQpAhnva-OUA#MJMAIN-30" x="1001" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo stretchy="false">(</mo><mn>5000000</mn><mo>+</mo><mn>2000000</mn><mo stretchy="false">)</mo><mo>∗</mo><mn>100</mn><mo>+</mo><mo stretchy="false">(</mo><mn>2</mn><mo>∗</mo><mn>100</mn><mo stretchy="false">)</mo><mo>=</mo><mn>250</mn><mo>,</mo><mn>000</mn><mo>,</mo><mn>000</mn></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2">(5000000+2000000)*100+(2*100) = 250,000,000</script></p> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu viel, nicht wahr?) Wie wir selbst durch einen so einfachen Ansatz sehen können, haben wir eine ziemlich große Anzahl von Parametern, was sehr typisch für Deep-Learning-Methoden ist. </font><font style="vertical-align: inherit;">Eine sehr grobe Schätzung wird verwendet, zum Beispiel die Anzahl der N-Gramm, die für 2_000_000 genommen wurden, um die Reihenfolge anzuzeigen. </font><font style="vertical-align: inherit;">Im Allgemeinen kann die Komplexität des Modells durch Einstellen einiger Hyperparameter wie eines </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buckets</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder der Abtastschwelle </font><font style="vertical-align: inherit;">verringert werden </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige Links können nützlich sein: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">research.fb.com/fasttext </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arxiv.org/pdf/1607.01759.pdf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arxiv.org/pdf/1607.04606v1.pdf </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.youtube.com/watch?v=isPiE-DBagM&amp;index=5&amp;list=PLU40WL8Ol94IJt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ab 47:39)</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de492414/index.html">Anatomie des NSI-Systems</a></li>
<li><a href="../de492420/index.html">Wechat oder eine wirklich umfassende Anwendung. Was kann ein Entwickler damit machen?</a></li>
<li><a href="../de492422/index.html">Escobar Fold 2 - Der Betrug geht weiter</a></li>
<li><a href="../de492424/index.html">Angular: eine andere Möglichkeit, sich abzumelden</a></li>
<li><a href="../de492426/index.html">Wie man Minen der Informationstechnologie umgeht</a></li>
<li><a href="../de492436/index.html">Animierte Proteinankerverbindung</a></li>
<li><a href="../de492438/index.html">Reddit PC-Spieler bündeln ihre Rechenleistung im Rahmen des Folding @ Home-Projekts, um COVID-19 zu bekämpfen</a></li>
<li><a href="../de492440/index.html">FOSS News Nr. 7 - eine Überprüfung der kostenlosen und Open Source-Nachrichten für den 9. bis 15. März 2020</a></li>
<li><a href="../de492444/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 502 (25.02.2020-02.03.2020)</a></li>
<li><a href="../de492446/index.html">Russische Entwickler präsentierten zwei Exoskelette</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>