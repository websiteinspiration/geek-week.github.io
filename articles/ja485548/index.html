<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥖 🚜 🖨️ 棚のSwiftUI 🤸🏼 📍 👩🏼‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="新しいフレームワークがプログラミング言語で登場するたびに、遅かれ早かれ、そこから言語を学ぶ人々が現れます。これはおそらく、Swiftが登場したときのIOS開発のケースでした。最初はObjective-Cへの追加と見なされていましたが、まだ見つかりませんでした。今、あなたがゼロから始めるなら、言語の選...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>棚のSwiftUI</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485548/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいフレームワークがプログラミング言語で登場するたびに、遅かれ早かれ、そこから言語を学ぶ人々が現れます。これはおそらく、Swiftが登場したときのIOS開発のケースでした。最初はObjective-Cへの追加と見なされていましたが、まだ見つかりませんでした。今、あなたがゼロから始めるなら、言語の選択はもはや価値がありません。 Swiftは競争を超えています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じことですが、小規模ですが、フレームワークでも発生します。 SwiftUIの外観も例外ではありません。私はおそらく、UIKitを無視してSwiftUIを学ぶことから始めた最初の世代の開発者の代表です。これには代償があります-トレーニング用の資料や作業コードの例はまだほとんどありません。はい、ネットワークには既に、特定の機能、1つまたは別のツールについて説明する記事が多数あります。同じ上</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.hackingwithswift.comには、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すでに説明付きのサンプルコードがかなりあります。ただし、私のように、SwiftUIをゼロから学習することにした人を支援することはほとんどありません。ほとんどのオンライン資料は、特定の定式化された質問に対する回答です。経験豊富な開発者は、すべてがどのように機能するか、なぜ機能するのか、なぜ適用する必要があるのか​​を簡単に理解できます。初心者の場合、最初にどのような質問をするかを理解する必要があり、そうして初めて彼はこれらの記事にたどり着くことができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カットの下では、現時点で学んだことを体系化して整理しようと思います。</font><font style="vertical-align: inherit;">記事の形式はほぼガイドですが、旅の最初に自分が読みたい形式で私が編集したチートシートです。</font><font style="vertical-align: inherit;">まだSwiftUIを深く掘り下げていない経験豊富な開発者のために、興味深いコード例もいくつかあり、テキストによる説明は斜めに読むことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事を読んで、少しでも魔法を感じたいときは、時間を節約してください。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手始めに、あなた自身について少し</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はモバイル開発のバックグラウンドを実質的に持っておらず</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 、1cでの</font><font style="vertical-align: inherit;">豊富な経験</font><font style="vertical-align: inherit;">はここではほとんど役に立ちません。</font><font style="vertical-align: inherit;">SwiftUIを学ぶことにした理由と方法については、もちろん、誰かにとって興味深いものになるかどうか、改めてお知らせします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私がモバイル開発に没頭するきっかけとなったのは、iOS 13とSwiftUIがリリースされたときです。これは兆候だと私は思い、UIKitを無視して、すぐに始めることを決めました。私がそのようなときに1cで作業を開始したのは面白い偶然でした。その後、管理されたフォームが表示されました。 1cの場合、新技術の普及までに約5年かかりました。開発者は毎回、新しい機能を実装するように指示され、使い慣れたツールを使用して迅速かつ確実に実装するか、結果を保証せずに新しいツールを使いこなすことに多くの時間を費やすという選択に直面しました。現在の選択は通常、速度と品質を優先して行われ、新しいツールへの時間の投資は非常に長い間遅れていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、どうやら、SwiftUIの状況はほぼ同じです。誰もが興味を持ち、誰もがこれが未来であることを理解していますが、これまでに時間をかけて研究した人はほとんどいません。ペットプロジェクトを除いて。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
概して、どのフレームワークを研究するかは問題ではなかったので、一般的な意見ではありますが、1〜2年で製品化することが可能だと思いました。そして、たまたま先駆者の一人だったので、実務経験を共有することにしました。私は第一人者ではなく、一般にモバイル開発のケトルです。それにもかかわらず、私は情報を求めてすべてのインターネットを検索している間に、すでに一定の方法で進んでおり、それは十分ではなく、実際には体系化されていないと確信できます。しかし、もちろんロシア語では、それは事実上存在しません。もしそうなら、私は自分の力を集め、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">詐欺師の</font></a><font style="vertical-align: inherit;">複合体を押しのけることにしました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そして私がどうにか自分で理解したことをコミュニティと共有します。</font><font style="vertical-align: inherit;">読者は少なくとも最低限SwiftUIに精通しているという前提から進み</font></font><code>VStack{…}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>Text(…)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの</font><font style="vertical-align: inherit;">ことは解読しません</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftUIから望ましい結果を達成しようとする自分自身の印象についてさらに説明することをもう一度強調します。</font><font style="vertical-align: inherit;">私は何かを十分に理解できず、誤ったまたは不正確な結論を導き出すためのいくつかの実験から、修正および明確化は断固として歓迎されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
経験豊富な開発者にとって、この記事は明らかなことの説明でいっぱいに見えるかもしれませんが、厳密には判断しません。</font><font style="vertical-align: inherit;">SwiftUIのダミーのチュートリアルはまだ書かれていません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このSwiftUIは一体何なのでしょうか。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だから、私はおそらくそれがすべてであるものから始めるでしょう、これはあなたのSwiftUIです。ここで再び、私の最初の過去が出てきます。管理されたフォームとの類似性は、ストーリーボードでレイアウトをインターフェイスする方法に関するチュートリアルビデオをいくつか見たとき（つまり、UIKitで作業しているとき）だけ強くなりました。私は1の「制御できない」フォームに従って懐かしさを取りました：フォーム上の要素の手動配置、特にバインディング...ああ、約20分のトレーニングビデオの作者がさまざまな要素を互いにバインドしたり、画面の端に微妙なことについて話したとき、私は笑顔で思い出しました1C-制御されたフォームの前はすべて同じでした。ええと、ほぼ...少し悪く、もちろん、ええと、それに応じて-簡単です。そして、SwiftUIは、大まかに言えば、Appleが管理するフォームです。バインディングはありません。ストーリーボードやセグウェイはありません。コードでビューの構造を記述するだけです。そして、それだけです。すべてのパラメーターサイズやものはコードで直接設定されますが、非常に簡単です。より正確には、Canvasで既存のオブジェクトのパラメーターを編集できますが、そのためには、まずそれらをコードに追加する必要があります。正直なところ、大規模な開発チームでこれがどのように機能するのかはわかりません。デザインのレイアウトとビュー自体のコンテンツを分離するのが通例ですが、インディーズの開発者として、私はこのアプローチが本当に好きです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宣言的なスタイル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftUIは、ビューの構造の記述が完全にコード化されていることを前提としています。</font><font style="vertical-align: inherit;">さらに、Appleはこのコードを記述する宣言的なスタイルを提供しています。</font><font style="vertical-align: inherit;">つまり、次のようなものです。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「これはビューです。</font><font style="vertical-align: inherit;">これは</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（何らかの理由で「ビュー」と言いたいので、赤字をフェミニンな言葉として適用します）</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、2つのテキストフィールドと1つの画像で構成されます。</font><font style="vertical-align: inherit;">テキストフィールドは水平方向に次々と配置されます。</font><font style="vertical-align: inherit;">画像はその下にあり、そのエッジは円の形にトリミングされています。」</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異常に聞こえますよね？</font><font style="vertical-align: inherit;">通常、プロセス自体を記述するコードでは、頭の中にある結果を達成するために何を行う必要がありますか。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ブロックを挿入し、このブロックにテキストフィールドを挿入してから、別のテキストフィールドを挿入します。その後、写真を撮り、端を丸めて切り取り、下に貼り付けます。」 </font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イケアからの家具の指示のようですね。</font><font style="vertical-align: inherit;">そして、swiftUIでは、結果がどうなるかがすぐにわかります。</font><font style="vertical-align: inherit;">Canvasやデバッグがなくても、コードの構造はビューの構造を明確に反映しています。</font><font style="vertical-align: inherit;">何がどの順序で表示され、どのような効果があるかは明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FunctionBuilderに関する優れた記事、および宣言型スタイルでコードを記述できる方法については、すでに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habréに掲載されてい</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原則として、宣言型のスタイルとその利点についてはたくさん書かれているので、四捨五入します。</font><font style="vertical-align: inherit;">少し慣れてきたことを自分で付け加えますが、インターフェイスに関しては、このスタイルでコードを書くのがいかに便利かを実感しました。</font><font style="vertical-align: inherit;">これで、Appleはいわゆるブルズアイにぶつかった！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビューは何で構成されていますか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、詳しく見てみましょう。</font><font style="vertical-align: inherit;">Appleは、宣言型スタイルは次のようにすることを推奨しています。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> text1 = <span class="hljs-string">"some text"</span>
    <span class="hljs-keyword">var</span> text2 = <span class="hljs-string">"some more text"</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Text</span>(text1)<font></font>
                .padding()<font></font>
                .frame(width: <span class="hljs-number">100</span>, height: <span class="hljs-number">50</span>)
            <span class="hljs-type">Text</span>(text2)<font></font>
                .background(<span class="hljs-type">Color</span>.gray)<font></font>
                .border(<span class="hljs-type">Color</span>.green)<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意してください</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これはいくつかのパラメータを持つ構造です。</font><font style="vertical-align: inherit;">構造体がになるため</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には、を</font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返す</font><font style="vertical-align: inherit;">計算パラメータを設定する必要があり</font><font style="vertical-align: inherit;">ます</font></font><code>some View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これについては後で説明します。</font><font style="vertical-align: inherit;">回路の内容</font></font><code>body: some View { … }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これは画面に表示される内容の説明です。</font><font style="vertical-align: inherit;">実際には、これが、Viewプロトコルの要件を満たすために私たちの構造に必要なすべてです。</font><font style="vertical-align: inherit;">主にに焦点を当てることを提案し</font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、棚</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
合計で、ビューの本体を構築する3つのタイプの要素を数えました。</font></font><br>
<br>
<ul>
<li><b> View</b><br>
 ..  View        <code>View</code>. ,           <code>View</code>  <code>Text()</code>,   , ,   .       . </li>
<li><b></b><br>
       .  ,      SwiftUI,      <code>View</code>.   ,    ,   —      <code>View</code>  .</li>
<li><b></b><br>
  ,     «Hello, world» —  <code>HStack</code>  <code>VStack</code>.  ,  <code>Group</code>, <code>Section</code>  . ,  —    View,     .      ,   .     ,    -      .   ,    ,    ,        View,     View ( ,    )   ,     (<code>VStack{...}</code> <code>HStack{...}</code>).    ,  <code>ForEach</code>  <code>GeometryReader</code>,      .<br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、私はコンテナを任意のビューと見なし、コンテンツをパラメータとして渡すことができます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、それはすべてです。</font><font style="vertical-align: inherit;">純血種のSwiftUIのすべての要素は、これらのタイプのいずれかに属します。</font><font style="vertical-align: inherit;">はい、これはビューを機能で満たすのに十分ではありませんが、これは画面に機能を表示するために必要なすべてです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.modifiers（）-それらはどのように配置されていますか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も単純なものから始めましょう。修飾子は実際には非常に単純なものです。彼はいくつかを取り</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それに</font><font style="vertical-align: inherit;">いくつかの変更</font><font style="vertical-align: inherit;">を適用します</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（またはそれを行いますか？）</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そしてそれを返します。それら。修飾子は、</font><font style="vertical-align: inherit;">以前にいくつかの変更を行った、を</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返す</font><font style="vertical-align: inherit;">それ自体の関数です</font></font><code>self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、自分の修飾子を宣言するコードの例です。より正確には、既存の修飾子をオーバーロードし</font></font><code> frame(width:height:)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。これにより、特定のビューの特定の寸法を修正できます。そのボックスから、幅と高さを指定する必要があり</font></font><code>CGSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、長さと幅だけの説明で</font><font style="vertical-align: inherit;">あるオブジェクトを1つの引数でそれに渡す必要がありました</font><font style="vertical-align: inherit;">。なぜこれが必要なのかは、後で説明します。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FrameFromSize</span>: <span class="hljs-title">ViewModifier</span></span>{
    <span class="hljs-keyword">let</span> size: <span class="hljs-type">CGSize</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        content<font></font>
            .frame(width: size.width, height: size.height)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードを使用して、プロトコルに準拠した構造を作成しました</font></font><code>ViewModifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このプロトコルは、このような構造で機能を実装するために私たちを必要とし</font></font><code>body()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、特定のがあるでしょうその入力で、</font></font><code>Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および出力に- </font></font><code>some View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と同じタイプの</font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちの</font><font style="vertical-align: inherit;">パラメータ</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（我々はいくつかのビュー以下についてお話します）。</font><font style="vertical-align: inherit;">なんだ</font></font><code>Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これ？</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ+ ViewBuilder =ビュー</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
組み込みのドキュメントはそれについて言っています：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">`content`は、` Self`で表される修飾子が適用されるビューのプロキシです。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはプロキシタイプであり、モディファイヤを適用できるビュープレハブです。半製品の一種。実際、これ</font></font><code>Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は宣言型のクロージャであり、その構造を利用して記述されてい</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。したがって、この修飾子を一部のビューで呼び出す場合、彼が行うのは、クロージャーをから取得</font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して関数に渡すことだけ</font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。このクロージャーに5セントを追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しますが、</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは主に、画面上に画像を生成するために必要なすべてのパラメーターを格納する構造です。組み立て説明書を含み</font></font><code>Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。したがって、</font></font><code>Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘルプで処理さ</font><font style="vertical-align: inherit;">れた宣言スタイル（</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">のクロージャは</font></font><code>ViewBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View </font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
修飾子に戻りましょう。</font><font style="vertical-align: inherit;">理論的には、構造宣言は</font></font><code>FrameFromSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すでにそれを適用し始めるのに十分です。</font><font style="vertical-align: inherit;">内部</font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では次のように書くことができます：</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">4</span>).modifier(<span class="hljs-type">FrameFromSize</span>(size: size))
</code></pre><br>
<code>modifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これはViewのプロトコルメソッドです。これは、変更可能なからコンテンツを抽出し、</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それをモディファイア構造のbody関数に渡し、結果をさらに処理するために</font></font><code>ViewBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、または変更のチェーンがある場合は次のモディファイヤに</font><font style="vertical-align: inherit;">渡し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、独自の修飾子を関数として宣言し、それによってViewプロトコルの機能を拡張することで、さらに簡潔にすることができます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">frame</span><span class="hljs-params">(<span class="hljs-number">_</span> size: CGSize)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">FrameFromSize</span>(size: size))<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、既存の修飾子に</font></font><code>.frame(width: height:)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別のバリアントの入力パラメーター</font><font style="vertical-align: inherit;">をオーバーロードしました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これで、</font></font><code>frame(size:)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意のに対して</font><font style="vertical-align: inherit;">修飾子呼び出しオプション</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用できます</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">結局のところ、複雑なことは何もありません。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラーについて少し</font></font></b>
                        <div class="spoiler_text">,  ,       ,      <code>RoundedRectangle</code>   ,      ,    —   Xcode    ,      «<code>Abort trap: 6</code>»     .  ,  SwiftUI            .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、カスタムモディファイヤを作成し、組み込みのSwiftUIと同じように使用できます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">4</span>).frame(size)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
便利、簡潔、明確。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビーズが糸の上に張られた一連の変更を想像します-私たちのビュー。</font><font style="vertical-align: inherit;">この類似性は、変更が呼び出される順序が重要であるという意味でも当てはまります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tw/1p/ak/tw1paklgxp9d5acpcmwvjywxjce.png"><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SwiftUIのほとんどすべてがビューです</font></font></b>
                        <div class="spoiler_text">,  .     background   ,  View. ..  Color —     ,   View,        .    background, ,    View.<br>
</div>
                    </div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">修飾子-修飾のみ</font></font></b>
                        <div class="spoiler_text">,     . ,      —   SwiftUI   . ..         ,  - ,       . Apple     ,    -      ,    .<br>
</div>
                    </div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静止画</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
先ほど、</font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボディの</font><font style="vertical-align: inherit;">構成要素</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、またはその組み立て手順について説明しました。</font><font style="vertical-align: inherit;">一番に戻りましょう</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">まず第一に、それはいくつかのパラメーターを宣言できる構造であり、</font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはそれらの1つにすぎません。</font><font style="vertical-align: inherit;">すでに述べたように、それ</font></font><code>Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">何であるかを理解すること</font><font style="vertical-align: inherit;">は</font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、宣言的なスタイルのクロージャである、目的のビューを組み立てる方法についての指示です。</font><font style="vertical-align: inherit;">しかし、何が私たちの閉鎖を返すべきでしょうか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部のビュー-便利</font></font></h3><br>
<img align="right" src="https://habrastorage.org/webt/j9/zh/zz/j9zhzza2ma_4if9rhtzqjkqvdhi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、私は長い間理解できなかったという質問にスムーズに行きましたが、これは私が動作するコードを書くことを止めませんでしたが。</font><font style="vertical-align: inherit;">これは何</font></font><code>some View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですか？</font><font style="vertical-align: inherit;">ドキュメントには、この説明は「不透明な結果タイプ」であると記載されていますが、あまり意味がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーワード</font></font><code>some</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これは、クロージャーによって返されるタイプの記述の「汎用」バージョンであり、記述されたコード自体以外には依存しません。それら。ビューの本体の計算されたプロパティにアクセスした結果は、ビュープロトコルを満たす構造になるはずです。それらの多くがあるかもしれません-あなたが宣言したテキスト、画像、またはおそらくいくつかの構造。 someキーワードの全体の要点は、Viewプロトコルに準拠する「ジェネリック」を宣言することです。これは、ビューの本体内に実装されたコードによって静的に決定され、Xcodeはこのコードを完全に解析して、戻り値の特定のシグネチャを計算できます</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ほとんどの場合）</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。そして、いくつかは開発者に不必要な</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">儀式</font></a><font style="vertical-align: inherit;">を負担させないための単なる試みです</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。開発者が「ある種のビューがあるだろう」と言うだけで十分です。どのビューか-自分で整理してください。ここで重要なのは、具象型は、通常のジェネリック型のように入力パラメーターではなく、コードによって直接決定されることです。したがって、上記ではジェネリックを引用しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Xcodeは、この構造体に渡す値を正確に知らなくても、特定のタイプを特定できる必要があります。これは理解することが重要です-コンパイル後、Some Viewという式は特定のタイプに置き換えられます</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このタイプは完全に決定されており、たとえば次のように非常に複雑になる可能性があります</font></font><code>Group&lt;TupleView&lt;(Text, ForEach&lt;[SomeClass], SomeClass.ID, Text&gt;)&gt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このタイプからサンプルコードを復元できます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">Group</span>{
        <span class="hljs-type">Text</span>(…)
        <span class="hljs-type">ForEach</span>(…){(value: <span class="hljs-type">SomeClass</span>)  <span class="hljs-keyword">in</span>
 		<span class="hljs-type">Text</span>(…)<font></font>
 	}<font></font>
}</code></pre><br>
<code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、型シグネチャからわかるように、これはランタイムループではありません。</font><font style="vertical-align: inherit;">それはちょうどだ</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typeオブジェクトの配列に基づいて構築されていること</font></font><code>SomeClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>subView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素</font><font style="vertical-align: inherit;">の識別子は</font><font style="vertical-align: inherit;">、コレクションに関連付けられ</font><font style="vertical-align: inherit;">た特定の</font><font style="vertical-align: inherit;">要素の</font><font style="vertical-align: inherit;">識別子として</font><font style="vertical-align: inherit;">示さ</font><font style="vertical-align: inherit;">れ、</font><font style="vertical-align: inherit;">要素ごとに</font></font><code>subView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型</font><font style="vertical-align: inherit;">が生成されます</font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結合され</font></font><code>TupleView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、これはすべてに配置され</font></font><code>Group</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">あ</font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、もっと話しましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラメータのような正確なシグネチャを記述せざるを得なかった場合、どのくらいの量の書き込みが行われるか想像できます</font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か？</font><font style="vertical-align: inherit;">これを行わないために、キーワードが作成されました</font></font><code>some</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></b>
                        <div class="spoiler_text"><code>some</code>,  „generic — “.      ,      generic-, XCode ,    . <code>some-</code>     ,     .   ,     ,        ().<br>
</div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかのビュー-および結果</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ボディ内の式の静的タイプを計算するアプローチは、私の意見では、2つの重要なポイントを生み出します。 </font></font><br>
<br>
<ul>
<li>Xcode     body      .   body     .     body        ,     .<br>
<img src="https://habrastorage.org/webt/-b/cf/nv/-bcfnvtylozajmnzcgjcto_8ms0.png"><br>
 , View      .       View.  ,        —  CustomView,           .<br>
,     —     View,  ,        Canvas.</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フローを直接制御することはできません。</font><font style="vertical-align: inherit;">If If-else SwiftUIは、タイプ&lt;_ConditionalContent &lt;Text、TextField &gt;&gt;の「Schrödingerビュー」を作成することで引き続き処理できます。トライナー条件演算子は、特定のパラメーター値を選択するためだけに使用でき、タイプを選択したり、修飾子のシーケンスを選択したりすることさえできます。</font></font><br>
<img src="https://habrastorage.org/webt/cp/18/7s/cp187s4fsvn9v3kvwobduyk5rie.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、同じ順序の修飾子を復元する価値があり、そのようなレコードは問題でなくなります。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本体を除く</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、構造内に、操作できる他のパラメーターがある場合があります。</font><font style="vertical-align: inherit;">パラメータとして、次のものを宣言できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外部パラメーター</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらは、ビューが何らかの方法でレンダリングするために、初期化中に外部から渡す必要がある単純な構造パラメーターです。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TextView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">let</span> textValue: <span class="hljs-type">String</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">Text</span>(textValue)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例で</font></font><code>textValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、構造体の</font></font><code>TextView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、これはデフォルト値がないため、外部から入力する必要があるパラメーターです。</font><font style="vertical-align: inherit;">構造体がイニシャライザの自動生成をサポートしている場合、このビューを簡単に使用できます。</font></font><br>
<br>
<pre><code class="swift hljs">        <span class="hljs-type">TextView</span>(textValue: <span class="hljs-string">"some text"</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
外部から、イベント発生時に実行する必要があるクロージャーを転送することもできます。</font><font style="vertical-align: inherit;">たとえば</font></font><code>Button(lable:action:)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ボタンが押されたときに、渡されたアクションクロージャを実行します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態-パラメータ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftUIは、新しいSwift 5.1機能である</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティラッパー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を非常に積極的に使用してい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず第一に、これらは状態変数です-私たちの構造の保存されたパラメーターであり、その変更は画面に反映されるべきです。それらは</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、プリミティブ型</font></font><code>@ObservedObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用とクラス</font><font style="vertical-align: inherit;">用の</font><font style="vertical-align: inherit;">特別なラッパーでラップされ</font><font style="vertical-align: inherit;">ています。クラスはプロトコルを満たす必要があります。</font></font><code>ObservableObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つまり、このクラスは</font></font><code>@ObservedObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティの変更について</font><font style="vertical-align: inherit;">サブスクライバー（この値をラッパーで使用するビュー）に通知できる必要があり</font><font style="vertical-align: inherit;">ます。これを行うには、必要なプロパティをでラップするだけです</font></font><code>@Published</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単な方法を探していない場合、またはこのラッパーの代わりに追加の機能が必要な場合は、</font></font><code>ObservableObjectPublisher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントを使用して手動で通知を送信</font><font style="vertical-align: inherit;">でき</font><font style="vertical-align: inherit;">ます</font></font><code>willSet()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明されているように、これらのパラメータ</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
覚えておいて、私は言った</font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これは単に計算可能なプロパティですか？最初は、State変数の全体的なトリックをすぐには理解していなかったため、</font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラッパーなしで</font><font style="vertical-align: inherit;">いくつかのState変数を内部で宣言しようとしました</font><font style="vertical-align: inherit;">。問題</font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、私が言った</font><font style="vertical-align: inherit;">ように、</font><font style="vertical-align: inherit;">それがステートレスな命令である</font><font style="vertical-align: inherit;">ことである</font><font style="vertical-align: inherit;">ことが</font><font style="vertical-align: inherit;">判明しました</font><font style="vertical-align: inherit;">。ビューはこの指示に従って生成され、ボディ内で宣言されたコンテキスト全体が埋め立てに行きました。保存された構造パラメーターのみが有効です。状態パラメータを変更すると、すべてが</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新されます。命令が再度取得され、すべての構造パラメーターの現在の値がそれに代入され、画面上の画像が収集され、命令は次回まで再びスローされます。内部で宣言された変数</font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-彼女と一緒に。</font><font style="vertical-align: inherit;">経験豊富な開発者にとってはこれは明白かもしれませんが、最初はプロセスの本質を理解していないため、私はこれに苦しみました。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そしてもう一つの発言</font></font></b>
                        <div class="spoiler_text">    <code>didSet</code> <code>willSet</code>   ,   - .      ,     .  ,   —    -  ,     .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
古典的な例 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> tapCount = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span> {
            <span class="hljs-type">Button</span>(action: {<span class="hljs-keyword">self</span>.tapCount += <span class="hljs-number">1</span>},<font></font>
                   label: {<font></font>
                        <span class="hljs-type">Text</span>(<span class="hljs-string">"Tap count \(tapCount)"</span>)<font></font>
                        })<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バインドパラメータ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、ビューサーブのいくつかの変更を反映するために</font></font><code>@State</code> <code>@ObservedObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。しかし、これらの変更はどのように受け渡され</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ますか？これを行うために、SwiftUIには別のPropertyWrapper-があり</font></font><code>@Binding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。クリック数をカウントするためのボタンを使用して、例を複雑にします。</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とりわけ、クリックカウンターを反映</font><font style="vertical-align: inherit;">する親</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、ボタン</font><font style="vertical-align: inherit;">を持つ子がある</font><font style="vertical-align: inherit;">とします。親ビューでは、カウンターは次のように宣言されています</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-理解可能ですが、画面上のカウンターを更新する必要があります。ただし、子では、カウンターはとして宣言する必要があります</font></font><code>@Binding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは別のプロパティラッパーです。これを使用して、変更されるだけでなく、親に戻る構造パラメーターを宣言します</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは一種の</font></font><code>inout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マーカーです</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">子ビューで値が変更されると、この変更は元の元の親ビューに変換されます。</font><font style="vertical-align: inherit;">と同様に</font></font><code>inout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>$,</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">送信された値が別のビュー内で変化するのを待っていることを示すために、送信された値に</font><font style="vertical-align: inherit;">特別な記号を付ける必要があり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">アクションで反応します。</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> tapCount = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">SomeView</span>(<span class="hljs-built_in">count</span>: $tapCount)
            <span class="hljs-type">Text</span>(<span class="hljs-string">"you tap \(tapCount) times"</span>)<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、データ型にも反映されます。</font></font><code>@Binding var tapCount: Int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、それはもはや単なる</font></font><code>Int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプでは</font><font style="vertical-align: inherit;">なく</font><font style="vertical-align: inherit;">、</font></font><br>
<br>
<pre><code class="plaintext hljs">Binding&lt;Int&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、たとえば、独自のイニシャライザを作成する場合に役立ちます</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SomeView</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">Binding</span> <span class="hljs-keyword">var</span> tapCount: <span class="hljs-type">Int</span>
    <span class="hljs-keyword">init</span>(<span class="hljs-built_in">count</span>: <span class="hljs-type">Binding</span>&lt;<span class="hljs-type">Int</span>&gt;){
        <span class="hljs-keyword">self</span>._tapCount = <span class="hljs-built_in">count</span>
 <span class="hljs-comment">//    -   </span><font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">Button</span>(action: {<span class="hljs-keyword">self</span>.tapCount += <span class="hljs-number">1</span>},<font></font>
               label: {<font></font>
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"Tap me"</span>)<font></font>
                    })<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部</font><font style="vertical-align: inherit;">では、アンダースコア</font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font><code>@PropertyWrapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">して一部のパラメーターでラップされたパラメーターを参照する</font><font style="vertical-align: inherit;">必要がある</font><font style="vertical-align: inherit;">ことに</font><font style="vertical-align: inherit;">注意してください。</font></font><code>self._</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、</font></font><code>self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まだ作成</font><font style="vertical-align: inherit;">中の初期化子で機能します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">より正確には、</font></font><code>self._</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラッパーと一緒にパラメーターを参照することにより、パラメーターを参照します。</font><font style="vertical-align: inherit;">ラッパー内で直接値にアクセスすると、下線が引かれません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、変数が何らかの入力</font></font><code>PropertyWrapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でラップされている場合、ラッパータイプを取得します。この場合、</font></font><br>
<br>
<pre><code class="plaintext hljs">Binding&lt;Int&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 タイプ値には、</font></font><code>Int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から</font><font style="vertical-align: inherit;">直接アクセス</font><font style="vertical-align: inherit;">でき</font><font style="vertical-align: inherit;">ます</font></font><code>.wrappedValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そしていつものように、個人的な熊手</font></font></b>
                        <div class="spoiler_text">,  Binding     .   View          View.      View      ,    @Binding-.  ,   View     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link">State</a>  @Binding — ,     State-   Binding.       -,  ,    .<br>
update:  , SwiftUI    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link">State</a>    . ..   ,   init(),       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link">State</a>   , SwiftUI      ,        .    @ObservedObject   ,    .<br>
</div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EnvironmentObject</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要するに、</font></font><code> EnvironmentObject </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータはのようなものであり</font></font><code>Binding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明示的に渡す必要なしに、階層内の</font><font style="vertical-align: inherit;">すべてのユーザーに対して即座にのみ</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">ContentView</span>().environmentObject(session)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、アプリケーションの現在の状態、または多くのViewが一度に必要とするアプリケーションの一部が送信されます。たとえば、ユーザー、セッション、または類似のものに関するデータは、一度ルートビューのEnvironmentObjectに配置するのが理にかなっています。各ビューでは、必要に応じて、@ EnvironmentObjectラッパーで変数を宣言することにより、環境から取り出すことができます。たとえば、次のようにします。</font></font><br>
<br>
<pre><code class="swift hljs"> @<span class="hljs-type">EnvironmentObject</span> <span class="hljs-keyword">var</span> session: <span class="hljs-type">Session</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定の値の識別子は、タイプ自体です。あなたが入れた場合は</font></font><code>EnvironmentObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、同じタイプのいくつかの値は、順序が重要です。 3番目の値、たとえば値に到達するには、必要がない場合でも、すべての値を順番に取得する必要があります。したがって、</font></font><code>EnvironmentObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションの状態を反映するのに適していますが、同じタイプの複数の値をの間で渡すことはあまり適していません</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。それらはを介して手動で送信する必要があります</font></font><code>Binding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
@環境はほとんど同じです。つまり、これは環境の状態です。 OSこのラッパーを通過すると便利です。たとえば、画面の位置（垂直または水平）、明るいまたは暗いテーマが使用されているなどです。また、このラッパーを介して、CoreDataを使用するときにデータベースにアクセスできます。</font></font><br>
<br>
<pre><code class="swift hljs">@<span class="hljs-type">Environment</span>(\.managedObjectContext) <span class="hljs-keyword">var</span> moc: <span class="hljs-type">NSManagedObjectContext</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ところで、SwiftUIでCoreDataを操作するために、非常に多くの興味深いことが行われています。</font><font style="vertical-align: inherit;">しかし、これについては、おそらく次回です。</font><font style="vertical-align: inherit;">したがって、記事はすべての期待を超えて成長しています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カスタム@PropertyWrapper</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
概して、</font></font><code>PropertyWrapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはセッターとゲッターのショートカットであり、同じパラメーターでラップされたすべてのパラメーターで同じ</font></font><code>property wrapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">ラッパー宣言を削除してゲッター{}セッター{}パラメーターを書き込むことにより、この機能を自分で完全に復元できますが、これは毎回、毎回</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コードを複製する必要があります。</font><font style="vertical-align: inherit;">たとえば、を使用すると、</font></font><code>PropertyWrapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から作業を隠すのに非常に便利</font></font><code>UserDefaults</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-meta">@propertyWrapper</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UserDefault</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
    <span class="hljs-keyword">var</span> key: <span class="hljs-type">String</span>
    <span class="hljs-keyword">var</span> initialValue: <span class="hljs-type">T</span>
    <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-type">T</span> {
        <span class="hljs-keyword">set</span> { <span class="hljs-type">UserDefaults</span>.standard.<span class="hljs-keyword">set</span>(newValue, forKey: key) }
        <span class="hljs-keyword">get</span> { <span class="hljs-type">UserDefaults</span>.standard.object(forKey: key) <span class="hljs-keyword">as</span>? <span class="hljs-type">T</span> ?? initialValue }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、プリミティブデータ型をstorageに格納でき</font></font><code>UserDefaults</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">Appleは、このストレージへのアクセス速度は非常に優れていると主張しているため、もちろん、大量のループやスピードが要求されるタスクで使用されない限り、このデータを構造パラメーターまたは変数の形式でメモリにキャッシュする必要はないでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを念頭に置い</font></font><code>UserDefaults</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て、先ほど作成したラッパーを使用して</font><font style="vertical-align: inherit;">格納された特定の値にアクセスするための静的変数を宣言するスタブ型（この場合は列挙型）を</font><font style="vertical-align: inherit;">作成できます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">UserPreferences</span> </span>{<font></font>
    @<span class="hljs-type">UserDefault</span>(key: <span class="hljs-string">"isCheatModeEnabled"</span>, initialValue: <span class="hljs-literal">false</span>) <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> isCheatModeEnabled: <span class="hljs-type">Bool</span>
    @<span class="hljs-type">UserDefault</span>(key: <span class="hljs-string">"highestScore"</span>, initialValue: <span class="hljs-number">10000</span>) <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> highestScore: <span class="hljs-type">Int</span>
    @<span class="hljs-type">UserDefault</span>(key: <span class="hljs-string">"nickname"</span>, initialValue: <span class="hljs-string">"cloudstrife97"</span>) <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> nickname: <span class="hljs-type">String</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果は、ロジックと視覚的表示に焦点を当てて非常に簡潔に使用でき、すべての作業は内部で行われます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">UserPreferences</span>.isCheatModeEnabled = <span class="hljs-literal">true</span>
<span class="hljs-type">UserPreferences</span>.highestScore = <span class="hljs-number">25000</span>
<span class="hljs-type">UserPreferences</span>.nickname = <span class="hljs-string">"squallleonhart”
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例はもともと</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明さ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">れました</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、私のリストから最後に議論するのはコンテナです。について話したとき、これについてはすでに部分的に触れました</font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。実際、コンテナは一般的</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。唯一の違いは、この構造のパラメータの1つとして、コンテンツを送信することです。コンテンツは、宣言的なスタイルの1つ以上の式を含むクロージャーであることを思い出してください。このクロージャーは、を使用して処理</font></font><code>@ViewBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">されると、クロージャー（コンテンツブロック）にリストされているすべてのビューを特定の方法で結合した新しいビューに戻ります。同時に、コンテナごとに、ブロック自体の処理メカニズムは異なります。</font></font><code>VStack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ要素を垂直方向、</font></font><code>HStack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水平方向などに配置します。これはモディファイアのようなものですが、今回は変更されている特定の1つのビューだけでなく、全体</font></font><code>Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナに転送され、新しいコンテナが生成され</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">さらに、この新しい</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプには新しいタイプがあります。</font><font style="vertical-align: inherit;">たとえば、</font></font><code>HStack{Text(…)}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このタイプの場合はになります</font></font><code> TupleView&lt;Text, Image&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナを含む</font><font style="vertical-align: inherit;">すべての</font><font style="vertical-align: inherit;">は、ボディ以外のパラメータを持つことができる構造であることを</font><font style="vertical-align: inherit;">忘れないでください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">たとえば、長い間、</font></font><code>Text(«a»)</code> <code>Text(«b»)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部の</font><font style="vertical-align: inherit;">小さな隙間をどうやって取り除くかわからなかった</font></font><code>HStack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私は多くの時間を過ごした</font></font><code>offset()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、</font></font><code>position()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私が誤って宣言の完全な構文につまずいまで、オフセットラインの長さに基づいて座標を計算し、</font></font><code>HStack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HStack（spacing：、alingment：、context :)。</font></font><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単に言うと、最初の2つのパラメーターはオプションであり、ほとんどの例ではスキップされます。</font><font style="vertical-align: inherit;">初心者の間違い-完全な構文を見ていません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foreach</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それとは別に、について話す価値があり</font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。これは、転送されたコレクションのすべての要素を画面に反映するためのコンテナです。まず、これはコレクションの呼び出しと同じではないことを理解する必要があります</font></font><code>forEach(…)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。上で述べたよう</font><font style="vertical-align: inherit;">に、転送されたコレクションの要素に基づいて作成された</font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つの一意のを返します</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。それら。これは、コレクションが転送されるもう1つのコンテナであり、コレクションの要素を画面に反映する方法についての説明です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、</font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この複数のエンティティをグループ化する方法を決定する他のコンテナ内に配置</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">必要があります。たとえば、エンティティを垂直、水平、またはリストに配置します（</font></font><code>List</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3つのパラメーターを受け入れます：コレクション（</font></font><code>data: RandomAccesCollection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、コレクション要素識別子（</font></font><code>id: Hashable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）およびコンテンツ（</font></font><code>content: ()-&gt;Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">のアドレス</font><font style="vertical-align: inherit;">。すでに説明した3番目：他のコンテナーと同様に、それ</font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は受け入れます</font></font><code>Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-つまり短絡。ただし</font></font><code>content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、パラメーターが含まれ</font><font style="vertical-align: inherit;">て</font><font style="vertical-align: inherit;">いない</font><font style="vertical-align: inherit;">通常のコンテナーとは異なり</font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コレクション要素をクロージャーに転送し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">クロージャーは、コンテンツを説明するために使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コレクションは</font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どれにも適し</font><font style="vertical-align: inherit;">て</font><font style="vertical-align: inherit;">いません</font></font><code>RandomAccesCollection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。さまざまな無秩序なコレクションの場合、</font></font><code>sorted(by:)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取得できる</font><font style="vertical-align: inherit;">メソッドを呼び出すだけで十分</font><font style="vertical-align: inherit;">です</font></font><code>RandomAccesCollection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これは</font></font><code>subView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、送信されたコンテンツに基づいて、コレクションの各要素に対して生成され</font><font style="vertical-align: inherit;">たセット</font><font style="vertical-align: inherit;">です。 SwiftUI </font></font><code>subView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、コレクション内のどの要素に関連付けられ</font><font style="vertical-align: inherit;">ているかを知る必要があることに注意することが重要</font><font style="vertical-align: inherit;">です。このために、それぞれ</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">識別子でなければなりません。これには、2番目のパラメーターが正確に必要です。コレクションの要素が</font></font><code>Hashable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文字列などの型</font><font style="vertical-align: inherit;">である場合は、</font><font style="vertical-align: inherit;">簡単に記述できます</font></font><code>id: \.self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、文字列自体が識別子になることを意味します。コレクションの要素がクラスであり、プロトコルを満たす</font></font><code>Identifiable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、2番目の引数は省略できます。この場合、コレクション内の各アイテムのIDが識別子になります</font></font><code>subView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。オブジェクトに、一意性を保証する何らかの種類の小道具があり、それがプロトコルを満たす</font></font><code>Hashable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、次のように指定できます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">ForEach</span>(values, id: \.value){item <span class="hljs-keyword">in</span> …}
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の例で</font></font><code>values</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">は、</font></font><code>SomeObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小道具が宣言されている</font><font style="vertical-align: inherit;">クラスオブジェクトの配列です</font></font><code>value: Int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。いずれの場合も、</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コレクションの要素に関連付けられて</font><font style="vertical-align: inherit;">いる各識別子</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">一意であることを確認する必要があり</font><font style="vertical-align: inherit;">ます。たとえば、コンテキストでは、オブジェクトの一部のパラメーターが変更される場合があります。</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データオブジェクト（コレクション要素）と1対1でマッピングする必要があります。そうしないと、</font></font><code>@Binding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータ</font><font style="vertical-align: inherit;">changeを返す場所が明確になりません</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、Identifiableを満たさないコレクション要素のクロールの整理は、インデックスを使用して行うこともできます。たとえば、次のようになります。</font></font><br>
<pre><code class="swift hljs">
<span class="hljs-type">ForEach</span>(keys.<span class="hljs-built_in">indices</span>){ind <span class="hljs-keyword">in</span>
        <span class="hljs-type">SomeView</span>(key: <span class="hljs-keyword">self</span>.keys[ind]) <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、トラバーサルは要素自体ではなく、それらのインデックスによって構築されます。小さなコレクションの場合、これは完全に許容できます。多数の要素を含むコレクションでは、特にコレクションの要素が参照型ではなく、膨大な文字列やJSONデータなどの場合、これはおそらくパフォーマンスに影響を与える可能性があります。一般に、注意して使用してください。</font><font style="vertical-align: inherit;">何に言及するか</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
についての重要なポイント</font><font style="vertical-align: inherit;">。彼は非常に不機嫌で、複数のブロックがあるクロージャでは正常に動作することを拒否します（つまり、彼は通常1行のコンテンツを認識していますが、すでに2つ以上持っていません）。これは非常に簡単に解決され、すべてのコンテンツをプッシュするのは非常に簡単</font><font style="vertical-align: inherit;">です。このようなハッキングは問題ではなくなります。</font></font><code>Content</code><font style="vertical-align: inherit;"></font><code>ForEach</code><font style="vertical-align: inherit;"></font><code>Groupe{}</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このクロージャーのスコープで内部変数を宣言するだけでは機能しません。</font><font style="vertical-align: inherit;">ViewBuilderに渡されるクロージャーには、変数宣言を含めることはできません。</font><font style="vertical-align: inherit;">記事の冒頭で、モディファイアを作成する例を挙げました</font></font><code>.frame(size:)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か？</font><font style="vertical-align: inherit;">このために作成しました。</font><font style="vertical-align: inherit;">行内のこれらのボタンの数と行の数に基づいてボタンのサイズを計算しました（自動ストレッチに不満があり、ボタンごとにサイズを変える必要がありました）。</font><font style="vertical-align: inherit;">関数はCGSizeを返し、ネストされた構造のいくつかのレベルが内部でクロールされました。</font><font style="vertical-align: inherit;">関数を1回実行できる場合は、その結果を可変サイズとして書き込み、次に呼び出します。</font></font><code>.frame(width: size.width, height: size.height)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「私はそうします。」</font><font style="vertical-align: inherit;">しかし、そのような可能性はなく、関数を2回実行したくありませんでした。この制限を回避し、コードの一部を修飾子に入れたためです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カスタムコンテナービュー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、たまたま、カスタムコンテナを作成する例を紹介します。</font><font style="vertical-align: inherit;">多くの場合、タイプ「1：N」のいくつかのオブジェクトの関係は、辞書の形で便利に表すことができます。</font><font style="vertical-align: inherit;">クエリ</font></font><code>dict: [KeyObject: [SomeObject]]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">実行して、その結果をタイプディクショナリに変換することは</font><font style="vertical-align: inherit;">難しく</font><font style="vertical-align: inherit;">あり</font><font style="vertical-align: inherit;">ません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、クラスのオブジェクトはディクショナリキーとして機能し</font></font><code>KeyObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（このため、プロトコルをサポートする必要があります</font></font><code>Hashable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、値-別のクラスのオブジェクトの配列-として機能します</font></font><code>SomeObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeObject</span>: <span class="hljs-title">Identifiable</span></span>{
    <span class="hljs-keyword">let</span> value: <span class="hljs-type">Int</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> id: <span class="hljs-type">UUID</span> = <span class="hljs-type">UUID</span>()
    <span class="hljs-keyword">init</span>(value: <span class="hljs-type">Int</span>){
        <span class="hljs-keyword">self</span>.value = value<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeyObject</span>: <span class="hljs-title">Hashable</span>, <span class="hljs-title">Comparable</span></span>{
    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>
    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>){
        <span class="hljs-keyword">self</span>.name = name<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> &lt; (lhs: KeyObject, rhs: KeyObject) -&gt; <span class="hljs-title">Bool</span> </span>{<font></font>
        lhs.name &lt; rhs.name<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> == <span class="hljs-params">(lhs: KeyObject, rhs: KeyObject)</span></span> -&gt; <span class="hljs-type">Bool</span> {
        <span class="hljs-keyword">return</span> lhs.name == rhs.name<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hash</span><span class="hljs-params">(into hasher: <span class="hljs-keyword">inout</span> Hasher)</span></span> {<font></font>
        hasher.combine(name)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションがグループ化を使用してある種の分析を計画している場合、各ビューのすべてのコードを複製しないように、そのような辞書を表示するための別個のコンテナーを作成することは理にかなっています。グループ化はユーザーが変更できるという事実を考えると、ジェネリックを使用する必要があります。コンテナーの構造だけを残して、視覚的なデザインを追加することでそれを複雑にしませんでした。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeView</span>&lt;<span class="hljs-title">K</span>: <span class="hljs-title">Hashable</span>, <span class="hljs-title">V</span>: <span class="hljs-title">Identifiable</span>, <span class="hljs-title">KeyContent</span>, <span class="hljs-title">ValueContent</span>&gt;: <span class="hljs-title">View</span> <span class="hljs-title">where</span> <span class="hljs-title">K</span>: <span class="hljs-title">Comparable</span>, <span class="hljs-title">KeyContent</span>: <span class="hljs-title">View</span>, <span class="hljs-title">ValueContent</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">let</span> data: [<span class="hljs-type">K</span>: [<span class="hljs-type">V</span>]]
    <span class="hljs-keyword">let</span> keyContent: (<span class="hljs-type">K</span>)-&gt;<span class="hljs-type">KeyContent</span>
    <span class="hljs-keyword">let</span> valueContent: (<span class="hljs-type">V</span>)-&gt;<span class="hljs-type">ValueContent</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>(alignment: .leading, spacing: <span class="hljs-number">0</span>){
            <span class="hljs-type">ForEach</span>(data.keys.sorted(), id: \.<span class="hljs-keyword">self</span>){(key: <span class="hljs-type">K</span>) <span class="hljs-keyword">in</span>
                <span class="hljs-type">VStack</span>(alignment: .trailing, spacing: <span class="hljs-number">0</span>){
                    <span class="hljs-keyword">self</span>.keyContent(key)
                    <span class="hljs-type">ForEach</span>(<span class="hljs-keyword">self</span>.data[key]!){(value: <span class="hljs-type">V</span>) <span class="hljs-keyword">in</span>
                        <span class="hljs-keyword">self</span>.valueContent(value)<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、コンテナは</font><font style="vertical-align: inherit;">タイプのディクショナリ</font></font><code>[K: [V]]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>K</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はディクショナリキーオブジェクト</font></font><code>V</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のタイプ、ディクショナリ値が一致する配列のタイプです）と2つのコンテキストを</font><font style="vertical-align: inherit;">受け入れます</font><font style="vertical-align: inherit;">。1つはディクショナリキーの表示用で、もう1つは値の表示用です。残念ながら、</font></font><code>ViewBuilder-</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カスタムコンテナの</font><font style="vertical-align: inherit;">カスタム</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">作成する例は見つからなかったため</font><font style="vertical-align: inherit;">（おそらくこのオプションは存在しないだけです）、標準のを使用する必要があります</font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。それが唯一の入力で受け付けているので</font></font><code>RandomAccessCollection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そして</font></font><code>dict.keys</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それはありませんが、我々は、並べ替えを使用する必要があります。したがって、プロトコル</font></font><code>Comparable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k </font><font style="vertical-align: inherit;">をサポートするための要件</font></font><code>KeyObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのネストされた</font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナー</font><font style="vertical-align: inherit;">を使用しました</font><font style="vertical-align: inherit;">。最初のケースでは、コレクションアイテムのハッシュ（</font></font><code>\.self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）ネストされ</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">た</font><font style="vertical-align: inherit;">各の識別子として</font><font style="vertical-align: inherit;">。私はそれをすることができましたとにかく、辞書キーはプロトコルをサポートするべきです</font></font><code>Hashable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 2番目のケースでは、クラスに</font></font><code>SomeObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロトコルサポート</font><font style="vertical-align: inherit;">を追加しました</font></font><code>Identifiable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これにより、通信キーをまったく指定する必要がなくなりました-idが自動的に使用されます。</font><font style="vertical-align: inherit;">私の場合、idはどこにも保存されていません。</font><font style="vertical-align: inherit;">オブジェクトが作成されるたびに、それがコードで作成されるか、データベースクエリを使用して取得されるかにかかわらず、新しいIDが生成されます。</font><font style="vertical-align: inherit;">インターフェースの場合、これは必須ではありません。</font><font style="vertical-align: inherit;">オブジェクトの存続期間を通じて変化しません。</font><font style="vertical-align: inherit;">セッション、これはこのIDで表示するには十分です。</font><font style="vertical-align: inherit;">そして、次にアプリケーションを開いたときに、別のIDが割り当てられます-何も悪いことは起こりません。</font><font style="vertical-align: inherit;">オブジェクトにすでにキーフィールドがある場合は、idを計算されたパラメータにして、このプロトコルのサポートと省略構文を使用できます</font></font><code>ForEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナーの使用例：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">let</span> dict: [<span class="hljs-type">KeyObject</span>: [<span class="hljs-type">SomeObject</span>]] = [
        <span class="hljs-type">KeyObject</span>(name: <span class="hljs-string">"1st group"</span>) : [<span class="hljs-type">SomeObject</span>(value: <span class="hljs-number">1</span>),
             <span class="hljs-type">SomeObject</span>(value: <span class="hljs-number">2</span>),
             <span class="hljs-type">SomeObject</span>(value: <span class="hljs-number">3</span>)],
        <span class="hljs-type">KeyObject</span>(name: <span class="hljs-string">"2nd group"</span>) : [<span class="hljs-type">SomeObject</span>(value: <span class="hljs-number">4</span>),
             <span class="hljs-type">SomeObject</span>(value: <span class="hljs-number">5</span>),
             <span class="hljs-type">SomeObject</span>(value: <span class="hljs-number">6</span>)],
        <span class="hljs-type">KeyObject</span>(name: <span class="hljs-string">"3rd group"</span>) : [<span class="hljs-type">SomeObject</span>(value: <span class="hljs-number">7</span>),
             <span class="hljs-type">SomeObject</span>(value: <span class="hljs-number">8</span>),
             <span class="hljs-type">SomeObject</span>(value: <span class="hljs-number">9</span>)]<font></font>
    ]<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">TreeView</span>(data: dict,<font></font>
                 keyContent: {keyObject <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"the key is: \(keyObject.name)"</span>)<font></font>
                 }<font></font>
        ){valueObject <span class="hljs-keyword">in</span>
            <span class="hljs-type">Text</span>(<span class="hljs-string">"value: \(valueObject.value)"</span>)<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャンバスの画面上の結果：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/48/jl/e_/48jle_vonedzfqtotu7uclu2u1e.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つづく</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは今のところすべてです。</font><font style="vertical-align: inherit;">私が踏んだすべてのレーキ</font></font><code>CoreData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をSwiftUIと組み合わせ</font><font style="vertical-align: inherit;">て使用することも試みて照らしたかったのです</font><font style="vertical-align: inherit;">が、率直に言って、SwiftUIの基本だけにそれほど時間がかかり、記事が膨大になるとは思いませんでした。</font><font style="vertical-align: inherit;">彼らが言うように、継続されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
追加または修正する必要がある場合は、コメントへようこそ。</font><font style="vertical-align: inherit;">記事に重要なコメントを反映するようにします。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja485538/index.html">Zabbix：行のすべてを監視します（例としてRedisを使用）</a></li>
<li><a href="../ja485540/index.html">リバースアナログカメラの設計</a></li>
<li><a href="../ja485542/index.html">Notionにグラフィックを追加する</a></li>
<li><a href="../ja485544/index.html">動的システムとしてのチェス</a></li>
<li><a href="../ja485546/index.html">黙示録が来ています</a></li>
<li><a href="../ja485550/index.html">モスクワ環状道路を越えて生命はありますか？開発者を探して準備する方法</a></li>
<li><a href="../ja485554/index.html">目標と主要な結果（OKR）-段階的な実装経験</a></li>
<li><a href="../ja485556/index.html">ショウジョウバエの脳マップのセクションを作成するのに12年かかりました。250人の努力と4000万ドル</a></li>
<li><a href="../ja485558/index.html">蚊にノー！蚊「ファイト弾薬」の概要</a></li>
<li><a href="../ja485560/index.html">アンチパターンDevOpsインタビュー</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>