<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>↕️ 🔤 🖕🏼 高負荷のGPUコンピューティングサービス 🧑🏻 🧑🏼‍🤝‍🧑🏻 ♠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！私はビジョンプラットフォームの開発を主導しています。これは、コンピュータービジョンモデルへのアクセスを提供し、顔、数字、オブジェクト、シーン全体の認識などの問題を解決できるパブリックプラットフォームです。そして今日、私はビジョンの例によって、ビデオカードを使用して高速で高負荷のサ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>高負荷のGPUコンピューティングサービス</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/472928/"><img src="https://habrastorage.org/webt/_v/yk/sa/_vyksasjmhcbsn1feox_egbqs_4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
こんにちは、ハブル！</font><font style="vertical-align: inherit;">私は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジョン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プラットフォームの開発を主導してい</font><font style="vertical-align: inherit;">ます。これは、コンピュータービジョンモデルへのアクセスを提供し、顔、数字、オブジェクト、シーン全体の認識などの問題を解決できるパブリックプラットフォームです。</font><font style="vertical-align: inherit;">そして今日、私はビジョンの例によって、ビデオカードを使用して高速で高負荷のサービスを実装する方法、それを展開して操作する方法を伝えたいと思います。</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジョンとは？</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは本質的にREST APIです。ユーザーは写真付きのHTTPリクエストを生成し、それをサーバーに送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
写真で顔を認識する必要があるとします。システムはそれを見つけ、切り取り、顔からいくつかのプロパティを抽出し、データベースに保存して、条件付きの番号を割り当てます。たとえば、person42です。次に、ユーザーは同じ人物が写っている次の写真をアップロードします。システムは顔からプロパティを抽出し、データベースを検索して、最初に個人に割り当てられた条件付き番号を返します。人42。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日、Visionの主なユーザーはMail.ru Groupのさまざまなプロジェクトです。ほとんどのリクエストはメールとクラウドから送信されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c77/448/9a8/c774489a8bcd0a3badf0a8413d95e97c.png" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラウドでは、ユーザーは写真がアップロードされるフォルダーを持っています。クラウドは、Visionを介してファイルを実行し、それらをカテゴリーにグループ化します。その後、ユーザーは自分の写真を簡単にめくることができます。たとえば、友達や家族に写真を見せたいときに、必要な写真をすばやく見つけることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メールとクラウドはどちらも数百万人の非常に大規模なサービスであるため、Visionは1分あたり数十万のリクエストを処理します。</font><font style="vertical-align: inherit;">つまり、これは古典的な高負荷サービスですが、ひねりを加えています。nginx、Webサーバー、データベース、キューがありますが、このサービスの最低レベルでは推論、つまりニューラルネットワークを介して画像を実行します。</font><font style="vertical-align: inherit;">ほとんどの時間を占め、リソースを必要とするのはニューラルネットワークの実行です。</font><font style="vertical-align: inherit;">コンピューティングネットワークは、通常CPUで長い時間がかかる一連の行列演算で構成されていますが、GPUで完全に並列化されています。</font><font style="vertical-align: inherit;">ネットワークを効率的に実行するには、ビデオカードを備えたサーバーのクラスターを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、このようなサービスを作成するときに役立つヒントをいくつか紹介します。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービス開発</font></font></h1><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのリクエストの処理時間</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
負荷の高いシステムでは、1つのリクエストの処理時間とシステムのスループットが重要です。まず、ニューラルネットワークアーキテクチャを正しく選択することにより、高速なクエリ処理が提供されます。 MLでは、他のプログラミングタスクと同様に、同じタスクをさまざまな方法で解決できます。顔検出を行う：この問題を解決するために、最初にR-FCNアーキテクチャを備えたニューラルネットワークを採用しました。どちらかと言えば高品質ですが、1つの画像に約40ミリ秒かかって不適でしたが、MTCNNアーキテクチャに切り替えたところ、速度が2倍になり、わずかに品質が低下しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ニューラルネットワークの計算時間を最適化するために、教えられたものではなく、別のフレームワークで推論を実装することが本番環境で有利になる場合があります。</font><font style="vertical-align: inherit;">たとえば、モデルをNVIDIA TensorRTに変換することが理にかなっている場合があります。</font><font style="vertical-align: inherit;">彼はいくつかの最適化を適用し、かなり複雑なモデルで特に優れています。</font><font style="vertical-align: inherit;">たとえば、何とかしてレイヤーを並べ替えたり、マージしたり、破棄したりすることもできます。</font><font style="vertical-align: inherit;">結果は変化せず、推論計算速度が向上します。</font><font style="vertical-align: inherit;">また、TensorRTを使用すると、メモリをより適切に管理でき、いくつかのトリックの後で、メモリの計算を減らして精度の低い数値を計算できるため、推論の計算速度も向上します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオカードをダウンロード</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワークの推論はGPUで実行されます。ビデオカードはサーバーの最も高価な部分であるため、できるだけ効率的に使用することが重要です。理解するには、GPUを完全にロードしましたか、それとも負荷を増やすことができますか？この質問には、たとえば、標準のビデオドライバーパッケージのnvidia-smiユーティリティのGPU Utilizationパラメーターを使用して回答できます。もちろん、この図では、ビデオカードに直接ロードされているCUDAコアの数は示されていませんが、アイドル状態の数は示されていますが、GPUのロードを何らかの方法で評価できます。経験から、80〜90％の読み込みが適切であると言えます。負荷が10〜20％の場合、これは不良であり、まだ可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この観察の重要な結果：ビデオカードのロードを最大化するようにシステムを整理する必要があります。</font><font style="vertical-align: inherit;">さらに、ビデオカードが10枚あり、それぞれが10〜20％でロードされている場合、ほとんどの場合、2枚の高負荷ビデオカードで同じ問題を解決できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムスループット</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像をニューラルネットワークの入力に送信すると、画像処理はさまざまな行列演算に削減されます。</font><font style="vertical-align: inherit;">ビデオカードはマルチコアシステムであり、通常送信する入力画像は小さいです。</font><font style="vertical-align: inherit;">ビデオカードに1,000コアがあり、画像に250 x 250ピクセルがあるとします。</font><font style="vertical-align: inherit;">単独で、それらは適度なサイズのためにすべてのコアをロードすることができません。</font><font style="vertical-align: inherit;">また、そのような写真を一度に1つずつモデルに送信すると、ビデオカードの読み込みは25％を超えません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b9/b25/191/4b9b2519170a86b151420cc0a746a2fe.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、一度に推論するためにいくつかの画像をアップロードし、それらからバッチを形成する必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04c/367/51b/04c36751b27fa428e9828a6fa007e25d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、ビデオカードの負荷が95％に上昇し、単一の画像の場合と同様に、推論の計算に時間がかかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、キューに10枚の写真がないために、それらを1つのバッチに結合できるとしたらどうでしょう。</font><font style="vertical-align: inherit;">リクエストが来ることを期待して、たとえば50〜100 ms少し待つことができます。</font><font style="vertical-align: inherit;">この戦略は、レイテンシの修正戦略と呼ばれます。</font><font style="vertical-align: inherit;">これにより、クライアントからのリクエストを内部バッファに結合できます。</font><font style="vertical-align: inherit;">その結果、遅延が一定量増加しますが、システムのスループットは大幅に増加します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推論を開始</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
固定のフォーマットとサイズ（200 x 200ピクセルなど）の画像でモデルをトレーニングしますが、サービスはさまざまな画像をアップロードする機能をサポートしている必要があります。したがって、推論を行う前にすべての画像を適切に準備する必要があります（サイズ変更、中央揃え、正規化、フロートへの変換など）。これらすべての操作が推論を起動するプロセスで実行される場合、その作業サイクルは次のよう</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f75/5be/112/f755be112bc557d3ab602aee47e40d2e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
になります。プロセッサーでしばらくの間、入力データを準備し、しばらくの間、GPUからの応答を待機します。 GPUがアイドル状態にならないように、推論の間隔を最小限に抑えることをお勧めします。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/fdb/783/cd7/fdb783cd70c90fcc06ba2cfca5f9c7f2.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、ビデオカードを使用せずに、強力なプロセッサを使用して、別のストリームを開始したり、画像の準備を他のサーバーに転送したりできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可能であれば、推論を担当するプロセスはそれのみを処理する必要があります。共有メモリにアクセスし、入力データを収集して、すぐにビデオカードのメモリにコピーして推論を実行します。 </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ターボブースト</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ニューラルネットワークの起動は、GPUだけでなくプロセッサのリソースも消費する操作です。</font><font style="vertical-align: inherit;">すべてが帯域幅に関して正しく構成されていて、推論を実行するスレッドがすでに新しいデータを待機している場合でも、弱いプロセッサでは、このストリームを新しいデータで飽和させることはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くのプロセッサがターボブーストテクノロジをサポートしています。</font><font style="vertical-align: inherit;">プロセッサーの周波数を上げることができますが、デフォルトで常に有効になっているとは限りません。</font><font style="vertical-align: inherit;">それをチェックする価値があります。</font><font style="vertical-align: inherit;">これを行うには、LinuxにCPU Powerユーティリティがあります</font></font><code>$ cpupower frequency-info -m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd4/78f/ca4/fd478fca423620ee3bd684d2adfe9d73.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセッサーも電力消費モードで構成されており、このCPU Power：コマンドでそれを認識できます</font></font><code>performance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12a/ed4/a1b/12aed4a1b0dec7240bd744232b5d4770.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
省電力モードでは、プロセッサは周波数を抑制し、実行速度を遅くすることができます。</font><font style="vertical-align: inherit;">BIOSに入り、パフォーマンスモードを選択する価値があります。</font><font style="vertical-align: inherit;">その後、プロセッサは常に最大周波数で動作します。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションの配置</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dockerはアプリケーションのデプロイに最適であり、コンテナ内のGPUでアプリケーションを実行できます。ビデオカードにアクセスするには、最初にホストシステム（物理サーバー）にビデオカードのドライバーをインストールする必要があります。次に、コンテナーを開始するには、多くの手動作業を行う必要があります。適切なパラメーターを使用して、コンテナー内にビデオカードを正しく投入します。コンテナーを起動した後も、コンテナー内にビデオドライバーをインストールする必要があります。そしてその後にのみ、アプリケーションを使用できます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/20a/ae0/cb2/20aae0cb286e3cef415f2a32f4f12bfa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチには注意点が1つあります。サーバーはクラスターから消えて追加できます。サーバーごとにドライバーのバージョンが異なり、コンテナー内にインストールされているバージョンとは異なる場合があります。この場合、単純なDockerは機能しなくなります。アプリケーションは、ビデオカードにアクセスしようとすると、ドライバーバージョンの不一致エラーを受け取ります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bb4/1af/0b2/bb41af0b281cf8a660d2cc35db133101.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これに対処するには？ NVIDIAのDockerのバージョンがあり、コンテナをより簡単に、より楽しく使用できます。 NVIDIA自体と実際の観察によれば、nvidia-dockerを使用するオーバーヘッドコストは約1％です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、ドライバーはホストマシンにのみインストールする必要があります。コンテナを開始するとき、内部に何かを投げる必要はなく、アプリケーションはすぐにビデオカードにアクセスできます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c95/967/a3a/c95967a3a8ac668acaed1fc14550dcb8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドライバーからのnvidia-dockerの「独立性」により、異なるバージョンのドライバーがインストールされている異なるマシンで同じイメージからコンテナーを実行できます。</font><font style="vertical-align: inherit;">これはどのように実装されますか？</font><font style="vertical-align: inherit;">Dockerにはdocker-runtimeと呼ばれる概念があります。それは、コンテナーがホストカーネルと通信する方法、コンテナーが開始および停止する方法、カーネルお​​よびドライバーと対話する方法を記述する一連の標準です。</font><font style="vertical-align: inherit;">Dockerの特定のバージョンから、このランタイムを置き換えることが可能です。</font><font style="vertical-align: inherit;">これはNVIDIAが行ったことです。ランタイムを置き換え、内部のビデオドライバーへの呼び出しをキャッチし、正しいバージョンをビデオドライバーへの呼び出しに変換します。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オーケストレーション</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはオーケストラとしてKubernetesを選びました。</font><font style="vertical-align: inherit;">これは、負荷の高いシステムに役立つ多くの非常に優れた機能をサポートしています。</font><font style="vertical-align: inherit;">たとえば、自動検出により、サービスは複雑なルーティングルールなしでクラスター内で相互にアクセスできます。</font><font style="vertical-align: inherit;">またはフォールトトレランス-Kubernetesが常に複数のコンテナを準備していて、何かが発生した場合、Kubernetesはすぐに新しいコンテナを起動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetesクラスタがすでに構成されている場合は、クラスタ内でビデオカードを使い始めるのにそれほど必要はありません。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比較的新鮮なドライバー</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インストールされたnvidia-dockerバージョン2</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/etc/docker/daemon.jsonのdocker runtimeはデフォルトで `nvidia`に設定されています：</font></font><br>
 <code>"default-runtime": "nvidia"</code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インストールされているプラ​​グイン </font></font><code>kubectl create -f https://githubusercontent.com/k8s-device-plugin/v1.12/plugin.yml</code></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスターを構成し、デバイスプラグインをインストールしたら、ビデオカードをリソースとして指定できます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/414/c90/8f6/414c908f6d3ba6d4a9bded55921790c6.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは何に影響しますか？ 2つのノード、物理マシンがあるとします。一方にはビデオカードがあり、もう一方にはありません。 Kubernetesはビデオカードが搭載されたマシンを検出し、ポッドをピックアップします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetesは、ポッド間でビデオカードを適切に操作する方法を認識していないことに注意することが重要です。 4つのビデオカードがあり、コンテナーを起動するために1つのGPUが必要な場合、クラスターでポッドを4つまで増やすことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原則として、1ポッド= 1モデル= 1 GPUを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4つのビデオカードでより多くのインスタンスを実行するオプションがありますが、このオプションはそのままでは機能しないため、この記事では考慮しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のモデルを同時に回転させる必要がある場合は、モデルごとにKubernetesでDeploymentを作成すると便利です。その構成ファイルでは、モデルの人気を考慮して、各モデルの炉の数を指定できます。モデルが多くのリクエストを受け取った場合、それに応じて、それに応じて多くのポッドを指定する必要があります。リクエストが少ない場合、ポッドは少なくなります。合計すると、ハースの数は、クラスタ内のビデオカードの数と同じになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味深い点を考えてみましょう。 4つのビデオカードと3つのモデルがあるとします。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04c/767/23a/04c76723a17fef7311eb41462db1d5a7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の2つのビデオカードでは、オブジェクトの別の認識と車の番号の別の認識に基づいて、顔認識モデルの推論を高めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたが働いて、クライアントが行き来して、ある日、たとえば夜に、推論オブジェクトを含むビデオカードが単に読み込まれず、ごく少数のリクエストがそれに到着し、顔認識を備えたビデオカードが過負荷になるという状況が発生します。この時点でオブジェクトを含むモデルを作成し、その場所でフェースを起動してラインをアンロードしたいと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオカード上のモデルの自動スケーリングのために、Kubernetes内にツールがあります-水平ハース自動スケーリング（HPA、水平ポッドオートスケーラー）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デフォルトでは、KubernetesはCPU使用率の自動スケーリングをサポートしています。</font><font style="vertical-align: inherit;">ただし、ビデオカードを使用するタスクでは、スケーリングのために各モデルのタスク数に関する情報を使用する方がはるかに合理的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行う：各モデルのリクエストをキューに入れます。</font><font style="vertical-align: inherit;">リクエストが完了すると、このキューから削除されます。</font><font style="vertical-align: inherit;">人気のあるモデルのリクエストを迅速に処理できれば、キューは大きくなりません。</font><font style="vertical-align: inherit;">特定のモデルに対するリクエストの数が突然増加すると、キューが増加し始めます。</font><font style="vertical-align: inherit;">ラインをすくうのに役立つビデオカードを追加する必要があることが明らかになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キュー情報をPrometheusを介してHPAに渡します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/aa3/da3/6ba/aa3da36baec71d52dcd0bee93c8e52cf.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、クラスターへのリクエストの数に応じて、クラスター内のビデオカード上</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">モデルの</font><font style="vertical-align: inherit;">自動スケーリング</font><font style="vertical-align: inherit;">を実行します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CI / CD</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションを囲み、Kubernetesでラップしたら、プロジェクトの上部まであと1ステップです。</font><font style="vertical-align: inherit;">CI / CDを追加できます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3d3/982/b23/3d3982b23d9ff4f1d413cee86c601d8d.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここに</font><font style="vertical-align: inherit;">パイプラインの例を示します。</font><font style="vertical-align: inherit;">ここで、プログラマーがマスターブランチに新しいコードを起動します。その後、バックエンドデーモンを含むDockerイメージが自動的に収集され、テストが実行されます。</font><font style="vertical-align: inherit;">すべてのチェックマークが緑色の場合、アプリケーションはテスト環境に注がれています。</font><font style="vertical-align: inherit;">問題がなければ、問題なく画像を運用することができます。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の記事では、GPUを使用した高負荷サービスの作業のいくつかの側面に触れました。</font><font style="vertical-align: inherit;">次のようなサービスの応答時間を短縮する方法について話しました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待ち時間を短縮するための最適なニューラルネットワークアーキテクチャの選択。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TensorRTなどの最適化フレームワークのアプリケーション。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スループットの向上に関する問題が発生しました：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像のバッチ処理の使用。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">修正レイテンシ戦略を適用して推論の実行数を減らしますが、各推論はより多くの画像を処理します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUダウンタイムを最小限に抑えるためのデータ入力パイプラインの最適化。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセッサの駆け引き、他のサーバーへのCPUバウンド操作の削除による「戦い」。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GPUを使用してアプリケーションをデプロイするプロセスを確認しました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes内でnvidia-dockerを使用する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リクエスト数とHPA（水平ポッドオートスケーラー）に基づくスケーリング。</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja472914/index.html">Wolfram関数リポジトリ：Wolfram言語拡張のためのオープンアクセスプラットフォーム</a></li>
<li><a href="../ja472916/index.html">7月のHabrカンファレンスで最も興味深いのは、バックエンド、機械学習、サーバーレスです。</a></li>
<li><a href="../ja472918/index.html">ロシアとCISのZXスペクトラム：オンラインの追求がオフラインでどのように変化したか</a></li>
<li><a href="../ja472922/index.html">エントロピーよりも強力なディフェンダープログラマー</a></li>
<li><a href="../ja472926/index.html">返品を加速する法則（パート1）</a></li>
<li><a href="../ja472930/index.html">ファッションを定量化するシリコンバレー天体物理学者</a></li>
<li><a href="../ja472932/index.html">IntelliJ IDEA静的分析と人間の心</a></li>
<li><a href="../ja472934/index.html">ゼロトラストとは何ですか？安全モデル</a></li>
<li><a href="../ja472936/index.html">オペレーションTA505：ネットワークインフラストラクチャのグループ化。パート3</a></li>
<li><a href="../ja472940/index.html">詐欺師と人について</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>