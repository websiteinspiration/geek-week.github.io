<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❔ 🚯 👨🏾‍⚕️ 最受欢迎的数据结构 👃🏽 🐳 📧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="什么是数据结构？
 简而言之，数据结构是一个容器，其中数据以特定的布局（格式或在内存中的组织方式）存储。这种“布局”使数据结构在某些操作中有效，而在另一些操作中无效。您的目标是了解数据结构，以便可以选择最适合所讨论问题的数据结构。
 
 为什么我们需要数据结构？
 因为数据结构用于以有组织的方式存储...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>最受欢迎的数据结构</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489494/"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么是数据结构？</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
简而言之，数据结构是一个容器，其中数据以特定的布局（格式或在内存中的组织方式）存储。这种“布局”使数据结构在某些操作中有效，而在另一些操作中无效。您的目标是了解数据结构，以便可以选择最适合所讨论问题的数据结构。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么我们需要数据结构？</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
因为数据结构用于以有组织的方式存储数据，并且由于数据是计算机科学中最重要的元素，所以数据结构的真正价值显而易见。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
无论您解决什么问题，都必须以一种或另一种方式处理数据-无论是员工的工资，股票价格，购物清单还是简单的电话簿。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据不同的方案，数据应以特定格式存储。</font><font style="vertical-align: inherit;">我们有几种数据结构，涵盖了以不同格式存储数据的需求。</font></font><br>
<br>
<a name="habracut"></a><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常用的数据结构</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
让我们首先列出最常用的数据结构，然后逐一查看它们：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组-数组</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆栈-堆栈</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">队列-队列</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接列表-相关列表</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">树木-树木</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图-图</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尝试（它们本质上是树，但是单独命名它们仍然很不错）。</font><font style="vertical-align: inherit;">- 优先</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈希表-哈希表</font></font></li>
</ul><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组-数组</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
数组是最简单，使用最广泛的数据结构。</font><font style="vertical-align: inherit;">其他数据结构（例如堆栈和队列）是从数组派生的。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是包含元素（1、2、3和4）的大小为4的简单数组的图像。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ir/_e/d3/ir_ed3oofkmldyxlz1sibsq5lmo.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个数据项都被分配一个称为索引的正数值，该索引对应于该项在数组中的位置。</font><font style="vertical-align: inherit;">大多数语言将数组的起始索引定义为0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是两种类型的数组：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一维数组（如上所示）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多维数组（数组内部的数组）多维数组</font></font></li>
</ul><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组的基本操作Insert-</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在指定的索引处</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
插入</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元素</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Delete（Delete）-删除在指定索引处的元素</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Size-获取数组中元素的总数</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自学习：</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
1查找数组的第二个最小元素。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.数组中的第一个非重复整数。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.合并两个排序的数组。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4.对数组中的正值和负值重新排序。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆栈</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们都熟悉著名的选项“撤消（取消）”，该选项几乎出现在每个应用程序中。有没有想过这是如何工作的？该机制的本质是将工作的先前状态（受一定数量的限制）保存在内存中，以使最后一个动作首先出现。仅数组不能做到这一点。那就是堆栈派上用场的地方！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
堆栈的一个真实示例是一堆垂直排列的书。要在中间某处放置一本书，您需要删除所有放在其顶部的书。这是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LIFO（后进先出）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法的工作方式</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是包含三个数据元素（1、2和3）的堆栈的图像，其中3在顶部，将首先删除：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/eh/cp/oo/ehcpoocbq_kv4mzmheqmccdwhfy.png"><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆栈的基本操作：</font></font></u><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
推-在其他元素之上插入元素。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
拉（弹出）-从堆栈中移除后返回顶部元素。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
空吗（IsEmpty）-如果堆栈为空，则返回true（true）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顶部（顶部）-返回顶部元素，而不从堆栈中删除。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于独立研究：</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
1.使用堆栈评估后缀表达式。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.在堆栈上对值进行排序。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.检查表达式中的平衡括号。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">队列</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
就像堆栈一样，队列是另一个线性数据结构，其中的项按顺序存储。堆栈和队列之间的唯一显着区别是，Queue使用了一种方法，而不是使用LIFO方法</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FIFO，先进先出的缩写</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个真实的路线示例：许多人在售票处等车。如果有新人到达，他将从头开始而不是从一开始就加入队伍，而站在前面的人将是第一个收到车票的人，因此将离开队伍。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是包含四个数据元素（1、2、3和4）的队列的图像，其中1在顶部，并且将首先被删除：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1x/rs/yr/1xrsyryryhsien5gzdqpwphgbpo.png"><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">队列的基本操作：入队</font></font></u><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
-在队列的末尾插入一个元素。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出队-从队列的开头删除项目。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
空吗（IsEmpty）-如果队列为空，则返回true（true）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顶部（顶部）-返回队列的第一个元素。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于独立学习：</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.使用队列实现堆栈。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.队列的前k个元素相反。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.使用队列生成从1到n的二进制数。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链表</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
链表是另一个重要的线性数据结构，乍一看可能看起来与数组相似，但是在内存分配，内部结构以及基本插入和删除操作的执行方式上有所不同。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
链表就像一个节点链，其中每个节点都包含诸如数据之类的信息，以及指向链中下一个节点的指针。有一个标头指针指向链接列表的第一个元素，如果列表为空，则仅指向零或不指向任何内容。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
链接列表用于实现文件系统，哈希表和邻接列表。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是链表的内部结构的直观表示：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fl/3i/ze/fl3izeslba8w1wzeyg1tnrby7ug.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是链表的类型：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单链接列表（单向）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">双链表（双向）</font></font></li>
</ul><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链表的基本操作</font></font></u><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
InsertAtEnd- </font><u><font style="vertical-align: inherit;">在链表的</font></u><font style="vertical-align: inherit;">末尾插入一个项目。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
InsertB Start（InsertAtHead）-在链接列表的开头插入一个项目。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
删除-从链接列表中删除该项目。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DeleteBeginning（DeleteAtHead）-删除链接列表的第一个元素。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
搜索-从链接列表中返回找到的项目。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
空吗（IsEmpty）-如果链接列表为空，则返回true（true）。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于独立学习：</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
1.翻转链接列表（反向，反向，向后显示）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.在链表中定义一个循环。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.从链接列表的末尾返回第N个节点。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4.从链接列表中删除重复项。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
图是以网络形式相互连接的节点的集合。</font><font style="vertical-align: inherit;">节点也称为顶点。</font><font style="vertical-align: inherit;">该对（x，y）称为边，它表示顶点x与顶点y连接。</font><font style="vertical-align: inherit;">一条边可以包含重量/成本，显示从顶部x移到y所需的成本。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6h/nw/g-/6hnwg-sgikrn3gmftsuwnfklkcs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
图形类型：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无向图</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有向图</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在编程语言中，图形以两种形式表示：</font></font><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">邻接矩阵</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">邻接表</font></font></a></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是连续的邻接表（无向图）的示例。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wp/xw/gx/wpxwgxkis9lmoatkcsskhjfn9eq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
沿图移动算法的已知示例：</font></font><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">广度优先搜索</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">深度优先搜索</font></font></a></li>
</ul><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于独立研究：</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
1.广度和深度的实现首次搜索</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.检查图是否为树。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.计算图中的边数。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4.查找峰之间的最短路径。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">树</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
树是由顶点（节点）和连接它们的边组成的分层数据结构。</font><font style="vertical-align: inherit;">树看起来像图，但是将树与图区分开的关键是树中不​​能存在循环。</font><font style="vertical-align: inherit;">树是一幅残缺的图。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
树广泛用于人工智能和复杂算法中，为问题解决算法提供了有效的存储机制。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一棵简单树的图像，以及树数据结构中使用的基本术语：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/w4/ic/iv/w4icivyghqug8j9nxyer2xuvwxi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有树类型：</font></font><br>
<br>
<ul>
<li>N- </li>
<li>  (Balanced Tree)</li>
<li>  (Binary Tree)</li>
<li>   (Binary Search Tree)</li>
<li>AVL </li>
<li>-  (Red Black Tree)</li>
<li>2–3 </li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
综上所述，二叉树和二叉搜索树是最常用的树。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于独立研究：</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
1.找到二叉树的高度。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.在二进制搜索树中找到第k个最大值。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.在距根“ k”的距离处找到节点。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4.在二叉树中找到给定节点的祖先。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际示例：</font></font></u><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
1. Facebook：当两个顶点之间有边时，每个用户都是一个顶点，两个人是朋友。推荐给朋友的建议也是基于图论计算的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Google Maps：不同的位置由峰表示，道路由边表示，图论用于查找两个峰之间的最短路径。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.交通网络：山峰是道路与肋骨的交汇处-这些是交汇处之间的路段。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4.表示分子结构，其中顶点是分子，而边缘是分子之间的键。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图形中的离散信令过程。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和有一个很好的文章在这里也</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个在同一时间</font><font style="vertical-align: inherit;">）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6.经验观察表明，大多数基因受少数其他基因（通常少于十个）的调控。因此，可以将遗传网络视为稀疏图，即其中一个节点连接到其他几个节点的图。如果有向（无环）图或无向图被概率饱和，则结果分别是概率导向的图形模型和概率无向图形模型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mayer集群</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">波动性</font></a><font style="vertical-align: inherit;">函数</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">展开的理论</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">热力学中的气体（Z）需要计算两个，三个，四个条件，依此类推。有一种系统的方法可以与图表组合执行此操作，这有助于找出图表之间的连接方式。当您想要总结这些图的子集时，了解图论会很有用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8.贴图着色：著名的四色定理指出，您始终可以正确地对贴图区域进行着色，这样就不会使用不超过四种不同的颜色为两个相邻区域分配相同的颜色。在此模型中，带有颜色的区域是节点，而相邻区域是图的边缘。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9.拥有三座小屋的任务是众所周知的数学难题。它可以表述为：飞机（或球体）上的三个小屋，每个小屋必须与天然气，水和电力公司连接。使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平面图</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以解决该问题</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10.搜索图的中心：对于每个顶点，找到到最远顶点的最短路径的长度。图的中心是该值最小的顶点。这对于定居点的建筑规划很重要，在定居点中应将医院，消防部门或警察局设置在最远的地方。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于像我这样的C＃爱好者，</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">这里</font></a><font style="vertical-align: inherit;">有C＃图形代码示例的链接</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。对于最高级的库，可在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处使用</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C ++实现图形</font><font style="vertical-align: inherit;">。对于AI和天网的爱好者，请</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">脚</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">序列（Trie）</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
序列，也称为带前缀的树（Prefix Trees），是一种树状数据结构，足以解决与字符串相关的问题。它们提供快速搜索，主要用于在字典中搜索单词，在搜索引擎中搜索自动句子，甚至用于IP路由。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是“ top”，“ thus”和“ their”这三个词如何按优先级存储的说明：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/11/os/cj/11oscjph-dhzoqncmzbq6dxb1mo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
单词从上到下存储，其中绿色节点“ p”，“ s”和“ r”指向“ top”，“因此，分别是“和”。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于独立学习：</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.计算优先级中的单词总数。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.打印存储在优先级中的所有单词。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.使用优先级对数组元素进行排序。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4.使用队列从字典中生成单词。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5.创建T9词典。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际的使用示例：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.输入单词时从字典中选择或完成。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.在电话或电话词典中搜索联系人。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈希表</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
散列是用于唯一标识对象并通过一些预先计算的唯一索引（称为“键”）存储每个对象的过程。</font><font style="vertical-align: inherit;">因此，对象以键值对的形式存储，此类元素的集合称为字典。</font><font style="vertical-align: inherit;">可以使用此键找到每个对象。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有不同的基于哈希的数据结构，但是哈希表是最常用的数据结构。</font><font style="vertical-align: inherit;">当需要使用键访问元素时，可以使用哈希表，并且可以确定键的有用值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
哈希表通常使用数组来实现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
哈希数据结构的性能取决于以下三个因素：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈希函数</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈希表大小</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">碰撞处理方法</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是散列如何显示在数组中的说明。</font><font style="vertical-align: inherit;">使用哈希函数计算该数组的索引。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/r4/jk/qj/r4jkqjrkjobsio3r3eq02ebxstw.png"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于独立研究：</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
1.在阵列中找到对称对。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.遵循完整的行驶路径。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.查找该数组是否是另一个数组的子集。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4.检查给定的数组是否不相交。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是.Net中的哈希表使用示例代码</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span><font></font>
        {<font></font>
            Hashtable ht = <span class="hljs-keyword">new</span> Hashtable<font></font>
            {<font></font>
                { <span class="hljs-string">"001"</span>, <span class="hljs-string">"Zara Ali"</span> },<font></font>
                { <span class="hljs-string">"002"</span>, <span class="hljs-string">"Abida Rehman"</span> },<font></font>
                { <span class="hljs-string">"003"</span>, <span class="hljs-string">"Joe Holzner"</span> },<font></font>
                { <span class="hljs-string">"004"</span>, <span class="hljs-string">"Mausam Benazir Nur"</span> },<font></font>
                { <span class="hljs-string">"005"</span>, <span class="hljs-string">"M. Amlan"</span> },<font></font>
                { <span class="hljs-string">"006"</span>, <span class="hljs-string">"M. Arif"</span> },<font></font>
                { <span class="hljs-string">"007"</span>, <span class="hljs-string">"Ritesh Saikia"</span> }<font></font>
            };<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (ht.ContainsValue(<span class="hljs-string">"Nuha Ali"</span>))<font></font>
            {<font></font>
                Console.WriteLine(<span class="hljs-string">"    !"</span>);<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span><font></font>
            {<font></font>
                ht.Add(<span class="hljs-string">"008"</span>, <span class="hljs-string">"Nuha Ali"</span>);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-comment">//   .</span><font></font>
            ICollection key = ht.Keys;<font></font>
<font></font>
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">string</span> k <span class="hljs-keyword">in</span> key)<font></font>
            {<font></font>
                Console.WriteLine(k + <span class="hljs-string">": "</span> + ht[k]);<font></font>
            }<font></font>
            Console.ReadKey();<font></font>
        }<font></font>
</code></pre><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际示例：</font></font></u><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
1.游戏“生活”。在其中，哈希是每个活细胞的一组坐标。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Google搜索引擎的原始版本可以将所有现有单词映射到出现它们的一组URL中。在这种情况下，哈希表使用了两次：第一次将单词映射到URL集，第二次保存每个URL集。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.在实现多路树结构/算法时，哈希表可用于快速访问内部节点的任何子元素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4.编写用于下棋的程序时，跟踪先前评估过的位置非常重要，这样您可以在需要时再次回来。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5.任何编程语言都需要将变量名映射到其在内存中的地址。</font><font style="vertical-align: inherit;">实际上，在像Javascript和Perl这样的脚本语言中，字段可以动态地添加到对象中，这意味着对象本身就像哈希映射一样。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN489482/index.html">如果要从汇编程序调用Go函数，需要知道什么</a></li>
<li><a href="../zh-CN489486/index.html">我们将数据科学用于购房的和平目的</a></li>
<li><a href="../zh-CN489488/index.html">适用于开发人员的DevOps（或反对他们？！）</a></li>
<li><a href="../zh-CN489490/index.html">井字游戏（PixiJS）</a></li>
<li><a href="../zh-CN489492/index.html">Яндекс.Диск запретил использование open source утилиты rclone. UPD — снова работает</a></li>
<li><a href="../zh-CN489496/index.html">寻找员工和寻找工作：我从内部到外部的观点</a></li>
<li><a href="../zh-CN489500/index.html">在故事点评估任务</a></li>
<li><a href="../zh-CN489502/index.html">Selenium + AutoIT。Windows测试自动化Windows</a></li>
<li><a href="../zh-CN489504/index.html">如何在UE4中开始创建地图</a></li>
<li><a href="../zh-CN489510/index.html">试图解决假期2号票之前的选择问题</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>