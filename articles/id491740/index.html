<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŸï¸ ğŸ‘©â€ğŸ‘©â€ğŸ‘¦ ğŸ’¶ Internet of Things di Yandex.Cloud: Bagaimana Layanan Yandex IoT Core dan Yandex Cloud Functions Diatur ğŸŒº â™ ï¸ ğŸ—ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada Oktober tahun lalu, konferensi awan Yandex Yandex Scale pertama diadakan. Ia mengumumkan peluncuran banyak layanan baru, termasuk Yandex IoT Core...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Internet of Things di Yandex.Cloud: Bagaimana Layanan Yandex IoT Core dan Yandex Cloud Functions Diatur</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/491740/"><img src="https://habrastorage.org/webt/wf/_u/zo/wf_uzobkj9vxp2ddkzxzux7lhbo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada Oktober tahun lalu, konferensi awan Yandex Yandex Scale pertama diadakan. Ia mengumumkan peluncuran banyak layanan baru, termasuk Yandex IoT Core, yang memungkinkan Anda untuk bertukar data dengan jutaan perangkat IoT. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam artikel ini, saya akan berbicara tentang mengapa Yandex IoT Core diperlukan dan cara kerjanya, serta bagaimana ia dapat berinteraksi dengan layanan Yandex.Cloud lainnya. Anda akan belajar tentang arsitektur, seluk-beluk interaksi komponen dan fitur penerapan fungsi - semua ini akan membantu Anda mengoptimalkan penggunaan layanan ini.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, mari kita ingat keunggulan utama cloud publik dan PaaS - mengurangi waktu dan biaya pengembangan, serta biaya dukungan dan infrastruktur, yang juga relevan untuk proyek IoT. Tetapi ada beberapa fitur berguna yang kurang jelas yang bisa Anda dapatkan di cloud. Penskalaan dan toleransi kesalahan yang efektif ini merupakan aspek penting ketika bekerja dengan perangkat, terutama dalam proyek-proyek untuk infrastruktur informasi penting. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penskalaan efektif adalah kemampuan untuk secara bebas menambah atau mengurangi jumlah perangkat tanpa mengalami masalah teknis dan melihat perubahan yang dapat diprediksi dalam biaya sistem setelah perubahan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toleransi kesalahan adalah kepercayaan bahwa layanan dirancang dan digunakan sedemikian rupa untuk memastikan kinerja setinggi mungkin bahkan dalam hal terjadi kegagalan beberapa sumber daya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita masuk ke detailnya.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arsitektur Script IoT</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, mari kita lihat seperti apa keseluruhan arsitektur skrip IoT. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z_/po/yk/z_poykwjdwprirjgwkxmkvjnq0o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dua bagian besar dapat dibedakan di dalamnya:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang pertama adalah pengiriman data ke penyimpanan dan pengiriman perintah ke perangkat. </font><font style="vertical-align: inherit;">Ketika Anda membangun sistem IoT, tugas ini harus diselesaikan dalam hal apa pun, apa pun proyek yang Anda lakukan.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang kedua bekerja dengan data yang diterima. </font><font style="vertical-align: inherit;">Semuanya mirip dengan proyek lain berdasarkan analisis dan visualisasi set data. </font><font style="vertical-align: inherit;">Anda memiliki repositori dengan larik informasi awal, yang dapat digunakan untuk mewujudkan tugas Anda.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagian pertama kira-kira sama di semua sistem IoT: ia dibangun berdasarkan prinsip umum dan cocok dengan skenario umum yang cocok untuk sebagian besar sistem IoT. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagian kedua hampir selalu unik dalam hal fungsi yang dilakukan, meskipun dibangun pada komponen standar. Pada saat yang sama, tanpa sistem yang berkualitas tinggi, toleran terhadap kesalahan, dan dapat diskalakan untuk berinteraksi dengan perangkat keras, efektivitas bagian analitis arsitektur berkurang hingga hampir nol, karena tidak ada yang perlu dianalisis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itulah sebabnya tim Yandex.Cloud pertama-tama memutuskan untuk berkonsentrasi membangun ekosistem layanan yang nyaman yang akan dengan cepat, efisien dan andal mengirimkan data dari perangkat ke penyimpanan, dan sebaliknya - mengirim perintah ke perangkat.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tq/k8/ug/tqk8ugcmjnp3-s3cscc4ldhmuou.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengatasi masalah ini, kami sedang mengerjakan fungsionalitas dan integrasi Yandex IoT Core, Fungsi Yandex, dan layanan penyimpanan data di Cloud: </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Layanan Yandex IoT Core adalah broker MQTT scalable gagal-aman multi-penyewa dengan serangkaian fungsi berguna tambahan.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Layanan Yandex Cloud Functions adalah perwakilan dari arah tanpa server yang menjanjikan dan memungkinkan Anda untuk menjalankan kode Anda sebagai fungsi dalam lingkungan yang aman, toleran terhadap kesalahan, dan secara otomatis dapat diskalakan tanpa membuat dan memelihara mesin virtual.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penyimpanan Objek Yandex adalah penyimpanan efektif array data yang besar dan sangat cocok untuk catatan arsip "historis".</font></font></li>
<li>          ,    ,      Yandex Managed Service for ClickHouse,     Â«Â»  .       Â«Â»      ,       ,     ,             .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika layanan penyimpanan dan analisis data adalah layanan "tujuan umum" yang telah banyak ditulis, maka Yandex IoT Core dan interaksinya dengan Fungsi Yandex Cloud biasanya menimbulkan banyak pertanyaan, terutama bagi orang-orang yang baru mulai memahami Internet benda dan teknologi cloud. </font><font style="vertical-align: inherit;">Dan karena layanan ini memberikan toleransi kesalahan dan penskalaan pekerjaan dengan perangkat, pertama-tama kita akan melihat apa yang mereka miliki di bawah tenda.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana Yandex IoT Core bekerja</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex IoT Core adalah layanan platform khusus untuk pertukaran data dua arah antara cloud dan perangkat yang menjalankan protokol MQTT. Bahkan, protokol ini telah menjadi standar untuk mentransfer data ke IoT. Ini menggunakan konsep antrian bernama (topik), di mana, di satu sisi, Anda dapat menulis data, dan di sisi lain, menerimanya secara tidak sinkron dengan berlangganan acara antrian ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Layanan Yandex IoT Core adalah multi-tenant, yang berarti satu entitas tunggal yang dapat diakses oleh semua pengguna. Artinya, semua perangkat dan semua pengguna berinteraksi dengan instance layanan yang sama.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal ini memungkinkan, di satu sisi, untuk memastikan keseragaman pekerjaan untuk semua pengguna, di sisi lain, penskalaan dan toleransi kesalahan yang efektif, untuk menjaga koneksi dengan jumlah perangkat yang tidak terbatas dan memproses data dalam jumlah yang tidak terbatas baik dalam volume maupun kecepatan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oleh karena itu, layanan harus memiliki mekanisme redundansi dan kemampuan untuk secara fleksibel mengelola sumber daya yang digunakan - untuk menanggapi perubahan beban. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, multi-tenancy membutuhkan logika khusus untuk berbagi hak akses ke topik MQTT. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat bagaimana ini diterapkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti banyak layanan Yandex.Cloud lainnya, Yandex IoT Core secara logis dibagi menjadi dua bagian - Control Plane dan Data Plane:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8a/u0/f3/8au0f3pzmwa1v-hhsxikvo_l_0m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Data Plane bertanggung jawab atas logika operasi di bawah protokol MQTT, dan Control Plane bertanggung jawab untuk membatasi hak akses ke topik tertentu dan menggunakan entitas logis Registry and Device untuk ini. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eu/b1/1n/eub11nm0nlmhprrhfqzohfwcyow.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap pengguna Yandex.Cloud dapat memiliki beberapa pendaftar, yang masing-masing dapat berisi subset perangkatnya sendiri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akses ke topik disediakan sebagai berikut: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/df/wc/hd/dfwchdy-bdwxs56mkgykrcs0ia4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perangkat hanya dapat mengirim data ke topik acara dan topik acara registri:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/events<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/events</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dan berlangganan pesan hanya dari topik perintah Anda dan topik perintah registri:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/commands<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/commands</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Registri dapat mengirim data ke semua topik perintah perangkat dan ke topik perintah registri:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/commands<font></font>
$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device2</span> <span class="hljs-attr">ID</span>&gt;</span>/commands<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/commands</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dan berlangganan pesan dari semua topik acara perangkat dan topik acara registri:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/events<font></font>
$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device2</span> <span class="hljs-attr">ID</span>&gt;</span>/events<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/events</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk bekerja dengan semua entitas yang dijelaskan di atas, Data Plane memiliki protokol gRPC dan protokol REST, berdasarkan akses yang diimplementasikan melalui konsol GUI Yandex.Cloud dan antarmuka baris perintah CLI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adapun Data Plane, mendukung protokol MQTT versi 3.1.1. </font><font style="vertical-align: inherit;">Namun, ada beberapa fitur:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat menghubungkan, pastikan untuk menggunakan TLS.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hanya koneksi TCP yang didukung. </font><font style="vertical-align: inherit;">WebSocket belum tersedia.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otorisasi tersedia baik melalui login dan kata sandi (di mana login adalah perangkat atau ID registri, dan kata sandi ditetapkan oleh pengguna), dan menggunakan sertifikat.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bendera Pertahankan tidak didukung, saat menggunakan mana broker MQTT menyimpan pesan yang ditandai dengan bendera tersebut dan mengirimkannya saat berikutnya Anda berlangganan topik tersebut.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Persistent Session tidak didukung, di mana broker MQTT menyimpan informasi tentang klien (perangkat atau registri) untuk memfasilitasi koneksi ulang.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan berlangganan dan menerbitkan, hanya dua tingkat layanan pertama yang didukung:</font></font><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QoS0 - Paling banyak sekali. </font><font style="vertical-align: inherit;">Tidak ada jaminan pengiriman, tetapi tidak ada pengiriman ulang dari pesan yang sama.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QoS1 - Setidaknya satu kali. </font><font style="vertical-align: inherit;">Pengiriman dijamin, tetapi ada kemungkinan menerima kembali pesan yang sama.</font></font></li>
</ol></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menyederhanakan koneksi ke Yandex IoT Core, kami secara teratur menambahkan contoh baru untuk berbagai platform dan bahasa ke repositori kami di GitHub, dan juga menjelaskan skrip dalam dokumentasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arsitektur layanan terlihat seperti ini: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6g/ig/4o/6gig4ofj7dksmbn18wvq5swkpuo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Logika bisnis dari layanan mencakup empat bagian:</font></font><br>
<br>
<ol>
<li> Device management â€”     .   Control Plane.</li>
<li> MQTT Broker â€”  MQTT-.  Data Plane.</li>
<li> Triggers â€”     Yandex Cloud Functions.  Data Plane.</li>
<li> Shards â€”      MQTT-    .  Data Plane.</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua interaksi dengan "dunia luar" melewati load balancers. Selain itu, sesuai dengan filosofi dogfooding, Yandex Load Balancer digunakan, yang tersedia untuk semua pengguna Yandex.Cloud. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap bagian dari logika bisnis terdiri dari beberapa set tiga mesin virtual - satu di setiap zona ketersediaan (dalam Skema A, B, dan C). Mesin virtual persis sama dengan semua pengguna Yandex.Cloud. Ketika beban meningkat, penskalaan terjadi dengan bantuan seluruh rangkaian - tiga mesin ditambahkan sekaligus dalam kerangka satu bagian dari logika bisnis. Ini berarti bahwa jika satu set tiga mesin Broker MQTT tidak mengatasi beban, maka seperangkat tiga mesin Broker MQTT ditambahkan, sedangkan konfigurasi bagian lain dari logika bisnis tetap sama.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan hanya Logbroker yang tidak tersedia untuk umum. Ini adalah layanan untuk operasi gagal-aman yang efisien dengan aliran data. Ini didasarkan pada Apache Kafka, tetapi memiliki banyak fungsi berguna lainnya: ia mengimplementasikan proses pemulihan bencana (termasuk semantik sekali ketika Anda memiliki jaminan pengiriman pesan tanpa duplikasi) dan proses layanan (seperti replikasi lintas-pusat, distribusi data ke cluster perhitungan), dan juga memiliki mekanisme untuk distribusi data non-duplikat yang seragam antara pelanggan aliran - semacam penyeimbang beban. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fitur manajemen perangkat di Control Plane dijelaskan di atas. Tetapi dengan Data Plane, semuanya jauh lebih menarik.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap instance MQTT Broker bekerja secara independen dan tidak tahu apa-apa tentang instance lain. Semua data yang diterima (dipublikasikan dari pelanggan) dikirim oleh broker ke Logbroker, dari mana mereka diambil oleh Shards dan Pemicu. Dan di dalam pecahan itulah sinkronisasi terjadi di antara beberapa broker. Shards tahu tentang semua klien MQTT dan distribusi langganan mereka (berlangganan) di seluruh contoh broker MQTT dan menentukan ke mana harus mengirim data yang diterima. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, klien MQTT A berlangganan ke topik dari broker A, dan klien MQTT B berlangganan ke topik yang sama dari broker B. Jika klien MQTT C mempublikasikan topik yang sama, tetapi ke broker C, maka shard mentransfer data dari broker C ke broker A dan B, sebagai akibatnya data akan diterima oleh klien MQTT A dan klien MQTT B.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ia/dv/dz/iadvdzgd2cs6o1r3stjkqfhsq6y.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagian terakhir dari logika bisnis, Pemicu, juga menerima semua data yang diterima dari klien MQTT dan, jika ini dikonfigurasikan oleh pengguna, transfer ke pemicu layanan Fungsi Cloud Yandex. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, Yandex IoT Core memiliki arsitektur dan logika kerja yang agak rumit, yang sulit untuk diulang pada instalasi lokal. </font><font style="vertical-align: inherit;">Hal ini memungkinkannya untuk menahan kehilangan bahkan dua dari tiga zona ketersediaan, dan bekerja dalam jumlah koneksi yang tidak terbatas dan volume data yang tidak terbatas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terlebih lagi, semua logika ini disembunyikan dari pengguna â€œunder the hoodâ€, tetapi dari luar semuanya terlihat sangat sederhana - seolah-olah Anda bekerja dengan satu broker MQTT.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi Pemicu dan Cloud Yandex</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex Cloud Functions adalah perwakilan dari apa yang disebut layanan "serverless" (serverless) di Yandex.Cloud. Esensi utama dari layanan tersebut adalah bahwa pengguna tidak menghabiskan waktunya untuk mengatur, menyebarkan, dan meningkatkan skala lingkungan untuk mengeksekusi kode, tetapi hanya berurusan dengan hal yang paling berharga baginya - menulis kode itu sendiri yang melakukan tugas yang diperlukan. Dalam hal fungsi, ini disebut kode statik atom yang dapat dipicu oleh beberapa peristiwa. "Atomic" dan "stateless" berarti bahwa kode ini harus melakukan beberapa tugas yang relatif kecil tetapi tidak terpisahkan, sementara kode tersebut tidak boleh menggunakan variabel apa pun untuk menyimpan nilai di antara panggilan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada beberapa cara untuk memanggil fungsi: panggilan HTTP langsung, panggilan waktu (cron), atau langganan acara. Sebagai yang terakhir, layanan sudah mendukung berlangganan antrian pesan (Antrian Pesan Yandex), peristiwa yang dihasilkan oleh layanan Penyimpanan Objek, dan (paling berharga untuk skenario IoT) berlangganan pesan di Yandex IoT Core.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terlepas dari kenyataan bahwa Anda dapat bekerja dengan Yandex IoT Core menggunakan klien yang kompatibel dengan MQTT, Yandex Cloud Functions adalah salah satu cara paling optimal dan nyaman untuk menerima dan memproses data. Alasannya sangat sederhana. Suatu fungsi dapat dipanggil pada setiap pesan yang masuk dari perangkat apa pun, dan fungsi tersebut akan dieksekusi secara paralel satu sama lain (karena pendekatan atomitas dan stateless), dan jumlah panggilan mereka secara alami akan berubah karena jumlah pesan yang masuk dari perangkat berubah. Dengan demikian, pengguna dapat sepenuhnya mengabaikan masalah pengaturan infrastruktur dan, lebih lanjut, tidak seperti mesin virtual yang sama, pembayaran hanya akan terjadi untuk pekerjaan yang sebenarnya dilakukan.Ini akan memungkinkan Anda untuk menghemat secara signifikan pada beban rendah dan mendapatkan biaya yang jelas dan dapat diprediksi dengan pertumbuhan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mekanisme untuk memanggil fungsi pada acara (berlangganan acara) disebut pemicu (Pemicu). Esensinya digambarkan dalam diagram: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5u/yv/bn/5uyvbnyviueygxt4ykzdh9n2nug.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Layanan yang menghasilkan acara untuk fungsi panggilan menempatkan mereka dalam antrian di Logbroker. Dalam kasus Yandex IoT Core, Pemicu dari Data Plane melakukan ini. Selanjutnya, peristiwa ini diambil oleh preprocessor, yang mencari catatan dalam database untuk acara ini yang menunjukkan fungsi yang akan dipanggil. Jika entri seperti itu ditemukan, preprocessor meletakkan informasi tentang panggilan fungsi (ID fungsi dan parameter panggilan) dalam antrian dalam layanan Antrian Pesan Yandex, dari mana pawang panggilan mengambilnya. Pawang, pada gilirannya, mengirimkan permintaan HTTP untuk memanggil fungsi ke layanan Fungsi Yandex Cloud.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada saat yang sama, sekali lagi, sesuai dengan filosofi dogfooding, layanan Antrian Pesan Yandex, dapat diakses oleh semua pengguna, digunakan, dan fungsi-fungsinya dipanggil dengan cara yang persis sama dengan pengguna lain yang dapat memanggil fungsi mereka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Katakanlah beberapa kata tentang Antrian Pesan Yandex. Terlepas dari kenyataan bahwa ini, seperti Logbroker, adalah layanan antrian, ada satu perbedaan signifikan di antara mereka. Saat memproses pesan dari antrian, pawang menginformasikan antrian yang telah selesai dan pesan tersebut dapat dihapus. Ini adalah mekanisme keandalan penting dalam layanan seperti itu, tetapi mempersulit logika bekerja dengan pesan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antrian Pesan Yandex memungkinkan Anda untuk "memparalelkan" pemrosesan setiap pesan dalam antrian. Dengan kata lain, pesan dari antrian yang sedang diproses tidak memblokir kemungkinan "utas" lain untuk mengambil acara berikutnya dari antrian untuk diproses. Ini disebut konkurensi tingkat pesan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan LogBroker beroperasi pada grup pesan, dan hingga seluruh grup diproses, grup berikutnya tidak dapat diambil untuk diproses. Pendekatan ini disebut concurrency di tingkat partisi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan justru penggunaan Antrian Pesan Yandex yang memungkinkan Anda memproses dengan cepat dan efisien secara paralel banyak permintaan untuk memanggil fungsi untuk acara dari layanan tertentu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terlepas dari kenyataan bahwa pemicu adalah unit independen yang terpisah, mereka merupakan bagian dari layanan Fungsi Yandex Cloud. Kami hanya harus mencari tahu persis bagaimana fungsi dipanggil.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fb/ew/ke/fbewkedbrp6eyri7zkubwiu6dzu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua permintaan untuk memanggil fungsi (baik eksternal maupun internal) masuk ke load balancer, yang mendistribusikannya ke router di zona akses berbeda (AZ), beberapa bagian dikerahkan di setiap zona. Setelah menerima permintaan, router pertama-tama pergi ke layanan Identity and Access manager (IAM) untuk memastikan bahwa sumber permintaan memiliki hak untuk memanggil fungsi ini. Dia kemudian beralih ke penjadwal dan meminta pekerja mana yang menjalankan fungsi. Worker adalah mesin virtual dengan runtime yang disesuaikan dari fungsi yang terisolasi. Lebih lanjut, router, setelah menerima dari penjadwal alamat pekerja yang akan menjalankan fungsi, mengirimkan perintah kepada pekerja ini untuk memulai fungsi dengan parameter tertentu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dari mana asal pekerja? Di sinilah semua keajaiban tanpa server terjadi. Penjadwal, menganalisis beban (jumlah dan durasi fungsi), mengelola (memulai dan menghentikan) mesin virtual dengan runtime tertentu. NodeJS dan Python sekarang didukung. Dan di sini satu parameter sangat penting - kecepatan fungsi peluncuran. Tim pengembangan layanan telah melakukan pekerjaan dengan baik, dan sekarang mesin virtual dimulai dalam maksimum 250 ms, sambil menggunakan lingkungan yang paling aman untuk mengisolasi fungsi satu sama lain - virtualisasi QEMU, yang menjalankan semua Yandex. Pada saat yang sama, jika sudah ada pekerja yang bekerja untuk permintaan yang masuk, fungsi dimulai hampir secara instan.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan, sesuai dengan pendekatan dogfooding yang sama, Load Balancer menggunakan layanan publik yang dapat diakses oleh semua pengguna, dan pekerja, penjadwal dan router adalah mesin virtual biasa, sama seperti semua pengguna. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, toleransi kesalahan layanan diimplementasikan pada tingkat penyeimbang beban dan redundansi komponen sistem utama (router dan penjadwal), dan penskalaan terjadi karena penyebaran atau pengurangan jumlah pekerja. </font><font style="vertical-align: inherit;">Selain itu, setiap zona aksesibilitas bekerja secara independen, yang memungkinkan untuk selamat dari kehilangan bahkan dua dari tiga zona.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tautan yang bermanfaat</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai kesimpulan, saya ingin memberikan beberapa tautan yang memungkinkan Anda mempelajari layanan secara lebih rinci:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex IoT Core: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloud.yandex.ru/services/iot-core</font></font></a> </li>
<li> Yandex Cloud Functions: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cloud.yandex.ru/services/functions</a> </li>
<li> Yandex Message Queue: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cloud.yandex.ru/services/message-queue</a> </li>
<li> Yandex Managed Service for ClickHouse: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cloud.yandex.ru/services/managed-clickhouse</a> </li>
<li> Yandex Load Balancer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cloud.yandex.ru/services/load-balancer</a> </li>
<li> Yandex Object Storage: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cloud.yandex.ru/services/storage</a> </li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id491724/index.html">Buku "Laravel. Panduan lengkap. Edisi ke-2</a></li>
<li><a href="../id491726/index.html">Luaskan kolom bersarang - daftar menggunakan bahasa R (paket tidyr dan fungsi keluarga yang tidak patut)</a></li>
<li><a href="../id491728/index.html">Prinsip KERING dengan Laravel</a></li>
<li><a href="../id491732/index.html">Apakah ada kehidupan setelah Scratch, atau bagaimana memperkenalkan anak ke Python</a></li>
<li><a href="../id491736/index.html">TMS1000: mikrokontroler pertama yang tersedia secara komersial</a></li>
<li><a href="../id491742/index.html">Sherbet: keyboard gaming yang ergonomis</a></li>
<li><a href="../id491744/index.html">Peretas Iran mengeksploitasi kerentanan dalam VPN</a></li>
<li><a href="../id491746/index.html">Sejarah sintesis wicara: era solusi listrik</a></li>
<li><a href="../id491748/index.html">Teknologi yang membantu orang buta belajar bahasa Inggris</a></li>
<li><a href="../id491750/index.html">Kami menulis pencarian substring lebih baik daripada di buku teks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>