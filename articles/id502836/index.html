<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë®‚Äçüëß‚Äçüë¶ ‚ñ∂Ô∏è üî¥ Unity Editor Adventures: Serialized Matryoshka üë®üèæ‚Äç‚öñÔ∏è ‚ôâÔ∏è üòí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengantar singkat
 Sebagai aturan, untuk sampai ke bidang properti serial yang menarik minat kami, terapi manual menyarankan kami untuk menggunakan me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Unity Editor Adventures: Serialized Matryoshka</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502836/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengantar singkat</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai aturan, untuk sampai ke bidang properti serial yang menarik minat kami, terapi manual menyarankan kami untuk menggunakan metode FindPropertyRelative (), di mana nama variabel dilemparkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk alasan tertentu, pendekatan ini tidak selalu nyaman. Alasannya bisa sangat beragam. Misalnya, nama variabel dapat berubah, kita perlu akses mimisan ke properti non-serial, kita perlu memiliki akses ke pengambil setter atau bahkan metode objek serial. Kami tidak akan menanyakan pertanyaan ‚Äúmengapa Anda membutuhkan ini sama sekali‚Äù dan ‚Äúmengapa Anda tidak dapat melakukannya tanpa cara tradisional‚Äù. Misalkan kita perlu - dan hanya itu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, mari kita cari tahu cara mendapatkan objek yang sedang kita kerjakan, serta semua objek induknya dari properti berseri, dan tidak terjebak di jalan serialisasi yang penuh jebakan. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatian. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel ini menyiratkan bahwa Anda sudah tahu cara bekerja dengan UnityEditor, setidaknya sekali menulis PropertyDrawers kustom, dan setidaknya secara umum memahami bagaimana properti berseragam berbeda dari objek berseri.</font></font><br>
<br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jalur serialisasi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memulainya, letakkan semua titik di atas O. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus yang paling primitif, kami memiliki kelas pewaris tertentu dari MonoBehaviour, dan memiliki bidang tertentu yang termasuk dalam kelas serial, jelas bukan pewaris dari sapi kesatuan suci A.K.A. </font><font style="vertical-align: inherit;">UnityEngine.Object.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExamplePulsar</span> : <span class="hljs-title">MonoBehaviour</span><font></font>
{<font></font>
...<font></font>
        [<span class="hljs-meta">Space</span>][Header(<span class="hljs-string">"Example Sandbox Inspector Field"</span>)]
        <span class="hljs-keyword">public</span> SandboxField sandboxField;<font></font>
...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kode di atas, SandboxField adalah kelas dengan atribut Serializable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mendapatkan akses ke MonoBehaviour pemilik bukan masalah:</font></font><br>
<br>
<pre><code class="cs hljs">UnityEngine.Object serializationRoot = property.serializedObject.targetObject;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika mau, Anda dapat menerimanya sebagai, tetapi sekarang kami tidak membutuhkannya. </font><font style="vertical-align: inherit;">Kami tertarik pada bidang serial itu sendiri untuk menggambarnya dengan semua blackjack seperti pada gambar di bawah ini.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/-w/3n/th/-w3nthkn0gmcdeuvpqlw2zctxhy.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita dapat mengambil jalur serialisasi sebagai berikut:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">string</span> serializationPath = property.propertyPath;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus kami, jalur serialisasi akan terdiri dari salah satu bidang kami dan akan mengembalikan "sandboxField", yang darinya kami tidak kedinginan atau panas, karena untuk tingkat pertama peneluran, kami hanya perlu mengetahui nama variabel (yang, kebetulan, dikembalikan kepada kami). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Harap dicatat bahwa tidak ada orang tua MonoBehaviour di jalan. </font><font style="vertical-align: inherit;">Sekarang tidak masalah, tetapi akan menjadi penting ketika kita mulai membongkar boneka Rusia yang terlihat seperti ini:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nestedClassVariable.exampleSandboxesList.Array.data [0] .evenMoreNested.Array.data [0]</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar tidak ketahuan, ketika properti bersarang, sebelumnya kami akan melakukan hal berikut:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">string</span>[] path = property.propertyPath.Split(<span class="hljs-string">'.'</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita memiliki semua simpul jalur serialisasi. </font><font style="vertical-align: inherit;">Tetapi dalam kasus yang paling primitif, kita hanya perlu simpul nol. </font><font style="vertical-align: inherit;">Ambil:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">string</span> pathNode = path[<span class="hljs-number">0</span>];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nyalakan sedikit refleksi dan dapatkan bidang dari sini:</font></font><br>
<br>
<pre><code class="cs hljs">Type objectType = serializationRoot.GetType();<font></font>
FieldInfo objectFieldInfo = objectType.GetField(pathNode);<font></font>
<span class="hljs-keyword">object</span> field = objectFieldInfo.GetValue(serializationRoot);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami meninggalkan pertanyaan tentang kecepatan usaha ini. Untuk sejumlah kecil bidang tersebut dan bersarang kecil, biaya refleksi akan jauh lebih sedikit daripada semua yang terjadi di bawah kap UnityEditor selama rendering. Jika Anda ingin bukti - di github, pengembang Unity memiliki hal yang menarik, UnityCsReference, lihat waktu luang Anda, bagaimana rendering ObjectField diimplementasikan, misalnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebenarnya, ini </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bukan (ha ha)</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> segalanya. Kami memiliki bidang, kami bahagia, kami dapat melakukan apa pun yang kami inginkan dengannya dan bahkan mencoba untuk menulis UnityEvent kami sendiri dengan semua tombol dan tindakan penting yang hanya memengaruhi bidang kami, tidak peduli objek apa yang menggantung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setidaknya, sementara itu tergantung pada akar dari objek ini, semuanya akan baik-baik saja, tetapi kemudian tidak begitu banyak lagi. </font><font style="vertical-align: inherit;">Di jalan serialisasi, kami menunggu array dan semua jenis daftar, yang keinginan utamanya adalah untuk menempatkan kami di sandal, tepat waktu mengubah jumlah elemen ke atas. </font><font style="vertical-align: inherit;">Tapi persetan dengan ini, pertama-tama kita akan menggali di bawah array itu sendiri.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tujuan kami adalah resistensi terhadap boneka semacam itu</font></font></b>
                        <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/l7/do/h3/l7doh3b9j_da24zsw9rc-7xefjs.png"></div></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kami tidak memiliki array di jalur serialisasi, tugas tersebut akan diselesaikan secara sepele: kami akan mengulangi simpul serialisasi di loop hingga kami mencapai akhir rantai. </font><font style="vertical-align: inherit;">Sesuatu seperti kode berikut:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">object</span> currentObject = serializationRoot;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; directSearchDepth; i++)<font></font>
{<font></font>
       <span class="hljs-keyword">string</span> pathNode = path[i];<font></font>
       Type objectType = currentObject.GetType();<font></font>
       FieldInfo objectFieldInfo = objectType.GetField(pathNode);<font></font>
       <span class="hljs-keyword">object</span> nextObject = objectFieldInfo.GetValue(currentObject);<font></font>
       currentObject = nextObject;<font></font>
}<font></font>
<span class="hljs-keyword">return</span> currentObject;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kita menunggu dua berita yang tidak menyenangkan sekaligus. </font><font style="vertical-align: inherit;">Saya akan mulai dengan yang kedua. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Langkah mengambil nextObject mungkin tiba-tiba mengembalikan nol daripada objek yang diharapkan. </font><font style="vertical-align: inherit;">Biasanya ini terjadi ketika kita pertama kali membuat objek induk di inspektur, dan jalur serialisasi sudah ada, tetapi bidang yang sesuai tidak (ini akan membawa kita lebih banyak fasilitas). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal ini, alangkah baiknya untuk segera menambahkan jalan keluar dari metode dengan pengembalian nol:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">object</span> nextObject = objectFieldInfo.GetValue(currentObject);
<span class="hljs-keyword">if</span> (nextObject == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
currentObject = nextObject;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Tunggu sebentar! </font><font style="vertical-align: inherit;">- kamu bilang. </font><font style="vertical-align: inherit;">"Dan apa yang harus dilakukan di OnGUI jika nol dikembalikan kepada kita?" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jawab: tidak ada. </font><font style="vertical-align: inherit;">Tidak ada yang secara harfiah. </font><font style="vertical-align: inherit;">Cukup buat kembali dan lewati langkah menggambar ini, sambil menunggu bidang yang akan dibuat. </font><font style="vertical-align: inherit;">Tidak ada yang mengerikan akan terjadi dari ini.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>(<span class="hljs-params">Rect position, SerializedProperty property, GUIContent label</span>)</span><font></font>
{<font></font>
       SandboxField sandboxField = GetTarget&lt;T&gt;(property);<font></font>
       <span class="hljs-keyword">if</span> (sandboxField == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<font></font>
‚Ä¶<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
di sini GetTarget () adalah fungsi yang sesuai, mengambil objek serial dari properti. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ngomong-ngomong, saya akan menyarankan Anda untuk membawa bidang yang menarik kepada kami tidak di sini, tetapi di GetPropertyHeight. Ini akan diperlukan jika kita menulis bidang yang dapat dilipat yang dapat diperluas dengan ukuran yang berbeda tergantung pada konten. GetPropertyHeight () dipanggil sebelum OnGUI (), jadi jika kita membawa bidang di sana dan menulisnya di bidang PropertyDrawer kita, kita tidak perlu membawanya lagi ke OnGUI.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Harap perhatikan bahwa instance dari PropertyDrawer khusus dibuat sendiri untuk menggambar semua properti berseri yang terlihat saat ini, dan properti baru dilemparkan ke sana secara bergantian dari atas ke bawah. Ini harus diperhitungkan agar tidak mengacaukan perhitungan ketinggian properti berikutnya, jika tidak, Anda mungkin mendapatkan situasi yang tidak menyenangkan ketika Anda mengklik flip dan bidang yang Anda harapkan diperluas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juga, semua perada yang bertanggung jawab untuk menampilkan bidang dalam editor dan yang ingin Anda serialkan, Anda harus membuat serial di sisi kelas yang dapat diserialkan, bukan PropertyDrawer, dan demi akurasi - sertakan kurung kompilasi bersyarat sehingga semua malu Spanyol ini tidak mencoba untuk pergi ke build :</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">Serializable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SandboxField</span><font></font>
{<font></font>
‚Ä¶<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> UNITY_EDITOR</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> editorFoldout;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
‚Ä¶<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perangkap lain yang menunggu kita di sini: semua bidang yang dibuat melalui editor ingin meludah pada konstruktor kelas dan pada nilai-nilai default yang ditentukan dalam kelas. </font><font style="vertical-align: inherit;">Jika Anda melakukannya, misalnya, seperti ini (contoh dari proyek saya, di mana itu adalah nilai dari node permukaan air):</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">SerializeField</span>]<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m_nodesPerUnit = <span class="hljs-number">5</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nilai ini akan diabaikan serialisasi titik-kosong segera setelah Anda menambahkan item baru ke daftar. </font><font style="vertical-align: inherit;">Memanggil konstruktor untuk bantuan tidak kurang berguna: semua yang Anda tulis di sana akan diabaikan. </font><font style="vertical-align: inherit;">Objek baru adalah tujuan seperti elang, semua nilainya benar-benar nilai default, itu bukan saja yang ingin Anda lihat di sana, tetapi semua jenis null, false, 0, Color.clear dan hal-hal cabul lainnya.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kruk dalam daging</font></font></b>
                        <div class="spoiler_text">  .   NonUnitySerializableClass,       .      , DefaultEditorObject(),    . <br>
<br>
  - :<br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NonUnitySerializableClass</span><font></font>
{<font></font>
        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DefaultEditorObject</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-comment">// virtually do nothing</span><font></font>
        }<font></font>
<font></font>
        [<span class="hljs-meta">SerializeField</span>]<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> validated = <span class="hljs-literal">false</span>;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">EditorCreated</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> force = <span class="hljs-literal">false</span></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (validated &amp;&amp; !force) <span class="hljs-keyword">return</span>;<font></font>
            DefaultEditorObject();<font></font>
            validated = <span class="hljs-literal">true</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NonUnitySerializableClass</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            EditorCreated(<span class="hljs-literal">true</span>);<font></font>
        }<font></font>
}</code></pre><br>
        DefaultEditorObject(),    ,   EditorCreated     .<br>
<br>
 :       .<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fg/dh/dr/fgdhdrfczfhhcki7dw6plxzj7vi.png"></div><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita kembali ke domba kita, atau lebih tepatnya, ke array. </font><font style="vertical-align: inherit;">Masalah lain yang mungkin muncul pada tahap lebih awal terletak pada baris ini:</font></font><br>
<br>
<pre><code class="cs hljs">FieldInfo objectFieldInfo = objectType.GetField(pathNode);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sisi kanan dapat mengembalikan kita nol jika muncul terhadap array di jalur serialisasi (dan objek "IList" akan menjadi array "Array"). </font><font style="vertical-align: inherit;">Tidak menyenangkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang harus dilakukan? </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cobalah untuk tidak jatuh ke dalam situasi seperti itu dengan</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menulis pawang:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pathNode.Length; i++)<font></font>
{<font></font>
        <span class="hljs-keyword">string</span> pathNode = path[i];<font></font>
        Type objectType = currentObject.GetType();<font></font>
        FieldInfo objectFieldInfo = objectType.GetField(pathNode);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (objectFieldInfo == <span class="hljs-literal">null</span>)<font></font>
        {<font></font>
                <span class="hljs-keyword">if</span> (pathNode == <span class="hljs-string">"Array"</span>)<font></font>
                {<font></font>
                        i++;<font></font>
                        <span class="hljs-keyword">string</span> nextNode = path[i];
                        <span class="hljs-keyword">string</span> idxstr = nextNode.Substring(nextNode.IndexOf(<span class="hljs-string">"["</span>) + <span class="hljs-number">1</span>);<font></font>
                        idxstr = idxstr.Replace(<span class="hljs-string">"]"</span>, <span class="hljs-string">""</span>);
                        <span class="hljs-keyword">int</span> arrayNumber = Convert.ToInt32(idxstr);<font></font>
                        IList collection = currentObject <span class="hljs-keyword">as</span> IList;
                        <span class="hljs-keyword">if</span> (collection.Count &lt;= arrayNumber) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
                        currentObject = collection[arrayNumber];<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span><font></font>
                {<font></font>
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException(<span class="hljs-string">"   "</span>);<font></font>
                }<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> <span class="hljs-comment">//  ,     </span><font></font>
        {<font></font>
                <span class="hljs-keyword">object</span> nextObject = objectFieldInfo.GetValue(currentObject);
                <span class="hljs-keyword">if</span> (nextObject == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
                currentObject = nextObject;<font></font>
        }<font></font>
}<font></font>
<span class="hljs-keyword">return</span> currentObject;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya, kita bahkan dapat masuk ke situasi yang tidak menyenangkan di sini, ketika jalur serialisasi sudah memiliki, misalnya, data [0] atau data [1] elemen, dan array belum mengimplementasikannya. </font><font style="vertical-align: inherit;">Misalnya, kami membuat Daftar kosong. </font><font style="vertical-align: inherit;">Kami bertanya kepadanya N elemen - dan tanpa garis yang indah ini:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">if</span> (collection.Count &lt;= arrayNumber) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... kami mendapat banyak pengecualian dalam dengungan. </font><font style="vertical-align: inherit;">Dan semua yang diperlukan adalah untuk melewatkan langkah rendering, setelah menunggu sampai bidang yang menarik bagi kami dibuat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya belum menemukan kasus-kasus lain ketika objectFieldInfo == null, tetapi pada saat yang sama node serialisasi tidak ditunjuk sebagai Array, jadi melempar pengecualian yang mengerikan ke dalam situasi hipotetis yang luar biasa adalah untuk kemudian memecahkannya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, kami mendapat fungsi kerja yang lebih atau kurang yang memungkinkan kami untuk mengekstrak bidang dengan properti berseri. </font><font style="vertical-align: inherit;">Di masa depan, fungsi ini dapat dimodifikasi dengan memaksa untuk mengekstrak semua objek di jalur serialisasi, serta mencari "induk" terdekat, termasuk atau mengecualikan array di sepanjang jalur.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retas seumur hidup untuk menggambar properti bersarang</font></font></b>
                        <div class="spoiler_text">      -  ,   Rect position  Rect indentedPosition = EditorGUI.IndentedRect(position).     ,         EditorGUI,      position ,       GUI ‚Äì    indentedPosition.   EditorGUILayout  OnGUI,       (   ,   ).<br>
<br>
    ,   MonoScript   (     -,   ),     static-,      AssetDatabase,        <i></i>         .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terimakasih atas perhatiannya.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id502818/index.html">Y messenger: messenger terdesentralisasi di blockchain *</a></li>
<li><a href="../id502826/index.html">Ikhtisar 3D Creaform MetraSCAN 3D Scanner</a></li>
<li><a href="../id502830/index.html">VirusHack "Realitas Baru" Hackathon Online. Bagaimana itu</a></li>
<li><a href="../id502832/index.html">Sertifikasi ISTQB tersedia secara online: pengalaman pribadi</a></li>
<li><a href="../id502834/index.html">Bagaimana menjadi insinyur DevOps dalam enam bulan atau bahkan lebih cepat. Bagian 5. Penempatan</a></li>
<li><a href="../id502838/index.html">Apa perbedaan antara IT dan profesi digital: transformasi digital dan pendapat para pakar</a></li>
<li><a href="../id502840/index.html">Ulasan Pemindai 3D Cemerlang EinScan Pro 2X Plus 3D</a></li>
<li><a href="../id502842/index.html">Cara melindungi data biometrik pengguna dari penggunaan kriminal</a></li>
<li><a href="../id502844/index.html">[Bagian 2/2] Panduan untuk FFmpeg dan SDL atau Cara menulis pemutar video dalam waktu kurang dari 1000 baris</a></li>
<li><a href="../id502846/index.html">Zuckerberg meluncurkan Shops. Instagram dan Facebook secara bertahap menjadi toko.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>