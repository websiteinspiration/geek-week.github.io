<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👓 🧑🏿‍🤝‍🧑🏼 🦇 快速简便的体绘制算法 🎗️ 💆🏼 🎹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我最近写了一个小的ShaderToy，可以进行简单的体积渲染，然后决定发表一篇说明其工作的文章。可以在此处查看交互式ShaderToy本身。如果您正在阅读手机或笔记本电脑，建议您观看此快速版本。我在帖子中包含了一些代码片段，这些片段可以帮助您全面了解ShaderToy的性能，但其中没有全部细节。如果...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>快速简便的体绘制算法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500914/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/8r/iy/wc/8riywca1jhipnzh4e3ycjritfec.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我最近写了一个小的ShaderToy，可以进行简单的体积渲染，然后决定发表一篇说明其工作的文章。</font><font style="vertical-align: inherit;">可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看交互式ShaderToy本身</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果您正在阅读手机或笔记本电脑，建议您观看</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">快速版本。</font><font style="vertical-align: inherit;">我在帖子中包含了一些代码片段，这些片段可以帮助您全面了解ShaderToy的性能，但其中没有全部细节。</font><font style="vertical-align: inherit;">如果您想更深入地研究，建议使用ShaderToy代码进行检查。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我的ShaderToy有三个主要任务：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实时执行</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简单</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">身体上的正确性（...或类似的东西）</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将从这个空白代码场景开始。</font><font style="vertical-align: inherit;">我不会详细介绍实现，因为它不是很有趣，但是我将简要地告诉您我们从哪里开始：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不透明对象的光线跟踪。</font><font style="vertical-align: inherit;">所有对象都是具有与光线（1个平面和3个球体）的简单交点的图元</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了计算照明，使用了Phong阴影，在三个球形光源中，使用了自定义的光衰减系数。</font><font style="vertical-align: inherit;">不需要阴影线，因为我们仅照亮平面。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
看起来是这样的：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba8/4dc/f82/ba84dcf8277762a067454fb786d266be.jpg" alt="ShaderToy屏幕截图"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将体积渲染为与不透明场景混合的单独通道。</font><font style="vertical-align: inherit;">这类似于所有实时渲染引擎分别处理不透明和半透明表面的方式。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第1部分：模拟音量</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是首先，在我们开始体积渲染之前，我们需要相同的体积！为了模拟音量，我决定使用带符号的距离函数（SDF）。为什么要精确地定义距离场的功能？因为我不是艺术家，但是他们允许您用几行代码创建非常自然的形式。我不会详细讨论带有标志的距离的功能，因为Inigo Kiles已经很好地解释了它们。如果你是好奇，然后</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就是迹象距离和改性剂的不同FUNC-蒸发散的大名单。而</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是关于这些raymarching自卫队的另一篇文章。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们从一个简单的开始，并在此处添加一个球体：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c03/5c4/536/c035c45368ef0cd0e232041b4ca2eec4.jpg" alt="ShaderToy屏幕截图"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们将添加另一个球体，并使用平滑共轭合并这些球体的距离函数。</font><font style="vertical-align: inherit;">我直接从Inigo页面获取了此代码，但为清楚起见，我将其插入此处：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Taken from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm</span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdSmoothUnion</span><span class="hljs-params">( <span class="hljs-keyword">float</span> d1, <span class="hljs-keyword">float</span> d2, <span class="hljs-keyword">float</span> k )</span> 
</span>{
    <span class="hljs-keyword">float</span> h = clamp( <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>*(d2-d1)/k, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> );
    <span class="hljs-keyword">return</span> mix( d2, d1, h ) - k*h*(<span class="hljs-number">1.0</span>-h); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
平滑配对是一种非常强大的工具，因为您只需将其与一些简单的形状组合即可获得非常有趣的东西。</font><font style="vertical-align: inherit;">这是我的许多平滑共轭球的外观：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/c3c/4b4/ddcc3c4b4f6d38d509b69cae63088c4a.jpg" alt="ShaderToy屏幕截图"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们得到了水滴状的东西，但是我们需要的更像是云而不是水滴。 SDF的一大特色是，只需在SDF中添加一点噪声即可使表面变形。因此，让我们使用位置索引噪声函数来添加一些分形布朗运动（fBM）开销。 Inigo Kiles在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一篇</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关FBM噪声</font><font style="vertical-align: inherit;">的出色</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">文章中</font></a><font style="vertical-align: inherit;">也谈到了这个话题</font><font style="vertical-align: inherit;">。叠加了fBM噪声的图像如下所示：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a47/bd6/bbd/a47bd6bbd487a37bc5e07a8f65e6436d.jpg" alt="ShaderToy屏幕截图"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
精细！</font><font style="vertical-align: inherit;">多亏了fBM噪音，这个物体突然看起来变得更加有趣！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们需要创建一种幻想，即体积与地球平面相互作用。</font><font style="vertical-align: inherit;">为此，我将有符号平面的距离增加到略低于接地平面的距离，然后重新使用平滑配对与非常积极的配对值（参数k）的组合。</font><font style="vertical-align: inherit;">之后，我们得到了这张照片：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d2/7e9/863/8d27e9863fb9637575e23a4cf593f90e.jpg" alt="ShaderToy屏幕截图"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后一点将是fBM噪声的xz指数随时间变化，因此音量看起来像是旋转的雾。</font><font style="vertical-align: inherit;">在移动中，它看起来非常好！</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/167/2d6/6fa/1672d66fa4b2760e9e57bd6062281cc2.gif" alt="ShaderToy屏幕截图"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
太好了，我们有点像云！</font><font style="vertical-align: inherit;">SDF计算代码也非常紧凑：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">QueryVolumetricDistanceField</span><span class="hljs-params">( in vec3 pos)</span>
</span>{    <font></font>
    vec3 fbmCoord = (pos + <span class="hljs-number">2.0</span> * vec3(iTime, <span class="hljs-number">0.0</span>, iTime)) / <span class="hljs-number">1.5f</span>;
    <span class="hljs-keyword">float</span> sdfValue = sdSphere(pos, vec3(<span class="hljs-number">-8.0</span>, <span class="hljs-number">2.0</span> + <span class="hljs-number">20.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">-1</span>), <span class="hljs-number">5.6</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue,sdSphere(pos, vec3(<span class="hljs-number">8.0</span>, <span class="hljs-number">8.0</span> + <span class="hljs-number">12.0</span> * <span class="hljs-built_in">cos</span>(iTime), <span class="hljs-number">3</span>), <span class="hljs-number">5.6</span>), <span class="hljs-number">3.0f</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdSphere(pos, vec3(<span class="hljs-number">5.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">3.0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">8.0</span>), <span class="hljs-number">3.0</span>) + <span class="hljs-number">7.0</span> * fbm_4(fbmCoord / <span class="hljs-number">3.2</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdPlane(pos + vec3(<span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0</span>)), <span class="hljs-number">22.0</span>);
    <span class="hljs-keyword">return</span> sdfValue;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这只是渲染一个不透明的对象。我们需要一朵美丽的壮丽的雾！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们如何以体积而不是不透明对象的形式呈现它？让我们先谈谈我们模拟的物理。体积是空间中特定区域中的大量粒子。当我说“巨大”时，我的意思是“巨大”。如此之多，以至于当今对这些粒子中的每一个进行建模都是一项不可能的任务，即使对于离线渲染也是如此。火，雾和云就是很好的例子。严格来说，一切都是体积，但是为了计算的速度，我们更容易对此视而不见，而假装不是。我们将这些粒子的累积表示为密度值，通常存储在某种3D网格中（或更复杂的东西，例如在OpenVDB中）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当光穿过某个体积时，当光与粒子碰撞时会发生一对现象。</font><font style="vertical-align: inherit;">它可以散射并向另一个方向传播，或者部分光可以被粒子吸收并溶解。</font><font style="vertical-align: inherit;">为了满足实时执行要求，我们将执行所谓的单次散射。</font><font style="vertical-align: inherit;">这意味着：当光与粒子碰撞并飞向相机时，我们将假设光仅散射一次。</font><font style="vertical-align: inherit;">也就是说，我们将无法模拟多重散射（例如雾）的影响，在这种情况下，远处的对象通常看起来更加模糊。</font><font style="vertical-align: inherit;">但是对于我们的系统而言，这已经足够了。</font><font style="vertical-align: inherit;">这是光线散射时的单次散射的样子：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2d/19e/00f/f2d19e00fa758b0addc4ca447c0b024e.jpg" alt="ShaderToy屏幕截图"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它的伪代码如下所示：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> n steps along the camera ray:<font></font>
   Calculate what % <span class="hljs-function">of your ray hit <span class="hljs-title">particles</span> <span class="hljs-params">(i.e. were absorbed)</span> <span class="hljs-keyword">and</span> needs lighting
   <span class="hljs-keyword">for</span> m lights:
      <span class="hljs-keyword">for</span> k steps towards the light:
         Calculate % of light that were absorbe in <span class="hljs-keyword">this</span> step
      Calculate lighting based on how much light is visible
Blend results on top of opaque objects pass based on % of your ray that made it through the volume</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也就是说，我们正在处理复杂度为O（n * m * k）的计算。</font><font style="vertical-align: inherit;">因此，GPU将必须努力工作。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们计算吸收</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，让我们看一下沿相机光束的体积中的光吸收（即，我们现在还不执行沿光源方向的光线marching）。</font><font style="vertical-align: inherit;">为此，我们需要执行两个操作：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在体积内执行光线行进</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计算每一步的吸收/照明</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了计算每个点吸收多少光，我们使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了布格–兰伯特–比尔定律</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">定律</font></a><font style="vertical-align: inherit;">描述了穿过材料时光的衰减。</font><font style="vertical-align: inherit;">计算非常简单：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">BeerLambert</span><span class="hljs-params">(<span class="hljs-keyword">float</span> absorptionCoefficient, <span class="hljs-keyword">float</span> distanceTraveled)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">exp</span>(-absorptionCoefficient * distanceTraveled);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
吸收系数是材料参数。</font><font style="vertical-align: inherit;">例如，在透明体积中（例如在水中），该值将较低；对于较稠的东西（例如，牛奶），该系数将较高。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了进行体积射线行进，我们只需沿光束采取固定大小的台阶，并在每一步都获得吸收。</font><font style="vertical-align: inherit;">您可能不明白为什么要采取固定的步骤而不是更快地执行某些步骤，例如跟踪球体，但是如果您记得体积内的密度是异质的，那么一切都会变得清晰。</font><font style="vertical-align: inherit;">下面是光线行进和累积吸收代码。</font><font style="vertical-align: inherit;">一些变量不在此代码段的范围内，因此请检查ShaderToy中的完整实现。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> opaqueVisiblity = <span class="hljs-number">1.0f</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> marchSize = <span class="hljs-number">0.6f</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_VOLUME_MARCH_STEPS; i++) {<font></font>
	volumeDepth += marchSize;<font></font>
	<span class="hljs-keyword">if</span>(volumeDepth &gt; opaqueDepth) <span class="hljs-keyword">break</span>;<font></font>
	<font></font>
	vec3 position = rayOrigin + volumeDepth*rayDirection;<font></font>
	<span class="hljs-keyword">bool</span> isInVolume = QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0f</span>;
	<span class="hljs-keyword">if</span>(isInVolume) 	{
		<span class="hljs-keyword">float</span> previousOpaqueVisiblity = opaqueVisiblity;<font></font>
		opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
		<span class="hljs-keyword">float</span> absorptionFromMarch = previousOpaqueVisiblity - opaqueVisiblity;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> lightIndex = <span class="hljs-number">0</span>; lightIndex &lt; NUM_LIGHTS; lightIndex++) {
			<span class="hljs-keyword">float</span> lightDistance = length((GetLight(lightIndex).Position - position));<font></font>
			vec3 lightColor = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDistance);  <font></font>
			volumetricColor += absorptionFromMarch * volumeAlbedo * lightColor;<font></font>
		}<font></font>
		volumetricColor += absorptionFromMarch * volumeAlbedo * GetAmbientLight();<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就是我们得到的：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/14e/a86/c8714ea862797c656d9c64105c7befed.jpg" alt="ShaderToy屏幕截图"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
看起来像棉花糖！</font><font style="vertical-align: inherit;">也许对于某些效果就足够了！</font><font style="vertical-align: inherit;">但是我们缺乏自我遮蔽。</font><font style="vertical-align: inherit;">光均匀地到达体积的所有部分。</font><font style="vertical-align: inherit;">但这在物理上是不正确的，具体取决于渲染点和光源之间的体积大小，我们将接收到不同数量的入射光。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自阴影</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们已经做了最困难的事情。</font><font style="vertical-align: inherit;">我们需要做与计算沿照相机光束的吸收相同的操作，但仅沿光束进行吸收。</font><font style="vertical-align: inherit;">用于计算到达每个点的光量的代码本质上将是该代码的重复，但是复制它比破解HLSL更容易获得我们所需的递归。</font><font style="vertical-align: inherit;">所以这是它的样子：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetLightVisiblity</span><span class="hljs-params">(in vec3 rayOrigin, in vec3 rayDirection, in <span class="hljs-keyword">float</span> maxT, in <span class="hljs-keyword">int</span> maxSteps, in <span class="hljs-keyword">float</span> marchSize)</span> </span>{
    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0.0f</span>;
    <span class="hljs-keyword">float</span> lightVisiblity = <span class="hljs-number">1.0f</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxSteps; i++) {                       <font></font>
        t += marchSize;<font></font>
        <span class="hljs-keyword">if</span>(t &gt; maxT) <span class="hljs-keyword">break</span>;<font></font>
<font></font>
        vec3 position = rayOrigin + t*rayDirection;<font></font>
        <span class="hljs-keyword">if</span>(QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0</span>) {<font></font>
            lightVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> lightVisiblity;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
添加自阴影可以为我们提供以下功能：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/6e0/96e/a4f6e096e2250a9aa17594b59cc7e25d.jpg" alt="ShaderToy屏幕截图"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">柔化边缘</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此刻，我已经很喜欢我们的音量。</font><font style="vertical-align: inherit;">我向他展示了联盟视觉特效部门的才华领袖詹姆斯·夏普（James Sharp）。</font><font style="vertical-align: inherit;">他立即注意到该卷的边缘看起来太尖锐。</font><font style="vertical-align: inherit;">这是绝对正确的-像云一样的物体不断散布在它们周围的空间中，因此它们的边缘与体积周围的空白空间混合在一起，这将导致创建非常光滑的边缘。</font><font style="vertical-align: inherit;">詹姆斯给我提供了一个好主意-根据我们离边缘的距离减少密度。</font><font style="vertical-align: inherit;">而且由于我们正在使用带符号的距离功能，因此非常容易实现！</font><font style="vertical-align: inherit;">因此，让我们添加一个可用于请求体积中任意点密度的函数：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">return</span> sdfMultiplier;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后我们简单地将其折叠为吸收值：</font></font><br>
<br>
<pre><code class="cpp hljs">opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT * GetFogDensity(position), marchSize);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是它的样子：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/7b3/ab5/7887b3ab53afcfc69c33e12bd473de9d.gif" alt="ShaderToy屏幕截图"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">密度函数</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们有了密度功能，您可以轻松地在体积上添加一点噪音，使其具有更多细节和光彩。</font><font style="vertical-align: inherit;">在这种情况下，我只是重复使用了用来调整音量形状的fBM函数。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
   <span class="hljs-keyword">return</span> sdfMultiplier * <span class="hljs-built_in">abs</span>(fbm_4(position / <span class="hljs-number">6.0</span>) + <span class="hljs-number">0.5</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们得到以下信息：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b9/c0a/1e6/1b9c0a1e68d020206e9567b9044317d9.jpg" alt="ShaderToy屏幕截图"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不透明的自我遮蔽</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该卷已经看起来很漂亮！</font><font style="vertical-align: inherit;">但是仍然有一点光从那里泄漏出来。</font><font style="vertical-align: inherit;">在这里，我们看到绿色如何渗入体积一定要吸收的位置：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/e16/dbf/051e16dbfa5d9f307c635a6293dcc69f.jpg" alt="ShaderToy屏幕截图"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
发生这种情况是因为在渲染体积之前渲染了不透明的对象，因此它们不考虑由体积引起的阴影。</font><font style="vertical-align: inherit;">这很容易修复-我们有一个GetLightVisiblity函数可用于计算阴影，因此我们只需调用它即可照亮不透明的对象。</font><font style="vertical-align: inherit;">我们得到以下内容：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cda/1c4/99d/cda1c499d05729265b374378e3da9481.gif" alt="ShaderToy屏幕截图"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了创建漂亮的多色阴影外，这还有助于改善阴影并在场景中建立体积。</font><font style="vertical-align: inherit;">此外，由于体积的平滑边缘，尽管严格地说我们使用点光源进行照明，但我们仍可获得柔和的阴影。</font><font style="vertical-align: inherit;">就这样！</font><font style="vertical-align: inherit;">在这里可以做更多的工作，但在我看来，我已经达到了所需的视觉效果，同时又保持了示例的相对简单性。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最佳化</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，我将简要列出一些可能的优化：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在沿光源方向进行光线行进之前，有必要通过光的衰减值来检查是否有大量的这种光确实到达了所讨论的点。</font><font style="vertical-align: inherit;">在我的实现中，我查看了光的亮度乘以材质的反照率，并确保该值足够大以执行光线行进。</font></font></li>
<li>      ,     ,     raymarching   </li>
<li>        raymarching .      ,        .           ,       raymarching ,     .</li>
</ol><br>
<h1></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就这样！</font><font style="vertical-align: inherit;">就个人而言，我很惊讶您可以用这么少的代码（大约500行）创建在物理上相当正确的东西。</font><font style="vertical-align: inherit;">谢谢您的阅读，我希望这很有趣。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还有一点需要注意：这是一个有趣的变化-我根据SDF距离添加了光发射以创建爆炸效果。</font><font style="vertical-align: inherit;">毕竟，爆炸从未发生过。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/2f1/ab0/c642f1ab0fbc3df3b35cfafa97f9c694.gif" alt="ShaderToy屏幕截图"></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN500896/index.html">在隔离区看到什么？Technostream精选材料（第3部分）</a></li>
<li><a href="../zh-CN500898/index.html">疯狂的SpaceX月球计划？U / S_Hirangy（reddit）进行程序评估</a></li>
<li><a href="../zh-CN500902/index.html">343号移动开发人员的有趣材料摘要（4月27日-5月3日）</a></li>
<li><a href="../zh-CN500904/index.html">2020年支付生态系统中的谁是谁。第1部分</a></li>
<li><a href="../zh-CN500910/index.html">中国远程空间通信系统</a></li>
<li><a href="../zh-CN500918/index.html">在计算A / B检验的统计显着性时要注意的是</a></li>
<li><a href="../zh-CN500920/index.html">古物：ZX Spectrum和古代igrozhur</a></li>
<li><a href="../zh-CN500922/index.html">披着羊皮的狼：如何捉住精心掩饰自己是普通用户的黑客</a></li>
<li><a href="../zh-CN500924/index.html">与Evgeny Borisov的在线会议JUG.ru“弹簧制造者”</a></li>
<li><a href="../zh-CN500928/index.html">2020年数字突破竞赛启动在线IT马拉松</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>