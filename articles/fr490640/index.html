<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏼 🎇 ☝🏾 Surcharge en C ++. Partie III. Surcharge des instructions new / delete 🧖🏾 👛 🧔🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous continuons la série "C ++, creuser en profondeur." Le but de cette série est d'en dire le plus possible sur les différentes caractéristiques du l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Surcharge en C ++. Partie III. Surcharge des instructions new / delete</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490640/"><hr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous continuons la série "C ++, creuser en profondeur." </font><font style="vertical-align: inherit;">Le but de cette série est d'en dire le plus possible sur les différentes caractéristiques du langage, peut-être assez particulières. </font><font style="vertical-align: inherit;">Cet article concerne la surcharge des opérateurs </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il s'agit du troisième article de la série, le premier dédié aux fonctions et modèles de surcharge, situé </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , le deuxième dédié aux opérateurs de surcharge, situé </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cet article conclut une série de trois articles sur la surcharge en C ++.</font></font><br>
<hr><a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table des matières</font></font></h1><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table des matières</font></font></b><div class="spoiler_text">&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.    new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.1.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.3.     </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.1.     </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.2.1.      new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.2.2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.2.3.  </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.2.4. </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.2.5.    operator delete()</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.   new/delete</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.    </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5. -  </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a><br>
</div></div><br>
<a name="id-1"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Formes standard des opérateurs nouveaux / supprimés</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ prend en charge plusieurs options d'opérateur </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ils peuvent être divisés en standard de base, standard supplémentaire et personnalisé. </font><font style="vertical-align: inherit;">Cette section et la section 2 traitent des formulaires standard; les formulaires personnalisés seront abordés dans la section 3.</font></font><br>
<br>
<a name="id-1-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1. </font><font style="vertical-align: inherit;">Formulaires standard de base</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les principales formes standard d'opérateurs </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisées pour créer et supprimer un objet et un tableau du type sont </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les suivantes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span> T[<span class="hljs-comment">/*   */</span>]
<span class="hljs-keyword">delete</span> ptr;
<span class="hljs-keyword">delete</span>[] ptr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leur travail peut être décrit comme suit. Lorsque l'opérateur est appelé </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la mémoire est d'abord allouée à l'objet. Si la sélection réussit, le constructeur est appelé. Si le constructeur lève une exception, la mémoire allouée est libérée. Lorsque l'opérateur est appelé, </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tout se passe dans l'ordre inverse: d'abord, le destructeur est appelé, puis la mémoire est libérée. Le destructeur ne doit pas lever d'exceptions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque l'opérateur</font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisée pour créer un tableau d'objets, la mémoire est d'abord allouée à l'ensemble du tableau. Si la sélection réussit, le constructeur par défaut (ou un autre constructeur, s'il y a un initialiseur) est appelé pour chaque élément du tableau à partir de zéro. Si un constructeur lève une exception, alors pour tous les éléments créés du tableau, le destructeur est appelé dans l'ordre inverse de l'appel du constructeur, la mémoire allouée est libérée. Pour supprimer un tableau, vous devez appeler l'opérateur </font></font><code>delete[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et pour tous les éléments du tableau, le destructeur est appelé dans l'ordre inverse du constructeur, puis la mémoire allouée est libérée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Attention! Il est nécessaire d'appeler la bonne forme de l'opérateur</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selon si un seul objet ou un tableau est supprimé. Cette règle doit être strictement respectée, sinon vous pouvez obtenir un comportement indéfini, c'est-à-dire que tout peut arriver: fuites de mémoire, crash, etc. Voir [Meyers1] pour plus de détails. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la description ci-dessus, une clarification est nécessaire. Pour les soi-disant types triviaux (types intégrés, structures de style C), le constructeur par défaut ne peut pas être appelé et le destructeur ne fait en aucun cas quoi que ce soit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les fonctions d'allocation de mémoire standard, lorsqu'il n'est pas possible de satisfaire la demande, lèvent une exception de type </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mais cette exception peut être interceptée, pour cela, vous devez installer un intercepteur global à l'aide d'un appel de fonction </font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pour plus de détails, voir [Meyers1]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toute forme d'opérateur</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appliquer en toute sécurité au pointeur nul. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la création d'un tableau avec un opérateur, la </font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">taille peut être définie sur zéro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les deux formes de l'opérateur </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permettent d'utiliser des initialiseurs dans les accolades.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>{<span class="hljs-number">42</span>}
<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">8</span>]{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>}</code></pre><br>
<a name="id-1-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2. </font><font style="vertical-align: inherit;">Formulaires standard supplémentaires</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la connexion du fichier d'en-tête </font></font><code>&lt;new&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, 4 formulaires d'opérateur standard supplémentaires sont disponibles </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(ptr) T(<span class="hljs-comment">/*  */</span>);
<span class="hljs-keyword">new</span>(ptr) T[<span class="hljs-comment">/*   */</span>];
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T(<span class="hljs-comment">/*   */</span>);
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T[<span class="hljs-comment">/*   */</span>];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les deux premiers d'entre eux sont appelés </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">placement sans allocation </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Un argument </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est un pointeur vers une région de mémoire suffisamment grande pour contenir une instance ou un tableau. De plus, la zone de mémoire doit avoir un alignement approprié. Cette version de l'opérateur </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'alloue pas de mémoire, elle fournit uniquement un appel au constructeur. Ainsi, cette option vous permet de séparer les phases d'allocation de mémoire et d'initialisation des objets. Cette fonctionnalité est activement utilisée dans les conteneurs standard. L'opérateur </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour les objets ainsi créés ne peut bien entendu pas être appelé. Pour supprimer un objet, vous devez appeler directement le destructeur, puis libérer la mémoire d'une manière qui dépend de la méthode d'allocation de mémoire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les deux autres options sont appelées l'opérateur ne lançant pas d'exceptions </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(nothrow </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) et diffèrent en ce que s'il est impossible de satisfaire la demande, elles renvoient </font></font><code>nullptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais ne </font><font style="vertical-align: inherit;">lèvent </font><font style="vertical-align: inherit;">pas d'exception de </font><font style="vertical-align: inherit;">type </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La suppression d'un objet se produit à l'aide de l'opérateur principal </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ces options sont considérées comme obsolètes et non recommandées.</font></font><br>
<br>
<a name="id-1-3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3. </font><font style="vertical-align: inherit;">Allocation de mémoire et fonctions libres</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les opérateurs standard </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisent les fonctions d'allocation et de désallocation suivantes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces fonctions sont définies dans l'espace de noms global. </font><font style="vertical-align: inherit;">Les fonctions d'allocation de mémoire pour les instructions host </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne font rien et retournent simplement </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 17 a pris en charge d'autres formes d'allocation de mémoire et de désallocation, indiquant l'alignement. </font><font style="vertical-align: inherit;">En voici quelques uns:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces formulaires ne sont pas directement accessibles à l'utilisateur, ils sont utilisés par le compilateur pour des objets dont les exigences d'alignement sont supérieures </font></font><code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, donc le principal problème est que l'utilisateur ne les cache pas accidentellement (voir section 2.2.1). </font><font style="vertical-align: inherit;">Rappelons qu'en C ++ 11, il est devenu possible de définir explicitement l'alignement des types d'utilisateurs.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">struct <span class="hljs-title">alignas</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span> X </span>{ <span class="hljs-comment">/* ... */</span> };</code></pre><br>
<a name="id-2"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Surcharger les formulaires standard des opérateurs nouveaux / supprimer</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La surcharge des formes standard d'opérateurs </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consiste à définir des fonctions définies par l'utilisateur pour allouer et libérer de la mémoire dont les signatures coïncident avec celles standard. </font><font style="vertical-align: inherit;">Ces fonctions peuvent être définies dans l'espace de noms global ou dans une classe, mais pas dans un espace de noms autre que global. </font><font style="vertical-align: inherit;">La fonction d'allocation de mémoire pour une instruction hôte standard </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne peut pas être définie dans l'espace de noms global. </font><font style="vertical-align: inherit;">Après une telle définition, les opérateurs correspondants </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les utiliseront, pas les </font><font style="vertical-align: inherit;">opérateurs </font><font style="vertical-align: inherit;">standard.</font></font><br>
<br>
<a name="id-2-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1. </font><font style="vertical-align: inherit;">Surcharge dans l'espace de noms global</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons, par exemple, dans un module dans un espace de noms global que des fonctions définies par l'utilisateur soient définies:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
</span>{
<span class="hljs-comment">// ...</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, il y aura en fait un remplacement (remplacement) des fonctions standard pour allouer et libérer de la mémoire pour tous les appels d'opérateur </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour toutes les classes (y compris les classes standard) dans le module entier. Cela peut conduire au chaos complet. Notez que le mécanisme de substitution décrit est un mécanisme spécial implémenté uniquement pour ce cas, et non un mécanisme C ++ général. Dans ce cas, lors de l'implémentation des fonctions utilisateur d'allocation et de libération de mémoire, il devient impossible d'appeler les fonctions standard correspondantes, elles sont complètement masquées (l'opérateur </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'aide pas), et lorsque vous essayez de les appeler, un appel récursif à la fonction utilisateur se produit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fonction définie par l'espace de noms global</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il remplacera également le standard, mais il y aura moins de problèmes potentiels, car l'opérateur qui ne lance pas d'exceptions </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est rarement utilisé. </font><font style="vertical-align: inherit;">Mais le formulaire standard n'est pas non plus disponible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La même situation avec des fonctions pour les tableaux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La surcharge des instructions </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans l'espace de noms global est fortement déconseillée.</font></font><br>
<br>
<a name="id-2-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2. </font><font style="vertical-align: inherit;">Surcharge de classe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La surcharge des opérateurs </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans une classe est dépourvue des inconvénients décrits ci-dessus. </font><font style="vertical-align: inherit;">La surcharge n'est efficace que lors de la création et de la suppression d'instances de la classe correspondante, quel que soit le contexte d'appel des opérateurs </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lorsque vous implémentez des fonctions définies par l'utilisateur pour allouer et libérer de la mémoire à l'aide de l'opérateur, </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous pouvez accéder aux fonctions standard correspondantes. </font><font style="vertical-align: inherit;">Prenons un exemple.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span>
{</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete\n"</span>;<font></font>
        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(ptr)</span></span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new[]\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete[]\n"</span>;<font></font>
        ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](ptr);<font></font>
    }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet exemple, le suivi est simplement ajouté aux opérations standard. </font><font style="vertical-align: inherit;">Maintenant, en termes </font></font><code>new X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>new X[N]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliser ces fonctions pour allouer et libérer de la mémoire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces fonctions sont formellement statiques et peuvent être déclarées comme </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais pour l'essentiel, ce sont des instances, avec l'appel de fonction </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la création de l'instance commence et l'appel de fonction </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">termine sa suppression. </font><font style="vertical-align: inherit;">Ces fonctions ne sont jamais appelées pour d'autres tâches. </font><font style="vertical-align: inherit;">De plus, comme cela sera montré ci-dessous, la fonction </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est essentiellement virtuelle. </font><font style="vertical-align: inherit;">Il est donc plus correct de les déclarer sans </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.1. </font><font style="vertical-align: inherit;">Accès aux formulaires standard des opérateurs nouveaux / supprimés</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les opérateurs </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peuvent être utilisés avec un opérateur de résolution d'étendue supplémentaire, par exemple </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans ce cas, la fonction </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">définie dans la classe sera ignorée et la norme correspondante sera utilisée. </font><font style="vertical-align: inherit;">De la même manière, vous pouvez utiliser l'opérateur </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.2. </font><font style="vertical-align: inherit;">Masquage d'autres formes d'opérateurs nouveaux / supprimés</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si maintenant, pour la classe, </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous essayons d'utiliser des exceptions de lancement ou de non-lancement </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous obtenons une erreur. </font><font style="vertical-align: inherit;">Le fait est que la fonction </font></font><code>operator new(std::size_t size)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masquera d'autres formes </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Le problème peut être résolu de deux manières. </font><font style="vertical-align: inherit;">Dans le premier, vous devez ajouter les options appropriées à la classe (ces options devraient simplement déléguer le fonctionnement de la fonction standard). </font><font style="vertical-align: inherit;">Dans le second, vous devez utiliser un opérateur </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec un opérateur de résolution de portée, par exemple </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.3. </font><font style="vertical-align: inherit;">Conteneurs standard</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous essayons de placer les instances </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans un conteneur standard, par exemple </font></font><code>std::vector&lt;X&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous verrons que nos fonctions ne sont pas utilisées pour allouer et libérer de la mémoire. </font><font style="vertical-align: inherit;">Le fait est que tous les conteneurs standard ont leur propre mécanisme d'allocation et de libération de mémoire (une classe d'allocateur spéciale, qui est un paramètre de modèle du conteneur), et ils utilisent un opérateur de placement pour initialiser les éléments </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.4. </font><font style="vertical-align: inherit;">Héritage</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les fonctions d'allocation et de libération de mémoire sont héritées. Si ces fonctions sont définies dans la classe de base, mais pas dans la classe dérivée, les opérateurs seront surchargés pour la classe dérivée </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et les fonctions définies et allouées dans la classe de base seront utilisées pour allouer et libérer de la mémoire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérons maintenant une hiérarchie de classes polymorphe, où chaque classe surcharge les opérateurs </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Maintenant, laissez l'instance de la classe dérivée supprimée à l'aide de l'opérateur </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">via un pointeur vers la classe de base. Si le destructeur de la classe de base est virtuel, la norme garantit que le destructeur de cette classe dérivée est appelé. Dans ce cas </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, l' </font><font style="vertical-align: inherit;">appel de fonction </font><font style="vertical-align: inherit;">défini pour cette classe dérivée </font><font style="vertical-align: inherit;">est également garanti </font><font style="vertical-align: inherit;">. Ainsi, la fonction est en </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">réalité virtuelle.</font></font><br>
<br>
<a name="id-2-2-5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.5. </font><font style="vertical-align: inherit;">Forme alternative de la fonction delete () de l'opérateur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans une classe (surtout quand l'héritage est utilisé), il est parfois pratique d'utiliser une forme alternative de la fonction pour libérer de la mémoire:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le paramètre </font></font><code>size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">définit la taille de l'élément (même dans la version du tableau). </font><font style="vertical-align: inherit;">Ce formulaire vous permet d'utiliser différentes fonctions pour allouer et libérer de la mémoire, selon la classe dérivée spécifique.</font></font><br>
<br>
<a name="id-3"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Opérateurs utilisateurs nouveaux / supprimés</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ peut prendre en charge les formulaires d'opérateur personnalisés de la </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forme suivante:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T[<span class="hljs-comment">/*   */</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour que ces formulaires soient pris en charge, il est nécessaire de déterminer les fonctions appropriées pour l'allocation et la libération de mémoire:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>);
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La liste des paramètres supplémentaires des fonctions d'allocation de mémoire ne doit pas être vide et ne doit pas consister en une </font></font><code>void*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>const std::nothrow_t&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui est, leur signature ne doit pas coïncider avec l' </font><font style="vertical-align: inherit;">un des standards. Liste des paramètres supplémentaires dans </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit correspondre. Les arguments transmis à l'opérateur </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doivent correspondre à des paramètres supplémentaires des fonctions d'allocation de mémoire. Une fonction personnalisée </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut également être dans le formulaire avec un paramètre de taille facultatif.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces fonctions peuvent être définies dans l'espace de noms global ou dans une classe, mais pas dans un espace de noms autre que global. S'ils sont définis dans l'espace de noms global, ils ne remplacent pas, mais surchargent, les fonctions standard d'allocation et de libération de mémoire, leur utilisation est donc prévisible et sûre, et les fonctions standard sont toujours disponibles. S'ils sont définis dans la classe, ils masquent les formulaires standard, mais l'accès aux formulaires standard peut être obtenu en utilisant l'opérateur </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, cela est décrit en détail dans la section 2.2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les </font><font style="vertical-align: inherit;">formulaires d' </font><font style="vertical-align: inherit;">opérateur </font><font style="vertical-align: inherit;">définis par l' </font><font style="vertical-align: inherit;">utilisateur </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont appelés </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emplacements définis par l'utilisateur </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ils ne doivent pas être confondus avec l'opérateur de placement standard (sans allocation) </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">décrit à la section 1.2.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le formulaire opérateur correspondant </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'existe pas. </font><font style="vertical-align: inherit;">Il </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existe deux façons de </font><font style="vertical-align: inherit;">supprimer un objet créé à l'aide d'un opérateur défini par l'utilisateur </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si une fonction définie par l'utilisateur </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">délègue une opération d'allocation de mémoire à des fonctions d'allocation de mémoire standard, un opérateur standard peut être utilisé </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sinon, vous devrez appeler explicitement le destructeur, puis la fonction définie par l'utilisateur </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Le compilateur appelle la fonction définie par l'utilisateur dans </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un seul cas: lorsque le </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constructeur lève une exception </font><font style="vertical-align: inherit;">pendant le fonctionnement de l'opérateur défini par l'utilisateur </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un exemple (de portée globale).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"new "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"delete "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;<font></font>
    ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> {</span><span class="hljs-comment">/* ... */</span>};<font></font>
X* p = <span class="hljs-keyword">new</span>(<span class="hljs-number">42</span>, <span class="hljs-string">"meow"</span>) X(); <span class="hljs-comment">// : new 42 + meow</span>
<span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//   ::operator delete()</span></code></pre><br>
<a name="id-4"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Définition des fonctions d'allocation de mémoire</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ces exemples, les fonctions utilisateur </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et les </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opérations déléguées correspondant aux fonctions standard. Parfois, cette option est utile, mais le but principal de la surcharge </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est de créer un nouveau mécanisme d'allocation / libération de mémoire. La tâche n'est pas simple et avant d'entreprendre, il faut bien réfléchir à tout. Scott Meyers [Meyers1] discute des motifs possibles pour prendre une telle décision (bien sûr, le principal est l'efficacité). Il discute également des principaux problèmes techniques liés à la mise en œuvre correcte des fonctions définies par l'utilisateur pour l'allocation et la libération de mémoire (en utilisant la fonction</font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, synchronisation multi-thread, alignement). </font><font style="vertical-align: inherit;">Guntheroth fournit un exemple de mise en œuvre de fonctions d'allocation de mémoire et de désallocation définies par l'utilisateur relativement simples. </font><font style="vertical-align: inherit;">Avant de créer votre propre version, vous devez rechercher des solutions prêtes à l'emploi, par exemple, vous pouvez apporter la bibliothèque Pool du projet Boost.</font></font><br>
<br>
<a name="id-5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Classes d'allocateurs de conteneurs standard</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme mentionné ci-dessus, les conteneurs standard utilisent des classes d'allocation spéciales pour allouer et libérer de la mémoire. </font><font style="vertical-align: inherit;">Ces classes sont des paramètres de modèle de conteneurs et l'utilisateur peut définir sa version d'une telle classe. </font><font style="vertical-align: inherit;">Les motifs d'une telle solution sont à peu près les mêmes que pour les opérateurs de surcharge </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">[Guntheroth] décrit comment créer de telles classes.</font></font><br>
<br>
<a name="id-refs"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliographie</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Guntheroth] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gunteroth, Kurt. </font><font style="vertical-align: inherit;">Optimisation des programmes en C ++. </font><font style="vertical-align: inherit;">Méthodes éprouvées pour augmenter la productivité.: Per. </font><font style="vertical-align: inherit;">de l'anglais </font><font style="vertical-align: inherit;">- SPb.: Alpha-book LLC, 2017. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Meyers1] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meyers, Scott. </font><font style="vertical-align: inherit;">Utilisation efficace de C ++. </font><font style="vertical-align: inherit;">55 façons sûres d'améliorer la structure et le code de vos programmes.: Per. </font><font style="vertical-align: inherit;">de l'anglais </font><font style="vertical-align: inherit;">- M .: DMK Press, 2014.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr490626/index.html">Un guide complet des attributs data- * HTML</a></li>
<li><a href="../fr490628/index.html">Que faire lorsque CSS bloque l'analyse des pages?</a></li>
<li><a href="../fr490630/index.html">Chargement de tableaux NumPy à partir du disque: comparaison de memmap () et Zarr / HDF5</a></li>
<li><a href="../fr490634/index.html">Événements numériques à Moscou du 2 au 8 mars</a></li>
<li><a href="../fr490636/index.html">Événements numériques à Saint-Pétersbourg du 2 au 8 mars</a></li>
<li><a href="../fr490642/index.html">Plugin pour la surveillance des applications K8s DevOpsProdigy KubeGraf v1.3.0: nouvelle version et nouvelles fonctionnalités</a></li>
<li><a href="../fr490644/index.html">Référentiel rpm simple utilisant Inotify et webdav</a></li>
<li><a href="../fr490648/index.html">Utilisation de conteneurs Kata dans Kubernetes</a></li>
<li><a href="../fr490650/index.html">Les principales erreurs dans la compilation d'un CV par des informaticiens débutants</a></li>
<li><a href="../fr490652/index.html">Logistique. introduction À peu près compliqué</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>