<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§πüèº üéá ‚òùüèæ Surcharge en C ++. Partie III. Surcharge des instructions new / delete üßñüèæ üëõ üßîüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous continuons la s√©rie "C ++, creuser en profondeur." Le but de cette s√©rie est d'en dire le plus possible sur les diff√©rentes caract√©ristiques du l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Surcharge en C ++. Partie III. Surcharge des instructions new / delete</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490640/"><hr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous continuons la s√©rie "C ++, creuser en profondeur." </font><font style="vertical-align: inherit;">Le but de cette s√©rie est d'en dire le plus possible sur les diff√©rentes caract√©ristiques du langage, peut-√™tre assez particuli√®res. </font><font style="vertical-align: inherit;">Cet article concerne la surcharge des op√©rateurs </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il s'agit du troisi√®me article de la s√©rie, le premier d√©di√© aux fonctions et mod√®les de surcharge, situ√© </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , le deuxi√®me d√©di√© aux op√©rateurs de surcharge, situ√© </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cet article conclut une s√©rie de trois articles sur la surcharge en C ++.</font></font><br>
<hr><a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table des mati√®res</font></font></h1><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table des mati√®res</font></font></b><div class="spoiler_text">&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.    new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.1.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.3.     </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.1.     </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.2.1.      new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.2.2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.2.3.  </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.2.4. </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.2.5.    operator delete()</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.   new/delete</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.    </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5. -  </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a><br>
</div></div><br>
<a name="id-1"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Formes standard des op√©rateurs nouveaux / supprim√©s</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ prend en charge plusieurs options d'op√©rateur </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ils peuvent √™tre divis√©s en standard de base, standard suppl√©mentaire et personnalis√©. </font><font style="vertical-align: inherit;">Cette section et la section 2 traitent des formulaires standard; les formulaires personnalis√©s seront abord√©s dans la section 3.</font></font><br>
<br>
<a name="id-1-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1. </font><font style="vertical-align: inherit;">Formulaires standard de base</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les principales formes standard d'op√©rateurs </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilis√©es pour cr√©er et supprimer un objet et un tableau du type sont </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les suivantes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span> T[<span class="hljs-comment">/*   */</span>]
<span class="hljs-keyword">delete</span> ptr;
<span class="hljs-keyword">delete</span>[] ptr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leur travail peut √™tre d√©crit comme suit. Lorsque l'op√©rateur est appel√© </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la m√©moire est d'abord allou√©e √† l'objet. Si la s√©lection r√©ussit, le constructeur est appel√©. Si le constructeur l√®ve une exception, la m√©moire allou√©e est lib√©r√©e. Lorsque l'op√©rateur est appel√©, </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tout se passe dans l'ordre inverse: d'abord, le destructeur est appel√©, puis la m√©moire est lib√©r√©e. Le destructeur ne doit pas lever d'exceptions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque l'op√©rateur</font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilis√©e pour cr√©er un tableau d'objets, la m√©moire est d'abord allou√©e √† l'ensemble du tableau. Si la s√©lection r√©ussit, le constructeur par d√©faut (ou un autre constructeur, s'il y a un initialiseur) est appel√© pour chaque √©l√©ment du tableau √† partir de z√©ro. Si un constructeur l√®ve une exception, alors pour tous les √©l√©ments cr√©√©s du tableau, le destructeur est appel√© dans l'ordre inverse de l'appel du constructeur, la m√©moire allou√©e est lib√©r√©e. Pour supprimer un tableau, vous devez appeler l'op√©rateur </font></font><code>delete[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et pour tous les √©l√©ments du tableau, le destructeur est appel√© dans l'ordre inverse du constructeur, puis la m√©moire allou√©e est lib√©r√©e. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Attention! Il est n√©cessaire d'appeler la bonne forme de l'op√©rateur</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selon si un seul objet ou un tableau est supprim√©. Cette r√®gle doit √™tre strictement respect√©e, sinon vous pouvez obtenir un comportement ind√©fini, c'est-√†-dire que tout peut arriver: fuites de m√©moire, crash, etc. Voir [Meyers1] pour plus de d√©tails. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la description ci-dessus, une clarification est n√©cessaire. Pour les soi-disant types triviaux (types int√©gr√©s, structures de style C), le constructeur par d√©faut ne peut pas √™tre appel√© et le destructeur ne fait en aucun cas quoi que ce soit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les fonctions d'allocation de m√©moire standard, lorsqu'il n'est pas possible de satisfaire la demande, l√®vent une exception de type </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mais cette exception peut √™tre intercept√©e, pour cela, vous devez installer un intercepteur global √† l'aide d'un appel de fonction </font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pour plus de d√©tails, voir [Meyers1]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toute forme d'op√©rateur</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appliquer en toute s√©curit√© au pointeur nul. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la cr√©ation d'un tableau avec un op√©rateur, la </font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">taille peut √™tre d√©finie sur z√©ro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les deux formes de l'op√©rateur </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permettent d'utiliser des initialiseurs dans les accolades.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>{<span class="hljs-number">42</span>}
<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">8</span>]{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>}</code></pre><br>
<a name="id-1-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2. </font><font style="vertical-align: inherit;">Formulaires standard suppl√©mentaires</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la connexion du fichier d'en-t√™te </font></font><code>&lt;new&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, 4 formulaires d'op√©rateur standard suppl√©mentaires sont disponibles </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(ptr) T(<span class="hljs-comment">/*  */</span>);
<span class="hljs-keyword">new</span>(ptr) T[<span class="hljs-comment">/*   */</span>];
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T(<span class="hljs-comment">/*   */</span>);
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T[<span class="hljs-comment">/*   */</span>];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les deux premiers d'entre eux sont appel√©s </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">placement sans allocation </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Un argument </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est un pointeur vers une r√©gion de m√©moire suffisamment grande pour contenir une instance ou un tableau. De plus, la zone de m√©moire doit avoir un alignement appropri√©. Cette version de l'op√©rateur </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'alloue pas de m√©moire, elle fournit uniquement un appel au constructeur. Ainsi, cette option vous permet de s√©parer les phases d'allocation de m√©moire et d'initialisation des objets. Cette fonctionnalit√© est activement utilis√©e dans les conteneurs standard. L'op√©rateur </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour les objets ainsi cr√©√©s ne peut bien entendu pas √™tre appel√©. Pour supprimer un objet, vous devez appeler directement le destructeur, puis lib√©rer la m√©moire d'une mani√®re qui d√©pend de la m√©thode d'allocation de m√©moire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les deux autres options sont appel√©es l'op√©rateur ne lan√ßant pas d'exceptions </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(nothrow </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) et diff√®rent en ce que s'il est impossible de satisfaire la demande, elles renvoient </font></font><code>nullptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais ne </font><font style="vertical-align: inherit;">l√®vent </font><font style="vertical-align: inherit;">pas d'exception de </font><font style="vertical-align: inherit;">type </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La suppression d'un objet se produit √† l'aide de l'op√©rateur principal </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ces options sont consid√©r√©es comme obsol√®tes et non recommand√©es.</font></font><br>
<br>
<a name="id-1-3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3. </font><font style="vertical-align: inherit;">Allocation de m√©moire et fonctions libres</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les op√©rateurs standard </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisent les fonctions d'allocation et de d√©sallocation suivantes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces fonctions sont d√©finies dans l'espace de noms global. </font><font style="vertical-align: inherit;">Les fonctions d'allocation de m√©moire pour les instructions host </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne font rien et retournent simplement </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 17 a pris en charge d'autres formes d'allocation de m√©moire et de d√©sallocation, indiquant l'alignement. </font><font style="vertical-align: inherit;">En voici quelques uns:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces formulaires ne sont pas directement accessibles √† l'utilisateur, ils sont utilis√©s par le compilateur pour des objets dont les exigences d'alignement sont sup√©rieures </font></font><code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, donc le principal probl√®me est que l'utilisateur ne les cache pas accidentellement (voir section 2.2.1). </font><font style="vertical-align: inherit;">Rappelons qu'en C ++ 11, il est devenu possible de d√©finir explicitement l'alignement des types d'utilisateurs.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">struct <span class="hljs-title">alignas</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span> X </span>{ <span class="hljs-comment">/* ... */</span> };</code></pre><br>
<a name="id-2"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Surcharger les formulaires standard des op√©rateurs nouveaux / supprimer</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La surcharge des formes standard d'op√©rateurs </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consiste √† d√©finir des fonctions d√©finies par l'utilisateur pour allouer et lib√©rer de la m√©moire dont les signatures co√Øncident avec celles standard. </font><font style="vertical-align: inherit;">Ces fonctions peuvent √™tre d√©finies dans l'espace de noms global ou dans une classe, mais pas dans un espace de noms autre que global. </font><font style="vertical-align: inherit;">La fonction d'allocation de m√©moire pour une instruction h√¥te standard </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne peut pas √™tre d√©finie dans l'espace de noms global. </font><font style="vertical-align: inherit;">Apr√®s une telle d√©finition, les op√©rateurs correspondants </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les utiliseront, pas les </font><font style="vertical-align: inherit;">op√©rateurs </font><font style="vertical-align: inherit;">standard.</font></font><br>
<br>
<a name="id-2-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1. </font><font style="vertical-align: inherit;">Surcharge dans l'espace de noms global</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons, par exemple, dans un module dans un espace de noms global que des fonctions d√©finies par l'utilisateur soient d√©finies:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
</span>{
<span class="hljs-comment">// ...</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, il y aura en fait un remplacement (remplacement) des fonctions standard pour allouer et lib√©rer de la m√©moire pour tous les appels d'op√©rateur </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour toutes les classes (y compris les classes standard) dans le module entier. Cela peut conduire au chaos complet. Notez que le m√©canisme de substitution d√©crit est un m√©canisme sp√©cial impl√©ment√© uniquement pour ce cas, et non un m√©canisme C ++ g√©n√©ral. Dans ce cas, lors de l'impl√©mentation des fonctions utilisateur d'allocation et de lib√©ration de m√©moire, il devient impossible d'appeler les fonctions standard correspondantes, elles sont compl√®tement masqu√©es (l'op√©rateur </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'aide pas), et lorsque vous essayez de les appeler, un appel r√©cursif √† la fonction utilisateur se produit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fonction d√©finie par l'espace de noms global</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il remplacera √©galement le standard, mais il y aura moins de probl√®mes potentiels, car l'op√©rateur qui ne lance pas d'exceptions </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est rarement utilis√©. </font><font style="vertical-align: inherit;">Mais le formulaire standard n'est pas non plus disponible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La m√™me situation avec des fonctions pour les tableaux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La surcharge des instructions </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans l'espace de noms global est fortement d√©conseill√©e.</font></font><br>
<br>
<a name="id-2-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2. </font><font style="vertical-align: inherit;">Surcharge de classe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La surcharge des op√©rateurs </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans une classe est d√©pourvue des inconv√©nients d√©crits ci-dessus. </font><font style="vertical-align: inherit;">La surcharge n'est efficace que lors de la cr√©ation et de la suppression d'instances de la classe correspondante, quel que soit le contexte d'appel des op√©rateurs </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lorsque vous impl√©mentez des fonctions d√©finies par l'utilisateur pour allouer et lib√©rer de la m√©moire √† l'aide de l'op√©rateur, </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous pouvez acc√©der aux fonctions standard correspondantes. </font><font style="vertical-align: inherit;">Prenons un exemple.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span>
{</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete\n"</span>;<font></font>
        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(ptr)</span></span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new[]\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete[]\n"</span>;<font></font>
        ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](ptr);<font></font>
    }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet exemple, le suivi est simplement ajout√© aux op√©rations standard. </font><font style="vertical-align: inherit;">Maintenant, en termes </font></font><code>new X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>new X[N]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliser ces fonctions pour allouer et lib√©rer de la m√©moire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces fonctions sont formellement statiques et peuvent √™tre d√©clar√©es comme </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais pour l'essentiel, ce sont des instances, avec l'appel de fonction </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la cr√©ation de l'instance commence et l'appel de fonction </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">termine sa suppression. </font><font style="vertical-align: inherit;">Ces fonctions ne sont jamais appel√©es pour d'autres t√¢ches. </font><font style="vertical-align: inherit;">De plus, comme cela sera montr√© ci-dessous, la fonction </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est essentiellement virtuelle. </font><font style="vertical-align: inherit;">Il est donc plus correct de les d√©clarer sans </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.1. </font><font style="vertical-align: inherit;">Acc√®s aux formulaires standard des op√©rateurs nouveaux / supprim√©s</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les op√©rateurs </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peuvent √™tre utilis√©s avec un op√©rateur de r√©solution d'√©tendue suppl√©mentaire, par exemple </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans ce cas, la fonction </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©finie dans la classe sera ignor√©e et la norme correspondante sera utilis√©e. </font><font style="vertical-align: inherit;">De la m√™me mani√®re, vous pouvez utiliser l'op√©rateur </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.2. </font><font style="vertical-align: inherit;">Masquage d'autres formes d'op√©rateurs nouveaux / supprim√©s</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si maintenant, pour la classe, </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous essayons d'utiliser des exceptions de lancement ou de non-lancement </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous obtenons une erreur. </font><font style="vertical-align: inherit;">Le fait est que la fonction </font></font><code>operator new(std::size_t size)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masquera d'autres formes </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Le probl√®me peut √™tre r√©solu de deux mani√®res. </font><font style="vertical-align: inherit;">Dans le premier, vous devez ajouter les options appropri√©es √† la classe (ces options devraient simplement d√©l√©guer le fonctionnement de la fonction standard). </font><font style="vertical-align: inherit;">Dans le second, vous devez utiliser un op√©rateur </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec un op√©rateur de r√©solution de port√©e, par exemple </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.3. </font><font style="vertical-align: inherit;">Conteneurs standard</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous essayons de placer les instances </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans un conteneur standard, par exemple </font></font><code>std::vector&lt;X&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous verrons que nos fonctions ne sont pas utilis√©es pour allouer et lib√©rer de la m√©moire. </font><font style="vertical-align: inherit;">Le fait est que tous les conteneurs standard ont leur propre m√©canisme d'allocation et de lib√©ration de m√©moire (une classe d'allocateur sp√©ciale, qui est un param√®tre de mod√®le du conteneur), et ils utilisent un op√©rateur de placement pour initialiser les √©l√©ments </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.4. </font><font style="vertical-align: inherit;">H√©ritage</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les fonctions d'allocation et de lib√©ration de m√©moire sont h√©rit√©es. Si ces fonctions sont d√©finies dans la classe de base, mais pas dans la classe d√©riv√©e, les op√©rateurs seront surcharg√©s pour la classe d√©riv√©e </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et les fonctions d√©finies et allou√©es dans la classe de base seront utilis√©es pour allouer et lib√©rer de la m√©moire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consid√©rons maintenant une hi√©rarchie de classes polymorphe, o√π chaque classe surcharge les op√©rateurs </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Maintenant, laissez l'instance de la classe d√©riv√©e supprim√©e √† l'aide de l'op√©rateur </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">via un pointeur vers la classe de base. Si le destructeur de la classe de base est virtuel, la norme garantit que le destructeur de cette classe d√©riv√©e est appel√©. Dans ce cas </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, l' </font><font style="vertical-align: inherit;">appel de fonction </font><font style="vertical-align: inherit;">d√©fini pour cette classe d√©riv√©e </font><font style="vertical-align: inherit;">est √©galement garanti </font><font style="vertical-align: inherit;">. Ainsi, la fonction est en </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©alit√© virtuelle.</font></font><br>
<br>
<a name="id-2-2-5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.5. </font><font style="vertical-align: inherit;">Forme alternative de la fonction delete () de l'op√©rateur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans une classe (surtout quand l'h√©ritage est utilis√©), il est parfois pratique d'utiliser une forme alternative de la fonction pour lib√©rer de la m√©moire:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le param√®tre </font></font><code>size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©finit la taille de l'√©l√©ment (m√™me dans la version du tableau). </font><font style="vertical-align: inherit;">Ce formulaire vous permet d'utiliser diff√©rentes fonctions pour allouer et lib√©rer de la m√©moire, selon la classe d√©riv√©e sp√©cifique.</font></font><br>
<br>
<a name="id-3"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Op√©rateurs utilisateurs nouveaux / supprim√©s</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ peut prendre en charge les formulaires d'op√©rateur personnalis√©s de la </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forme suivante:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T[<span class="hljs-comment">/*   */</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour que ces formulaires soient pris en charge, il est n√©cessaire de d√©terminer les fonctions appropri√©es pour l'allocation et la lib√©ration de m√©moire:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>);
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La liste des param√®tres suppl√©mentaires des fonctions d'allocation de m√©moire ne doit pas √™tre vide et ne doit pas consister en une </font></font><code>void*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>const std::nothrow_t&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui est, leur signature ne doit pas co√Øncider avec l' </font><font style="vertical-align: inherit;">un des standards. Liste des param√®tres suppl√©mentaires dans </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit correspondre. Les arguments transmis √† l'op√©rateur </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doivent correspondre √† des param√®tres suppl√©mentaires des fonctions d'allocation de m√©moire. Une fonction personnalis√©e </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut √©galement √™tre dans le formulaire avec un param√®tre de taille facultatif.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces fonctions peuvent √™tre d√©finies dans l'espace de noms global ou dans une classe, mais pas dans un espace de noms autre que global. S'ils sont d√©finis dans l'espace de noms global, ils ne remplacent pas, mais surchargent, les fonctions standard d'allocation et de lib√©ration de m√©moire, leur utilisation est donc pr√©visible et s√ªre, et les fonctions standard sont toujours disponibles. S'ils sont d√©finis dans la classe, ils masquent les formulaires standard, mais l'acc√®s aux formulaires standard peut √™tre obtenu en utilisant l'op√©rateur </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, cela est d√©crit en d√©tail dans la section 2.2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les </font><font style="vertical-align: inherit;">formulaires d' </font><font style="vertical-align: inherit;">op√©rateur </font><font style="vertical-align: inherit;">d√©finis par l' </font><font style="vertical-align: inherit;">utilisateur </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont appel√©s </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emplacements d√©finis par l'utilisateur </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ils ne doivent pas √™tre confondus avec l'op√©rateur de placement standard (sans allocation) </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©crit √† la section 1.2.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le formulaire op√©rateur correspondant </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'existe pas. </font><font style="vertical-align: inherit;">Il </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existe deux fa√ßons de </font><font style="vertical-align: inherit;">supprimer un objet cr√©√© √† l'aide d'un op√©rateur d√©fini par l'utilisateur </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si une fonction d√©finie par l'utilisateur </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©l√®gue une op√©ration d'allocation de m√©moire √† des fonctions d'allocation de m√©moire standard, un op√©rateur standard peut √™tre utilis√© </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sinon, vous devrez appeler explicitement le destructeur, puis la fonction d√©finie par l'utilisateur </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Le compilateur appelle la fonction d√©finie par l'utilisateur dans </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un seul cas: lorsque le </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constructeur l√®ve une exception </font><font style="vertical-align: inherit;">pendant le fonctionnement de l'op√©rateur d√©fini par l'utilisateur </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un exemple (de port√©e globale).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"new "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"delete "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;<font></font>
    ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> {</span><span class="hljs-comment">/* ... */</span>};<font></font>
X* p = <span class="hljs-keyword">new</span>(<span class="hljs-number">42</span>, <span class="hljs-string">"meow"</span>) X(); <span class="hljs-comment">// : new 42 + meow</span>
<span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//   ::operator delete()</span></code></pre><br>
<a name="id-4"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. D√©finition des fonctions d'allocation de m√©moire</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ces exemples, les fonctions utilisateur </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et les </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">op√©rations d√©l√©gu√©es correspondant aux fonctions standard. Parfois, cette option est utile, mais le but principal de la surcharge </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est de cr√©er un nouveau m√©canisme d'allocation / lib√©ration de m√©moire. La t√¢che n'est pas simple et avant d'entreprendre, il faut bien r√©fl√©chir √† tout. Scott Meyers [Meyers1] discute des motifs possibles pour prendre une telle d√©cision (bien s√ªr, le principal est l'efficacit√©). Il discute √©galement des principaux probl√®mes techniques li√©s √† la mise en ≈ìuvre correcte des fonctions d√©finies par l'utilisateur pour l'allocation et la lib√©ration de m√©moire (en utilisant la fonction</font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, synchronisation multi-thread, alignement). </font><font style="vertical-align: inherit;">Guntheroth fournit un exemple de mise en ≈ìuvre de fonctions d'allocation de m√©moire et de d√©sallocation d√©finies par l'utilisateur relativement simples. </font><font style="vertical-align: inherit;">Avant de cr√©er votre propre version, vous devez rechercher des solutions pr√™tes √† l'emploi, par exemple, vous pouvez apporter la biblioth√®que Pool du projet Boost.</font></font><br>
<br>
<a name="id-5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Classes d'allocateurs de conteneurs standard</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme mentionn√© ci-dessus, les conteneurs standard utilisent des classes d'allocation sp√©ciales pour allouer et lib√©rer de la m√©moire. </font><font style="vertical-align: inherit;">Ces classes sont des param√®tres de mod√®le de conteneurs et l'utilisateur peut d√©finir sa version d'une telle classe. </font><font style="vertical-align: inherit;">Les motifs d'une telle solution sont √† peu pr√®s les m√™mes que pour les op√©rateurs de surcharge </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">[Guntheroth] d√©crit comment cr√©er de telles classes.</font></font><br>
<br>
<a name="id-refs"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliographie</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Guntheroth] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gunteroth, Kurt. </font><font style="vertical-align: inherit;">Optimisation des programmes en C ++. </font><font style="vertical-align: inherit;">M√©thodes √©prouv√©es pour augmenter la productivit√©.: Per. </font><font style="vertical-align: inherit;">de l'anglais </font><font style="vertical-align: inherit;">- SPb.: Alpha-book LLC, 2017. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Meyers1] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meyers, Scott. </font><font style="vertical-align: inherit;">Utilisation efficace de C ++. </font><font style="vertical-align: inherit;">55 fa√ßons s√ªres d'am√©liorer la structure et le code de vos programmes.: Per. </font><font style="vertical-align: inherit;">de l'anglais </font><font style="vertical-align: inherit;">- M .: DMK Press, 2014.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr490626/index.html">Un guide complet des attributs data- * HTML</a></li>
<li><a href="../fr490628/index.html">Que faire lorsque CSS bloque l'analyse des pages?</a></li>
<li><a href="../fr490630/index.html">Chargement de tableaux NumPy √† partir du disque: comparaison de memmap () et Zarr / HDF5</a></li>
<li><a href="../fr490634/index.html">√âv√©nements num√©riques √† Moscou du 2 au 8 mars</a></li>
<li><a href="../fr490636/index.html">√âv√©nements num√©riques √† Saint-P√©tersbourg du 2 au 8 mars</a></li>
<li><a href="../fr490642/index.html">Plugin pour la surveillance des applications K8s DevOpsProdigy KubeGraf v1.3.0: nouvelle version et nouvelles fonctionnalit√©s</a></li>
<li><a href="../fr490644/index.html">R√©f√©rentiel rpm simple utilisant Inotify et webdav</a></li>
<li><a href="../fr490648/index.html">Utilisation de conteneurs Kata dans Kubernetes</a></li>
<li><a href="../fr490650/index.html">Les principales erreurs dans la compilation d'un CV par des informaticiens d√©butants</a></li>
<li><a href="../fr490652/index.html">Logistique. introduction √Ä peu pr√®s compliqu√©</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>