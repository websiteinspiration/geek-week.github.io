<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧙🏻 👍🏽 🎼 Kisah bagaimana membuat mesin waktu untuk database dan secara tidak sengaja menulis exploit 🈶 👨🏾‍🎨 🦆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat siang, Habr. 
 
 Pernahkah Anda bertanya-tanya bagaimana cara mengubah waktu di dalam database? Mudah? Ya, dalam beberapa kasus, ya, itu mudah...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kisah bagaimana membuat mesin waktu untuk database dan secara tidak sengaja menulis exploit</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503804/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selamat siang, Habr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pernahkah Anda bertanya-tanya bagaimana cara mengubah waktu di dalam database? </font><font style="vertical-align: inherit;">Mudah? </font><font style="vertical-align: inherit;">Ya, dalam beberapa kasus, ya, itu mudah - perintah tanggal linux dan masalahnya sudah siap. </font><font style="vertical-align: inherit;">Dan jika Anda perlu mengubah waktu hanya di dalam satu contoh dari database jika ada beberapa dari mereka di server? </font><font style="vertical-align: inherit;">Dan untuk satu proses basis data? </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DAN? </font><font style="vertical-align: inherit;">Eh, itu dia, temanku, itu intinya.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seseorang akan mengatakan bahwa ini adalah sur lain, tidak terkait dengan kenyataan, yang secara berkala dituangkan pada Habré. </font><font style="vertical-align: inherit;">Tapi tidak, tugasnya cukup nyata dan ditentukan oleh kebutuhan produksi - pengujian kode. </font><font style="vertical-align: inherit;">Meskipun saya setuju, test case ini bisa sangat eksotis - periksa bagaimana kode berperilaku untuk tanggal tertentu di masa depan. </font><font style="vertical-align: inherit;">Pada artikel ini, saya akan memeriksa secara rinci bagaimana tugas ini diselesaikan, dan pada saat yang sama menangkap sedikit proses pengorganisasian tes dan dev singkatan dari basis Oracle. </font><font style="vertical-align: inherit;">Menjelang bacaan yang panjang, merasa nyaman dan minta kucing.</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latar Belakang</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita mulai dengan pengantar singkat untuk menunjukkan mengapa ini perlu. Seperti yang sudah diumumkan, kami menulis tes saat menerapkan pengeditan di database. Sistem di mana tes ini dilakukan dikembangkan pada awal (atau mungkin sedikit sebelum awal) dari nol, jadi semua logika bisnis ada di dalam database dan ditulis dalam bentuk prosedur tersimpan dalam bahasa pl / sql. Dan ya, itu membawa kita kesakitan dan penderitaan. Tetapi ini adalah warisan, dan Anda harus hidup dengannya. Dalam kode dan model tabular, dimungkinkan untuk menentukan bagaimana parameter di dalam sistem berevolusi dari waktu ke waktu, dengan kata lain, mengatur aktivitas dari tanggal mana dan tanggal berapa mereka dapat diterapkan. Apa yang harus dilakukan jauh - perubahan terbaru dalam tingkat PPN adalah contoh nyata dari ini. Dan agar perubahan dalam sistem dapat diperiksa terlebih dahulu,database dengan perubahan tersebut perlu ditransfer ke tanggal tertentu di masa mendatang, parameter kode dalam tabel akan menjadi aktif pada "saat ini". Dan karena spesifik dari sistem yang didukung, Anda tidak dapat menggunakan tes tiruan yang hanya akan mengubah nilai kembali dari tanggal sistem saat ini dalam bahasa ketika sesi tes dimulai.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, kami menentukan alasannya, maka kami perlu menentukan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bagaimana</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tujuan </font><i><font style="vertical-align: inherit;">itu</font></i><font style="vertical-align: inherit;"> tercapai. </font><font style="vertical-align: inherit;">Untuk melakukan ini, saya akan membuat sedikit retrospektif dari opsi untuk membangun bangku tes untuk pengembang dan bagaimana setiap sesi tes dimulai.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jaman Batu</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dahulu kala, ketika pohon-pohon kecil, dan mainframe besar, hanya ada 1 server untuk pengembangan dan juga sedang melakukan tes. </font><font style="vertical-align: inherit;">Dan pada prinsipnya, semua ini sudah cukup untuk semua orang ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">640K sudah cukup untuk semua orang!</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kontra: untuk tugas mengubah waktu, perlu melibatkan banyak departemen terkait - administrator sistem (melakukan perubahan waktu pada subd server dari root), administrator DBMS (melakukan restart database), programmer ( perlu untuk memberi tahu bahwa perubahan waktu akan terjadi, karena bagian dari kode berhenti bekerja, misalnya, token web yang sebelumnya dikeluarkan untuk memanggil metode api tidak lagi valid dan ini bisa mengejutkan, penguji (menguji sendiri) ... Ketika Anda mengembalikan waktu ke saat ini semuanya diulang dalam urutan terbalik.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abad Pertengahan</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seiring waktu, jumlah pengembang di departemen bertambah dan pada beberapa titik 1 server tidak lagi mencukupi. Terutama karena kenyataan bahwa pengembang yang berbeda ingin mengubah paket pl / sql yang sama dan melakukan pengujian untuk itu (bahkan tanpa mengubah waktu). Semakin banyak kemarahan terdengar: "Berapa lama! Cukup mentolerir ini! Pabrik untuk pekerja, tanah untuk petani! Setiap programmer memiliki database! " Namun, jika Anda memiliki beberapa terabyte basis data produk, dan 50-100 pengembang, maka jujur ​​dalam bentuk ini, persyaratannya tidak terlalu nyata. Dan masih semua orang ingin tes dan basis dev tidak ketinggalan jauh di belakang penjualan, baik dalam struktur dan data di dalam tabel. Jadi ada server terpisah untuk pengujian, sebut saja pra-produksi. Itu dibangun dari 2 server yang identik,di mana penjualan dilakukan untuk memulihkan database dari dolar RMAN dan butuh sekitar 2-2,5 hari. Setelah pemulihan, database membuat anonimisasi data pribadi dan penting lainnya dan beban dari aplikasi pengujian diterapkan ke server ini (dan juga programmer sendiri selalu bekerja dengan server yang baru saja dipulihkan). Pekerjaan dengan server yang diperlukan dipastikan menggunakan cluster ip-resource yang didukung melalui corosync (alat pacu jantung). Ketika semua orang bekerja dengan server aktif, pada simpul ke-2, pemulihan basis data dimulai lagi dan setelah 2-3 hari mereka kembali mengubah tempat.Pekerjaan dengan server yang diperlukan dipastikan menggunakan cluster ip-resource yang didukung melalui corosync (alat pacu jantung). Ketika semua orang bekerja dengan server aktif, pada simpul ke-2, pemulihan basis data dimulai lagi dan setelah 2-3 hari mereka kembali mengubah tempat.Pekerjaan dengan server yang diperlukan dipastikan menggunakan cluster ip-resource yang didukung melalui corosync (alat pacu jantung). Ketika semua orang bekerja dengan server aktif, pada simpul ke-2, pemulihan basis data dimulai lagi dan setelah 2-3 hari mereka kembali mengubah tempat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dari kekurangan yang jelas: Anda membutuhkan 2 server dan sumber daya 2 kali lebih banyak (terutama disk) daripada prod. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelebihan: operasi perubahan waktu dan pengujian - ini dapat dilakukan pada server ke-2, pada server utama saat ini pengembang tinggal dan menjalankan bisnis mereka. </font><font style="vertical-align: inherit;">Perubahan server hanya terjadi ketika database siap, dan waktu henti lingkungan pengujian minimal.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Era kemajuan ilmiah dan teknologi</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika kami beralih ke database 11g Release 2, kami membaca tentang teknologi menarik yang disediakan Oracle dengan nama CloneDB. Intinya adalah bahwa pencadangan basis data produk (ada salinan bit langsung dari file data produk) disimpan di server khusus, yang kemudian menerbitkan kumpulan file data ini melalui DNFS (NFS langsung) pada dasarnya sejumlah server, dan Anda tidak perlu memilikinya di server volume disk yang sama, karena pendekatan Copy-On-Write diimplementasikan: database menggunakan jaringan berbagi dengan file data dari server cadangan untuk membaca data dalam tabel, dan perubahan ditulis ke file data lokal di server dev itu sendiri. Secara berkala, "zeroing the deadline" dilakukan untuk server sehingga file data lokal tidak bertambah banyak dan tempat itu tidak berakhir. Saat memperbarui server, data juga direpersonalisasikan dalam tabel,dalam hal ini, semua pembaruan tabel jatuh ke file data lokal dan tabel tersebut dibaca dari server lokal, semua tabel lainnya dibaca melalui jaringan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cons: masih ada 2 server (untuk memastikan pembaruan lancar dengan downtime minimal untuk konsumen), tetapi sekarang volume disk sangat berkurang. Untuk menyimpan dolar pada bola nfs, Anda memerlukan 1 server lebih banyak dalam ukuran + - sebagai sebuah produk, tetapi waktu pelaksanaan pembaruan itu sendiri berkurang (terutama saat menggunakan dolar tambahan). Jaringan dengan bola nfs secara nyata memperlambat operasi baca IO. Untuk menggunakan teknologi CloneDB, pangkalan haruslah Edisi Perusahaan, dalam kasus kami, kami harus melakukan prosedur peningkatan pada basis pengujian setiap kali. Untungnya, basis data pengujian dikecualikan dari kebijakan lisensi Oracle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pro: operasi untuk memulihkan basis dari bakup membutuhkan waktu kurang dari 1 hari (saya tidak ingat waktu yang tepat).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perubahan waktu: tidak ada perubahan besar. </font><font style="vertical-align: inherit;">Meskipun saat ini skrip sudah dibuat untuk mengubah waktu di server dan me-restart database untuk melakukan ini tanpa menarik </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perhatian para petugas</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> administrasi.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Era Sejarah Baru</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menghemat ruang disk lebih banyak dan membuat pembacaan data offline, kami memutuskan untuk mengimplementasikan versi CloneDB kami (dengan flashback dan snapshots) menggunakan sistem file dengan kompresi. </font><font style="vertical-align: inherit;">Selama tes pendahuluan, pilihan jatuh pada ZFS, meskipun tidak ada dukungan resmi untuk itu di kernel Linux (kutipan dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Sebagai perbandingan, kami juga melihat BTRFS (b-tree fs), yang dipromosikan Oracle, tetapi rasio kompresi kurang dengan konsumsi CPU dan RAM yang sama dalam pengujian. Untuk mengaktifkan dukungan ZFS pada RHEL5, kernelnya sendiri yang berbasis pada UEK (kernel perusahaan yang tidak bisa dipecahkan) dibangun, dan pada kapak dan kernel yang lebih baru Anda cukup menggunakan kernel UEK yang sudah jadi. Implementasi dari basis tes tersebut juga didasarkan pada mekanisme SAP, tetapi pada tingkat snapshot sistem file. 2 perangkat disk dipasok ke server, di satu, zfs pool dibuat, di mana melalui RMAN database siaga tambahan dibuat dari penjualan, dan karena kami menggunakan kompresi, partisi tersebut memakan waktu kurang dari produksi.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sistem diinstal pada perangkat disk kedua dan sisanya diperlukan agar server dan database itu sendiri berfungsi, misalnya, partisi untuk undo dan temp. Kapan saja, Anda dapat membuat snapshot dari kumpulan zfs, yang kemudian dibuka sebagai basis data terpisah. Membuat snapshot membutuhkan beberapa detik. Itu ajaib! Dan basis data semacam itu dapat dimiringkan pada prinsipnya cukup banyak, jika saja server memiliki cukup RAM untuk semua contoh dan ukuran kumpulan zfs itu sendiri (untuk menyimpan perubahan dalam file data selama depersonalisasi dan selama siklus hidup klon basis data). Waktu utama untuk memperbarui basis tes adalah pengoperasian depersonalisasi data, tetapi juga cocok dalam 15-20 menit. Ada akselerasi yang signifikan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kekurangan: pada server Anda tidak dapat mengubah waktu hanya dengan menerjemahkan waktu sistem, karena semua instance database yang berjalan di server ini akan jatuh ke dalam waktu ini sekaligus. Solusi untuk masalah ini telah ditemukan dan akan dijelaskan di bagian yang sesuai. Ke depan, saya akan mengatakan bahwa itu memungkinkan Anda untuk mengubah waktu hanya dalam 1 instance dari database ( </font><i><font style="vertical-align: inherit;">per contoh</font></i><font style="vertical-align: inherit;"> pendekatan waktu perubahan</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) tanpa mempengaruhi sisanya pada server yang sama. </font><font style="vertical-align: inherit;">Dan waktu di server itu sendiri tidak berubah. </font><font style="vertical-align: inherit;">Ini menghilangkan kebutuhan untuk skrip root untuk mengubah waktu di server. </font><font style="vertical-align: inherit;">Juga pada tahap ini, otomatisasi perubahan waktu untuk contoh melalui Jenkins CI diimplementasikan dan pengguna (tim pengembangan yang relatif berbicara) yang memiliki stan mereka diberikan hak untuk pekerjaan yang mereka dapat ubah waktu, perbarui stan ke keadaan saat ini dengan penjualan, buat snapshot dan restorasi (rollback) dari pangkalan ke snapshot yang dibuat sebelumnya.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Era Sejarah Terakhir</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan hadirnya Oracle 12c, muncul teknologi baru - basis data yang dapat dicolokkan dan, sebagai hasilnya, basis data kontainer (cdb). Dengan teknologi ini, dalam satu instance fisik, beberapa basis data "virtual" dapat dibuat yang berbagi area memori umum dari instance tersebut. Kelebihan: Anda dapat menghemat memori untuk server (dan meningkatkan kinerja keseluruhan basis data kami, karena semua memori yang ditempati sebelumnya, misalnya, 5 contoh berbeda, dapat dibagi untuk semua wadah pdb yang digunakan di dalam cdb, dan mereka hanya akan menggunakannya ketika mereka benar-benar membutuhkannya, dan tidak seperti pada fase sebelumnya, ketika setiap contoh "diblokir" memori dialokasikan untuk itu sendiri dan ketika aktivitas salah satu klon rendah, memori tidak digunakan secara efektif, dengan kata lain, itu menganggur).File data dari pdb berbeda masih terletak di kumpulan zfs, dan ketika menggunakan klon, mereka menggunakan mekanisme snapshot zfs yang sama. Pada tahap ini, kami mendekati kemampuan untuk memberikan hampir setiap pengembang database mereka sendiri. Mengubah waktu pada tahap ini tidak memerlukan restart database dan bekerja sangat akurat hanya untuk proses-proses yang membutuhkan perubahan waktu, semua pengguna lain yang bekerja dengan database ini tidak terpengaruh sama sekali.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Minus: Anda tidak dapat menggunakan pendekatan perubahan waktu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">per instance</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari fase sebelumnya, karena kami memiliki satu instance sekarang. Namun, solusi untuk kasus ini ditemukan. Dan justru inilah yang menjadi dorongan untuk menulis artikel ini. Ke depan, saya akan mengatakan bahwa ini adalah perubahan waktu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">per</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pendekatan </font><i><font style="vertical-align: inherit;">proses</font></i><font style="vertical-align: inherit;"> yaitu. dalam setiap proses basis data, Anda dapat mengatur waktu unik Anda sendiri secara umum.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus ini, sesi pengujian yang khas segera setelah terhubung ke database menetapkan waktu yang tepat di awal pekerjaannya, melakukan tes dan mengembalikan waktu kembali di akhir. Mengembalikan waktu diperlukan untuk satu alasan sederhana: beberapa proses basis data Oracle tidak berakhir ketika klien basis data terputus dari server, ini adalah proses server yang disebut shared server, yang, tidak seperti proses khusus, berjalan ketika server basis data mulai dan hidup hampir tanpa batas (dalam kondisi ideal) gambar dunia). Jika Anda membiarkan waktu berubah dalam proses server seperti itu, maka koneksi lain yang akan dilayani dalam proses ini akan menerima waktu yang salah.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam sistem kami, server bersama banyak digunakan, karena hingga 11g praktis tidak ada solusi yang memadai bagi sistem kami untuk menahan beban tinggi (dalam 11g DRCP muncul - pengumpulan koneksi penduduk basis data). Dan inilah alasannya - dalam sub ada batasan pada jumlah total proses server yang dapat dibuat dalam mode khusus dan bersama. Proses khusus dihasilkan lebih lambat daripada database dapat mengeluarkan proses berbagi yang sudah siap dari kumpulan proses bersama, yang berarti bahwa ketika koneksi baru terus-menerus datang (terutama jika proses melakukan beberapa operasi lambat lainnya), jumlah total proses akan meningkat. Ketika batas sesi / proses tercapai, basis data berhenti untuk melayani koneksi baru dan runtuh terjadi.Transisi ke penggunaan kumpulan proses bersama memungkinkan kami untuk mengurangi jumlah proses baru di server saat menghubungkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di situlah peninjauan teknologi untuk membangun database uji selesai, dan kami akhirnya dapat mulai menerapkan algoritma perubahan-waktu untuk database itu sendiri.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendekatan per instance palsu</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana cara mengubah waktu di dalam database? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal pertama yang terlintas dalam pikiran adalah membuat skema yang berisi semua kode logika bisnis, fungsinya sendiri, yang tumpang tindih dengan fungsi bahasa yang bekerja dengan waktu (sysdate, current_date, dll.) Dan dalam kondisi tertentu mulai memberikan nilai-nilai lain, misalnya, ia bisa set nilai melalui konteks sesi di awal uji coba. Itu tidak berhasil, fungsi bahasa built-in tidak tumpang tindih dengan yang pengguna. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian, sistem virtualisasi ringan (Vserver, OpenVZ) dan kontainerisasi melalui buruh pelabuhan diuji. Tidak juga berfungsi, mereka menggunakan kernel yang sama dengan sistem host, yang berarti mereka menggunakan nilai pengatur waktu sistem yang sama. Jatuh lagi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan di sini saya tidak takut untuk menyelamatkan kata ini, sebuah penemuan cemerlang dari dunia Linux - redefinisi / intersepsi fungsi pada tahap pemuatan dinamis objek yang dibagikan. Ini dikenal banyak orang sebagai trik dengan LD_PRELOAD. Dalam variabel lingkungan LD_PRELOAD, Anda bisa menentukan pustaka yang akan memuat sebelum semua yang lain yang dibutuhkan proses, dan jika pustaka ini memiliki karakter dengan nama yang sama seperti misalnya dalam libc standar, yang akan dimuat nanti, maka tabel impor simbol untuk aplikasi akan terlihat seperti apakah fungsi tersebut menyediakan modul pengganti kami. Dan itulah yang </font><i><font style="vertical-align: inherit;">dilakukan</font></i><font style="vertical-align: inherit;"> perpustakaan proyek </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libfaketime</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang kami mulai gunakan untuk memulai database pada waktu yang berbeda secara terpisah dari sistem. Perpustakaan melewatkan panggilan yang berhubungan dengan timer sistem dan mendapatkan waktu dan tanggal sistem. Untuk mengontrol berapa banyak waktu bergerak relatif ke tanggal server saat ini atau dari titik waktu waktu harus masuk ke dalam proses - semuanya dikendalikan oleh variabel lingkungan yang harus ditetapkan bersama dengan LD_PRELOAD. Untuk mengimplementasikan perubahan waktu, kami mengimplementasikan pekerjaan di server Jenkins, yang memasuki server database dan me-restart DBMS baik dengan atau tanpa variabel lingkungan yang ditetapkan untuk libfaketime. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh algoritma untuk memulai database dengan waktu penggantian:</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-built_in">export</span> LD_PRELOAD=/usr/<span class="hljs-built_in">local</span>/lib/faketime/libfaketime.so
<span class="hljs-built_in">export</span> FAKETIME=<span class="hljs-string">"+1d"</span>
<span class="hljs-built_in">export</span> FAKETIME_NO_CACHE=1<font></font>
<font></font>
<span class="hljs-variable">$ORACLE_HOME</span>/bin/sqlplus @/home/oracle/scripts/restart_db.sql
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan jika Anda berpikir bahwa semuanya bekerja segera, maka Anda salah besar. </font><font style="vertical-align: inherit;">Karena, ternyata, memvalidasi pustaka yang dimuat ke dalam proses ketika DBMS dimulai. </font><font style="vertical-align: inherit;">Dan di log peringatan, ia mulai membenci pemalsuan yang diketahui, sementara pangkalan tidak dimulai. </font><font style="vertical-align: inherit;">Sekarang saya tidak ingat persis bagaimana cara menghilangkannya, ada beberapa parameter yang dapat menonaktifkan pelaksanaan pemeriksaan kewarasan saat startup.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendekatan palsu per proses</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gagasan umum untuk mengubah waktu hanya dalam 1 proses tetap sama - gunakan libfaketime. </font><font style="vertical-align: inherit;">Kami memulai database dengan pustaka yang dimuat di dalamnya, tetapi menetapkan offset waktu nol pada saat startup, yang kemudian disebarkan ke semua proses DBMS. </font><font style="vertical-align: inherit;">Dan kemudian, di dalam sesi tes, tetapkan variabel lingkungan untuk proses ini saja. </font><font style="vertical-align: inherit;">Pff, bisnis sesuatu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, bagi mereka yang terbiasa dengan bahasa pl / sql, seluruh malapetaka ide ini segera jelas. Karena bahasanya sangat terbatas dan pada dasarnya cocok untuk tugas tingkat tinggi. Tidak ada pemrograman sistem yang dapat diterapkan di sana. Meskipun beberapa operasi tingkat rendah (misalnya, bekerja dengan jaringan, bekerja dengan file) hadir dalam bentuk paket sistem / paket utb yang diinstal sebelumnya. Selama saya bekerja dengan Oracle, saya melakukan reverse engineering paket pra-instal beberapa kali, kode beberapa di antaranya disembunyikan dari mata orang asing (mereka disebut dibungkus). Jika Anda dilarang untuk menonton sesuatu, maka godaan untuk mengetahui bagaimana hal itu diatur di dalam hanya meningkat. Tetapi seringkali, bahkan setelah anvrapper, tidak selalu ada sesuatu untuk dilihat, karena fungsi dari paket-paket tersebut diimplementasikan sebagai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antarmuka c</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk perpustakaan di disk.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara total, kami mendekati satu kandidat untuk implementasi - teknologi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan prosedur eksternal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perpustakaan yang dirancang dengan cara khusus dapat mengekspor metode, yang kemudian dapat dipanggil oleh database Oracle melalui pl / sql. Tampak menjanjikan. Hanya sekali saya bertemu ini di kursus lanjutan plsql, jadi saya ingat sangat jauh cara memasaknya. Dan itu berarti perlu membaca dokumentasi. Saya membacanya - dan segera menjadi depresi. Karena pemuatan pustaka seperti itu, maka pustaka berjalan dalam proses agen terpisah melalui pendengar basis data, dan komunikasi dengan agen ini melalui dlink. Jadi ide kami berteriak untuk mengatur variabel lingkungan di dalam proses database itu sendiri. Dan ini semua dilakukan untuk alasan keamanan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gambar dari dokumentasi yang menunjukkan cara kerjanya:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pu/1h/07/pu1h07d6fvy1wwetq4deujbpnga.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jenis pustaka begitu / dll tidak begitu penting, tetapi untuk beberapa alasan gambar hanya untuk Windows. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin seseorang memperhatikan peluang potensial lain di sini. Ya, ya, ini Jawa. Oracle memungkinkan Anda untuk menulis kode prosedur tersimpan tidak hanya di plsql, tetapi juga di java, yang diekspor dengan cara yang sama seperti metode plsql. Secara berkala, saya melakukan ini, jadi seharusnya tidak ada masalah dengan ini. Tapi kemudian perangkap lain disembunyikan. Java bekerja dengan salinan lingkungan, dan memungkinkan Anda untuk hanya mendapatkan variabel lingkungan yang proses JVM miliki saat startup. JVM bawaan mewarisi variabel lingkungan dari proses basis data, tetapi hanya itu. Saya melihat tips di internet bagaimana mengubah peta yang hanya dibaca melalui refleksi, tapi apa gunanya, karena itu masih hanya salinan. Artinya, wanita itu lagi-lagi tidak punya apa-apa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, Jawa bukan hanya bulu yang berharga. Dengan menggunakannya, Anda dapat menelurkan proses dari dalam proses basis data. Meskipun semua operasi yang tidak aman harus diselesaikan secara terpisah melalui mekanisme hibah java, yang dilakukan dengan menggunakan paket dbms_java. Dari dalam kode plsql, Anda bisa mendapatkan proses pid dari proses server saat ini di mana kode berjalan, menggunakan sistem dilihat v $ sesi dan proses v $. Selanjutnya kita dapat menelurkan beberapa proses anak dari sesi kami untuk melakukan sesuatu dengan pid ini. Untuk memulai, saya hanya menyimpulkan semua variabel lingkungan yang ada di dalam proses basis data (untuk menguji hipotesis)</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/sh
</span>
pid=<span class="hljs-variable">$1</span><font></font>
<font></font>
awk <span class="hljs-string">'BEGIN {RS="\0"; ORS="\n"} $0'</span> <span class="hljs-string">"/proc/<span class="hljs-variable">$pid</span>/environ"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Disimpulkan dengan baik, lalu apa. Masih tidak mungkin untuk mengubah variabel dalam file environment, ini adalah data yang ditransfer ke proses ketika dimulai dan mereka hanya dibaca. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mencari di Internet di stackoverflow "Bagaimana cara mengubah variabel lingkungan dalam proses lain." Sebagian besar jawabannya adalah bahwa itu tidak mungkin, tetapi ada satu jawaban yang menggambarkan peluang ini sebagai peretasan di bawah standar dan kotor. Dan jawaban itu adalah </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Albert Einstein</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gdb. Debugger dapat menghubungkan ke setiap proses mengetahui pidnya dan menjalankan fungsi / prosedur di dalamnya yang ada di dalamnya sebagai simbol yang diekspor secara publik, misalnya, dari beberapa perpustakaan. Di libc, ada fungsi untuk bekerja dengan variabel lingkungan, dan libc dimuat ke dalam proses apa pun dari database Oracle (dan hampir semua program di linux).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah bagaimana variabel lingkungan diatur dalam proses asing (Anda perlu menyebutnya dari root karena ptrace yang digunakan):</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/sh
</span>
pid=<span class="hljs-variable">$1</span>
env_name=<span class="hljs-variable">$2</span>
env_val=<span class="hljs-string">"<span class="hljs-variable">$3</span>"</span><font></font>
<font></font>
out=`gdb -q -batch -ex <span class="hljs-string">"attach <span class="hljs-variable">$pid</span>"</span> -ex <span class="hljs-string">'call (int) setenv("'</span><span class="hljs-variable">$env_name</span><span class="hljs-string">'", "'</span><span class="hljs-string">"<span class="hljs-variable">$env_val</span>"</span><span class="hljs-string">'", 1)'</span> -ex <span class="hljs-string">"detach"</span> 2&gt;&amp;1`
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juga, untuk melihat variabel lingkungan di dalam proses gdb juga cocok. </font><font style="vertical-align: inherit;">Seperti disebutkan sebelumnya, file environment dari / proc / pid / hanya menunjukkan variabel yang ada pada awal proses. </font><font style="vertical-align: inherit;">Dan jika proses tersebut menciptakan sesuatu dalam perjalanan kerjanya, maka ini hanya dapat dilihat melalui debugger:</font></font><br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/sh
</span>
pid=<span class="hljs-variable">$1</span>
var_name=<span class="hljs-variable">$2</span><font></font>
<font></font>
var_value=`gdb -q -batch -ex <span class="hljs-string">"attach <span class="hljs-variable">$pid</span>"</span> -ex <span class="hljs-string">'call (char*) getenv("'</span><span class="hljs-variable">$var_name</span><span class="hljs-string">'")'</span> -ex <span class="hljs-string">'detach'</span> | egrep <span class="hljs-string">'^\$1 ='</span>`<font></font>
<font></font>
<span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span> == <span class="hljs-string">'$1 = 0x0'</span> ]
<span class="hljs-keyword">then</span>
  <span class="hljs-comment"># variable empty or does not exist</span>
  <span class="hljs-built_in">echo</span> -n
<span class="hljs-keyword">else</span>
  <span class="hljs-comment"># gdb returns $1 = hex_value "string value"</span>
  var_hex=`<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span> | awk <span class="hljs-string">'{print $3}'</span>`<font></font>
  var_value=`<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span> | sed -r -e <span class="hljs-string">'s/^\$1 = '</span><span class="hljs-variable">$var_hex</span><span class="hljs-string">' //;s/^"//;s/"$//'</span>`<font></font>
  <font></font>
  <span class="hljs-built_in">echo</span> -n <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span>
<span class="hljs-keyword">fi</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, solusinya sudah di saku kita - melalui java kita menelurkan proses debugger, yang pergi ke proses yang menghasilkannya dan menetapkan variabel lingkungan yang diinginkan untuk itu dan kemudian berakhir (Moor telah melakukan pekerjaannya - Moor dapat pergi). </font><font style="vertical-align: inherit;">Tetapi ada perasaan bahwa itu semacam tongkat penyangga. </font><font style="vertical-align: inherit;">Saya menginginkan sesuatu yang lebih elegan. </font><font style="vertical-align: inherit;">Entah bagaimana semuanya akan memaksa proses database itu sendiri untuk mengatur variabel lingkungan tanpa serangan eksternal.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Telur di bebek, bebek di kelinci ...</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan kemudian seseorang datang untuk menyelamatkan, ya, Anda dapat menebaknya dengan benar, sekali lagi Java, yaitu JNI (antarmuka asli java). </font><font style="vertical-align: inherit;">JNI memungkinkan Anda untuk memanggil metode C asli di dalam JVM. </font><font style="vertical-align: inherit;">Kode dikeluarkan dengan cara khusus dalam bentuk objek bersama dari perpustakaan, yang kemudian dimuat JVM, sedangkan metode yang ada di perpustakaan memetakan ke metode java di dalam kelas yang dideklarasikan dengan pengubah asli. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baiklah, kita menulis kelas (sebenarnya, ini hanya benda kerja):</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Posix</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">setenv</span><span class="hljs-params">(String key, String value, <span class="hljs-keyword">boolean</span> overwrite)</span></span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> String <span class="hljs-title">getenv</span><span class="hljs-params">(String key)</span></span>;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stub</span><span class="hljs-params">()</span> 
    </span>{<font></font>
        <font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah itu, kompilasi dan dapatkan file-h yang dihasilkan dari perpustakaan masa depan:</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-comment">#  </span><font></font>
javac Posix.java<font></font>
<font></font>
<span class="hljs-comment">#   Posix.h        JNI</span><font></font>
javah Posix<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah menerima file header, kami menulis isi untuk setiap metode:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Posix.h"</span></span><font></font>
<font></font>
<span class="hljs-function">JNIEXPORT jint JNICALL <span class="hljs-title">Java_Posix_setenv</span><span class="hljs-params">(JNIEnv *env, jclass cls, jstring key, jstring value, jboolean overwrite)</span>
</span>{
    <span class="hljs-keyword">char</span>* k = (<span class="hljs-keyword">char</span> *) (*env)-&gt;GetStringUTFChars(env, key, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">char</span>* v = (<span class="hljs-keyword">char</span> *) (*env)-&gt;GetStringUTFChars(env, value, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
    <span class="hljs-keyword">int</span> err = setenv(k, v, overwrite);<font></font>
<font></font>
    (*env)-&gt;ReleaseStringUTFChars(env, key, k);<font></font>
    (*env)-&gt;ReleaseStringUTFChars(env, value, v);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> err;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">JNIEXPORT jstring JNICALL <span class="hljs-title">Java_Posix_getenv</span><span class="hljs-params">(JNIEnv *env, jclass cls, jstring key)</span>
</span>{
    <span class="hljs-keyword">char</span>* k = (<span class="hljs-keyword">char</span> *) (*env)-&gt;GetStringUTFChars(env, key, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">char</span>* v = getenv(k);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> (*env)-&gt;NewStringUTF(env, v);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dan kompilasi perpustakaan</font></font><br>
<br>
<pre><code class="bash hljs">gcc -I<span class="hljs-string">"<span class="hljs-variable">$JAVA_HOME</span>/include"</span> -I<span class="hljs-string">"<span class="hljs-variable">$JAVA_HOME</span>/include/linux"</span> -fPIC Posix.c -shared -o libPosix.so -Wl,-soname -Wl,--no-whole-archive<font></font>
<font></font>
strip libPosix.so<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agar Java memuat perpustakaan asli, itu harus ditemukan oleh sistem ld sesuai dengan semua aturan Linux. </font><font style="vertical-align: inherit;">Selain itu, Java memiliki serangkaian properti yang berisi jalur tempat pencarian pustaka berlangsung. </font><font style="vertical-align: inherit;">Cara termudah untuk bekerja di dalam Oracle adalah dengan menempatkan perpustakaan kami di $ ORACLE_HOME / lib. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan setelah kita membuat pustaka, kita perlu mengkompilasi kelas di dalam database dan menerbitkannya sebagai paket plsql. </font><font style="vertical-align: inherit;">Ada 2 opsi untuk membuat kelas Java di dalam database:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memuat file kelas biner melalui utilitas loadjava</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kompilasi kode kelas dari sumber menggunakan sqlplus</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan menggunakan metode kedua, meskipun mereka pada dasarnya sama. </font><font style="vertical-align: inherit;">Untuk kasus pertama, perlu segera menulis semua kode kelas di tahap 1, ketika kami menerima kelas rintisan untuk file-h. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk membuat kelas dalam subd, sintaks khusus digunakan:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">REPLACE</span> <span class="hljs-keyword">AND</span> RESOLVE <span class="hljs-keyword">JAVA</span> <span class="hljs-keyword">SOURCE</span> NAMED <span class="hljs-string">"Posix"</span> <span class="hljs-keyword">AS</span><font></font>
...<font></font>
...<font></font>
/<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika kelas dibuat, perlu dipublikasikan sebagai metode plsql, dan di sini lagi sintaks khusus:</font></font><br>
<br>
<pre><code class="sql hljs">procedure set_env(var_name varchar2, var_value varchar2)<font></font>
is<font></font>
language java name 'Posix.set_env(java.lang.String, java.lang.String)';<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat Anda mencoba memanggil metode yang berpotensi tidak aman di dalam Java, eksekusi akan muncul yang mengatakan bahwa tidak ada hibah java yang telah dikeluarkan untuk pengguna. </font><font style="vertical-align: inherit;">Memuat metode asli adalah operasi lain yang tidak aman, karena kami menyuntikkan kode asing secara langsung ke dalam proses basis data (exploit yang sama dengan yang diumumkan di header). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi karena database adalah tes, kami memberikan hibah tanpa masalah koneksi dari sys:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">begin</span>
dbms_java.grant_permission( <span class="hljs-string">'SYSTEM'</span>, <span class="hljs-string">'SYS:java.lang.RuntimePermission'</span>, <span class="hljs-string">'loadLibrary.Posix'</span>, <span class="hljs-string">''</span>);
<span class="hljs-keyword">commit</span>;
<span class="hljs-keyword">end</span>;<font></font>
/<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nama pengguna sistem adalah yang saya gunakan untuk mengkompilasi paket kode java dan plsql. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penting untuk dicatat bahwa ketika memuat pustaka melalui panggilan ke System.loadLibrary, kami menghilangkan awalan lib dan ekstensi (seperti yang dijelaskan dalam dokumentasi) dan tidak melewati jalur apa pun ke mana harus mencari. Ada metode System.load serupa yang hanya bisa memuat perpustakaan menggunakan jalur absolut. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan kemudian 2 kejutan yang tidak menyenangkan menunggu kita - saya mendarat di lubang kelinci Oracle berikutnya. Saat mengeluarkan hibah, kesalahan terjadi dengan pesan yang agak berkabut:</font></font><br>
<br>
<pre><code class="plaintext hljs">ORA-29532: Java call terminated by uncaught Java exception: java.lang.SecurityException: policy table update
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalahnya adalah googled di Internet dan mengarah ke Dukungan Oracle Saya (alias Metalink). </font><font style="vertical-align: inherit;">Karena </font><font style="vertical-align: inherit;">Menurut aturan Oracle, menerbitkan artikel dari metalink tidak diperbolehkan di sumber terbuka, saya hanya akan menyebutkan nomor dokumen - 259471.1 (mereka yang memiliki akses akan dapat membaca sendiri). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inti masalahnya adalah bahwa Oracle tidak akan membiarkan kami mengizinkan pemuatan kode pihak ketiga yang mencurigakan ke dalam proses kami. </font><font style="vertical-align: inherit;">Itu logis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi karena basis ini adalah tes dan kami yakin dengan kode kami, kami mengizinkan unduhan tanpa ketakutan khusus. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fuh, misadventures sudah berakhir.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu hidup, hidup</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan nafas yang tertahan, saya memutuskan untuk mencoba menghembuskan napas ke Frankenstein saya. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memulai database dengan libfaketime yang sudah dimuat sebelumnya dan offset 0. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hubungkan ke database dan buat panggilan ke kode yang hanya menampilkan waktu sebelum dan sesudah mengubah variabel lingkungan:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">begin</span>
dbms_output.enable(<span class="hljs-number">100000</span>);<font></font>
dbms_java.set_output(100000);<font></font>
dbms_output.put_line('old time: '||to_char(sysdate, 'dd.mm.yyyy hh24:mi:ss'));<font></font>
system.posix.set_env('FAKETIME','+1d');<font></font>
dbms_output.put_line('new time: '||to_char(sysdate, 'dd.mm.yyyy hh24:mi:ss'));<font></font>
<span class="hljs-keyword">end</span>;<font></font>
/<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini berhasil, sial! </font><font style="vertical-align: inherit;">Jujur, saya mengharapkan beberapa kejutan lagi, seperti kesalahan ORA-600. </font><font style="vertical-align: inherit;">Namun, peringatan memiliki seluruh nomor dan kode terus berfungsi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penting untuk dicatat bahwa jika koneksi ke database dilakukan sebagai dedicated, maka setelah koneksi selesai, proses akan dihancurkan dan tidak akan ada jejak. </font><font style="vertical-align: inherit;">Tetapi jika kita menggunakan koneksi bersama, maka dalam hal ini proses siap pakai dialokasikan dari kumpulan server, kami mengubah waktu di dalamnya melalui variabel lingkungan dan ketika diputuskan akan tetap berubah di dalam proses. </font><font style="vertical-align: inherit;">Dan ketika kemudian sesi database lain jatuh ke proses server yang sama, itu akan menerima waktu yang salah dengan kejutan yang cukup besar. </font><font style="vertical-align: inherit;">Oleh karena itu, pada akhir sesi tes, lebih baik untuk selalu mengembalikan waktu kembali ke nol offset.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya harap ceritanya menarik (dan mungkin bahkan bermanfaat bagi seseorang). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua kode sumber tersedia di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dokumentasi libfaketime </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">juga</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana Anda melakukan pengujian? </font><font style="vertical-align: inherit;">Dan bagaimana Anda membuat database dev dan pengujian di perusahaan?</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonus untuk mereka yang membaca sampai akhir</font></font></b>
                        <div class="spoiler_text"><img src="https://habrastorage.org/webt/wd/m1/s9/wdm1s9kk6_kckj-xf5amc_o6wjq.jpeg"><br>
</div>
                    </div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id503782/index.html">Bagaimana cara membuat tabel interaktif dengan permukaan kerja dalam bentuk lingkaran?</a></li>
<li><a href="../id503786/index.html">Representasi digital dari audio analog. Program pendidikan singkat</a></li>
<li><a href="../id503788/index.html">Email dinamis :: keamanan</a></li>
<li><a href="../id503790/index.html">Permutasi. kelas 9. Tugas paritas</a></li>
<li><a href="../id503796/index.html">Membuat dukungan lebih murah, berusaha untuk tidak kehilangan kualitas</a></li>
<li><a href="../id503812/index.html">Bajak laut lincah dan beberapa hukum dialektika</a></li>
<li><a href="../id503826/index.html">Perlindungan DDoS simetris dan asimetris - apa bedanya?</a></li>
<li><a href="../id503830/index.html">Amazon telah membuka tempat perlindungan besar bagi para tunawisma</a></li>
<li><a href="../id503832/index.html">Resep PostgreSQL: mesin template mustach</a></li>
<li><a href="../id503836/index.html">Pro dan kontra teknologi moderasi komentar (+ Polling)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>