<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼🏼 🍒 🉐 Optimisation du rendu pour mobile 🧖🏼 🕶️ 👩🏿‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour chers lecteurs, amateurs et professionnels de la programmation graphique! Nous attirons votre attention sur une série d'articles consacrés à l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Optimisation du rendu pour mobile</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/492874/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour chers lecteurs, amateurs et professionnels de la programmation graphique! Nous attirons votre attention sur une série d'articles consacrés à l'optimisation du rendu pour les appareils mobiles: téléphones et tablettes basés sur iOS et Android. Le cycle comprendra trois parties. Dans la première partie, nous examinerons les fonctionnalités de l' </font><font style="vertical-align: inherit;">architecture </font><font style="vertical-align: inherit;">populaire de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tuiles</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GPU </font><font style="vertical-align: inherit;">sur mobile </font><font style="vertical-align: inherit;">. Dans le second, nous passerons en revue les principales familles de GPU présentés dans les appareils modernes, et examinerons leurs forces et leurs faiblesses. Dans la troisième partie, nous nous familiariserons avec les fonctionnalités d'optimisation du shader. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passons donc à la première partie.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le développement de cartes vidéo sur les ordinateurs de bureau et les consoles a eu lieu en l'absence de restrictions importantes sur la consommation d'énergie. Avec l'avènement des cartes vidéo pour appareils mobiles, les ingénieurs ont été confrontés à la tâche d'assurer des performances acceptables à des résolutions de bureau comparables, tandis que la consommation d'énergie de ces cartes vidéo devrait être de 2 ordres de grandeur inférieure.&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51e/4fa/969/51e4fa969a3e5ede3b31064499c33226.png"></div><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La solution a été trouvée dans une architecture spéciale appelée </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tile Based Rendering (TBR)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pour un programmeur graphique ayant une expérience dans le développement de PC, lorsqu'il se familiarise avec le développement mobile, tout semble familier: une API OpenGL ES similaire est utilisée, la même structure du pipeline graphique. Cependant, l'architecture des tuiles des GPU mobiles est considérablement différente de celle utilisée sur les consoles PC / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mode immédiat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Connaître les forces et les faiblesses de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TBR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous aidera à prendre les bonnes décisions et à obtenir d'excellentes performances avec Mobile. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous trouverez ci-dessous un schéma simplifié d'un pipeline graphique classique utilisé sur les PC et les consoles pour la troisième décennie.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/281/67b/5e2/28167b5e2eaa4746ebd1ed45f8aa2dfb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au stade du traitement de la géométrie, les attributs de sommet sont lus dans la mémoire vidéo du GPU. Après diverses transformations </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Vertex Shader), les</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> primitives prêtes à être rendues dans l'ordre d'origine (FIFO) sont transmises au rasterizer, qui divise les primitives en pixels. Après cela, l'étape de traitement des fragments de chaque pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Fragment Shader) est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> effectuée </font><font style="vertical-align: inherit;">, et les valeurs de couleur obtenues sont écrites dans le tampon d'écran, qui est également situé dans la mémoire vidéo. Une caractéristique de l'architecture traditionnelle du </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Mode Immédiat»</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est l'enregistrement du résultat du Fragment Shader dans des sections arbitraires du tampon d'écran lors du traitement d'un seul </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appel de tirage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ainsi, pour chaque appel de tirage, l'accès à la totalité de la mémoire tampon d'écran peut être requis. Travailler avec un large éventail de mémoire nécessite une </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bande passante de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bus appropriée ( </font><b><font style="vertical-align: inherit;">bande passante</font></b><font style="vertical-align: inherit;"> ) et est associé à une consommation d'énergie élevée. Par conséquent, les </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mobiles ont </font><font style="vertical-align: inherit;">commencé à adopter une approche différente. Sur l'architecture de tuile typique des cartes vidéo mobiles, le rendu se fait dans un petit morceau de mémoire correspondant à la partie de l'écran - la tuile. La petite taille de la tuile (par exemple 16x16 pixels pour les cartes vidéo Mali, 32x32 pour PowerVR) vous permet de la placer directement sur la puce de la carte vidéo, ce qui rend la vitesse d'accès comparable à la vitesse d'accès aux registres de base du shader, c'est-à-dire très vite.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86d/7bf/c65/86d7bfc65e53739ab9be0d5ea1242c0e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, comme les primitives peuvent tomber dans des sections arbitraires du tampon d'écran et qu'une tuile n'en recouvre qu'une petite partie, une étape supplémentaire dans le pipeline graphique était nécessaire. </font><font style="vertical-align: inherit;">Voici un diagramme simplifié du fonctionnement du pipeline avec l'architecture de tuiles.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/531/ea5/00c/531ea500c507eb47558676582e20c94c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir traité les sommets et construit les primitives, ces dernières, au lieu d'être envoyées au pipeline de fragments, tombent dans le soi-disant </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ici, les primitives sont distribuées par des tuiles, dans les pixels dont elles tombent. </font><font style="vertical-align: inherit;">Après une telle distribution, qui, en règle générale, couvre tous les appels de tirage dirigés vers un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objet tampon de trame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (aka </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cible de rendu</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), les tuiles sont rendues séquentiellement. </font><font style="vertical-align: inherit;">Pour chaque tuile, la séquence d'actions suivante est effectuée:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chargement d'anciens contenus </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO à</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> partir de la mémoire système ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Charger</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu des primitifs tombant dans cette tuile</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Téléchargement de nouveau contenu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans la mémoire système ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Store</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ea/20b/74b/9ea20b74b9fb716af30d5e0fa4ee1b34.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il convient de noter que l' </font><font style="vertical-align: inherit;">opération de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chargement</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peut être considérée comme une superposition supplémentaire de la «texture plein écran» sans compression. </font><font style="vertical-align: inherit;">Si possible, évitez cette opération, c'est-à-dire </font><font style="vertical-align: inherit;">Ne laissez pas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> basculer d' </font><font style="vertical-align: inherit;">avant en arrière. </font><font style="vertical-align: inherit;">Si </font><font style="vertical-align: inherit;">tout son contenu est effacé </font><font style="vertical-align: inherit;">avant le rendu en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , l' </font><font style="vertical-align: inherit;">opération de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chargement</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n'est pas effectuée. </font><font style="vertical-align: inherit;">Cependant, afin d'envoyer le bon signal au conducteur, les paramètres d'un tel nettoyage doivent répondre à certains critères:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doit être désactivé </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scissor Rect</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'enregistrement dans tous les canaux de couleur et alpha doit être autorisé.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour empêcher l' </font><font style="vertical-align: inherit;">opération de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chargement</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> du tampon de profondeur et du gabarit, ils doivent également être nettoyés avant le début du rendu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est également possible d'éviter le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">magasin</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> opération </font><font style="vertical-align: inherit;">pour le tampon de profondeur / pochoir. </font><font style="vertical-align: inherit;">Après tout, le contenu de ces tampons ne s'affiche pas à l'écran. </font><font style="vertical-align: inherit;">Avant l'opération </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glSwapBuffers</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><b><font style="vertical-align: inherit;">vous</font></b><font style="vertical-align: inherit;"> pouvez appeler </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glDiscardFramebufferEXT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glInvalidateFramebuffer</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> GLenum attachments[] = {GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT};<font></font>
glDiscardFramebufferEXT (GL_FRAMEBUFFER, <span class="hljs-number">2</span>, attachments);</code></pre><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> GLenum attachments[] = {GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT};<font></font>
glInvalidateFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">2</span>, attachments);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe des scénarios de rendu dans lesquels le placement des tampons de profondeur / gabarit, ainsi que des </font><font style="vertical-align: inherit;">tampons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans la mémoire système n'est pas requis. Par exemple, si le rendu dans la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avec le tampon de profondeur est continu et que les informations de profondeur de la trame précédente ne sont pas utilisées, le tampon de profondeur n'a pas besoin d'être chargé dans la mémoire de tuiles avant le début du rendu, ni déchargé après la fin du rendu. Par conséquent, la mémoire système ne peut pas être allouée sous le tampon de profondeur. Les API graphiques modernes telles que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vulkan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous permettent de définir explicitement le mode de mémoire pour vos homologues </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">  &nbsp;( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MTLStorageModeMemoryless</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metal, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT +</font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vulkan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il convient de noter en particulier l'implémentation de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur les architectures de tuiles. Le tampon haute résolution pour le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne laisse pas la mémoire des tuiles en divisant le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en plusieurs tuiles. Par exemple, pour </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA 2x2, </font></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16x16</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tuiles </font><font style="vertical-align: inherit;">seront résolus en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8x8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pendant la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">magasin</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> opération, à </font><font style="vertical-align: inherit;">savoir Au total, il faudra traiter 4 fois plus de tuiles. Mais la mémoire supplémentaire pour </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA n'est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pas requise, et en raison du rendu dans la mémoire rapide des tuiles, il n'y aura pas de restrictions de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bande passante</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> importantes </font><b><font style="vertical-align: inherit;">.</font></b><font style="vertical-align: inherit;"> Cependant, utilisez</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur l'architecture de tuiles augmente la charge sur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiler,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ce qui peut affecter négativement les performances de rendu des scènes avec beaucoup de géométrie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En résumant ce qui précède, nous présentons le schéma souhaité de travail avec FBO sur l'architecture de tuile:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// 1.   ,    auxFBO</span><font></font>
glBindFramebuffer(GL_FRAMEBUFFER, auxFBO);<font></font>
glDisable(GL_SCISSOR);<font></font>
glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);<font></font>
glDepthMask(GL_TRUE);<font></font>
<span class="hljs-comment">// glClear,     </span><font></font>
glClear(GL_COLOR_BUFFER_BIT |&nbsp;GL_DEPTH_BUFFER_BIT |&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GL_STENCIL_BUFFER_BIT);<font></font>
<font></font>
renderAuxFBO();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
<font></font>
<span class="hljs-comment">//   /      </span>
glInvalidateFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">2</span>, depth_and_stencil);
<span class="hljs-comment">// 2.   mainFBO</span><font></font>
glBindFramebuffer(GL_FRAMEBUFFER, mainFBO);<font></font>
glDisable(GL_SCISSOR);<font></font>
<font></font>
glClear(...);<font></font>
<span class="hljs-comment">//   mainFBO    auxFBO</span><font></font>
renderMainFBO(auxFBO);<font></font>
<font></font>
glInvalidateFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">2</span>, depth_and_stencil);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous passez au rendu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auxFBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au milieu de la formation </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mainFBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vous pouvez obtenir des </font><font style="vertical-align: inherit;">opérations de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chargement et</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><b><font style="vertical-align: inherit;">stockage</font></b><font style="vertical-align: inherit;"> inutiles </font><font style="vertical-align: inherit;">, ce qui peut augmenter considérablement le temps de formation de la trame. </font><font style="vertical-align: inherit;">Dans notre pratique, nous avons rencontré un ralentissement du rendu même dans le cas de paramètres FBO inactifs, c'est-à-dire </font><font style="vertical-align: inherit;">sans le rendu réel en eux. </font><font style="vertical-align: inherit;">En raison de l'architecture du moteur, notre ancien circuit ressemblait à ceci:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   mainFBO</span><font></font>
glBindFramebuffer(GL_FRAMEBUFFER, mainFBO);<font></font>
<span class="hljs-comment">//   </span><font></font>
glBindFramebuffer(GL_FRAMEBUFFER, auxFBO);<font></font>
<span class="hljs-comment">//  auxFBO</span><font></font>
renderAuxFBO();<font></font>
<font></font>
glBindFramebuffer(GL_FRAMEBUFFER, mainFBO);<font></font>
<span class="hljs-comment">//   mainFBO</span><font></font>
renderMainFBO(auxFBO);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malgré le manque d'appels gl après la première installation de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mainFBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sur certains appareils, nous avons obtenu des </font><font style="vertical-align: inherit;">opérations de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chargement et</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><b><font style="vertical-align: inherit;">stockage</font></b><font style="vertical-align: inherit;"> supplémentaires </font><font style="vertical-align: inherit;">et de mauvaises performances. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour améliorer notre compréhension des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frais généraux liés</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> à l'utilisation des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> intermédiaires </font><font style="vertical-align: inherit;">, nous avons mesuré la perte de temps pour la commutation des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO en</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plein écran à l' </font><font style="vertical-align: inherit;">aide d'un test synthétique. Le tableau indique le temps passé sur le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">magasin</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonctionnement lors de la </font><font style="vertical-align: inherit;">commutation </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plusieurs fois </font><font style="vertical-align: inherit;">dans une trame (le temps d'une telle opération est donnée). </font><b><font style="vertical-align: inherit;">Fonctionnement de la </font></b></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">charge</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> absent en raison de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glClear</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, c'est à dire. </font><font style="vertical-align: inherit;">un scénario plus favorable a été mesuré. </font><font style="vertical-align: inherit;">L'autorisation utilisée sur l'appareil a contribué. </font><font style="vertical-align: inherit;">Cela pourrait plus ou moins correspondre à la puissance du GPU installé. </font><font style="vertical-align: inherit;">Par conséquent, ces chiffres ne donnent qu'une idée générale du coût de la commutation des cibles sur les cartes vidéo mobiles de différentes générations.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">millisecondes</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">millisecondes</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 320</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 512</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,74</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR G6200</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 615</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,7</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-400</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 530</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,4</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-t720</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1,9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-g51</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,32</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR SXG 544</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-t830</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,15</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur la base des données obtenues, nous pouvons recommander de ne pas utiliser plus d'un ou deux commutateurs FBO par trame, au moins pour les anciennes cartes vidéo. Si le jeu a une passe de code distincte pour les appareils bas de gamme, il est conseillé de ne pas y utiliser la modification FBO. Cependant, sur le bas de gamme, la question de l'abaissement de la résolution devient souvent pertinente. Sur Android, vous pouvez réduire la résolution de rendu sans recourir à un FBO intermédiaire en appelant </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SurfaceHolder.setFixedSize ():</font></font></b><br>
<br>
<pre><code class="java hljs">surfaceView.getHolder().setFixedSize(...)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette méthode ne fonctionnera pas si le jeu est rendu via l' </font><font style="vertical-align: inherit;">application </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Surface</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> principale </font><font style="vertical-align: inherit;">(un schéma typique pour travailler avec </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NativeActivity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Si vous utilisez la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">surface</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> principale </font><b><font style="vertical-align: inherit;">,</font></b><font style="vertical-align: inherit;"> une résolution inférieure peut être définie en appelant la fonction native </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ANativeWindow_setBuffersGeometry.</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">JNIEXPORT <span class="hljs-keyword">void</span> JNICALL <span class="hljs-title">Java_com_organization_app_AppNativeActivity_setBufferGeometry</span><span class="hljs-params">(JNIEnv *env, jobject thiz, jobject surface, jint width, jint height)</span>
</span>{<font></font>
ANativeWindow* window = ANativeWindow_fromSurface(env, surface);&nbsp;<font></font>
ANativeWindow_setBuffersGeometry(window, width, height, AHARDWAREBUFFER_FORMAT_R8G8B8X8_UNORM);&nbsp;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Java:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBufferGeometry</span><span class="hljs-params">(Surface surface, <span class="hljs-keyword">int</span> width , <span class="hljs-keyword">int</span> height )</span></span>;&nbsp;<font></font>
...<font></font>
<span class="hljs-comment">//   SurfaceHolder.Callback</span>
<span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">surfaceChanged</span><span class="hljs-params">(SurfaceHolder holder, <span class="hljs-keyword">int</span> format, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span>
</span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setBufferGeometry(holder.getSurface(), <span class="hljs-number">768</span>, <span class="hljs-number">1366</span>); <span class="hljs-comment">/* ... */</span>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, nous mentionnons la commande ADB pratique pour contrôler les tampons de surface sélectionnés sur Android:</font></font><br>
<br>
<pre><code class="plaintext hljs">adb shell dumpsys surfaceflinger
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez obtenir une conclusion similaire qui vous permet d'estimer la consommation de mémoire pour les tampons de surface:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/524/2fe/ea6/5242feea615abe186c6c3538c9d60565.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La capture d'écran montre le système mettant en évidence 3 tampons pour une triple mise en mémoire tampon du </font><font style="vertical-align: inherit;">jeu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GLSurfaceView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (surligné en jaune), ainsi que 2 tampons pour la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">surface</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> principale </font><font style="vertical-align: inherit;">(surlignée en rouge). </font><font style="vertical-align: inherit;">Dans le cas du rendu via la surface principale, qui est le schéma par défaut lors de l'utilisation de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NativeActivity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , l'allocation de tampons supplémentaires peut être évitée.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est tout pour le moment. </font><font style="vertical-align: inherit;">Dans les articles suivants, nous classerons les GPU mobiles et analyserons les méthodes d'optimisation pour eux.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr492862/index.html">15 meilleurs conseils d'optimisation des performances Oracle APEX pour les développeurs</a></li>
<li><a href="../fr492864/index.html">Puis-je pirater un navire?</a></li>
<li><a href="../fr492866/index.html">Le livre "Machine Learning sans mots"</a></li>
<li><a href="../fr492868/index.html">Optimisation des chaînes dans ClickHouse. Rapport Yandex</a></li>
<li><a href="../fr492872/index.html">Comment organiser l'accès à distance et ne pas souffrir de pirates</a></li>
<li><a href="../fr492878/index.html">Pantoufles geek: à la recherche de positif dans les fermetures de bureaux temporaires</a></li>
<li><a href="../fr492880/index.html">Que devrions-nous construire une maison intelligente?</a></li>
<li><a href="../fr492884/index.html">Recevoir des messages des diffusions YouTube + autorisation google en PHP</a></li>
<li><a href="../fr492886/index.html">Recette des testeurs de recrutement de masse</a></li>
<li><a href="../fr492888/index.html">Pourquoi vous ne devriez pas utiliser WireGuard</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>