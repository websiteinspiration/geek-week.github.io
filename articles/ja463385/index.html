<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👎🏼 🌉 👨‍❤️‍👨 もう一度、Lisk置換の原則、またはOOPにおける継承のセマンティクスについて 🏛️ 🤦🏼 😎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="継承はOOPの柱の1つです。継承は、一般的なコードを再利用するために使用されます。ただし、常に一般的なコードを再利用する必要があるとは限りません。また、常に継承がコードを再利用する最良の方法であるとは限りません。しばしば判明するので、2つの異なるコード（クラス）に同様のコードがありますが、それらの要...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>もう一度、Lisk置換の原則、またはOOPにおける継承のセマンティクスについて</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463385/"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">継承はOOPの柱の1つです。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">継承は、一般的なコードを再利用するために使用されます。</font><font style="vertical-align: inherit;">ただし、常に一般的なコードを再利用する必要があるとは限りません。また、常に継承がコードを再利用する最良の方法であるとは限りません。</font><font style="vertical-align: inherit;">しばしば判明するので、2つの異なるコード（クラス）に同様のコードがありますが、それらの要件は異なります。</font><font style="vertical-align: inherit;">クラスは実際には互いに継承し合うため、価値がない場合があります。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、この問題を説明するために、RectangleクラスからSquareクラスを継承するか、その逆の例を使用しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
四角形のクラスがあるとします。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, width, height</span>):</span><font></font>
        self._width = width<font></font>
        self._height = height<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_width</span>(<span class="hljs-params">self, width</span>):</span><font></font>
        self._width = width <font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_height</span>(<span class="hljs-params">self, height</span>):</span><font></font>
        self._height = height<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_area</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">return</span> self._width * self._height<font></font>
   ...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、Squareクラスを記述したかったのですが、面積計算コードを再利用するために、RectangleからSquareを継承することは論理的に思えます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span>(<span class="hljs-params">Rectangle</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_width</span>(<span class="hljs-params">self, width</span>):</span><font></font>
        self._width = width<font></font>
        self._height = width<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_height</span>(<span class="hljs-params">self, height</span>):</span><font></font>
        self._width = height<font></font>
        self._height = height<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SquareクラスとRectangleクラスのコードは一貫しているようです。</font><font style="vertical-align: inherit;">Squareは正方形の数学的特性を保持しているようです。</font><font style="vertical-align: inherit;">そして長方形。</font><font style="vertical-align: inherit;">つまり、Rectangleの代わりにSquareクラスのオブジェクトを転送できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これを行う</font><font style="vertical-align: inherit;">と、Rectangleクラスの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動作</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">プロパティに違反する可能性があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、クライアントコードがあります。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">client_code</span>(<span class="hljs-params">rect</span>):</span>
    rect.set_height(<span class="hljs-number">10</span>)<font></font>
    rect.set_width(<span class="hljs-number">20</span>)
    <span class="hljs-keyword">assert</span> rect.get_area() == <span class="hljs-number">200</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数の引数としてSquareクラスのインスタンスを渡すと、関数の動作が異なります。</font><font style="vertical-align: inherit;">これは、Rectangleクラスの動作に関する規約の違反です。これは、基本クラスのオブジェクトを使用したアクションは、子孫クラスのオブジェクトを使用した場合とまったく同じ結果を与える必要があるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正方形クラスが長方形クラスの子孫である場合、正方形を操作して長方形のメソッドを実行する場合、それが長方形ではないことに気付くべきではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題は、たとえば次のように修正できます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスと完全に一致するようにアサートを作成するか、クラスによって動作が異なる場合はifを作成します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Squareでは、set_size（）メソッドを作成し、set_height、set_widthメソッドをオーバーライドして、例外</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
など</font><font style="vertical-align: inherit;">をスローするようにします</font><font style="vertical-align: inherit;">。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなコードとクラスは、コードが機能するという意味で機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の質問は、SquareクラスまたはRectangleクラスを使用するクライアントコードは、基本クラスとその動作、または子孫クラスとその動作のいずれかを知る必要があるということです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
やがて、それを得ることができます：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子孫クラスはほとんどのメソッドをオーバーライドします</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本クラスにメソッドをリファクタリングまたは追加すると、子孫を使用してコードが破損します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本クラスのオブジェクトを使用するコードでは、オブジェクトのクラスをチェックするifsがあり、子孫と基本クラスの動作は異なります</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本クラス用に作成されたクライアントコードは、基本クラスと子孫クラスの実装に依存することがわかります。これは時間の経過とともに開発を非常に複雑にします。そして、OOPは、基本クラスと子孫クラスを互いに独立して編集できるように作成されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前世紀の80年代に、クラスの継承がコードの再利用にうまく機能するためには、基本クラスの代わりに子孫クラスを使用できることを確認する必要があることに気付きました。それら。継承のセマンティクス-これは、振る舞いとしてだけでなく、それほど多くのデータであってはなりません。継承者は、基本クラスの動作を「壊す」べきではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、これは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lisk置換</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の原理、またはクラスの動作（強力な動作タイピング）に基づいてサブタイプを決定する原理です。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本クラスオブジェクトを子孫クラスオブジェクトで置き換えると破損するような、意味のあるコードを少なくとも記述できる場合は、相互に継承しないでください。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子孫の基本クラスの動作を拡張し、大幅に変更しないでください。基本クラスを使用する関数は、それを知らなくてもサブクラスオブジェクトを使用できる必要があります。実際、これはOOPにおける継承のセマンティクスです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、実際の産業用コードでは、この原則に従い、説明されている継承のセマンティクスに従うことを強くお勧めします。そしてこの原則にはいくつかの微妙な点があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この原則は、ドメインレベルの抽象化ではなく、コードの抽象化-クラスで満たす必要があります。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幾何学的な観点から、正方形は長方形です。クラス継承の階層の観点から見ると、正方形のクラスがクラス長方形の相続人になるかどうかは、これらのクラスに必要な動作に依存します。このコードを使用する方法と状況によって異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rectangleクラスに2つのメソッドしかない場合-面積の計算とレンダリングであり、再描画とサイズ変更の可能性はありません。この場合、オーバーライドされたコンストラクターを持つSquareは、Liskovの置換の原則を満たします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それら。そのようなクラスは置換の原則を満たします：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw</span>():</span><font></font>
        ...<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_area</span>():</span><font></font>
        ...<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span>(<span class="hljs-params">Rectangle</span>):</span>
    <span class="hljs-keyword">pass</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、これは非常に良いコードではなく、おそらく、クラス設計のアンチパターンですが、正式な観点からは、リスコフの原則を満たしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。セットは、マルチセットのサブタイプです。これはドメイン抽象化の比率です。ただし、BagからSetクラスを継承して置換の原則に違反するようにコードを記述したり、原則が尊重されるように記述したりできます。同じドメインのセマンティクス。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、クラスの継承は、関係「IS」の実装と見なすことができますが、サブジェクトエリアのエンティティ間ではなく、クラス間と見なすことができます。そして、子孫クラスが基本クラスのサブタイプであるかどうかは、クライアントコードが使用する（そして原則として使用できる）クラス動作の制限とコントラクトによって決まります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制約、不変条件、基本クラスコントラクトはコードで修正されていませんが、コードを編集および読み取る開発者の責任者で修正されています。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「破壊」とは何か、「契約」を破壊するとは、コードではなく、開発者の頭にあるクラスのセマンティクスによって決まります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基底クラスのオブジェクトにとって意味のあるコードは、それを子孫クラスのオブジェクトに置き換えても壊れてはなりません。意味のあるコードとは、基本クラスのセマンティクスと制限のフレームワーク内で基本クラス（およびその子孫）のオブジェクトを使用するクライアントコードです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理解することが非常に重要なのは、基本クラスに実装されている抽象化の制限は、通常、プログラムコードに含まれていないということです。</font><font style="vertical-align: inherit;">これらの制限は、開発者によって理解され、認識され、サポートされています。</font><font style="vertical-align: inherit;">抽象化とコードの一貫性を監視します。</font><font style="vertical-align: inherit;">コードが意味を表すために。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、長方形にはjsonでビューを返す別のメソッドがあります</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>:</span> 
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_dict</span>(<span class="hljs-params">self</span>):</span>
       <span class="hljs-keyword">return</span> {<span class="hljs-string">"height"</span>: self.height, <span class="hljs-string">"width"</span>: self.width}
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてSquareでそれを再定義します：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span>:</span> 
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_dict</span>(<span class="hljs-params">self</span>):</span>
       <span class="hljs-keyword">return</span> {<span class="hljs-string">"size"</span>: self.height}
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rectangleクラスto_jsonの動作の基本契約が高さと幅を持つと考える場合、コードは </font></font><br>
<br>
<pre><code class="python hljs">r = rect.to_dict()<font></font>
log(r[<span class="hljs-string">'height'</span>], r[<span class="hljs-string">'width'</span>])
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本クラスRectangleのオブジェクトにとって意味があります。基本クラスのオブジェクトをクラスに置き換えると、Squareの相続人コードはその動作を変更し、コントラクトに違反するため、Lisk置換の原則に違反します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rectangleクラスの動作の基本的な規約が、to_dictが特定のフィールドを使用せずにシリアル化できるディクショナリを返すことであると考える場合、そのようなto_dictメソッドは問題ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、これは良い例で、不変性が原理の違反から救うという神話を破壊します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正式には、子孫クラスのメソッドのオーバーライドは基本クラスのロジックの変更と同様に危険です。たとえば、子孫クラスは基本クラスの「不正な」動作に適応することがよくあり、基本クラスでバグが修正されると、それらは壊れます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コントラクトと不変条件のすべての条件をコードに転送することは可能ですが、一般的なケースでは、動作のセマンティクスはすべてコードの外側にあり、問題領域にあり、開発者によってサポートされています。 to_dictの例は、コントラクトをコードで記述できる例ですが、たとえば、行だけでなく、get_hashメソッドが実際にハッシュのすべてのプロパティを含むハッシュを返すことを確認することは不可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者が他の開発者が作成したコードを使用する場合、コード、メソッド名、ドキュメント、およびコメントによってのみ、クラスのセマンティクスが何であるかを直接理解できます。</font><font style="vertical-align: inherit;">しかし、いずれにせよ、セマンティクスは人間の領域であることが多く、したがって誤っています。</font><font style="vertical-align: inherit;">最も重要な結果：コードによってのみ-構文的に-リスコフの原則への準拠を検証することは不可能であり、（しばしば）あいまいなセマンティクスに依存する必要があります。</font><font style="vertical-align: inherit;">強力な動作タイピングを検証するための検証可能で保証された方法の正式な（数学的な）手段はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、多くの場合、リスコフの原則の代わりに、契約プログラミングの前提条件と事後条件の正式なルールが使用されます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> サブクラスの前提条件を強化することはできません-サブクラスは基本クラスを超える必要はありません</font></font></li>
<li>      —     () ,   </li>
<li>        . </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、子孫クラスのメソッドでは、基本クラスになかった必須パラメーターを追加することはできません。これが前提条件を強化する方法だからです。または、オーバーライドされたメソッドで例外をスローすることはできません。基本クラスの不変条件に違反します。等。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要なのはクラスの現在の動作ではありませんが、クラスのどの変更がクラスの責任またはセマンティクスを意味します。</font></font><br>
</b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
コードは常に修正および変更されています。したがって、現時点でコードが置換の原則を満たしている場合でも、コードの変更によってこれが変更されるわけではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rectangleライブラリクラスの開発者と、RectangleからSquareを継承するアプリケーション開発者がいるとします。アプリケーション開発者が四角形からSquareを継承した瞬間、すべてが問題なく、クラスは置換の原則を満たしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ある時点で、ライブラリを担当する開発者が、Rectangle基本クラスにreshapeまたはset_width / set_heightメソッドを追加しました。彼の観点からは、基本クラスの拡張がちょうど起こった。しかし、実際には、子孫クラスが依存していたセマンティクスと規約に変更がありました。現在、クラスは原則を満たしていない。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、OOPで継承する場合、インターフェイスの拡張のように見える基本クラスの変更—別のメソッドまたはフィールドが追加されると、以前の「自然な」規約に違反し、それによって実際にセマンティクスまたは責任が変更される場合があります。したがって、基本クラスにメソッドを追加することは危険です。誤って契約を誤って変更してしまう可能性があります。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、実際的な観点から、長方形とクラスの例では、reshapeメソッドまたはset_width / set_heightメソッドがあるかどうかが重要です。実用的な観点から見ると、ライブラリコードでのこのような変更の可能性がどれほど高いかが重要です。クラス責任のセマンティクスまたは境界は、そのような変更を意味しますか？暗黙的に示されている場合、エラーの可能性やリファクタリングの必要性が大幅に増加します。そして、少しでも可能性があるなら、おそらくそのようなクラスを互いに継承しない方が良いでしょう。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明確なセマンティクスを持つ単純なクラスであっても、動作ベースのサブタイプ定義を維持することは困難です。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複雑なビジネスロジックを備えた企業について、私たちは何と言えますか。基本クラスと後続クラスは異なるコードであるという事実にもかかわらず、それらについては、インターフェースと責任を注意深く慎重に考える必要があります。そして、クラスのセマンティクスにわずかな変更があったとしても、これは絶対に避けられないことです。関連するクラスのコードを調べ、新しいコントラクトまたは不変式がすでに記述されている内容に違反していないかどうかを確認する必要があります（！）そして使用されます。分岐したクラス階層のほとんどすべての変更により、他の多くのコードを調べてチェックする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが、一部の人々がOOPでの伝統的な継承をあまり好まない理由の1つです。したがって、クラスの構成、インターフェースの継承などを好むことがよくあります。古典的な振る舞いの継承の代わりに。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
公平に言えば、代替の原則に違反しない可能性が最も高いルールがいくつかあります。危険な構造物をすべて禁止すれば、できるだけ身を守ることができます。たとえば、C ++の場合、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oleg</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はこれについて書きました</font><font style="vertical-align: inherit;">。しかし、一般的に、そのような規則はクラスを古典的な意味でのクラスに変えません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
管理方法を使用しても、タスクはあまりうまく解決されません。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、マーティンおじさんがC ++でどのようにして、どのように機能しなかったかを読むことができます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、実際の産業用コードでは、Liskの原則は依然としてかなり頻繁に違反されており、それは大した問題ではありません</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。原則に従うのは難しい、なぜなら1）クラスの責任とセマンティクスは、多くの場合明示的ではなく、コードで表現されていません。2）クラスの責任は、基本クラスと子孫クラスの両方で変わる可能性があります。しかし、これは必ずしもいくつかの本当にひどい結果につながるわけではありません。最も一般的で最も単純で最も基本的な違反は、オーバーライドされたメソッドが動作を変更することです。例えばここのように：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span>:</span> 
 <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close</span>(<span class="hljs-params">self</span>):</span><font></font>
    self.status = CLOSED<font></font>
 ...<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProjectTask</span>(<span class="hljs-params">Task</span>):</span>
 <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close</span>(<span class="hljs-params">self</span>):</span>
    <span class="hljs-keyword">if</span> status == STARTED:
        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">"Cannot close a started Project Task"</span>)<font></font>
    ...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ProjectTaskのcloseメソッドは、Taskクラスのオブジェクトが正常に機能する場合に例外をスローします。一般に、基本クラスのメソッドを再定義すると、置換の原則に違反することがよくありますが、問題にはなりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、この場合、開発者は継承を「IS」関係の実装としてではなく、単にコードを再利用する方法として認識します。それら。サブクラスは単なるサブクラスであり、サブタイプではありません。この場合、実用的で実用的な観点から、それはもっと重要です-しかし、子孫クラスと基本クラスのメソッドの異なるセマンティクスに気づくクライアントコードが存在する、またはすでに存在する可能性はどのくらいですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本クラスのオブジェクトを想定しているが、子孫クラスのオブジェクトを渡すコードはたくさんありますか？多くのタスクでは、そのようなコードは決して存在しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LSP違反はいつ大きな問題につながりますか？動作の違いにより、クライアントコードを子孫クラスの変更で書き直す必要がある場合、またはその逆の場合。このクライアントコードが変更できないライブラリコードである場合、これは特に問題になります。コードを再利用しても、クライアントコードとクラスコードの間に依存関係を作成できない場合は、Liskov置換の原則に違反しても、そのようなコードは大きな問題にはならない可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、開発中、継承は2つの観点から見ることができます。サブクラスはサブタイプであり、コントラクトプログラミングとLiskの原則にすべての制限があります。</font><font style="vertical-align: inherit;">それら。</font><font style="vertical-align: inherit;">クラスの責任と契約を考えて設計し、クライアントコードを気にする必要はありません。</font><font style="vertical-align: inherit;">クライアント側のコードが何であるか、クラスがどのように使用されるか、および潜在的な問題に備えるかを検討しますが、程度は低いものの、置換の原則を順守することに注意します。</font><font style="vertical-align: inherit;">いつものように、決定は開発者次第です。最も重要なことは、特定の状況での選択は意識的であり、このソリューションまたはそのソリューションに伴う長所、短所、および落とし穴について理解していることです。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja463365/index.html">Spring Bootを使用したRedisの概要</a></li>
<li><a href="../ja463369/index.html">医師の診察について</a></li>
<li><a href="../ja463371/index.html">モスクワ以外のIT</a></li>
<li><a href="../ja463373/index.html">UXデザインポートフォリオ：ベストプラクティス</a></li>
<li><a href="../ja463375/index.html">Windows 10のWine。</a></li>
<li><a href="../ja463387/index.html">パスQAファイター</a></li>
<li><a href="../ja463389/index.html">パーソナライズ：QIWIの推奨事項との連携方法</a></li>
<li><a href="../ja463391/index.html">数学の観点から全員と結婚する方法（1人、2人、3人の男性の結婚）と男性が常に勝つ理由</a></li>
<li><a href="../ja463393/index.html">あなたの会社は家族ですか、それともスポーツチームですか？</a></li>
<li><a href="../ja463397/index.html">中世の外国為替市場と金融工学</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>