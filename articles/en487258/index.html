<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÇüèΩ üßñ üõ´ Asynchronous PHP üêá ü•á üßëüèΩ‚Äçü§ù‚Äçüßëüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ten years ago, we had a classic LAMP stack: Linux, Apache, MySQL, and PHP, which worked in the slow mode of mod_php. The world has changed, and with i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Asynchronous PHP</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/487258/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ten years ago, we had a classic LAMP stack: Linux, Apache, MySQL, and PHP, which worked in the slow mode of mod_php. The world has changed, and with it the importance of speed. PHP-FPM appeared, which allowed to significantly increase the performance of solutions in PHP, and not to urgently rewrite to something faster. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In parallel, the ReactPHP library was developed using the Event Loop concept for processing signals from the OS and presenting results for asynchronous operations. The development of the idea of ‚Äã‚ÄãReactPHP - AMPHP. This library uses the same Event Loop, but supports coroutines, unlike ReactPHP. They allow you to write asynchronous code that looks like synchronous. Perhaps this is the most current framework for developing asynchronous applications in PHP.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tf/03/e6/tf03e6u08mt8gake9o4lbbfbdca.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But speed is required more and more, tools are already not enough, so the idea of ‚Äã‚Äãasynchronous programming in PHP is one of the ways to speed up query processing and better utilize resources. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is what </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anton Shabovta will</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> talk about </font><font style="vertical-align: inherit;">(</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zloyusr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Is a developer at Onliner. </font><font style="vertical-align: inherit;">Experience over 10 years: I started with desktop applications in C / C ++, and then switched to web development in PHP. </font><font style="vertical-align: inherit;">He writes "Home" projects in C # and Python 3, and in PHP he is experimenting with DDD, CQRS, Event Sourcing, Async Multitasking.</font></font><br>
<a name="habracut"></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This article is based on a transcript of Anton's report on </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP Russia 2019</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In it we will understand blocking and non-blocking operations in PHP, we will study the structure of Event Loop and asynchronous primitives, such as Promise and coroutines, from the inside. </font><font style="vertical-align: inherit;">Finally, we will find out what awaits us in ext-async, AMPHP 3, and PHP 8.</font></font></i><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/w75P9RrVgKg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We introduce a couple of definitions. </font><font style="vertical-align: inherit;">For a long time I tried to find an exact definition of asynchrony and asynchronous operations, but I did not find and wrote mine.</font></font><br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchrony</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the ability of a software system to not block the main thread of execution. </font></font><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An asynchronous operation</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is an operation that does not block the execution flow of a program until it completes.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It seems to be simple, but first you need to understand what operations block the execution flow.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blocking operations</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHP is an interpreter language. </font><font style="vertical-align: inherit;">He reads the code line by line, translates into his instructions and executes. </font><font style="vertical-align: inherit;">On which line from the example below will the code be blocked?</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">User $user</span>)
</span>{
    <span class="hljs-keyword">try</span> {<font></font>
        $sql = <span class="hljs-string">'UPDATE users SET ...'</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;connection-&gt;execute($sql, $user-&gt;data());<font></font>
    } <span class="hljs-keyword">catch</span> (\PDOException $error) {<font></font>
        log($error-&gt;getMessage());<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we connect to the database via PDO, the thread of execution will be blocked on the query string to SQL-server: </font></font><code>return $this-&gt;connection-&gt;execute($sql, $user-&gt;data());</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is because PHP does not know how long the SQL server will process this query and whether it will execute at all. </font><font style="vertical-align: inherit;">It waits for a response from the server and the program has not been running all this time. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHP also blocks the flow of execution on all I / O operations.</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">File System</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><code>fwrite</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>file_get_contents</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Databases</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><code>PDOConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>RedisClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Almost all extensions for connecting a database work in blocking mode by default.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Processes</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><code>exec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>system</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>proc_open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">These are blocking operations, since all work with processes is built through system calls.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Working with stdin / stdout</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><code>readline</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>echo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>print</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, execution is blocked on </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">timers</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><code>sleep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>usleep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">These are operations in which we explicitly tell the thread to fall asleep for a while. </font><font style="vertical-align: inherit;">PHP will be idle all this time.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronous SQL Client</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But modern PHP is a general-purpose language, and not just for the web like PHP / FI in 1997. </font><font style="vertical-align: inherit;">Therefore, we can write an asynchronous SQL client from scratch. </font><font style="vertical-align: inherit;">The task is not the most trivial, but solvable.</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execAsync</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> $query, <span class="hljs-keyword">array</span> $params = []</span>)
</span>{<font></font>
    $socket = stream_socket_client(<span class="hljs-string">'127.0.0.1:3306'</span>, ...);<font></font>
<font></font>
    stream_set_blocking($socket, <span class="hljs-literal">false</span>);<font></font>
<font></font>
    $data = <span class="hljs-keyword">$this</span>-&gt;packBinarySQL($query, $params);<font></font>
    <font></font>
    socket_write($socket, $data, strlen($data));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What does such a client do? </font><font style="vertical-align: inherit;">It connects to our SQL server, puts the socket in non-blocking mode, packs the request in a binary format that the SQL server understands, writes data to the socket. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since the socket is in non-blocking mode, the write operation from PHP is fast. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But what will return as a result of such an operation? </font><font style="vertical-align: inherit;">We do not know what the SQL server will respond. </font><font style="vertical-align: inherit;">It may take a long time to complete the request or not at all. </font><font style="vertical-align: inherit;">But something needs to be returned? </font><font style="vertical-align: inherit;">If we use PDO and call the </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">query on the SQL server, we are returned </font></font><code>affected rows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- the number of rows changed by this query. </font><font style="vertical-align: inherit;">We cannot return it yet, therefore we only </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">promise a</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> return.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a concept from the world of asynchronous programming.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise is a wrapper object over the result of an asynchronous operation. </font><font style="vertical-align: inherit;">Moreover, the result of the operation is still unknown to us.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, there is no single Promise standard, and it is not possible to directly transfer standards from the JavaScript world to PHP.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How Promise Works</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since there is no result yet, we can only establish some </font></font><code>callbacks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ia/n1/qq/ian1qqvr_xs0faonifptkfrd2jc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When data is available, it is necessary to execute a callback </font></font><code>onResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/8v/bk/sf/8vbksfxvsfxskeozp3jckft5rmg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If an error occurs, a callback will be executed </font></font><code>onReject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to handle the error. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/8x/hw/0v/8xhw0vsdhfryxyxalvsydiydfsc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Promise interface looks something like this.</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Promise</span>
</span>{
    <span class="hljs-keyword">const</span>
        STATUS_PENDING = <span class="hljs-number">0</span>,<font></font>
        STATUS_RESOLVED = <span class="hljs-number">1</span>,<font></font>
        STATUS_REJECTED = <span class="hljs-number">2</span><font></font>
    ;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onResolve</span>(<span class="hljs-params"><span class="hljs-keyword">callable</span> $callback</span>)</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onReject</span>(<span class="hljs-params"><span class="hljs-keyword">callable</span> $callback</span>)</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">$data</span>)</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">\<span class="hljs-built_in">Throwable</span> $error</span>)</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Promise has status and methods for setting callbacks and populating ( </font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Promise with data or error ( </font></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">But there are differences and variations. </font><font style="vertical-align: inherit;">Methods may be called differently, or instead of separate methods for establishing callbacks, </font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and there </font></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">may be some one, as in AMPHP, for example. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Often techniques to fill Promise </font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">take out in a separate object </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Deferred</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - storage state asynchronous function. </font><font style="vertical-align: inherit;">It can be considered as a kind of factory for Promise. </font><font style="vertical-align: inherit;">It is one-time: one Deferred makes one Promise. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bq/on/aq/bqonaqi04ql4kdhakfezn9nu25g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How to apply this in the SQL client if we decide to write it ourselves?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronous SQL Client</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, we created Deferred, did all the work with sockets, wrote down the data and returned Promise - everything is simple.</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execAsync</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> $query, <span class="hljs-keyword">array</span> $params = []</span>)
</span>{<font></font>
    $deferred = <span class="hljs-keyword">new</span> Deferred;<font></font>
<font></font>
    $socket = stream_socket_client(<span class="hljs-string">'127.0.0.1:3306'</span>, ...);<font></font>
    stream_set_blocking($socket, <span class="hljs-literal">false</span>);<font></font>
<font></font>
    $data = <span class="hljs-keyword">$this</span>-&gt;packBinarySQL($query, $params);<font></font>
    socket_write($socket, $data, strlen($data));<font></font>
<font></font>
    <span class="hljs-keyword">return</span> $deferred-&gt;promise();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When we have Promise, we can, for example:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">set the callback and get the ones </font></font><code>affected rows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that returns to us </font></font><code>PDOConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">handle the error, add to the log;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retry the query if the SQL server responds with an error.</font></font></li>
</ul><br>
<pre><code class="php hljs">$promise = <span class="hljs-keyword">$this</span>-&gt;execAsync($sql, $user-&gt;data());<font></font>
<font></font>
$promise-&gt;onResolve(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-keyword">int</span> $rows</span>) </span>{
    <span class="hljs-keyword">echo</span> <span class="hljs-string">"Affected rows: {$rows}"</span>;<font></font>
});<font></font>
<font></font>
$promise-&gt;onReject(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">\<span class="hljs-built_in">Throwable</span> $error</span>) </span>{<font></font>
    log($error-&gt;getMessage());<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The question remains: we set the callback, and who will call </font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Event loop</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is the concept of </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Event Loop - an event loop</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">He is able to process messages in an asynchronous environment. </font><font style="vertical-align: inherit;">For asynchronous I / O, these will be messages from the OS that the socket is ready to read or write. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How it works.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The client tells Event Loop that it is interested in some kind of socket.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Event Loop polls the OS through a system call </font></font><code>stream_select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: is the socket ready, is all the data written, is the data coming from the other side.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the OS reports that the socket is not ready, blocked, then Event Loop repeats the loop.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the OS notifies that the socket is ready, Event Loop returns control to the client and enables ( </font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Promise.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/ln/ey/bb/lneybbz-tylmfanfoizqm2hscik.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We express this concept in the code: take the simplest case, remove the error handling and other nuances, so that one infinite loop remains. </font><font style="vertical-align: inherit;">In each iteration, it will poll the OS about sockets that are ready to read or write, and call a callback for a specific socket.</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>)
</span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {<font></font>
        stream_select($readSockets, $writeSockets, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>);<font></font>
        <font></font>
        <span class="hljs-keyword">foreach</span> ($readSockets <span class="hljs-keyword">as</span> $i =&gt; $socket) {<font></font>
            call_user_func(<span class="hljs-built_in">self</span>::readCallbacks[$i], $socket);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">// Do same for write sockets</span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We complement our SQL client. </font><font style="vertical-align: inherit;">We inform Event Loop that as soon as the data from the SQL server comes to the socket we are working with, we need to bring Deferred to the ‚Äúdone‚Äù state and transfer the data from the socket to Promise.</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execAsync</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> $query, <span class="hljs-keyword">array</span> $params = []</span>)
</span>{<font></font>
    $deferred = <span class="hljs-keyword">new</span> Deferred;<font></font>
    ...<font></font>
    Loop::onReadable($socket, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$socket</span>) <span class="hljs-title">use</span> (<span class="hljs-params">$deferred</span>) </span>{<font></font>
        $deferred-&gt;resolve(socket_read($socket));<font></font>
    });<font></font>
<font></font>
    <span class="hljs-keyword">return</span> $deferred-&gt;promise();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Event Loop </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can handle our I / O</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">works with sockets</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">What else can he do?</font></font><br>
<br>
<ul>
<li> JavaScript   <code>setTimeout</code>  <code>setInterval</code> ‚Äî .             N . <strong>Event Loop      </strong>.</li>
<li>Event Loop  <strong>   </strong>.    <code>process control</code>,       .</li>
</ul><br>
<h3> Event Loop</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Writing your Event Loop is not only possible, but also necessary. If you want to work with asynchronous PHP, it is important to write your own simple implementation to understand how this works. But in production, we, of course, will not use it, but we will take ready-made implementations: stable, error-free and proven in work. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are three main implementations. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReactPHP</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The oldest project, started back in PHP 5.3. Now the minimum required version of PHP is 5.3.8. The project implements the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promises / A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> standard </font><font style="vertical-align: inherit;">from the JavaScript world. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMPHP</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It is this implementation that I prefer to use. The minimum requirement is PHP 7.0, and since the next version is already 7.3. It uses coroutines on top of Promise. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swoole</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is an interesting Chinese framework in which developers try to port some concepts from the Go world to PHP. </font><font style="vertical-align: inherit;">The documentation in English is incomplete, most of it on GitHub in Chinese. </font><font style="vertical-align: inherit;">If you know the language, go ahead, but so far I‚Äôm scared to work.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zo/n3/cq/zon3cqtbmsf-vnd0uliqqupphoo.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReactPHP</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's see what the client will look like using ReactPHP for MySQL.</font></font><br>
<br>
<pre><code class="php hljs">$connection = (<span class="hljs-keyword">new</span> ConnectionFactory)-&gt;createLazyConnection();<font></font>
<font></font>
$promise = $connection-&gt;query(<span class="hljs-string">'UPDATE users SET ...'</span>);<font></font>
$promise-&gt;then(<font></font>
    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">QueryResult $command</span>) </span>{
        <span class="hljs-keyword">echo</span> count($command-&gt;resultRows) . <span class="hljs-string">' row(s) in set.'</span>;<font></font>
    },<font></font>
    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">Exception</span> $error</span>) </span>{
        <span class="hljs-keyword">echo</span> <span class="hljs-string">'Error: '</span> . $error-&gt;getMessage();<font></font>
    });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything is almost the same as we wrote: we create </font></font><code>onnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and execute the request. </font><font style="vertical-align: inherit;">We can set the callback to process the results (return </font></font><code>affected rows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br>
<br>
<pre><code class="php hljs">    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">QueryResult $command</span>) </span>{
        <span class="hljs-keyword">echo</span> count($command-&gt;resultRows) . <span class="hljs-string">' row(s) in set.'</span>;<font></font>
    },</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
and callback for error handling:</font></font><br>
<br>
<pre><code class="php hljs">    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">Exception</span> $error</span>) </span>{
        <span class="hljs-keyword">echo</span> <span class="hljs-string">'Error: '</span> . $error-&gt;getMessage();<font></font>
    });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From these callbacks you can build long-long chains, because each result </font></font><code>then</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in ReactPHP also returns Promise.</font></font><br>
<br>
<pre><code class="php hljs">$promise<font></font>
    -&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$data</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(...);<font></font>
    })<font></font>
    -&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$data</span>) </span>{<font></font>
        ...<font></font>
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$error</span>) </span>{<font></font>
        log($error);<font></font>
    })<font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a solution to a problem called callback hell. </font><font style="vertical-align: inherit;">Unfortunately, in the ReactPHP implementation, this leads to the ‚ÄúPromise hell‚Äù problem, when </font><strong><font style="vertical-align: inherit;">10-11 callbacks are </font></strong></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">required to correctly connect RabbitMQ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Working with such code and fixing it is difficult. </font><font style="vertical-align: inherit;">I quickly realized that this was not mine and switched to AMPHP.</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Amphp</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This project is younger than ReactPHP and promotes a different concept - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coroutines</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If you look at working with MySQL in AMPHP, you can see that this is almost the same as working with </font></font><code>PDOConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in PHP.</font></font><br>
<br>
<pre><code class="php hljs">$pool = Mysql\pool(<span class="hljs-string">"host=127.0.0.1 port=3306 db=test"</span>);<font></font>
<font></font>
<span class="hljs-keyword">try</span> {<font></font>
    $result = <span class="hljs-keyword">yield</span> $pool-&gt;query(<span class="hljs-string">"UPDATE users SET ..."</span>);<font></font>
<font></font>
    <span class="hljs-keyword">echo</span> $result-&gt;affectedRows . <span class="hljs-string">' row(s) in set.'</span>;<font></font>
} <span class="hljs-keyword">catch</span> (\<span class="hljs-built_in">Throwable</span> $error) {
    <span class="hljs-keyword">echo</span> <span class="hljs-string">'Error: '</span> . $error-&gt;getMessage();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we create a pool, connect and execute the request. </font><font style="vertical-align: inherit;">We can handle errors through the usual ones </font></font><code>try...catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we do not need callbacks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But before the asynchronous call, the keyword - appears here </font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generators</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The keyword </font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">turns our function into a generator.</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generator</span>(<span class="hljs-params">$counter = <span class="hljs-number">1</span></span>)
</span>{
    <span class="hljs-keyword">yield</span> $counter++;<font></font>
<font></font>
    <span class="hljs-keyword">echo</span> <span class="hljs-string">"A"</span>;<font></font>
<font></font>
    <span class="hljs-keyword">yield</span> $counter;<font></font>
<font></font>
    <span class="hljs-keyword">echo</span> <span class="hljs-string">"B"</span>;<font></font>
<font></font>
    <span class="hljs-keyword">yield</span> ++$counter;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As soon as the PHP interpreter encounters </font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">functions in the body, it realizes that it is a generator function. </font><font style="vertical-align: inherit;">Instead of executing, a class object is created when called </font></font><code>Generator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Generators inherit the iterator interface.</font></font><br>
<br>
<pre><code class="php hljs">$generator = <span class="hljs-built_in">generator</span>(<span class="hljs-number">1</span>);<font></font>
<font></font>
<span class="hljs-keyword">foreach</span> ($generator <span class="hljs-keyword">as</span> $value) {
    <span class="hljs-keyword">echo</span> $value;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">while</span> ($generator-&gt;valid()) {
    <span class="hljs-keyword">echo</span> $generator-&gt;current();<font></font>
<font></font>
    $generator-&gt;next();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Accordingly, it is possible to run cycles </font></font><code>foreach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and others. </font><font style="vertical-align: inherit;">But, more interestingly, the iterator has methods </font></font><code>current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Let's go through them step by step. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Run our function </font></font><code>generator($counter = 1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We call the generator method </font></font><code>current()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The value of the variable will be returned </font></font><code>$counter++</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As soon as we execute the generator </font></font><code>next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the code will go to the next call inside the generator </font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The whole piece of code between the two </font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will execute, and that's cool. </font><font style="vertical-align: inherit;">Continuing to spin the generator, we get the result.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutines</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But the generator has a more interesting function - we can send data to the generator from the outside. </font><font style="vertical-align: inherit;">In this case, this is not quite a generator, but a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coroutine</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or coroutine.</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printer</span>(<span class="hljs-params"></span>) </span>{  
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {     
        <span class="hljs-keyword">echo</span> <span class="hljs-keyword">yield</span>;       <font></font>
    }                             <font></font>
}                                <font></font>
<font></font>
$print = printer();<font></font>
$print-&gt;send(<span class="hljs-string">'Hello'</span>);<font></font>
$print-&gt;send(<span class="hljs-string">' PHPRussia'</span>);<font></font>
$print-&gt;send(<span class="hljs-string">' 2019'</span>);<font></font>
$print-&gt;send(<span class="hljs-string">'!'</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this section of the code, it is interesting that it </font></font><code>while (true)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will not block the flow of execution, but will be executed once. </font><font style="vertical-align: inherit;">We sent the data to Corutin and received </font></font><code>'Hello'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sent more - received </font></font><code>'PHPRussia'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The principle is clear. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition to sending data to the generator, you can send errors and process them from the inside, which is convenient.</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printer</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">echo</span> <span class="hljs-keyword">yield</span>;<font></font>
    } <span class="hljs-keyword">catch</span> (\<span class="hljs-built_in">Throwable</span> $e) {
        <span class="hljs-keyword">echo</span> $e-&gt;getMessage();<font></font>
    }<font></font>
}<font></font>
<font></font>
printer()-&gt;throw(<span class="hljs-keyword">new</span> \<span class="hljs-built_in">Exception</span>(<span class="hljs-string">'Ooops...'</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To summarize. </font><font style="vertical-align: inherit;">Corutin is a component of a program that </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">supports stopping and continuing execution while maintaining the current state</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Corutin remembers his call stack, the data inside, and can use them in the future.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generators and Promise</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at the generator and Promise interfaces.</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generator</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">send</span>(<span class="hljs-params">$data</span>)</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throw</span>(<span class="hljs-params">\<span class="hljs-built_in">Throwable</span> $error</span>)</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">$data</span>)</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">\<span class="hljs-built_in">Throwable</span> $error</span>)</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
They look the same, except for different method names. </font><font style="vertical-align: inherit;">We can send data and throw an error to both the generator and Promise. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How can this be used? </font><font style="vertical-align: inherit;">Let's write a function.</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recoil</span>(<span class="hljs-params">\<span class="hljs-built_in">Generator</span> $generator</span>)
</span>{<font></font>
    $promise = $generator-&gt;current();<font></font>
<font></font>
    $promise-&gt;onResolve(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$data</span>) <span class="hljs-title">use</span> (<span class="hljs-params">$generator</span>) </span>{<font></font>
        $generator-&gt;send($data);<font></font>
        recoil($generator);<font></font>
    };<font></font>
<font></font>
    $promise-&gt;onReject(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$error</span>) <span class="hljs-title">use</span> (<span class="hljs-params">$generator</span>) </span>{<font></font>
        $generator-&gt;throw($error);<font></font>
        recoil($generator);<font></font>
    });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The function takes the current value of the generator: </font></font><code> $promise = $generator-&gt;current();</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I exaggerated a little. </font><font style="vertical-align: inherit;">Yes, we must check that the current value that is returned to us is some kind of </font></font><code>instanceof</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise. </font><font style="vertical-align: inherit;">If so, then we can ask him a callback. </font><font style="vertical-align: inherit;">It internally sends the data back to the generator when Promise succeeds and recursively starts the function </font></font><code>recoil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="php hljs">    $promise-&gt;onResolve(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$data</span>) <span class="hljs-title">use</span> (<span class="hljs-params">$generator</span>) </span>{<font></font>
        $generator-&gt;send($data);<font></font>
        recoil($generator);<font></font>
    };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The same can be done with errors. </font><font style="vertical-align: inherit;">If Promise failed, for example, the SQL server said ‚ÄúToo many connections‚Äù, then we can throw the error inside the generator and go to the next step. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All this brings us to the important concept of cooperative multitasking.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cooperative multitasking</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a type of multitasking, in which the next task is performed only after the current task explicitly declares itself ready to give processor time to other tasks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I rarely come across something simple, such as working with only one database. Most often, in the process of updating the user, you need to update the data in the database, in the search index, then clean or update the cache, and then send 15 more messages to RabbitMQ. In PHP, it all looks like this. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m6/w7/5n/m6w75nkbjrduxzynamn9qiinfwm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We perform operations one by one: we updated the database, index, and then the cache. But by default, PHP blocks on such operations (I / O), so if you look closely, in fact, everything is so. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wk/3d/wc/wk3dwckb_gjjfnoprw63gxnoxlm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the dark parts we blocked. They take the most time. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we work in asynchronous mode, then these parts are not there, the execution timeline is intermittent.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qj/mx/xv/qjmxxv9oiwkix-_oebyl48qbio4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can glue it all together and make pieces one by one. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t0/o0/x5/t0o0x5ddiw6pij4rlmvzst2oyaq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is all this for? </font><font style="vertical-align: inherit;">If you look at the size of the timeline, at first it takes a lot of time, but as soon as we glue it together, the application accelerates. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The very concept of Event Loop and cooperative multitasking has long been used in various applications: Nginx, Node.js, Memcached, Redis. </font><font style="vertical-align: inherit;">All of them use inside Event Loop and are built on the same principle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since we started talking about the Nginx and Node.js web servers, let's recall how the processing of requests in PHP takes place.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Request Processing in PHP</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The browser sends a request, it gets to the HTTP server behind which there is a pool of FPM streams. </font><font style="vertical-align: inherit;">One of the threads takes this request into operation, connects our code and starts to execute it. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/s1/p_/bgs1p_g8r9ytthxrst0mszi7_bw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When the next request arrives, another FPM thread will pick it up, connect the code and it will be executed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">advantages to</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> this work scheme </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simple error handling</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If something went wrong and one of the requests fell, we do not need to do anything - the next one will come, and this will not affect its work.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We do not think about memory</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">We do not need to clean or monitor the memory. </font><font style="vertical-align: inherit;">On the next request, all memory will be cleared.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a cool scheme that worked in PHP from the very beginning and still works successfully. </font><font style="vertical-align: inherit;">But there are also </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disadvantages</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limit the number of processes</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If we have 50 FPM threads on the server, then as soon as the 51st request arrives, it will wait until one of the threads becomes free.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Costs for Context Switch</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The OS switches requests between FPM streams. </font><font style="vertical-align: inherit;">This processor-level operation is called Context Switch. </font><font style="vertical-align: inherit;">It is expensive and runs a huge number of measures. </font><font style="vertical-align: inherit;">It is necessary to save all the registers, the call stack, everything that is in the processor, then switch to another process, load its registers and its call stack, perform something there again, switch again, save again ... For a long time.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's approach the question differently - we will write an HTTP server in PHP itself.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronous HTTP Server</font></font></h2><br>
<img src="https://habrastorage.org/webt/nd/dy/yt/nddyyt6dhjy0dxnkmpokppvvcr4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It can be done. </font><font style="vertical-align: inherit;">We have already learned how to work with sockets in non-blocking mode, and an HTTP connection is the same socket. </font><font style="vertical-align: inherit;">How will it look and work? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is an example of starting HTTP servers in the AMPHP framework.</font></font><br>
<br>
<pre><code class="php hljs">Loop::run(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{<font></font>
    $app = <span class="hljs-keyword">new</span> Application();<font></font>
    $app-&gt;bootstrap();<font></font>
<font></font>
    $sockets = [Socket\listen(<span class="hljs-string">'0.0.0.0:80'</span>)];<font></font>
<font></font>
    $server = <span class="hljs-keyword">new</span> Server($sockets, <span class="hljs-keyword">new</span> CallableRequestHandler(
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Request $request</span>) <span class="hljs-title">use</span> (<span class="hljs-params">$app</span>) </span>{<font></font>
            $response = <span class="hljs-keyword">yield</span> $app-&gt;dispatch($request);<font></font>
<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response(Status::OK, [], $response);<font></font>
        })<font></font>
    );<font></font>
<font></font>
    <span class="hljs-keyword">yield</span> $server-&gt;start();<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything is quite simple: load </font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and create a socket pool (one or more). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, we start our server, set it </font></font><code>Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which will be executed on each request and send the request to ours </font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in order to get a response. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The last thing to do is start the server </font></font><code>yield $server-&gt;start();</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In ReactPHP it will look approximately the same, but only there will be 150 callbacks for different options, which is not very convenient.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problems</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are several issues with asynchrony in PHP. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lack of standards</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Each framework: Swoole, ReactPHP, or AMPHP, implements its own Promise interface, and they are incompatible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AMPHP could theoretically interact with Promise from ReactPHP, but there is a caveat. If the code for ReactPHP is not very well written, and somewhere implicitly calls or creates an Event Loop, then it turns out that two Event Loops will spin inside. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript has a relatively good Promises / A + standard that implements Guzzle. It would be nice if the frameworks follow it. But so far this is not. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory leaks</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. When we work in PHP in the usual FPM mode, we may not think about memory. Even if the developers of some extension forgot to write good code, forgot to run through Valgrind, and somewhere inside the memory is flowing, then there is nothing to worry about - the next request will be cleared and start over. But in asynchronous mode, you cannot afford this, because sooner or later we will simply fall off </font></font><code>OutOfMemoryException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is possible to repair, but it is difficult and painful. In some cases, Xdebug helps, in others, strace to parse the errors that caused </font></font><code>OutOfMemoryException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blocking operations</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It is vital not to block Event Loop when we write asynchronous code. The application slows down as soon as we block the flow of execution, each of our coroutines starts to run slower.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kelunik / loop-block</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> package will help find such operations for AMPHP </font><font style="vertical-align: inherit;">. He sets the timer to a very small interval. If the timer does not work, then we are blocked somewhere. The package helps in finding blocking places, but not always: blocking in some extensions may not be noticed. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Library Support: Cassandra, Influx, ClickHouse</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The main problem of all asynchronous PHP is the support of libraries. We cannot use the usual </font></font><code>PDOConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>RedisClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">other drivers for </font><font style="vertical-align: inherit;">everyone </font><font style="vertical-align: inherit;">- we need non-blocking implementations. They must also be written in PHP in non-blocking mode, because C drivers rarely provide interfaces that can be integrated into asynchronous code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The strangest experience I got with the driver for the Cassandra database. They provide operations</font></font><code>ExecuteAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>GetAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and others, but at the same time they return an object </font></font><code>Future</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with a single method </font></font><code>get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that blocks. </font><font style="vertical-align: inherit;">There is an opportunity to get something asynchronously, but to wait for the result, we will still block our entire Loop. </font><font style="vertical-align: inherit;">To do it somehow differently, for example, through callbacks, it does not work. </font><font style="vertical-align: inherit;">I even wrote my client for Cassandra, because we use it in our work. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Type indication</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This is a problem of AMPHP and corutin.</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> $id</span>): \<span class="hljs-title">Generator</span>
    </span>{<font></font>
        $data = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">$this</span>-&gt;db-&gt;query(<span class="hljs-string">'SELECT ...'</span>, $id);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> User::fill($data);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If it occurs in a function </font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then it becomes a generator. </font><font style="vertical-align: inherit;">At this point, we can no longer specify the correct return data types.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP 8</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What awaits us in PHP 8? </font><font style="vertical-align: inherit;">I‚Äôll tell you about my assumptions or, rather, my desires ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">editor's note: Dmitry Stogov </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">knows</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> what will actually appear in PHP 8</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Event Loop </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a chance that it will appear, because work is underway to bring Event Loop in some form to the kernel. </font><font style="vertical-align: inherit;">If this happens, we will have a function </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, like in JavaScript or C #, which will allow us to wait for the result of the asynchronous operation in a certain place. </font><font style="vertical-align: inherit;">In this case, we will not need any extensions, everything will work asynchronously at the kernel level.</font></font><br>
<br>
<pre><code class="php hljs">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> $id</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">User</span>&gt;
    </span>{<font></font>
        $data = await <span class="hljs-keyword">$this</span>-&gt;db-&gt;query(<span class="hljs-string">'SELECT ...'</span>, $id);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> User::fill($data);<font></font>
    }<font></font>
}</code></pre><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generics </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go is waiting for Generics, we are waiting for Generics, everyone is waiting for Generics.</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span>
</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> $id</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">User</span>&gt;
    </span>{<font></font>
        $data = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">$this</span>-&gt;db-&gt;query(<span class="hljs-string">'SELECT ...'</span>, $id);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> User::fill($data);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But we are not waiting for Generics for collections, but to indicate that the result of Promise will be exactly the User object.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why all this?</font></font></h2><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For speed and performance.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP is a language in which most of the operations are I / O bound. </font><font style="vertical-align: inherit;">We rarely write code that is significantly tied to computations in the processor. </font><font style="vertical-align: inherit;">Most likely, we work with sockets: we need to make a request to the database, read something, return a response, send a file. </font><font style="vertical-align: inherit;">Asynchrony allows you to speed up such code. </font><font style="vertical-align: inherit;">If we look at the average response time for 1000 requests, we can accelerate by about 8 times, and by 10,000 requests by almost 6!</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">May 13, 2020, we will gather for the second time in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP Russia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to discuss the language, libraries and frameworks, ways to increase productivity and the pitfalls of hype solutions. </font><font style="vertical-align: inherit;">We have accepted the first 4 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reports</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but Call for Papers is still coming. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apply</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if you want to share your experience with the community.</font></font></blockquote></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/en487258/">https://habr.com/ru/post/en487258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en487246/index.html">Tensor Certification Authority may compromise customer private keys</a></li>
<li><a href="../en487248/index.html">A little more about improper testing</a></li>
<li><a href="../en487250/index.html">Delayed Alpha blending</a></li>
<li><a href="../en487254/index.html">How to use CCTV cameras not only to monitor intruders</a></li>
<li><a href="../en487256/index.html">Burn and return from the ashes or Phoenix people</a></li>
<li><a href="../en487260/index.html">NoVerify: a PHP linter that works fast</a></li>
<li><a href="../en487262/index.html">Open conference PHP Russia Online</a></li>
<li><a href="../en487266/index.html">GitLab 12.7 released with Parent-Child pipelines and beta version of common job handlers for Windows</a></li>
<li><a href="../en487270/index.html">Perovskites can extend the life of gadget screens</a></li>
<li><a href="../en487272/index.html">Bookmarks - counting is finished</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>