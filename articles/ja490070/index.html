<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍵 🖐️ 🙋🏾 メッセンジャーを書いたとき 🛁 🖕🏼 🍝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ある夜、苛立たしい一日が続き、ゲームのバランスをとろうとする試みでいっぱいになり、私は緊急に休息が必要だと判断しました。私は別のプロジェクトに切り替え、すぐにそれを行い、ゲームの開発中に転がっていた自尊心を取り戻し、新たな活気でゲームを嵐に巻き込みます！主なことは、素敵でリラックスできるプロジェクト...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>メッセンジャーを書いたとき</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490070/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ある夜、苛立たしい一日が続き、ゲームのバランスをとろうとする試みでいっぱいになり、私は緊急に休息が必要だと判断しました。</font><font style="vertical-align: inherit;">私は別のプロジェクトに切り替え、すぐにそれを行い、ゲームの開発中に転がっていた自尊心を取り戻し、新たな活気でゲームを嵐に巻き込みます！</font><font style="vertical-align: inherit;">主なことは、素敵でリラックスできるプロジェクトを選ぶことです...あなた自身のメッセンジャーを書きますか？</font><font style="vertical-align: inherit;">ハ！</font><font style="vertical-align: inherit;">それはどれほど難しいでしょうか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここにあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><img src="https://habrastorage.org/webt/_b/cw/av/_bcwavbn-h0r3vgv8zzhdkaq09y.jpeg"></td>
<td><img src="https://habrastorage.org/webt/97/4x/qd/974xqd470ltfwu6gge0hfnaqry4.jpeg"></td>
</tr>
</tbody></table></div><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単な背景</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセンジャーの作業を開始する前のほぼ1年間、彼はオンラインマルチプレイヤーLine Tower Warsゲームに取り組んでいました。</font><font style="vertical-align: inherit;">プログラミングはうまくいき、他のすべて（特にバランスとビジュアル）はあまり良くありませんでした。</font><font style="vertical-align: inherit;">突然、ゲームを作ることと楽しいゲーム（自分以外の人にとって楽しい）を作ることは2つの異なるものであることが判明しました。</font><font style="vertical-align: inherit;">試練の1年後、私は注意散漫になる必要があったので、私は何か他のものに手を試すことにしました。</font><font style="vertical-align: inherit;">選択はモバイル開発、すなわちFlutterにかかった。</font><font style="vertical-align: inherit;">Flutterについて多くの良いことを聞いたし、短い実験の後でダーツが好きだった。</font><font style="vertical-align: inherit;">自分でメッセンジャーを書くことにしました。</font><font style="vertical-align: inherit;">まず、クライアントとサーバーの両方を実装することをお勧めします。</font><font style="vertical-align: inherit;">第二に、仕事を探すためにポートフォリオに入れるべき重要なものがあるでしょう。私はまさにその過程です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スケジュールされた機能</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プライベートおよびグループチャット</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テキスト、画像、動画を送信する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音声通話とビデオ通話</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">受け取りと読み取りの確認（Votsapからのティック）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「プリント...」</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お知らせ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QRコードと地理位置情報で検索</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将来的には、計画されているほとんどすべてが実装されており、まだ実装されていません。近いうちに実装される予定です。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://player.vimeo.com/video/393246625" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">言語選択</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語の選択については長い間考えていませんでした。</font><font style="vertical-align: inherit;">最初は、クライアントとサーバーの両方にダーツを使用するのが魅力的でしたが、より詳細な調査により、ダーツ用のドライバーが多くないこと、および信頼性があまり高くないものがあることがわかりました。</font><font style="vertical-align: inherit;">現時点での話はしませんが、状況は改善されたかもしれません。</font><font style="vertical-align: inherit;">だから私の選択は、私がUnityで働いていたC＃に当てはまりました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建築</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼はまず建築について考え始めました。</font><font style="vertical-align: inherit;">もちろん、3人半の人が私のメッセンジャーを使用する可能性が最も高いことを考えると、一般的にアーキテクチャーを気にする必要はありません。</font><font style="vertical-align: inherit;">あなたは無数のチュートリアルのように取り、行います。</font><font style="vertical-align: inherit;">これがノード、ここがモンゴ、ここがWebソケットです。</font><font style="vertical-align: inherit;">できました。</font><font style="vertical-align: inherit;">そして、Firebaseがここにあります。</font><font style="vertical-align: inherit;">しかし、それは面白くありません。</font><font style="vertical-align: inherit;">数百万の同時クライアントを期待するかのように、水平方向に簡単に拡張できるメッセンジャーを作成することにしました。</font><font style="vertical-align: inherit;">しかし、私はこの分野での経験がなかったため、エラーの方法とエラーの方法で実際にすべてを学ぶ必要がありました。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最終的なアーキテクチャはこのようになります</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/xp/jc/n7/xpjcn7otuw8am5jv9yztpp1sgyu.png"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのようなアーキテクチャは非常に優れた信頼性があるとは言いませんが、それは実行可能であり</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、理論</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的には</font><font style="vertical-align: inherit;">重い負荷に耐え、水平方向に拡張する必要がありますが、確認方法がよくわかりません。</font><font style="vertical-align: inherit;">そして、私以外の誰もが知っている明らかな瞬間を見逃さなかったことを願っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、個々のコンポーネントの詳細な説明です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロントエンドサーバー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームの作成を始める前から、非同期シングルスレッドサーバーの概念に魅了されました。</font><font style="vertical-align: inherit;">効果的かつ潜在的な人種差別なし-他に何を求めることができますか。</font><font style="vertical-align: inherit;">このようなサーバーがどのように配置されているかを理解するために、私は</font></font><code>asyncio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">python言語</font><font style="vertical-align: inherit;">モジュールについて詳しく調べ始めました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私が見たソリューションは非常にエレガントに見えました。</font><font style="vertical-align: inherit;">つまり、疑似コードソリューションは次のようになります。</font></font><br>
<pre><code class="cs hljs"><span class="hljs-comment">//  ,      ,    </span>
<span class="hljs-comment">//       .      socket.Receive</span>
<span class="hljs-comment">//     , :</span>
<span class="hljs-keyword">var</span> bytesReceived = Completer&lt;<span class="hljs-keyword">object</span>&gt;();<font></font>
selector.Register(<font></font>
    socket,<font></font>
    SocketEvent.Receive,<font></font>
    () =&gt; bytesReceived.Complete(<span class="hljs-literal">null</span>)<font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">await</span> bytesReceived.Future;<font></font>
<font></font>
<span class="hljs-keyword">int</span> n = socket.Receive(...); <span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-comment">// selector -     poll.   </span>
<span class="hljs-comment">//        (Receive </span>
<span class="hljs-comment">//  ), ,    ,  .</span>
<span class="hljs-comment">//   completer,      ,</span>
<span class="hljs-comment">//        , ,     .</span>
<span class="hljs-comment">//     ,       .</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この単純な手法を使用すると、単一のスレッドで多数のソケットを処理できます。</font><font style="vertical-align: inherit;">バイトの受信または送信を待機している間、ストリームをブロックすることはありません。</font><font style="vertical-align: inherit;">ストリームは常に有用な作業で忙しいです。</font><font style="vertical-align: inherit;">一言で言えば、並行性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フロントエンドサーバーはそのように実装されます。</font><font style="vertical-align: inherit;">それらはすべてシングルスレッドで非同期です。</font><font style="vertical-align: inherit;">したがって、最大のパフォーマンスを得るには、1つのマシンでコア（図の4）と同じ数のサーバーを実行する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フロントエンドサーバーはクライアントからメッセージを読み取り、メッセージコードに基づいてKafkaのトピックの1つに送信します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kafaに慣れていない人のための小さな脚注</font></font></b><div class="spoiler_text">   ,          RabbitMQ.    .       ,              (   authentication backend     authentication, ).  ?      -  ,         (partition).      ,      .      ,   ,       . ,             ( ,   ,  ,     (headers)).<br>
<br>
  ?     ?      .   (consumer)         (  consumer'),    ( )      . , ,      ,    2 ,       .   3 —     2.                .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フロントエンドサーバーはキーなしでkafkaにメッセージを送信します（キーがない場合、kafkaは単に順番にメッセージをパーティーに送信します）。メッセージは、対応するバックエンドサーバーの1つによってトピックから取得されます。サーバーはメッセージを処理し、...次はどうしますか？そして、さらにメッセージの種類によって異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も一般的なケースでは、要求と応答のサイクルが発生します。たとえば、登録リクエストの場合、クライアントに回答（</font></font><code>Success</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>EmailAlreadyInUse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、など）。しかし、新しいメンバー（Vasya、Emil、Julia）の既存のチャットへの招待を含むメッセージに対しては、3つの異なるタイプのメッセージで即座に応答する必要があります。最初のタイプ-操作の結果について招待者に通知する必要があります（突然サーバーエラーが発生しました）。 2番目のタイプ-チャットの現在のすべてのメンバーに、そのような新しいメンバーがチャットに参加していることを通知する必要があります。 3つ目は、Vasya、Emil、Yuliaに招待状を送信することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それほど難しくはありませんが、クライアントにメッセージを送信するには、次のことを行う必要があります。1）このクライアントが接続されているフロントエンドサーバーを確認します（クライアントが接続するサーバーは選択しません。バランサーが決定します）。 2）バックエンドサーバーから目的のフロントエンドサーバーにメッセージを送信します。 3）実際、クライアントにメッセージを送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポイント1と2を実装するために、別のトピック（「フロントエンドサーバー」トピック）を使用することにしました。認証、セッション、および呼び出しトピックをパーティションに分離すると、並列化メカニズムとして機能します。セッションサーバーの負荷が高いことがわかりますか？新しいパーティションとセッションサーバーをいくつか追加するだけで、Kafkaが負荷を再分散し、既存のセッションサーバーをアンロードします。 「フロントエンドサーバー」トピックをパーティションに分離すると、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルーティング</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メカニズムとして機能し</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各フロントエンドサーバーは、「サーバー自体と同じインデックスを持つ」「フロントエンドサーバー」トピックの一部に対応しています。つまり、サーバー0-パーティション0などです。 Kafkaを使用すると、特定のトピックだけでなく、特定のトピックの特定の部分も購読できます。スタートアップのすべてのフロントエンドサーバーは、対応するパーティションにサブスクライブします。したがって、バックエンドサーバーは、特定のパーティションにメッセージを送信することにより、特定のフロントエンドサーバーにメッセージを送信できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、今度はクライアントが参加するときに、ユーザーIDとフロントエンドサーバーのインデックスのペアをどこかに保存する必要があります。切断の場合-削除します。これらの目的のために、多くのメモリ内のKey-Valueデータベースのいずれでも実行できます。大根を選びました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際の見た目。</font><font style="vertical-align: inherit;">まず、接続が確立された後、クライアントのAndreyがサーバーにメッセージを送信します</font></font><code>Join</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">フロントエンドサーバーはメッセージを受信して​​セッショントピックに転送し、「フロントエンドサーバー」ヘッダー{index}を事前に追加します。</font><font style="vertical-align: inherit;">バックエンドセッションサーバーの1つがメッセージを受信し、認証トークンを読み取り、参加しているユーザーの種類を判別し、フロントエンドサーバーによって追加されたインデックスを読み取り、UserId-Indexを大根に書き込みます。</font><font style="vertical-align: inherit;">この瞬間から、クライアントはオンラインと見なされ、他のクライアントがAndreyにメッセージを送信するときに、どのフロントエンドサーバー（したがって「フロントエンドサーバー」トピックのどの部分）から「リーチ」できるかがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
*実際、プロセスは私が説明したよりも少し複雑です。</font><font style="vertical-align: inherit;">あなたはソースコードでそれを見つけることができます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロントエンドサーバーの疑似コード</font></font></h4><br>
<pre><code class="cs hljs"><span class="hljs-comment">// Frontend Server 6</span>
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-comment">// Consume from "Frontend Servers" topic, partition 6</span>
    <span class="hljs-keyword">var</span> messageToClient = consumer.Consume();
    <span class="hljs-keyword">if</span> (message != <span class="hljs-literal">null</span>) {<font></font>
        relayMessageToClient(messageToClient);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">var</span> callbacks = selector.Poll();
    <span class="hljs-keyword">while</span> (callbacks.TryDequeue(<span class="hljs-keyword">out</span> callback)) {<font></font>
        callback();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">long</span> now = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
    <span class="hljs-keyword">while</span> (!callAtQueue.IsEmpty &amp;&amp; callAtQueue.PeekPriority() &lt;= now) {<font></font>
        callAtQueue.Dequeue()();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (messagesToRelayToBackendServers.TryDequeue(<span class="hljs-keyword">out</span> messageFromClient)) {
        <span class="hljs-comment">// choose topic</span><font></font>
        producer.Produce(topic, messageFromClient);<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここにはいくつかのトリックがあります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1）</font></font><code>relayMessageToClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。多分私たちがしているので、単にあなたがしたいソケットを取り、すぐにメッセージの送信を開始するのは間違いだろう</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、すでに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントに他のいくつかのメッセージを送信します。ソケットが現在ビジーかどうかを確認せずにバイトの送信を開始すると、メッセージが混合されます。整然としたデータ処理が必要な他の多くの場所と同様に、コツはキュー、つまりコンプリーターからのキュー（</font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C＃の場合）を使用することです。</font></font><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">async</span> <span class="hljs-title">relayMessageToClient</span>(<span class="hljs-params">message</span>)</span> {
    <span class="hljs-comment">// find client</span>
    <span class="hljs-keyword">await</span> client.ReadyToSend();
    <span class="hljs-keyword">await</span> sendMessage(client, message);<font></font>
    client.CompleteSend();<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> {
    <span class="hljs-comment">// ...</span>
    sendMessageQueue = <span class="hljs-keyword">new</span> LinkedList&lt;Completer&lt;<span class="hljs-keyword">object</span>&gt;&gt;();<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">async</span> Future <span class="hljs-title">ReadyToSend</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">var</span> sendMessage = Completer&lt;<span class="hljs-keyword">object</span>&gt;();
	<span class="hljs-keyword">if</span> (sendMessageQueue.IsEmpty) {<font></font>
	    sendMessageQueue.AddLast(sendMessage);<font></font>
	} <span class="hljs-keyword">else</span> {
	    <span class="hljs-keyword">var</span> prevSendMessage = sendMessageQueue.Last;<font></font>
	    sendMessageQueue.AddLast(sendMessage);<font></font>
	    <span class="hljs-keyword">await</span> prevSendMessage.Future;<font></font>
	}<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CompleteSend</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">var</span> sendMessage = sendMessageQueue.RemoveFirst();<font></font>
	sendMessage.Complete(<span class="hljs-literal">null</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キューが空でない場合、ソケットはすでにその時点で使用されています。新しいものを作成し</font></font><code>completer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、キューとに追加し</font><i><font style="vertical-align: inherit;">、前の1</font></i><font style="vertical-align: inherit;">。したがって、前のメッセージが送信される</font><font style="vertical-align: inherit;">と完了し</font><font style="vertical-align: inherit;">ます。これにより、サーバーは次のメッセージの送信を開始します。このようなキューにより、例外をスムーズに伝達することもできます。クライアントにメッセージを送信中にエラーが発生したとします。この場合、このメッセージだけでなく、現在キューで待機しているすべてのメッセージ（</font><font style="vertical-align: inherit;">'ahで</font><font style="vertical-align: inherit;">ハングアップ</font><font style="vertical-align: inherit;">'）</font><font style="vertical-align: inherit;">を送信することを除いて、完了する必要があります</font><font style="vertical-align: inherit;">。そうしないと、引き続きハングし、メモリリークが発生します。簡潔にするために、これを行うコードはここでは示していません。</font><font style="vertical-align: inherit;">
2）</font></font><code>await</code><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i> <code>completer</code><font style="vertical-align: inherit;"></font><code>CompleteSend</code><font style="vertical-align: inherit;"></font><code>completer</code><font style="vertical-align: inherit;"></font><code>await</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>selector.Poll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。実際、これはトリックではなく、メソッドの実装の欠点を解消するための試みです</font></font><code>Socket.Select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>selector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このメソッドのラッパーにすぎません）。内部のOSに応じて、このメソッドは</font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはを</font><font style="vertical-align: inherit;">使用します</font></font><code>poll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。しかし、これはここでは重要ではありません。重要なことは、このメソッドが入力にフィードするリスト（読み取り、書き込み、エラーチェック用のソケットのリスト）とどのように連携するかです。このメソッドは、リストを取得し、ソケットをポーリングして、必要な操作を実行する準備ができているソケットのみをリストに残します。他のすべてのソケットはリストからスローされます。 「蹴り」は</font></font><code>RemoveAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（つまり、後続のすべての要素がシフトされるため、非効率的です）。さらに、サイクルの反復ごとにすべての登録済みソケットをポーリングする必要があるため、このような「クレンジング」は一般的に有害であり、毎回リストを再入力する必要があります。カスタム問題を使用すると、これらすべての問題を回避できます</font></font><code>List</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>RemoveAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その</font><font style="vertical-align: inherit;">方法で</font><font style="vertical-align: inherit;">は、項目がリストから削除されず、削除済みとしてマークされます。クラス</font></font><code>ListForPolling</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はそのようなリストの私の実装です。</font></font><code>ListForPolling</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドでのみ機能し、</font></font><code>Socket.Select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それ以外には適していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3）</font></font><code>callAtQueue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ほとんどの場合、クライアントメッセージをバックエンドサーバーに送信したフロントエンドサーバーは、応答（操作が成功したことの確認、または問題が発生した場合はエラー）を期待します。構成可能な時間内に回答を待たない場合は、クライアントにエラーを送信して、決して来ない答えを待たないようにします。</font></font><code>callAtQueue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">優先キューです。サーバーがメッセージをKafkaに送信するとすぐに、次のようになります。</font></font><br>
<pre><code class="cs hljs"><span class="hljs-keyword">long</span> now = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();<font></font>
callAtQueue.Enqueue(callback, now + config.WaitForReplyMSec);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コールバックでは、応答の待機がキャンセルされ、サーバーエラーの送信が開始されます。バックエンドサーバーからの応答を受信した場合、コールバックは何もしません。</font><font style="vertical-align: inherit;">後のコード</font><font style="vertical-align: inherit;">はプールのスレッドで実行される</font><font style="vertical-align: inherit;">ため、これを</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用</font></font><code>await Task.WhenAny(answerReceivedTask, Task.Delay(x))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する方法はありません</font></font><code>Task.Delay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、実際には、フロントエンドサーバーに関するすべて。ここで若干の修正が必要です。実際、サーバーは</font><i><font style="vertical-align: inherit;">完全で</font></i><font style="vertical-align: inherit;">はありません</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シングルスレッド。もちろん、内部のkafkaはスレッドを使用しますが、アプリケーションコードを意味します。実際のところ、kafka（プロデュース）のトピックへのメッセージの送信は成功しない可能性があります。失敗した場合、Kafkaは特定の設定可能な回数だけ送信を繰り返しますが、繰り返しの送信が失敗した場合、Kafkaはこのビジネスを絶望的なものとして中止します。</font></font><code>deliveryHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドに渡される</font><font style="vertical-align: inherit;">メッセージが正常に送信されたかどうかを確認できます</font></font><code>Produce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 Kafkaは、プロデューサーのI / Oスレッド（メッセージを送信するスレッド）でこのハンドラーを呼び出します。メッセージが正常に送信されたことを確認し、送信されなかった場合は、バックエンドサーバーからの応答の待機をキャンセルし（要求が送信されなかったため、応答が送信されません）、クライアントにエラーを送信します。つまり、別のスレッドとのやり取りを避けられません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
*記事を書いているとき</font></font><code>deliveryHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、メソッドに</font><font style="vertical-align: inherit;">渡せ</font><font style="vertical-align: inherit;">ない、</font></font><code>Produce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはすべてのカフカエラーを無視</font><font style="vertical-align: inherit;">できないことに突然気づきました</font><font style="vertical-align: inherit;">（エラーは以前に説明したタイムアウトまでにクライアントに送信されます）。その後、すべてのコードがシングルスレッドになります。</font><font style="vertical-align: inherit;">今、私はそれをより良くする方法を考えています。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウサギではなく、なぜカフカなのか？</font></font></b><div class="spoiler_text">,        ,   ,  , ,   RabbitMQ?        .  , ,   .     ?    ,         frontend .   ,     backend ,      ,          .    ,       ,     .   ,       error-prone.  ,     <code>basicGet</code> ,    ,   ,      .     .      <code>basicGet</code>,      ,       .          .<br>
</div></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックエンドサーバー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フロントエンドサーバーと比較して、ここでは実質的に興味深い点はありません。</font><font style="vertical-align: inherit;">すべてのバックエンドサーバーは同じように動作します。</font><font style="vertical-align: inherit;">起動時に、サーバーはトピック（役割に応じて認証、セッション、または呼び出し）をサブスクライブし、kafkaがトピックに1つ以上のパーティションを割り当てます。</font><font style="vertical-align: inherit;">サーバーはKafkaからメッセージを受信し、通常は1つ以上のメッセージを処理して送信します。</font><font style="vertical-align: inherit;">ほぼ実際のコード：</font></font><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">long</span> lastCommitTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">var</span> consumeResult = consumer.Consume(<font></font>
            TimeSpan.FromMilliseconds(config.Consumer.PollTimeoutMSec)<font></font>
        );<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (consumeResult != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> workUnit = <span class="hljs-keyword">new</span> WorkUnit() {<font></font>
                ConsumeResult = consumeResult,<font></font>
            };<font></font>
<font></font>
            LinkedList&lt;WorkUnit&gt; workUnits;<font></font>
            <span class="hljs-keyword">if</span> (partitionToWorkUnits.ContainsKey(consumeResult.Partition)) {<font></font>
                workUnits = partitionToWorkUnits[consumeResult.Partition];<font></font>
            } <span class="hljs-keyword">else</span> {<font></font>
                workUnits = partitionToWorkUnits[consumeResult.Partition] =<font></font>
                    <span class="hljs-keyword">new</span> LinkedList&lt;WorkUnit&gt;();<font></font>
            }<font></font>
<font></font>
            workUnits.AddLast(workUnit);<font></font>
<font></font>
            handleWorkUnit(workUnit);<font></font>
        }<font></font>
<font></font>
	<span class="hljs-keyword">if</span> (<font></font>
            DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() - lastCommitTime &gt;=<font></font>
            config.Consumer.CommitIntervalMSec<font></font>
        ) {<font></font>
            commitOffsets();<font></font>
	    lastCommitTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();<font></font>
	}<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コミットするオフセットの種類は？</font></font></b><div class="spoiler_text">       .   —   (offset)    (0, 1  ).         0.        <code>TopicPartitionOffset</code>.    (consume)   ,   <code>ConsumeResult</code>, ,   ,   <code>TopicPartitionOffset</code>.     ?<br>
<br>
  at least once delivery,  ,              (    ).     ,           (commited) . ,  consumer         16,  ,  16 ,   ,      ,   .     -  consumer'     consumer'        ,    16 + 1 (   + 1).    17   .        N ,       .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動コミットを無効にして自分でコミットしました。これは</font></font><code>handleWorkUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、メッセージ処理が実際に実行される場合、これが</font></font><code>async void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドであるために必要です。したがって、メッセージ5がメッセージ6の前に処理される保証はありません。Kafkaは、オフセットをコミットする前に、コミットされたオフセットを1つだけ保存します（オフセットのセットではありません）。 6、前のメッセージもすべて処理されていることを確認する必要があります。さらに、1つのバックエンドサーバーが同時に複数のパーティションからのメッセージを消費する可能性があるため、対応するパーティションに正しいオフセットをコミットする必要があります。これには、partition：work unitsという形式のハッシュマップを使用します。コードは次のようになります</font></font><code>commitOffsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（今回は実際のコード）：</font></font><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commitOffsets</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">foreach</span> (LinkedList&lt;WorkUnit&gt; workUnits <span class="hljs-keyword">in</span> partitionToWorkUnits.Values) {<font></font>
        WorkUnit lastFinishedWorkUnit = <span class="hljs-literal">null</span>;<font></font>
        LinkedListNode&lt;WorkUnit&gt; workUnit;<font></font>
        <span class="hljs-keyword">while</span> ((workUnit = workUnits.First) != <span class="hljs-literal">null</span> &amp;&amp; workUnit.Value.IsFinished) {<font></font>
            lastFinishedWorkUnit = workUnit.Value;<font></font>
            workUnits.RemoveFirst();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (lastFinishedWorkUnit != <span class="hljs-literal">null</span>) {<font></font>
            offsets.Add(lastFinishedWorkUnit.ConsumeResult.TopicPartitionOffset);<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (offsets.Count &gt; <span class="hljs-number">0</span>) {<font></font>
        consumer.Commit(offsets);<font></font>
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> offset <span class="hljs-keyword">in</span> offsets) {<font></font>
            logger.Debug(<font></font>
                <span class="hljs-string">"{Identifier}: Commited offset {TopicPartitionOffset}"</span>,<font></font>
                identifier,<font></font>
                offset<font></font>
            );<font></font>
        }<font></font>
        offsets.Clear();<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、ユニットを繰り返し処理し、この時点までに完了した最後のユニットを見つけます。その後</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、不完全な</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユニット</font><i><font style="vertical-align: inherit;">はなく</font></i><font style="vertical-align: inherit;">なり、対応するオフセットがコミットされます。</font><font style="vertical-align: inherit;">このようなループにより、「完全な」コミットを回避できます。</font><font style="vertical-align: inherit;">たとえば、現在4ユニット（</font></font><code>0: Finished, 1: Not Finished, 2: Finished, 3: Finished</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）がある場合、0番目のユニットのみをコミットできます。3番目をすぐにコミットすると、サーバーがすぐに停止した場合、1番目のユニットが失われる可能性があるためです。</font></font><br>
<pre><code class="cs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkUnit</span> {
    <span class="hljs-keyword">public</span> ConsumeResult&lt;Null, <span class="hljs-keyword">byte</span>[]&gt; ConsumeResult { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> finished = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> IsFinished =&gt; finished == <span class="hljs-number">1</span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Finish</span>(<span class="hljs-params"></span>)</span> {<font></font>
        Interlocked.Increment(<span class="hljs-keyword">ref</span> finished);<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<br>
<code>handleWorkUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">言われたように、</font></font><code>async void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドとそれに応じて、それは完全にラップされ</font></font><code>try-catch-finally</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">で</font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、彼は必要なサービスを呼び出し、中</font></font><code>finally</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>workUnit.Finish()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サービスはかなり簡単です。</font><font style="vertical-align: inherit;">ここでは、たとえば、ユーザーが新しいメッセージを送信したときに実行されるコードは次のとおりです。</font></font><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task&lt;ServiceResult&gt; <span class="hljs-title">createShareItem</span>(<span class="hljs-params">CreateShareItemMessage msg</span>)</span> {
    <span class="hljs-keyword">byte</span>[] message;
    <span class="hljs-keyword">byte</span>[] messageToPals1 = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">int</span>?[] partitions1 = <span class="hljs-literal">null</span>;<font></font>
<font></font>
    <span class="hljs-comment">//  UserId  .</span>
    <span class="hljs-keyword">long</span>? userId = hashService.ValidateSessionIdentifier(msg.SessionIdentifier);
    <span class="hljs-keyword">if</span> (userId != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> shareItem = <span class="hljs-keyword">new</span> ShareItemModel(<font></font>
            requestIdentifier: msg.RequestIdentifier,<font></font>
            roomIdentifier: msg.RoomIdentifier,<font></font>
            creatorId: userId,<font></font>
            timeOfCreation: <span class="hljs-literal">null</span>,<font></font>
            type: msg.ShareItemType,<font></font>
            content: msg.Content<font></font>
        );<font></font>
<font></font>
        <span class="hljs-comment">//      null,</span>
        <span class="hljs-comment">//     .</span>
        <span class="hljs-keyword">long</span>? timeOfCreation = <span class="hljs-keyword">await</span> storageService.CreateShareItem(shareItem);
        <span class="hljs-keyword">if</span> (timeOfCreation != <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">//      .</span>
            List&lt;<span class="hljs-keyword">long</span>&gt; pals = <span class="hljs-keyword">await</span> inMemoryStorageService.GetRoomPals(<font></font>
                msg.RoomIdentifier<font></font>
            );<font></font>
            <span class="hljs-keyword">if</span> (pals == <span class="hljs-literal">null</span>) {
            	<span class="hljs-comment">//     -       .</span>
                pals = <span class="hljs-keyword">await</span> storageService.GetRoomPals(msg.RoomIdentifier);
                <span class="hljs-keyword">await</span> inMemoryStorageService.SaveRoomPals(msg.RoomIdentifier, pals);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-comment">//    ,  .</span><font></font>
            pals.Remove(userId.Value);<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (pals.Count &gt; <span class="hljs-number">0</span>) {
            	<span class="hljs-comment">//  ack,  ,    </span>
                <span class="hljs-comment">//    .</span>
                <span class="hljs-keyword">await</span> storageService.CreateAck(<font></font>
                    msg.RequestIdentifier, userId.Value, msg.RoomIdentifier,<font></font>
                    timeOfCreation.Value, pals<font></font>
                );<font></font>
<font></font>
                <span class="hljs-comment">// in -  UserId, out -   frontend ,</span>
                <span class="hljs-comment">//    .  -   -</span>
                <span class="hljs-comment">//   null.</span>
                partitions1 = <span class="hljs-keyword">await</span> inMemoryStorageService.GetUserPartitions(pals);<font></font>
<font></font>
                List&lt;<span class="hljs-keyword">long</span>&gt; onlinePals = getOnlinePals(pals, partitions1);<font></font>
<font></font>
                <span class="hljs-comment">//    ,       .</span>
                <span class="hljs-comment">//         .</span>
                <span class="hljs-keyword">if</span> (onlinePals.Count &gt; <span class="hljs-number">0</span>) {<font></font>
                    messageToPals1 = converterService.EncodeNewShareItemMessage(<font></font>
                        userId.Value, timeOfCreation.Value, onlinePals, shareItem<font></font>
                    );<font></font>
                    nullRepeatedPartitions(partitions1);<font></font>
                    <span class="hljs-comment">// -         </span>
                    <span class="hljs-comment">// frontend ,    null' .</span><font></font>
                }<font></font>
            }<font></font>
<font></font>
            message = converterService.EncodeSuccessfulShareItemCreationMessage(<font></font>
                msg.RequestIdentifier, timeOfCreation.Value<font></font>
            );<font></font>
        } <span class="hljs-keyword">else</span> {<font></font>
            message = converterService.EncodeMessage(<font></font>
                MessageCode.RoomNotFound, msg.RequestIdentifier<font></font>
            );<font></font>
        }<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        message = converterService.EncodeMessage(<font></font>
            MessageCode.UserNotFound, msg.RequestIdentifier<font></font>
        );<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServiceResult(<font></font>
        message: message, <span class="hljs-comment">//    .</span>
        messageToPals1: messageToPals1, <span class="hljs-comment">//  -    .</span><font></font>
        partitions1: partitions1<font></font>
    );<font></font>
}<font></font>
</code></pre><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベース</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックエンドサーバーによって呼び出されるサービスの機能のほとんどは、データベースに新しいデータを追加し、既存のデータを処理するだけです。明らかに、データベースがどのように編成され、どのように操作されるかはメッセンジャーにとって非常に重要です。ここで、すべてのオプションを注意深く検討した後、データベースを選択する問題に非常に注意深く取り組みましたが、そうではありません。 CockroachDbを選択したのは、最小限の労力で多くのことが約束され、postgres互換の構文があるためです（以前はpostgresで作業していました）。 Cassandraを使用する考えがありましたが、結局私は身近なものにこだわることにしました。私はKafka、Rabbit、FlutterとDart、またはWebRtcを使用したことがなかったので、Cassandraもドラッグしないことにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のプロジェクトのすべての部分の中で、データベース設計は私が最も疑うべきことです。私が下した決定が本当に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">良い</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定である</font><font style="vertical-align: inherit;">かどうかはわかりません</font><font style="vertical-align: inherit;">。すべてが機能しますが、もっとうまくできる可能性があります。たとえば、ShareRoomsテーブル（チャットと呼ぶ）とShareItemsテーブル（メッセージと呼ぶ）があります。したがって、ルームに入るすべてのユーザーは、このルームのjsonbフィールドに記録されます。これは便利ですが、明らかに非常に遅いため、おそらく外部キーを使用してやり直します。または、たとえば、ShareItemsテーブルには</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージが</font><font style="vertical-align: inherit;">格納され</font><font style="vertical-align: inherit;">ます。これも便利ですが、ShareItemsは最もロードされるテーブルの1つであるため</font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>insert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、部屋ごとに新しいテーブルを作成するなどの価値があるかもしれません。 Kokroachはレコードをさまざまなノードに分散させるため、最大のパフォーマンスを達成するためにはどのレコードを使用するかを慎重に検討する必要がありますが、私はしませんでした。一般的に、上記のすべてから理解できるように、データベースは私の最大の強みではありません。現在、私は通常、kokroachではなくpostgresのすべてをテストしています。これは、作業用マシンの負荷が少ないため、負荷が低いため、すぐに機能しなくなります。幸い、postgresとkokroachのコードはかなり異なるため、切り替えは難しくありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、コクローチが実際にどのように機能するか（SQLとKey-Valueの間でマッピングがどのように行われるか（コクローチは内部でRocksDbを使用しています）、ノード間でデータを分散する方法、レプリケートなど）を調査しています。もちろん、それを使用する前にコクローチを研究することは価値がありましたが、決して遅くはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題をよく理解できるようになると、拠点は大きく変わると思います。今、Acksテーブルが私を悩ませています。この表には、まだ受信していない人とメッセージをまだ読んでいない人に関するデータが格納されています（ユーザーのチェックマークを表示するため）。ユーザーがオンラインであれば、メッセージが既読であることをユーザーに通知するのは簡単ですが、そうでない場合は、後でユーザーに通知するためにこの情報を保存する必要があります。また、グループチャットを利用できるため、フラグを保存するだけでは不十分であり、個々のユーザーに関するデータが必要です。したがって、ここではビット文字列の使用を直接求めています（まだ受信していないユーザーの1行目、2行目-まだ読んでいないユーザー向け）。特にコクローチのサポート</font></font><code>bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>bit varying</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ただし、部屋の構成は常に変化する可能性があるため、このビジネスを実装する方法はわかりませんでした。ビット文字列がその意味を保持するためには、部屋のユーザーは同じ順序を維持する必要があります。これは、たとえば、一部のユーザーが部屋を離れるときに行うのは非常に困難です。ここにはオプションがあります。おそらく、jsonbフィールドからユーザーを削除する代わりに-1を記述する価値があります。そのため、このビット文字列はユーザ​​ーの順序を参照していることがわかります。ユーザーの現在の順序ではありません。このビジネスをより適切に実装する方法についてはまだ検討中ですが、当分の間、まだユーザーを受け取っておらず、まだ読んでいないユーザーもjsonbフィールドにすぎません。 Acksテーブルが各メッセージで書き込まれるとすると、データ量は大きくなります。もちろん、レコードは全員がメッセージを受信して​​読んだときに削除されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラッター</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長い間、サーバー側で作業していて、テストには単純なコンソールクライアントを使用していたため、Flutterプロジェクトを作成することすらしませんでした。</font><font style="vertical-align: inherit;">それを作成したとき、サーバーの部分は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複雑な</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分だと思いました。アプリケーションはそのようなもので、ゴミです。数日でわかります。</font><font style="vertical-align: inherit;">サーバーで作業しているときに、フレームワークの感触をつかむために羽ばたき用のHello Worldsを数回作成しました。メッセンジャーには複雑なUIが必要ないため、完全に準備ができていると思いました。</font><font style="vertical-align: inherit;">したがって、UIは実際にはゴミですが、機能の実装によって問題が発生しました（すべての準備が整っているわけではないため、引き続き提供されます）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態管理</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も人気のあるトピック。状態を管理する方法は1,000通りあり、推奨されるアプローチは6か月ごとに変更されます。現在、主流はプロバイダーです。個人的に、私はblocとreduxの2つの方法を選択しました。ローカル状態を管理するためのBloc（ビジネスロジックコンポーネント）およびグローバル管理のためのredux。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Blocはある種のライブラリーではありません（もちろん、ボイラープレートを削減するライブラリーもありますが、私は使用していません）。 Blocはストリームベースのアプローチです。一般的に、dartは非常に優れた言語であり、ストリームは一般的にとても甘いです。このアプローチの本質は、ビジネスロジック全体をサービスにプッシュし、UIとサービスの間でさまざまなストリームを提供するコントローラーを介して通信することです。ユーザーは[連絡先を検索]ボタンをクリックしましたか？使用する</font></font><code>sink</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ストリームのもう一方の端）コントローラー</font></font><code>SearchContactsEvent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">イベントを送信すると、コントローラー</font><font style="vertical-align: inherit;">は目的のサービスを呼び出し、結果を待って、ユーザーのリストをストリームを通じてUIに返します。 UI </font></font><code>StreamBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、サブスクライブするストリームに新しいデータが到着するたびに再構築されるウィジェットを</font><font style="vertical-align: inherit;">使用して結果を待ち</font><font style="vertical-align: inherit;">ます。それは、実際には、すべてです。場合によっては、ユーザーの関与なしに（たとえば、新しいメッセージが到着したときなど）UIを更新する必要がありますが、これもストリームを介して簡単に実行できます。実際、ストリームを備えた単純なMVCで、魔法はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のいくつかのアプローチと比較して、ブロックにはより多くのボイラープレートが必要ですが、私の意見では、サードパーティのソリューションを使用していくつかの</font><i><font style="vertical-align: inherit;">重要な</font></i><font style="vertical-align: inherit;">ことを与えない限り、サードパーティのライブラリの参加なしでネイティブソリューションを使用する方が良い</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">利点。</font><font style="vertical-align: inherit;">上にある抽象化が多いほど、エラーが発生したときにエラーが何であるかを理解することが難しくなります。</font><font style="vertical-align: inherit;">私は、プロバイダーの利点がそれを切り替えるのに十分なほど重要であるとは考えていません。</font><font style="vertical-align: inherit;">しかし、私はこの分野での経験がほとんどないので、将来的にキャンプを変更する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、reduxについては誰もがすべてを知っているので、言うことは何もありません。</font><font style="vertical-align: inherit;">さらに、私はそれをアプリケーションから切り取りました:)私はそれを自分のアカウントの管理に使用しましたが、この場合、ブロックを超える特別な利点はないことに気づき、あまりドラッグしすぎないように切り取りました。</font><font style="vertical-align: inherit;">しかし、一般的に、私はreduxをグローバルな状態を管理するための有用なものと考えています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最も耐え難い部分</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーがメッセージを送信したが、送信前にインターネット接続が失われた場合はどうすればよいですか？ユーザーが読み取り確認を受信したが、データベース内の対応するレコードが更新される前にアプリケーションを閉じた場合はどうすればよいですか？ユーザーが友人を部屋に招待したが、招待が送信される前にバッテリーが切れた場合はどうすればよいですか？同様の質問をしたことがありますか？ここにいるよ。前。しかし、開発の過程で私は疑問に思い始めました。接続はいつでも消える可能性があり、電話はいつでもオフになるため、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてを確認する</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要があります</font><font style="vertical-align: inherit;">。楽しくない。したがって、クライアントがサーバーに送信する最初のメッセージ（</font></font><code>Join</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">覚えている場合）は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「こんにちは私はオンラインです」</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ではなく、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「こんにちは私はオンラインです。未確認の部屋、未確認のack、未確認のルームメンバーシップの操作、および各部屋の最後に受信したメッセージをここに示します</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">」</font></i><font style="vertical-align: inherit;">そしてサーバーは同様のシートで応答します：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「あなたがオフラインである間、そのようなメッセージはそのようなユーザーによって読まれ、そして彼らはまたペティアをこの部屋に招待し、そしてスヴェタはこの部屋を去りました、そしてあなたはこの部屋に招待されましたがこれら2つの部屋には、40の新しい投稿があり</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">私の実装は優雅に輝いていないので、他のメッセンジャーで同様のことがどのように行われるのか本当に知りたいです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現時点では、テキスト、テキスト+画像、画像のみを送信できます。</font><font style="vertical-align: inherit;">ビデオのアップロードはまだ実装されていません。</font><font style="vertical-align: inherit;">画像は少し圧縮され、Firebaseストレージに保存されます。</font><font style="vertical-align: inherit;">メッセージ自体にリンクが含まれています。</font><font style="vertical-align: inherit;">メッセージを受信すると、クライアントは画像をダウンロードし、サムネイルを生成して、すべてをファイルシステムに保存します。</font><font style="vertical-align: inherit;">ファイルパスはデータベースに書き込まれます。</font><font style="vertical-align: inherit;">ちなみに、サムネイル生成は別のスレッドで実行される唯一のコードです。これは、計算量の多い操作であるためです。</font><font style="vertical-align: inherit;">ワーカーストリームを1つ開始し、画像をフィードすると、サムネイルが表示されます。</font><font style="vertical-align: inherit;">dartはストリームを操作するための便利な抽象化を提供するため、コードは非常に単純です。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThumbnailGeneratorService</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThumbnailGeneratorService</span> </span>{<font></font>
  SendPort _sendPort;<font></font>
  final Queue&lt;Completer&lt;Uint8List&gt;&gt; _completerQueue =<font></font>
      Queue&lt;Completer&lt;Uint8List&gt;&gt;();<font></font>
<font></font>
  ThumbnailGeneratorService() {<font></font>
    <span class="hljs-keyword">var</span> receivePort = ReceivePort();<font></font>
    Isolate.spawn(startWorker, receivePort.sendPort);<font></font>
<font></font>
    receivePort.listen((data) {<font></font>
      <span class="hljs-keyword">if</span> (data is SendPort) {<font></font>
        _sendPort = data;<font></font>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> completer = _completerQueue.removeFirst();<font></font>
        completer.complete(data);<font></font>
      }<font></font>
    });<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> startWorker(SendPort sendPort) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">var</span> receivePort = ReceivePort();<font></font>
    sendPort.send(receivePort.sendPort);<font></font>
<font></font>
    receivePort.listen((imageBytes) {<font></font>
      Image image = decodeImage(imageBytes);<font></font>
      Image thumbnail = copyResize(image, <span class="hljs-attr">width</span>: min(image.width, <span class="hljs-number">200</span>));<font></font>
<font></font>
      sendPort.send(Uint8List.fromList(encodePng(thumbnail)));<font></font>
    });<font></font>
  }<font></font>
<font></font>
  Future&lt;Uint8List&gt; generate(Uint8List imageBytes) {<font></font>
    <span class="hljs-keyword">var</span> completer = Completer&lt;Uint8List&gt;();<font></font>
    _completerQueue.add(completer);<font></font>
    <font></font>
    _sendPort.send(imageBytes);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> completer.future;<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Firebase authも使用されますが、Firebaseストレージへのアクセスを承認するためにのみ使用されます（ユーザーが他のユーザーにプロフィール写真を入力することはできませ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ん</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">他のすべての承認は私のサーバーを介して行われます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージフォーマット</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は通常のバイト配列を使用しているので、あなたはおそらくここで恐怖を感じるでしょう。効率が必要なため、Jsonは表示されなくなり、私はprotobufについて知りました。配列の使用には、1つのインデックスが間違っていて、うまくいかないため、多くの注意が必要です。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の4バイト</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はメッセージの長さです。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次のバイト</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はメッセージコードです。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次の16バイト</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は要求ID（uuid）です。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次の40バイト</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は認証トークンです。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージの残りの部分</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージの長さ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私はhttpまたはwebソケット、または1つのメッセージを別のメッセージから分離する他のプロトコルを使用していないため、必須です。私のフロントエンドサーバーはバイトストリームのみを認識し、メッセージの終わりと別の始まりを知る必要があります。メッセージを分離する方法はいくつかあります（たとえば、メッセージにない文字をセパレーターとして使用するなど）が、この方法が最も簡単なため、長さを指定することをお勧めします。長さを示す1バイト。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージコード</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は列挙型のメンバーの1つにすぎません</font></font><code>MessageCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ルーティングはコードに従って実行され、予備の逆シリアル化なしで配列からコードを抽出できるため、フロントエンドサーバーは、この責任を他の誰かに委任する代わりに、kafkaのどのトピックでメッセージを送信するかを決定します。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リクエストID</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほとんどの投稿に存在しますが、すべてには存在しません。これは2つの機能を実行します。この識別子により、クライアントは送信された要求と受信された応答の間の対応を確立します（クライアントがこの順序でメッセージA、B、Cを送信した場合、これは応答も順序どおりになることを意味しません）。 2番目の機能は、重複を避けることです。前述のように、kafkaは少なくとも1回の配信を保証します。つまり、まれに、メッセージが重複する可能性があります。一意の制約を持つRequestIdentifier列を目的のデータベーステーブルに追加することで、重複を挿入することを回避できます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">認可トークン</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UserId（8バイト）+ 32バイトのHmacSha256署名です。</font><font style="vertical-align: inherit;">ここでJwtを使用する価値はないと思います。</font><font style="vertical-align: inherit;">Jwtは何のために約7-8倍大きいですか？</font><font style="vertical-align: inherit;">私のユーザーにはクレームがないため、単純なhmac署名で十分です。</font><font style="vertical-align: inherit;">他のサービスによる承認は予定されておらず、計画もされていません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音声通話とビデオ通話</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題を解決できないと確信していたので、音声通話とビデオ通話の実装を意図的に延期したのはおかしいですが、実際には、これが実装するのが最も簡単な機能の1つであることがわかりました。</font><font style="vertical-align: inherit;">少なくとも基本的な機能。</font><font style="vertical-align: inherit;">一般に、アプリケーションにWebRtcを追加して最初のビデオセッションを取得するだけで数時間しかかからず、奇跡的に最初のテストは成功しました。</font><font style="vertical-align: inherit;">それ以前は、初めて機能するコードは神話だと思っていました。</font><font style="vertical-align: inherit;">通常、「サービスを追加しましたが、DIコンテナーに登録しませんでした」などのなんらかの愚かなエラーのため、新機能の最初のテストは常に失敗します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初心者向けのWebRtcについてはあまり簡潔ではない</font></font></b><div class="spoiler_text">WebRtc —  ,   peer-to-peer    , ,    peer-to-peer  ,     .   - ,     ,      .      ,      .<br>
<br>
          (peer-to-peer),     <i></i> ,  3   (     <i></i> ,  3  .           3 ).<br>
<br>
    — stun .   stun  ,    —  Source IP  Source Port      ,    <i></i> .    ?        - .       IP .      - , ,    ,   Source IP  Source Port    IP  -        NAT  [ Source IP | Source Port | Router External IP | Router Port ].     - ,   Dest IP  Dest Port     Router External IP  Router Port  NAT, ,    Source IP — Source Port     ,   .   , ,       ,      , ,    ,      NAT .       stun     NAT .     stun     Router External IP — Router Port.   — <i></i>   .     ,  «»    NAT (NAT traversal)  ,      NAT  ,     stun .<br>
*  NAT ,      . ,     ,  WebRtc    .<br>
<br>
  — turn.  ,       ,   peer-to-peer . Fallback .    , ,  ,  ,   ,   peer-to-peer     .    turn  — coturn,      .<br>
<br>
  — .    <i> </i>  ,    .       ,    .   —           .       .    ,          , ,     :)       —   .<br>
<br>
 WebRtc  3   : offer, answer  candidate.    offer     ,    answer,       .    , ,  ,    ,       .    (     )   ,  .<br>
</div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WebRtcテクノロジー自体が接続を確立し、フローのやり取りを行っていますが、これは本格的な通話を作成するためのフレームワークではありません。通話とは、通話をキャンセル、拒否、受諾するだけでなく、電話を切ることができる通信セッションを意味します。さらに、反対側がすでに使用されているかどうかを発信者に知らせる必要があります。また、「呼び出しへの応答をN秒待ってからリセットする」などの小さなことも実装します。アプリケーションに単純な形式でWebRtcを実装するだけの場合、着信コールを使用すると、カメラとビデオが自発的にオンになりますが、これはもちろん受け入れられません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
純粋な形式では、WebRtcは通常、できるだけ早く相手に候補者を送信することを意味します。これにより、交渉はできるだけ早く開始されます。これは論理的です。私のテストでは、通常、受信側の候補者は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">申し出が来る前から来始めました。そのような「初期」の候補は破棄できません。それらは覚えておく必要があるため、後でオファーが到着し</font></font><code>RTCPeerConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て作成されたときに、それらを接続に追加します。候補者がオファーの前でも到着し始める可能性があるという事実、および他のいくつかの理由により、本格的なコールの実装は重要なタスクになります。複数のユーザーが一度に電話をかけてきたらどうしますか？すべてから候補者を受け取ります。候補者をユーザーごとに分離することはできますが、どちらの候補者が先になるかわからないため、どの候補者を拒否するかは明確になりません。候補者が私たちのところに来て、私</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たち</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が誰か</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">電話する</font><font style="vertical-align: inherit;">ときに申し出が来た場合にも問題があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
裸のWebRtcでいくつかのオプションをテストした後、この形式では問題があり、呼び出しを試みるとメモリリークが発生するという結論に達したため、WebRtcネゴシエーションプロセスに別のステージを追加することにしました。このステージを呼んでいます</font></font><code>Inquire - Grant/Refuse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アイデアはとてもシンプルですが、それを実現するのにかなり時間がかかりました。呼び出し元は、ストリームを作成する前でも</font></font><code>RTCPeerConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（そして一般に</font><font style="vertical-align: inherit;">WebRtcに関連するコードを</font><font style="vertical-align: inherit;">実行する前</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でも</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、信号サーバーを介して反対側にメッセージを送信します</font></font><code>Inquire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。受信側では、ユーザーが現在他の通信セッションに参加しているかどうかが確認されます（単純</font></font><code>bool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールド）。そうであれば、メッセージが送り返されます。</font></font><code>Refuse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そしてこのようにして、ユーザーがビジーであることを発信者に知らせ、レシーバー-別の会話でビジーであったときにそのような電話が呼び出されたことを知らせます。ユーザーが現在空いている場合は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予約されています</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>Inquire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セッション識別子が</font><font style="vertical-align: inherit;">メッセージ</font><font style="vertical-align: inherit;">で送信さ</font><font style="vertical-align: inherit;">れ、</font><font style="vertical-align: inherit;">この識別子が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セッションの</font><font style="vertical-align: inherit;">識別子として設定され</font><font style="vertical-align: inherit;">ます。ユーザーが予約さ</font></font><code>Inquire/Offer/Candidate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れている場合、現在のセッションID以外のセッションIDを持つメッセージ</font><font style="vertical-align: inherit;">はすべて拒否され</font><font style="vertical-align: inherit;">ます。予約後、受信者は信号サーバーを介して発信者にメッセージを送信します</font></font><code>Grant</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。まだ呼び出しがないため、このプロセスは受信ユーザーには表示されません。そして、ここでの主なことは、受信側でタイムアウトを切ることを忘れないことです。突然セッションを予約し、オファーは続きません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
発信者はを受け取ります</font></font><code>Grant</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これはWebRtcがオファー、候補者から始まる場所であり、これはすべての人が利用できる場所です。</font><font style="vertical-align: inherit;">オファーがレシーバーに飛ぶと、彼は受け取り次第、ボタン「応答」/「拒否」のある画面を表示します。</font><font style="vertical-align: inherit;">しかし、候補者は、いつものように、誰も期待していません。</font><font style="vertical-align: inherit;">ユーザーが通話に応答するのを待つ理由がないため、オファーよりもさらに早く到着し始めます。</font><font style="vertical-align: inherit;">彼は答えないかもしれませんが、拒否するか、タイムアウトの期限が切れるまで待ちます-その後、候補者は単に捨てられます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現状と今後の計画</font></font></h2><br>
<ul>
<li><font color="#009c50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プライベートおよびグループチャット</font></font></font></li>
<li><font color="#009c50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テキスト、画像</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、動画を</font><font color="#009c50"><font style="vertical-align: inherit;">送信する</font></font></font></li>
<li><font color="#009c50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音声通話とビデオ通話</font></font></font></li>
<li><font color="#009c50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">受領確認と閲覧</font></font></font></li>
<li><font color="#009c50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「プリント...」</font></font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お知らせ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QRコードと地理位置情報で検索</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
予想外に、QRコードによる検索は、実装が非常に困難です。これは、私が試したコードスキャン用のほとんどすべてのプラグインが、起動を拒否したり、正しく機能しなかったりするためです。</font><font style="vertical-align: inherit;">しかし、問題はここで解決されると思います。</font><font style="vertical-align: inherit;">地理位置情報の検索の実装については、まだ取り上げていません。</font><font style="vertical-align: inherit;">理論的には、特別な問題はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
進行中の通知、およびビデオの送信。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他に何をする必要がありますか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ああ、たくさん。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まず、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストはありません。同僚がテストを書いていたので、私は完全にリラックスしました。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">既存のチャットにユーザーを招待してチャットを終了することは、現在のところ不可能です。サーバーコードはこれに対応していますが、クライアントコードは対応していません。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、サーバーでのエラー処理が多かれ少なかれある場合、クライアントでのエラー処理はありません。ログエントリを作成するだけでは不十分で、操作を再試行する必要があります。現在、たとえば、メッセージを再送信するメカニズムは実装されていません。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4番目に、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーはクライアントにpingしないため、たとえばクライアントがインターネットを失った場合、切断は検出されません。切断は、クライアントがアプリケーションを閉じたときにのみ検出されます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第5に、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックスはデータベースで使用されません。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第六に、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適化。コードには、のようなものが書かれた場所が多数あり</font></font><code>// @@TODO: Pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。ほとんどの配列はそれだけ</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。バックエンドサーバーは固定長の配列を多数作成するため、ここではプールを使用できます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第7</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、クライアント上にはコードが</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">終了する</font><font style="vertical-align: inherit;">場所がたくさんありますが、</font><font style="vertical-align: inherit;">これは必須ではありません。たとえば、画像の送信は、コードが</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像をファイルシステムに保存し、メッセージを表示する前にサムネイルを生成しますが、これを行う必要はありません。または、たとえば、アプリケーションを開いたときに不在時に画像が送信された場合、これらの画像がすべてダウンロードされてシステムに保存され、サムネイルが生成され、その後起動が終了してスプラッシュ画面からスローされるため、起動が遅くなりますホーム画面で。これらの冗長なはすべて</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デバッグを容易にするために作成されましたが、もちろん、リリース前に不要な待機を取り除く必要があります。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UIの表示方法はまだ決定していないため、UIの準備は完了です。したがって、今ではすべてが直感的ではなく、ボタンの半分が何をしているのか不明確です。また、ボタンは最初は押されないことがよくあります。これは、ボタンが</font></font><code>GestureDetector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パディング</font><font style="vertical-align: inherit;">付き</font><font style="vertical-align: inherit;">とパディングなしの</font><font style="vertical-align: inherit;">単なるアイコンになっているため</font><font style="vertical-align: inherit;">、常に</font><font style="vertical-align: inherit;">ボタンに</font><font style="vertical-align: inherit;">アクセスできるとは限らないためです。さらに、一部の場所では、ピクセルオーバーフローは修正されていません。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第9</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、アカウントにサインインすることさえ不可能になりました。サインアップするだけです。したがって、アプリケーションをアンインストールして再インストールすると、アカウントにログインできなくなります:) </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10番目に</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、確認コードはメールに送信されません。デバッグが簡単なため、コードは一般に常に同じです。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十一</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単一責任の原則は、多くの場所で違反されています。リファクタリングが必要です。データベースとのやり取りを担当するクラス（クライアントとサーバーの両方）は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベース操作に</font><font style="vertical-align: inherit;">関与しているため、一般に非常に肥大化し</font><i><font style="vertical-align: inherit;">てい</font></i><font style="vertical-align: inherit;">ます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第12に、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージが応答の送信を意味しない場合でも（たとえば、コード付きのメッセージ</font></font><code>IsTyping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と一部のWebRtc関連メッセージ）</font><b><font style="vertical-align: inherit;">、</font></b><font style="vertical-align: inherit;">フロントエンドサーバーは常にバックエンドサーバーからの応答を予期し</font><font style="vertical-align: inherit;">ます。したがって、回答を待たずに、コンソールにエラーを書き込みますが、これはエラーではありません。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13番目に、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全な画像がタップで開かない。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1億分の5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッチで送信する必要がある一部のメッセージは、個別に送信されます。同じことが一部のデータベース操作に適用されます。単一のコマンドを実行する代わりに、コマンドは</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（brr ..）の</font><font style="vertical-align: inherit;">ループで実行され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1億6分の1、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部の値は構成可能ではなく、ハードコーディングされています。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7分の1、100万</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーへのログオンはコンソールのみになり、クライアントでは一般にウィジェットに直接なります。メイン画面には、[ログ]タブがあり、タップするとすべてのログがドロップされます。実際のところ、私の稼働中のマシンは、エミュレーターとサーバーに必要なすべてのもの（kafka、データベース、大根、およびすべてのサーバー）の実行を拒否しています。コンピュータが負荷に対応できなかったため、接続されたデバイスでのデビットも機能せず、すべてがケースの半分でしっかりとハングしました。したがって、毎回ビルドを作成してデバイスにドロップし、このようにインストールしてテストする必要があります。ログを表示するには、ウィジェットに直接ドロップします。倒錯、私は知っていますが、選択の余地はありません。同じ理由で、多くのメソッドが戻り</font></font><code>Future</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それらは（例外をキャッチしてウィジェットにスローするため）ですが、そうすべきではありません。コードを見ると、</font></font><code>_logError</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これを行う多くのクラスに</font><font style="vertical-align: inherit;">醜い</font><font style="vertical-align: inherit;">メソッドが</font><font style="vertical-align: inherit;">あることがわかります</font><font style="vertical-align: inherit;">。もちろん、これはゴミ箱にも行きます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1億と8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音なし。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1億9番目に、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュをさらに使用する必要があります。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10億分の1、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの反復的なコード。たとえば、多くのアクションでは、最初にトークンの有効性をチェックし、有効でない場合はエラーを送信します。単純なミドルウェアパイプラインを実装する必要があると思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、</font></font><code>StringBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'a </font><font style="vertical-align: inherit;">を使用する代わりに文字列を連結するなど、多くの小さなこと</font></font><code>Dispose</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての場所がどこで呼び出されるかというと、そうではありません。</font><font style="vertical-align: inherit;">一般に、プロジェクトの通常の状態は開発中です。</font><font style="vertical-align: inherit;">上記のすべては解決可能ですが、頭の外に出たため、最後まで考えていなかった根本的な問題が1つあります。アプリケーションが開いていなくてもメッセンジャーが機能し、私のものは機能しません。</font><font style="vertical-align: inherit;">正直なところ、この問題の解決策はまだ私の心を超えていません。</font><font style="vertical-align: inherit;">ここでは、どうやら、ネイティブコードなしでは実行できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトの準備状況を70％と評価します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトの作業開始から6か月が経過しました。</font><font style="vertical-align: inherit;">パートタイムの仕事と組み合わせて長い休憩を取ったが、それでもそれなりの時間とエネルギーがかかった。</font><font style="vertical-align: inherit;">私は宣言されたすべての機能を実装する予定で、部屋に三目並べや下書きなどの変わったものを追加します。</font><font style="vertical-align: inherit;">理由もなく、それが面白いからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
質問があれば書いてください。</font><font style="vertical-align: inherit;">メールはgithubにあります。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja490054/index.html">Tesla Model 3を使用して最初の1年で17の驚き</a></li>
<li><a href="../ja490056/index.html">ブラックボックス：ロギングを忘れる</a></li>
<li><a href="../ja490060/index.html">検索ナレッジグラフ：複数のソースからの構築</a></li>
<li><a href="../ja490066/index.html">中国から南極へ：ニュートリノ質量パズルを解決するために力を合わせます</a></li>
<li><a href="../ja490068/index.html">疑似ランダムシーケンスの並べ替えによるランダム性と変換の改ざん</a></li>
<li><a href="../ja490076/index.html">eスポーツ分野のスポーツ分類</a></li>
<li><a href="../ja490080/index.html">競合他社がサイトを簡単にブロックできる方法</a></li>
<li><a href="../ja490082/index.html">遺伝コード分析I</a></li>
<li><a href="../ja490084/index.html">ECMAScript仕様を理解する、パート1</a></li>
<li><a href="../ja490086/index.html">ポルトガルでの初心者サーフガイドまたはプログラマーの生活</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>