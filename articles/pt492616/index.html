<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦁 👩🏽‍🏫 👨🏿 Packer, Terraform e Ansible: implantação do cluster Kubernetes em uma hora 🙎🏿 ☸️ 🛣️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá, meu nome é Andrey Schukin, ajudo grandes empresas a migrar serviços e sistemas para a CROC Cloud. Juntamente com colegas de Southbridge, que mini...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Packer, Terraform e Ansible: implantação do cluster Kubernetes em uma hora</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/croccloudteam/blog/492616/"><img src="https://habrastorage.org/webt/0m/2c/zt/0m2cztx1saqv1v7e8a3mrliht_k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Olá, meu nome é Andrey Schukin, ajudo grandes empresas a migrar serviços e sistemas para a CROC Cloud. Juntamente com colegas de Southbridge, que ministram cursos de Kubernetes no centro de treinamento Slerm, recentemente realizamos um webinar para nossos clientes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Decidi pegar os materiais de uma excelente palestra de Pavel Selivanov e escrever um post para aqueles que estão começando a trabalhar com ferramentas de provisionamento em nuvem e não sabem por onde começar. Portanto, falarei sobre a pilha de tecnologias usadas em nosso treinamento e produção do CROC Cloud. Vamos falar sobre abordagens modernas para gerenciamento de infraestrutura, sobre o pacote de componentes Packer, Terraform e Ansible, bem como sobre a ferramenta Kubeadm com a qual executaremos a instalação.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sob o corte, haverá muito texto e configurações. </font><font style="vertical-align: inherit;">Há muito material, então eu adicionei a navegação pós. </font><font style="vertical-align: inherit;">Também preparamos um pequeno repositório onde colocamos tudo o que precisamos para nossa implantação de treinamento. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não dê nomes às galinhas. </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bolos assados ​​são mais saudáveis ​​que fritos. </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Começamos o forno. </font><font style="vertical-align: inherit;">Packer </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terraform - infraestrutura como código </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iniciar a </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estrutura do </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Terraform </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Cluster </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Repositório </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Kubernetes </font></a></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubeadm </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com todos os arquivos</font></font></a><br>
 <a name="habracut"></a><br>
<a name="1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não dê nomes a galinhas</font></font></h2><br>
<img src="https://habrastorage.org/webt/j0/0w/v1/j00wv1h7pcevviakk2iocfleqjk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem muitos conceitos diferentes de gerenciamento de infraestrutura. Um deles é chamado Pets vs. Gado, isto é, "animais de estimação contra animais". Este conceito descreve duas abordagens opostas à infraestrutura. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imagine que temos um cachorro favorito. Nós cuidamos dela, o levamos ao veterinário, penteamos o pêlo e, em geral, é único para nós entre muitos outros cães.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em outro caso, temos um galinheiro. Também cuidamos de galinhas, alimentamos, aquecemos e tentamos criar as condições mais confortáveis. No entanto, as galinhas são um recurso sem rosto para nós, que cumpre sua função de pôr ovos, e, na melhor das hipóteses, as designamos como “aquele preto em pó que sempre bica cimento”. Se a galinha parar de pôr ovos ou quebrar a pata, provavelmente fornecerá um delicioso caldo para o almoço. De fato, não nos importamos com o destino de uma galinha individual, mas com o galinheiro como um todo como uma linha de produção. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na área de TI, uma abordagem semelhante começou a ser aplicada assim que as ferramentas apareceram, reduzindo o limite de entrada para os engenheiros e possibilitando implantar e manter clusters complexos em um modo totalmente automático.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anteriormente, tínhamos um pequeno número de servidores que eram monitorados, ajustados manualmente e tratados de todas as maneiras possíveis. No monitoramento, os logs dos servidores Cthulhu, Aylith e Dagon piscaram. Tradições. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então a virtualização entrou firmemente em nossas vidas, e os nomes das obras de Lovecraft e Star Trek deram lugar ao mais vantajoso "vlg-vlt-vault01.company.ru". Existem muitos servidores, mas ainda aumentamos os serviços mais ou menos manualmente, eliminando os problemas em cada máquina, se necessário.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, a abordagem para manter a infraestrutura coincide completamente com a programação. </font><font style="vertical-align: inherit;">Adicionamos outro nível de abstração e paramos de nos preocupar com nós individuais. </font><font style="vertical-align: inherit;">Cada um tem um índice sem rosto em vez de um nome e, no caso de um problema, a máquina virtual simplesmente mata e sobe a partir do instantâneo de trabalho. </font><font style="vertical-align: inherit;">Existem ferramentas que permitem implementar essa abordagem. </font><font style="vertical-align: inherit;">No nosso caso, a primeira ferramenta é a nuvem CROC, a segunda é a Terraform.</font></font><br>
<br>
<a name="2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bolos assados ​​são mais saudáveis ​​que fritos</font></font></h2><br>
<img src="https://habrastorage.org/webt/hs/pp/oa/hsppoaujv0lhrk0u3dt6ust0rry.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No gerenciamento de infraestrutura, há um contraste entre as duas abordagens Fried vs. Assado, ou seja, "frito contra assado". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A abordagem Fried implica que você tem uma imagem do SO baunilha, por exemplo, CentOS 7. Depois de implantar o SO, usamos o sistema de gerenciamento de configuração para trazer o sistema ao estado de destino. Por exemplo, usando Ansible, Chef, Puppet ou SaltStack.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo funciona bem, especialmente quando não há muitos servidores. Quando há necessidade de uma implantação maciça, nos deparamos com problemas de desempenho. Centenas de servidores começam a consumir sincronicamente recursos de rede, CPU, RAM e IOPS no processo de lançamento de muitos pacotes novos. Além disso, esse processo pode ser adiado por um longo tempo. Em resumo, o circuito é absolutamente operacional, mas não tão interessante do ponto de vista de minimizar o tempo de inatividade durante acidentes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A abordagem Baked implica que você possui imagens de SO prontas em que já instalou todos os pacotes necessários, configurou a configuração e tudo mais. </font><font style="vertical-align: inherit;">Na saída, temos um modelo de instantâneo abstrato, aprimorado para o desempenho de alguma função. </font><font style="vertical-align: inherit;">A implantação da infraestrutura a partir dessas imagens processadas leva muito menos tempo e reduz ao mínimo o tempo de inatividade. </font><font style="vertical-align: inherit;">Uma ideologia muito semelhante é usada nas imagens Docker de várias camadas, nas quais ninguém aperta as mãos desnecessariamente. </font><font style="vertical-align: inherit;">Pregou o recipiente - pegou um novo.</font></font><br>
<br>
<a name="3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Começamos o forno. </font><font style="vertical-align: inherit;">Packer</font></font></h2><br>
<img src="https://habrastorage.org/webt/xw/mr/im/xwmrimtkl-6qvfcrae3xo4zdf7q.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em nossa infraestrutura, usamos vários produtos Hashicorp, alguns dos quais se mostraram extremamente bem-sucedidos. Vamos começar nossa mágica com a preparação e o cozimento de uma imagem usando a ferramenta Packer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Packer usa um modelo JSON, ou seja, arquivos de modelo que contêm uma descrição do que precisa ser obtido como uma máquina virtual "VM". Após criar o modelo, o arquivo é transferido para o Packer e as permissões necessárias para criar o servidor na nuvem são configuradas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Packer permite que você crie VMs localmente no KVM, VirtualBox, Vagrant, AWS, GCP, Alibaba Cloud, OpenStack etc. É conveniente trabalhar com o Packer na CROC Cloud, pois implementa interfaces da AWS, ou seja, todas as ferramentas criadas para AWS, trabalhe com a CROC Cloud.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Após definir os modelos necessários, o Packer eleva o VM CROC na nuvem, aguarda o início e, em seguida, o "provedor" entra no fornecedor de trabalho: um utilitário que deve concluir a preparação da imagem. </font><font style="vertical-align: inherit;">No nosso caso, isso é Ansible, embora o Packer possa trabalhar com outras opções. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando a VM está pronta, o Packer cria sua imagem e a coloca na nuvem CROC para que outras VMs possam ser iniciadas a partir da mesma imagem.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estrutura Base.json</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No início do arquivo, há uma seção na qual as variáveis ​​são declaradas:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"variables" : {<font></font>
 "source_ami_name": "{{env SOURCE_AMI_NAME}}",<font></font>
 "ami_name": "{{env AMI_NAME}}",<font></font>
 "instance_type": "{{env INSTANCE_TYPE}}",<font></font>
 "kubernetes_version": "{{env KUBERNETES_VERSION}}",<font></font>
 "docker_version": "{{env DOCKER_VERSION}}",<font></font>
 "subnet_id": "",<font></font>
 "availability_zone": "",<font></font>
},</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O conjunto principal dessas variáveis ​​será definido no arquivo settings.json. </font><font style="vertical-align: inherit;">E aquelas variáveis ​​que mudam com frequência são mais convenientes de serem definidas no console ao iniciar o Packer e criar uma nova imagem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A seguir está a seção Construtores:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"builders" : [<font></font>
 {<font></font>
  "type": "amazon-ebs",<font></font>
  "region": "croc",<font></font>
  "skip_region_validation": true,<font></font>
  "custom_endpoint_ec2": "https://api.cloud.croc.ru",<font></font>
  "source_ami": "",<font></font>
  "source_ami_filter": {<font></font>
   "filters": {<font></font>
    "name": "{{user `source_ami_name`}}"<font></font>
    "state": "available",<font></font>
    "virtualization-type": "kvm-virtio"<font></font>
     },<font></font>
...</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuvens de destino e o método de inicialização da VM são descritos aqui. Observe que, neste caso, o tipo amazon-ebs é declarado, mas para a operação do Packer com a nuvem CROC, o endereço correspondente em custom_endpoint_ec2 é definido. Nossa infraestrutura possui uma API que é quase completamente compatível com o Amazon Web Services; portanto, se você tiver desenvolvimentos prontos para esta plataforma, na maioria das vezes precisará especificar apenas um ponto de entrada da API personalizado - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">api.cloud.croc.ru</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em nosso exemplo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vale a pena notar a seção source_ami_filter separadamente. </font><font style="vertical-align: inherit;">Aqui é definida a imagem inicial da VM, na qual as alterações necessárias serão feitas. </font><font style="vertical-align: inherit;">No entanto, o Packer requer uma AMI para esta imagem, ou seja, seu identificador aleatório. </font><font style="vertical-align: inherit;">Como esse identificador raramente é conhecido com antecedência e muda a cada atualização, a AMI de origem é definida não como um valor específico, mas como uma variável source_ami_filter. </font><font style="vertical-align: inherit;">Nesse caso, o parâmetro determinante do filtro é o nome da imagem. </font><font style="vertical-align: inherit;">Este nome é definido nas variáveis ​​através do arquivo settings.json. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, as configurações da VM são definidas: o tipo de instância, processador, tamanho da memória, espaço alocado etc. são especificados:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"instance_type": "{{user `instance_type`}}",<font></font>
"launch_block_device_mappings": [<font></font>
 {<font></font>
  "device_name": "disk1",<font></font>
  "volume_type": "io1",<font></font>
  "volume_size": "8",<font></font>
  "iops": "1000",<font></font>
  "delete_on_termination": "true"<font></font>
 }<font></font>
],</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A seguir, em base.json estão os parâmetros para conectar-se a esta VM:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"availability_zone": "{{user `availability_zone`}}",<font></font>
"subnet_id": "{{user `subnet_id`}}",<font></font>
"associate_public_ip_address": true,<font></font>
"ssh_username": "ec2-user",<font></font>
"ami_name": "{{user `ami_name`}}"<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É importante observar o parâmetro subnet_id aqui. </font><font style="vertical-align: inherit;">Ele deve ser definido manualmente, porque sem especificar a sub-rede da VM na nuvem CROC, é impossível criar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro parâmetro que requer preparação prévia é o endereço_public_ip_administrativo. </font><font style="vertical-align: inherit;">Você precisa selecionar um endereço IP branco, porque depois de criar o VM Packer começará a aplicar as configurações necessárias através do Ansible. </font><font style="vertical-align: inherit;">Nesse caso, o Ansible se conecta à VM via SSH, o que requer um endereço IP ou VPN branco. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A última seção é dos Provisioners:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"provisioners": [<font></font>
 {<font></font>
  "type": "ansible",<font></font>
  "playbook_file": "playbook.yml",<font></font>
  "extra_arguments": [<font></font>
   "--extra-vars",<font></font>
   "kubernetes_version={{user `kubernetes_version`}}",<font></font>
   "--extra-vars",<font></font>
   "docker_version={{user `docker_version`}}"<font></font>
   ]<font></font>
  }<font></font>
]</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esses são os provedores, ou seja, os utilitários com os quais o Packer configura o servidor. </font><font style="vertical-align: inherit;">Nesse caso, o provedor do tipo ansible é usado. </font><font style="vertical-align: inherit;">A seguir, é apresentado o parâmetro playbook_file, que define as funções Ansible e os hosts nos quais as funções especificadas serão aplicadas. </font><font style="vertical-align: inherit;">Opções adicionais extra_arguments são apresentadas abaixo, as quais, ao iniciar o Ansible, transmitem versões do Kubernetes e Docker.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preparação para a nuvem CROC</font></font></h3><br>
 <img src="https://habrastorage.org/webt/23/_s/uo/23_suoef0us5ia6kjgn8xteomba.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além dos nossos arquivos de configuração, precisamos fazer algumas coisas na lateral do painel de controle da nuvem para que toda a mágica funcione. </font><font style="vertical-align: inherit;">Precisamos selecionar um IP branco e criar uma sub-rede funcional, que usaremos ao implantar.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clique em Realçar endereço. </font><font style="vertical-align: inherit;">O Packer encontrará o endereço IP branco desejado por conta própria.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clique em Criar sub-rede e especifique uma sub-rede e uma máscara. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Copie o ID da sub-rede. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insira esse valor no parâmetro subnet_id do comando de inicialização do Packer. </font></font></li>
</ol><br>
<img src="https://habrastorage.org/webt/24/0w/gp/240wgpvzi8oyy6ixwzdj8cougqk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, execute o Packer. </font><font style="vertical-align: inherit;">Ele encontra a imagem original da VM, a implanta na nuvem CROC e executa a função Ansible nela. </font><font style="vertical-align: inherit;">A nova VM pode ser vista na nuvem CROC na seção "Instâncias". </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ol/aj/ui/olajuiprqljv50bi2opn4xlqcvs.png"> <br>
 <br>
<img src="https://habrastorage.org/webt/rq/0d/ri/rq0drint5cwvddjxbd7czcyfp9a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Após concluir o trabalho, o Packer remove a VM da nuvem e deixa uma imagem pronta em seu lugar, que pode ser encontrada na seção "Modelos". </font><font style="vertical-align: inherit;">Toda a infraestrutura do Kubernetes será criada a partir desta imagem.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ansible</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como mencionado anteriormente, o parâmetro playbook é passado nos parâmetros do provedor Ansible. </font><font style="vertical-align: inherit;">O arquivo playbook.yml se parece com o seguinte:</font></font><br>
<br>
<pre><code class="plaintext hljs">- hosts: all<font></font>
  become: true<font></font>
<font></font>
  roles:<font></font>
  | - base</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O arquivo é transferido para o Ansible que em todos os hosts é necessário cumprir a função de base. </font><font style="vertical-align: inherit;">Se houver outras funções, você poderá adicioná-las ao mesmo arquivo que uma lista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A função base permite que você obtenha um cluster pronto com um único comando. </font><font style="vertical-align: inherit;">O arquivo main.yml mostra o que exatamente essa função faz:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adiciona um repositório do Docker ao modelo do sistema. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adiciona o repositório Kubernetes ao modelo do sistema. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instala os pacotes necessários. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cria um diretório para configurar o daemon do Docker. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configura a máquina de acordo com o arquivo de configuração daemon.json.j2. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carrega o kernel br_netfilter.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inclui as opções necessárias para br_netfilter.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inclui componentes Docker e Kubelet.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Executa o Docker na VM.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Executa um comando que baixa as imagens do Docker necessárias para o Kubernetes funcionar.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, os pacotes instalados são configurados no arquivo main.yml no diretório vars. </font><font style="vertical-align: inherit;">No nosso caso, instalamos o pacote docker-ce, bem como os três pacotes necessários para o Kubernetes funcionar: kubelet, kubeadm e kubectl.</font></font><br>
<br>
<a name="4"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terraform - infraestrutura como código</font></font></h2><br>
<img src="https://habrastorage.org/webt/o4/um/wi/o4umwitq-qh_zpwr0thmcmejis0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terraform é uma ferramenta muito funcional da HashiCorp para orquestração de nuvens. Ele possui seu próprio idioma HCL específico, que é frequentemente usado em outros produtos da empresa, por exemplo, no HashiCorp Vault e Consul. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O princípio básico é semelhante a todos os sistemas de gerenciamento de configuração. Você simplesmente indica o estado de destino no formato desejado e o sistema calcula o algoritmo de como conseguir isso. Outra coisa é que, ao contrário do mesmo Ansible, que funciona como uma caixa preta em playbooks complexos, o Terraform pode fornecer um plano de ações futuras de uma forma conveniente para análise. Isso é importante ao planejar alterações complexas na infraestrutura. Após planejar as ações necessárias, execute o comando </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terraform apply</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e o Terraform implementará a infraestrutura descrita nos arquivos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como o Packer, essa ferramenta oferece suporte à AWS, GCP, Alibaba Cloud, Azure, OpenStack, VMware, etc.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nós descrevemos o projeto</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O diretório Terraform possui um conjunto de arquivos com a extensão .tf. </font><font style="vertical-align: inherit;">Esses arquivos descrevem os componentes da infraestrutura com a qual trabalharemos. </font><font style="vertical-align: inherit;">Divida o projeto em módulos funcionais. </font><font style="vertical-align: inherit;">Essa estrutura facilita o controle de versão e a montagem de cada projeto a partir de blocos práticos prontos. </font><font style="vertical-align: inherit;">Para nossa opção, a seguinte estrutura é adequada:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.tf</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">network.tf</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">security_groups.tf</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">master.tf</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">master.tpl</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estrutura do arquivo Main.tf</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos começar com o arquivo main.tf, no qual o acesso à nuvem está configurado. </font><font style="vertical-align: inherit;">Em particular, são anunciados vários parâmetros que configuram o Terraform para funcionar com a nuvem CROC:</font></font><br>
<br>
<pre><code class="plaintext hljs">provider "aws" {<font></font>
 endpoints {<font></font>
  ec2 = "https://api.cloud.croc.ru"<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, o arquivo descreve que o Terraform deve criar independentemente uma chave privada e fazer upload de sua parte pública para todos os servidores. </font><font style="vertical-align: inherit;">A própria chave privada é emitida no final do Terraform:</font></font><br>
<br>
<pre><code class="plaintext hljs">resource "tls_private_key" "ssh" {<font></font>
 algorithm = "RSA"<font></font>
}<font></font>
resource "aws_key_pair" "kube" {<font></font>
 key_name = "terraform"<font></font>
 public_key = "${tls_private_key.ssh.public_key_openssh}"<font></font>
}<font></font>
output "ssh" {<font></font>
value = "${tls_private_key.ssh.private_key_pem}"<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A estrutura do arquivo network.tf</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este arquivo descreve os componentes de rede necessários para iniciar a VM:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">data "aws_availability_zones" "az" {<font></font>
 state = "available"<font></font>
}<font></font>
resource "aws_vpc" "kube" {<font></font>
 cidr_block = "${var.vpc_cidr}"<font></font>
}<font></font>
resource "aws_eip" "master" {<font></font>
 count = "1"<font></font>
 vpc = true<font></font>
}<font></font>
resource "aws_subnet" "private" {<font></font>
 vpc_id = "${aws_vpc.kube.id}"<font></font>
 count = "${length(data.aws_availability_zones.az.names)}"<font></font>
 cidr_block = "${var.private_subnet_cidr_list[count.index]}"<font></font>
 availability_zone = "${data.aws_availability_zones.az.names[count.index]}"<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Terraform usa dois tipos de componentes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recurso - o que precisa ser criado;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dados - o que você precisa obter.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, o parâmetro data indica que o Terraform deve receber as zonas de disponibilidade da nuvem especificada, que estão no estado disponível. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O primeiro recurso de parâmetro descreve a criação de uma nuvem privada virtual e o próximo parâmetro descreve a criação de Endereço IP Elástico. Para o cluster Kubernetes, solicitamos esse endereço IP através do Terraform. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, em cada uma das zonas de acessibilidade e, no momento, o CROC possui dois serviços em nuvem, sua própria sub-rede é criada. Um recurso do tipo aws_subnet é declarado e o ID do aws_vpc gerado é passado como parte desse parâmetro. Mas, como o ID desse recurso ainda é desconhecido, especificamos o parâmetro aws_vpc.kube.id, que se refere ao recurso criado e substitui o valor do campo ID.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como o número de sub-redes criadas é determinado pelo número de zonas de disponibilidade da nuvem e esse número pode mudar com o tempo, esse parâmetro é definido através da variável length (data.aws_availability_zones.az.names), ou seja, o comprimento da lista de zonas de acesso recebidas por meio do parâmetro data. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os dois últimos parâmetros são cidr_block (a sub-rede alocada) e a zona de disponibilidade na qual essa sub-rede é criada. </font><font style="vertical-align: inherit;">O último parâmetro também é definido por meio de uma variável que obtém um valor da lista de dados de acordo com o índice do loop declarado por </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[count.index]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estrutura do arquivo Security_groups.tf</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grupos de segurança são um tipo de firewall para nuvens, que pode ser criado não dentro da própria VM, mas pela nuvem. </font><font style="vertical-align: inherit;">Nesse caso, o firewall descreve duas regras. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira regra cria um grupo de segurança chamado kube. </font><font style="vertical-align: inherit;">Esse grupo de segurança é necessário para permitir todo o tráfego de saída dos nós do Kubernetes, permitindo que os nós acessem livremente a Internet. </font><font style="vertical-align: inherit;">O tráfego de entrada para nós Kubernetes das sub-redes dos próprios nós também é permitido. </font><font style="vertical-align: inherit;">Assim, os nós do Kubernetes podem trabalhar entre si sem restrições. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A segunda regra cria o grupo de segurança ssh. </font><font style="vertical-align: inherit;">Ele permite a conexão SSH de qualquer endereço IP à porta 22 da VM do cluster Kubernetes:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">resource "aws_security_group" "kube" {<font></font>
 vpc_id = "${aws_vpc.kube.id}"<font></font>
 name   = "kubernetes"<font></font>
 # Allow all outbound<font></font>
 egress {<font></font>
  from_port = 0<font></font>
  to_port = 0<font></font>
  protocol = "-1"<font></font>
  cidr_blocks = ["0.0.0.0/0"]<font></font>
 }<font></font>
 # Allow all internal<font></font>
 ingress {<font></font>
  from_port = 0<font></font>
  to_port = 0<font></font>
  protocol = "-1"<font></font>
  cidr_blocks = ["${var.vpc_cidr}"]<font></font>
 }<font></font>
}<font></font>
resource "aws_security_group" "ssh" {<font></font>
 vpc_id = "${aws_vpc.kube.id}"<font></font>
 name   = "ssh"<font></font>
<font></font>
 # Allow all inbound<font></font>
 ingress {<font></font>
  from_port = 22<font></font>
  to_port = 22<font></font>
  protocol = "tcp"<font></font>
  cidr_blocks = ["0.0.0.0/0"]<font></font>
 }<font></font>
}</code></pre><br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nó mestre. </font><font style="vertical-align: inherit;">Estrutura de arquivos Master.tf</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O arquivo master.tf descreve a criação de vários modelos e instâncias. </font><font style="vertical-align: inherit;">Em particular, uma instância principal do Kubernetes está sendo criada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A variável ami define a AMI da imagem de origem para a VM. </font><font style="vertical-align: inherit;">A seguir, descreve o tipo de VM e a sub-rede na qual ela é criada. </font><font style="vertical-align: inherit;">Ao definir uma sub-rede, um ciclo é novamente usado para criar VMs em cada zona de disponibilidade. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, os grupos de segurança usados ​​e a chave especificada no arquivo main.tf são declarados. </font><font style="vertical-align: inherit;">O campo user_data contém a execução de um conjunto de scripts cloud-init, cujos resultados serão implementados na VM:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">resource "aws_instance" "master" {<font></font>
 count = "1"<font></font>
 ami = "${var.kubernetes_ami}"<font></font>
 instance_type = "c3.large"<font></font>
 disable_api_termination = false<font></font>
 instance_initiated_shutdown_behavior = "terminate"<font></font>
 source_dest_check = false<font></font>
 subnet_id = "${aws_subnet.private.*.id[count.index % length(data.aws_availability_zones.az.names)]}"<font></font>
 associate_public_ip_address = true<font></font>
 vpc_security_group_ids = [<font></font>
  "${aws_security_group.ssh.id}",<font></font>
  "${aws_security_group.kube.id}",<font></font>
 ]<font></font>
 key_name = "${aws_key_pair.kube.key_name}"<font></font>
 user_data = "${data.template_cloudinit_config.master.rendered}"<font></font>
 monitoring = "true"<font></font>
}</code></pre><br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nó mestre. </font><font style="vertical-align: inherit;">Cloud init</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Cloud-init</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é uma ferramenta que a Canonical está desenvolvendo. </font><font style="vertical-align: inherit;">Ele permite que você execute automaticamente em uma infraestrutura de nuvem um determinado conjunto de comandos após iniciar uma VM. </font><font style="vertical-align: inherit;">O Terraform possui mecanismos para se </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">integrar a ele usando modelos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como é impossível “assar” tudo o que é necessário na VM, após iniciar, dependendo do seu tipo, ele deve ingressar no cluster Kubernetes ou inicializar o cluster Kubernetes. </font><font style="vertical-align: inherit;">No modelo de arquivo cloud-init chamado master.tpl, várias ações são executadas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Os arquivos de configuração do Kubeadm são registrados:</font></font><br>
<br>
<pre><code class="plaintext hljs">#cloud-config<font></font>
<font></font>
    write_files:<font></font>
    - path: etc/kubernetes/kubeadm.conf<font></font>
      owner: root:root<font></font>
      content:<font></font>
    ...</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Um conjunto de comandos é executado:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o endereço IP do assistente é gravado no arquivo de configuração gerado;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o mestre no cluster Kubernetes é inicializado com o comando kubeadm init;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no cluster Kubernetes, a rede de sobreposição Calico é instalada com o comando kubectl apply.</font></font></li>
</ul><br>
 <pre><code class="plaintext hljs">runcmd:<font></font>
         - sed -i "s/CONTROL_PLANE_IP/$(curl http://169.254.169.254/latest/meta-data-local-ipv4)/g" /etc/kubernetes/kubeadm.conf<font></font>
         - kubeadm init --config /etc/kubernetes/kubeadm.conf<font></font>
         - mkdir -p $HOME/.kube<font></font>
         - sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<font></font>
         - sudo chown $(id -u):$(id -g) $HOME/.kube/config<font></font>
         - kubectl apply -f https://docs.projectcalico.org/v3.8/manifests/calico.yaml</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois de executar os comandos ao iniciar a VM, um cluster Kubernetes em funcionamento é obtido de um nó principal. </font><font style="vertical-align: inherit;">Os nós restantes ingressarão neste nó principal.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nós comuns. </font><font style="vertical-align: inherit;">node.tf</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O arquivo node.tf é semelhante ao arquivo master.tf. </font><font style="vertical-align: inherit;">Recursos também são criados aqui, que nesse caso são chamados de nó. </font><font style="vertical-align: inherit;">A única diferença é que o nó principal é criado em uma única instância e o número de nós em funcionamento criados é definido através da variável nodes_count:</font></font><br>
<br>
<pre><code class="plaintext hljs">resource "aws_instance" "node" {<font></font>
 count = "${var.nodes_count}"<font></font>
 ami = "${var.kubernetes_ami}"<font></font>
 instance_type = "c3.large"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O arquivo cloud-init para nós de trabalho executa apenas um comando - kubeadm join. </font><font style="vertical-align: inherit;">Este comando anexa a máquina finalizada ao cluster Kubernetes usando o token de autorização que enviamos.</font></font><br>
<br>
<a name="5"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lançamento Terraform</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando lançado, o Terraform usa vários módulos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Módulo AWS</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">módulo de modelo;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Módulo TLS responsável pela geração de chaves. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estes módulos devem ser instalados na máquina local:</font></font><br>
<br>
<pre><code class="plaintext hljs">terraform init terraform/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juntamente com este comando, é indicado o diretório em que todos os arquivos necessários estão localizados. </font><font style="vertical-align: inherit;">Ao inicializar, o Terraform baixa todos os módulos especificados, após o qual você precisa executar o comando plano de terraform:</font></font><br>
<br>
<pre><code class="plaintext hljs">terraform plan -var-file terraform/vars/dev.tfvars terraform/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe que, além do diretório com os arquivos do Terraform, é indicado o arquivo var, que contém os valores das variáveis ​​usadas nos arquivos do Terraform. </font><font style="vertical-align: inherit;">O diretório vars pode conter vários arquivos .tfvars, o que permite gerenciar diferentes tipos de infra-estruturas com um conjunto de arquivos Terraform. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O próprio arquivo dev.tfvars contém as seguintes variáveis ​​importantes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes_version (versão instalável do Kubernetes);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes_ami (imagem AMI criada pelo Packer). </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Após definir os valores necessários das variáveis, execute o comando do plano de terraform, após o qual o Terraform apresentará uma lista de ações necessárias para atingir o estado descrito nos arquivos do Terraform. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Após verificar esta lista, aplique as alterações propostas: </font></font><br>
<br>
<code>terraform apply -auto-approve -var-file terraform/vars/dev.tfvars terraform/</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No comando do plano de terraform, ele se distingue pela presença de uma chave - aprovação automática, que elimina a necessidade de confirmar as alterações feitas. </font><font style="vertical-align: inherit;">Você pode omitir essa chave, mas cada ação precisará ser confirmada manualmente.</font></font><br>
<br>
<a name="6"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estrutura de Cluster Kubernetes</font></font></h2><br>
<img src="https://habrastorage.org/webt/zs/i-/c3/zsi-c326-ips2acfurg_trunzhm.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O cluster Kubernetes consiste em um nó mestre que executa funções de gerenciamento e nós de trabalho que executam aplicativos instalados no cluster. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quatro componentes são instalados no nó principal que garantem a operação deste sistema:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ETCD, ou seja, banco de dados Kubernetes</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Servidor API, através do qual armazenamos informações no Kubernetes e obtemos informações dele;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controller Manager</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agendador </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dois componentes adicionais são instalados nos nós de trabalho:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kube-proxy (responsável por gerar regras de rede no cluster Kubernetes);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubelet (responsável por enviar o comando ao daemon do Docker para executar aplicativos no cluster Kubernetes). </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entre os nós, o plug-in de rede Calico funciona.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diagrama de fluxo de trabalho de cluster</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/oz/ew/f3/ozewf310dnhdmnx2gg4ozhzb1rc.png"><br>
,      Kubernetes    replicaset.<br>
<br>
<ol>
<li>     API-,     ETCD.        .</li>
<li>API-      .</li>
<li>Controller-manager   API-   ,    «»,    .</li>
<li>Scheduler       .       ETCD  API-.</li>
<li>Kubelet  API-  Docker    .</li>
<li>Docker   .</li>
<li>Kubelet   API-   ,     .</li>
</ol><br>
 ,    Kubernetes  ,      .       ,           ,     YAML-.  ,   ,    API-.       .<br>
</div></div><br>
<a name="7"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubeadm</font></font></h2><br>
<img src="https://habrastorage.org/webt/wd/sw/cu/wdswcujzvnx4ynnrbi_ec9c1gr8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O último elemento que vale a pena mencionar é o Kubeadm. </font><font style="vertical-align: inherit;">A implantação de um novo cluster Kubernetes é sempre um processo minucioso. </font><font style="vertical-align: inherit;">Em cada estágio, há riscos de erros devido ao fator humano, e muitas tarefas são simplesmente muito rotineiras e longas. </font><font style="vertical-align: inherit;">Por exemplo, servindo certificados para criptografia TLS entre nós e mantendo-os atualizados. </font><font style="vertical-align: inherit;">É aqui que os utilitários para automação básica de modelos são úteis. </font><font style="vertical-align: inherit;">O truque do Kubeadm é que ele é oficialmente certificado para trabalhar com o Kubernetes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele permite que você:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instale, configure e execute todos os principais componentes de cluster</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gerenciar certificados, incluindo rotacioná-los e redigir novos;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gerenciar versões de componentes de cluster (atualização e downgrade). </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao mesmo tempo, o Kubeadm não é um sistema completo de gerenciamento de cluster Kubernetes, mas é um tipo de componente básico que permite configurar o Kubernetes no nó no qual o utilitário Kubeadm está sendo executado. </font><font style="vertical-align: inherit;">Isso significa que é necessário um sistema de orquestração que execute todas as VMs necessárias, configure-as e execute o Kubeadm em todos os nós. </font><font style="vertical-align: inherit;">É para esses fins que o Terraform é usado.</font></font><br>
<br>
<a name="8"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repositório com todos os arquivos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, colocamos todos os arquivos e configurações</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em um único local, para que seja mais conveniente para você. </font><font style="vertical-align: inherit;">Se você não possui uma nuvem privada em mãos, mas deseja executar todas essas etapas e testar a implantação na prática, escreva-nos para cloud@croc.ru. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Forneceremos uma versão demo para testes e aconselharemos sobre todos os problemas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E em breve haverá um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">novo Slurm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , onde você poderá criar seu próprio cluster. </font><font style="vertical-align: inherit;">O código promocional CROC tem um desconto de 10%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para quem já trabalha com o Kubernetes, há um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">curso avançado</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">O desconto é o mesmo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Colegas, Habraparser quebra a marcação do código. </font><font style="vertical-align: inherit;">Por favor, pegue a fonte do GitHub no link acima.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt492600/index.html">Guia Semi-Científico para Hospedar um Roteador WiFi</a></li>
<li><a href="../pt492604/index.html">Trabalhando com o View de forma assíncrona usando coroutine</a></li>
<li><a href="../pt492606/index.html">Problemas do kit de ferramentas em grandes projetos</a></li>
<li><a href="../pt492608/index.html">Apresenta recursos de entrega em grandes projetos</a></li>
<li><a href="../pt492612/index.html">Plafon decorativo Leek Celebrity</a></li>
<li><a href="../pt492628/index.html">Intervalo de confiança para o número de pacientes com coronavírus (cálculo da mortalidade)</a></li>
<li><a href="../pt492632/index.html">Pequenas empresas em quarentena: o pânico é o inimigo da razão</a></li>
<li><a href="../pt492636/index.html">O que significa ser eficaz?</a></li>
<li><a href="../pt492638/index.html">Escalando um aplicativo Redux com patos</a></li>
<li><a href="../pt492642/index.html">Crie uma arquitetura escalável e resiliente com microsserviços dinâmicos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>