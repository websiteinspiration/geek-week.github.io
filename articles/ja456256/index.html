<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍⚖️ 🐶 🙎🏿 Androidアプリケーションアーキテクチャガイド 🚳 🤥 📤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！JetPackの「Guide to app architecture」の無料翻訳をお届けします。翻訳のすべてのコメントをコメントに残すようにお願いします。コメントは修正されます。また、提示されたアーキテクチャを使用したユーザーからのコメントとその使用に関する推奨事項は、すべての人...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Androidアプリケーションアーキテクチャガイド</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456256/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JetPack</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の「Guide to app architecture」の無料翻訳をお</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">届けし</font></a><font style="vertical-align: inherit;">ます。翻訳のすべてのコメントをコメントに残すようにお願いします。コメントは修正されます。また、提示されたアーキテクチャを使用したユーザーからのコメントとその使用に関する推奨事項は、すべての人に役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このガイドでは、堅牢なアプリケーションを構築するためのベストプラクティスと推奨アーキテクチャについて説明します。このページは、Androidフレームワークの基本的な紹介を前提としています。 Androidアプリの開発に不慣れな方は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デベロッパーガイドをご覧ください。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はじめに、このガイドで言及されている概念の詳細をご覧ください。</font><font style="vertical-align: inherit;">アプリケーションアーキテクチャに興味があり、このガイドの資料をKotlinプログラミングの観点から理解したい場合は、Udacityコース</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「Kotlinを使用したAndroidアプリケーションの開発」を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ご覧ください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モバイルアプリのユーザーエクスペリエンス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、デスクトップアプリケーションには、デスクトップまたはランチャーからの単一のエントリポイントがあり、単一のモノリシックプロセスとして実行されます。 Androidアプリケーションの構造ははるかに複雑です。典型的なAndroidアプリケーションには、いくつか含まれている</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションコンポーネント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を含め、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">活動</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラグメント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ContentProviders、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BroadcastReceiversを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのアプリケーションコンポーネントのすべてまたは一部をアプリケーション</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">マニフェスト</font></a><font style="vertical-align: inherit;">で宣言する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次に、Androidはこのファイルを使用して、アプリケーションをデバイスの共通ユーザーインターフェイスに統合する方法を決定します。</font><font style="vertical-align: inherit;">適切に作成されたAndroidアプリケーションには複数のコンポーネントが含まれており、ユーザーは短時間で複数のアプリケーションを操作することが多いため、アプリケーションはさまざまなタイプのワークフローやユーザー主導のタスクに適応する必要があります。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、お気に入りのソーシャルメディアアプリケーションで写真を共有するとどうなるかを考えてみましょう。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションはカメラのインテントを呼び出します。</font><font style="vertical-align: inherit;">Androidがカメラアプリケーションを起動して、リクエストを処理します。</font><font style="vertical-align: inherit;">現在、ユーザーはソーシャルネットワークのアプリケーションを離れており、ユーザーとしての経験は申し分のないものです。</font></font></li>
<li>     ,     ,      .</li>
<li>  ,         .</li>
</ol> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセスのどの時点でも、ユーザーは電話または通知によって中断される場合があります。この割り込みに関連するアクションの後、ユーザーはこの写真共有プロセスに戻って再開できることを期待しています。このアプリケーション切り替え動作はモバイルデバイスで一般的であるため、アプリケーションはこれらのポイント（タスク）を正しく処理する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モバイルデバイスのリソースも限られていることを忘れないでください。そのため、オペレーティングシステムはいつでも、一部のアプリケーションプロセスを破棄して、新しいプロセスのためにスペースを解放できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この環境の条件を前提として、アプリケーションのコンポーネントは順番にではなく個別に起動でき、オペレーティングシステムまたはユーザーはいつでもそれらを破棄できます。これらのイベントはあなたの管理下にないので、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションコンポーネントにデータや状態を保存しないでください。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">また、アプリケーションコンポーネントが相互に依存しないようにする必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的な建築原則</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションコンポーネントを使用してデータとアプリケーションの状態を保存しない場合、アプリケーションをどのように開発する必要がありますか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">責任分担</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
従うべき最も重要な原則は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、責任の共有です</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">よくある間違いは、すべてのコードを</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Activity</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragment</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で記述する場合です</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらは、ユーザーインターフェイスとオペレーティングシステムの相互作用を処理するロジックのみを含むユーザーインターフェイスクラスです。</font><font style="vertical-align: inherit;">これらのクラス</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（SRP）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">責任をできるだけ共有することにより</font><font style="vertical-align: inherit;">、アプリケーションのライフサイクルに関連する問題の多くを回避できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルからのユーザーインターフェイス制御</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の重要な原則は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ユーザーインターフェースをモデル</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から、できれば永続的なモデルから</font><b><font style="vertical-align: inherit;">制御する</font></b><font style="vertical-align: inherit;">必要があることです</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">モデルは、アプリケーションのデータを処理するコンポーネントです。</font><font style="vertical-align: inherit;">これらは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクト</font><font style="vertical-align: inherit;">やアプリケーションコンポーネントから</font><font style="vertical-align: inherit;">独立し</font><font style="vertical-align: inherit;">ているため、アプリケーションのライフサイクルや関連する問題の影響を受けません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
永続モデルは、次の理由で理想的です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android OSがアプリケーションを破棄してリソースを解放しても、ユーザーはデータを失うことはありません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワーク接続が不安定または使用できない場合でも、アプリケーションは機能し続けます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションの基盤を、データ管理の責任が明確に定義されたモデルクラスに編成することにより、アプリケーションのテストとサポートがさらに強化されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推奨されるアプリケーションアーキテクチャ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクション</font><font style="vertical-align: inherit;">では、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">エンドツーエンドの使用シナリオ</font></a><font style="vertical-align: inherit;">で動作する、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アーキテクチャコンポーネント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用してアプリケーションを構築する方法を示します</font><font style="vertical-align: inherit;">。</font><i><b><font style="vertical-align: inherit;">注意。</font></b></i><i><font style="vertical-align: inherit;">各シナリオに最適なアプリケーションを作成する方法を1つ用意することはできません。</font></i><i><font style="vertical-align: inherit;">ただし、推奨されるアーキテクチャは、ほとんどの状況とワークフローの出発点として適しています。</font></i><i><font style="vertical-align: inherit;">一般的なアーキテクチャの原則に一致するAndroidアプリケーションを作成する良い方法がすでにある場合は、それを変更しないでください。</font></i><font style="vertical-align: inherit;">
ユーザープロファイルを表示するユーザーインターフェイスを作成しているとします。</font><font style="vertical-align: inherit;">プライベートAPIとREST APIを使用して、プロファイルデータを取得します。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<i><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font></i> <br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概観</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、完成したアプリケーションアーキテクチャのモジュールの相互作用方式を検討します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lb/xq/cx/lbxqcxyjtoauqkif9hte7srpnm8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各コンポーネントは、その1つ下のレベルのコンポーネントにのみ依存することに注意してください。</font><font style="vertical-align: inherit;">たとえば、アクティビティとフラグメントはビューモデルにのみ依存します。</font><font style="vertical-align: inherit;">リポジトリは、他の多くのクラスに依存する唯一のクラスです。</font><font style="vertical-align: inherit;">この例では、ストレージは永続データモデルとリモートの内部データソースに依存しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このデザインパターンは、一貫した楽しいユーザーエクスペリエンスを作成します。</font><font style="vertical-align: inherit;">ユーザーがアプリケーションを閉じてから数分後に、または数日後にアプリケーションに戻るかどうかに関係なく、アプリケーションがローカルに保存されているというユーザーの情報がすぐに表示されます。</font><font style="vertical-align: inherit;">このデータが古い場合、アプリケーションストレージモジュールはバックグラウンドでデータの更新を開始します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーインターフェイスを作成する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーインターフェイスは、フラグメント</font></font><code>UserProfileFragment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とそれに対応するレイアウトファイルで</font><font style="vertical-align: inherit;">構成され</font><font style="vertical-align: inherit;">ます</font></font><code>user_profile_layout.xml</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーインターフェイスを管理するには、データモデルに次のデータ要素が含まれている必要があります。</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーID：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーID。</font><font style="vertical-align: inherit;">最善の解決策は、フラグメントの引数を使用してこの情報をフラグメントに渡すことです。</font><font style="vertical-align: inherit;">Android OSがプロセスを破壊した場合、この情報は保存されるため、次にアプリケーションを起動したときに識別子が利用可能になります。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーオブジェクト：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザー情報を含むデータクラス。</font></font></li>
</ul><br><font style="vertical-align: inherit;"></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネントベースのViewModel </font><font style="vertical-align: inherit;">
を使用して、</font><font style="vertical-align: inherit;">この情報を保存します。</font><i><u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ViewModel</font></a></u></i></font><br>
<br>
<i><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクト</font><font style="vertical-align: inherit;">は、フラグメントやアクティビティなどの特定のユーザーインターフェイスコンポーネントにデータを提供し、モデルと対話するためのビジネスデータ処理ロジックを含みます。</font><font style="vertical-align: inherit;">たとえば、</font><b><font style="vertical-align: inherit;">ViewModel</font></b><font style="vertical-align: inherit;">は他のコンポーネントを呼び出してデータを読み込み、ユーザーのデータ変更要求を転送する場合があります。</font><b><font style="vertical-align: inherit;">ViewModel</font></b><font style="vertical-align: inherit;">はユーザーインターフェイスのコンポーネントを認識しないため、デバイスが回転したときにアクティビティを再作成するなどの構成変更の影響を受けません。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font></u></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、次のファイルが定義されました。</font></font><br>
<br>
<ul>
<li><code>user_profile.xml</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ユーザーインターフェイスのレイアウトを定義しました。</font></font></li>
<li><code>UserProfileFragment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ユーザーへの情報の表示を担当するユーザーインターフェイスコントローラーについて説明します。</font></font></li>
<li><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：クラスは、データを表示するためのデータを準備</font></font><code>UserProfileFragment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、ユーザーの操作に応答します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のコードスニペットは、これらのファイルの初期コンテンツを示しています。</font><font style="vertical-align: inherit;">（レイアウトファイルは簡単にするために省略されています。）</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserProfileViewModel</span> : <span class="hljs-type">ViewModel</span></span>() {
   <span class="hljs-keyword">val</span> userId : String = TODO()
   <span class="hljs-keyword">val</span> user : User = TODO()<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserProfileFragment</span> : <span class="hljs-type">Fragment</span></span>() {
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewModel: UserProfileViewModel <span class="hljs-keyword">by</span> viewModels()<font></font>
<font></font>
   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(
       inflater: <span class="hljs-type">LayoutInflater</span>, container: <span class="hljs-type">ViewGroup</span>?,
       savedInstanceState: <span class="hljs-type">Bundle</span>?
   )</span></span>: View {
       <span class="hljs-keyword">return</span> inflater.inflate(R.layout.main_fragment, container, <span class="hljs-literal">false</span>)<font></font>
   }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのコードモジュールができたので、どのように接続しますか？</font><font style="vertical-align: inherit;">UserProfileViewModelクラスでユーザーフィールドを設定したら、ユーザーインターフェイスに通知する方法が必要です。</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SavedStateHandleにより、ViewModelは、関連付けられたフラグメントまたはアクションの保存された状態と引数にアクセスできます。</font></font></i><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// UserProfileViewModel</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserProfileViewModel</span></span>(<font></font>
   savedStateHandle: SavedStateHandle<font></font>
) : ViewModel() {<font></font>
   <span class="hljs-keyword">val</span> userId : String = savedStateHandle[<span class="hljs-string">"uid"</span>] ?:
          <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">"missing user id"</span>)
   <span class="hljs-keyword">val</span> user : User = TODO()<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// UserProfileFragment</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewModel: UserProfileViewModel <span class="hljs-keyword">by</span> viewModels(<font></font>
   factoryProducer = { SavedStateVMFactory(<span class="hljs-keyword">this</span>) }<font></font>
   ...<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ユーザーオブジェクトが受信されたときにフラグメントを通知する必要があります。ここに、LiveDataアーキテクチャのコンポーネントが表示されます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LiveData</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">監視</font></a><font style="vertical-align: inherit;">可能なデータホルダーです。アプリケーション内の他のコンポーネントは、このホルダーを使用して、オブジェクト間の依存関係の明示的なハードパスを作成することなく、オブジェクトの変更を追跡できます。 LiveDataコンポーネントは、アクティビティ、フラグメント、サービスなど、アプリケーションのコンポーネントのライフサイクルの状態も考慮し、オブジェクトのリークや過度のメモリ消費を防ぐためのクリーンアップロジックを備えています。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意。 RxJavaやAgeraなどのライブラリをすでに使用している場合は、LiveDataの代わりにそれらを引き続き使用できます。ただし、ライブラリや同様のアプローチを使用する場合は、アプリケーションのライフサイクルを適切に処理するようにしてください。特に、関連するLifecycleOwnerが停止したときにデータストリームを中断し、関連するLifecycleOwnerが破棄されたときにこれらのストリームを破棄するようにしてください。アーティファクトandroid.arch.lifecycle：jetストリームを追加して、RxJava2などの別のジェットストリームライブラリでLiveDataを使用することもできます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
アプリケーションでLiveDataコンポーネントを有効にするには、フィールドのタイプ</font></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をLiveDataに変更します。これで</font></font><code>UserProfileFragment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、データの更新について通知されます。また、これは</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">LiveData</font></a><font style="vertical-align: inherit;">フィールドなので</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライフサイクルをサポートし、不要になったリンクを自動的にクリアします。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserProfileViewModel</span></span>(<font></font>
   savedStateHandle: SavedStateHandle<font></font>
) : ViewModel() {<font></font>
   <span class="hljs-keyword">val</span> userId : String = savedStateHandle[<span class="hljs-string">"uid"</span>] ?:
          <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">"missing user id"</span>)
   <span class="hljs-keyword">val</span> user : LiveData&lt;User&gt; = TODO()<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に</font></font><code>UserProfileFragment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、データを監視</font></font><code>ViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、変更に応じてユーザーインターフェイスを更新するように変更します。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
   <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState)<font></font>
   viewModel.user.observe(viewLifecycleOwner) {<font></font>
       <span class="hljs-comment">//  UI</span><font></font>
   }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザープロファイルデータが更新される</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たび</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">onChanged（）</font></a><font style="vertical-align: inherit;">コールバックが呼び出さ</font><font style="vertical-align: inherit;">れ、ユーザーインターフェイスが更新されます。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">監視</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
可能なコールバックを使用する他のライブラリに精通している場合は、</font><font style="vertical-align: inherit;">フラグメントの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onStop（）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドを再定義</font><font style="vertical-align: inherit;">してデータの監視を停止して</font><font style="vertical-align: inherit;">いないことに気付いた可能性が</font><font style="vertical-align: inherit;">あります。このステップは、ライフサイクルをサポートするため、LiveDataには必要ありません。</font></font><code>onChanged()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つまり、フラグメントが非アクティブな状態の場合、</font><font style="vertical-align: inherit;">コールバックは呼び出されません</font><font style="vertical-align: inherit;">。つまり、彼は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onStart（）の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出しを受け取りましたが、</font><font style="vertical-align: inherit;">まだ受け取っていません</font></font><code>onStop()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。また、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LiveData</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、フラグメントで</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">onDestroy（）</font></a><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">呼び出すときにオブザーバーを自動的に削除し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーによるデバイスの画面の回転など、構成の変更を処理するロジックは追加していません。</font></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構成が変更されると自動的に復元されるため、新しいフラグメントが作成さ</font></font><code>ViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れるとすぐに</font><font style="vertical-align: inherit;">同じインスタンスを受け取り</font><font style="vertical-align: inherit;">、現在のデータを使用してコールバックがすぐに呼び出されます。</font><font style="vertical-align: inherit;">オブジェクト</font></font><code>ViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、更新</font><font style="vertical-align: inherit;">するオブジェクトに対応できるように設計されているため、</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ViewModel実装</font><font style="vertical-align: inherit;">にオブジェクトへの直接参照を含めない</font><font style="vertical-align: inherit;">でください。</font><font style="vertical-align: inherit;">ライフスパンの詳細について</font></font><code>ViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ユーザーインターフェースコンポーネントのライフサイクルに対応しています</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">。ViewModelライフサイクルを</font></a><font style="vertical-align: inherit;">参照してください</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ検索</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LiveDataを使用</font></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">てに接続</font><font style="vertical-align: inherit;">した</font></font><code>UserProfileFragment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ので、ユーザープロファイルデータを取得</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">はどうすればよいですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、バックエンドがREST APIを提供すると想定しています。レトロフィットライブラリを使用してバックエンドにアクセスしますが、同じ目的を果たす別のライブラリを使用することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、</font></font><code>Webservice </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックエンドにリンクする</font><font style="vertical-align: inherit;">定義</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Webservice</span> </span>{
   <span class="hljs-comment">/**
    * <span class="hljs-doctag">@GET</span> declares an HTTP GET request
    * <span class="hljs-doctag">@Path</span>("user") annotation on the userId parameter marks it as a
    * replacement for the {user} placeholder in the <span class="hljs-doctag">@GET</span> path
    */</span>
   <span class="hljs-meta">@GET(<span class="hljs-meta-string">"/users/{user}"</span>)</span>
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUser</span><span class="hljs-params">(<span class="hljs-meta">@Path(<span class="hljs-meta-string">"user"</span>)</span> userId: <span class="hljs-type">String</span>)</span></span>: Call&lt;User&gt;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装の最初のアイデアに</font></font><code>ViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font></font><code>Webservice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データを取得してこのデータをオブジェクトに割り当てる</font><font style="vertical-align: inherit;">直接呼び出しが含ま</font><font style="vertical-align: inherit;">れる</font><font style="vertical-align: inherit;">場合があり</font><font style="vertical-align: inherit;">ます</font></font><code>LiveData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この設計は機能しますが、その使用により、アプリケーションが大きくなるにつれてアプリケーションの保守がますます困難になります。これはクラスにあまりにも多くの責任を与え、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">利益</font></a></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分離の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原則に違反し</font><font style="vertical-align: inherit;">ます。さらに、ViewModelのスコープは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Activity</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragment</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライフサイクル</font><font style="vertical-align: inherit;">に</font></font><code>Webservice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関連付けられています。つまり、関連付けられたユーザーインターフェイスオブジェクトのライフサイクルが終了</font><font style="vertical-align: inherit;">するとデータが</font><font style="vertical-align: inherit;">失われます。この動作により、望ましくないユーザーエクスペリエンスが作成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代わりに、私たちのもの</font></font><code>ViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データを抽出するプロセスを新しいモジュールであるリポジトリに委任します。</font><u><i><b><font style="vertical-align: inherit;">リポジトリ</font></b></i></u></font><br>
<br>
<u><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュールは</font><font style="vertical-align: inherit;">データ操作を処理します。それらはクリーンなAPIを提供するため、アプリケーションの残りの部分はこのデータを簡単に取得できます。彼らは、データをどこから取得するか、データを更新するときにどのAPI呼び出しを行うかを知っています。リポジトリは、永続モデル、Webサービス、キャッシュなどのさまざまなデータソース間の仲介として表示できます。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font></i></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次のコードスニペットに示す</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラス</font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では、インスタンス</font></font><code>WebService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用してユーザーデータを取得します。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> webservice: Webservice = TODO()
   <span class="hljs-comment">// ...</span>
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUser</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>)</span></span>: LiveData&lt;User&gt; {
       <span class="hljs-comment">//    .    .</span>
       <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = MutableLiveData&lt;User&gt;()<font></font>
       webservice.getUser(userId).enqueue(<span class="hljs-keyword">object</span> : Callback&lt;User&gt; {
           <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">User</span>&gt;, response: <span class="hljs-type">Response</span>&lt;<span class="hljs-type">User</span>&gt;)</span></span> {
               <span class="hljs-keyword">data</span>.value = response.body()<font></font>
           }<font></font>
           <span class="hljs-comment">//     .</span>
           <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">User</span>&gt;, t: <span class="hljs-type">Throwable</span>)</span></span> {<font></font>
               TODO()<font></font>
           }<font></font>
       })<font></font>
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">data</span><font></font>
   }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストレージモジュールは不要に見えますが、それは重要な目的を果たします。アプリケーションの他の部分からデータソースを抽象化します。現在</font></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、データの抽出方法がわからないため、いくつかの異なるデータ抽出実装から取得したデータ表現モデルを提供できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単にするために、ネットワークエラーのケースを見逃しました。エラーとダウンロードステータスを公開する別の実装については、「付録：ネットワークステータスの開示」を参照してください。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネント間の依存関係の管理</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上記</font><b><font style="vertical-align: inherit;">の</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
クラス</font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には、</font></font><code>Webservice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーデータを取得</font><font style="vertical-align: inherit;">するためのインスタンスが必要</font><font style="vertical-align: inherit;">です。彼はインスタンスを作成することもできましたが、そのためにはクラスの依存関係も知っている必要があります</font></font><code>Webservice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。それに、</font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おそらくWebサービスを必要とする唯一のクラスではありません。参照が必要なすべてのクラスは</font></font><code>Webservice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その作成方法とその依存関係を知っ</font><font style="vertical-align: inherit;">ている必要があるため、この状況ではコードを複製する必要があります</font><font style="vertical-align: inherit;">。各クラスが新しいクラスを作成する場合</font></font><code>WebService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、アプリケーションは非常に多くのリソースを消費する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するには、次のデザインパターンを使用できます。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  (DI)</a>.       ,   .   ,       .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Dagger 2</a>       Android. Dagger 2   ,   ,       . </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">(Service location)  :</a>     ,          .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サービスレジストリの実装は、DIを使用するよりも簡単なので、DIに慣れていない場合は、代わりにテンプレートを使用してください：サービスの場所。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのテンプレートは、コードを複製または複雑化することなく依存関係を管理するための明確なテンプレートを提供するため、コードをスケーリングすることができます。</font><font style="vertical-align: inherit;">さらに、これらのテンプレートを使用すると、データサンプリングのテスト実装と本番実装をすばやく切り替えることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプルアプリケーションでは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dagger 2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">してオブジェクトの依存関係を管理します</font></font><code>Webservice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ViewModelとストレージを接続する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に</font></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、オブジェクトを使用</font><font style="vertical-align: inherit;">するように変更</font><font style="vertical-align: inherit;">します</font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserProfileViewModel</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
   savedStateHandle: SavedStateHandle,<font></font>
   userRepository: UserRepository<font></font>
) : ViewModel() {<font></font>
   <span class="hljs-keyword">val</span> userId : String = savedStateHandle[<span class="hljs-string">"uid"</span>] ?:
          <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">"missing user id"</span>)
   <span class="hljs-keyword">val</span> user : LiveData&lt;User&gt; = userRepository.getUser(userId)<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装</font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はオブジェクトへの呼び出しを抽象化しますが、</font></font><code>Webservice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのデータソースのみに依存しているため、あまり柔軟ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装の主な問題は、</font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックエンドからデータを受信した後、このデータがどこにも保存されないことです。</font><font style="vertical-align: inherit;">したがって、ユーザーが離れ</font></font><code>UserProfileFragment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">てから戻ってきた場合、アプリケーションでデータが変更されていなくても、データを再抽出する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この設計は、次の理由で最適ではありません。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">貴重なトラフィックリソースを消費します。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これにより、ユーザーは新しいリクエストの完了を待ちます。 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの欠点を排除するために、</font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクト</font></font><code>User</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をメモリに</font><font style="vertical-align: inherit;">キャッシュ</font><font style="vertical-align: inherit;">する新しいデータソースをに追加</font><font style="vertical-align: inherit;">します。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// Dagger,        .</span>
<span class="hljs-meta">@Singleton</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span></span>(
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> webservice: Webservice,
   <span class="hljs-comment">//    .    .</span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userCache: UserCache<font></font>
) {<font></font>
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUser</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>)</span></span>: LiveData&lt;User&gt; {
       <span class="hljs-keyword">val</span> cached = userCache.<span class="hljs-keyword">get</span>(userId)
       <span class="hljs-keyword">if</span> (cached != <span class="hljs-literal">null</span>) {
           <span class="hljs-keyword">return</span> cached<font></font>
       }<font></font>
       <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = MutableLiveData&lt;User&gt;()<font></font>
       userCache.put(userId, <span class="hljs-keyword">data</span>)
       <span class="hljs-comment">//     ,  ,  .</span>
       <span class="hljs-comment">//      .</span>
       webservice.getUser(userId).enqueue(<span class="hljs-keyword">object</span> : Callback&lt;User&gt; {
           <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">User</span>&gt;, response: <span class="hljs-type">Response</span>&lt;<span class="hljs-type">User</span>&gt;)</span></span> {
               <span class="hljs-keyword">data</span>.value = response.body()<font></font>
           }<font></font>
<font></font>
           <span class="hljs-comment">//     .</span>
           <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">User</span>&gt;, t: <span class="hljs-type">Throwable</span>)</span></span> {<font></font>
               TODO()<font></font>
           }<font></font>
       })<font></font>
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">data</span><font></font>
   }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">永続的なデータ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在の実装を使用すると、ユーザーがデバイスを回転させるか、離れてすぐにアプリケーションに戻ると、ストレージがメモリ内のキャッシュからデータを取得するため、既存のユーザーインターフェイスがすぐに表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、ユーザーがアプリケーションを離れ、Android OSがプロセスを完了してから数時間後に戻った場合はどうなりますか？この状況での現在の実装に依存して、ネットワークからデータを再度取得する必要があります。このアップグレードプロセスは、単に悪いユーザーエクスペリエンスではありません。また、貴重なモバイルデータを消費するため、無駄になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題はWebリクエストをキャッシュすることで解決できますが、新しい重要な問題が発生します。たとえば、友達のリストを受け取ったときに、同じユーザーデータが異なるタイプのリクエストに表示されるとどうなりますか？アプリケーションは競合するデータを表示しますが、これはよくても混乱を招きます。たとえば、ユーザーがフレンドリストリクエストとシングルユーザーリクエストを別々に送信した場合、アプリケーションは同じユーザーの2つの異なるバージョンのデータを表示することがあります。アプリケーションは、この矛盾するデータを組み合わせる方法を理解する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況に対処する正しい方法は、定数モデルを使用することです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Room</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Permanent Data Library（DB）が役立ち</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルーム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これはオブジェクトリレーショナルマッピングライブラリ（object-mapping）であり、最小限の標準コードでローカルデータストレージを提供します。コンパイル時に、データスキーマに準拠しているかどうか各クエリをチェックします。そのため、機能しないSQLクエリはコンパイル時エラーになり、ランタイムクラッシュにはなりません。ルームは、生のSQLテーブルとクエリのいくつかの基本的な実装の詳細から抽象化します。また、コレクションや接続要求などのデータベースデータの変更を観察し、LiveDataオブジェクトを使用してそのような変更を公開することもできます。メインスレッドのストレージへのアクセスなど、一般的なスレッドの問題を解決する実行制約も明示的に定義します。</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションがSQLiteオブジェクトリレーショナルマッピング（ORM）などの別のソリューションをすでに使用している場合は、既存のソリューションをRoomに置き換える必要はありません。</font><font style="vertical-align: inherit;">ただし、新しいアプリケーションを作成する場合、または既存のアプリケーションを再編成する場合は、Roomを使用してアプリケーションデータを保存することをお勧めします。</font><font style="vertical-align: inherit;">したがって、ライブラリの抽象化とクエリ検証を利用できます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Roomを使用するには、ローカル回路を定義する必要があります。</font><font style="vertical-align: inherit;">まず、</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">@Entity</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データモデルクラス</font></font><code>User</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に注釈</font><font style="vertical-align: inherit;">を追加</font></font><code>@PrimaryKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、</font></font><code>id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">フィールドに</font><font style="vertical-align: inherit;">注釈</font><font style="vertical-align: inherit;">を追加し</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらの注釈は</font></font><code>User</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、データベース内のテーブルとして、および</font></font><code>id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テーブルの主キーとして</font><font style="vertical-align: inherit;">マークさ</font><font style="vertical-align: inherit;">れ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Entity</span>
<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>(
   <span class="hljs-meta">@PrimaryKey</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> id: String,
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> name: String,
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lastName: String<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に</font></font><code>RoomDatabase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、アプリケーション</font><font style="vertical-align: inherit;">に実装するデータベースクラスを作成します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Database(entities = [User::class], version = 1)</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDatabase</span> : <span class="hljs-type">RoomDatabase</span></span>()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これ</font></font><code>UserDatabase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は抽象的である</font><font style="vertical-align: inherit;">ことに注意してください</font><font style="vertical-align: inherit;">。 Roomライブラリは、これの実装を自動的に提供します。詳細については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部屋の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメントを参照してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、ユーザーデータをデータベースに挿入する方法が必要です。このタスクでは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、データアクセスオブジェクト（DAO）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を作成</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">します</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Dao</span>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>{
   <span class="hljs-meta">@Insert(onConflict = REPLACE)</span>
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">save</span><span class="hljs-params">(user: <span class="hljs-type">User</span>)</span></span><font></font>
<font></font>
   <span class="hljs-meta">@Query(<span class="hljs-meta-string">"SELECT * FROM user WHERE id = :userId"</span>)</span>
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">load</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>)</span></span>: LiveData&lt;User&gt;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッド</font></font><code>load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、LiveDataタイプのオブジェクトを返す</font><font style="vertical-align: inherit;">ことに注意してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Roomはデータベースがいつ変更されたかを認識し、すべてのアクティブなオブザーバーにデータ変更を自動的に通知します。</font><font style="vertical-align: inherit;">Roomは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LiveDataを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用する</font><i><font style="vertical-align: inherit;">ため</font></i><font style="vertical-align: inherit;">、この操作は効率的です。</font><font style="vertical-align: inherit;">少なくとも1つのアクティブなオブザーバーが存在する場合にのみ、データを更新します。</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルームは、テーブルの変更に基づいて無効化をチェックします。つまり、誤検知通知を送信できます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスを定義</font></font><code>UserDao</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">したら、データベースクラスからDAOを参照します。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Database(entities = [User::class], version = 1)</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDatabase</span> : <span class="hljs-type">RoomDatabase</span></span>() {
   <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">userDao</span><span class="hljs-params">()</span></span>: UserDao<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで</font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Roomデータソースを含めるように</font><font style="vertical-align: inherit;">変更できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">//  Dagger,         .</span>
<span class="hljs-meta">@Singleton</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span></span>(
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> webservice: Webservice,
   <span class="hljs-comment">//    .    .</span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> executor: Executor,
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userDao: UserDao<font></font>
) {<font></font>
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUser</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>)</span></span>: LiveData&lt;User&gt; {<font></font>
       refreshUser(userId)<font></font>
       <span class="hljs-comment">//   LiveData    .</span>
       <span class="hljs-keyword">return</span> userDao.load(userId)<font></font>
   }<font></font>
<font></font>
   <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">refreshUser</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>)</span></span> {
       <span class="hljs-comment">//    .</span><font></font>
       executor.execute {<font></font>
           <span class="hljs-comment">// ,      .</span>
           <span class="hljs-keyword">val</span> userExists = userDao.hasUser(FRESH_TIMEOUT)
           <span class="hljs-keyword">if</span> (!userExists) {
               <span class="hljs-comment">//  .</span>
               <span class="hljs-keyword">val</span> response = webservice.getUser(userId).execute()<font></font>
<font></font>
               <span class="hljs-comment">//    .</span><font></font>
<font></font>
               <span class="hljs-comment">//   .  LiveData  ,</span>
               <span class="hljs-comment">//        .</span><font></font>
               userDao.save(response.body()!!)<font></font>
           }<font></font>
       }<font></font>
   }<font></font>
<font></font>
   <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
       <span class="hljs-keyword">val</span> FRESH_TIMEOUT = TimeUnit.DAYS.toMillis(<span class="hljs-number">1</span>)<font></font>
   }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データソースをに変更した場合でも</font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font><font style="vertical-align: inherit;">を変更する必要はありません</font></font><code>UserProfileFragment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この小さなアップデートは、アプリケーションアーキテクチャが提供する柔軟性を示しています。偽物</font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とプロダクションを同時にテスト</font><font style="vertical-align: inherit;">できるため、テストにも最適です</font></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーが数日で戻る場合、リポジトリが更新された情報を受け取るまで、このアーキテクチャを使用するアプリケーションは古い情報を表示する可能性があります。ユースケースによっては、古い情報が表示されない場合があります。代わりに、</font><i><font style="vertical-align: inherit;">プレースホルダー</font></i><font style="vertical-align: inherit;">データ（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">placeholder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ）、ダミー値を示し、アプリケーションが現在最新の情報をダウンロードおよびロードしていることを示します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">唯一の信頼できる情報源：</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
通常、異なるREST APIエンドポイントは同じデータを返します。たとえば、バックエンドに友達のリストを返す別のエンドポイントがある場合、同じユーザーオブジェクトが2つの異なるAPIエンドポイントから来る可能性があります。</font><font style="vertical-align: inherit;">ストレージからのデータのバージョンとフォーマットは最後に呼び出されたエンドポイントに依存するため、整合性をチェックせずに</font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リクエストからの応答をそのまま返した</font><font style="vertical-align: inherit;">場合</font></font><code>Webservice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ユーザーインターフェイスは混乱する情報を表示する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このため、私たちの実装</font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Webサービスの応答をデータベースに保存します。</font><font style="vertical-align: inherit;">次に、データベースを変更すると、アクティブな</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LiveData</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトのコールバックがトリガーされます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このモデルを使用すると</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、データベースは唯一の真の情報源として機能し</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、アプリケーションの他の部分は私たちを介してそれにアクセスします</font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ディスクキャッシュを使用するかどうかに関係なく、リポジトリでデータソースを残りのアプリケーションの唯一の信頼できるソースとして識別することをお勧めします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作の進行状況を表示</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プルトゥリフレッシュなどの一部の使用例では、ユーザーインターフェイスに、ネットワーク操作が現在進行中であることをユーザーに示すことが重要です。</font><font style="vertical-align: inherit;">さまざまな理由でデータが更新される可能性があるため、ユーザーインターフェイスアクションを実際のデータから分離することをお勧めします。</font><font style="vertical-align: inherit;">たとえば、友人のリストを受け取った場合、同じユーザーをプログラムで再度選択できます。これにより、LiveDataが更新されます。</font><font style="vertical-align: inherit;">ユーザーインターフェースの観点から見ると、リクエストが処理中であるという事実は、オブジェクト自体のデータの他の部分と同様に、単なる別のデータポイント</font></font><code>User</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のいずれかの方法を使用して、データ更新リクエストの送信元に関係なく、合意されたデータ更新ステータスをユーザーインターフェイスに表示できます。</font></font><br>
<br>
<ul>
<li> <code>getUser ()</code>,      <code>LiveData</code>.         .  ,   NetworkBoundResource   GitHub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">android-Architecture-components</a>. </li>
<li>      <code>UserRepository</code>,      .    ,              ,         ,   pull-to-refresh. </li>
</ul><br>
<h3>  </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
利益の分離に関するセクションでは、この原則に従うことの主要な利点の1つがテスト容易性であることを述べました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のリストは、拡張された例から各コードモジュールをテストする方法を示しています。</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーインターフェイスと操作</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android UIテストツールキットを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このテストを作成する最良の方法は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espresso</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリを使用すること</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">フラグメントを作成して、レイアウトを提供できます</font></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">フラグメントはにのみ関連付けられているため、</font><font style="vertical-align: inherit;">アプリケーションのユーザーインターフェイスを完全にテストするには、このクラスのみの</font></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モック</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（模倣）で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十分です。</font></font></li>
<li><b>ViewModel:</b>     <code>UserProfileViewModel</code>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">JUnit</a>.      , <code>UserRepository</code>. </li>
<li><b>UserRepository:</b>     <code>UserRepository</code>    JUnit.    <code>Webservice</code>  <code>UserDao</code>.      :<br>
<br>
<ul>
<li>    -. </li>
<li>     . </li>
<li>    ,     . </li>
</ul><br>
 </li>
<li>  <code>Webservice</code>,  <code>UserDao</code>  ,             . </li>
<li><b>UserDao:</b>   DAO    .       -   ,   .        ,  ,      ,        …<br>
<br>
<i><b>:</b> Room     ,    DAO,   JSQL  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">SupportSQLiteOpenHelper</a></b>.     ,      SQLite     SQLite   .</i> </li>
<li><b>-:</b>         .   ,  -,      .  ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://github.com/square/ok">MockWebServer</a>,          . </li>
<li><b> :</b>     maven    .    <code>androidx.arch.core</code>:    JUnit:<br>
<br>
<ul>
<li><code>InstantTaskExecutorRule:</code>            . </li>
<li><code>CountingTaskExecutorRule:</code>         .        Espresso     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>. </li>
</ul><br>
 </li>
</ul><br>
<h2> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラミングは創造的な分野であり、Androidアプリケーションの作成も例外ではありません。複数のアクションまたはフラグメント間でデータを転送する、削除されたデータを取得してローカルにオフラインで保存するなど、問題を解決するには多くの方法があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の推奨事項は必須ではありませんが、私たちの経験では、それらの実装により、コードベースの信頼性が高く、テスト可能で、長期的にサポートさ</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れることが示されています。アクション、サービス、ブロードキャストレシーバーなどのアプリケーションのエントリポイントをデータソースとして指定しないでください。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代わりに、他のコンポーネントと調整するだけで、このエントリポイントに関連するデータのサブセットを取得できます。アプリケーションの各コンポーネントは、ユーザーのデバイスとの相互作用やシステムの一般的な現在の状態に応じて、非常に短命です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションのさまざまなモジュール間に明確な責任の線を作成します。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
たとえば、ネットワークからデータをダウンロードするコードを、コードベースのいくつかのクラスまたはパッケージに配布しないでください。同様に、同じクラスで、データキャッシュやデータバインディングなど、関連のない複数の責任を定義しないでください。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各モジュールからできるだけ公開しないでください。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つのモジュールからの内部実装の詳細を明らかにする「1つだけ」のラベルを作成するという誘惑に抵抗します。短期的にはある程度の時間を稼ぐことができますが、コードベースの開発に伴い、技術的な負債が何度も発生します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各モジュールを個別にテスト可能にする方法を考えてください。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
たとえば、ネットワークからデータを取得するための明確に定義されたAPIがあれば、このデータをローカルデータベースに格納するモジュールを簡単にテストできます。代わりに、これら2つのモジュールのロジックを1か所に混在させるか、ネットワークコードをコードベース全体に分散させると、テストがさらに困難になります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他のアプリケーションから際立つように、アプリケーションの独自のコアに焦点を当てます。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じパターンを繰り返し書いてホイールを作り直さないでください。代わりに、アプリケーションを独自のものにすることに時間とエネルギーを集中させ、Androidアーキテクチャコンポーネントと他の推奨ライブラリが繰り返しパターンに対応できるようにします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関連性の高い最新のデータをできるだけ多く保存します。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
したがって、デバイスがオフラインであっても、ユーザーはアプリケーションの機能を楽しむことができます。すべてのユーザーが常時高速接続を使用しているわけではないことに注意してください。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単一のデータソースを唯一の真のソースとして指定します。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
アプリケーションがこのデータにアクセスする必要がある場合は常に、常にこの単一の真の情報源から取得する必要があります。</font></font><br>
<br>
<h3><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加：ネットワークステータスの開示</font></font></u></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の推奨アプリケーションアーキテクチャのセクションでは、コードスニペットを簡略化するために、ネットワークエラーとブート状態をスキップしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションでは、データとその状態の両方をカプセル化するResourceクラスを使用してネットワークステータスを表示する方法を示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のコードスニペットは、実装例を提供します</font></font><code>Resource:</code><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">//  ,         .</span>
<span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Resource</span>&lt;<span class="hljs-type">T</span>&gt;</span>(
   <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span>: T? = <span class="hljs-literal">null</span>,
   <span class="hljs-keyword">val</span> message: String? = <span class="hljs-literal">null</span><font></font>
) {<font></font>
   <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Success</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">data</span>: T) : Resource&lt;T&gt;(<span class="hljs-keyword">data</span>)
   <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Loading</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">data</span>: T? = <span class="hljs-literal">null</span>) : Resource&lt;T&gt;(<span class="hljs-keyword">data</span>)
   <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Error</span>&lt;<span class="hljs-type">T</span>&gt;</span>(message: String, <span class="hljs-keyword">data</span>: T? = <span class="hljs-literal">null</span>) : Resource&lt;T&gt;(<span class="hljs-keyword">data</span>, message)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このデータのコピーを表示するときにネットワークからデータをダウンロードすることは一般的な方法であるため、いくつかの場所で再利用できるヘルパークラスを作成すると便利です。この例では、という名前のクラスを作成します</font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の図は、のために決定木を示して</font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/e1/wv/c9/e1wvc9un_w2t8jyi0kiky8wagw0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは、リソースのデータベースを観察することによって開始されます。レコードがデータベースから初めてダウンロードされると、</font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果を送信するのに十分かどうか、またはネットワークから取得する必要があるかどうかが確認されます。ネットワークからデータを更新するときにキャッシュデータを表示したい場合は、これらの状況が同時に発生する可能性があることに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワーク呼び出しが成功すると、応答がデータベースに格納され、ストリームが再初期化されます。ネットワーク要求が</font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">失敗し</font><font style="vertical-align: inherit;">た場合は</font><font style="vertical-align: inherit;">、失敗を直接送信します。</font></font><br>
<br>
<code><b>.</b>             .       ,       . </code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変更の送信をデータベースに依存することは、関連する副作用の使用を伴うことに注意してください。データが変更されていないためにデータベースが変更を送信しない場合、これらの副作用の未定義の動作が発生する可能性があるため、これはあまり良くありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、ネットワークから受信した結果を送信しないでください。これは、単一の情報源の原則に違反するためです。</font><font style="vertical-align: inherit;">結局のところ、データベースには、保存操作中にデータ値を変更するトリガーが含まれている可能性があります。</font><font style="vertical-align: inherit;">同様に、クライアントが間違ったバージョンのデータを受信するため、新しいデータなしで「SUCCESS」を送信しないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のコードスニペットは、クラスによって</font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブクラスに</font><font style="vertical-align: inherit;">提供されるオープンAPIを示しています</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// ResultType:   .</span>
<span class="hljs-comment">// RequestType:   API.</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkBoundResource</span>&lt;<span class="hljs-type">ResultType, RequestType</span>&gt; </span>{
   <span class="hljs-comment">//      API   .</span>
   <span class="hljs-meta">@WorkerThread</span>
   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saveCallResult</span><span class="hljs-params">(item: <span class="hljs-type">RequestType</span>)</span></span><font></font>
<font></font>
   <span class="hljs-comment">//      ,  ,   </span>
   <span class="hljs-comment">//     .</span>
   <span class="hljs-meta">@MainThread</span>
   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">shouldFetch</span><span class="hljs-params">(<span class="hljs-keyword">data</span>: <span class="hljs-type">ResultType</span>?)</span></span>: <span class="hljs-built_in">Boolean</span><font></font>
<font></font>
   <span class="hljs-comment">//        .</span>
   <span class="hljs-meta">@MainThread</span>
   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadFromDb</span><span class="hljs-params">()</span></span>: LiveData&lt;ResultType&gt;<font></font>
<font></font>
   <span class="hljs-comment">//     API.</span>
   <span class="hljs-meta">@MainThread</span>
   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createCall</span><span class="hljs-params">()</span></span>: LiveData&lt;ApiResponse&lt;RequestType&gt;&gt;<font></font>
<font></font>
   <span class="hljs-comment">// ,    .  </span>
   <span class="hljs-comment">//    ,    .</span>
   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFetchFailed</span><span class="hljs-params">()</span></span> {}<font></font>
<font></font>
   <span class="hljs-comment">//   LiveData,  ,</span>
   <span class="hljs-comment">//    .</span>
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">asLiveData</span><span class="hljs-params">()</span></span>: LiveData&lt;ResultType&gt; = TODO()<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラス定義の次の重要な詳細に注意してください。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、2つのタイプのパラメータを定義し、</font></font><code>ResultType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして</font></font><code>RequestType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APIから戻されるデータ型ため、局所的に使用されるデータ型に対応していなくてもよいです。</font></font></li>
<li><font style="vertical-align: inherit;"></font><code>ApiResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワークリクエストの</font><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">応答をインスタンスに変換</font></font><code>ApiResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するクラスの単純なラッパーです</font><font style="vertical-align: inherit;">。</font></font><code>Retrofit2.Call</code><font style="vertical-align: inherit;"></font><code>LiveData</code><font style="vertical-align: inherit;"></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスの完全な実装は、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">GitHub android-Architecture-components</font></a></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトの一部として表示され</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作成したら、</font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それを使用して</font></font><code>User</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、クラスに</font><font style="vertical-align: inherit;">ディスクおよびネットワーク接続の実装を書き込むことができます</font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">//  Dagger2,         .</span>
<span class="hljs-meta">@Singleton</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span></span>(
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> webservice: Webservice,
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userDao: UserDao<font></font>
) {<font></font>
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getUser</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>)</span></span>: LiveData&lt;User&gt; {
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">object</span> : NetworkBoundResource&lt;User, User&gt;() {
           <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saveCallResult</span><span class="hljs-params">(item: <span class="hljs-type">User</span>)</span></span> {<font></font>
               userDao.save(item)<font></font>
           }<font></font>
<font></font>
           <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">shouldFetch</span><span class="hljs-params">(<span class="hljs-keyword">data</span>: <span class="hljs-type">User</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> {
               <span class="hljs-keyword">return</span> rateLimiter.canFetch(userId) &amp;&amp; (<span class="hljs-keyword">data</span> == <span class="hljs-literal">null</span> || !isFresh(<span class="hljs-keyword">data</span>))<font></font>
           }<font></font>
<font></font>
           <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadFromDb</span><span class="hljs-params">()</span></span>: LiveData&lt;User&gt; {
               <span class="hljs-keyword">return</span> userDao.load(userId)<font></font>
           }<font></font>
<font></font>
           <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createCall</span><span class="hljs-params">()</span></span>: LiveData&lt;ApiResponse&lt;User&gt;&gt; {
               <span class="hljs-keyword">return</span> webservice.getUser(userId)<font></font>
           }<font></font>
       }.asLiveData()<font></font>
   }<font></font>
}</code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja456240/index.html">チャットボットの開発（laravel + botman）</a></li>
<li><a href="../ja456242/index.html">マイクロコントローラーのマルチタスクについてもう少し</a></li>
<li><a href="../ja456246/index.html">ゼロ要素</a></li>
<li><a href="../ja456248/index.html">キャッチ方法：フォーカス要素のスタイルの前</a></li>
<li><a href="../ja456250/index.html">アプリケーションのローカリゼーションとRTLのサポート。Yandex.Taxiを報告する</a></li>
<li><a href="../ja456258/index.html">GNU FDL 1.3ライセンスに基づく「Free as in Freedom」のロシア語への翻訳は風のように無料、ビールのように無料</a></li>
<li><a href="../ja456260/index.html">フェアエコノミートーク</a></li>
<li><a href="../ja456262/index.html">ソフトウェア無線-それはどのように機能しますか？パート9</a></li>
<li><a href="../ja456264/index.html">ソースとAndroid NDKを使用してAndroidバイナリファイルをビルドします。screencapユーティリティを起動します</a></li>
<li><a href="../ja456266/index.html">モバイル＃302開発者向けの興味深い資料のダイジェスト（6月10〜16日）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>