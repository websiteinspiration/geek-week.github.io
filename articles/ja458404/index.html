<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏽 🤰 ☦️ モノリスからマイクロサービスへの移行：歴史と実践 👨🏿‍🤝‍👨🏽 👂🏼 🕠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事では、私が取り組んでいるプロジェクトが、大規模なモノリスから一連のマイクロサービスにどのように変わったかについて説明します。
 
 プロジェクトの歴史は2000年初頭に始まりました。最初のバージョンはVisual Basic 6で記述されていました。IDEと言語自体の開発が不十分なため、将来...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>モノリスからマイクロサービスへの移行：歴史と実践</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/458404/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事では、私が取り組んでいるプロジェクトが、大規模なモノリスから一連のマイクロサービスにどのように変わったかについて説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトの歴史は2000年初頭に始まりました。最初のバージョンはVisual Basic 6で記述されていました。IDEと言語自体の開発が不十分なため、将来この言語での開発をサポートすることが困難になることが明らかになりました。 2000年代後半に、より有望なC＃に切り替えることが決定されました。新しいバージョンは古いバージョンの改良と並行して作成され、徐々に.NETのコードが増えていきました。 C＃のバックエンドは最初はサービスアーキテクチャに重点を置いていましたが、開発時にはロジックを含む共有ライブラリが使用され、サービスは単一のプロセスで起動されました。 「サービスモノリス」と呼ばれるアプリケーションが判明しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このバンドルの数少ない利点の1つは、外部APIを介してサービスを相互に呼び出す機能です。</font><font style="vertical-align: inherit;">より正確なサービスへの移行、および将来的にはマイクロサービスアーキテクチャへの移行には、明確な前提条件がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2015年頃に分解作業を開始しました。</font><font style="vertical-align: inherit;">まだ理想的な状態には達していません。大規模プロジェクトの一部をモノリスと呼ぶのは難しいですが、マイクロサービスのようには見えません。</font><font style="vertical-align: inherit;">しかし、進歩はかなりのものです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事では彼について話します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ha/af/ct/haafctbyxepfypvukpmypyt30ji.png"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 既存のソリューションのアーキテクチャと問題</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイクロサービスへの期待</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移行の問題</font></font></a></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モノリスからマイクロサービスに切り替える方法</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の方法</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二番目の方法</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三の方法</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第四の方法</font></font></a></li>
</ul> </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DBを操作する</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">既存のテーブルを分岐する</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加工部</font></font></a></li>
</ul> </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコードを操作する</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インフラ問題</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">   </a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">    </a></li>
</ul></li>
</ul><br>
<br>
<a name="1"></a><b><h3>    </h3></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当初、アーキテクチャは次のように見えました。UIは独立したアプリケーションであり、モノリシックな部分はVisual Basic 6で記述されています。.NETのアプリケーションは、かなり大きなデータベースで機能する関連サービスのセットでした。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。以前のソリューションの短所</font></font></b><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シングルポイント障害が</font></font></u><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
。一つのプロセスで起動.NETアプリケーション：私たちは、単一障害点がありました。モジュールのいずれかがクラッシュした場合、アプリケーション全体が失敗し、再起動する必要がありました。私たちはさまざまなユーザーのために多数のプロセスを自動化しているため、そのうちの1人が失敗したため、一部のユーザーはしばらく動作しませんでした。また、ソフトウェアエラーにより、冗長性も効果がありませんでした。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">充実のラインナップ</font></font></u><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この欠陥はむしろ組織的なものです。私たちのアプリケーションには多くの顧客がいて、彼らは皆、できるだけ早くそれを完成させたいと思っています。以前は、これを並行して行うことは不可能であり、すべての顧客が並んでいました。このプロセスはビジネスにマイナスの影響を与えました。なぜなら彼らは彼らの仕事が価値があることを証明する必要があったからです。そして、開発チームは時間をかけてこのラインナップを整理していました。これには多くの時間と労力を要し、その結果、製品は彼からの場合ほど速く変化することができませんでした。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リソースの最適な使用</font></font></u><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
サービスを単一のプロセスに配置</font><u><font style="vertical-align: inherit;">する</font></u><font style="vertical-align: inherit;">場合、構成をサーバーからサーバーに常に完全にコピーしました。リソースを無駄にせず、導入スキームをより柔軟に管理できるように、最も負荷の高いサービスを個別に配置したいと考えました。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現代のテクノロジーを導入することは困難であり、</font></font></u><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
すべての開発者によく知られている問題</font><u><font style="vertical-align: inherit;">です。</font></u><font style="vertical-align: inherit;">プロジェクトに現代のテクノロジーを導入したいという願望がありますが、可能性はありません。</font><font style="vertical-align: inherit;">大規模なモノリシックソリューションでは、現在のライブラリの更新は、新しいライブラリへの移行は言うまでもなく、かなり重要なタスクになります。</font><font style="vertical-align: inherit;">チームのリーダーがこれを使用した神経よりも多くのボーナスをもたらすことを証明するには、長い時間がかかります。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更の発行の難しさ</font></font></u><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これは最も深刻な問題でした。2か月ごとにリリースを発行しました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストと開発者の努力にもかかわらず、各リリースは銀行にとって大きな災害になりました。</font><font style="vertical-align: inherit;">ビジネスは、機能の一部が週の初めに彼には機能しないことを理解していました。</font><font style="vertical-align: inherit;">そして開発者たちは、彼らが1週間の重大な事件を待っていることを理解しました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰もが状況を変えたいと思っていました。 </font></font><br>
<br>
<a name="2"></a><b><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイクロサービスへの期待</font></font></h3></b><br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在庫状況に応じたコンポーネントの配送。</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソリューションの分解とさまざまなプロセスの分離により、コンポーネントが利用可能になったときの配送。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小さな食品チーム。</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">古いモノリスで作業している大規模なチームを管理することが困難だったため、これは重要です。</font><font style="vertical-align: inherit;">そのようなチームは厳しいプロセスに従って働くことを余儀なくされましたが、私はもっと創造性と独立性を求めていました。</font><font style="vertical-align: inherit;">小さなチームだけがそれを買う余裕がありました。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別々のプロセスでのサービスの分離。</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理想的には、コンテナーに分離したかったのですが、.NET Frameworkで記述された多数のサービスはWindowsでのみ実行されます。</font><font style="vertical-align: inherit;">現在、サービスは.NET Coreに表示されていますが、現在のところ少数です。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">導入の柔軟性。</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は、コードが強制するのではなく、必要に応じてサービスを組み合わせたいと思います。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいテクノロジーの使用。</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはどのプログラマにとっても興味深いことです。</font></font><br>
<br>
<a name="3"></a><b><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移行の問題</font></font></h3></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、モノリスをマイクロサービスに分解するのが簡単であれば、会議でそれについて話したり記事を書いたりする必要はありません。このプロセスには多くの落とし穴があります。私たちを妨げた主な落とし穴について説明します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の問題</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ほとんどのモノリスの典型である、ビジネスロジックの一貫性です。モノリスを書くときは、余分なコードを書かないようにクラスを再利用したいと思います。マイクロサービスに切り替えると、これが問題になります。すべてのコードが非常に緊密に接続されており、サービスを分離することが困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作業の開始時に、リポジトリには500以上のプロジェクトと70万行以上のコードがありました。これはかなり大きなソリューションであり、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目の問題</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。単にそれを取得してマイクロサービスに分割することは不可能でした。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三の問題</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-必要なインフラストラクチャの欠如。</font><font style="vertical-align: inherit;">実際、ソースコードをサーバーに手動でコピーすることに関与していました。</font></font><br>
<br>
<a name="4"></a><b><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モノリスからマイクロサービスに切り替える方法</font></font></h3></b><br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイクロサービスの分離</font></font></u><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
まず、</font><u><font style="vertical-align: inherit;">マイクロサービス</font></u><font style="vertical-align: inherit;">の分離は反復的なプロセスであることがすぐにわかりました。</font><font style="vertical-align: inherit;">私たちは常に並行して業務開発を行うことを求められてきました。</font><font style="vertical-align: inherit;">これを技術的にどのように実行するかは、すでに私たちの問題です。</font><font style="vertical-align: inherit;">したがって、反復プロセスの準備をしていました。</font><font style="vertical-align: inherit;">大規模なアプリケーションの場合は動作が異なりません。また、最初から書き直す準備ができていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マイクロサービスを分離するためにどのような方法を使用しますか？</font></font><br>
<br>
<a name="5"></a><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の方法</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、既存のモジュールをサービスとして移植することです。この点で、私たちは幸運でした。WCFプロトコルで動作する正式なサービスは既にありました。それらは別々のアセンブリで配布されました。それらを別々に移動し、各アセンブリに小さなランチャーを追加しました。これは、アプリケーションをサービスとしてもコンソールとしても実行できる素晴らしいTopshelfライブラリを使用して作成されました。ソリューションに追加のプロジェクトは必要ないため、これはデバッグに便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サービスは、共通のアセンブリを使用し、共通のデータベースで動作するため、ビジネスロジックに従って接続されていました。それらを純粋な形でマイクロサービスと呼ぶのは困難でした。それにもかかわらず、これらのサービスを別々のプロセスで別々に発行することができます。これにより、相互の影響を減らし、並行開発と単一障害点の問題を減らすことができました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ホストを使用したビルドは、Programクラスのコードの1行にすぎません。</font><font style="vertical-align: inherit;">Topshelfをヘルパークラスに隠しました。</font></font><br>
<br>
<pre><code class="plaintext hljs">namespace RBA.Services.Accounts.Host<font></font>
{<font></font>
   internal class Program<font></font>
   {<font></font>
      private static void Main(string[] args)<font></font>
      {<font></font>
        HostRunner&lt;Accounts&gt;.Run("RBA.Services.Accounts.Host");<font></font>
<font></font>
       }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<a name="6"></a><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイクロサービスを分離する2番目の方法：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい問題を解決するためにそれらを作成します。</font><font style="vertical-align: inherit;">モノリスが同時に成長しない場合、これはすでに優れています。つまり、正しい方向に進んでいることになります。</font><font style="vertical-align: inherit;">新しい問題を解決するために、個別のサービスを実行しようとしました。</font><font style="vertical-align: inherit;">そのような機会があった場合は、データモデルを完全に制御する「標準」サービス、つまり別のデータベースを作成しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは、多くの人と同様に、認証および承認サービスから始めました。彼らはこれに最適です。これらは独立しており、原則として、個別のデータモデルを持っています。彼ら自身はモノリスと相互作用せず、彼がいくつかの問題を解決するために彼らに頼るだけです。これらのサービスでは、新しいアーキテクチャへの移行を開始し、それらのインフラストラクチャをデバッグし、ネットワークライブラリに関連するいくつかのアプローチを試すことができます。私たちの組織では、認証サービスを作成できなかったチームはありません。</font></font><br>
<br>
<a name="7"></a><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちが使用</font><b><font style="vertical-align: inherit;">するマイクロサービスを分離する3番目の方法</font></b><font style="vertical-align: inherit;">は、私たちに少し固有のものです。これは、UIレイヤーからビジネスロジックを引き出します。メインのデスクトップUIアプリケーションがあり、バックエンドと同様にC＃で記述されています。開発者は定期的にミスを犯し、バックエンドに存在して再利用されるはずだったロジックのUI部分を引き出しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UIパーツのコードから実際の例を見ると、このソリューションのほとんどに実際のビジネスロジックが含まれていることがわかります。これは、UIフォームの構築だけでなく、他のプロセスでも役立ちます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7s/_e/rb/7s_erbatvtbzompywj94igyvwho.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際のUIロジックは、最後の数行だけです。サーバーに転送して再利用できるようにしたので、UIが削減され、正しいアーキテクチャが実現しました。</font></font><br>
<br>
<a name="8"></a><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モノリスを削減できる</font><b><font style="vertical-align: inherit;">マイクロサービスを分離する4番目の最も重要な方法</font></b><font style="vertical-align: inherit;">は、既存のサービスを処理で削除することです。既存のモジュールをそのまま取り出すと、開発者にとって必ずしも満足できる結果にはならず、機能が作成された時点からのビジネスプロセスは時代遅れになる可能性があります。リファクタリングのおかげで、ビジネス要件は常に変化しているため、新しいビジネスプロセスをサポートできます。ソースコードを改善し、既知の欠陥を取り除き、より良いデータモデルを作成できます。多くの利点があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
処理サービス部門は、限定されたコンテキストの概念と密接に関連しています。これは主題指向の設計からの概念です。これは、単一言語のすべての用語が一意に定義されているドメインモデルセクションを意味します。例として保険と請求書のコンテキストを検討してください。私たちはモノリシックアプリケーションを使用しており、保険アカウントの保険と連携する必要があります。開発者は別のアセンブリで既存の「Account」クラスを見つけ、「Insurance」クラスからそれにリンクを作成することを期待しており、実際のコードを取得します。 DRYの原則が尊重され、既存のコードを使用したタスクがより速く実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、口座と保険のコンテキストが関連していることがわかりました。新しい要件が発生すると、この接続が開発を妨害し、すでに複雑なビジネスロジックの複雑さが増します。この問題を解決するには、コード内のコンテキスト間の境界を見つけて、それらの違反を取り除く必要があります。たとえば、保険のコンテキストでは、中央銀行の20桁の口座番号と口座開設の日付で十分である可能性が高いです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの限られたコンテキストを互いに分離し、マイクロサービスをモノリシックソリューションから分離するプロセスを開始するために、アプリケーション内に外部APIを作成するなどのアプローチを使用しました。一部のモジュールがマイクロサービスになり、プロセス内で何らかの形で変更されることがわかっている場合は、外部の呼び出しを通じて、別の限られたコンテキストに属するロジックをすぐに呼び出しました。たとえば、RESTまたはWCFを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分散トランザクションを必要とするコードは避けないことを自分たちで決めました。私たちの場合、このルールに従うのは非常に簡単であることがわかりました。ハード分散トランザクションが実際に必要とされるような状況にはまだ遭遇していません。モジュール間の最終的な整合性で十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
具体的な例を考えてみましょう。私たちは、「アプリケーション」の本質を処理するオーケストラ-コンベヤーの概念を持っています。彼は順番に顧客、口座、銀行カードを作成します。クライアントとアカウントが正常に作成され、カードの作成が失敗した場合、アプリケーションは「成功」の状態にならず、「カードが作成されません」の状態のままになります。将来的には、バックグラウンドアクティビティがそれを取得して終了します。システムはしばらくの間不整合の状態にありますが、これは全体として、私たちに適しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それにもかかわらず、データの一部を一貫して保存する必要がある状況が発生した場合、これを1つのプロセスで処理するためにサービスを拡大する可能性が最も高くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マイクロサービスの割り当ての例を考えてみましょう。どうすれば比較的安全に製品化できますか？この例では、システムの別の部分である給与サービスモジュールがあり、これはマイクロサービスを作成するコードのセクションの1つです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/g2/kn/he/g2knhebep6zxxcl-14mfdxd6xow.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、コードを書き換えてマイクロサービスを作成します。合わなかった点を改善します。お客様からの新たなビジネスニーズを実現します。コール転送を提供する、UIとAPIゲートウェイバックエンド間のバンドルに追加します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/g4/eo/sw/g4eoswb9nmxcoom9tbsug5quwsu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、この構成を運用にリリースしますが、パイロットの状態です。</font><font style="vertical-align: inherit;">ほとんどのユーザーは、古いビジネスプロセスを使用しています。</font><font style="vertical-align: inherit;">新しいユーザーのために、このプロセスに含まれていないモノリシックアプリケーションの新しいバージョンを開発しています。</font><font style="vertical-align: inherit;">実際、パイロットの形で動作するモノリスとマイクロサービスの束があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vw/hn/p3/vwhnp3x9xxb1qrnz9rqe-552mvs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パイロットが成功すると、新しい構成が実際に機能していることがわかり、古いモノリスを方程式から削除して、新しい構成を古いソリューションの代わりに残すことができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4w/pk/a3/4wpka3wcyexlk-ohyvab4vucbts.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
全体として、モノリスのソースコードを分離するために、ほぼすべての既存の方法を使用します。</font><font style="vertical-align: inherit;">これらすべてにより、アプリケーションのパーツのサイズを縮小して新しいライブラリに転送し、ソースコードを改善することができます。</font></font><br>
<br>
<a name="9"></a><b><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DBを操作する</font></font></h3></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在のスキーマだけでなく、累積された履歴データも含まれているため、データベースはソースコードよりも分割することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのデータベースには、他の多くのデータベースと同様に、巨大なサイズという別の重要な欠点がありました。このデータベースは、モノリスの複雑なビジネスロジックに従って設計されており、さまざまな限られたコンテキストのテーブル間にリンクが蓄積されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのケースでは、すべてのトラブル（大規模なデータベース、多くのリレーションシップ、時にはテーブル間の境界が理解できない場合がある）を完了するために、多くの大規模なプロジェクト（共有データベーステンプレートの使用）で問題が発生しました。データは、ビューからレプリケーションを介してテーブルから取得され、このレプリケーションが必要な他のシステムに送信されました。その結果、テーブルが頻繁に使用されたため、別のスキームでテーブルを取り出すことができませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分離は、コード内の限られたコンテキストに分割するのに役立ちます。これは通常、データベースレベルでデータを分割する方法についてかなり良い考えを与えてくれます。どのテーブルが1つの限定されたコンテキストに関連し、どれが別のコンテキストに関連するかを理解しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースを分割するには、既存のテーブルの分割と分割の2つのグローバルな方法を適用しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
既存のテーブルの分離は、データ構造が高品質であり、ビジネス要件を満たし、すべての人に適している場合に適した方法です。この場合、別のスキーマの既存のテーブルを選択できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビジネスモデルが大きく変化し、テーブルが完全に満足しなくなった場合、処理部門が必要になります。</font></font><br>
<br>
<a name="10"></a><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">既存のテーブルを分岐します。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何を分離するかを決定する必要があります。この知識がなければ、何も起こりません。ここでは、コード内の限られたコンテキストを分離することが役立ちます。原則として、ソースコードのコンテキストの境界を理解することができれば、どのテーブルを部門にリストするかが明確になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのモノリスモジュールが1つのデータベースと対話するソリューションがあるとします。 1つのモジュールのみが分離されたテーブルの一部と対話し、もう1つのモジュールがAPIを介して対話を開始することを確認する必要があります。まず、APIを介してエントリを作成するだけで十分です。これは、マイクロサービスの独立性について説明するために必要な条件です。大きな問題が発生するまで、リンクを読むことができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ed/tk/ea/edtkeafsmsewkmmwbaxh-nicpou.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のステップとして、別のマイクロサービスへの処理の有無にかかわらず、分離可能なテーブルで機能するコードセクションをすでに選択し、別のプロセスであるコンテナーで実行できます。これは、monolithデータベースと直接関係のないテーブルとの通信を伴う別個のサービスになります。モノリスは引き続き、取り外し可能なパーツと相互作用して読み取りを行います。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/39/xe/qp/39xeqpzjbsxcjtdxwh8_jgt4uxa.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
後でこの接続を削除します。つまり、モノリシックアプリケーションのデータを分離可能なテーブルから読み取ることもAPIに転送されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qu/j9/hx/quj9hx6oj3ovg71xy_lge9ziovg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、一般的なデータベースから、新しいマイクロサービスのみが機能するテーブルを選択します。テーブルを別のスキーマまたは別の物理データベースに移動することもできます。マイクロサービスとモノリスデータベースの間に読み取り接続がありましたが、心配する必要はありません。この構成では、長期間存続できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/os/uc/zq/osuczqkdtaoxzmdmii1oni3qhlm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後のステップは、すべての接続を完全に削除することです。この場合、メインデータベースからのデータ移行が必要になる場合があります。いくつかのデータベースで外部システムから複製されたデータやディレクトリを再利用したい場合があります。私たちは時々これに会います。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9e/ws/m9/9ewsm976maj96yzqj_-atbml4ae.png"> <br>
<br>
<a name="11"></a><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">処理部門。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この方法は最初の方法とよく似ており、逆の順序でのみ実行されます。 APIを介してモノリスと対話する新しいデータベースと新しいマイクロサービスがすぐに用意されました。しかし同時に、将来削除したい一連のデータベーステーブルが残っています。もう必要ありません。新しいモデルでは交換しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fy/ic/jx/fyicjxxkjagnsd_acgimthenabs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このスキームが機能するには、おそらく移行期間が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの可能なアプローチがあります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、新しいデータベースと古いデータベースのすべてのデータを複製します。この場合、データの冗長性があります。同期に問題がある可能性があります。しかし、2つの異なる顧客を受け入れることができます。 1つは新しいバージョンで動作し、もう1つは古いバージョンで動作します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二番目</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：いくつかのビジネス属性のデータを共有します。たとえば、私たちのシステムでは、古いデータベースに保存されている5つの製品がありました。 6番目の新しいビジネスタスクの一部として、新しいデータベースを作成しました。ただし、このデータを同期し、クライアントがどこで何を行うかを示すGateway APIが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どちらの方法も機能しています。状況に応じて選択してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが機能することを確認したら、古いデータベース構造で機能するモノリスの一部を無効にすることができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1j/tf/tg/1jtftgwoy_c-bcfa8yddp5whppc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後のステップは、古いデータ構造を削除することです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4r/4o/m_/4r4om_wgj3wwxi25mf45eg_umss.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要約すると、データベースに問題があると言えます。ソースコードに比べてデータベースで作業するのは難しく、分離するのはより困難ですが、これは可能であり、また実行する必要があります。</font><font style="vertical-align: inherit;">これを非常に安全に実行できるいくつかの方法を見つけましたが、ソースコードよりもデータを間違える方が簡単です。</font></font><br>
<br>
<a name="12"></a><b><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコードを操作する</font></font></h3></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、モノリシックプロジェクトの分析を開始したときのソースコード図です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/z2/2m/wxz22mn86ej9jfyhkjww7zmvnoe.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
条件付きで3つのレイヤーに分割できます。これは、起動されたモジュール、プラグイン、サービス、および個々のアクティビティのレイヤーです。実際、これらはモノリシックソリューション内のエントリポイントでした。それらのすべては共通層でしっかりと結合されていました。サービス間で共有されるビジネスロジックと多くの接続がありました。各サービスとプラグインは、それらのサイズと開発者の良心に応じて、最大10以上の一般的なアセンブリを使用しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸運なことに、個別に使用できるインフラストラクチャライブラリがありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commonオブジェクトの一部が実際にはこのレイヤーに属しておらず、インフラストラクチャライブラリである場合に、状況が発生することがあります。これは、名前を変更することによって決定されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も心配だったのは、限られたコンテキストでした。たまたま、3〜4つのコンテキストがCommonの1つのアセンブリに混在し、同じビジネス機能のフレームワーク内で互いに使用されていました。これをどこに分割でき、どの境界で、この分離をソースコードアセンブリにマッピングして次に何をするかを理解する必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード分​​離プロセスに関するいくつかのルールを策定しました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：サービス、アクティビティ、プラグイン間でビジネスロジックを共有する必要がなくなりました。彼らは、マイクロサービスのフレームワーク内でビジネスロジックを独立させたいと考えていました。一方、理想的な場合、マイクロサービスは完全に独立して存在するサービスとして認識されます。このアプローチは多少無駄が多いと思います。たとえば、C＃のサービスはいずれにしても標準ライブラリによって接続されるため、その実現は困難です。私たちのシステムはC＃で書かれており、他のテクノロジーはまだ使用されていません。したがって、一般的な技術アセンブリを使用する余裕があると判断しました。主なことは、ビジネスロジックのフラグメントがないことです。使用するORMの便利なラッパーがある場合、サービスからサービスへのコピーは非常に高価です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのチームは主題指向のデザインのファンなので、「オニオンアーキテクチャ」は私たちに最適です。私たちのサービスの基礎は、データアクセスレイヤーではなく、ビジネスロジックのみを含み、インフラストラクチャ接続のないドメインロジックを備えたアセンブリでした。同時に、ドメインアセンブリを個別に変更して、フレームワークに関連する問題を解決できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階で、私たちは最初の深刻な問題に直面しました。サービスは1つのドメインアセンブリを参照する必要があり、ロジックを独立させる必要があり、ここでDRYの原則が強く干渉しました。重複を避けるために、開発者は隣接するアセンブリのクラスを再利用することを望んでいたため、ドメインは再び相互に通信し始めました。私たちは結果を分析し、おそらく問題はソースコードストレージデバイスの領域にもあると判断しました。私たちはすべてのソースコードが置かれている大きなリポジトリを持っていました。プロジェクト全体のソリューションは、ローカルマシンでの組み立てが非常に困難でした。したがって、プロジェクトのパーツに対して個別の小さなソリューションが作成され、Commまたはドメインアセンブリをそれらに追加して再利用することを禁止する人はいませんでした。これを行うことができなかった唯一のツールはレビューコードでした。しかし時々彼はまた墜落した。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、個別のリポジトリを持つモデルに切り替え始めました。ビジネスロジックはサービスからサービスへと流れなくなり、ドメインは完全に独立しました。限定されたコンテキストがより明確にサポートされます。インフラストラクチャライブラリを再利用するにはどうすればよいですか？それらを別のリポジトリーで選択し、Artifactoryに配置したNugetパッケージに配置しました。変更を加えると、アセンブリと公開が自動的に行われます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/so/tk/g_/sotkg_uskgxq41d3swhkewhkzcy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのサービスは、外部のものと同じように内部インフラストラクチャパッケージを参照し始めました。</font><font style="vertical-align: inherit;">Nugetから外部ライブラリをダウンロードします。</font><font style="vertical-align: inherit;">これらのパッケージを配置するArtifactoryで作業するために、2つのパッケージマネージャーを使用しました。</font><font style="vertical-align: inherit;">小さなリポジトリでは、Nugetも使用しました。</font><font style="vertical-align: inherit;">複数のサービスを含むリポジトリでは、モジュール間のバージョンの一貫性を高めるPaketを使用しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dr/0g/qe/dr0gqecxnqni4wcer4m1ogw-x70.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ソースコードに取り組み、アーキテクチャをわずかに変更してリポジトリを共有することで、サービスをより独立させます。</font></font><br>
<br>
<a name="13"></a><b><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インフラ問題</font></font></h3></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マイクロサービスへの切り替えの欠点のほとんどはインフラストラクチャに関連しています。</font><font style="vertical-align: inherit;">インフラストラクチャを操作するには、自動展開が必要で、新しいライブラリが必要です。</font></font><br>
<br>
<a name="16"></a><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">環境への手動インストール</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最初に、環境に手動でソリューションをインストールしました。</font><font style="vertical-align: inherit;">このプロセスを自動化するために、CI / CDパイプラインを作成しました。</font><font style="vertical-align: inherit;">ビジネスプロセスの観点からは、継続的な展開はまだ受け入れられないため、継続的なデリバリープロセスを選択しました。</font><font style="vertical-align: inherit;">したがって、操作への送信はボタンによって、そしてテストのために-自動的に実行されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vz/lp/yw/vzlpyw7h9ej1gdxvkzqwivl_gqu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは、Atlassian、Bitbucketを使用してソースコードを保存し、Bambooを使用してビルドします。</font><font style="vertical-align: inherit;">アセンブリスクリプトは、Cと同じであるため、Cakeで記述します。</font><font style="vertical-align: inherit;">既製のパッケージがArtifactoryに届き、Ansibleが自動的にテストサーバーに到達した後、すぐにテストできます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-g/5p/dn/-g5pdnzpev-odvgxu-woy7qtcny.png"><br>
<br>
<a name="14"></a><b><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">個別のロギング</font></font></h3></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
かつて、モノリスのアイデアの1つは共同伐採の提供でした。</font><font style="vertical-align: inherit;">また、ディスク上にある個々のログをどう処理するかを理解する必要もありました。</font><font style="vertical-align: inherit;">ログはテキストファイルで書き込まれます。</font><font style="vertical-align: inherit;">標準のELKスタックを使用することにしました。</font><font style="vertical-align: inherit;">プロバイダー経由でELKに直接書き込むことはしませんでしたが、テキストログを完成させ、トレースIDを識別子として書き留め、これらのログを解析できるようにサービス名を追加することにしました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/e5/pd/ws/e5pdwsgrrb-9cpjhxabejxqdpt8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Filebeatを使用すると、サーバーからログを収集して変換し、Kibanaを使用してUIでリクエストを作成し、サービス間での呼び出しを監視することができます。</font><font style="vertical-align: inherit;">トレースIDはこれに大きく役立ちます。</font></font><br>
<br>
<a name="15"></a><b><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関連サービスのテストとデバッグ</font></font></h3></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は、開発されたサービスをデバッグする方法を完全には理解していませんでした。モノリスはすべてシンプルで、ローカルマシンで実行しました。最初はマイクロサービスで同じことを試みましたが、1つのマイクロサービスを完全に起動するために、他のいくつかを開始する必要があり、不便です。ローカルマシンにデバッグするサービスのみを残す場合は、モデルに切り替える必要があることに気付きました。残りのサービスは、prodの構成と一致するサーバーから使用されます。デバッグ後、テスト中、各タスクについて、変更されたサービスのみがテストサーバーに発行されます。したがって、ソリューションは、将来利用できる形でテストされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サービスの本番バージョンのみが存在するサーバーがあります。これらのサーバーは、問題が発生した場合、展開前に配信を確認するため、および内部トレーニングのために必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人気のSpecflowライブラリを使用した自動テストプロセスを追加しました。テストは、Ansibleからの展開直後にNUnitで自動的に実行されます。タスクのカバレッジが完全に自動である場合、手動でテストする必要はありません。ただし、追加の手動テストが依然として必要な場合もあります。特定のタスクに対して実行するテストを決定するには、Jiraでタグを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、ストレステストの必要性が高まっており、以前はまれなケースでのみ実施されていました。テストを実行するには、JMeterを使用して、それらを保存し（InfluxDB）、プロセスグラフを作成します（Grafana）。</font></font><br>
<br>
<b><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは何を達成しましたか？</font></font></h3></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、「リリース」の概念を取り除きました。</font><font style="vertical-align: inherit;">2か月前の巨大なリリースは、この巨大なものが本番環境に配備されたときに姿を消し、しばらくの間ビジネスプロセスを壊していました。</font><font style="vertical-align: inherit;">現在、サービスは承認後に稼働するため、平均1.5日ごとにサービスを展開してグループ化しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムに致命的なクラッシュはありません。</font><font style="vertical-align: inherit;">エラーが発生したマイクロサービスをリリースした場合、それに関連する機能は無効になり、他のすべての機能には影響しません。</font><font style="vertical-align: inherit;">これにより、ユーザーエクスペリエンスが大幅に向上します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
展開スキームを管理できます。</font><font style="vertical-align: inherit;">必要に応じて、他のソリューションとは別にサービスグル​​ープを選択できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、改善の大きなキューで問題を大幅に削減しました。</font><font style="vertical-align: inherit;">現在、サービスの一部を個別に処理する個別の製品チームがあります。</font><font style="vertical-align: inherit;">スクラムプロセスはすでに適切です。</font><font style="vertical-align: inherit;">特定のチームは、そのタスクを設定する製品の個別の所有者を持つ場合があります。</font></font><br>
<br>
<b><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h3></b><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイクロサービスは、複雑なシステムの分解に適しています。</font><font style="vertical-align: inherit;">その過程で、私たちはシステムに何があるか、境界がどこにある限られたコンテキストかを理解し始めます。</font><font style="vertical-align: inherit;">これにより、モジュールの改善を正しく配布し、コードの難読化を防ぐことができます。</font></font></li>
<li>   .        ,        ,     .    ,         , ,     Scrum.</li>
<li> —   .        .      .       legacy,      ,            .<br>
<br>
<i> :</i>       .        . ,     ,     ,     ,        , , ,  —   ,    .   .     ,     ,          . <br>
<br>
P.S.    (    ) –  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>. <br>
   .</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja458388/index.html">深い（学習+ランダム）フォレストと記事の解析</a></li>
<li><a href="../ja458390/index.html">Ceph-「膝の上」から「本番」までパート2</a></li>
<li><a href="../ja458394/index.html">例としてLoRaWANを使用したワイヤレスプロトコルの保護</a></li>
<li><a href="../ja458396/index.html">サーバー側レンダリングでVue.jsでの開発を便利にする方法</a></li>
<li><a href="../ja458398/index.html">遠隔作業の衛生またはテレパシーの利点</a></li>
<li><a href="../ja458406/index.html">ユーティリティおよび非ユーティリティプログラムに関する30以上の質問</a></li>
<li><a href="../ja458408/index.html">セキュリティウィーク27：インスリンポンプの脆弱性</a></li>
<li><a href="../ja458410/index.html">セマンティクスのクラスタリングと見出し語化に基づいてオンラインストア構造を開発する方法</a></li>
<li><a href="../ja458412/index.html">ブロックチェーンは、PRと宣伝だけのためにここにありますか？</a></li>
<li><a href="../ja458414/index.html">キャリアを変える方法、30歳でフロントエンドの開発者になり、あなたの喜びで働く方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>