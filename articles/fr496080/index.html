<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïï üë©‚Äç‚öñÔ∏è üêÑ Cr√©ation d'interactions IA simples avec des objets d'environnement üîÆ üïü üö´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lors de la cr√©ation de l'intelligence artificielle pour les jeux vid√©o, l'un des aspects les plus importants est sa localisation. La position du perso...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Cr√©ation d'interactions IA simples avec des objets d'environnement</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496080/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b5/840/cec/6b5840cec8e3b42adad879472c47930d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la cr√©ation de l'intelligence artificielle pour les jeux vid√©o, l'un des aspects les plus importants est sa localisation. La position du personnage de l'IA peut changer compl√®tement ses types de comportement et ses d√©cisions futures. Dans ce tutoriel, nous allons comprendre comment l'environnement de jeu peut affecter l'IA et comment l'utiliser correctement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet article est tir√© du livre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Practical Game AI Programming</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , √©crit par Michael Dagrack et publi√© par Packt Publishing. Ce livre vous permet d'apprendre √† cr√©er une IA de jeu et √† partir de z√©ro mettre en ≈ìuvre les algorithmes d'IA les plus avanc√©s.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les interactions visuelles sont basiques, elles n'affectent pas directement le gameplay, mais vous permettent d'am√©liorer le jeu vid√©o et ses personnages en les int√©grant √† l'environnement que nous cr√©ons, ce qui affecte grandement l'immersion du joueur dans le jeu. </font><font style="vertical-align: inherit;">Cela nous prouve l'importance de l'environnement faisant partie du jeu, et pas seulement d'aider √† remplir l'espace sur l'√©cran. </font><font style="vertical-align: inherit;">Des interactions similaires se retrouvent de plus en plus dans les jeux, et les joueurs s'attendent √† les voir. </font><font style="vertical-align: inherit;">S'il y a un objet dans le jeu, il doit remplir une fonction, mais pas la plus importante.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'un des premiers exemples d'interaction avec les environnements se trouve dans le premier Castlevania, sorti en 1986 pour la Nintendo Entertainment System. </font><font style="vertical-align: inherit;">D√®s le d√©but, le joueur peut utiliser le fouet pour d√©truire les bougies et les incendies, qui faisaient √† l'origine partie de l'arri√®re-plan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90c/a93/19c/90ca9319cffa8e665c51bc56297876a5.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce jeu et certains jeux de cette √©poque ont ouvert de nombreuses portes et opportunit√©s en termes de perception moderne des arri√®re-plans et des environnements des personnages du jeu. </font><font style="vertical-align: inherit;">De toute √©vidence, en raison des limites mat√©rielles de cette g√©n√©ration de consoles, il √©tait beaucoup plus difficile de cr√©er des choses simples qui sont g√©n√©ralement accept√©es par les normes actuelles. </font><font style="vertical-align: inherit;">Mais chaque g√©n√©ration de consoles a apport√© de nouvelles fonctionnalit√©s et les d√©veloppeurs les ont utilis√©es pour cr√©er des jeux incroyables.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, notre premier exemple d'interaction visuelle est un objet en arri√®re-plan qui peut √™tre d√©truit sans affecter directement le gameplay. </font><font style="vertical-align: inherit;">Ce type d'interaction se retrouve dans de nombreux jeux. </font><font style="vertical-align: inherit;">Son impl√©mentation est simple, il suffit d'animer l'objet lorsqu'il est attaqu√©. </font><font style="vertical-align: inherit;">Apr√®s cela, nous pouvons d√©cider si des points ou des objets doivent √™tre retir√©s de l'objet qui r√©compensent le joueur pour avoir explor√© le jeu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons maintenant passer √† l'exemple suivant - les objets du jeu qui sont anim√©s ou se d√©placent lorsque les personnages les traversent. Le principe ici est le m√™me que pour les objets destructibles, mais cette fois l'interaction est plus subtile - elle n√©cessite que le personnage se d√©place jusqu'au point o√π se trouve l'objet. Cela peut √™tre appliqu√© √† divers √©l√©ments du jeu, du mouvement de l'herbe, de la poussi√®re ou de l'eau aux oiseaux volants ou aux personnes faisant des gestes amusants; les possibilit√©s sont infinies. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de l'analyse de ces interactions, nous pouvons facilement d√©terminer qu'elles n'utilisent pas n√©cessairement l'IA, et dans la plupart des cas, c'est juste une fonction bool√©enne qui est activ√©e en fonction d'une action donn√©e. Mais ils font partie de l'environnement et doivent donc √™tre pris en compte lors de la mise en ≈ìuvre d'une interaction de haute qualit√© entre l'environnement et l'IA.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ez des interactions simples avec l'environnement</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme nous l'avons d√©j√† vu, l'environnement est devenu une fois une partie du gameplay, ce qui a donn√© naissance √† de nombreux nouveaux concepts et id√©es pour les futurs jeux. </font><font style="vertical-align: inherit;">L'√©tape suivante a √©t√© l'int√©gration de ces petits changements dans le gameplay et leur utilisation pour changer le comportement du joueur dans le jeu. </font><font style="vertical-align: inherit;">Cela a certainement affect√© positivement l'histoire des jeux vid√©o, car tous les √©l√©ments de la sc√®ne ont progressivement pris vie et le joueur a commenc√© √† r√©aliser √† quel point l'environnement √©tait riche. </font><font style="vertical-align: inherit;">L'utilisation d'environnements pour atteindre les objectifs du jeu fait d√©sormais partie du gameplay.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/0c6/39f/ad20c639fd190d338f6e2e72847338b1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour illustrer un exemple d'un environnement qui affecte directement le gameplay, nous prendrons un excellent exemple - la franchise Tomb Raider. Dans cet exemple, notre personnage, Lara Croft, doit pousser le cube jusqu'√† ce qu'il atterrisse sur la zone marqu√©e. Cela changera l'environnement et ouvrira un nouveau chemin, permettant au joueur de se d√©placer plus loin dans le niveau. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De tels puzzles peuvent √™tre trouv√©s dans de nombreux jeux: vous devez effectuer une action √† un certain point sur la carte afin que quelque chose se passe dans une autre partie de celui-ci, et cela peut √™tre utilis√© pour atteindre un objectif dans le jeu. Habituellement, nous devons changer l'environnement lui-m√™me afin de progresser davantage en niveau. Par cons√©quent, lorsque les d√©veloppeurs planifient une carte ou un niveau, ils en tiennent compte et cr√©ent toutes les r√®gles li√©es √† chacune des interactions. Par exemple:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(cube.transform.position == mark.transform.position)<font></font>
{<font></font>
  openDoor = <span class="hljs-literal">true</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imaginez maintenant un instant que Lara Croft ait un personnage alli√© dont la t√¢che principale est de l'aider √† remettre cette bo√Æte √† sa place. </font><font style="vertical-align: inherit;">Et dans ce chapitre, nous ne consid√©rerons que ce type d'interaction: le personnage de l'IA comprend comment l'environnement fonctionne et comment l'utiliser.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Environnement en mouvement dans Tomb Raider</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Allons directement √† ce sc√©nario et essayons de recr√©er une situation dans laquelle il y a un personnage IA qui peut aider le joueur √† atteindre son objectif. </font><font style="vertical-align: inherit;">Dans cet exemple, nous imaginerons qu'un joueur est pi√©g√© dont il ne peut pas acc√©der √† un objet interactif qui peut le lib√©rer. </font><font style="vertical-align: inherit;">Le personnage que nous cr√©ons doit pouvoir trouver le cube et le pousser dans la bonne direction.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b5/840/cec/6b5840cec8e3b42adad879472c47930d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors maintenant, nous avons tous les personnages et objets. Planifions le comportement du personnage de l'IA dans cette situation. Tout d'abord, il doit voir que le joueur est proche, afin qu'il puisse commencer √† rechercher et d√©placer le cube √† la position souhait√©e. Supposons que si le cube est √† la marque, alors un nouveau bloc appara√Æt du sable, permettant au joueur d'avancer plus loin en niveau. Un personnage IA peut pousser un cube dans quatre directions: gauche, droite, avant et arri√®re, de sorte qu'il s'adapte parfaitement au rep√®re de position.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/804/463/982/8044639827005d84bcf50014f095b46e.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le personnage AI doit v√©rifier et valider chaque action indiqu√©e dans cet arbre de comportement. La premi√®re chose et la plus importante pour continuer la t√¢che est que le personnage doit √™tre s√ªr que le joueur se trouve sur sa marque. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si le joueur n'y est pas encore arriv√©, alors notre personnage doit attendre et rester en place. Si le joueur est d√©j√† arriv√© √† la marque, alors le personnage AI continue l'ex√©cution et se demande √† quelle distance il est de l'objet cube. Sinon, le personnage devrait se diriger vers le cube, et une fois cette action confirm√©e, il devrait poser la m√™me question. Lorsque la r√©ponse devient positive et que le personnage est √† c√¥t√© du cube, il doit d√©terminer de quelle mani√®re vous devez d'abord pousser le cube. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puis il commence √† pousser le cube le long de l'axe Y ou X jusqu'√† ce qu'il corresponde √† la position de marquage et que la t√¢che soit termin√©e.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueYplayerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  {<font></font>
     playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous commen√ßons √† ajouter des informations au code qui permettent au personnage de v√©rifier si le joueur est √† c√¥t√© de sa position marqu√©e. Pour ce faire, nous cr√©ons toutes les variables n√©cessaires pour calculer les distances entre le joueur et la position dans laquelle il devrait se trouver. </font></font><code>playerMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fait r√©f√©rence au mod√®le 3D du joueur, √† partir duquel nous extrayons sa position et l'utiliser comme </font></font><code>currentPlayerPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour savoir s'il est proche de la marque, nous avons besoin d'une variable repr√©sentant la position de la marque, et dans notre exemple, nous avons cr√©√© une variable </font></font><code>playerMark</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans laquelle nous pouvons √©crire la position dans laquelle le joueur devrait √™tre. Ensuite, nous avons ajout√© trois variables qui nous permettent de savoir si le joueur est √† proximit√©. </font></font><code>proximityValueX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calcule la distance entre le joueur et la marque de l'axe X. </font></font><code>proximityValueY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calcule la distance entre le joueur et la marque de l'axe Y.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous avons </font></font><code>nearValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dans lequel nous pouvons d√©terminer √† quelle distance le joueur peut √™tre de la position de la marque, quand le personnage de l'IA peut commencer √† travailler pour atteindre l'objectif. D√®s que le joueur est proche de la marque, la variable bool√©enne </font></font><code>playerOnMark</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">change la valeur en </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour calculer la distance entre le joueur et la marque, nous avons utilis√© ce qui suit: la distance entre le joueur et sa marque, similaire </font></font><code>(mark.position - player.position)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, pour d√©terminer si le caract√®re AI est proche du cube, nous calculons la m√™me √©quation en calculant la distance entre l'IA et le cube. De plus, nous avons compl√©t√© le code avec des positions sur les deux marques (joueur et cube):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearCube;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> cubeIsNear;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
   Vector3 playerMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.2f</span>, <span class="hljs-number">32.6f</span>, <span class="hljs-number">-31.3f</span>);<font></font>
   Vector3 cubeMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.9f</span>, <span class="hljs-number">-8.3f</span>, <span class="hljs-number">-2.94f</span>);<font></font>
   nearValue = <span class="hljs-number">0.5f</span>;<font></font>
   nearCube = <span class="hljs-number">0.5f</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  {<font></font>
     playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  cubeProximityX = currentCubePosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  cubeProximityY = currentCubePosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>((cubeProximityX + cubeProximityY) &lt; nearCube)<font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant que notre personnage IA sait s'il est √† c√¥t√© du cube, cela nous permet de r√©pondre √† la question et de d√©terminer s'il peut passer √† la branche suivante que nous avons planifi√©e. </font><font style="vertical-align: inherit;">Mais que se passe-t-il lorsque le personnage n'est pas √† c√¥t√© du cube? </font><font style="vertical-align: inherit;">Il devra s'approcher du cube. </font><font style="vertical-align: inherit;">Par cons√©quent, nous ajouterons ceci au code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform cubeMesh;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearCube;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> cubeIsNear;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> Finding;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
   Vector3 playerMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.2f</span>, <span class="hljs-number">32.6f</span>, <span class="hljs-number">-31.3f</span>);<font></font>
   Vector3 cubeMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.9f</span>, <span class="hljs-number">-8.3f</span>, <span class="hljs-number">-2.94f</span>);<font></font>
   nearValue = <span class="hljs-number">0.5f</span>;<font></font>
   nearCube = <span class="hljs-number">0.5f</span>;<font></font>
   speed = <span class="hljs-number">1.3f</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  { <font></font>
      playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  cubeProximityX = currentCubePosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  cubeProximityY = currentCubePosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>((cubeProximityX + cubeProximityY) &lt; nearCube)<font></font>
  {<font></font>
      cubeIsNear = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
      cubeIsNear = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">false</span> &amp;&amp; Finding == <span class="hljs-literal">false</span>)<font></font>
  {<font></font>
     PositionChanging();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">true</span>)<font></font>
  {<font></font>
     Finding = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PositionChanging</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  Finding = <span class="hljs-literal">true</span>;<font></font>
  Vector3 positionA = <span class="hljs-keyword">this</span>.transform.position;<font></font>
  Vector3 positionB = cubeMesh.transform.position;<font></font>
  <span class="hljs-keyword">this</span>.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jusqu'√† pr√©sent, notre personnage AI est capable de calculer la distance entre lui et le cube; </font><font style="vertical-align: inherit;">s'ils sont trop √©loign√©s, alors il ira au cube. </font><font style="vertical-align: inherit;">Apr√®s avoir termin√© cette t√¢che, il peut passer √† la phase suivante et commencer √† pousser le cube. </font><font style="vertical-align: inherit;">La derni√®re chose dont il a besoin pour calculer est la distance entre le cube et la position de la marque, apr√®s quoi il d√©cide de quelle direction pousser, en tenant compte de quel c√¥t√© du cube la marque est la plus proche.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de1/be5/bf7/de1be5bf7e65540dfaeb6ab186a8e3c8.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le cube ne peut √™tre pouss√© que le long des axes X et Z, et sa rotation n'est pas encore importante pour nous, car le bouton est activ√© lorsque le cube est install√© dessus. Compte tenu de tout cela, le personnage AI doit calculer la distance entre le cube et la position de la marque en X et la position de la marque en Z. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, il compare les deux valeurs sur deux axes et s√©lectionne celle qui est la plus √©loign√©e de la position souhait√©e, puis commence √† pousser le long de cette axe. Le personnage continuera √† pousser dans cette direction jusqu'√† ce que le cube soit align√© avec la position de la marque, puis passe de l'autre c√¥t√©, et le poussera jusqu'√† ce qu'il soit compl√®tement au-dessus de la position de la marque:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform cubeMesh;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearCube;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeMarkProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeMarkProximityZ;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> cubeIsNear;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> Finding;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        Vector3 playerMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.2f</span>, <span class="hljs-number">32.6f</span>, <span class="hljs-number">-31.3f</span>);<font></font>
        Vector3 cubeMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.9f</span>, <span class="hljs-number">-8.3f</span>, <span class="hljs-number">-2.94f</span>);<font></font>
        nearValue = <span class="hljs-number">0.5f</span>;<font></font>
        nearCube = <span class="hljs-number">0.5f</span>;<font></font>
        speed = <span class="hljs-number">1.3f</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  {<font></font>
     playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  cubeProximityX = currentCubePosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  cubeProximityY = currentCubePosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>((cubeProximityX + cubeProximityY) &lt; nearCube)<font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">false</span> &amp;&amp; Finding == <span class="hljs-literal">false</span>)<font></font>
  {<font></font>
      PositionChanging();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">true</span>)<font></font>
  {<font></font>
      Finding = <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
   cubeMarkProximityX = cubeMark.transform.position.x - currentCubePosition.transform.position.x;<font></font>
   cubeMarkProximityZ = cubeMark.transform.position.z - currentCubePosition.transform.position.z;<font></font>
<font></font>
   <span class="hljs-keyword">if</span>(cubeMarkProximityX &gt; cubeMarkProximityZ)<font></font>
   {<font></font>
     PushX();<font></font>
   }<font></font>
<font></font>
   <span class="hljs-keyword">if</span>(cubeMarkProximityX &lt; cubeMarkProximityZ)<font></font>
   {<font></font>
     PushZ();<font></font>
   }<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PositionChanging</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  Finding = <span class="hljs-literal">true</span>;<font></font>
  Vector3 positionA = <span class="hljs-keyword">this</span>.transform.position;<font></font>
  Vector3 positionB = cubeMesh.transform.position;<font></font>
  <span class="hljs-keyword">this</span>.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s avoir ajout√© les derni√®res actions au code, le personnage doit apprendre √† d√©terminer son objectif, trouver et pousser le cube √† la position souhait√©e afin que le joueur puisse passer et terminer le niveau. </font><font style="vertical-align: inherit;">Dans cet exemple, nous nous sommes concentr√©s sur la fa√ßon de calculer les distances entre les objets de sc√®ne et les personnages. </font><font style="vertical-align: inherit;">Cela nous aidera √† cr√©er des types d'interactions similaires dans lesquels nous devons placer l'objet de jeu dans une certaine position. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'exemple montre un personnage IA amical qui aide le joueur, mais les m√™mes principes peuvent √™tre appliqu√©s si nous avons besoin de l'effet inverse (si le personnage est un ennemi), dans lequel le personnage doit trouver le cube le plus t√¥t possible pour arr√™ter le joueur.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obstacles dans des environnements utilisant l'exemple d'Age of Empires</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme nous l'avons vu pr√©c√©demment, vous pouvez utiliser ou d√©placer des objets dans le jeu pour atteindre des objectifs, mais que se passe-t-il si un objet obstrue le chemin du personnage? L'objet peut √™tre plac√© par le joueur ou simplement localis√© par le concepteur √† cette position de la carte. Dans tous les cas, le personnage IA devrait √™tre capable de d√©terminer ce qui doit √™tre fait dans cette situation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons observer ce comportement, par exemple, dans une strat√©gie appel√©e Age of Empires II d√©velopp√©e par Ensemble Studios. Chaque fois qu'un personnage de jeu ne peut pas atteindre le territoire ennemi en raison du fait qu'il est entour√© de murs fortifi√©s, l'IA passe √† la destruction d'une partie du mur pour continuer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce type d'interaction est √©galement tr√®s intelligent et important, car sinon les personnages se prom√®neraient le long du mur √† la recherche d'une entr√©e, et cela ne ressemblerait pas √† un comportement raisonnable. </font><font style="vertical-align: inherit;">Puisque le mur renforc√© est cr√©√© par le joueur, il peut √™tre plac√© n'importe o√π et avoir n'importe quelle forme. </font><font style="vertical-align: inherit;">Par cons√©quent, vous devez y penser lorsque vous d√©veloppez une IA ennemie.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/137/655/f44137655e3220988033bcb97db85b96.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet exemple se rapporte √©galement au sujet de notre article, car au stade de la planification, lorsque nous cr√©ons des arbres de comportement, nous devons r√©fl√©chir √† ce qui se passera si quelque chose g√™ne le personnage et qu'il ne peut pas atteindre ses objectifs. </font><font style="vertical-align: inherit;">Nous examinerons cet aspect en d√©tail dans les chapitres suivants du livre, mais pour l'instant nous simplifions la situation et analysons comment le personnage de l'IA devrait se comporter si l'objet d'environnement l'emp√™che d'atteindre son objectif.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfb/464/89b/dfb46489b482f383bc95662246308536.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre exemple, le personnage de l'IA doit entrer dans la maison, mais lorsqu'il s'approche, il se rend compte qu'il est entour√© d'une cl√¥ture en bois, √† travers laquelle vous ne pouvez pas passer. Nous voulons que le personnage choisisse une cible √† ce stade et commence √† attaquer jusqu'√† ce que cette partie de la cl√¥ture soit d√©truite et qu'il puisse entrer dans la maison. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet exemple, nous devons calculer quelle cl√¥ture le personnage doit attaquer, compte tenu de la distance et de l'√©tat de sant√© actuel de la cl√¥ture. Une cl√¥ture avec des HP bas devrait avoir une priorit√© d'attaque plus √©lev√©e qu'une cl√¥ture avec des HP complets, donc nous en tiendrons compte dans nos calculs.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/223/23f/ac4/22323fac4373a3556b58383bfb6b36fe.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous voulons d√©finir le voisinage autour du personnage, dans lequel les cl√¥tures les plus proches transmettent leurs informations √† l'intelligence artificielle afin qu'elle puisse d√©cider laquelle est plus facile √† d√©truire. Cela peut √™tre mis en ≈ìuvre de diff√©rentes mani√®res, soit en utilisant la reconnaissance des collisions de cl√¥tures avec le joueur, soit en les for√ßant √† calculer la distance entre les cl√¥tures / objets et le joueur; nous d√©finissons la valeur de la distance √† laquelle le joueur commence √† percevoir l'√©tat de la cl√¥ture. Dans notre exemple, nous allons calculer la distance et l'utiliser pour informer le personnage des cl√¥tures HP. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commen√ßons par cr√©er le code qui sera appliqu√© √† l'objet fence; tous auront le m√™me script:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> HP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> distanceValue;
<span class="hljs-keyword">private</span> Transform characterPosition;
<span class="hljs-keyword">private</span> GameObject characterMesh;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-comment">// Use this for initialization</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  HP = <span class="hljs-number">100f</span>;<font></font>
  distanceValue = <span class="hljs-number">1.5f</span>;<font></font>
<font></font>
  <span class="hljs-comment">// Find the Character Mesh</span>
  characterMesh = GameObject.Find(<span class="hljs-string">"AICharacter"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Update is called once per frame</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Obtain the Character Mesh Position</span><font></font>
  characterPosition = characterMesh.transform;<font></font>
<font></font>
  <span class="hljs-comment">//Calculate the distance between this object and the AI Character</span>
  proximityValueX = characterPosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  proximityValueY = characterPosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  nearValue = proximityValueX + proximityValueY;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce script, nous avons ajout√© des informations de base sur les HP et les distances, qui seront utilis√©es pour se connecter avec le personnage AI. Cette fois, nous ajoutons le script de calcul de distance non pas au personnage, mais aux objets d'environnement; cela donne √† l'objet plus de dynamisme et nous permet de cr√©er plus d'opportunit√©s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, si les personnages du jeu participent √©galement √† la cr√©ation de cl√¥tures, ils auront alors des √©tats diff√©rents, par exemple, ¬´en construction¬ª, ¬´termin√©¬ª ou ¬´endommag√©¬ª; le personnage pourra alors recevoir ces informations et les utiliser √† ses propres fins.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D√©finissons le personnage interagissant avec l'objet environnement. Son objectif principal sera d'acc√©der √† la maison, mais lorsqu'il s'en approche, il se rend compte qu'il ne peut pas entrer √† l'int√©rieur du fait qu'il est entour√© de cl√¥tures en bois. Nous voulons qu'apr√®s avoir analys√© la situation, notre personnage d√©truise la cl√¥ture pour atteindre son objectif et entrer dans la maison. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le script de caract√®re, nous ajouterons une fonction statique √† l'entr√©e dont les cl√¥tures pourront transmettre des informations sur leur ¬´sant√©¬ª actuelle; cela aidera le personnage √† choisir la cl√¥ture la plus appropri√©e pour la destruction.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> fenceHP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> lowerFenceHP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> fencesAnalyzed;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameObject bestFence;<font></font>
<font></font>
<span class="hljs-keyword">private</span> Transform House;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> timeWasted;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;<font></font>
<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        fenceHP = <span class="hljs-number">100f</span>;<font></font>
        lowerFenceHP = fenceHP;<font></font>
        fencesAnalyzed = <span class="hljs-number">0</span>;<font></font>
        speed = <span class="hljs-number">0.8</span>;<font></font>
<font></font>
        Vector3 House = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">300.2f</span>, <span class="hljs-number">83.3f</span>, <span class="hljs-number">-13.3f</span>);<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        timeWasted += Time.deltaTime;<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(fenceHP &gt; lowerFenceHP)<font></font>
        {<font></font>
            lowerFenceHP = fenceHP;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(timeWasted &gt; <span class="hljs-number">30f</span>)<font></font>
        {<font></font>
            GoToFence();  <font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GoToFence</span><span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        Vector3 positionA = <span class="hljs-keyword">this</span>.transform.position;<font></font>
        Vector3 positionB = bestFence.transform.position;<font></font>
        <span class="hljs-keyword">this</span>.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/970/af0/7a8970af0c9b5aa303ba32d6dc021ec8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons d√©j√† ajout√© les informations les plus √©l√©mentaires au personnage. </font></font><code>fenceHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sera une variable statique dans laquelle chaque cl√¥ture qui se situe dans le rayon du voisinage du personnage enregistrera des informations sur le HP actuel. Ensuite, le personnage de l'IA analyse les informations re√ßues et les compare avec la cl√¥ture avec le moins de HP pr√©sent√© </font></font><code>lowerFenceHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le personnage a une variable </font></font><code>timeWasted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repr√©sentant le nombre de secondes qu'il a d√©j√† pass√© √† chercher une cl√¥ture appropri√©e √† d√©truire. </font></font><code>fencesAnalyzed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sera utilis√© pour savoir s'il y a d√©j√† une cl√¥ture dans le code, et sinon, la premi√®re cl√¥ture trouv√©e par le personnage est ajout√©e; si les cl√¥tures ont la m√™me valeur de PV, le personnage les attaque en premier. Ajoutons maintenant le code des cl√¥tures afin qu'elles puissent acc√©der au script du personnage et entrer des informations utiles.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> HP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> distanceValue;
<span class="hljs-keyword">private</span> Transform characterPosition;
<span class="hljs-keyword">private</span> GameObject characterMesh;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> nearValue;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        HP = <span class="hljs-number">100f</span>;<font></font>
        distanceValue = <span class="hljs-number">1.5f</span>;<font></font>
<font></font>
        <span class="hljs-comment">// Find the Character Mesh</span>
        characterMesh = GameObject.Find(<span class="hljs-string">"AICharacter"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        <span class="hljs-comment">// Obtain the Character Mesh Position</span><font></font>
        characterPosition = characterMesh.transform;<font></font>
<font></font>
        <span class="hljs-comment">//Calculate the distance between this object and the AI Character</span>
        proximityValueX = characterPosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
        proximityValueY = characterPosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
        nearValue = proximityValueX + proximityValueY;<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(nearValue &lt;= distanceValue){
            <span class="hljs-keyword">if</span>(AICharacter.fencesAnalyzed == <span class="hljs-number">0</span>){<font></font>
                AICharacter.fencesAnalyzed = <span class="hljs-number">1</span>;<font></font>
                AICharacter.bestFence = <span class="hljs-keyword">this</span>.gameObject;<font></font>
            }<font></font>
<font></font>
            AICharacter.fenceHP = HP;<font></font>
<font></font>
            <span class="hljs-keyword">if</span>(HP &lt; AICharacter.lowerFenceHP){<font></font>
                AICharacter.bestFence = <span class="hljs-keyword">this</span>.gameObject;<font></font>
            }<font></font>
        }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons finalement termin√© cet exemple. </font><font style="vertical-align: inherit;">Maintenant, la cl√¥ture compare ses HP actuels avec les donn√©es du personnage ( </font></font><code>lowerFenceHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), et si ses HP sont inf√©rieurs √† la valeur la plus basse du personnage, alors cette cl√¥ture sera consid√©r√©e </font></font><code>bestFence</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet exemple montre comment adapter un personnage IA √† divers objets dynamiques du jeu; </font><font style="vertical-align: inherit;">le m√™me principe peut √™tre √©tendu et utilis√© pour interagir avec presque n'importe quel objet. </font><font style="vertical-align: inherit;">Il est √©galement applicable et utile lors de l'utilisation d'objets pour interagir avec un personnage, en reliant des informations entre eux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, nous avons explor√© diff√©rentes fa√ßons d'interagir avec l'environnement. </font><font style="vertical-align: inherit;">Les techniques pr√©sent√©es dans ce chapitre peuvent √™tre √©tendues √† de nombreux genres de jeux diff√©rents et utilis√©es pour effectuer des interactions simples et complexes entre les personnages de l'IA et l'environnement.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr496046/index.html">Graphiques 3D sur le STM32F103</a></li>
<li><a href="../fr496050/index.html">Des tigres et des lions contractent un coronavirus √† New York</a></li>
<li><a href="../fr496052/index.html">Comment une entreprise de services peut-elle √©viter des amendes √† un client? Quelques avantages √©vidents de l'automatisation des processus</a></li>
<li><a href="../fr496056/index.html">Num√©rique: comment les chiffres et les termes nous trompent</a></li>
<li><a href="../fr496058/index.html">Pourquoi est-il n√©cessaire de combiner des robots agricoles, quelles sont les difficult√©s et comment nous l'avons fait en deux ans</a></li>
<li><a href="../fr496082/index.html">Ing√©nieur et Data Scientist: quelle est la diff√©rence?</a></li>
<li><a href="../fr496084/index.html">Boutique en ligne c√¥t√© client Blazor: Partie 6 - Cr√©ation d'une commande et utilisation des actions compensatoires</a></li>
<li><a href="../fr496086/index.html">Organisation du travail √† distance avec les travaux num√©riques Zextras</a></li>
<li><a href="../fr496088/index.html">21 avril en direct! Meetup de localisation de Badoo</a></li>
<li><a href="../fr496090/index.html">Supprim√© avec Zyxel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>