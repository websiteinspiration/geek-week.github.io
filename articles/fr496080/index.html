<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕕 👩‍⚖️ 🐄 Création d'interactions IA simples avec des objets d'environnement 🔮 🕟 🚫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lors de la création de l'intelligence artificielle pour les jeux vidéo, l'un des aspects les plus importants est sa localisation. La position du perso...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Création d'interactions IA simples avec des objets d'environnement</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496080/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b5/840/cec/6b5840cec8e3b42adad879472c47930d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la création de l'intelligence artificielle pour les jeux vidéo, l'un des aspects les plus importants est sa localisation. La position du personnage de l'IA peut changer complètement ses types de comportement et ses décisions futures. Dans ce tutoriel, nous allons comprendre comment l'environnement de jeu peut affecter l'IA et comment l'utiliser correctement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet article est tiré du livre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Practical Game AI Programming</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , écrit par Michael Dagrack et publié par Packt Publishing. Ce livre vous permet d'apprendre à créer une IA de jeu et à partir de zéro mettre en œuvre les algorithmes d'IA les plus avancés.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les interactions visuelles sont basiques, elles n'affectent pas directement le gameplay, mais vous permettent d'améliorer le jeu vidéo et ses personnages en les intégrant à l'environnement que nous créons, ce qui affecte grandement l'immersion du joueur dans le jeu. </font><font style="vertical-align: inherit;">Cela nous prouve l'importance de l'environnement faisant partie du jeu, et pas seulement d'aider à remplir l'espace sur l'écran. </font><font style="vertical-align: inherit;">Des interactions similaires se retrouvent de plus en plus dans les jeux, et les joueurs s'attendent à les voir. </font><font style="vertical-align: inherit;">S'il y a un objet dans le jeu, il doit remplir une fonction, mais pas la plus importante.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'un des premiers exemples d'interaction avec les environnements se trouve dans le premier Castlevania, sorti en 1986 pour la Nintendo Entertainment System. </font><font style="vertical-align: inherit;">Dès le début, le joueur peut utiliser le fouet pour détruire les bougies et les incendies, qui faisaient à l'origine partie de l'arrière-plan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90c/a93/19c/90ca9319cffa8e665c51bc56297876a5.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce jeu et certains jeux de cette époque ont ouvert de nombreuses portes et opportunités en termes de perception moderne des arrière-plans et des environnements des personnages du jeu. </font><font style="vertical-align: inherit;">De toute évidence, en raison des limites matérielles de cette génération de consoles, il était beaucoup plus difficile de créer des choses simples qui sont généralement acceptées par les normes actuelles. </font><font style="vertical-align: inherit;">Mais chaque génération de consoles a apporté de nouvelles fonctionnalités et les développeurs les ont utilisées pour créer des jeux incroyables.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, notre premier exemple d'interaction visuelle est un objet en arrière-plan qui peut être détruit sans affecter directement le gameplay. </font><font style="vertical-align: inherit;">Ce type d'interaction se retrouve dans de nombreux jeux. </font><font style="vertical-align: inherit;">Son implémentation est simple, il suffit d'animer l'objet lorsqu'il est attaqué. </font><font style="vertical-align: inherit;">Après cela, nous pouvons décider si des points ou des objets doivent être retirés de l'objet qui récompensent le joueur pour avoir exploré le jeu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons maintenant passer à l'exemple suivant - les objets du jeu qui sont animés ou se déplacent lorsque les personnages les traversent. Le principe ici est le même que pour les objets destructibles, mais cette fois l'interaction est plus subtile - elle nécessite que le personnage se déplace jusqu'au point où se trouve l'objet. Cela peut être appliqué à divers éléments du jeu, du mouvement de l'herbe, de la poussière ou de l'eau aux oiseaux volants ou aux personnes faisant des gestes amusants; les possibilités sont infinies. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de l'analyse de ces interactions, nous pouvons facilement déterminer qu'elles n'utilisent pas nécessairement l'IA, et dans la plupart des cas, c'est juste une fonction booléenne qui est activée en fonction d'une action donnée. Mais ils font partie de l'environnement et doivent donc être pris en compte lors de la mise en œuvre d'une interaction de haute qualité entre l'environnement et l'IA.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créez des interactions simples avec l'environnement</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme nous l'avons déjà vu, l'environnement est devenu une fois une partie du gameplay, ce qui a donné naissance à de nombreux nouveaux concepts et idées pour les futurs jeux. </font><font style="vertical-align: inherit;">L'étape suivante a été l'intégration de ces petits changements dans le gameplay et leur utilisation pour changer le comportement du joueur dans le jeu. </font><font style="vertical-align: inherit;">Cela a certainement affecté positivement l'histoire des jeux vidéo, car tous les éléments de la scène ont progressivement pris vie et le joueur a commencé à réaliser à quel point l'environnement était riche. </font><font style="vertical-align: inherit;">L'utilisation d'environnements pour atteindre les objectifs du jeu fait désormais partie du gameplay.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/0c6/39f/ad20c639fd190d338f6e2e72847338b1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour illustrer un exemple d'un environnement qui affecte directement le gameplay, nous prendrons un excellent exemple - la franchise Tomb Raider. Dans cet exemple, notre personnage, Lara Croft, doit pousser le cube jusqu'à ce qu'il atterrisse sur la zone marquée. Cela changera l'environnement et ouvrira un nouveau chemin, permettant au joueur de se déplacer plus loin dans le niveau. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De tels puzzles peuvent être trouvés dans de nombreux jeux: vous devez effectuer une action à un certain point sur la carte afin que quelque chose se passe dans une autre partie de celui-ci, et cela peut être utilisé pour atteindre un objectif dans le jeu. Habituellement, nous devons changer l'environnement lui-même afin de progresser davantage en niveau. Par conséquent, lorsque les développeurs planifient une carte ou un niveau, ils en tiennent compte et créent toutes les règles liées à chacune des interactions. Par exemple:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(cube.transform.position == mark.transform.position)<font></font>
{<font></font>
  openDoor = <span class="hljs-literal">true</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imaginez maintenant un instant que Lara Croft ait un personnage allié dont la tâche principale est de l'aider à remettre cette boîte à sa place. </font><font style="vertical-align: inherit;">Et dans ce chapitre, nous ne considérerons que ce type d'interaction: le personnage de l'IA comprend comment l'environnement fonctionne et comment l'utiliser.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Environnement en mouvement dans Tomb Raider</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Allons directement à ce scénario et essayons de recréer une situation dans laquelle il y a un personnage IA qui peut aider le joueur à atteindre son objectif. </font><font style="vertical-align: inherit;">Dans cet exemple, nous imaginerons qu'un joueur est piégé dont il ne peut pas accéder à un objet interactif qui peut le libérer. </font><font style="vertical-align: inherit;">Le personnage que nous créons doit pouvoir trouver le cube et le pousser dans la bonne direction.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b5/840/cec/6b5840cec8e3b42adad879472c47930d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors maintenant, nous avons tous les personnages et objets. Planifions le comportement du personnage de l'IA dans cette situation. Tout d'abord, il doit voir que le joueur est proche, afin qu'il puisse commencer à rechercher et déplacer le cube à la position souhaitée. Supposons que si le cube est à la marque, alors un nouveau bloc apparaît du sable, permettant au joueur d'avancer plus loin en niveau. Un personnage IA peut pousser un cube dans quatre directions: gauche, droite, avant et arrière, de sorte qu'il s'adapte parfaitement au repère de position.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/804/463/982/8044639827005d84bcf50014f095b46e.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le personnage AI doit vérifier et valider chaque action indiquée dans cet arbre de comportement. La première chose et la plus importante pour continuer la tâche est que le personnage doit être sûr que le joueur se trouve sur sa marque. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si le joueur n'y est pas encore arrivé, alors notre personnage doit attendre et rester en place. Si le joueur est déjà arrivé à la marque, alors le personnage AI continue l'exécution et se demande à quelle distance il est de l'objet cube. Sinon, le personnage devrait se diriger vers le cube, et une fois cette action confirmée, il devrait poser la même question. Lorsque la réponse devient positive et que le personnage est à côté du cube, il doit déterminer de quelle manière vous devez d'abord pousser le cube. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puis il commence à pousser le cube le long de l'axe Y ou X jusqu'à ce qu'il corresponde à la position de marquage et que la tâche soit terminée.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueYplayerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  {<font></font>
     playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous commençons à ajouter des informations au code qui permettent au personnage de vérifier si le joueur est à côté de sa position marquée. Pour ce faire, nous créons toutes les variables nécessaires pour calculer les distances entre le joueur et la position dans laquelle il devrait se trouver. </font></font><code>playerMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fait référence au modèle 3D du joueur, à partir duquel nous extrayons sa position et l'utiliser comme </font></font><code>currentPlayerPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour savoir s'il est proche de la marque, nous avons besoin d'une variable représentant la position de la marque, et dans notre exemple, nous avons créé une variable </font></font><code>playerMark</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans laquelle nous pouvons écrire la position dans laquelle le joueur devrait être. Ensuite, nous avons ajouté trois variables qui nous permettent de savoir si le joueur est à proximité. </font></font><code>proximityValueX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calcule la distance entre le joueur et la marque de l'axe X. </font></font><code>proximityValueY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calcule la distance entre le joueur et la marque de l'axe Y.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous avons </font></font><code>nearValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dans lequel nous pouvons déterminer à quelle distance le joueur peut être de la position de la marque, quand le personnage de l'IA peut commencer à travailler pour atteindre l'objectif. Dès que le joueur est proche de la marque, la variable booléenne </font></font><code>playerOnMark</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">change la valeur en </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour calculer la distance entre le joueur et la marque, nous avons utilisé ce qui suit: la distance entre le joueur et sa marque, similaire </font></font><code>(mark.position - player.position)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, pour déterminer si le caractère AI est proche du cube, nous calculons la même équation en calculant la distance entre l'IA et le cube. De plus, nous avons complété le code avec des positions sur les deux marques (joueur et cube):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearCube;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> cubeIsNear;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
   Vector3 playerMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.2f</span>, <span class="hljs-number">32.6f</span>, <span class="hljs-number">-31.3f</span>);<font></font>
   Vector3 cubeMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.9f</span>, <span class="hljs-number">-8.3f</span>, <span class="hljs-number">-2.94f</span>);<font></font>
   nearValue = <span class="hljs-number">0.5f</span>;<font></font>
   nearCube = <span class="hljs-number">0.5f</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  {<font></font>
     playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  cubeProximityX = currentCubePosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  cubeProximityY = currentCubePosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>((cubeProximityX + cubeProximityY) &lt; nearCube)<font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant que notre personnage IA sait s'il est à côté du cube, cela nous permet de répondre à la question et de déterminer s'il peut passer à la branche suivante que nous avons planifiée. </font><font style="vertical-align: inherit;">Mais que se passe-t-il lorsque le personnage n'est pas à côté du cube? </font><font style="vertical-align: inherit;">Il devra s'approcher du cube. </font><font style="vertical-align: inherit;">Par conséquent, nous ajouterons ceci au code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform cubeMesh;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearCube;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> cubeIsNear;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> Finding;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
   Vector3 playerMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.2f</span>, <span class="hljs-number">32.6f</span>, <span class="hljs-number">-31.3f</span>);<font></font>
   Vector3 cubeMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.9f</span>, <span class="hljs-number">-8.3f</span>, <span class="hljs-number">-2.94f</span>);<font></font>
   nearValue = <span class="hljs-number">0.5f</span>;<font></font>
   nearCube = <span class="hljs-number">0.5f</span>;<font></font>
   speed = <span class="hljs-number">1.3f</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  { <font></font>
      playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  cubeProximityX = currentCubePosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  cubeProximityY = currentCubePosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>((cubeProximityX + cubeProximityY) &lt; nearCube)<font></font>
  {<font></font>
      cubeIsNear = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
      cubeIsNear = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">false</span> &amp;&amp; Finding == <span class="hljs-literal">false</span>)<font></font>
  {<font></font>
     PositionChanging();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">true</span>)<font></font>
  {<font></font>
     Finding = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PositionChanging</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  Finding = <span class="hljs-literal">true</span>;<font></font>
  Vector3 positionA = <span class="hljs-keyword">this</span>.transform.position;<font></font>
  Vector3 positionB = cubeMesh.transform.position;<font></font>
  <span class="hljs-keyword">this</span>.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jusqu'à présent, notre personnage AI est capable de calculer la distance entre lui et le cube; </font><font style="vertical-align: inherit;">s'ils sont trop éloignés, alors il ira au cube. </font><font style="vertical-align: inherit;">Après avoir terminé cette tâche, il peut passer à la phase suivante et commencer à pousser le cube. </font><font style="vertical-align: inherit;">La dernière chose dont il a besoin pour calculer est la distance entre le cube et la position de la marque, après quoi il décide de quelle direction pousser, en tenant compte de quel côté du cube la marque est la plus proche.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de1/be5/bf7/de1be5bf7e65540dfaeb6ab186a8e3c8.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le cube ne peut être poussé que le long des axes X et Z, et sa rotation n'est pas encore importante pour nous, car le bouton est activé lorsque le cube est installé dessus. Compte tenu de tout cela, le personnage AI doit calculer la distance entre le cube et la position de la marque en X et la position de la marque en Z. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, il compare les deux valeurs sur deux axes et sélectionne celle qui est la plus éloignée de la position souhaitée, puis commence à pousser le long de cette axe. Le personnage continuera à pousser dans cette direction jusqu'à ce que le cube soit aligné avec la position de la marque, puis passe de l'autre côté, et le poussera jusqu'à ce qu'il soit complètement au-dessus de la position de la marque:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform cubeMesh;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearCube;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeMarkProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeMarkProximityZ;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> cubeIsNear;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> Finding;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        Vector3 playerMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.2f</span>, <span class="hljs-number">32.6f</span>, <span class="hljs-number">-31.3f</span>);<font></font>
        Vector3 cubeMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.9f</span>, <span class="hljs-number">-8.3f</span>, <span class="hljs-number">-2.94f</span>);<font></font>
        nearValue = <span class="hljs-number">0.5f</span>;<font></font>
        nearCube = <span class="hljs-number">0.5f</span>;<font></font>
        speed = <span class="hljs-number">1.3f</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  {<font></font>
     playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  cubeProximityX = currentCubePosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  cubeProximityY = currentCubePosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>((cubeProximityX + cubeProximityY) &lt; nearCube)<font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">false</span> &amp;&amp; Finding == <span class="hljs-literal">false</span>)<font></font>
  {<font></font>
      PositionChanging();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">true</span>)<font></font>
  {<font></font>
      Finding = <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
   cubeMarkProximityX = cubeMark.transform.position.x - currentCubePosition.transform.position.x;<font></font>
   cubeMarkProximityZ = cubeMark.transform.position.z - currentCubePosition.transform.position.z;<font></font>
<font></font>
   <span class="hljs-keyword">if</span>(cubeMarkProximityX &gt; cubeMarkProximityZ)<font></font>
   {<font></font>
     PushX();<font></font>
   }<font></font>
<font></font>
   <span class="hljs-keyword">if</span>(cubeMarkProximityX &lt; cubeMarkProximityZ)<font></font>
   {<font></font>
     PushZ();<font></font>
   }<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PositionChanging</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  Finding = <span class="hljs-literal">true</span>;<font></font>
  Vector3 positionA = <span class="hljs-keyword">this</span>.transform.position;<font></font>
  Vector3 positionB = cubeMesh.transform.position;<font></font>
  <span class="hljs-keyword">this</span>.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir ajouté les dernières actions au code, le personnage doit apprendre à déterminer son objectif, trouver et pousser le cube à la position souhaitée afin que le joueur puisse passer et terminer le niveau. </font><font style="vertical-align: inherit;">Dans cet exemple, nous nous sommes concentrés sur la façon de calculer les distances entre les objets de scène et les personnages. </font><font style="vertical-align: inherit;">Cela nous aidera à créer des types d'interactions similaires dans lesquels nous devons placer l'objet de jeu dans une certaine position. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'exemple montre un personnage IA amical qui aide le joueur, mais les mêmes principes peuvent être appliqués si nous avons besoin de l'effet inverse (si le personnage est un ennemi), dans lequel le personnage doit trouver le cube le plus tôt possible pour arrêter le joueur.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obstacles dans des environnements utilisant l'exemple d'Age of Empires</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme nous l'avons vu précédemment, vous pouvez utiliser ou déplacer des objets dans le jeu pour atteindre des objectifs, mais que se passe-t-il si un objet obstrue le chemin du personnage? L'objet peut être placé par le joueur ou simplement localisé par le concepteur à cette position de la carte. Dans tous les cas, le personnage IA devrait être capable de déterminer ce qui doit être fait dans cette situation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons observer ce comportement, par exemple, dans une stratégie appelée Age of Empires II développée par Ensemble Studios. Chaque fois qu'un personnage de jeu ne peut pas atteindre le territoire ennemi en raison du fait qu'il est entouré de murs fortifiés, l'IA passe à la destruction d'une partie du mur pour continuer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce type d'interaction est également très intelligent et important, car sinon les personnages se promèneraient le long du mur à la recherche d'une entrée, et cela ne ressemblerait pas à un comportement raisonnable. </font><font style="vertical-align: inherit;">Puisque le mur renforcé est créé par le joueur, il peut être placé n'importe où et avoir n'importe quelle forme. </font><font style="vertical-align: inherit;">Par conséquent, vous devez y penser lorsque vous développez une IA ennemie.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/137/655/f44137655e3220988033bcb97db85b96.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet exemple se rapporte également au sujet de notre article, car au stade de la planification, lorsque nous créons des arbres de comportement, nous devons réfléchir à ce qui se passera si quelque chose gêne le personnage et qu'il ne peut pas atteindre ses objectifs. </font><font style="vertical-align: inherit;">Nous examinerons cet aspect en détail dans les chapitres suivants du livre, mais pour l'instant nous simplifions la situation et analysons comment le personnage de l'IA devrait se comporter si l'objet d'environnement l'empêche d'atteindre son objectif.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfb/464/89b/dfb46489b482f383bc95662246308536.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre exemple, le personnage de l'IA doit entrer dans la maison, mais lorsqu'il s'approche, il se rend compte qu'il est entouré d'une clôture en bois, à travers laquelle vous ne pouvez pas passer. Nous voulons que le personnage choisisse une cible à ce stade et commence à attaquer jusqu'à ce que cette partie de la clôture soit détruite et qu'il puisse entrer dans la maison. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet exemple, nous devons calculer quelle clôture le personnage doit attaquer, compte tenu de la distance et de l'état de santé actuel de la clôture. Une clôture avec des HP bas devrait avoir une priorité d'attaque plus élevée qu'une clôture avec des HP complets, donc nous en tiendrons compte dans nos calculs.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/223/23f/ac4/22323fac4373a3556b58383bfb6b36fe.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous voulons définir le voisinage autour du personnage, dans lequel les clôtures les plus proches transmettent leurs informations à l'intelligence artificielle afin qu'elle puisse décider laquelle est plus facile à détruire. Cela peut être mis en œuvre de différentes manières, soit en utilisant la reconnaissance des collisions de clôtures avec le joueur, soit en les forçant à calculer la distance entre les clôtures / objets et le joueur; nous définissons la valeur de la distance à laquelle le joueur commence à percevoir l'état de la clôture. Dans notre exemple, nous allons calculer la distance et l'utiliser pour informer le personnage des clôtures HP. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons par créer le code qui sera appliqué à l'objet fence; tous auront le même script:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> HP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> distanceValue;
<span class="hljs-keyword">private</span> Transform characterPosition;
<span class="hljs-keyword">private</span> GameObject characterMesh;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-comment">// Use this for initialization</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  HP = <span class="hljs-number">100f</span>;<font></font>
  distanceValue = <span class="hljs-number">1.5f</span>;<font></font>
<font></font>
  <span class="hljs-comment">// Find the Character Mesh</span>
  characterMesh = GameObject.Find(<span class="hljs-string">"AICharacter"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Update is called once per frame</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Obtain the Character Mesh Position</span><font></font>
  characterPosition = characterMesh.transform;<font></font>
<font></font>
  <span class="hljs-comment">//Calculate the distance between this object and the AI Character</span>
  proximityValueX = characterPosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  proximityValueY = characterPosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  nearValue = proximityValueX + proximityValueY;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce script, nous avons ajouté des informations de base sur les HP et les distances, qui seront utilisées pour se connecter avec le personnage AI. Cette fois, nous ajoutons le script de calcul de distance non pas au personnage, mais aux objets d'environnement; cela donne à l'objet plus de dynamisme et nous permet de créer plus d'opportunités. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, si les personnages du jeu participent également à la création de clôtures, ils auront alors des états différents, par exemple, «en construction», «terminé» ou «endommagé»; le personnage pourra alors recevoir ces informations et les utiliser à ses propres fins.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Définissons le personnage interagissant avec l'objet environnement. Son objectif principal sera d'accéder à la maison, mais lorsqu'il s'en approche, il se rend compte qu'il ne peut pas entrer à l'intérieur du fait qu'il est entouré de clôtures en bois. Nous voulons qu'après avoir analysé la situation, notre personnage détruise la clôture pour atteindre son objectif et entrer dans la maison. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le script de caractère, nous ajouterons une fonction statique à l'entrée dont les clôtures pourront transmettre des informations sur leur «santé» actuelle; cela aidera le personnage à choisir la clôture la plus appropriée pour la destruction.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> fenceHP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> lowerFenceHP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> fencesAnalyzed;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameObject bestFence;<font></font>
<font></font>
<span class="hljs-keyword">private</span> Transform House;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> timeWasted;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;<font></font>
<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        fenceHP = <span class="hljs-number">100f</span>;<font></font>
        lowerFenceHP = fenceHP;<font></font>
        fencesAnalyzed = <span class="hljs-number">0</span>;<font></font>
        speed = <span class="hljs-number">0.8</span>;<font></font>
<font></font>
        Vector3 House = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">300.2f</span>, <span class="hljs-number">83.3f</span>, <span class="hljs-number">-13.3f</span>);<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        timeWasted += Time.deltaTime;<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(fenceHP &gt; lowerFenceHP)<font></font>
        {<font></font>
            lowerFenceHP = fenceHP;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(timeWasted &gt; <span class="hljs-number">30f</span>)<font></font>
        {<font></font>
            GoToFence();  <font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GoToFence</span><span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        Vector3 positionA = <span class="hljs-keyword">this</span>.transform.position;<font></font>
        Vector3 positionB = bestFence.transform.position;<font></font>
        <span class="hljs-keyword">this</span>.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/970/af0/7a8970af0c9b5aa303ba32d6dc021ec8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons déjà ajouté les informations les plus élémentaires au personnage. </font></font><code>fenceHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sera une variable statique dans laquelle chaque clôture qui se situe dans le rayon du voisinage du personnage enregistrera des informations sur le HP actuel. Ensuite, le personnage de l'IA analyse les informations reçues et les compare avec la clôture avec le moins de HP présenté </font></font><code>lowerFenceHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le personnage a une variable </font></font><code>timeWasted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">représentant le nombre de secondes qu'il a déjà passé à chercher une clôture appropriée à détruire. </font></font><code>fencesAnalyzed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sera utilisé pour savoir s'il y a déjà une clôture dans le code, et sinon, la première clôture trouvée par le personnage est ajoutée; si les clôtures ont la même valeur de PV, le personnage les attaque en premier. Ajoutons maintenant le code des clôtures afin qu'elles puissent accéder au script du personnage et entrer des informations utiles.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> HP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> distanceValue;
<span class="hljs-keyword">private</span> Transform characterPosition;
<span class="hljs-keyword">private</span> GameObject characterMesh;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> nearValue;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        HP = <span class="hljs-number">100f</span>;<font></font>
        distanceValue = <span class="hljs-number">1.5f</span>;<font></font>
<font></font>
        <span class="hljs-comment">// Find the Character Mesh</span>
        characterMesh = GameObject.Find(<span class="hljs-string">"AICharacter"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        <span class="hljs-comment">// Obtain the Character Mesh Position</span><font></font>
        characterPosition = characterMesh.transform;<font></font>
<font></font>
        <span class="hljs-comment">//Calculate the distance between this object and the AI Character</span>
        proximityValueX = characterPosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
        proximityValueY = characterPosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
        nearValue = proximityValueX + proximityValueY;<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(nearValue &lt;= distanceValue){
            <span class="hljs-keyword">if</span>(AICharacter.fencesAnalyzed == <span class="hljs-number">0</span>){<font></font>
                AICharacter.fencesAnalyzed = <span class="hljs-number">1</span>;<font></font>
                AICharacter.bestFence = <span class="hljs-keyword">this</span>.gameObject;<font></font>
            }<font></font>
<font></font>
            AICharacter.fenceHP = HP;<font></font>
<font></font>
            <span class="hljs-keyword">if</span>(HP &lt; AICharacter.lowerFenceHP){<font></font>
                AICharacter.bestFence = <span class="hljs-keyword">this</span>.gameObject;<font></font>
            }<font></font>
        }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons finalement terminé cet exemple. </font><font style="vertical-align: inherit;">Maintenant, la clôture compare ses HP actuels avec les données du personnage ( </font></font><code>lowerFenceHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), et si ses HP sont inférieurs à la valeur la plus basse du personnage, alors cette clôture sera considérée </font></font><code>bestFence</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet exemple montre comment adapter un personnage IA à divers objets dynamiques du jeu; </font><font style="vertical-align: inherit;">le même principe peut être étendu et utilisé pour interagir avec presque n'importe quel objet. </font><font style="vertical-align: inherit;">Il est également applicable et utile lors de l'utilisation d'objets pour interagir avec un personnage, en reliant des informations entre eux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, nous avons exploré différentes façons d'interagir avec l'environnement. </font><font style="vertical-align: inherit;">Les techniques présentées dans ce chapitre peuvent être étendues à de nombreux genres de jeux différents et utilisées pour effectuer des interactions simples et complexes entre les personnages de l'IA et l'environnement.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr496046/index.html">Graphiques 3D sur le STM32F103</a></li>
<li><a href="../fr496050/index.html">Des tigres et des lions contractent un coronavirus à New York</a></li>
<li><a href="../fr496052/index.html">Comment une entreprise de services peut-elle éviter des amendes à un client? Quelques avantages évidents de l'automatisation des processus</a></li>
<li><a href="../fr496056/index.html">Numérique: comment les chiffres et les termes nous trompent</a></li>
<li><a href="../fr496058/index.html">Pourquoi est-il nécessaire de combiner des robots agricoles, quelles sont les difficultés et comment nous l'avons fait en deux ans</a></li>
<li><a href="../fr496082/index.html">Ingénieur et Data Scientist: quelle est la différence?</a></li>
<li><a href="../fr496084/index.html">Boutique en ligne côté client Blazor: Partie 6 - Création d'une commande et utilisation des actions compensatoires</a></li>
<li><a href="../fr496086/index.html">Organisation du travail à distance avec les travaux numériques Zextras</a></li>
<li><a href="../fr496088/index.html">21 avril en direct! Meetup de localisation de Badoo</a></li>
<li><a href="../fr496090/index.html">Supprimé avec Zyxel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>