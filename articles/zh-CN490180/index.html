<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔳 🧒🏽 🖼️ Kubernetes存储模式 👩🏼‍🤝‍👨🏿 🚈 ✊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！
 
 我们提醒您，我们已经发布了另一本关于Kubernetes模式的非常有趣和有用的书。一切始于布伦丹·伯恩斯（Brendan Burns）的“ 模式 ”，顺便说一下，这一部分的工作正在紧锣密鼓地进行。今天，我们邀请您阅读MinIO博客上的一篇文章，其中概述了Kubernetes中数据存储...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kubernetes存储模式</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/490180/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ku/xh/fw/kuxhfwyrk51o4xpq6d1km-gpfbg.png"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
哈Ha！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们提醒您，我们已经发布了另一</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于Kubernetes模式的</font><font style="vertical-align: inherit;">非常有趣和有用的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">书</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">一切始于</font><font style="vertical-align: inherit;">布伦丹·伯恩斯（Brendan Burns）的</font><font style="vertical-align: inherit;">“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”，顺便说一下，这一部分的工作正在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">紧锣密鼓地进行</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">今天，我们邀请您阅读MinIO博客上的一篇文章，其中概述了Kubernetes中数据存储模式的趋势和细节。</font></font><br>
<a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes从根本上改变了应用程序开发和部署的传统模式。</font><font style="vertical-align: inherit;">现在，团队可以花几天时间在不同的环境中以及Kubernetes集群中的所有环境中开发，测试和部署应用程序。</font><font style="vertical-align: inherit;">使用前几代技术进行的这种工作通常要花费数周，甚至数月。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
得益于Kubernetes提供的抽象，这样的加速才有可能实现-也就是说，由于Kubernetes本身与物理或虚拟机的低级详细信息进行交互，允许用户在其他参数中声明所需的处理器，所需的内存以及容器实例的数量。由于Kubernetes受到庞大社区的支持，并且Kubernetes的范围不断扩大，因此在所有容器编排平台中都有很大的领先优势。</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随着Kubernetes的用途扩展，对其使用的存储模式的困惑也随之增加</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在争夺Kubernetes馅饼（即用于数据存储）方面的普遍竞争中，当谈到数据存储时，信号淹没在嘈杂的噪音中。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes体现了用于开发，部署和管理应用程序的现代模型。这种现代模型将数据存储与计算分离。为了在Kubernetes的上下文中完全理解这种分离，您还需要了解什么是有状态和无状态应用程序，以及如何将数据存储与此相结合。与其他解决方案中常见的POSIX / CSI方法相比，S3使用的REST API方法具有明显的优势。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我们将讨论Kubernetes中的存储模式，并将分别讨论关于状态安全和无状态应用程序的辩论，以便我们可以清楚地了解它们之间的区别以及它为何重要。</font><font style="vertical-align: inherit;">在本文的进一步内容中，我们将根据与容器和Kubernetes一起使用的最佳实践来考虑应用程序和其中使用的数据存储模式。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无状态容器</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
容器本质上是轻便的和短暂的。</font><font style="vertical-align: inherit;">它们可以轻松地停止，删除或部署在另一个节点上-所有这些仅需几秒钟。</font><font style="vertical-align: inherit;">在大型容器编排系统中，此类操作始终发生，并且用户甚至没有注意到这种更改。</font><font style="vertical-align: inherit;">但是，只有在容器不依赖于其所在节点的情况下，才可以移动。</font><font style="vertical-align: inherit;">据说这些容器在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有状态保存的情况下</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工作</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有状态的容器</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果容器将数据存储在本地连接的设备（或块设备）上，则必须将其所在的数据仓库连同容器本身一起移至新节点，以防发生故障。这很重要，因为否则容器中运行的应用程序将无法正常运行，因为它需要访问存储在本地媒体上的数据。据说这些容器是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有状态的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从纯粹的技术角度来看，有状态容器也可以移动到其他节点。通常，这是通过使用分布式文件系统或阻止连接到容器在其上运行的所有节点的网络存储来实现的。因此，容器可以访问卷以进行持久数据存储，并且信息存储在整个网络中的磁盘上。我将这种方法称为“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态保存容器方法</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”，在本文的其余部分中，为了统一起见，我将其称为</font><font style="vertical-align: inherit;">“ </font><i><font style="vertical-align: inherit;">状态保存容器方法</font></i><font style="vertical-align: inherit;"> ”。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y1/cs/6z/y1cs6zoudpecfzs6ww-aw8ocxyg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在典型的有状态容器方法中，所有应用程序容器都连接到一个分布式文件系统-获得一种共享存储，在其中获取所有应用程序数据。</font><font style="vertical-align: inherit;">尽管可能会有一些变化，但这是一种高级方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在让我们看看为什么在基于云的世界中有状态容器方法是反模式的。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于云的应用程序设计</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
传统上，应用程序使用数据库来进行信息的结构化存储，并使用本地磁盘或分布式文件系统将所有非结构化甚至半结构化的数据转储到那里。随着非结构化数据量的增长，开发人员意识到POSIX太健谈了，带来了可观的成本，并且最终在大规模迁移时会干扰应用程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这主要是为数据存储新标准的出现做出了贡献，即基于云的存储主要基于REST API进行工作，并使应用程序摆脱了本地数据仓库繁重的维护工作。在这种情况下，应用程序实际上会进入操作模式而不保存状态（因为状态在远程存储中）。考虑到这一因素，从头开始构建现代应用程序。通常，任何处理一种或另一种数据（日志，元数据，blob等）的现代应用程序都是在面向云的范式上构建的，状态被转移到专门为其存储分配的软件系统中。</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有状态的容器方法使整个范例完全回滚到它开始的地方！</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
当使用POSIX接口存储数据时，应用程序的工作方式与维护状态相同，因此，它偏离了基于云的设计的最重要假设，即，根据传入的数据来更改应用程序工作流的大小的能力加载，在当前节点出现故障后立即移至新节点，依此类推。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仔细观察这种情况可以发现，在选择数据仓库时，我们一次又一次地面临“ POSIX与REST API”的难题，但由于Kubernetes环境的分布式性质而导致POSIX问题的加剧。特别是，</font></font><br>
<br>
<ul>
<li><b>POSIX </b>:  POSIX         ,     .     ,     . API   ,  , S3 API,    ,   ,   «»  .     ,       .        .</li>
<li><b> </b>:    ,     ,          . ,  ,            (    ),         ,     . -  POSIX       .   , S3 API       ,      ,  ,     .</li>
<li><b></b>:   POSIX     :          .      - .      ,   API,       ,   ,     ..</li>
<li><b></b>:       ,   .       ,    ,     ,      .  ,     ,      ,   .</li>
</ul><br>
<h4>   </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
容器数据存储接口（CSI）在Kubernetes卷级别的分配方面起到了很大作用，部分将其传递给了第三方数据仓库供应商，但也无意中促成了人们坚信有状态容器方法是Kubernetes中推荐的数据存储方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CSI被开发为在使用Kubernetes时为旧版应用程序提供任意块和文件存储系统的标准。而且，如本文所示，只有在应用程序本身是无法添加对对象数据存储API的支持的旧有系统时，才是有状态容器方法（以及当前形式的CSI）才是合适的情况。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要的是要理解，以当前形式使用CSI，即在使用现代应用程序安装卷时，我们将遇到与以POSIX样式组织数据存储的系统中几乎相同的问题。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更好的方法</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，重要的是要了解，大多数应用程序固有地不会针对具有状态保留或不具有状态保留的工作而进行特定处理。</font><font style="vertical-align: inherit;">此行为取决于系统的整体体系结构以及设计期间选择的特定选项。</font><font style="vertical-align: inherit;">让我们谈谈有状态应用程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原则上，所有应用程序数据都可以分为几种类型：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记录数据</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间戳数据</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交易数据</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元数据</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">容器图片</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blob数据（斑点）</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有这些数据类型在现代数据存储平台上都得到了很好的支持，并且有几种基于云的平台适合于以每种特定格式交付数据。例如，交易数据和元数据可以驻留在现代的基于云的数据库中，例如CockroachDB，YugaByte等。可以基于MinIO将容器映像或Blob数据存储在Docker注册表中。时间戳数据可以存储在时间序列数据库中，例如InfluxDB等。我们不会详细介绍每种类型的数据和相关应用程序，但总体思路是避免基于本地磁盘安装的持久性数据存储。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/us/gk/li/usgklihtry8ddkgmpkumtziiv3y.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，提供临时缓存层通常很有效，该层用作应用程序的一种临时文件存储，但是应用程序不应依赖此级别作为事实来源。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有状态的应用程序存储</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管在大多数情况下使应用程序保持无状态是有用的，但那些旨在存储数据的应用程序（例如数据库，对象存储，键和值存储）应保持状态。</font><font style="vertical-align: inherit;">让我们看看为什么将这些应用程序部署到Kubernetes。</font><font style="vertical-align: inherit;">以MinIO为例，但是类似的原理也适用于任何其他大型的基于云的存储系统。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以云为中心的应用程序旨在最大程度地利用容器固有的灵活性。这意味着他们对部署环境不做任何假设。例如，MinIO使用内部擦除编码机制，该机制为系统提供了足够的稳定性，因此即使一半的驱动器发生故障，它也可以正常运行。 MinIO还使用其自己的服务器端哈希和加密来管理数据完整性和安全性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于此类基于云的应用程序，本地永久卷（PV）最方便用作备份存储。</font><font style="vertical-align: inherit;">本地PV提供了存储原始数据的能力，而在这些PV之上运行的应用程序则独立收集信息以扩展数据并管理不断增长的数据需求。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与基于CSI的PV相比，这种方法简单得多，并且可扩展性明显更好，后者为系统带来了自己的数据管理和冗余级别。</font><font style="vertical-align: inherit;">事实是，这些级别通常与根据状态保存原理设计的应用程序冲突。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从计算中释放数据的信心运动</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我们讨论了如何在不保存状态的情况下重新定向应用程序以使其工作，换句话说，数据存储在它们上进行了计算限制。总之，我们考虑了这种趋势的一些实际例子。</font><font style="vertical-align: inherit;">传统上，著名的数据分析平台</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已用于状态部署和部署到HDFS文件系统。但是，随着Spark过渡到基于云的世界时，越来越多地使用该平台而不使用`s3a'进行状态保存。 Spark使用s3a将状态传输到其他系统，而Spark容器本身完全在不保存状态的情况下工作。大数据分析领域的其他大型企业参与者，特别是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertica</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teradata</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Greenplum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还致力于数据存储和计算的划分。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在其他大型分析平台上也可以看到类似的模式，包括Presto，Tensorflow到R，Jupyter。</font><font style="vertical-align: inherit;">将状态上传到远程云存储系统可以更轻松地管理和扩展您的应用程序。</font><font style="vertical-align: inherit;">此外，它有助于将应用程序移植到各种环境。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN490164/index.html">立即采访软件工程师Sony PlayStation。内部厨房，职能团队，核心部门</a></li>
<li><a href="../zh-CN490168/index.html">IBM Watson Assistant中的聊天机器人质量分析</a></li>
<li><a href="../zh-CN490170/index.html">副项目经理。为什么这样以及如何处理</a></li>
<li><a href="../zh-CN490174/index.html">Kubernetes中的DNS查找</a></li>
<li><a href="../zh-CN490178/index.html">当每个人都向西走时，我搬到了亚美尼亚</a></li>
<li><a href="../zh-CN490184/index.html">Alphabet有第二个秘密的量子计算机开发人员小组</a></li>
<li><a href="../zh-CN490186/index.html">我们从JET BI获得的东西。没有歌词的建筑商务智能系统</a></li>
<li><a href="../zh-CN490190/index.html">我将进行搜索：以Binance加密货币交换为例，通过IP地址在全球互联网中托管主机</a></li>
<li><a href="../zh-CN490194/index.html">将RabbitMQ与MonsterMQ结合使用第4部分</a></li>
<li><a href="../zh-CN490196/index.html">[Flipper Zero]拒绝Raspberry Pi，从头开始制作我们自己的板子。寻找合适的WiFi芯片</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>