<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☸️ 👩🏻‍🤝‍👨🏾 👨🏿‍🎤 最先端の不変のデータ構造 🐷 🤷🏾 🕵🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="長年、C ++の専門家は、値のセマンティクス、不変性、および通信によるリソース共有について議論してきました。ミューテックスとレースのない、コマンドとオブザーバーのパターンのない新しい世界について。実際、すべてがそれほど単純ではありません。主な問題はまだデータ構造にあります。
 
 
 
 不変のデー...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>最先端の不変のデータ構造</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/487100/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長年、C ++の専門家は、値のセマンティクス、不変性、および通信によるリソース共有について議論してきました。</font><font style="vertical-align: inherit;">ミューテックスとレースのない、コマンドとオブザーバーのパターンのない新しい世界について。</font><font style="vertical-align: inherit;">実際、すべてがそれほど単純ではありません。</font><font style="vertical-align: inherit;">主な問題はまだデータ構造にあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6o/pu/18/6opu18ei6gi5dbo8dvcsgopyebq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不変のデータ構造はその値を変更しません。それらで何かを行うには、新しい値を作成する必要があります。古い値は同じ場所に残るため、問題やロックなしで異なるストリームから読み取ることができます。その結果、古い値と新しい値で共通のデータを使用できるため、リソースをより合理的かつ秩序立って共有できます。これにより、相互の比較がはるかに速くなり、キャンセルの可能性がある操作の履歴をコンパクトに保存できます。これらすべては、マルチスレッドおよびインタラクティブシステムに完全に適合します。このようなデータ構造は、デスクトップアプリケーションのアーキテクチャを簡素化し、サービスの拡張を可能にします。不変構造はClojureとScalaの成功の秘訣です。Immutable.jsライブラリーがあるため、JavaScriptコミュニティでさえもそれらを利用しています。Facebookの会社の腸に書かれました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カット</font><font style="vertical-align: inherit;">-C ++ロシア2019モスクワ会議からの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フアンプエンテ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レポートのビデオと翻訳</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">フアンは</font><font style="vertical-align: inherit;">、C ++の不変構造のライブラリである</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について話し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">ポストで：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">免疫のアーキテクチャ上の利点;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RRBツリーに基づく効果的な永続的ベクトルタイプの作成。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単純なテキストエディタの例に関するアーキテクチャの分析。</font></font></li>
</ul><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/dbFfpTp3EhA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">価値ベースのアーキテクチャの悲劇</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不変のデータ構造の重要性を理解するために、値のセマンティクスについて説明します。これはC ++の非常に重要な機能です。この言語の主な利点の1つと考えています。これらすべてのために、私たちが望むように値のセマンティクスを使用することは非常に困難です。これは価値に基づく建築の悲劇であり、この悲劇への道は善意で舗装されていると思います。ユーザーが編集可能なドキュメントの表現を持つデータモデルに基づいてインタラクティブソフトウェアを作成する必要があるとします。このモデルの心臓部での値に基づくアーキテクチャは、すでに言語に存在する値の簡単で便利なタイプを使用する場合：</font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>tuple</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。アプリケーションロジックは、ドキュメントを値で受け取り、ドキュメントの新しいバージョンを値で返す関数から作成されます。このドキュメントは関数内で変更される可能性があります（以下で発生します）が、値ごとに引数に適用され、値ごとに戻り型に適用されるC ++の値のセマンティクスは、副作用がないことを確認します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fh/7e/0y/fh7e0ybdwuqnh3iona30quev4ja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この機能は、分析とテストが非常に簡単です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cb/5c/4x/cb5c4xq-hps1x76mn-fmweshklu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
値を操作しているので、アクションの取り消しを実装しようとします。これは難しい場合がありますが、私たちのアプローチではそれは取るに足らない作業です。</font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なる状態では、ドキュメントのさまざまなコピー</font><font style="vertical-align: inherit;">を持っ</font><font style="vertical-align: inherit;">ています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d-/vh/nd/d-vhndh9j8leugdcjoyf3b4yhqq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、UIがあり、その応答性を保証するために、UIのマッピングを別のスレッドで行う必要があるとします。ドキュメントはメッセージによって別のストリームに送信され、対話は、を使用し</font></font><code>mutexes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">た</font><font style="vertical-align: inherit;">状態の共有ではなく、メッセージに基づいて行われます</font><font style="vertical-align: inherit;">。コピーが2番目のストリームで受信されると、必要なすべての操作を実行できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/to/xx/kc/toxxkcwck44iayev1hywf-wqllk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特にドキュメントが大きい場合、ドキュメントをディスクに保存するのに非常に時間がかかることがよくあります。したがって、</font></font><code>std::async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この操作の</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">は非同期で実行されます。ラムダを使用し、その中に等号を入れてコピーを作成します。これで、他のプリミティブタイプの同期なしで保存できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ve/ey/jj/veeyjjijubbrc49-ghusxnuft4e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、サウンド制御フローもあるとします。私が言ったように、私は音楽ソフトウェアで多くのことをしました、そして音は私たちの文書の別の表現です、それは別のストリームにあるに違いありません。したがって、このストリームにはドキュメントのコピーも必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、非常に美しく、しかし現実的ではないスキームを得ました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dj/w2/hu/djw2hu7q55lbi2nmgmwok1i_cb0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
常にドキュメントをコピーする必要があり、キャンセルのアクション履歴には数ギガバイトかかります。UIをレンダリングするたびに、ドキュメントの深いコピーを作成する必要があります。一般に、すべてのやり取りはコストがかかりすぎます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uq/sv/8-/uqsv8-sx3hphtcm9wvozi1z83fs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況でC ++開発者は何をしていますか？値でドキュメントを受け入れる代わりに、アプリケーションロジックはドキュメントへのリンクを受け入れ、必要に応じて更新します。この場合、何も返す必要はありません。しかし、今は値ではなく、オブジェクトと場所を扱っています。これにより、新しい問題が発生します</font></font><code>mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">アクセスを共有している状態へのリンクがある場合は、それが必要</font><font style="vertical-align: inherit;">です。これは非常にコストがかかるため、さまざまなウィジェットからの非常に複雑なツリーの形でUIが表現されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの要素はすべて、ドキュメントが変更されたときに更新を受け取る必要があるため、変更信号にはいくつかのキューイングメカニズムが必要です。さらに、ドキュメントの履歴は一連の状態ではなく、Teamパターンの実装になります。この操作は、一方向と反対方向の2回実装する必要があり、すべてが対称的であることを確認します。別のスレッドに保存することはすでに非常に困難であるため、これは破棄する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dl/lr/sj/dllrsjhkvqxxckjx1r69lflqck4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーは砂時計の画像に既に慣れているので、少し待ってもかまいません。もう1つは恐ろしいことです。パスタモンスターがコードを支配するようになりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが下り坂になったのはいつですか。</font><font style="vertical-align: inherit;">私たちはコードを非常にうまく設計しましたが、コピーのために妥協する必要がありました。</font><font style="vertical-align: inherit;">ただし、C ++では、変更可能なデータの場合にのみ値による受け渡しを行うためにコピーが必要です。</font><font style="vertical-align: inherit;">オブジェクトが不変の場合、代入演算子を実装して、ポインターのみを内部表現にコピーし、それ以上はコピーしないようにすることができます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">const</span> auto v0 = vector&lt;<span class="hljs-keyword">int</span>&gt;{};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちを助けることができるデータ構造を検討してください。</font><font style="vertical-align: inherit;">以下のベクターでは、すべてのメソッドがとしてマークされている</font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため、不変です。</font><font style="vertical-align: inherit;">実行時に</font></font><code>.push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ベクターは更新されず、代わりに、転送されたデータが追加される新しいベクターが返されます。</font><font style="vertical-align: inherit;">残念ながら、この方法では角括弧を定義できません。</font><font style="vertical-align: inherit;">代わりに、関数を使用できます</font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新されたアイテムを含む新しいバージョンを返します。これで、データ構造に、関数型プログラミングの永続性と呼ばれるプロパティが追加されました。これは、このデータ構造をハードドライブに保存するのではなく、更新時に古いコンテンツが削除されないという事実です。代わりに、私たちの世界の新しいフォーク、つまり構造が作成されます。これのおかげで、過去の値と現在の値を比較できます-これは2つの助けを借りて行われ</font></font><code>assert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">const</span> auto v0 = vector&lt;<span class="hljs-keyword">int</span>&gt;{};
<span class="hljs-keyword">const</span> auto v1 = v0.push_back(<span class="hljs-number">15</span>);
<span class="hljs-keyword">const</span> auto v2 = v1.push_back(<span class="hljs-number">16</span>);
<span class="hljs-keyword">const</span> auto v3 = v2.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">42</span>);<font></font>
<font></font>
assert(v2.size() == v0.size() + <span class="hljs-number">2</span>);<font></font>
assert(v3[<span class="hljs-number">0</span>] - v1[<span class="hljs-number">0</span>] == <span class="hljs-number">27</span>);</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変更を直接確認できるようになり、データ構造の非表示のプロパティではなくなりました。この機能は、常にデータを変更する必要があるインタラクティブシステムで特に役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの重要な特性は、構造の共有です。ここでは、データ構造の新しいバージョンごとにすべてのデータをコピーしているわけではありません。でも持つ</font></font><code>.push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのデータがコピーされるわけではなく、その一部のみがコピーされます。私たちのすべてのフォークは、コピーの数ではなく変更の数に比例するコンパクトビューへの共通のアクセス権を持っています。また、比較が非常に高速であることもわかります。すべてが1つのメモリブロック、1つのポインタに格納されている場合、ポインタを比較し、それらが等しい場合は内部にある要素を調べることはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなベクトルは非常に便利なようですが、別のライブラリに実装しました。これは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イマーです</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -不変構造のライブラリ、オープンソースプロジェクトです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それを書くとき、私はその使用がC ++開発者になじみ深いものであることを望みました。</font><font style="vertical-align: inherit;">C ++で関数型プログラミングの概念を実装するライブラリは多数ありますが、開発者がC ++ではなくHaskell向けに作成しているような印象を与えます。</font><font style="vertical-align: inherit;">これは不便を生みます。</font><font style="vertical-align: inherit;">また、パフォーマンスも良好でした。</font><font style="vertical-align: inherit;">利用可能なリソースが限られている場合、人々はC ++を使用します。</font><font style="vertical-align: inherit;">最後に、ライブラリをカスタマイズ可能にしたかった。</font><font style="vertical-align: inherit;">この要件は、パフォーマンス要件に関連しています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">魔法のベクトルを求めて</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レポートの第2部では、この不変ベクトルがどのように構成されているかを検討します。このようなデータ構造の原理を理解する最も簡単な方法は、通常のリストから始めることです。関数型プログラミング（LispまたはHaskellを例として使用）に少し精通している場合は、リストが最も一般的な不変のデータ構造であることを知っています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rn/ou/d6/rnoud6a8vaqpet2jg-n18be85fk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、単一ノードのリストがあると仮定します</font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。リストの先頭に新しい要素を追加すると、新しいノードが作成され、各ノードには既存のノードへのポインターがあります。したがって、スライドの例では、1つのリストの3つのコピーではなく、メモリ内に3つの要素があります。つまり、</font></font><code>v1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これら</font></font><code>v0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は異なる要素</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bm/nf/bh/bmnfbhtdmbu_kdm_xlpuxleld2w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現実の分岐を作成することもできます。つまり、同じ終了であるが異なる開始を持つ新しいリストを作成します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなデータ構造は古くから研究されてきました。ChrisOkasakiは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">純粋関数型データ構造の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本的な著作を書きました</font><font style="vertical-align: inherit;">。さらに、Ralf HinzeとRoss Patersonによって提案された</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finger Tree</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ構造は非常に興味深いもの</font><font style="vertical-align: inherit;">です。しかし、C ++の場合、そのようなデータ構造はうまく機能しません。彼らは小さなノードを使用しており、C ++では小さなノードはキャッシング効率の欠如を意味することがわかっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、C ++にはない遅延などのプロパティに依存することがよくあります。したがって、不変のデータ構造に関するPhil Bagwellの作業は</font><font style="vertical-align: inherit;">、2000年代初頭に作成され</font><font style="vertical-align: inherit;">た</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とRich Hickeyの作業- </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">リンクの</font></a><font style="vertical-align: inherit;">ほうがはるかに便利です。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Clojureの作者。 Rich Hickeyはリストを作成しましたが、これは実際にはリストではありませんが、最新のデータ構造（ベクトルとハッシュマップ）に基づいています。これらのデータ構造はキャッシング効率があり、小さなノードで作業することは望ましくない最新のプロセッサとうまく相互作用します。このような構造はC ++で使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
免疫ベクターを構築するには？構造の中心には、たとえリモートでベクトルに似ていても、配列が必要です。ただし、アレイには構造的な共有はありません。配列の要素を変更するには、永続性プロパティを失うことなく、配列全体をコピーする必要があります。これを行わないようにするために、配列を個別の部分に分割できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、ベクター要素を更新するときに、ベクター全体ではなく、1つの部分のみをコピーする必要があります。しかし、そのような部分自体はデータ構造ではなく、何らかの方法で組み合わせる必要があります。それらを別の配列に入れます。繰り返しになりますが、配列が非常に大きくなる可能性があるという問題が発生し、それを再度コピーすると時間がかかりすぎます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この配列を分割し、別の配列に再度配置し、ルート配列が1つになるまでこの手順を繰り返します。結果の構造は残差ツリーと呼ばれます。このツリーは、定数M = 2B、つまり分岐係数で記述されます。この分岐インジケーターは2の累乗である必要があり、その理由はすぐにわかります。スライドの例では4文字のブロックを使用していますが、実際には32文字のブロックを使用しています。特定のアーキテクチャに最適なブロックサイズを見つけることができる実験があります。これにより、構造的な共有アクセスとアクセス時間の最適な比率を達成できます。ツリーが低いほど、アクセス時間は短くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを読んで、C ++で作成している開発者はおそらく考えます：しかし、ツリーベースの構造は非常に遅いです！ツリーは、その中の要素の数が増えると成長します。そのため、アクセス時間が低下します。それがプログラマーが好む理由</font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です</font></font><code>std::map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。私はあなたを安心させるために急ぎました：私たちの木は非常にゆっくりと成長します。 32ビットintのすべての可能な値を含むベクトルは、7レベルの高さしかありません。このデータサイズでは、キャッシュとロードボリュームの比率がツリーの深さよりもパフォーマンスに大きく影響することが実験的に示されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ツリーの要素へのアクセスがどのように実行されるかを見てみましょう。要素17に目を向ける必要があると仮定します。インデックスのバイナリ表現を取得し、それを分岐因子のサイズのグループに分割します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c1/gz/o1/c1gzo1qqm9pycpehqerzzkvwvwm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各グループでは、対応するバイナリ値を使用するため、ツリーを下っていきます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、このデータ構造に変更を加える必要があると仮定します</font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">つまり、メソッドを実行し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/l8/xi/3y/l8xi3yorosfghnwt9gmcijtk83a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、最初に要素が配置されているブロックをコピーしてから、要素への途中で各内部ノードをコピーする必要があります。一方では、かなりの量のデータをコピーする必要がありますが、同時にこのデータのかなりの部分が一般的であり、これによりボリュームが補正されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、私が説明したものと非常によく似た非常に古いデータ構造があります。これらは、ページテーブルツリーのあるメモリページです。彼女の管理も電話で行われます</font></font><code>fork</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ構造を改善してみましょう。 2つのベクトルを接続する必要があるとします。これまでに説明したデータ構造に</font></font><code>std::vector:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、右端に空のセル</font><font style="vertical-align: inherit;">があるのと同じ制限</font><font style="vertical-align: inherit;">があります。構造は完全にバランスが取れているため、これらの空のセルをツリーの中央に置くことはできません。したがって、最初のベクトルと組み合わせる2番目のベクトルがある場合、要素を空のセルにコピーする必要があります。これにより、2番目のベクトルに空のセルが作成され、最後に2番目のベクトル全体をコピーする必要があります。そのような演算は計算の複雑さO（n）を持ちます。ここで、nは2番目のベクトルのサイズです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より良い結果を目指します。緩和された基数バランスツリーと呼ばれるデータ構造の変更バージョンがあります。この構造では、左端のパス上にないノードには空のセルがある場合があります。したがって、このような不完全な（または緩和された）ノードでは、サブツリーのサイズを計算する必要があります。これで、複雑ですが対数結合操作を実行できます。この一定時間の複雑さの演算はO（log（32））です。木が浅いため、アクセス時間は比較的長くても一定です。このようなユニオン演算があるため、このデータ構造の緩和バージョンはコンフルエントと呼ばれます。永続的であることに加えて、2つの構造を1つに組み合わせることができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qr/rj/hz/qrrjhzfbr-22n0cdr-vvhke1pvq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでに扱った例では、データ構造は非常に巧妙ですが、実際には、Clojureと他の関数型言語の実装は異なって見えます。これらは各値のコンテナーを作成します。つまり、ベクターの各要素は個別のセルにあり、リーフノードにはこれらの要素へのポインターが含まれます。しかし、このアプローチは非常に非効率的です。C++では、通常、すべての値をコンテナーに入れません。したがって、これらの要素がノードに直接配置されている方が良いでしょう。次に、別の問題が発生します。異なる要素には異なるサイズがあります。要素がポインタと同じサイズの場合、構造は次のようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/78/s4/_k/78s4_kqqdc_fi8_ydkopktou0m4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、要素が大きい場合、シートの1つをコピーすると時間がかかるため、データ構造は測定したプロパティ（アクセス時間O（log（32）（））を失います。したがって、このデータ構造を変更して、サイズが大きくなるとその中に含まれる要素の数により、リーフノード内のこれらの要素の数が減少しました。逆に、要素が小さい場合は、それらをより適合させることができます。新しいバージョンのツリーは、組み込み基数平衡型ツリーと呼ばれます。1つの定数ではなく2つで記述されます。1つは内部ノードを表しますC ++でのツリー実装は、ポインタと要素自体のサイズに応じて、リーフ要素の最適なサイズを計算できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのツリーはすでにかなりうまく機能していますが、まだ改善することができます。関数に似た関数を見てみましょう</font></font><code>iota</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        v = v.push_back(i);<font></font>
    <span class="hljs-keyword">return</span> v;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、入力を受け取り</font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、実行</font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の間の各整数のためのベクトルの終わりに</font></font><code>first</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">及び</font></font><code>last</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そして何が起こったか戻ります。すべてはこの関数の正確さで整然としていますが、非効率的に機能します。各呼び出し</font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、左端のブロックを不必要にコピーします。次の呼び出しは別の要素をプッシュし、コピーが再度繰り返され、前のメソッドによってコピーされたデータは削除されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数の別の実装を試すことができます。この場合、関数内の永続性を放棄します。</font></font><code>transient vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常のAPIと互換性のある変更可能なAPIで</font><font style="vertical-align: inherit;">使用でき</font><font style="vertical-align: inherit;">ます</font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このような関数内では、呼び出し</font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ごとにデータ構造が変更されます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    auto t = v.transient();<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        t.push_back(i);<font></font>
    <span class="hljs-keyword">return</span> t.persistent();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この実装はより効率的で、正しいパスで新しい要素を再利用できます。関数の最後で、</font></font><code>.persistent()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immutableを返す</font><font style="vertical-align: inherit;">呼び出し</font><font style="vertical-align: inherit;">が行われます</font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。考えられる副作用は関数の外からは見えません。元</font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のデータは不変であり、不変のままです。関数内で作成されたデータのみが変更されます。すでに述べたように、このアプローチの重要な利点は</font></font><code>std::back_inserter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、変更可能なAPIを必要と</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">標準アルゴリズムを</font><font style="vertical-align: inherit;">使用できる</font><font style="vertical-align: inherit;">ことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の例を考えてみましょう。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">say_hi</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">char</span>&gt; v</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> v.push_back(<span class="hljs-string">'h'</span>)        <font></font>
            .push_back(<span class="hljs-string">'i'</span>)        <font></font>
            .push_back(<span class="hljs-string">'!'</span>);       <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数は受け入れずに戻ります</font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、呼び出しチェーンは内部で実行され</font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。ここでは、前の例と同様に、呼び出し内で不要なコピーが発生する可能性があります</font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。実行される最初の値</font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は名前付きの値であり、残りはr値、つまり匿名リンクであることに</font><font style="vertical-align: inherit;">注意してください</font><font style="vertical-align: inherit;">。参照カウントを使用する場合、メソッド</font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ツリーでメモリが割り当てられているノードの参照カウンターを参照できます。また、r値の場合、リンクの数が1の場合、プログラムの他の部分がこれらのノードにアクセスしないことが明らかになります。ここでのパフォーマンスは、の場合とまったく同じ</font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">say_hi</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">char</span>&gt; v</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> v.push_back(<span class="hljs-string">'h'</span>)        ⟵ named <span class="hljs-keyword">value</span>: v<font></font>
            .push_back(<span class="hljs-string">'i'</span>)        ⟵ r-<span class="hljs-keyword">value</span> <span class="hljs-keyword">value</span>
            .push_back(<span class="hljs-string">'!'</span>);       ⟵ r-<span class="hljs-keyword">value</span> <span class="hljs-keyword">value</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、コンパイラを助けるために、我々はそれを実行することができ</font></font><code>move(v)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それがあるため、</font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数内で他の場所では使用されません。</font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バリアントに</font><font style="vertical-align: inherit;">はない重要な利点がありました</font><font style="vertical-align: inherit;">。別のsay_hiの戻り値をsay_hi関数に渡した場合、余分なコピーはありません。 cの場合、</font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">過剰なコピーが発生する可能性がある境界があります。つまり、永続的な不変のデータ構造があり、そのパフォーマンスは実行時の共有アクセスの実際の量に依存します。共有がない場合、パフォーマンスは変更可能なデータ構造と同じになります。これは非常に重要な特性です。上ですでに示した例は、メソッドで書き直すことができます</font></font><code>move(v)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        v = std::move(v).push_back(i);<font></font>
    <span class="hljs-keyword">return</span> v;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまで、ベクトルについて説明してきましたが、ベクトルに加えて、ハッシュマップもあります。彼らはフィルナッシュによる非常に有用なレポートに捧げられています：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">聖杯。 C ++のハッシュ配列マッピングトライ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。先ほどお話ししたのと同じ原則に基づいて実装されたハッシュテーブルについて説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなた方の多くはそのような構造の性能について疑問を持っていると思います。彼らは実際にすばやく動作しますか？私は多くのテストを行ったので、要するに私の答えはイエスです。テスト結果について詳しく知りたい場合</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">は、関数型プログラミングの国際会議2017の</font></a><font style="vertical-align: inherit;">私の記事に掲載されています。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">さて、絶対値ではなく、このデータ構造がシステム全体に与える影響について検討する方が良いと思います。</font><font style="vertical-align: inherit;">もちろん、いくつかのデータブロックをコピーして他のデータにメモリを割り当てる必要があるため、ベクターの更新は遅くなります。</font><font style="vertical-align: inherit;">しかし、ベクターのバイパスは、通常のベクターとほぼ同じ速度で実行されます。</font><font style="vertical-align: inherit;">データの読み取りは変更よりもはるかに頻繁に実行されるため、これを達成することは私にとって非常に重要でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、更新が遅いため、何もコピーする必要はなく、データ構造のみがコピーされます。</font><font style="vertical-align: inherit;">したがって、ベクターの更新に費やされた時間は、システム内で実行されたすべてのコピーに対して、当然のことながら償却されます。</font><font style="vertical-align: inherit;">したがって、このデータ構造を、レポートの冒頭で説明したものと同様のアーキテクチャに適用すると、パフォーマンスが大幅に向上します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エヴィグ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は根拠のないものではなく、例を使用してデータ構造を示します。</font><font style="vertical-align: inherit;">小さなテキストエディタを書きました。</font><font style="vertical-align: inherit;">これは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれるインタラクティブなツール</font><font style="vertical-align: inherit;">で、ドキュメントは不変のベクトルで表されます。</font><font style="vertical-align: inherit;">エスペラント語でウィキペディア全体のコピーをディスクに保存しています。1ギガバイトです（最初は英語版をダウンロードしたかったのですが、大きすぎます）。</font><font style="vertical-align: inherit;">あなたがどんなテキストエディタを使っていても、彼はこのファイルが気に入らないと確信しています。</font><font style="vertical-align: inherit;">また、このファイルを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でダウンロードすると、ダウンロードは非同期であるため、すぐに編集できます。</font><font style="vertical-align: inherit;">ファイルナビゲーションは機能しますが、何もハングしませ</font></font><code>mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ん。</font><font style="vertical-align: inherit;">ご覧のように、ダウンロードしたファイルには2,000万行のコードが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このツールの最も重要な特性を検討する前に、面白い詳細に注意を払いましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/eb/kt/eq/ebkteqmtvnbkncoxlb91z0g6qpy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像の下部で白く強調表示されている行の先頭に、2つのハイフンが表示されています。このUIはemacsユーザーによく知られています。ハイフンは、ドキュメントがまったく変更されていないことを意味します。変更を加えると、ハイフンの代わりにアスタリスクが表示されます。ただし、他のエディターとは異なり、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewigで</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらの変更</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">消去する</font><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">（元</font><font style="vertical-align: inherit;">に</font><i><font style="vertical-align: inherit;">戻さ</font></i><font style="vertical-align: inherit;">ず、削除するだけです）、</font><font style="vertical-align: inherit;">以前のバージョンのテキストはすべて</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewigに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存</font><font style="vertical-align: inherit;">されるため、アスタリスクの代わりにハイフンが表示されます</font><font style="vertical-align: inherit;">。このおかげで、ドキュメントが変更されたかどうかを示すために特別なフラグは必要ありません。変更の存在は、元のドキュメントとの比較によって決定されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このツールの別の興味深いプロパティを考えてみましょう。テキスト全体をコピーして、既存のテキストの中央に数回貼り付けます。</font><font style="vertical-align: inherit;">ご覧のとおり、これは即座に行われます。</font><font style="vertical-align: inherit;">ここでのベクトルの結合は対数演算であり、数百万の対数はそれほど長い演算ではありません。</font><font style="vertical-align: inherit;">この巨大なドキュメントをハードドライブに保存しようとすると、テキストがこのベクターの以前のバージョンから取得したベクターとして表示されなくなるため、さらに時間がかかります。</font><font style="vertical-align: inherit;">ディスクに保存するときにシリアル化が行われるため、永続性は失われます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">価値ベースのアーキテクチャに戻る</font></font></h2><br>
<img src="https://habrastorage.org/webt/wf/o7/b7/wfo7b78ha0wnqjzcjjeky_esh0g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアーキテクチャに戻れない方法から始めましょう。通常のJavaスタイルのコントローラー、モデル、ビューを使用します。これらは、C ++のインタラクティブアプリケーションで最もよく使用されます。それらには何も問題はありませんが、私たちの問題には適していません。一方で、Model-View-Controllerパターンはタスクの分離を可能にしますが、他方で、これらの各要素はオブジェクト指向の観点とC ++の観点の両方からのオブジェクトです。つまり、これらは変更可能なメモリ領域です状態。ビューはモデルについて知っています。これははるかに悪いことです。モデルが変更されたときにビューに通知されるコールバックがほぼ確実にあるため、モデルはビューについて間接的に知っています。オブジェクト指向の原則を最適に実装しても、多くの相互依存関係があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/07/so/xq/07soxqkandixucwhzk6mvfr1e84.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションが大きくなり、新しいモデル、コントローラー、ビューが追加されると、プログラムのセグメントを変更するために、それに関連付けられているすべてのパーツ、を通じて通知を受け取るすべてのビューなどについて知る必要がある場合があります</font></font><code>callback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。その結果、すべてのおなじみのパスタモンスターは、これらの依存関係をじっと見始めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のアーキテクチャは可能ですか？ 「単方向データフローアーキテクチャ」と呼ばれる、Model-View-Controllerパターンへの代替アプローチがあります。この概念は私が考案したものではなく、Web開発でかなり頻繁に使用されています。 Facebookでは、これはFluxアーキテクチャと呼ばれていますが、C ++ではまだ適用されていません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ty/z6/p2/tyz6p2hutpnjwusi0edhbcwvo0s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのようなアーキテクチャの要素は、アクション、モデル、ビューにすでに慣れていますが、ブロックと矢印の意味は異なります。ブロックは値であり、オブジェクトではなく、状態が変更可能な領域ではありません。これはビューにも当てはまります。さらに、オブジェクトがなければリンクはないので、矢印はリンクではありません。ここで、矢印は関数です。アクションとモデルの間には、現在のモデル、つまり世界の現在の状態を受け入れる更新関数と、マウスクリックなどのイベントを表すアクション、または要素やシンボルがドキュメントに挿入されるなど、抽象化の別のレベルのイベントであるアクションがあります。 update関数はドキュメントを更新し、世界の新しい状態を返します。 ModelはView関数のレンダーに接続します。レンダーはモデルを受け取り、ビューを返します。これには、ビューを値として表すことができるフレームワークが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Web開発ではReactがこれを行いますが、C ++にはまだそのようなものはありません。その間、イミディエイトモードAPIを使用できます。このAPIでは、描画関数を使用して、副作用として値を作成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、ビューには、ユーザーまたは他のイベントソースがアクションを送信できるメカニズムが必要です。これを実装する簡単な方法があります。以下に示します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">application <span class="hljs-title">update</span>(<span class="hljs-params">application state, action ev</span>)</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fname</span>)</span><font></font>
{<font></font>
    auto term  = terminal{};<font></font>
    auto state = application{load_buffer(fname), key_map_emacs};<font></font>
    <span class="hljs-keyword">while</span> (!state.done) {<font></font>
        draw(state);<font></font>
        auto act = term.next();<font></font>
        state = update(state, act);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期での保存と読み込みを除いて、これは先ほど紹介したエディターで使用されるコードです。ここには</font></font><code>terminal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コマンドラインからの読み取りと書き込みを可能に</font><font style="vertical-align: inherit;">するオブジェクトがあります</font><font style="vertical-align: inherit;">。さらに、</font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはモデルの値であり、アプリケーションの状態全体を格納します。画面上部にあるように、新しいバージョンを返す関数があります</font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。関数内のサイクルは、アプリケーションを閉じる必要があるまで、つまりまで実行されます</font></font><code>!state.done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ループでは、新しい状態が描画され、次のイベントが要求されます。最後に、状態がローカル変数に格納され</font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ループが再び開始されます。このコードには非常に重要な利点があります</font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">プログラムの実行中に存在する可変変数は1つだけであり、それはオブジェクト</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Clojure開発者は、この単一原子アーキテクチャーを呼び出します。すべての変更が行われるアプリケーション全体に1つのポイントがあります。</font><font style="vertical-align: inherit;">アプリケーションロジックは、このポイントの更新には一切関与しません。これにより、このために特別に設計されたサイクルが作成されます。</font><font style="vertical-align: inherit;">これのおかげで、アプリケーションロジックは完全にfunctionなどの純粋な関数で構成されます</font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションを作成するこのアプローチにより、ソフトウェアについての考え方が変わります。</font><font style="vertical-align: inherit;">作業は、インターフェースと操作のUMLダイアグラムではなく、データ自体から始まります。</font><font style="vertical-align: inherit;">データ指向の設計にはいくつかの類似点があります。</font><font style="vertical-align: inherit;">真のデータ指向設計は通常、最大のパフォーマンスを得るために使用されます。ここでは、速度に加えて、シンプルさと正確さを追求しています。</font><font style="vertical-align: inherit;">重点は少し異なりますが、方法論には重要な類似点があります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> index = <span class="hljs-keyword">int</span>;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> coord<font></font>
{<font></font>
    index row = {};<font></font>
    index col = {};<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">using</span> line = immer::flex_vector&lt;<span class="hljs-keyword">char</span>&gt;;
<span class="hljs-keyword">using</span> text = immer::flex_vector&lt;line&gt;;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> file<font></font>
{<font></font>
    immer::box&lt;std::<span class="hljs-keyword">string</span>&gt; name;<font></font>
    text content;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> snapshot<font></font>
{<font></font>
    text content;<font></font>
    coord cursor;<font></font>
};<font></font>
 <font></font>
<span class="hljs-keyword">struct</span> buffer<font></font>
{<font></font>
    file <span class="hljs-keyword">from</span>;<font></font>
    text content;<font></font>
    coord cursor;<font></font>
    coord scroll;<font></font>
    std::optional&lt;coord&gt; selection_start;<font></font>
    immer::vector&lt;snapshot&gt; history;<font></font>
    std::optional&lt;std::size_t&gt; history_pos;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> application<font></font>
{<font></font>
    buffer current;<font></font>
    key_map keys;<font></font>
    key_seq input;<font></font>
    immer::vector&lt;text&gt; clipboard;<font></font>
    immer::vector&lt;message&gt; messages;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> action { key_code key; coord size; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記は、アプリケーションの主なデータ型です。アプリケーションの本体</font></font><code>line</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はflex_vectorであるで</font><font style="vertical-align: inherit;">構成され</font><font style="vertical-align: inherit;">、flex_vectorは</font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結合操作を実行できるものです。次</font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、それが格納されているベクトル</font></font><code>line</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。ご覧のとおり、これはテキストの非常に単純な表現です。</font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">助けを借りて保存され</font></font><code>file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、実際にはファイルシステム内のアドレス、および名前を、持っているの</font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別のタイプ</font><font style="vertical-align: inherit;">として</font><font style="vertical-align: inherit;">使用されているように、シンプルですが非常に便利です</font></font><code>box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは単一要素のコンテナです。ヒープに入れてオブジェクトを移動できますが、コピーはリソースを集中的に使用する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の重要なタイプ：</font></font><code>snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このタイプに基づいて、キャンセル機能がアクティブになります。文書が含まれています（フォームに</font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）およびカーソル位置（座標）。これにより、カーソルを編集中の位置に戻すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のタイプは</font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。オープンドキュメントが呼び出されるため、これはvimおよびemacsからの用語です。では</font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テキストがダウンロードされたファイルだけでなく、テキストの内容がある-これは、ドキュメント内の変更を確認することができます。テキストの一部を強調表示するため</font></font><code>selection_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、選択の開始を示す</font><font style="vertical-align: inherit;">オプションの変数があります</font><font style="vertical-align: inherit;">。からのベクトル</font></font><code>snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、テキストの物語です。チームパターンは使用しないことに注意してください。履歴は状態のみで構成されています。最後に、キャンセルが完了したばかりの場合は、状態履歴の位置インデックスが必要</font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のタイプ：</font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、開いているドキュメント（バッファ）を含み、</font></font><code>key_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><code>key_seq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーボードショートカットのほか</font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、クリップボードの</font><font style="vertical-align: inherit;">ベクトルfrom </font><font style="vertical-align: inherit;">と、画面の下部に表示されるメッセージの別のベクトル。</font><font style="vertical-align: inherit;">これまでのところ、アプリケーションのデビューバージョンでは、1つのスレッドと1つのタイプのアクションのみが入力</font></font><code>key_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">を受け取ります</font></font><code>coord</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、あなたの多くはすでにこれらの操作を実装する方法について考えています。</font><font style="vertical-align: inherit;">値で取得して値で返す場合、ほとんどの場合、操作は非常に簡単です。</font><font style="vertical-align: inherit;">私のテキストエディターのコードは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">投稿されている</font><font style="vertical-align: inherit;">ので、実際にどのように見えるかを確認できます。</font><font style="vertical-align: inherit;">次に、キャンセル機能を実装するコードについてのみ詳しく説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャンセル</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
適切なインフラストラクチャなしでキャンセルを正しく記述することはそれほど単純ではありません。私のエディターでは、emacsのラインに沿ってそれを実装したので、最初にその基本原則について少し説明します。ここにはreturnコマンドがありません。これにより、仕事を失うことはありません。返品が必要な場合は、テキストに変更が加えられ、すべてのキャンセルアクションがキャンセル履歴の一部になります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s0/4z/j_/s04zj_sia6mzw8reywkbznlhlem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この原理は上に描かれています。ここの赤いひし形は、履歴内の位置を示しています。キャンセルが完了していない場合、赤いひし形は常に最後にあります。キャンセルすると、ひし形は1つの状態に戻りますが、同時に、ユーザーが現在表示しているのと同じように、別の状態がキューの最後に追加されます（S3）。もう一度キャンセルして状態S2に戻ると、状態S2がキューの最後に追加されます。ユーザーがなんらかの変更を加えると、S5の新しい状態としてキューの最後に追加され、ひし形がそれに移動します。これで、過去の操作を元に戻すと、以前の元に戻す操作が最初にスクロールされます。このようなキャンセルシステムを実装するには、次のコードで十分です。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">buffer <span class="hljs-title">record</span>(<span class="hljs-params">buffer before, buffer after</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">if</span> (before.content != after.content) {<font></font>
        after.history = after.history.push_back({before.content, before.cursor});<font></font>
        <span class="hljs-keyword">if</span> (before.history_pos == after.history_pos)<font></font>
            after.history_pos = std::nullopt;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> after;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">buffer <span class="hljs-title">undo</span>(<span class="hljs-params">buffer buf</span>)</span><font></font>
{<font></font>
    auto idx = buf.history_pos.value_or(buf.history.size());<font></font>
    <span class="hljs-keyword">if</span> (idx &gt; <span class="hljs-number">0</span>) {<font></font>
        auto restore = buf.history[--idx];<font></font>
        buf.content = restore.content;<font></font>
        buf.cursor = restore.cursor;<font></font>
        buf.history_pos = idx;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> buf;<font></font>
  }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのアクションが</font></font><code>record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あり</font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><code>Record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作中に実行されます。ドキュメントの編集が行われたかどうかを知る必要がないため、これは非常に便利です。この関数は、アプリケーションロジックに対して透過的です。何らかのアクションの後、関数はドキュメントが変更されたかどうかをチェックします。変更があった場合、</font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容とカーソル位置が</font><font style="vertical-align: inherit;">実行され</font></font><code>history</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。アクションが変更につながらなかった場合</font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（つまり、受け取った入力</font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がキャンセルアクションによるもので</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">ない</font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">）、</font><font style="vertical-align: inherit;">値が割り当てられ</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。必要に応じ</font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">てチェックし</font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。意味がない場合</font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ストーリーの最後にある</font><font style="vertical-align: inherit;">と見なし</font><font style="vertical-align: inherit;">ます。キャンセル履歴が空でない場合（つまり、</font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストーリーの最初ではなく）、キャンセルが実行されます。</font><font style="vertical-align: inherit;">現在のコンテンツとカーソルが置き換えられ、変更され</font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">元に戻す操作の取り消し不能性は、元に戻す操作</font></font><code>record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中にも呼び出される</font><font style="vertical-align: inherit;">関数によって実現され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、</font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10行のコード</font><font style="vertical-align: inherit;">を使用する操作</font><font style="vertical-align: inherit;">があり、変更なしで（または最小限の変更で）、他のほとんどすべてのアプリケーションで使用できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイムトラベル</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイムトラベルについて。これから見るように、これはキャンセルに関連するトピックです。同様のアーキテクチャーを持つアプリケーションに有用な機能を追加するフレームワークの働きを示します。ここでのフレームワークは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig-debug</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。このバージョンの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewigに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、いくつかのデバッグ機能が含まれています。これで、ブラウザーからデバッガーを開くことができ、アプリケーションの状態を調べることができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dy/ba/7x/dyba7xjocwgjjmqvayinlfwx0y4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいウィンドウを開いたため、最後のアクションはサイズ変更でした。ウィンドウマネージャーは既に開いているウィンドウのサイズを自動的に変更しました。もちろん、JSONでの自動シリアル化のために、特別なリフレクションライブラリからstructの注釈を追加する必要がありました。しかし、システムの残りの部分は非常に普遍的で、同様のアプリケーションに接続できます。これで、ブラウザに完了したすべてのアクションが表示されます。もちろん、何もしない初期状態があります。これはダウンロード前の状態です。さらに、ダブルクリックすることで、アプリケーションを以前の状態に戻すことができます。これは、アプリケーションの誤動作の発生を追跡できる非常に便利なデバッグツールです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味があれば、CPPCON 19の私のレポートを聞くことができます。最も価値のある値です。そこで、このデバッガーを詳しく調べます。 </font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/_oBx_NbLghY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、価値ベースのアーキテクチャについては、そこで詳しく説明します。</font><font style="vertical-align: inherit;">その中で、アクションを実装して階層的に整理する方法についても説明します。</font><font style="vertical-align: inherit;">これにより、システムのモジュール性が確保され、すべてを1つの大きな更新機能に保持する必要がなくなります。</font><font style="vertical-align: inherit;">さらに、そのレポートでは、非同期およびマルチスレッドファイルのダウンロードについて説明しています。</font><font style="vertical-align: inherit;">このレポートの別のバージョンでは、追加の30分資料がポストモダンの不変データ構造です。</font></font><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/y_m0ce1rzRI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要約する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入荷時期です。 Andy Wingoを引用します-彼は優れた開発者であり、V8とコンパイラー全般に多くの時間を費やし、最後に、Guileのサポート、Scheme for GNUの実装に従事しています。最近、彼はTwitterに次のように書いています。しかし、私たちは本当に100％の信頼性を持たず、直感のみで導かれることなく、盲目的に多大な労力を費やして大幅な加速を実現しています。なんて奇妙な二分法でしょう。」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++開発者は最初のジャンルで成功しているように思えます。</font><font style="vertical-align: inherit;">私たちに閉鎖的なシステムを提供してください。そうすれば、私たちのツールで武装して、そこから可能なすべてのものを絞り出します。</font><font style="vertical-align: inherit;">しかし、第2のジャンルでは、私たちは働くことに慣れていません。</font><font style="vertical-align: inherit;">もちろん、2番目のアプローチの方がリスクが高く、多くの場合、多大な労力の浪費につながります。</font><font style="vertical-align: inherit;">一方、プログラムを完全に書き直すことにより、多くの場合、プログラムをより簡単かつ高速にすることができます。</font><font style="vertical-align: inherit;">少なくともこの2番目のアプローチを試すように説得できたと思います。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フアンプエンテは、C ++ Russia 2019 Moscow会議で講演し、興味深いことを行うためのデータ構造について話しました。</font><font style="vertical-align: inherit;">これらの構造の魔法の一部はコピー省略にあります。これは、今後の会議で</font><font style="vertical-align: inherit;">アントンポルキンとローマンルシャエフ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が話し合う</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もの</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">サイトの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">従ってください</font><font style="vertical-align: inherit;">。</font></font></blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja487090/index.html">新しいレベルのWindows最適化</a></li>
<li><a href="../ja487092/index.html">ERPシステム実装プロジェクトの一部としてのビジネスプロセスのモデリング</a></li>
<li><a href="../ja487094/index.html">Kafkaから受け取った再処理イベント</a></li>
<li><a href="../ja487096/index.html">切れ端。ドキュメンテーションでの作業プロセスを簡単にする方法</a></li>
<li><a href="../ja487098/index.html">アリで描く：アリのコロニー最適化アルゴリズムを使用した手続き型画像</a></li>
<li><a href="../ja487106/index.html">PVS-StudioアナライザーのRunUOチェック</a></li>
<li><a href="../ja487108/index.html">モバイルゲーマープロフィール：MyTracker Research</a></li>
<li><a href="../ja487110/index.html">Slurm SRE。Booking.comとGoogle.comの専門家による完全な実験</a></li>
<li><a href="../ja487112/index.html">Edge of Madness：The Basic Circle</a></li>
<li><a href="../ja487116/index.html">DiscordがGo to Rustから移行する理由</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>