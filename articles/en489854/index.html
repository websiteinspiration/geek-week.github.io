<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•í üë©üèª‚Äçüé® ü•¢ Redux vs MobX without confusion ü§Ø üë®üèº‚Äçüöí ‚è´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In recent years, I have often used Redux , but recently I have been using MobX as an alternative to state management. Redux alternatives seem to natur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Redux vs MobX without confusion</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489854/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/dt/7e/na/dt7enamgfkxspaajcdst26auxj8.jpeg" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In recent years, I have often used </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but recently I have been using </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MobX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> as an alternative to state management. Redux alternatives seem to naturally turn into a mess. People are not sure which solution to choose. The problem is not necessarily Redux vs MobX. Whenever there is an alternative, people are curious how best to solve their problem. I am writing these lines to eliminate confusion around Redux and MobX state management solutions.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What will this article be about? </font><font style="vertical-align: inherit;">First, I want to briefly return to the problem that the state management library solves. </font><font style="vertical-align: inherit;">In the end, everything will be fine if you just use this.setState () and this.state in React or its variation in another presentation-level library or in a SPA environment. </font><font style="vertical-align: inherit;">Secondly, I will continue to give you an overview of both solutions, showing consistency and differences. </font><font style="vertical-align: inherit;">And last but not least, if you already have an application that works with MobX or Redux, I want to tell you about refactoring from one state library to another.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Content:</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What problem do we solve?</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is the difference between REDUX and MOBX?</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React state learning curve</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recent thoughts on the topic</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">More resources</font></font></a></li>
</ol><br>
<a name="WhatProblem"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What problem do we solve?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everyone wants to have state management in the application. </font><font style="vertical-align: inherit;">But what problem does this solve for us? </font><font style="vertical-align: inherit;">Most people start with a small application and already implement a state management library. </font><font style="vertical-align: inherit;">Everyone is talking about it, right? </font><font style="vertical-align: inherit;">Redux! </font><font style="vertical-align: inherit;">MobX! </font><font style="vertical-align: inherit;">But most applications do not need ambitious state management from the start. </font><font style="vertical-align: inherit;">This is even more dangerous because </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">most people will never be confronted with problems such as libraries such as Redux or MobX</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The status quo is currently building a front-end application with components. </font><font style="vertical-align: inherit;">Components have an internal state. </font><font style="vertical-align: inherit;">In a growing application, state management can become chaotic with a local state, because:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a component must share state with another component</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a component must modify the state of another component</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At some point, it becomes more and more difficult to talk about the state of the application. This becomes a dirty web of state objects and state mutations in your component hierarchy. In most cases, state objects and state mutations are not necessarily associated with one component. They are linked through your component tree, and you must raise and lower the state. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The solution, therefore, is to introduce a state management library such as MobX or Redux. It gives you tools to save your state, change state, and receive state updates. You have one place to search, one place to change, and one place to receive status updates. He follows the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">principle of a single source of truth.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This makes it easier to reason about changes in your state and conditions, because they separate from your components. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
State management libraries such as Redux and MobX often have add-ons for utilities, for example, for Angular they have angular-redux and mobx-angular to give your components access to state. </font><font style="vertical-align: inherit;">Often, these components are called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">containerized components,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or, to be more precise, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">related components</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">From anywhere in your component hierarchy, you can access the state and change it by updating your component to a related one.</font></font><br>
<br>
<a name="whats-the-difference-between-redux-and-mobx"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is the difference between REDUX and MOBX?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before we dive into the difference, I want to tell you about the similarities between MobX and Redux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Both libraries are used to control state in JavaScript applications. They are not necessarily associated with a library such as Angular. They are also used in other libraries such as ReactJs and VueJs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you choose one of the state management solutions, you will not run into a vendor lockout. You can switch to another state management solution at any time. You can upgrade from MobX to Redux or from Redux to MobX. Later I will show you how this happens. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redux designed by </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan Abramov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andrew Clark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a derivative </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of the Flux architecture</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Unlike Flux, it uses one repository over several to maintain state. In addition, instead of a dispatcher, it uses pure functions to change state. If you are not familiar with the flow and you are new to state management, do not worry about the last paragraph. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redux is influenced by the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">principles of functional programming</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (FP). FP can be done in JavaScript, but many people come from an object-oriented background, like Java, and have difficulty accepting the principles of functional programming in the first place. This later explains why MobX may be easier to learn as a beginner. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since Redux includes functional programming, it uses </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pure functions</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pure function is a function that receives input, returns output, and has no other dependencies other than the same functions. </font><font style="vertical-align: inherit;">Such a function always produces the same output with the same input and has no side effects. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">More details</font></font></a></blockquote><br>
<pre><code class="javascript hljs">(state, action) =&gt; newState</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Your Redux state </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is unchanged</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Instead of mutating, you always return a new state. </font><font style="vertical-align: inherit;">You do not perform state mutations and are not dependent on object references.</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-comment">//     Redux,     </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAuthor</span>(<span class="hljs-params">state, action</span>) </span>{
  <span class="hljs-keyword">return</span> state.authors.push(action.author);<font></font>
}<font></font>
<span class="hljs-comment">//       </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAuthor</span>(<span class="hljs-params">state, action</span>) </span>{
  <span class="hljs-keyword">return</span> [ ...state.authors, action.author ];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And last but not least, in idiomatic Redux, your </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">state is normalized</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , like in a database. Entities </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">refer to each other only by id</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This is the best practice. Although not everyone does, you can use a library like </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normalizr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to achieve such a normalized state. Normalized state allows you to maintain a flat state and entities as a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">single source of truth</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="json hljs">{<font></font>
  post: {<font></font>
    id: 'a',<font></font>
    authorId: 'b',<font></font>
    ...<font></font>
  },<font></font>
  author: {<font></font>
    id: 'b',<font></font>
    postIds: ['a', ...],<font></font>
    ...<font></font>
  }<font></font>
}</code></pre><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In comparison, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Michel Weststratt‚Äôs MobX is</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> influenced not only by object-oriented programming, but also by reactive programming. </font><font style="vertical-align: inherit;">It wraps your state in observable objects. </font><font style="vertical-align: inherit;">Thus, you have all the features of " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " in your state. </font><font style="vertical-align: inherit;">Data can have simple setters and getters, but observable allows you to receive updates after data changes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Mobx, your </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">status is volatile</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This way you change the state directly:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAuthor</span>(<span class="hljs-params">author</span>) </span>{
  <span class="hljs-keyword">this</span>.authors.push(author);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, organizations remain in a (deeply) nested data structure with respect to each other. </font><font style="vertical-align: inherit;">You do not normalize your condition. </font><font style="vertical-align: inherit;">The condition </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">remains </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">denormalized</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and embedded.</font></font></b><br>
<br>
<pre><code class="json hljs">{<font></font>
  post: {<font></font>
    id: 'a',<font></font>
    ...<font></font>
    author: {<font></font>
      id: 'b',<font></font>
      ...<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One repository versus several</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Redux, you store all your state in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one global repository</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one global state</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . A single state object is your only source of truth. Numerous gearboxes, on the other hand, allow it to change an unchanging state. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In comparison, MobX uses several repositories. Like Redux reducers, you can apply separation and conquest by technical level, domain, etc. You can store your domain objects in separate repositories, but you can also control the viewing status in your repositories. In the end, you place the state that is most appropriate for your application.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Technically, you can have multiple repositories in Redux as well. </font><font style="vertical-align: inherit;">No one forces you to use only one. </font><font style="vertical-align: inherit;">But this is not an advertised use case of Redux. </font><font style="vertical-align: inherit;">Using multiple repositories runs counter to best practices. </font><font style="vertical-align: inherit;">In Redux, you want to have one repository that responds through its reducers to global events.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What does the implementation look like?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On Redux, adding the configuration of an application to a global state requires the following lines of code. </font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> initialState = {
  <span class="hljs-attr">users</span>: [<font></font>
    {<font></font>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Alex'</span><font></font>
    },<font></font>
    {<font></font>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Nik'</span><font></font>
    }<font></font>
  ]<font></font>
};<font></font>
<span class="hljs-comment">// reducer</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">users</span>(<span class="hljs-params">state = initialState, action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
  <span class="hljs-keyword">case</span> <span class="hljs-string">'USER_ADD'</span>:
    <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">users</span>: [ ...state.users, action.user ] };
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">return</span> state;<font></font>
  }<font></font>
}<font></font>
<span class="hljs-comment">// action</span>
{ <span class="hljs-attr">type</span>: <span class="hljs-string">'USER_ADD'</span>, <span class="hljs-attr">user</span>: user };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In MobX, storage will only manage the substate (as the reducer in Redux controls the substate), but you can directly change the state. </font><font style="vertical-align: inherit;">The @observable annotation allows you to observe state changes.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">userStore</span></span>{<font></font>
@observable users = [<font></font>
    {<font></font>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Nikita'</span><font></font>
    }<font></font>
  ];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now you can call userStore.users.push (user); </font><font style="vertical-align: inherit;">on the copy of the store. </font><font style="vertical-align: inherit;">However, it is recommended that state mutations be more explicit through action.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">userStore</span></span>{<font></font>
@observable users = [<font></font>
    {<font></font>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Nikita'</span><font></font>
    }<font></font>
  ];<font></font>
}<font></font>
@action addUser = <span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> {
    <span class="hljs-keyword">this</span>.users.push(user);<font></font>
  }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can strictly apply it by configuring MobX with configure ({empceActions: true});. </font><font style="vertical-align: inherit;">Now you can change your state by calling userStore.addUser (user); </font><font style="vertical-align: inherit;">on the copy of the store. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You have seen how to update state on both Redux and MobX. </font><font style="vertical-align: inherit;">In Redux, your state is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">read-only</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">You can only change state with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explicit actions</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In contrast, in MobX, state includes reading and writing. </font><font style="vertical-align: inherit;">You can mutate the state directly without using actions, but you can select explicit actions using the enforceActions configuration.</font></font><br>
<br>
<a name="the-learning-curve-in-react-state-management"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React state learning curve</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Both Redux and MobX are mainly used in React applications. But these are standalone state management libraries that can be used everywhere without React. Their interaction libraries make it easy to combine them with Angular components. These are </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">react-redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React + Redux</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mobx-react</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React + MobX</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Later I will explain how to use both in the Angular component tree.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In recent discussions, it has happened that people argued about the learning curve in Redux. This often happened in the context of React: people started learning React and already wanted to use state management with Redux. Most people claim that React and Redux themselves have a good learning curve, but both can be overwhelming. Therefore, MobX will be an alternative, because it is more suitable for beginners.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, I would suggest a different approach for new React users to learn about state management in the React ecosystem. </font><font style="vertical-align: inherit;">Start learning React with your own local state-management features in components. </font><font style="vertical-align: inherit;">In a React application, you first learn about the React lifecycle methods and understand how to manage local states with setState () and this.state. </font><font style="vertical-align: inherit;">I highly recommend this learning path. </font><font style="vertical-align: inherit;">Otherwise, you will be quickly overwhelmed by the React ecosystem. </font><font style="vertical-align: inherit;">In the end, along the way you will realize that managing the (internal) state of the components becomes complicated.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux or MobX for beginners?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By familiarizing yourself with Angular components and internal state management, you can choose a state management library to solve your problem. After I used both libraries, I would say that MobX can be very convenient for beginners. We've already seen that MobX needs less code, although it does use some magic notes that we don‚Äôt need to know about yet. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With MobX, you don't need to be familiar with functional programming. Terms such as immutability may still be foreign.</font></font><blockquote>  ‚Äî   ,       JavaScript.     ,          ,   - , ,     MobX.</blockquote><br>
<br>
<h3>  Redux</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As your application grows larger and several developers work on it, you should consider using Redux. By nature, he undertakes to use explicit actions to change state. The action has a type and payload that the gearbox can use to change state. It is very easy for the development team to talk about state changes in this way. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redux provides you with an entire architecture for managing state with clear limitations. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux Success Story</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another advantage of Redux is its use on the server side. Since we are dealing with simple JavaScript, you can send state over the network. Serialization and deserialization of a state object works out of the box. However, this is also possible with MobX.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MobX is less self-confident, but with configure ({empceActions: true}) you can apply more precise restrictions, as in Redux. That's why I would not say that you cannot use MobX to scale applications, but Redux has a clear way to do something. The MobX documentation even says: ‚Äú </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[MobX] doesn't tell you how to structure your code, where to store state, or how to handle events</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .‚Äù The development team would first have to create a state management architecture. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After all, the state management learning curve is not that steep. When we repeat the recommendations, a newbie to React will </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first learn how to use setState () and this.state correctly</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . After a while you will understand the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">problems of using only setState ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to maintain state in the React app. </font><font style="vertical-align: inherit;">When looking for a solution, you come across state management libraries such as MobX or Redux. </font><font style="vertical-align: inherit;">But which one to choose? </font><font style="vertical-align: inherit;">Since MobX is less self-confident, has a smaller template and can be used similarly to setState (), I would recommend giving MobX a chance in small projects. </font><font style="vertical-align: inherit;">As soon as the application grows in size and increases the number of participants, you should consider applying additional restrictions in MobX or give Redux a chance. </font><font style="vertical-align: inherit;">I liked using both libraries. </font><font style="vertical-align: inherit;">Even if you do not use one of them in the end, it makes sense to see an alternative way to manage the state.</font></font><br>
<br>
<a name="last-thoughts"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Last thoughts</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Whenever I read the comments in the Redux vs MobX discussion, there is always one comment: ‚Äú </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux has too much standard, you should use MobX instead. I was able to delete XXX lines of code</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . " The comment may be true, but no one considers a compromise. Redux comes with a lot of templates like MobX because it has been added for specific design constraints. This allows you to reason about the state of your application, even if it is on a larger scale. The whole ceremony associated with the treatment of the state, is not just. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Redux library is pretty small. Most of the time you </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">only deal with simple JavaScript objects and arrays.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This is closer to vanilla JavaScript than MobX. In MobX, objects and arrays are wrapped in observable objects that hide most of the standard template. It is built on hidden abstractions in which magic occurs, but it is more difficult to understand the basic mechanisms. Redux makes it easier to talk about this with simple JavaScript. This makes it easy to test and debug the application. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, you need to think again about where we came from in the SPA. A bunch of single-page frameworks and application libraries had the same state management problems that were ultimately resolved using a comprehensive stream model. Redux is the successor to this approach.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In MobX, it is again moving in the opposite direction. We again begin to mutate the state directly, without taking advantage of functional programming. For some people, this is again approaching two-way data binding. After some time, people may again encounter the same problems before a state management library such as Redux appears. State management is scattered across the components and ends in clutter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
While on Redux you have an established ceremony for setting things up, MobX is less self-confident. But it would be wise to accept the best MobX experience. People need to know how to organize state management in order to improve their arguments about it. Otherwise, people tend to change state directly in the components.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both libraries are great. </font><font style="vertical-align: inherit;">Although Redux is already well established, MobX is becoming a viable alternative to state management.</font></font></blockquote><br>
<a name="more-resurces"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">More resources</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comparison of Michel Weststratt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - creator of </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MobX</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en489840/index.html">Drive Anatomy: Hard Drives</a></li>
<li><a href="../en489844/index.html">Comparative analysis of some Java decompilers</a></li>
<li><a href="../en489848/index.html">Why do my colleagues / employees behave like @% ¬ß?</a></li>
<li><a href="../en489850/index.html">Security Week 09: who is responsible for Android security?</a></li>
<li><a href="../en489852/index.html">Transparent authentication in ASP.Net Core on Linux</a></li>
<li><a href="../en489856/index.html">Banach-Tarski reverse paradox or how to reduce the stored data volume by five times</a></li>
<li><a href="../en489858/index.html">Internationalization: Making the Web Accessible to Everyone</a></li>
<li><a href="../en489860/index.html">The history of Telefunken: the phoenix of German electronics from Wilhelm II and Goebbels to the Beatles and today</a></li>
<li><a href="../en489862/index.html">Planning in Go: Part II - The Go Scheduler</a></li>
<li><a href="../en489868/index.html">Freezing Mozilla WebThings</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>