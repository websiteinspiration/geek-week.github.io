<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆒 🌏 🔄 Go: deserialisasi JSON dengan pengetikan yang salah, atau cara mengatasi kesalahan pengembang API 🅱️ 🦐 👨🏾‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, saya kebetulan mengembangkan klien http on Go untuk layanan yang menyediakan REST API dengan json sebagai format penyandian. Tugas stan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Go: deserialisasi JSON dengan pengetikan yang salah, atau cara mengatasi kesalahan pengembang API</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502176/"><img src="https://habrastorage.org/webt/pf/hz/xm/pfhzxmp9antvvecnexqujg6pkzk.jpeg" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baru-baru ini, saya kebetulan mengembangkan klien http on Go untuk layanan yang menyediakan REST API dengan json sebagai format penyandian. </font><font style="vertical-align: inherit;">Tugas standar, tetapi dalam pekerjaan saya harus menghadapi masalah non-standar. </font><font style="vertical-align: inherit;">Saya memberi tahu Anda apa intinya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda ketahui, format json memiliki tipe data. </font><font style="vertical-align: inherit;">Empat primitif: string, angka, boolean, null; </font><font style="vertical-align: inherit;">dan dua tipe struktural: objek dan array. </font><font style="vertical-align: inherit;">Dalam hal ini, kami tertarik pada tipe primitif. </font><font style="vertical-align: inherit;">Berikut adalah contoh kode json dengan empat bidang tipe yang berbeda:</font></font><br>
<br>
<pre><code class="json hljs">{
	<span class="hljs-attr">"name"</span>:<span class="hljs-string">"qwerty"</span>,
	<span class="hljs-attr">"price"</span>:<span class="hljs-number">258.25</span>,
	<span class="hljs-attr">"active"</span>:<span class="hljs-literal">true</span>,
	<span class="hljs-attr">"description"</span>:<span class="hljs-literal">null</span>,<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang ditunjukkan contoh, nilai string dilampirkan dalam tanda kutip. Numerik - tidak memiliki tanda kutip. Tipe boolean hanya dapat memiliki satu dari dua nilai: true atau false (tanpa tanda kutip). Dan tipe null sesuai nol (juga tanpa tanda kutip).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan sekarang masalahnya sendiri. Pada titik tertentu, dalam pemeriksaan terperinci atas kode json yang diterima dari layanan pihak ketiga, saya menemukan bahwa salah satu bidang (sebut saja harga) secara berkala memiliki nilai string (jumlah dalam tanda kutip) di samping nilai numerik. Artinya, kueri yang sama dengan parameter yang berbeda dapat mengembalikan angka sebagai angka, atau dapat mengembalikan angka yang sama sebagai string. Saya tidak bisa membayangkan bagaimana kode yang mengembalikan hasil tersebut diatur di ujung yang lain, tetapi tampaknya ini disebabkan oleh fakta bahwa layanan itu sendiri adalah agregator dan menarik data dari sumber yang berbeda, dan pengembang tidak membawa respons server json ke format tunggal. Meskipun demikian, perlu untuk bekerja dengan apa yang ada.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi kemudian saya bahkan lebih terkejut. </font><font style="vertical-align: inherit;">Bidang logis (sebut saja aktif), selain benar dan salah, mengembalikan nilai string "benar", "salah", dan bahkan numerik 1 dan 0 (masing-masing benar dan salah).</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua kebingungan tentang tipe data ini tidak akan menjadi kritis jika saya akan memproses json mengatakan dalam PHP yang diketik dengan lemah, tetapi Go memiliki pengetikan yang kuat, dan membutuhkan indikasi yang jelas tentang jenis bidang deserialized. </font><font style="vertical-align: inherit;">Akibatnya, ada kebutuhan untuk menerapkan mekanisme yang memungkinkan mengkonversi semua nilai dari bidang aktif ke tipe logis selama proses deserialisasi, dan nilai apa pun dari bidang harga ke yang numerik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita mulai dengan kolom harga. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan kita memiliki kode json seperti ini:</font></font><br>
<br>
<pre><code class="json hljs">[<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-number">2.58</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-number">7.15</span>}<font></font>
]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yaitu, json berisi larik objek dengan dua bidang bertipe numerik. </font><font style="vertical-align: inherit;">Kode deserialisasi standar untuk json on Go ini terlihat seperti ini:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id    <span class="hljs-keyword">int</span>     <span class="hljs-string">`json:"id"`</span>
	Price <span class="hljs-keyword">float64</span> <span class="hljs-string">`json:"price"`</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	jsonString := <span class="hljs-string">`[{"id":1,"price":2.58},
					{"id":4,"price":7.15}]`</span><font></font>
<font></font>
	targets := []Target{}<font></font>
<font></font>
	err := json.Unmarshal([]<span class="hljs-keyword">byte</span>(jsonString), &amp;targets)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
		fmt.Println(err)<font></font>
		<span class="hljs-keyword">return</span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> targets {<font></font>
		fmt.Println(t.Id, <span class="hljs-string">"-"</span>, t.Price)<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kode ini, kita akan membatalkan desalisasi bidang id ke int dan bidang harga ke float64. </font><font style="vertical-align: inherit;">Sekarang anggaplah kode json kita terlihat seperti ini:</font></font><br>
<br>
<pre><code class="json hljs">[<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-number">2.58</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-string">"2.58"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-number">7.15</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">4</span>,<span class="hljs-attr">"price"</span>:<span class="hljs-string">"7.15"</span>}<font></font>
]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yaitu, bidang harga berisi nilai tipe numerik dan string. </font><font style="vertical-align: inherit;">Dalam kasus ini, hanya nilai numerik bidang harga yang dapat diterjemahkan ke dalam tipe float64, sementara nilai string akan menyebabkan kesalahan tentang ketidakcocokan jenis. </font><font style="vertical-align: inherit;">Ini berarti bahwa float64 atau tipe primitif lainnya tidak cocok untuk deserialisasi bidang ini, dan kita membutuhkan tipe kustom kita sendiri dengan logika deserialisasi sendiri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai tipe seperti itu, deklarasikan struktur CustomFloat64 dengan bidang Float64 tunggal dari tipe float64.</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> CustomFloat64 <span class="hljs-keyword">struct</span>{<font></font>
	Float64 <span class="hljs-keyword">float64</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan segera tunjukkan jenis ini untuk bidang Harga dalam struktur Target:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id    <span class="hljs-keyword">int</span>           <span class="hljs-string">`json:"id"`</span>
	Price CustomFloat64 <span class="hljs-string">`json:"price"`</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang Anda perlu menjelaskan logika Anda sendiri untuk mendekode bidang tipe CustomFloat64. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Paket encoding / json menyediakan dua metode khusus: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MarshalJSON</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnmarshalJSON</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang dirancang untuk menyesuaikan logika enkode dan dekode dari tipe data pengguna tertentu. Cukup dengan mengganti metode ini dan menjelaskan implementasi Anda sendiri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ganti metode UnmarshalJSON untuk jenis CustomFloat64 yang sewenang-wenang. Dalam hal ini, sangat penting untuk mengikuti tanda tangan metode ini, jika tidak maka metode ini tidak akan berfungsi, dan yang paling penting itu tidak akan menghasilkan kesalahan.</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf *CustomFloat64)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada input, metode ini mengambil sepotong byte (data), yang berisi nilai bidang tertentu dari json yang didekodekan. Jika kita mengonversi urutan byte ini menjadi string, maka kita akan melihat nilai bidang persis dalam bentuk yang ditulis dalam json. Yaitu, jika itu adalah tipe string, maka kita akan melihat string dengan tanda kutip ganda ("258"), jika itu adalah tipe numerik, maka kita akan melihat string tanpa tanda kutip (258).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk membedakan nilai numerik dari nilai string, Anda harus memeriksa apakah karakter pertama adalah tanda kutip. Karena karakter kutipan ganda dalam tabel UNICODE membutuhkan satu byte, kita hanya perlu memeriksa byte pertama dari irisan data dengan membandingkannya dengan nomor karakter di UNICODE. Ini adalah angka 34. Perhatikan bahwa secara umum, karakter tidak sama dengan byte, karena dapat mengambil lebih dari satu byte. Simbol dalam Go sama dengan rune (rune). Dalam kasus kami, kondisi ini cukup:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] == <span class="hljs-number">34</span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kondisi terpenuhi, maka nilainya memiliki tipe string, dan kita perlu mendapatkan string di antara tanda kutip, yaitu byte slice antara byte pertama dan terakhir. </font><font style="vertical-align: inherit;">Iris ini berisi nilai numerik yang dapat diterjemahkan ke dalam tipe float64 primitif. </font><font style="vertical-align: inherit;">Ini berarti bahwa kita dapat menerapkan metode json.Unmarshal padanya, sambil menyimpan hasilnya di bidang Float64 dari struktur CustomFloat64.</font></font><br>
<br>
<pre><code class="go hljs">err := json.Unmarshal(data[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(data)<span class="hljs-number">-1</span>], &amp;cf.Float64)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika irisan data tidak dimulai dengan tanda kutip, maka sudah berisi tipe data numerik, dan kita bisa menerapkan metode json.Unmarshal langsung ke seluruh irisan data.</font></font><br>
<br>
<pre><code class="go hljs">err := json.Unmarshal(data, &amp;cf.Float64)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut adalah kode lengkap untuk metode UnmarshalJSON:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf *CustomFloat64)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] == <span class="hljs-number">34</span> {<font></font>
		err := json.Unmarshal(data[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(data)<span class="hljs-number">-1</span>], &amp;cf.Float64)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomFloat64: UnmarshalJSON: "</span> + err.Error())<font></font>
		}<font></font>
	} <span class="hljs-keyword">else</span> {<font></font>
		err := json.Unmarshal(data, &amp;cf.Float64)<font></font>
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomFloat64: UnmarshalJSON: "</span> + err.Error())<font></font>
		}<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akibatnya, menggunakan metode json.Unmarshal ke kode json kami, semua nilai bidang harga akan secara transparan dikonversi ke tipe float64 primitif untuk kami, dan hasilnya akan ditulis ke bidang Float64 pada struktur CustomFloat64. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita mungkin perlu mengubah struktur Target kembali ke json. Tapi, jika kita menerapkan metode json.Marshal langsung ke tipe CustomFloat64, maka kita membuat serial struktur ini sebagai objek. Kita perlu menyandikan bidang harga menjadi nilai numerik. Untuk mengkustomisasi logika pengkodean dari tipe kustom CustomFloat64, kami menerapkan metode MarshalJSON untuk itu, sambil secara ketat mengamati tanda tangan metode:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf CustomFloat64)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> {<font></font>
	json, err := json.Marshal(cf.Float64)<font></font>
	<span class="hljs-keyword">return</span> json, err<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang perlu Anda lakukan dalam metode ini adalah kembali menggunakan metode json.Marshal, tetapi sudah menerapkannya bukan pada struktur CustomFloat64, tetapi ke bidang Float64. </font><font style="vertical-align: inherit;">Dari metode ini, kita mengembalikan byte dan slice yang diterima. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut ini adalah kode lengkap yang menampilkan hasil serialisasi dan deserialisasi (pengecekan kesalahan dihilangkan untuk singkatnya, jumlah byte dengan simbol tanda kutip ganda konstan):</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"encoding/json"</span>
	<span class="hljs-string">"errors"</span>
	<span class="hljs-string">"fmt"</span><font></font>
)<font></font>
<font></font>
<span class="hljs-keyword">type</span> CustomFloat64 <span class="hljs-keyword">struct</span> {<font></font>
	Float64 <span class="hljs-keyword">float64</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">const</span> QUOTES_BYTE = <span class="hljs-number">34</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf *CustomFloat64)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] == QUOTES_BYTE {<font></font>
		err := json.Unmarshal(data[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(data)<span class="hljs-number">-1</span>], &amp;cf.Float64)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomFloat64: UnmarshalJSON: "</span> + err.Error())<font></font>
		}<font></font>
	} <span class="hljs-keyword">else</span> {<font></font>
		err := json.Unmarshal(data, &amp;cf.Float64)<font></font>
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomFloat64: UnmarshalJSON: "</span> + err.Error())<font></font>
		}<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cf CustomFloat64)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> {<font></font>
	json, err := json.Marshal(cf.Float64)<font></font>
	<span class="hljs-keyword">return</span> json, err<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id    <span class="hljs-keyword">int</span>           <span class="hljs-string">`json:"id"`</span>
	Price CustomFloat64 <span class="hljs-string">`json:"price"`</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	jsonString := <span class="hljs-string">`[{"id":1,"price":2.58},
					{"id":2,"price":"2.58"},
					{"id":3,"price":7.15},
					{"id":4,"price":"7.15"}]`</span><font></font>
<font></font>
	targets := []Target{}<font></font>
<font></font>
	_ := json.Unmarshal([]<span class="hljs-keyword">byte</span>(jsonString), &amp;targets)<font></font>
<font></font>
	<span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> targets {<font></font>
		fmt.Println(t.Id, <span class="hljs-string">"-"</span>, t.Price.Float64)<font></font>
	}<font></font>
<font></font>
	jsonStringNew, _ := json.Marshal(targets)<font></font>
	fmt.Println(<span class="hljs-keyword">string</span>(jsonStringNew))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasil Eksekusi Kode:</font></font><br>
<br>
<pre><code class="bash hljs">1 - 2.58<font></font>
2 - 2.58<font></font>
3 - 7.15<font></font>
4 - 7.15<font></font>
[{<span class="hljs-string">"id"</span>:1,<span class="hljs-string">"price"</span>:2.58},{<span class="hljs-string">"id"</span>:2,<span class="hljs-string">"price"</span>:2.58},{<span class="hljs-string">"id"</span>:3,<span class="hljs-string">"price"</span>:7.15},{<span class="hljs-string">"id"</span>:4,<span class="hljs-string">"price"</span>:7.15}]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita beralih ke bagian kedua dan mengimplementasikan kode yang sama untuk deserialisasi json dengan nilai yang tidak konsisten dari bidang logis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan kita memiliki kode json seperti ini:</font></font><br>
<br>
<pre><code class="json hljs">[<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-literal">true</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">"true"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">"1"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">4</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-number">1</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">5</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-literal">false</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">6</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">"false"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">7</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">"0"</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">8</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-number">0</span>},<font></font>
	{<span class="hljs-attr">"id"</span>:<span class="hljs-number">9</span>,<span class="hljs-attr">"active"</span>:<span class="hljs-string">""</span>}<font></font>
]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus ini, bidang aktif menyiratkan tipe logis dan keberadaan hanya satu dari dua nilai: true dan false. </font><font style="vertical-align: inherit;">Nilai-nilai non-boolean perlu dikonversi ke boolean selama deserialisasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh saat ini, kami mengakui kecocokan berikut. </font><font style="vertical-align: inherit;">Nilai true berhubungan dengan: true (logis), true (string), 1 (string), 1 (numeric). </font><font style="vertical-align: inherit;">Nilai false sesuai dengan: false (logical), false (string), 0 (string), 0 (numeric), "" (string kosong). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, kami akan mendeklarasikan struktur target untuk deserialisasi. </font><font style="vertical-align: inherit;">Sebagai jenis bidang Aktif, kami segera menentukan jenis khusus CustomBool:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id     <span class="hljs-keyword">int</span>        <span class="hljs-string">`json:"id"`</span>
	Active CustomBool <span class="hljs-string">`json:"active"`</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CustomBool adalah struktur dengan satu bidang bool tunggal dari tipe bool:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> CustomBool <span class="hljs-keyword">struct</span> {<font></font>
	Bool <span class="hljs-keyword">bool</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menerapkan metode UnmarshalJSON untuk struktur ini. </font><font style="vertical-align: inherit;">Saya akan segera memberi Anda kode:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CustomBool)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">switch</span> <span class="hljs-keyword">string</span>(data) {
	<span class="hljs-keyword">case</span> <span class="hljs-string">`"true"`</span>, <span class="hljs-string">`true`</span>, <span class="hljs-string">`"1"`</span>, <span class="hljs-string">`1`</span>:<font></font>
		cb.Bool = <span class="hljs-literal">true</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">case</span> <span class="hljs-string">`"false"`</span>, <span class="hljs-string">`false`</span>, <span class="hljs-string">`"0"`</span>, <span class="hljs-string">`0`</span>, <span class="hljs-string">`""`</span>:<font></font>
		cb.Bool = <span class="hljs-literal">false</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomBool: parsing \""</span> + <span class="hljs-keyword">string</span>(data) + <span class="hljs-string">"\": unknown value"</span>)<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena bidang aktif dalam kasing kami memiliki jumlah nilai yang terbatas, kami dapat membuat keputusan dengan menggunakan sakelar sakelar bertukar tentang berapa nilai bidang Bool dari struktur CustomBool. Untuk memeriksa, Anda hanya perlu dua blok kasus. Di blok pertama, kami memeriksa nilai true, di blok kedua - false.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat merekam nilai yang mungkin, Anda harus memperhatikan peran kerikil (ini adalah tanda kutip pada tombol dengan huruf E dalam tata letak bahasa Inggris). Karakter ini memungkinkan Anda menghindari tanda kutip ganda dalam sebuah string. Untuk lebih jelasnya, saya membingkai nilai dengan tanda kutip dan tanpa tanda kutip dengan simbol ini. Jadi, `false` sesuai dengan string false (tanpa tanda kutip, ketik bool in json), dan` false 'sesuai dengan string "false" (dengan tanda kutip, ketik string dalam json). Hal yang sama dengan nilai `1` dan` 1` `Yang pertama adalah angka 1 (ditulis dalam json tanpa tanda kutip), yang kedua adalah string" 1 "(dalam json ditulis dengan tanda kutip). Entri ini `` "` adalah string kosong, mis., Dalam format json terlihat seperti ini: "". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nilai yang sesuai (benar atau salah) ditulis langsung ke bidang Bool dari struktur CustomBool:</font></font><br>
<br>
<pre><code class="go hljs">cb.Bool = <span class="hljs-literal">true</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di blok defaul, kami mengembalikan kesalahan yang menyatakan bahwa bidang memiliki nilai yang tidak diketahui:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomBool: parsing \""</span> + <span class="hljs-keyword">string</span>(data) + <span class="hljs-string">"\": unknown value"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita dapat menerapkan metode json.Unmarshal ke kode json kita, dan nilai-nilai bidang aktif akan dikonversi ke tipe bool primitif. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menerapkan metode MarshalJSON untuk struktur CustomBool:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb CustomBool)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> {<font></font>
	json, err := json.Marshal(cb.Bool)<font></font>
	<span class="hljs-keyword">return</span> json, err<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak ada yang baru di sini. </font><font style="vertical-align: inherit;">Metode ini membuat serial bidang Bool dari struktur CustomBool. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut adalah kode lengkap yang menampilkan hasil serialisasi dan deserialisasi (pengecekan kesalahan dihilangkan untuk singkatnya):</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"encoding/json"</span>
	<span class="hljs-string">"errors"</span>
	<span class="hljs-string">"fmt"</span><font></font>
)<font></font>
<font></font>
<span class="hljs-keyword">type</span> CustomBool <span class="hljs-keyword">struct</span> {<font></font>
	Bool <span class="hljs-keyword">bool</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CustomBool)</span> <span class="hljs-title">UnmarshalJSON</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">switch</span> <span class="hljs-keyword">string</span>(data) {
	<span class="hljs-keyword">case</span> <span class="hljs-string">`"true"`</span>, <span class="hljs-string">`true`</span>, <span class="hljs-string">`"1"`</span>, <span class="hljs-string">`1`</span>:<font></font>
		cb.Bool = <span class="hljs-literal">true</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">case</span> <span class="hljs-string">`"false"`</span>, <span class="hljs-string">`false`</span>, <span class="hljs-string">`"0"`</span>, <span class="hljs-string">`0`</span>, <span class="hljs-string">`""`</span>:<font></font>
		cb.Bool = <span class="hljs-literal">false</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">"CustomBool: parsing \""</span> + <span class="hljs-keyword">string</span>(data) + <span class="hljs-string">"\": unknown value"</span>)<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb CustomBool)</span> <span class="hljs-title">MarshalJSON</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> {<font></font>
	json, err := json.Marshal(cb.Bool)<font></font>
	<span class="hljs-keyword">return</span> json, err<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">type</span> Target <span class="hljs-keyword">struct</span> {<font></font>
	Id     <span class="hljs-keyword">int</span>        <span class="hljs-string">`json:"id"`</span>
	Active CustomBool <span class="hljs-string">`json:"active"`</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	jsonString := <span class="hljs-string">`[{"id":1,"active":true},
					{"id":2,"active":"true"},
					{"id":3,"active":"1"},
					{"id":4,"active":1},
					{"id":5,"active":false},
					{"id":6,"active":"false"},
					{"id":7,"active":"0"},
					{"id":8,"active":0},
					{"id":9,"active":""}]`</span><font></font>
<font></font>
	targets := []Target{}<font></font>
<font></font>
	_ = json.Unmarshal([]<span class="hljs-keyword">byte</span>(jsonString), &amp;targets)<font></font>
<font></font>
	<span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> targets {<font></font>
		fmt.Println(t.Id, <span class="hljs-string">"-"</span>, t.Active.Bool)<font></font>
	}<font></font>
<font></font>
	jsonStringNew, _ := json.Marshal(targets)<font></font>
	fmt.Println(<span class="hljs-keyword">string</span>(jsonStringNew))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasil Eksekusi Kode:</font></font><br>
<br>
<pre><code class="bash hljs">1 - <span class="hljs-literal">true</span>
2 - <span class="hljs-literal">true</span>
3 - <span class="hljs-literal">true</span>
4 - <span class="hljs-literal">true</span>
5 - <span class="hljs-literal">false</span>
6 - <span class="hljs-literal">false</span>
7 - <span class="hljs-literal">false</span>
8 - <span class="hljs-literal">false</span>
9 - <span class="hljs-literal">false</span>
[{<span class="hljs-string">"id"</span>:1,<span class="hljs-string">"active"</span>:<span class="hljs-literal">true</span>},{<span class="hljs-string">"id"</span>:2,<span class="hljs-string">"active"</span>:<span class="hljs-literal">true</span>},{<span class="hljs-string">"id"</span>:3,<span class="hljs-string">"active"</span>:<span class="hljs-literal">true</span>},{<span class="hljs-string">"id"</span>:4,<span class="hljs-string">"active"</span>:<span class="hljs-literal">true</span>},{<span class="hljs-string">"id"</span>:5,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>},{<span class="hljs-string">"id"</span>:6,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>},{<span class="hljs-string">"id"</span>:7,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>},{<span class="hljs-string">"id"</span>:8,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>},{<span class="hljs-string">"id"</span>:9,<span class="hljs-string">"active"</span>:<span class="hljs-literal">false</span>}]</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">temuan</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama. </font><font style="vertical-align: inherit;">Mengganti metode MarshalJSON dan UnmarshalJSON untuk tipe data arbitrer memungkinkan Anda untuk menyesuaikan serialisasi dan deserialisasi bidang kode json tertentu. </font><font style="vertical-align: inherit;">Selain kasus penggunaan yang ditunjukkan, fungsi-fungsi ini digunakan untuk bekerja dengan bidang nullable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kedua. </font><font style="vertical-align: inherit;">Format penyandian teks json adalah alat yang banyak digunakan untuk bertukar informasi, dan salah satu kelebihannya dari format lain adalah ketersediaan tipe data. </font><font style="vertical-align: inherit;">Kepatuhan dengan tipe-tipe ini harus dipantau dengan ketat.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id502154/index.html">Menulis Autotests Secara Efektif - Tes subkutan</a></li>
<li><a href="../id502156/index.html">Rambler v. NGINX Kasus: Resiko Pidana Digitalisasi Roundtable 16 Mei</a></li>
<li><a href="../id502158/index.html">Bagaimana mengatur pengujian untuk mempercepat dan menstabilkan rilis produk. Bagian 2</a></li>
<li><a href="../id502160/index.html">Pengembangan aplikasi seluler khusus tidak mahal: kenyataan atau ilusi</a></li>
<li><a href="../id502166/index.html">Hantu Windows 3.1</a></li>
<li><a href="../id502178/index.html">OVirt dalam 2 jam. Bagian 3. Pengaturan lanjutan</a></li>
<li><a href="../id502180/index.html">Hari perimeter menghilang. Solusi Keamanan dari Microsoft dan Mitra</a></li>
<li><a href="../id502182/index.html">Lagi tentang MikroTik atau SOCKS5 yang sudah lama ditunggu-tunggu</a></li>
<li><a href="../id502186/index.html">Webinar. Keamanan Informasi: SOC karantina</a></li>
<li><a href="../id502196/index.html">В подходе к математике столетней давности найдены новые ключи к разгадке природы времени</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>