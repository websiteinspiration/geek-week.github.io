<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👏🏼 💇🏿 📳 iOSのルーティング：アプリケーションを書き直さないユニバーサルナビゲーション ♉️ 👩🏼‍🎤 🔷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="複数の画面で構成されるアプリケーションでは、そのコンポーネント間のナビゲーションを実装する必要があります。UIKitには、UINavigationControllerやUITabBarControllerのような非常に便利なコンテナコンポーネントと、柔軟なモーダル表示メソッドがあるので、これは問題に...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>iOSのルーティング：アプリケーションを書き直さないユニバーサルナビゲーション</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/483830/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数の画面で構成されるアプリケーションでは、そのコンポーネント間のナビゲーションを実装する必要があります。</font><font style="vertical-align: inherit;">UIKitには、UINavigationControllerやUITabBarControllerのような非常に便利なコンテナコンポーネントと、柔軟なモーダル表示メソッドがあるので、これは問題にはならないようです。適切なナビゲーションを適切なタイミングで使用してください。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-p/_m/o7/-p_mo7dpypo7hqv5qmd2layllfk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、アプリケーションがプッシュ通知またはリンクによって画面への遷移を表示するとすぐに、すべてが少し複雑になります。</font><font style="vertical-align: inherit;">すぐにたくさんの質問があります：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画面に表示されているビューコントローラーをどのように処理しますか？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテキストを切り替える方法（UITabBarControllerのアクティブなタブなど）？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在のナビゲーションスタックには適切な画面がありますか？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ナビゲーションはいつ無視すべきですか？</font></font></li>
</ul><br>
<a name="habracut"></a><br>
<img src="https://habrastorage.org/webt/rb/dr/zb/rbdrzb1qpjkgxw6zfclqjqtdstq.gif" width="300"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
iOSの開発では、Badooがこれらすべての問題に遭遇しました。</font><font style="vertical-align: inherit;">その結果、すべての新製品で使用するナビゲーション用のコンポーネントのライブラリでソリューションメソッドを設計しました。</font><font style="vertical-align: inherit;">この記事では、私たちのアプローチについて詳しく説明します。</font><font style="vertical-align: inherit;">記述されたプラクティスの適用例は、小さな</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デモプロジェクトで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見ることができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちの問題</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの場合、ナビゲーションの問題は、アプリケーションの画面の構造を認識し、特定のケースで何をするかを決定するグローバルコンポーネントを追加することによって解決されます。</font><font style="vertical-align: inherit;">画面の構造は、コントローラの現在の階層とアプリケーションのセクションにあるコンテナの存在に関する情報を意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Badooにも同様のコンポーネントがありました。 Facebookのかなり古いライブラリでも同様に機能しましたが、現在はパブリックリポジトリにありません。ナビゲーションは、アプリケーション画面に関連付けられたURLに基​​づいていました。基本的に、すべてのロジックは1つのクラスに含まれていました。これは、タブバーの存在と、Badooに固有のその他の機能に関連付けられていました。このコンポーネントの複雑さと接続性は非常に高かったため、ナビゲーションロジックの変更を必要とするタスクの解決には、計画より数倍長い時間がかかる可能性があります。このクラスのテスト容易性も大きな疑問を投げかけました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコンポーネントは、アプリケーションが1つしかなかったときに作成されました。将来的にはまったく異なるいくつかの製品を開発することは想像できません（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バンブル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルーメン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">など）。</font><font style="vertical-align: inherit;">このため、最も成熟したアプリケーションBadooのナビゲーターを他の製品で使用することは不可能であり、各チームは何か新しいものを考え出す必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、特定のアプリケーション向けに新しいアプローチも強化されています。</font><font style="vertical-align: inherit;">プロジェクトの数が増えるにつれて問題が明らかになり、ユニバーサルナビゲーションロジックを含む特定のコンポーネントセットを提供するライブラリを作成するというアイデアが浮かび上がりました。</font><font style="vertical-align: inherit;">これにより、新製品における同様の機能の実装時間を最小限に抑えることができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユニバーサルルーターを実装</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グローバルナビゲーターが解決する主なタスクはそれほど多くありません：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在アクティブな画面を見つけます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どういうわけかアクティブな画面のタイプとその内容を表示する必要があるものと比較します。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要に応じて遷移を実行します（遷移のシーケンス）。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクの定式化は少し抽象的に見えるかもしれませんが、ロジックの普遍化を可能にするのはこの抽象化です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.アクティブな画面検索</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のタスクは非常に単純に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見え</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">画面の階層全体を調べて、一番上の</font><i><font style="vertical-align: inherit;">UIViewController</font></i><font style="vertical-align: inherit;">を見つける</font><i><font style="vertical-align: inherit;">だけ</font></i><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vw/dj/er/vwdjerugihaukbnwqjri1cd4wu0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトのインターフェースは次のようになります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TopViewControllerProvider</span> </span>{
    <span class="hljs-keyword">var</span> topViewController: <span class="hljs-type">UIViewController?</span> { <span class="hljs-keyword">get</span> }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、階層のルート要素を決定する方法と、UIPageViewControllerやアプリケーション固有のコンテナーなどのコンテナー画面をどのように処理するかは明確ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルート要素を決定する最も簡単なオプションは、アクティブな画面からルートコントローラーを取得することです。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">UIApplication</span>.shared.windows.first { $<span class="hljs-number">0</span>.isKeyWindow }?.rootViewController</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは、複数のウィンドウがあるアプリケーションでは常に機能するとは限りません。</font><font style="vertical-align: inherit;">ただし、これはかなりまれなケースであり、目的のウィンドウをパラメーターとして明示的に渡すことで問題を解決できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナー画面の問題は、アクティブな画面を取得するためのメソッドが含まれる特別なプロトコルを作成することで解決できます。または、上記のプロトコルを使用できます。</font><font style="vertical-align: inherit;">アプリケーションで使用されるすべてのコンテナコントローラは、このプロトコルを実装する必要があります。</font><font style="vertical-align: inherit;">たとえば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UITabBarControllerの場合、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装は次のようになります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">UITabBarController</span>: <span class="hljs-title">TopViewControllerProvider</span> </span>{
    <span class="hljs-keyword">var</span> topViewController: <span class="hljs-type">UIViewController?</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.selectedViewController<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
階層全体を移動してトップ画面を表示するだけです。</font><font style="vertical-align: inherit;">次のコントローラーがTopViewControllerProviderを実装する場合、宣言されたメソッドを介して、その上に表示される画面を取得します。</font><font style="vertical-align: inherit;">それ以外の場合、その上に表示されるコントローラーは、モーダルでチェックされます（ある場合）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.現在のコンテキスト</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在のコンテキストを決定するタスクは、はるかに複雑に見えます。</font><font style="vertical-align: inherit;">画面のタイプと、場合によっては画面に表示される情報を判別したいと考えています。</font><font style="vertical-align: inherit;">この情報を含む構造を作成するのは理にかなっているようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、どのタイプにオブジェクトプロパティが必要ですか？</font><font style="vertical-align: inherit;">私たちの最終的な目標は、コンテキストを表示する必要があるものと比較することです</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そのため、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Equatable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロトコルを実装する</font><i><font style="vertical-align: inherit;">必要があり</font></i><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、ジェネリック型を通じて実装できます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ViewControllerContext</span>&lt;<span class="hljs-title">ScreenType</span>: <span class="hljs-title">Equatable</span>, <span class="hljs-title">InfoType</span>: <span class="hljs-title">Equatable</span>&gt;: <span class="hljs-title">Equatable</span> </span>{
    <span class="hljs-keyword">let</span> screenType: <span class="hljs-type">ScreenType</span>
    <span class="hljs-keyword">let</span> info: <span class="hljs-type">InfoType?</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、Swiftの特性により、このタイプの使用には一定の制限が課されます。</font><font style="vertical-align: inherit;">問題を回避するために、アプリケーションのこの構造の外観は少し異なります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ViewControllerContextInfo</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isEqual</span><span class="hljs-params">(to info: ViewControllerContextInfo?)</span></span> -&gt; <span class="hljs-type">Bool</span><font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ViewControllerContext</span>: <span class="hljs-title">Equatable</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> screenType: <span class="hljs-type">String</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">let</span> info: <span class="hljs-type">ViewControllerContextInfo?</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つのオプションは、新しいSwift機能の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opaque Typesを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">利用することですが、これはiOS 13以降でのみ利用できます。これは、多くの製品ではまだ受け入れられません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテキスト比較の実装は非常に明白です。</font><font style="vertical-align: inherit;">既にEquatableを実装している型に対してisEqual関数を記述しないようにするために、今度はSwiftの利点を使用して簡単なトリックを実行できます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewControllerContextInfo</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">Equatable</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isEqual</span><span class="hljs-params">(to info: ViewControllerContextInfo?)</span></span> -&gt; <span class="hljs-type">Bool</span> {
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> info = info <span class="hljs-keyword">as</span>? <span class="hljs-type">Self</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span> == info<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すばらしい、比較するオブジェクトがあります。</font><font style="vertical-align: inherit;">しかし、どうすれば</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UIViewControllerに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関連付けることができます</font><font style="vertical-align: inherit;">か？</font><font style="vertical-align: inherit;">方法の1つは、</font><font style="vertical-align: inherit;">Objective-C言語の関数である場合に役立つ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関連オブジェクト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">すること</font></a><font style="vertical-align: inherit;">です。しかし、最初はそれほど明確ではなく、次に、通常、一部のアプリケーション画面のコンテキストのみを比較します。</font><font style="vertical-align: inherit;">したがって、プロトコルの作成は良い考えに見えます：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ViewControllerContextHolder</span> </span>{
    <span class="hljs-keyword">var</span> currentContext: <span class="hljs-type">ViewControllerContext?</span> { <span class="hljs-keyword">get</span> }<font></font>
}</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要な画面でのみその実装。</font><font style="vertical-align: inherit;">アクティブな画面がこのプロトコルを実装していない場合、その内容は重要ではないと見なされ、新しい画面を表示するときに考慮されません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.遷移の実行</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに持っているものを見てみましょう。</font><font style="vertical-align: inherit;">特定のデータ構造の形式でアクティブな画面に関する情報をいつでも取得する機能。</font><font style="vertical-align: inherit;">オープンURL、プッシュ通知、またはナビゲーションを開始する別の方法で外部から受け取った情報。同じタイプの構造に変換でき、ナビゲーションインテントとして機能します。</font><font style="vertical-align: inherit;">トップ画面にすでに必要な情報が表示されている場合は、ナビゲーションを無視するか、画面のコンテンツを更新できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wl/wq/lx/wlwqlxy8knlnfjgy6sg-gmnycm4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、移行自体はどうですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントを作成するのが論理的です（</font><b><font style="vertical-align: inherit;">ルーター</font></b><font style="vertical-align: inherit;">と呼びましょう）</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、入力で表示する必要があるものを受け入れ、すでに表示されているものと比較して、遷移または遷移のシーケンスを実行します。また、ルーターには、情報とアプリケーションのステータスを処理および検証するための一般的なロジックが含まれている場合があります。主なことは、このコンポーネントにドメインまたはアプリケーション機能に固有のロジックを含めるべきではないということです。このルールを順守すると、さまざまなアプリケーションで再利用でき、保守も容易になります。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなプロトコルの基本的なインターフェース宣言は次のようになります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ViewControllerContextRouterProtocol</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">navigateToContext</span><span class="hljs-params">(<span class="hljs-number">_</span> context: ViewControllerContext, animated: Bool)</span></span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテキストのシーケンスを渡すことにより、上記の関数を一般化できます。これは実装に大きな影響を与えません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ナビゲーションデータのみがその入力で受信されるため、ルーターにコントローラーファクトリが必要であることは明らかです。ファクトリ内で個別の画面を作成する必要があります。転送されたコンテキストに基づいてモジュール全体を作成することもできます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">screenType</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールドで</font><font style="vertical-align: inherit;">は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情報</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールドから、作成する画面を決定でき</font><font style="vertical-align: inherit;">ます。事前に入力する必要があるデータは次のとおりです。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ViewControllersByContextFactory</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewController</span><span class="hljs-params">(<span class="hljs-keyword">for</span> context: ViewControllerContext)</span></span> -&gt; <span class="hljs-type">UIViewController?</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションがSnapchatクローンではない場合、新しいコントローラーを表示するために使用されるメソッドの数はほとんどありません。したがって、ほとんどのアプリケーションでは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UINavigationController</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタック</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">更新し</font><font style="vertical-align: inherit;">てモーダル画面を表示する</font><font style="vertical-align: inherit;">だけで十分</font><font style="vertical-align: inherit;">です。この場合、可能な型を使用して列挙型を定義できます。次に例を示します。</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NavigationType</span> </span>{
    <span class="hljs-keyword">case</span> modal
    <span class="hljs-keyword">case</span> navigationStack
    <span class="hljs-keyword">case</span> rootScreen<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画面の種類は、表示方法によって異なります。これがブロッキング通知の場合は、モーダルで表示する必要があります。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UINavigationController</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を介して別の画面を既存のナビゲーションスタックに追加する必要がある場合があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定の画面をどのように表示するかを決めるのは、ルーター自体ではありません。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ViewControllerNavigationTypeProvider</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロトコルの下にルーター依存関係を追加し、</font><font style="vertical-align: inherit;">各アプリケーションに固有の必要なメソッドのセットを実装すると、この目標を達成できます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ViewControllerNavigationTypeProvider</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">navigationType</span><span class="hljs-params">(<span class="hljs-keyword">for</span> context: ViewControllerContext)</span></span> -&gt; <span class="hljs-type">NavigationType</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、アプリケーションの1つに新しいタイプのナビゲーションを導入したい場合はどうでしょうか。</font><font style="vertical-align: inherit;">列挙型に新しいオプションを追加する必要があり、他のすべてのアプリケーションはそれについて知っていますか？</font><font style="vertical-align: inherit;">おそらく、これはまさに私たちが目指していることですが、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開閉の原則</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を順守して</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">いる</font></a><font style="vertical-align: inherit;">場合は、</font><font style="vertical-align: inherit;">柔軟性を高めるために、遷移を実行できるオブジェクトのプロトコルを入力できます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ViewControllerContextTransition</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">navigate</span><span class="hljs-params">(from source: UIViewController?,
                  to destination: UIViewController,
                  animated: Bool)</span></span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ViewControllerNavigationTypeProvider</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は次のようになります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ViewControllerContextTransitionProvider</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">transition</span><span class="hljs-params">(<span class="hljs-keyword">for</span> context: ViewControllerContext)</span></span> -&gt; <span class="hljs-type">ViewControllerContextTransition</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、画面表示タイプの固定セットに限定されず、ルーター自体を変更せずにナビゲーション機能を拡張できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画面に切り替えるために新しい</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UIViewController</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を作成する必要がない場合もあります</font><font style="vertical-align: inherit;">。既存の</font><font style="vertical-align: inherit;">画面</font><font style="vertical-align: inherit;">に切り替えるだけです。最も明白な例は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UITabBarControllerで</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タブを切り替えること</font><i><font style="vertical-align: inherit;">です</font></i><font style="vertical-align: inherit;">。別の例は、同じコンテンツで新しい画面を作成する代わりに、示されているコントローラーのスタック内の既存の要素への遷移です。これを行うには、ルーターで、新しい</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UIViewControllerを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作成する前に</font><i><font style="vertical-align: inherit;">、</font></i><font style="vertical-align: inherit;">まずコンテキストを簡単に切り替えることができるかどうかを確認します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するには？さらなる抽象化！</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ViewControllerContextSwitcher</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canSwitch</span><span class="hljs-params">(to context: ViewControllerContext)</span></span> -&gt; <span class="hljs-type">Bool</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">switchContext</span><span class="hljs-params">(to context: ViewControllerContext, animated: Bool)</span></span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タブの場合、このプロトコルは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UITabBarViewController</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内に何が含まれているかを認識</font><font style="vertical-align: inherit;">し、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ViewControllerContext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を特定のタブ</font><font style="vertical-align: inherit;">にマップ</font><font style="vertical-align: inherit;">してタブを切り替える</font><font style="vertical-align: inherit;">ことができる</font><font style="vertical-align: inherit;">コンポーネントによって実装</font><font style="vertical-align: inherit;">でき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/r_/do/yv/r_doyvigb9gfjp-i8afhu-btglk.gif" width="300"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなオブジェクトのセットは、依存関係としてルーターに渡すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要約すると、コンテキスト処理アルゴリズムは次のようになります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">navigateToContext</span><span class="hljs-params">(<span class="hljs-number">_</span> context: ViewControllerContext, animated: Bool)</span></span> {
    <span class="hljs-keyword">let</span> topViewController = <span class="hljs-keyword">self</span>.topViewControllerProvider.topViewController
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> contextHolder = topViewController <span class="hljs-keyword">as</span>? <span class="hljs-type">ViewControllerContextHolder</span>, contextHolder.currentContext == context {
        <span class="hljs-keyword">return</span><font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> switcher = <span class="hljs-keyword">self</span>.contextSwitchers.first(<span class="hljs-keyword">where</span>: { $<span class="hljs-number">0</span>.canSwitch(to: context) }) {<font></font>
        switcher.switchContext(to: context, animated: animated)<font></font>
        <span class="hljs-keyword">return</span><font></font>
    }<font></font>
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> viewController = <span class="hljs-keyword">self</span>.viewControllersFactory.viewController(<span class="hljs-keyword">for</span>: context) <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
    <span class="hljs-keyword">let</span> navigation = <span class="hljs-keyword">self</span>.transitionProvider.navigation(<span class="hljs-keyword">for</span>: context)<font></font>
    navigation.navigate(from: <span class="hljs-keyword">self</span>.topViewControllerProvider.topViewController,<font></font>
                        to: viewController,<font></font>
                        animated: <span class="hljs-literal">true</span>)<font></font>
}</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルーターの依存関係図をUMLダイアグラムの形式で提示すると便利です</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jt/ic/gk/jticgkvmsmm5own334ql_uvq6mg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。結果のルーターは、自動的に、またはユーザーアクションによって開始される遷移に使用できます。</font><font style="vertical-align: inherit;">当社の製品では、ナビゲーションが自動的に行われない場合、標準のシステム機能が使用され、ほとんどのモジュールはグローバルルーターの存在を認識しません。</font><font style="vertical-align: inherit;">ルーターがユーザーが現在表示している情報を常に見つけられるように、必要な場合は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ViewControllerContextHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロトコルの実装について覚えておくことは重要</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長所と短所</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近、私たちは説明したナビゲーション管理方法をBadoo製品に導入し始めました。</font><font style="vertical-align: inherit;">実装は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デモプロジェクト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">提示されたオプションよりもいくぶん複雑であることが判明したという事実にもかかわらず、</font><font style="vertical-align: inherit;">結果に満足しています。</font><font style="vertical-align: inherit;">説明したアプローチの利点と欠点を評価してみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
利点は次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">普遍 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代替セクションで提示されたオプションと比較した場合の実装の相対的な容易さ、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションのアーキテクチャと画面間の通常のナビゲーションの実装に制限がない。 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
短所の一部は長所の結果です。</font></font><br>
<br>
<ul>
<li>  ,    . E   , UIViewController     ,        -.  ,   ,       -,         ,    . </li>
<li>        ,       .</li>
</ul><br>
<br>
<h2></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチの代わりに、アクティブなモジュールの階層を手動で構築することもできます。</font><font style="vertical-align: inherit;">このようなソリューションの例は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コーディネーターパターンの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">実装です。</font></a><font style="vertical-align: inherit;">コーディネーターは、アクティブな画面を決定するための真実のソースとして機能するツリー構造を形成し、この画面またはその画面を表示するかどうかの決定のロジックは、コーディネーター自体に含まれます。</font><font style="vertical-align: inherit;">Androidチーム</font><font style="vertical-align: inherit;">が</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">使用し</font></a><font style="vertical-align: inherit;">て</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RIBs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アーキテクチャにも同様のアイデアがあります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
このような代替手段は、より柔軟な抽象化を提供しますが、アーキテクチャの均一性を必要とし、多くのアプリケーションにとって扱いにくい場合があります。</font><font style="vertical-align: inherit;">
そのような問題を解決するために別のアプローチをとった場合は、コメントで遠慮なく話してください。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja483820/index.html">クレジットの発行に影響するもの。住宅ローンのデフォルトのリスク競争の概要</a></li>
<li><a href="../ja483822/index.html">コードなしで作成できない5つのJavaScript機能</a></li>
<li><a href="../ja483824/index.html">私の5つのルールを学び、夢の仕事を手に入れ、前向きに考え、それを前進させる方法...</a></li>
<li><a href="../ja483826/index.html">Voアナログ出力を使用したCO2センサーモデルMH-Z19Bの接続</a></li>
<li><a href="../ja483828/index.html">輝きと貧困の原子交換</a></li>
<li><a href="../ja483834/index.html">Debian：単にi386をamd64に変える</a></li>
<li><a href="../ja483842/index.html">ホームクラウドの作成の歴史。パート5. 2019の更新-PHP 7.2、MariaDB 10.4およびNextcloud 17</a></li>
<li><a href="../ja483844/index.html">ロシアの信用および金融セクターにおける情報保護に関する規制文書の分析</a></li>
<li><a href="../ja483846/index.html">Linuxでの代替ウィンドウ管理</a></li>
<li><a href="../ja483850/index.html">鍋を燃やす神はいない</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>