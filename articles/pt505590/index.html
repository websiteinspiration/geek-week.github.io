<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíπ üç© üì∑ Como a computa√ß√£o em GPU literalmente me salvou no trabalho. Exemplo de Python üôçüèΩ üë®üèæ‚Äçüîß üë©üèø‚Äçü§ù‚Äçüë©üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! 
 
 Hoje, abordamos o t√≥pico mais relevante - Python, para trabalhar com a GPU. O autor considera um exemplo trivial em sua monstruosidade e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Como a computa√ß√£o em GPU literalmente me salvou no trabalho. Exemplo de Python</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/505590/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ol√° Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hoje, abordamos o t√≥pico mais relevante - Python, para trabalhar com a GPU. </font><font style="vertical-align: inherit;">O autor considera um exemplo trivial em sua monstruosidade e demonstra a solu√ß√£o, acompanhando-a com extensas listagens. </font><font style="vertical-align: inherit;">Gostar de ler!</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xb/mv/xr/xbmvxrrximpm1_fchk6fsi9v5fg.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nenhum de n√≥s, de uma forma ou de outra, ignorou o hype recente da computa√ß√£o em GPU. Antes de ler mais, explicarei: n√£o sou especialista em GPU. Minha jornada no mundo da GPU est√° apenas come√ßando. Hoje, por√©m, essa tecnologia atingiu tanto poder que, armada com ela, voc√™ pode resolver muitos problemas. Foi-me atribu√≠da uma tarefa no trabalho, a m√°quina passou horas nela e nenhum progresso foi vis√≠vel. Mas, assim que assumi a GPU - e o problema come√ßou a ser resolvido em segundos. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A tarefa, que levou aproximadamente 2 dias para ser conclu√≠da, consegui resolver em apenas 20 segundos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nas se√ß√µes a seguir, descreverei essa tarefa em detalhes. </font><font style="vertical-align: inherit;">Tamb√©m discutiremos como e quando usar a GPU para resolver esses problemas. </font><font style="vertical-align: inherit;">Ent√£o, lemos atentamente - acredite, voc√™ n√£o vai se arrepender. </font><font style="vertical-align: inherit;">Primeiro, vamos nos aprofundar nos detalhes da tarefa, depois nos familiarizarmos com a GPU e, finalmente, usaremos a GPU para resolver esse problema. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usarei a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> biblioteca Python </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Numba</font></a><font style="vertical-align: inherit;"> e a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU Nvidia Volta V100 de 16GB GPU</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Descri√ß√£o detalhada da tarefa</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No setor de varejo, voc√™ geralmente precisa procurar objetos semelhantes ou mais pr√≥ximos. </font><font style="vertical-align: inherit;">Recebi uma lista de posi√ß√µes, cada uma das quais representada por k atributos latentes. </font><font style="vertical-align: inherit;">Por isso, fui instru√≠do a encontrar as 3 principais posi√ß√µes mais semelhantes a cada uma das posi√ß√µes da lista. </font><font style="vertical-align: inherit;">A m√©trica de similaridade nesse problema foi escolhida similaridade de cosseno. </font><font style="vertical-align: inherit;">√â assim que meus dados eram. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/s1/02/if/s102ifuqgnhoe_pv81htzopsye4.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lista de itens de dados com 64 caracter√≠sticas latentes </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complexidade da tarefa</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Foi-me dada uma lista na qual havia cerca de dez posi√ß√µes. </font><font style="vertical-align: inherit;">Procurar as tr√™s posi√ß√µes mais semelhantes para cada uma delas exigiria a verifica√ß√£o da semelhan√ßa de cosseno com cada elemento da lista. </font><font style="vertical-align: inherit;">Isso resultaria em n * k opera√ß√µes, em que n √© o n√∫mero de posi√ß√µes ek s√£o os atributos de cada posi√ß√£o. </font><font style="vertical-align: inherit;">Seria necess√°rio obter o produto escalar dessa posi√ß√£o de cada uma das posi√ß√µes restantes na lista.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top_3_similar_items</span>(<span class="hljs-params">X,mindex</span>):</span> <span class="hljs-comment"># X   ,    -3 ,       'mindex'</span>
    SMALL = <span class="hljs-number">-9999.0</span> <span class="hljs-comment">#   ,         ( )</span>
    first_best_val = SMALL <span class="hljs-comment">#         </span>
    first_best_index = <span class="hljs-number">-1</span> <span class="hljs-comment">#       </span>
    second_best_val = SMALL <span class="hljs-comment">#        </span>
    second_best_index = <span class="hljs-number">-1</span> <span class="hljs-comment">#       </span>
    third_best_val = SMALL <span class="hljs-comment">#        </span>
    third_best_index = <span class="hljs-number">-1</span> <span class="hljs-comment">#       </span>
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n): <span class="hljs-comment">#  n-  </span>
            <span class="hljs-keyword">if</span>(mindex==j):
                <span class="hljs-keyword">continue</span>
            tmp = np.dot(X[mindex],X[j])/(np.sqrt(np.sum(np.square(X[mindex]))) * np.sqrt(np.sum(np.square(X[j])))) <span class="hljs-comment">#   </span>
            <span class="hljs-keyword">if</span>(tmp&gt;=first_best_val):<font></font>
                third_best_val = second_best_val<font></font>
                third_best_index = second_best_index<font></font>
                second_best_val = first_best_val<font></font>
                second_best_index = first_best_index<font></font>
                first_best_val = tmp<font></font>
                first_best_index = j<font></font>
            <span class="hljs-keyword">elif</span>(tmp&gt;=second_best_val):<font></font>
                third_best_val = second_best_val<font></font>
                third_best_index = second_best_index<font></font>
                second_best_val = tmp<font></font>
                second_best_index = j<font></font>
            <span class="hljs-keyword">elif</span>(tmp&gt;third_best_val):<font></font>
                third_best_val = tmp<font></font>
                third_best_index = j<font></font>
    <span class="hljs-keyword">return</span> first_best_val,first_best_index,second_best_val,second_best_index,third_best_val,third_best_index <span class="hljs-comment">#   </span></code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥digo para encontrar tr√™s posi√ß√µes o mais semelhante poss√≠vel ao</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Agora, quando voc√™ encontra as 3 principais semelhantes para todas as posi√ß√µes na lista, a complexidade √© multiplicada por outro n. </font><font style="vertical-align: inherit;">A complexidade final √© O (n * n * k) = O (n¬≤k).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top_3_similar_all_items</span>(<span class="hljs-params">X</span>):</span> <span class="hljs-comment"># X   ,      3     </span>
    SMALL = <span class="hljs-number">-9999.99</span> <span class="hljs-comment">#   ,         ( )</span>
    first_best_index = np.zeros(n,dtype=int) <span class="hljs-comment">#        </span>
    first_best_val = np.zeros(n,dtype=float) <span class="hljs-comment">#       </span>
    second_best_index = np.zeros(n,dtype=int) <span class="hljs-comment">#        </span>
    second_best_val = np.zeros(n,dtype=float) <span class="hljs-comment">#       </span>
    third_best_index = np.zeros(n,dtype=int) <span class="hljs-comment">#        </span>
    third_best_val = np.zeros(n,dtype=float) <span class="hljs-comment">#       </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):
        <span class="hljs-comment"># Initialisation</span><font></font>
        first_best_val[i] = SMALL<font></font>
        first_best_index[i] = <span class="hljs-number">-1</span><font></font>
        second_best_val[i] = SMALL<font></font>
        second_best_index[i] = <span class="hljs-number">-1</span><font></font>
        third_best_val[i] = SMALL<font></font>
        third_best_index[i] = <span class="hljs-number">-1</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n):
            <span class="hljs-keyword">if</span>(i==j):
                <span class="hljs-keyword">continue</span>
            tmp = np.dot(X[i],X[j])/(np.sqrt(np.sum(np.square(X[i]))) * np.sqrt(np.sum(np.square(X[j])))) <span class="hljs-comment">#   </span>
            <span class="hljs-keyword">if</span>(tmp&gt;=first_best_val[i]):<font></font>
                third_best_val[i] = second_best_val[i]<font></font>
                third_best_index[i] = second_best_index[i]<font></font>
                second_best_val[i] = first_best_val[i]<font></font>
                second_best_index[i] = first_best_index[i]<font></font>
                first_best_val[i] = tmp<font></font>
                first_best_index[i] = j<font></font>
            <span class="hljs-keyword">elif</span>(tmp&gt;=second_best_val[i]):<font></font>
                third_best_val[i] = second_best_val[i]<font></font>
                third_best_index[i] = second_best_index[i]<font></font>
                second_best_val[i] = tmp<font></font>
                second_best_index[i] = j<font></font>
            <span class="hljs-keyword">elif</span>(tmp&gt;third_best_val[i]):<font></font>
                third_best_val[i] = tmp<font></font>
                third_best_index[i] = j<font></font>
    <span class="hljs-keyword">return</span> first_best_val,first_best_index,second_best_val,second_best_index,third_best_val,third_best_index <span class="hljs-comment">#   </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C√≥digo para encontrar as tr√™s posi√ß√µes mais semelhantes para cada posi√ß√£o na lista </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Execu√ß√£o de teste e avalia√ß√£o de tempo</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Eu executei o c√≥digo, tentando encontrar as 3 posi√ß√µes mais semelhantes de um subconjunto contendo n = 10¬≥ posi√ß√µes com k = 64. Foram necess√°rios 17 para concluir esta tarefa com o Python segundos a uma velocidade m√©dia de 3,7 * 10‚Å∂ opera√ß√µes por segundo. </font><font style="vertical-align: inherit;">O c√≥digo foi bem otimizado usando opera√ß√µes e matrizes Numpy. </font><font style="vertical-align: inherit;">Noto que todas essas opera√ß√µes s√£o executadas sequencialmente na CPU.</font></font><br>
<br>
<pre><code class="python hljs">%time first_best_val,first_best_index,second_best_val,second_best_index,third_best_val,third_best_index = top_3_similar_all_items(X)</code></pre><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corra para n = 10¬≥ posi√ß√µes</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/z7/fr/p9/z7frp96r6jga71hy_eh5kqc6soo.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Conclus√£o: o tempo que levou para n = 10¬≥ posi√ß√µes </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, aumentei o subconjunto de teste para n = 10‚Å¥ posi√ß√µes. Como a complexidade √© O (n¬≤k), o tempo de execu√ß√£o aumentou 100 vezes (desde que n aumentou 10 vezes). Foram necess√°rios 1700 segundos para concluir o c√≥digo = 28,33 minutos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1t/hz/we/1thzweestkdve12ggxihgenaisu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Conclus√£o: o tempo que levou para processar n = 10‚Å¥ posi√ß√µes </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, chegamos √† mais importante: estimar o tempo necess√°rio para processar uma lista completa de 10‚Åµ posi√ß√µes. Contando, vemos que a complexidade do tempo aumenta novamente em 100 vezes, uma vez que a complexidade do algoritmo √© O (n¬≤k). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tempo estimado = 1700 * 100 segundos = 2834 minutos = 47,2 horas ~ 2 dias. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oh meu Deus! Tanto tempo!!!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ provavelmente j√° percebeu que eu consegui fazer tudo muito rapidamente, usando o poder da GPU. </font><font style="vertical-align: inherit;">De fato, o ganho de tempo ao usar uma GPU √© simplesmente chocante. </font><font style="vertical-align: inherit;">Vou deixar os n√∫meros para um lanche, mas por enquanto sugiro que voc√™ se familiarize com o mundo da GPU.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Compara√ß√£o de CPU e GPU</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A Unidade Central de Processamento (CPU), em ess√™ncia, √© o c√©rebro de qualquer dispositivo de computa√ß√£o: executa as instru√ß√µes escritas no programa, executando controle, opera√ß√µes l√≥gicas e opera√ß√µes de entrada / sa√≠da. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â verdade que as CPUs modernas ainda n√£o t√™m muitos n√∫cleos, e a estrutura e o objetivo b√°sicos da CPU - o processamento de c√°lculos complexos - em ess√™ncia, n√£o mudaram. </font><font style="vertical-align: inherit;">De fato, a CPU √© mais adequada para resolver problemas que envolvem a an√°lise ou interpreta√ß√£o da l√≥gica complexa contida no c√≥digo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por sua vez, o processador gr√°fico (GPU) possui n√∫cleos l√≥gicos menores, por√©m muito maiores (estamos falando de dispositivos l√≥gicos aritm√©ticos (ALU), elementos de controle e mem√≥ria cache), projetados com a expectativa do processamento paralelo como um todo opera√ß√µes id√™nticas e relativamente simples.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dv/rj/_r/dvrj_rfbqkiabwugkvilkoka3oo.png"><br>
 <blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A GPU possui mais unidades l√≥gicas aritm√©ticas (ALUs) do que uma CPU t√≠pica; portanto, a capacidade de processar opera√ß√µes simples em paralelo foi aprimorada</font></font></blockquote><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura: Comparar CPU e GPU ~ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Image Source</font></font></a></i><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Quando usar a computa√ß√£o GPU </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A CPU √© mais adequada para tarefas lineares complexas. Apesar de os n√∫cleos da CPU serem mais poderosos, as GPUs permitem processar de maneira mais eficiente e r√°pida as tarefas relacionadas √† IA, aprendizado de m√°quina e aprendizado profundo. A GPU lida com cargas de trabalho paralelizando opera√ß√µes semelhantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A ideia de opera√ß√µes do ponto de vista da GPU: considere, por exemplo, a opera√ß√£o de encontrar uma palavra em um documento. Isso pode ser feito sequencialmente, classificando uma a uma todas as palavras do documento, em paralelo, ou seja, linha por linha ou com uma pesquisa por uma palavra espec√≠fica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A ideia de opera√ß√µes do ponto de vista da CPU - existem tais opera√ß√µes, por exemplo, o c√°lculo da s√©rie Fibonacci, que n√£o pode ser paralelo. Afinal, voc√™ pode encontrar o pr√≥ximo n√∫mero somente depois de calcular os dois anteriores. Tais opera√ß√µes s√£o mais adequadas para a CPU.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por sua vez, opera√ß√µes como adi√ß√£o e multiplica√ß√£o de matrizes s√£o facilmente executadas usando a GPU, uma vez que a maioria dessas opera√ß√µes em c√©lulas da matriz s√£o independentes umas das outras, s√£o de natureza semelhante e, portanto, podem ser paralelizadas.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Brevemente sobre CUDA</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CUDA √© uma plataforma de computa√ß√£o paralela e um modelo de API criado pela Nvidia. Usando esta API, voc√™ pode usar um processador que suporte gr√°ficos CUDA para uma ampla variedade de c√°lculos. Essa abordagem √© chamada GPGPU (computa√ß√£o n√£o especializada em GPUs). Aqui eles s√£o descritos em </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais detalhes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUMBA O</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Numba √© um compilador JIT de freeware que converte um subconjunto de Python e NumPy em c√≥digo de m√°quina r√°pido usando LLVM; isso √© feito usando o pacote llvmlite no Python. Este pacote oferece v√°rias op√ß√µes para paralelizar o c√≥digo Python para a CPU e a GPU, enquanto mudan√ßas m√≠nimas costumam ser suficientes no pr√≥prio c√≥digo. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veja mais</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trabalhando com o processador</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU Nvidia Volta V100 de 16GB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , usei a biblioteca Numba. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detalhes arquitet√¥nicos ~ Fluxos, blocos e grades A</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
CUDA organiza a computa√ß√£o paralela usando abstra√ß√µes como fluxos, blocos e grades. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluxo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Um fluxo CUDA √© uma cadeia de instru√ß√µes atribu√≠da que vem / atualiza o n√∫cleo CUDA (na verdade, √© apenas um pipeline). Em tempo real, at√© 32 threads podem existir no mesmo n√∫cleo CUDA (nesse caso, todos os links desse pipeline s√£o preenchidos). Esta √© a execu√ß√£o do kernel com o √≠ndice fornecido. Cada encadeamento usa seu √≠ndice para acessar os elementos na matriz de forma que todo o conjunto de encadeamentos dispon√≠veis processe todo o conjunto de dados. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quadra</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Este √© um grupo de threads. N√£o se pode dizer muito sobre a execu√ß√£o de encadeamentos em um bloco: eles podem ser executados sequencialmente ou em paralelo, ou sem nenhuma ordem espec√≠fica. Voc√™ pode coordenar threads, por exemplo, usando uma fun√ß√£o </font></font><code>_syncthreads()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que for√ßa uma thread a parar em um determinado ponto do kernel e aguarde at√© que todos os outros threads do mesmo bloco atinjam o mesmo ponto. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grade</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : este √© um grupo de blocos. N√£o h√° sincroniza√ß√£o entre os blocos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fu/q_/rm/fuq_rmemxkfpo8o9wkx4es362s8.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CUDA: threads, blocos, grades ~ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Mas onde exatamente s√£o executados threads, blocos e grades? No caso da arquitetura de GPU G80 da Nvidia, os c√°lculos s√£o aparentemente distribu√≠dos da seguinte forma: </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grade ‚Üí GPU: a grade inteira √© processada por um √∫nico processador de GPU.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bloco ‚Üí MP: O processador GPU √© organizado como uma cole√ß√£o de multiprocessadores, onde cada multiprocessador √© respons√°vel por processar um ou mais blocos na grade. </font><font style="vertical-align: inherit;">Um bloco nunca √© dividido entre v√°rios MPs. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fluxo ‚Üí PP: Cada MP √© subdividido em processadores de fluxo (PP) e cada PP processa um ou mais encadeamentos em um bloco. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peguei emprestado algum material deste </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">excelente artigo escrito</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Eu recomendo a leitura com cuidado.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Um programa simples para adicionar matrizes em Python usando a GPU</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como eu disse no in√≠cio, a ess√™ncia deste artigo √© ajudar um amplo p√∫blico a entender o poder da GPU e obter uma compreens√£o intuitiva de como usar a GPU para resolver tarefas di√°rias. Antes de come√ßar a escrever o c√≥digo para a GPU, talvez voc√™ precise fazer uma pesquisa preliminar. Para fazer isso, vamos dar um exemplo de um programa para adicionar matrizes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que tenhamos duas matrizes, 'a' e 'b' de tamanho 'n'. Queremos gerar uma matriz 'c' de modo que cada elemento da matriz c seja a soma dos elementos com os mesmos √≠ndices das matrizes 'a' e 'b'. Mas, neste caso, para resolver o problema, n√£o usaremos c√°lculos seq√ºenciais, mas paralelos que s√£o feitos usando a GPU.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos lan√ßar n threads / n√∫cleos. O √≠ndice sob o qual cada thread espec√≠fico funciona pode ser derivado da seguinte f√≥rmula: </font></font><br>
<br>
<code>index = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No caso de uma matriz bidimensional, o √≠ndice cont√©m dois componentes, ou seja, uma linha e uma coluna, que podem ser exibidas da seguinte maneira: </font><font style="vertical-align: inherit;">
Tamb√©m precisamos determinar o n√∫mero de threads por bloco, digamos, tpb e blocos por grade, digamos bpg. Usaremos n√∫meros padr√£o para eles. </font><font style="vertical-align: inherit;">
√â importante observar outro conceito importante aqui: quando qualquer c√°lculo tiver que ser realizado na GPU, os dados correspondentes dever√£o ser transferidos para a mem√≥ria global da GPU e os resultados dos c√°lculos poder√£o ser transferidos de volta para o host. Essas opera√ß√µes s√£o executadas usando as fun√ß√µes </font><font style="vertical-align: inherit;">e </font><font style="vertical-align: inherit;">fornecidas na biblioteca Python Numba.</font></font><br>
<br>
<code>row = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x<br>
col = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>cuda.to_device()</code><font style="vertical-align: inherit;"></font><code>copy_to_host()</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abaixo est√£o as implementa√ß√µes desta solu√ß√£o para a CPU e a GPU. </font><font style="vertical-align: inherit;">Veja as duas listagens para ver a diferen√ßa.</font></font><br>
<br>
<pre><code class="python hljs">c = np.zeroes(n)
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):<font></font>
    c[i] = a[i] + b[i]<font></font>
<span class="hljs-keyword">return</span> c</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementa√ß√£o sequencial para CPU.</font></font></i><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> numba <span class="hljs-keyword">import</span> cuda <span class="hljs-comment">#  Nvidia    GPU </span>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <font></font>
<font></font>
<span class="hljs-meta">@cuda.jit('void(float32[:], float32[:], float32[:])') #  Cuda </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cuda_addition</span>(<span class="hljs-params">a,b,c</span>):</span>
    <span class="hljs-string">"""     ."""</span>
    i = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x <span class="hljs-comment">#     </span>
    <span class="hljs-keyword">if</span> i &gt; c.size:
        <span class="hljs-keyword">return</span>
    c[i] = a[i]+b[i] <span class="hljs-comment">#Perform the addition</span><font></font>
 <font></font>
<span class="hljs-comment">#   </span><font></font>
device = cuda.get_current_device()<font></font>
<font></font>
<span class="hljs-comment">#     </span>
d_a = cuda.to_device(a)  <span class="hljs-comment">#      GPU</span>
d_b = cuda.to_device(b)  <span class="hljs-comment">#      GPU</span><font></font>
d_c = cuda.device_array_like(a)<font></font>
<font></font>
tpb = device.WARP_SIZE       <span class="hljs-comment">#blocksize     ,   = 32</span>
bpg = int(np.ceil((n)/tpb))  <span class="hljs-comment">#   </span><font></font>
<font></font>
cuda_addition[bpg, tpb](d_a, d_b, d_c) <span class="hljs-comment">#  </span><font></font>
<font></font>
<span class="hljs-comment">#      </span><font></font>
c = d_c.copy_to_host()<font></font>
print(c)<font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementa√ß√£o paralela para GPU </font></font></i><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Localizando as 3 posi√ß√µes mais semelhantes para cada posi√ß√£o na lista usando a GPU</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois de estudar minuciosamente a teoria e a pr√°tica, retornamos √† tarefa original: encontrar as 3 principais posi√ß√µes semelhantes para cada posi√ß√£o na lista usando c√°lculos da GPU. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, a id√©ia principal √© que tenhamos n posi√ß√µes e iniciaremos n threads. </font><font style="vertical-align: inherit;">Cada thread funcionar√° em paralelo com os outros e independentemente deles, calculando as 3 posi√ß√µes mais semelhantes para cada posi√ß√£o na lista. </font><font style="vertical-align: inherit;">Cada posi√ß√£o ser√° respons√°vel por um segmento.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> numba <span class="hljs-keyword">import</span> cuda <span class="hljs-comment"># Nvidia's GPU Library</span>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np 
<span class="hljs-keyword">import</span> math <span class="hljs-comment">#  , ,   , Numpy    GPU</span>
<span class="hljs-keyword">import</span> random<font></font>
<font></font>
<span class="hljs-comment">#                   </span>
<span class="hljs-meta">@cuda.jit('void(float32[:,:],float32[:],int32[:],float32[:],int32[:],float32[:],int32[:])') # CUDA Just-in-time Compiler</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cuda_dist</span>(<span class="hljs-params">X,first_best_val,first_best_index,second_best_val,second_best_index,third_best_val,third_best_index</span>):</span>
    <span class="hljs-string">"""     ."""</span>
    <span class="hljs-comment">#    </span><font></font>
    row = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x;<font></font>
    <span class="hljs-keyword">if</span> ((row &gt;= n)): <span class="hljs-comment">#      </span>
        <span class="hljs-keyword">return</span>
    first_best_val[row] = SMALL <span class="hljs-comment">#       </span>
    first_best_index[row] = <span class="hljs-number">-1</span> <span class="hljs-comment">#        </span>
    second_best_val[row] = SMALL <span class="hljs-comment">#       </span>
    second_best_index[row] = <span class="hljs-number">-1</span> <span class="hljs-comment">#        </span>
    third_best_val[row] = SMALL <span class="hljs-comment">#       </span>
    third_best_index[row] = <span class="hljs-number">-1</span> <span class="hljs-comment">#        </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):
        <span class="hljs-keyword">if</span>(i==row): <span class="hljs-comment">#   </span>
            <span class="hljs-keyword">continue</span>
        <span class="hljs-comment">#     ,        numpy   GPU</span>
        tmp = <span class="hljs-number">0.0</span>
        magnitude1 = <span class="hljs-number">0.0</span>
        magnitude2 = <span class="hljs-number">0.0</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(k):<font></font>
            tmp += X[row,j] * X[i,j]<font></font>
            magnitude1 += (X[row,j]* X[row,j])<font></font>
            magnitude2 += (X[i,j]* X[i,j])<font></font>
        tmp /= (math.sqrt(magnitude1)*math.sqrt(magnitude2)) <span class="hljs-comment">#    Dot_product(a,b) = a.b/(|a|*|b|)</span>
        <span class="hljs-keyword">if</span>(tmp&gt;=first_best_val[row]):<font></font>
            third_best_val[row] = second_best_val[row]<font></font>
            third_best_index[row] = second_best_index[row]<font></font>
            second_best_val[row] = first_best_val[row]<font></font>
            second_best_index[row] = first_best_index[row]<font></font>
            first_best_val[row] = tmp<font></font>
            first_best_index[row] = i<font></font>
        <span class="hljs-keyword">elif</span>(tmp&gt;=second_best_val[row]):<font></font>
            third_best_val[row] = second_best_val[row]<font></font>
            third_best_index[row] = second_best_index[row]<font></font>
            second_best_val[row] = tmp<font></font>
            second_best_index[row] = i<font></font>
        <span class="hljs-keyword">elif</span>(tmp&gt;third_best_val[row]):<font></font>
            third_best_val[row] = tmp<font></font>
            third_best_index[row] = i<font></font>
<font></font>
<span class="hljs-comment">#   </span><font></font>
device = cuda.get_current_device()<font></font>
<font></font>
d_x = cuda.to_device(X)<font></font>
d_first_val = cuda.device_array_like(first_val)<font></font>
d_first_index = cuda.device_array_like(first_index)<font></font>
d_second_val = cuda.device_array_like(second_val)<font></font>
d_second_index = cuda.device_array_like(second_index)<font></font>
d_third_val = cuda.device_array_like(third_val)<font></font>
d_third_index = cuda.device_array_like(third_index)<font></font>
<font></font>
<font></font>
tpb = device.WARP_SIZE       <span class="hljs-comment"># blocksize     </span>
bpg = int(np.ceil((n)/tpb))  <span class="hljs-comment">#   </span><font></font>
<font></font>
%time cuda_dist[bpg,tpb](d_x,d_first_val,d_first_index,d_second_val,d_second_index,d_third_val,d_third_index) <span class="hljs-comment">#  </span><font></font>
<font></font>
<span class="hljs-comment">#      </span><font></font>
first_val = d_first_val.copy_to_host()<font></font>
<span class="hljs-keyword">print</span> (first_val[:<span class="hljs-number">10</span>]) <span class="hljs-comment">#  10 </span>
<span class="hljs-comment">#      </span><font></font>
first_index = d_first_index.copy_to_host()<font></font>
<span class="hljs-keyword">print</span> (first_index[:<span class="hljs-number">10</span>]) <span class="hljs-comment">#  10 </span>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementa√ß√£o do c√≥digo da GPU para encontrar as 3 posi√ß√µes mais semelhantes ao </font></font></i><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tempo</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
gasto O tempo total gasto pela GPU para encontrar as 3 principais posi√ß√µes semelhantes para cada posi√ß√£o na lista foi de 481 ms (0,5 segundos). </font><font style="vertical-align: inherit;">Foram necess√°rios mais 20 segundos para copiar os dados do dispositivo para o host e do host para o dispositivo.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Conclus√£o</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A tarefa, cuja solu√ß√£o na CPU levaria cerca de 2 dias, na GPU foi resolvida em 20,5 segundos. </font><font style="vertical-align: inherit;">Isso foi poss√≠vel apenas devido √† natureza da tarefa. </font><font style="vertical-align: inherit;">A busca pelas 3 posi√ß√µes mais semelhantes para 'A' n√£o depende da busca pelas 3 posi√ß√µes mais semelhantes para 'B'. </font><font style="vertical-align: inherit;">Aproveitamos esse fato e aplicamos o paralelismo fornecido pela GPU para acelerar o processo. </font><font style="vertical-align: inherit;">O exemplo tamb√©m ilustra quais tipos de tarefas s√£o resolvidos de maneira mais conveniente com a ajuda de uma GPU poderosa.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. Agradecimentos</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este estudo foi realizado no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Walmart Labs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MLP (plataforma de aprendizado de m√°quina) </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Agradecemos a Ayush Kumar por ajudar a otimizar o fluxo de trabalho.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt505558/index.html">C√¢mera de aprendizado profundo do Amazon DeepLens. Descompactando, Conectando e Implementando um Projeto</a></li>
<li><a href="../pt505560/index.html">O segundo conjunto para um programa de gerenciamento de produtos no centro de CS: o que os alunos dizem</a></li>
<li><a href="../pt505568/index.html">Transferindo arquivos usando pipes e outras pequenas coisas no Delphi</a></li>
<li><a href="../pt505574/index.html">Aprendizagem refor√ßada atrav√©s de redes neurais competitivas</a></li>
<li><a href="../pt505580/index.html">Usando planilhas e software de computa√ß√£o para modelagem do Newsvendor</a></li>
<li><a href="../pt505592/index.html">Programando para BK0010 usando Android</a></li>
<li><a href="../pt505594/index.html">Como transformar um visitante do site em um cliente: um guia para criar formul√°rios de lead</a></li>
<li><a href="../pt505604/index.html">Vulnerabilidade ao v√≠cio</a></li>
<li><a href="../pt505608/index.html">Vuex - resolva uma disputa antiga com novos m√©todos</a></li>
<li><a href="../pt505612/index.html">MK-61: hist√≥ria, emula√ß√£o, dispositivo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>