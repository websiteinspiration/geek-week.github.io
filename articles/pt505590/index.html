<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💹 🍩 📷 Como a computação em GPU literalmente me salvou no trabalho. Exemplo de Python 🙍🏽 👨🏾‍🔧 👩🏿‍🤝‍👩🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! 
 
 Hoje, abordamos o tópico mais relevante - Python, para trabalhar com a GPU. O autor considera um exemplo trivial em sua monstruosidade e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Como a computação em GPU literalmente me salvou no trabalho. Exemplo de Python</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/505590/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Olá Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hoje, abordamos o tópico mais relevante - Python, para trabalhar com a GPU. </font><font style="vertical-align: inherit;">O autor considera um exemplo trivial em sua monstruosidade e demonstra a solução, acompanhando-a com extensas listagens. </font><font style="vertical-align: inherit;">Gostar de ler!</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xb/mv/xr/xbmvxrrximpm1_fchk6fsi9v5fg.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nenhum de nós, de uma forma ou de outra, ignorou o hype recente da computação em GPU. Antes de ler mais, explicarei: não sou especialista em GPU. Minha jornada no mundo da GPU está apenas começando. Hoje, porém, essa tecnologia atingiu tanto poder que, armada com ela, você pode resolver muitos problemas. Foi-me atribuída uma tarefa no trabalho, a máquina passou horas nela e nenhum progresso foi visível. Mas, assim que assumi a GPU - e o problema começou a ser resolvido em segundos. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A tarefa, que levou aproximadamente 2 dias para ser concluída, consegui resolver em apenas 20 segundos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nas seções a seguir, descreverei essa tarefa em detalhes. </font><font style="vertical-align: inherit;">Também discutiremos como e quando usar a GPU para resolver esses problemas. </font><font style="vertical-align: inherit;">Então, lemos atentamente - acredite, você não vai se arrepender. </font><font style="vertical-align: inherit;">Primeiro, vamos nos aprofundar nos detalhes da tarefa, depois nos familiarizarmos com a GPU e, finalmente, usaremos a GPU para resolver esse problema. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usarei a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> biblioteca Python </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Numba</font></a><font style="vertical-align: inherit;"> e a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU Nvidia Volta V100 de 16GB GPU</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Descrição detalhada da tarefa</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No setor de varejo, você geralmente precisa procurar objetos semelhantes ou mais próximos. </font><font style="vertical-align: inherit;">Recebi uma lista de posições, cada uma das quais representada por k atributos latentes. </font><font style="vertical-align: inherit;">Por isso, fui instruído a encontrar as 3 principais posições mais semelhantes a cada uma das posições da lista. </font><font style="vertical-align: inherit;">A métrica de similaridade nesse problema foi escolhida similaridade de cosseno. </font><font style="vertical-align: inherit;">É assim que meus dados eram. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/s1/02/if/s102ifuqgnhoe_pv81htzopsye4.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lista de itens de dados com 64 características latentes </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complexidade da tarefa</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Foi-me dada uma lista na qual havia cerca de dez posições. </font><font style="vertical-align: inherit;">Procurar as três posições mais semelhantes para cada uma delas exigiria a verificação da semelhança de cosseno com cada elemento da lista. </font><font style="vertical-align: inherit;">Isso resultaria em n * k operações, em que n é o número de posições ek são os atributos de cada posição. </font><font style="vertical-align: inherit;">Seria necessário obter o produto escalar dessa posição de cada uma das posições restantes na lista.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top_3_similar_items</span>(<span class="hljs-params">X,mindex</span>):</span> <span class="hljs-comment"># X   ,    -3 ,       'mindex'</span>
    SMALL = <span class="hljs-number">-9999.0</span> <span class="hljs-comment">#   ,         ( )</span>
    first_best_val = SMALL <span class="hljs-comment">#         </span>
    first_best_index = <span class="hljs-number">-1</span> <span class="hljs-comment">#       </span>
    second_best_val = SMALL <span class="hljs-comment">#        </span>
    second_best_index = <span class="hljs-number">-1</span> <span class="hljs-comment">#       </span>
    third_best_val = SMALL <span class="hljs-comment">#        </span>
    third_best_index = <span class="hljs-number">-1</span> <span class="hljs-comment">#       </span>
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n): <span class="hljs-comment">#  n-  </span>
            <span class="hljs-keyword">if</span>(mindex==j):
                <span class="hljs-keyword">continue</span>
            tmp = np.dot(X[mindex],X[j])/(np.sqrt(np.sum(np.square(X[mindex]))) * np.sqrt(np.sum(np.square(X[j])))) <span class="hljs-comment">#   </span>
            <span class="hljs-keyword">if</span>(tmp&gt;=first_best_val):<font></font>
                third_best_val = second_best_val<font></font>
                third_best_index = second_best_index<font></font>
                second_best_val = first_best_val<font></font>
                second_best_index = first_best_index<font></font>
                first_best_val = tmp<font></font>
                first_best_index = j<font></font>
            <span class="hljs-keyword">elif</span>(tmp&gt;=second_best_val):<font></font>
                third_best_val = second_best_val<font></font>
                third_best_index = second_best_index<font></font>
                second_best_val = tmp<font></font>
                second_best_index = j<font></font>
            <span class="hljs-keyword">elif</span>(tmp&gt;third_best_val):<font></font>
                third_best_val = tmp<font></font>
                third_best_index = j<font></font>
    <span class="hljs-keyword">return</span> first_best_val,first_best_index,second_best_val,second_best_index,third_best_val,third_best_index <span class="hljs-comment">#   </span></code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código para encontrar três posições o mais semelhante possível ao</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Agora, quando você encontra as 3 principais semelhantes para todas as posições na lista, a complexidade é multiplicada por outro n. </font><font style="vertical-align: inherit;">A complexidade final é O (n * n * k) = O (n²k).</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top_3_similar_all_items</span>(<span class="hljs-params">X</span>):</span> <span class="hljs-comment"># X   ,      3     </span>
    SMALL = <span class="hljs-number">-9999.99</span> <span class="hljs-comment">#   ,         ( )</span>
    first_best_index = np.zeros(n,dtype=int) <span class="hljs-comment">#        </span>
    first_best_val = np.zeros(n,dtype=float) <span class="hljs-comment">#       </span>
    second_best_index = np.zeros(n,dtype=int) <span class="hljs-comment">#        </span>
    second_best_val = np.zeros(n,dtype=float) <span class="hljs-comment">#       </span>
    third_best_index = np.zeros(n,dtype=int) <span class="hljs-comment">#        </span>
    third_best_val = np.zeros(n,dtype=float) <span class="hljs-comment">#       </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):
        <span class="hljs-comment"># Initialisation</span><font></font>
        first_best_val[i] = SMALL<font></font>
        first_best_index[i] = <span class="hljs-number">-1</span><font></font>
        second_best_val[i] = SMALL<font></font>
        second_best_index[i] = <span class="hljs-number">-1</span><font></font>
        third_best_val[i] = SMALL<font></font>
        third_best_index[i] = <span class="hljs-number">-1</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n):
            <span class="hljs-keyword">if</span>(i==j):
                <span class="hljs-keyword">continue</span>
            tmp = np.dot(X[i],X[j])/(np.sqrt(np.sum(np.square(X[i]))) * np.sqrt(np.sum(np.square(X[j])))) <span class="hljs-comment">#   </span>
            <span class="hljs-keyword">if</span>(tmp&gt;=first_best_val[i]):<font></font>
                third_best_val[i] = second_best_val[i]<font></font>
                third_best_index[i] = second_best_index[i]<font></font>
                second_best_val[i] = first_best_val[i]<font></font>
                second_best_index[i] = first_best_index[i]<font></font>
                first_best_val[i] = tmp<font></font>
                first_best_index[i] = j<font></font>
            <span class="hljs-keyword">elif</span>(tmp&gt;=second_best_val[i]):<font></font>
                third_best_val[i] = second_best_val[i]<font></font>
                third_best_index[i] = second_best_index[i]<font></font>
                second_best_val[i] = tmp<font></font>
                second_best_index[i] = j<font></font>
            <span class="hljs-keyword">elif</span>(tmp&gt;third_best_val[i]):<font></font>
                third_best_val[i] = tmp<font></font>
                third_best_index[i] = j<font></font>
    <span class="hljs-keyword">return</span> first_best_val,first_best_index,second_best_val,second_best_index,third_best_val,third_best_index <span class="hljs-comment">#   </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Código para encontrar as três posições mais semelhantes para cada posição na lista </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Execução de teste e avaliação de tempo</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Eu executei o código, tentando encontrar as 3 posições mais semelhantes de um subconjunto contendo n = 10³ posições com k = 64. Foram necessários 17 para concluir esta tarefa com o Python segundos a uma velocidade média de 3,7 * 10⁶ operações por segundo. </font><font style="vertical-align: inherit;">O código foi bem otimizado usando operações e matrizes Numpy. </font><font style="vertical-align: inherit;">Noto que todas essas operações são executadas sequencialmente na CPU.</font></font><br>
<br>
<pre><code class="python hljs">%time first_best_val,first_best_index,second_best_val,second_best_index,third_best_val,third_best_index = top_3_similar_all_items(X)</code></pre><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corra para n = 10³ posições</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/z7/fr/p9/z7frp96r6jga71hy_eh5kqc6soo.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Conclusão: o tempo que levou para n = 10³ posições </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, aumentei o subconjunto de teste para n = 10⁴ posições. Como a complexidade é O (n²k), o tempo de execução aumentou 100 vezes (desde que n aumentou 10 vezes). Foram necessários 1700 segundos para concluir o código = 28,33 minutos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1t/hz/we/1thzweestkdve12ggxihgenaisu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Conclusão: o tempo que levou para processar n = 10⁴ posições </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, chegamos à mais importante: estimar o tempo necessário para processar uma lista completa de 10⁵ posições. Contando, vemos que a complexidade do tempo aumenta novamente em 100 vezes, uma vez que a complexidade do algoritmo é O (n²k). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tempo estimado = 1700 * 100 segundos = 2834 minutos = 47,2 horas ~ 2 dias. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oh meu Deus! Tanto tempo!!!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você provavelmente já percebeu que eu consegui fazer tudo muito rapidamente, usando o poder da GPU. </font><font style="vertical-align: inherit;">De fato, o ganho de tempo ao usar uma GPU é simplesmente chocante. </font><font style="vertical-align: inherit;">Vou deixar os números para um lanche, mas por enquanto sugiro que você se familiarize com o mundo da GPU.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Comparação de CPU e GPU</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A Unidade Central de Processamento (CPU), em essência, é o cérebro de qualquer dispositivo de computação: executa as instruções escritas no programa, executando controle, operações lógicas e operações de entrada / saída. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É verdade que as CPUs modernas ainda não têm muitos núcleos, e a estrutura e o objetivo básicos da CPU - o processamento de cálculos complexos - em essência, não mudaram. </font><font style="vertical-align: inherit;">De fato, a CPU é mais adequada para resolver problemas que envolvem a análise ou interpretação da lógica complexa contida no código.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por sua vez, o processador gráfico (GPU) possui núcleos lógicos menores, porém muito maiores (estamos falando de dispositivos lógicos aritméticos (ALU), elementos de controle e memória cache), projetados com a expectativa do processamento paralelo como um todo operações idênticas e relativamente simples.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dv/rj/_r/dvrj_rfbqkiabwugkvilkoka3oo.png"><br>
 <blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A GPU possui mais unidades lógicas aritméticas (ALUs) do que uma CPU típica; portanto, a capacidade de processar operações simples em paralelo foi aprimorada</font></font></blockquote><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura: Comparar CPU e GPU ~ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Image Source</font></font></a></i><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Quando usar a computação GPU </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A CPU é mais adequada para tarefas lineares complexas. Apesar de os núcleos da CPU serem mais poderosos, as GPUs permitem processar de maneira mais eficiente e rápida as tarefas relacionadas à IA, aprendizado de máquina e aprendizado profundo. A GPU lida com cargas de trabalho paralelizando operações semelhantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A ideia de operações do ponto de vista da GPU: considere, por exemplo, a operação de encontrar uma palavra em um documento. Isso pode ser feito sequencialmente, classificando uma a uma todas as palavras do documento, em paralelo, ou seja, linha por linha ou com uma pesquisa por uma palavra específica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A ideia de operações do ponto de vista da CPU - existem tais operações, por exemplo, o cálculo da série Fibonacci, que não pode ser paralelo. Afinal, você pode encontrar o próximo número somente depois de calcular os dois anteriores. Tais operações são mais adequadas para a CPU.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por sua vez, operações como adição e multiplicação de matrizes são facilmente executadas usando a GPU, uma vez que a maioria dessas operações em células da matriz são independentes umas das outras, são de natureza semelhante e, portanto, podem ser paralelizadas.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Brevemente sobre CUDA</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CUDA é uma plataforma de computação paralela e um modelo de API criado pela Nvidia. Usando esta API, você pode usar um processador que suporte gráficos CUDA para uma ampla variedade de cálculos. Essa abordagem é chamada GPGPU (computação não especializada em GPUs). Aqui eles são descritos em </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais detalhes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUMBA O</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Numba é um compilador JIT de freeware que converte um subconjunto de Python e NumPy em código de máquina rápido usando LLVM; isso é feito usando o pacote llvmlite no Python. Este pacote oferece várias opções para paralelizar o código Python para a CPU e a GPU, enquanto mudanças mínimas costumam ser suficientes no próprio código. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veja mais</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trabalhando com o processador</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU Nvidia Volta V100 de 16GB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , usei a biblioteca Numba. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detalhes arquitetônicos ~ Fluxos, blocos e grades A</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
CUDA organiza a computação paralela usando abstrações como fluxos, blocos e grades. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluxo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Um fluxo CUDA é uma cadeia de instruções atribuída que vem / atualiza o núcleo CUDA (na verdade, é apenas um pipeline). Em tempo real, até 32 threads podem existir no mesmo núcleo CUDA (nesse caso, todos os links desse pipeline são preenchidos). Esta é a execução do kernel com o índice fornecido. Cada encadeamento usa seu índice para acessar os elementos na matriz de forma que todo o conjunto de encadeamentos disponíveis processe todo o conjunto de dados. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quadra</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Este é um grupo de threads. Não se pode dizer muito sobre a execução de encadeamentos em um bloco: eles podem ser executados sequencialmente ou em paralelo, ou sem nenhuma ordem específica. Você pode coordenar threads, por exemplo, usando uma função </font></font><code>_syncthreads()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que força uma thread a parar em um determinado ponto do kernel e aguarde até que todos os outros threads do mesmo bloco atinjam o mesmo ponto. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grade</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : este é um grupo de blocos. Não há sincronização entre os blocos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fu/q_/rm/fuq_rmemxkfpo8o9wkx4es362s8.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CUDA: threads, blocos, grades ~ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Mas onde exatamente são executados threads, blocos e grades? No caso da arquitetura de GPU G80 da Nvidia, os cálculos são aparentemente distribuídos da seguinte forma: </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grade → GPU: a grade inteira é processada por um único processador de GPU.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bloco → MP: O processador GPU é organizado como uma coleção de multiprocessadores, onde cada multiprocessador é responsável por processar um ou mais blocos na grade. </font><font style="vertical-align: inherit;">Um bloco nunca é dividido entre vários MPs. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fluxo → PP: Cada MP é subdividido em processadores de fluxo (PP) e cada PP processa um ou mais encadeamentos em um bloco. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peguei emprestado algum material deste </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">excelente artigo escrito</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Eu recomendo a leitura com cuidado.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Um programa simples para adicionar matrizes em Python usando a GPU</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como eu disse no início, a essência deste artigo é ajudar um amplo público a entender o poder da GPU e obter uma compreensão intuitiva de como usar a GPU para resolver tarefas diárias. Antes de começar a escrever o código para a GPU, talvez você precise fazer uma pesquisa preliminar. Para fazer isso, vamos dar um exemplo de um programa para adicionar matrizes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que tenhamos duas matrizes, 'a' e 'b' de tamanho 'n'. Queremos gerar uma matriz 'c' de modo que cada elemento da matriz c seja a soma dos elementos com os mesmos índices das matrizes 'a' e 'b'. Mas, neste caso, para resolver o problema, não usaremos cálculos seqüenciais, mas paralelos que são feitos usando a GPU.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos lançar n threads / núcleos. O índice sob o qual cada thread específico funciona pode ser derivado da seguinte fórmula: </font></font><br>
<br>
<code>index = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No caso de uma matriz bidimensional, o índice contém dois componentes, ou seja, uma linha e uma coluna, que podem ser exibidas da seguinte maneira: </font><font style="vertical-align: inherit;">
Também precisamos determinar o número de threads por bloco, digamos, tpb e blocos por grade, digamos bpg. Usaremos números padrão para eles. </font><font style="vertical-align: inherit;">
É importante observar outro conceito importante aqui: quando qualquer cálculo tiver que ser realizado na GPU, os dados correspondentes deverão ser transferidos para a memória global da GPU e os resultados dos cálculos poderão ser transferidos de volta para o host. Essas operações são executadas usando as funções </font><font style="vertical-align: inherit;">e </font><font style="vertical-align: inherit;">fornecidas na biblioteca Python Numba.</font></font><br>
<br>
<code>row = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x<br>
col = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>cuda.to_device()</code><font style="vertical-align: inherit;"></font><code>copy_to_host()</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abaixo estão as implementações desta solução para a CPU e a GPU. </font><font style="vertical-align: inherit;">Veja as duas listagens para ver a diferença.</font></font><br>
<br>
<pre><code class="python hljs">c = np.zeroes(n)
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):<font></font>
    c[i] = a[i] + b[i]<font></font>
<span class="hljs-keyword">return</span> c</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementação sequencial para CPU.</font></font></i><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> numba <span class="hljs-keyword">import</span> cuda <span class="hljs-comment">#  Nvidia    GPU </span>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <font></font>
<font></font>
<span class="hljs-meta">@cuda.jit('void(float32[:], float32[:], float32[:])') #  Cuda </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cuda_addition</span>(<span class="hljs-params">a,b,c</span>):</span>
    <span class="hljs-string">"""     ."""</span>
    i = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x <span class="hljs-comment">#     </span>
    <span class="hljs-keyword">if</span> i &gt; c.size:
        <span class="hljs-keyword">return</span>
    c[i] = a[i]+b[i] <span class="hljs-comment">#Perform the addition</span><font></font>
 <font></font>
<span class="hljs-comment">#   </span><font></font>
device = cuda.get_current_device()<font></font>
<font></font>
<span class="hljs-comment">#     </span>
d_a = cuda.to_device(a)  <span class="hljs-comment">#      GPU</span>
d_b = cuda.to_device(b)  <span class="hljs-comment">#      GPU</span><font></font>
d_c = cuda.device_array_like(a)<font></font>
<font></font>
tpb = device.WARP_SIZE       <span class="hljs-comment">#blocksize     ,   = 32</span>
bpg = int(np.ceil((n)/tpb))  <span class="hljs-comment">#   </span><font></font>
<font></font>
cuda_addition[bpg, tpb](d_a, d_b, d_c) <span class="hljs-comment">#  </span><font></font>
<font></font>
<span class="hljs-comment">#      </span><font></font>
c = d_c.copy_to_host()<font></font>
print(c)<font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementação paralela para GPU </font></font></i><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Localizando as 3 posições mais semelhantes para cada posição na lista usando a GPU</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois de estudar minuciosamente a teoria e a prática, retornamos à tarefa original: encontrar as 3 principais posições semelhantes para cada posição na lista usando cálculos da GPU. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, a idéia principal é que tenhamos n posições e iniciaremos n threads. </font><font style="vertical-align: inherit;">Cada thread funcionará em paralelo com os outros e independentemente deles, calculando as 3 posições mais semelhantes para cada posição na lista. </font><font style="vertical-align: inherit;">Cada posição será responsável por um segmento.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> numba <span class="hljs-keyword">import</span> cuda <span class="hljs-comment"># Nvidia's GPU Library</span>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np 
<span class="hljs-keyword">import</span> math <span class="hljs-comment">#  , ,   , Numpy    GPU</span>
<span class="hljs-keyword">import</span> random<font></font>
<font></font>
<span class="hljs-comment">#                   </span>
<span class="hljs-meta">@cuda.jit('void(float32[:,:],float32[:],int32[:],float32[:],int32[:],float32[:],int32[:])') # CUDA Just-in-time Compiler</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cuda_dist</span>(<span class="hljs-params">X,first_best_val,first_best_index,second_best_val,second_best_index,third_best_val,third_best_index</span>):</span>
    <span class="hljs-string">"""     ."""</span>
    <span class="hljs-comment">#    </span><font></font>
    row = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x;<font></font>
    <span class="hljs-keyword">if</span> ((row &gt;= n)): <span class="hljs-comment">#      </span>
        <span class="hljs-keyword">return</span>
    first_best_val[row] = SMALL <span class="hljs-comment">#       </span>
    first_best_index[row] = <span class="hljs-number">-1</span> <span class="hljs-comment">#        </span>
    second_best_val[row] = SMALL <span class="hljs-comment">#       </span>
    second_best_index[row] = <span class="hljs-number">-1</span> <span class="hljs-comment">#        </span>
    third_best_val[row] = SMALL <span class="hljs-comment">#       </span>
    third_best_index[row] = <span class="hljs-number">-1</span> <span class="hljs-comment">#        </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):
        <span class="hljs-keyword">if</span>(i==row): <span class="hljs-comment">#   </span>
            <span class="hljs-keyword">continue</span>
        <span class="hljs-comment">#     ,        numpy   GPU</span>
        tmp = <span class="hljs-number">0.0</span>
        magnitude1 = <span class="hljs-number">0.0</span>
        magnitude2 = <span class="hljs-number">0.0</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(k):<font></font>
            tmp += X[row,j] * X[i,j]<font></font>
            magnitude1 += (X[row,j]* X[row,j])<font></font>
            magnitude2 += (X[i,j]* X[i,j])<font></font>
        tmp /= (math.sqrt(magnitude1)*math.sqrt(magnitude2)) <span class="hljs-comment">#    Dot_product(a,b) = a.b/(|a|*|b|)</span>
        <span class="hljs-keyword">if</span>(tmp&gt;=first_best_val[row]):<font></font>
            third_best_val[row] = second_best_val[row]<font></font>
            third_best_index[row] = second_best_index[row]<font></font>
            second_best_val[row] = first_best_val[row]<font></font>
            second_best_index[row] = first_best_index[row]<font></font>
            first_best_val[row] = tmp<font></font>
            first_best_index[row] = i<font></font>
        <span class="hljs-keyword">elif</span>(tmp&gt;=second_best_val[row]):<font></font>
            third_best_val[row] = second_best_val[row]<font></font>
            third_best_index[row] = second_best_index[row]<font></font>
            second_best_val[row] = tmp<font></font>
            second_best_index[row] = i<font></font>
        <span class="hljs-keyword">elif</span>(tmp&gt;third_best_val[row]):<font></font>
            third_best_val[row] = tmp<font></font>
            third_best_index[row] = i<font></font>
<font></font>
<span class="hljs-comment">#   </span><font></font>
device = cuda.get_current_device()<font></font>
<font></font>
d_x = cuda.to_device(X)<font></font>
d_first_val = cuda.device_array_like(first_val)<font></font>
d_first_index = cuda.device_array_like(first_index)<font></font>
d_second_val = cuda.device_array_like(second_val)<font></font>
d_second_index = cuda.device_array_like(second_index)<font></font>
d_third_val = cuda.device_array_like(third_val)<font></font>
d_third_index = cuda.device_array_like(third_index)<font></font>
<font></font>
<font></font>
tpb = device.WARP_SIZE       <span class="hljs-comment"># blocksize     </span>
bpg = int(np.ceil((n)/tpb))  <span class="hljs-comment">#   </span><font></font>
<font></font>
%time cuda_dist[bpg,tpb](d_x,d_first_val,d_first_index,d_second_val,d_second_index,d_third_val,d_third_index) <span class="hljs-comment">#  </span><font></font>
<font></font>
<span class="hljs-comment">#      </span><font></font>
first_val = d_first_val.copy_to_host()<font></font>
<span class="hljs-keyword">print</span> (first_val[:<span class="hljs-number">10</span>]) <span class="hljs-comment">#  10 </span>
<span class="hljs-comment">#      </span><font></font>
first_index = d_first_index.copy_to_host()<font></font>
<span class="hljs-keyword">print</span> (first_index[:<span class="hljs-number">10</span>]) <span class="hljs-comment">#  10 </span>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementação do código da GPU para encontrar as 3 posições mais semelhantes ao </font></font></i><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tempo</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
gasto O tempo total gasto pela GPU para encontrar as 3 principais posições semelhantes para cada posição na lista foi de 481 ms (0,5 segundos). </font><font style="vertical-align: inherit;">Foram necessários mais 20 segundos para copiar os dados do dispositivo para o host e do host para o dispositivo.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Conclusão</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A tarefa, cuja solução na CPU levaria cerca de 2 dias, na GPU foi resolvida em 20,5 segundos. </font><font style="vertical-align: inherit;">Isso foi possível apenas devido à natureza da tarefa. </font><font style="vertical-align: inherit;">A busca pelas 3 posições mais semelhantes para 'A' não depende da busca pelas 3 posições mais semelhantes para 'B'. </font><font style="vertical-align: inherit;">Aproveitamos esse fato e aplicamos o paralelismo fornecido pela GPU para acelerar o processo. </font><font style="vertical-align: inherit;">O exemplo também ilustra quais tipos de tarefas são resolvidos de maneira mais conveniente com a ajuda de uma GPU poderosa.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. Agradecimentos</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este estudo foi realizado no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Walmart Labs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MLP (plataforma de aprendizado de máquina) </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Agradecemos a Ayush Kumar por ajudar a otimizar o fluxo de trabalho.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt505558/index.html">Câmera de aprendizado profundo do Amazon DeepLens. Descompactando, Conectando e Implementando um Projeto</a></li>
<li><a href="../pt505560/index.html">O segundo conjunto para um programa de gerenciamento de produtos no centro de CS: o que os alunos dizem</a></li>
<li><a href="../pt505568/index.html">Transferindo arquivos usando pipes e outras pequenas coisas no Delphi</a></li>
<li><a href="../pt505574/index.html">Aprendizagem reforçada através de redes neurais competitivas</a></li>
<li><a href="../pt505580/index.html">Usando planilhas e software de computação para modelagem do Newsvendor</a></li>
<li><a href="../pt505592/index.html">Programando para BK0010 usando Android</a></li>
<li><a href="../pt505594/index.html">Como transformar um visitante do site em um cliente: um guia para criar formulários de lead</a></li>
<li><a href="../pt505604/index.html">Vulnerabilidade ao vício</a></li>
<li><a href="../pt505608/index.html">Vuex - resolva uma disputa antiga com novos métodos</a></li>
<li><a href="../pt505612/index.html">MK-61: história, emulação, dispositivo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>