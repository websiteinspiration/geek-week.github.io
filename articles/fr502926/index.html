<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📩 🍷 🕜 Paul Graham: concision = force 📏 🤚🏼 😳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="À HackerNews aujourd'hui, nous avons soulevé une discussion sur l' article de 2002 de Paul Graham et nous avons décidé de ressusciter sa traduction de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Paul Graham: concision = force</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillfactory/blog/502926/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À HackerNews aujourd'hui, nous avons </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soulevé une discussion sur l'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> article de 2002 de Paul Graham et nous avons décidé de ressusciter sa traduction de l'inexistence.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da8/643/390/da8643390d5501c1411a3ba972dbe2ac.jpg" alt="image"></div><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"La quantité de sens compressée dans un petit espace </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
par des signes algébriques, est une autre circonstance qui facilite </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
les raisonnements que nous sommes habitués à poursuivre par leur aide." </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - Charles Babbage (1791-1871)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dans la discussion autour de l'article </font><font style="vertical-align: inherit;">LL1 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revenge</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur la liste de diffusion LL1, Paul Prescod a fait une remarque qui ne me venait pas à l'esprit.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'objectif de Python est la régularité et la lisibilité, mais pas la brièveté.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À première vue, un langage de programmation ne devrait probablement pas prétendre l'être. </font><font style="vertical-align: inherit;">Si je comprends bien, brièveté (concision, concision, compacité) = force. </font><font style="vertical-align: inherit;">Et si oui, alors en faisant une substitution, on obtient:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'objectif de Python est la régularité et la lisibilité, mais pas la puissance.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ce qui, à son tour, n'est pas un très bon compromis (si c'est vraiment un compromis), qui vaut la peine d'être fait. </font><font style="vertical-align: inherit;">Il semble que si vous dites: le but du langage Python n'est pas d'être un langage de programmation efficace. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Est-ce que brièveté = force? </font><font style="vertical-align: inherit;">Cela semble être une question importante, peut-être la question la plus importante pour ceux qui sont impliqués dans le développement des langues. </font><font style="vertical-align: inherit;">Je ne suis pas encore sûr que la réponse soit simplement «oui», mais pour commencer, c'est une bonne hypothèse.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hypothèse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mon hypothèse est que la brièveté est le pouvoir, ou ils sont si proches que, à l'exception des cas pathologiques, vous pouvez les prendre pour quelque chose d'identique.</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La concision, me semble-t-il, est à quoi servent les langages de programmation. Les ordinateurs seraient tout aussi heureux s'ils recevaient des instructions directement en langage machine. Je pense que la principale raison pour laquelle nous allons développer des langages de haut niveau est d'avoir l'avantage d'exprimer (et surtout, de penser) dix lignes dans un langage de haut niveau, ce qui nécessiterait 1000 lignes de code machine. En d'autres termes, l'objectif principal des langages de haut niveau est de raccourcir le code source. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si le code source plus court est le but des langages de haut niveau, et la force de quelque chose est une mesure de la façon dont l'objectif est atteint, alors la force du langage de programmation est de savoir combien il réduit vos programmes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inversement, un langage qui ne rend pas vos programmes plus petits fait un mauvais travail d'un langage de programmation, tout comme un couteau qui coupe mal ou une impression illisible.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Métrique</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et dans quel sens est moins? </font><font style="vertical-align: inherit;">La mesure la plus courante de la taille du code source est le nombre de lignes. </font><font style="vertical-align: inherit;">Mais cette mesure n'est courante qu'à cause de la simplicité de la mesure, et je ne pense pas que quiconque pense que c'est un bon test de la taille du programme. </font><font style="vertical-align: inherit;">Les langues ont des conventions différentes sur ce qui peut être placé sur une seule ligne; </font><font style="vertical-align: inherit;">pas mal de lignes en C peuvent n'avoir qu'un ou deux séparateurs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre test simple est le nombre de caractères dans le programme, mais celui-ci n'est pas trop bon; </font><font style="vertical-align: inherit;">certaines langues (comme Perl) ont des identifiants plus courts que d'autres.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je pense que la meilleure mesure de la taille d'un programme peut être le nombre d'éléments, où l'élément est quelque chose qui pourrait devenir un sommet séparé dans l'arbre source. Le nom d'une variable ou d'une fonction est un élément; un entier ou un nombre réel est un élément; un segment littéral de texte est un élément; un élément d'une directive de modèle ou de format est un élément. Il y a des cas limites ("-5" est-il un élément ou deux?), Mais je pense que la plupart d'entre eux sont les mêmes dans toutes les langues, donc ils n'affecteront pas trop la comparaison.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette mesure doit être concrétisée, et elle peut nécessiter une interprétation supplémentaire dans le cas de certaines langues spécifiques, mais il me semble qu'elle essaie de mesurer la bonne chose: le nombre de parties du programme. </font><font style="vertical-align: inherit;">L'arbre source est ce que vous dessinez dans votre esprit pour représenter le programme, et donc la taille de cet arbre est proportionnelle à la quantité de travail nécessaire pour l'écrire ou le lire.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conception</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette mesure nous permettrait de comparer différentes langues, mais ce n'est pas, du moins pour moi, sa valeur de base. Et la valeur du test de brièveté est un guide pour concevoir des langues. La comparaison de langue la plus utile consiste à comparer deux variantes possibles de la même langue. Que puis-je faire dans la langue pour raccourcir les programmes? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si la charge conceptuelle d'un programme est proportionnelle à sa complexité et qu'un programmeur donné peut supporter une certaine charge conceptuelle, cela revient à demander: comment aider les programmeurs à faire plus? Et cela, me semble-t-il, revient à demander: comment concevoir un bon langage?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Soit dit en passant, la fausseté de ce dicton déjà barbu «toutes les langues sont équivalentes» est plus clairement visible lors de la conception des langues. Lorsque vous créez une nouvelle langue, vous comparez constamment deux langues - une dans laquelle je ferais X, et l'autre dans laquelle je ne ferais pas - de sorte que décider si c'est mieux. S'il s'agissait d'une question inutile, vous pourriez tout aussi bien lancer une pièce.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avoir un objectif de brièveté semble être un bon moyen de trouver de nouvelles idées. </font><font style="vertical-align: inherit;">Si vous trouvez un moyen de raccourcir les programmes, ce n'est pas un hasard: vous avez probablement trouvé une nouvelle abstraction utile. </font><font style="vertical-align: inherit;">Vous pourriez même écrire un programme qui récupérerait des morceaux répétés dans le code source. </font><font style="vertical-align: inherit;">De nouvelles idées peuvent être trouvées parmi les langues qui ont la réputation d'être concises: Forth, Joy, Icon.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparaison</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le premier qui a écrit sur ces choses était, pour autant que je sache, Fred Brooks avec son livre Mythical Man-Month. Il a écrit que les programmeurs génèrent la même quantité de code indépendamment de la langue. Quand je l'ai lu pour la première fois dans la vingtaine, ce fut une grosse surprise, et il me semblait que cela avait d'énormes conséquences. Cela signifiait que (a) la seule façon d'écrire des programmes plus rapidement était d'utiliser un langage plus court, et (b) celui qui avait pris la peine de le faire demanderait aux concurrents qui ne le font pas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La conjecture de Brooks, si elle est vraie, peut être l'essence même du piratage. Depuis lors, au fil des ans, j'ai prêté attention à tout ce qui pouvait être pertinent pour la question: des études théoriques aux histoires sur des projets individuels. Je n'ai rien vu qui contredirait cette hypothèse.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais je n'ai vu aucune preuve claire et je ne m'attends pas à les voir. Des études telles que la comparaison des langages de programmation Lutz Prekelt, bien qu'elles produisent les résultats escomptés, elles ont tendance à utiliser des tâches trop petites pour un test significatif. Le meilleur test pour une langue est ce qui se passe dans les programmes écrits en un mois. Et si vous êtes convaincu, comme moi, que le but principal des langues est d'être une bonne langue dans laquelle ils pensent (plutôt qu'une langue dans laquelle ils donnent des instructions à l'ordinateur après y avoir réfléchi), alors le véritable test pour la langue est quelle nouveauté pouvez-vous y écrire. Ainsi, la comparaison de langues basées sur une spécification prédéfinie est quelque peu erronée.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le vrai test pour la langue est de savoir dans quelle mesure vous pouvez y trouver et résoudre de nouveaux problèmes, mais pas les tâches formulées par quelqu'un d'autre. Ce sont des critères différents. Dans l'art, des outils tels que la broderie et la mosaïque fonctionnent bien si vous savez à l'avance ce que vous voulez obtenir, mais absolument indécents si vous ne le savez pas. Si vous souhaitez révéler une image en train d'écrire une image (ce que vous devez faire pour révéler des choses complexes comme, par exemple, l'image d'une personne), vous devez utiliser un outil plus flexible comme un crayon, de l'encre ou des peintures à l'huile. Bien sûr, les tapisseries et les mosaïques sont faites comme ça: d'abord une image est créée, puis seulement elle est copiée.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela signifie qu'il est peu probable que nous ayons une comparaison correcte de la force relative des langages de programmation. Nous aurons des comparaisons exactes, mais pas correctes. En particulier, les études visant explicitement à comparer les langues utiliseront probablement de petites tâches et utiliseront nécessairement un ensemble de tâches prédéfinies, et auront donc tendance à sous-estimer les langues les plus puissantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les rapports dans ce domaine, bien qu'ils soient moins précis que les études «scientifiques», seront probablement plus significatifs. Par exemple, Ulf Wieger d'Ericsson a mené une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">étude</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et est arrivé à la conclusion qu'Erlang est 4 à 10 fois plus court que C ++, et que la vitesse de développement du logiciel est proportionnellement plus élevée:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La comparaison des projets internes dans Ericsson révèle une productivité similaire en lignes de code par heure, y compris toutes les phases de développement, quel que soit le langage utilisé (Erlang, PLEX, C, C ++ ou Java). </font><font style="vertical-align: inherit;">Différences de langues - uniquement dans la quantité totale de code source.</font></font><br>
</blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette étude indique également clairement qu'elle n'apparaît pas dans le livre de Brooks (car elle ne mesurait que les lignes de code débogué): les programmes écrits dans des langages plus puissants ont tendance à contenir moins d'erreurs. </font><font style="vertical-align: inherit;">C'est déjà assez, et probablement dans des tâches telles que les commutateurs réseau, c'est plus important que les performances du programmeur.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Goûts</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fin de compte, vous pouvez faire confiance à votre instinct. Qu'est-ce que la programmation dans ce langage? Je pense que pour créer une meilleure langue, vous devez devenir hypersensible à la façon dont la langue vous permet d'y penser, puis choisir ou développer une langue qui vous semble la plus appropriée. Si une propriété de la langue est gênante ou restrictive - ne vous inquiétez pas, vous le saurez.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais une telle hypersensibilité se traduira par des langues maladroites devenant insupportables pour vous. </font><font style="vertical-align: inherit;">Je trouve la programmation dans des langages qui n'ont pas de macros insupportablement restrictive, tout comme si quelqu'un habitué à la frappe dynamique considérait insupportablement restrictif le retour aux langues, où les types devraient être décrits pour chaque variable déclarée et il est impossible de déclarer une liste composée d'éléments différents types. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et je ne suis pas seul. </font><font style="vertical-align: inherit;">Je connais de nombreux hackers Lisp avec lesquels quelque chose de similaire s'est produit. </font><font style="vertical-align: inherit;">En fait, la mesure la plus précise de la force relative d'un langage de programmation pourrait être la proportion de programmeurs qui connaissent un langage donné qui entreprendront tout travail dans lequel ce langage devrait être utilisé, quel que soit le domaine.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limites</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beaucoup de pirates savent probablement à quoi cela ressemble lorsque le langage semble restrictif. </font><font style="vertical-align: inherit;">C'est probablement le même sentiment que lorsque vous êtes coincé dans un embouteillage dans la rue que vous souhaitez emprunter et que vous devez faire un long détour. </font><font style="vertical-align: inherit;">Vous voulez dire quelque chose et la langue ne vous permet pas de le faire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, un langage limitatif n'est pas un langage succinct. </font><font style="vertical-align: inherit;">Le problème n'est pas que vous ne pouvez pas exprimer quelque chose, mais que le détour que cette langue vous oblige à faire est trop long. </font><font style="vertical-align: inherit;">Faites cette expérience de pensée: vous voulez écrire une sorte de programme, et le langage ne vous permet pas de le faire comme vous l'aviez prévu, mais au lieu de cela, vous le raccourcissez. </font><font style="vertical-align: inherit;">Au moins pour moi, ce ne serait pas trop restrictif. </font><font style="vertical-align: inherit;">Comme si un policier vous dirigeait d'un embouteillage sur une route plus courte au lieu d'un long détour. </font><font style="vertical-align: inherit;">Hou la la!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il me semble que le sentiment de limitation essentiellement (de 90 pour cent?) Découle du fait que vous êtes obligé de prolonger le programme dans la langue dans laquelle vous écrivez, par rapport à la langue dans laquelle vous pensez. </font><font style="vertical-align: inherit;">La limite est fondamentalement une brièveté insuffisante, donc quand une langue semble être limitative, cela signifie qu'elle n'est pas assez courte.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lisibilité</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La citation que j'ai commencée mentionne également deux autres qualités: la régularité et la lisibilité. </font><font style="vertical-align: inherit;">Je ne comprends pas vraiment ce qu'est la régularité et quels sont les avantages d'un code régulier et lisible par rapport à un code simplement lisible. </font><font style="vertical-align: inherit;">Mais je pense que je sais ce que l'on entend par lisibilité, et il me semble également que cela a à voir avec la brièveté. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous devons être prudents avec les concepts de lisibilité d'une seule ligne de code et la lisibilité du programme dans son ensemble. </font><font style="vertical-align: inherit;">Seul le dernier est important. </font><font style="vertical-align: inherit;">Je suis d'accord qu'une ligne sur BASIC est probablement plus lisible qu'une ligne sur Lisp, mais un programme écrit en BASIC aura plus de lignes que le même programme écrit en Lisp. </font><font style="vertical-align: inherit;">La lecture du programme BASIC demandera plus d'efforts.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">effort total = effort pour lire une ligne * nombre de lignes</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je ne suis pas sûr que la lisibilité soit proportionnelle à la brièveté, mais la brièveté est certainement un facteur de lisibilité (voir la formule ci-dessus). Il n'est donc guère logique de dire que le but du langage est la lisibilité, mais pas la brièveté.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour un utilisateur qui voit cette langue pour la première fois, la lisibilité ligne par ligne signifie que cette langue lui semblera inoffensive. Ainsi, la lisibilité ligne par ligne peut être une bonne décision marketing, bien que ce soit une mauvaise décision de conception. Il est isomorphe quant au mode de paiement échelonné: au lieu d'être intimidé par un gros acompte, vous offrez à l'acheteur un petit versement mensuel. Le paiement partiel n'est finalement pas rentable pour lui, ainsi que la lisibilité ligne par ligne - pour le programmeur. L'acheteur doit effectuer de nombreux petits paiements, tout comme le programmeur doit lire plusieurs lignes lisibles séparément.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce ratio existait même avant l'avènement des langages de programmation. </font><font style="vertical-align: inherit;">Si vous lisez des romans et des articles de journaux, votre première expérience de lecture d'un article en mathématiques peut être effrayante: lire une page prend une demi-heure. </font><font style="vertical-align: inherit;">Néanmoins, je suis sûr que le problème n'est pas dans la notation, comme cela peut sembler à première vue. </font><font style="vertical-align: inherit;">Un article en mathématiques est difficile à lire car les idées elles-mêmes sont complexes. </font><font style="vertical-align: inherit;">Si vous exprimez les mêmes idées en prose (comme le faisaient les mathématiciens avant de penser à une brève notation), leur lecture ne serait pas plus facile, car cette seule page se transformerait en un livre entier.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans quelle mesure?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certains étaient en désaccord avec l'idée de concision = force. Je pense que, au lieu de se demander si c'est le cas, il serait plus utile de se demander dans quelle mesure la brièveté est le pouvoir? Parce qu'il est clair que la brièveté est l'un des principaux objectifs des langages de programmation. Sinon, quel est leur objectif et quelle est l'importance de ces autres fonctions? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je propose cela pour ne pas rendre la discussion plus civile. Je veux vraiment connaître la réponse. Quand, si cela se produit, la langue devient-elle suffisamment concise?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'hypothèse avec laquelle j'ai commencé était que, à l'exception de certains cas pathologiques, la brièveté est identique à la force. </font><font style="vertical-align: inherit;">Je voulais dire qu'ils seront identiques dans n'importe quel langage développé par quelqu'un, mais si quelqu'un veut créer un langage spécifiquement pour réfuter cette hypothèse, alors cela fonctionnera probablement. </font><font style="vertical-align: inherit;">Mais je n'en suis pas vraiment sûr non plus.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langues mais pas programmes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il convient de préciser que nous parlons de la brièveté des langues et non des programmes individuels. Bien sûr, certains programmes peuvent être écrits très étroitement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai écrit à ce sujet dans le livre «About Lisp». Pour que la macro se justifie, elle doit économiser beaucoup plus d'espace par rapport à sa propre longueur. Si une macro volumineuse enregistre dix lignes de code chaque fois que vous l'utilisez et que la macro elle-même se compose de dix lignes, vous obtiendrez des économies de lignes si vous l'utilisez plus de deux fois. Mais c'est toujours une mauvaise décision, car les définitions de macro sont plus difficiles à lire que le code normal. Vous devrez peut-être utiliser la macro 10 ou 20 fois avant que la lisibilité ne s'améliore.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je suis sûr que dans n'importe quelle langue de tels compromis sont possibles (même si je soupçonne que les enjeux sont soulevés dans des langues fortes). Chaque programmeur a déjà vu du code extrêmement raccourci en raison de techniques de programmation douteuses. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, il est incontestable - du moins pour moi - que les programmes peuvent être suffisamment concis. La question est: les langues elles-mêmes peuvent-elles être courtes? Les langages peuvent-ils obliger les programmeurs à écrire brièvement (en éléments) au détriment de la lisibilité?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'une des raisons pour lesquelles il est difficile d'imaginer un langage trop concis est que s'il existe une manière trop compacte d'exprimer quelque chose, alors il y aura probablement une manière plus longue. Par exemple, s'il vous semble que l'utilisation de macros ou de fonctions de haut niveau en Lisp est trop dense, vous pouvez écrire du code isomorphe à Pascal. Si vous ne voulez pas exprimer la factorielle dans la langue d'Arc comme un appel à une fonction de haut niveau, </font></font><br>
<br>
<code>(rec zero 1 * 1-)</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
vous pouvez également écrire une définition récursive: bien </font></font><br>
<br>
<code>(rfn fact (x) (if (zero x) 1 (* x (fact (1- x)))))</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
que je ne puisse pas donner d'exemples aussi immédiatement, je suis intéressé par la question: la langue peut-elle être trop courte? Y a-t-il des langues qui vous obligent à écrire du code illisible? Si quelqu'un a des exemples, je serais heureux de les voir.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Rappelez-vous: je suis intéressé par les programmes qui ont une densité élevée selon la mesure des «éléments» décrits ci-dessus, mais pas les programmes qui sont courts juste parce que les séparateurs peuvent être omis en eux et tout a des noms qui sont un caractère long.) </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il a d'abord été publié </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br>
<hr><br>
<br>
<img src="https://habrastorage.org/webt/nk/j2/oz/nkj2oztxanscb6lhq19l-dfv2z8.jpeg" alt="image" align="left"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apprenez en détail comment obtenir une profession recherchée à partir de zéro ou passer au niveau supérieur en compétences et en salaire en suivant les cours en ligne de SkillFactory:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cours Profession Data Scientist (24 mois) </font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cours d'analyste de données de profession (18 mois)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cours de développement Web sur Python (9 mois)</font></font></a></li>
</ul> <br>
<br clear="left"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr502916/index.html">Tests unitaires pour le code RxSwift</a></li>
<li><a href="../fr502918/index.html">Erreur avec la directive #line dans le compilateur Visual C ++</a></li>
<li><a href="../fr502920/index.html">Comme nous avons testé les performances de nouveaux processeurs dans le cloud pour 1C selon le test de Gilyov</a></li>
<li><a href="../fr502922/index.html">Le marketing de foule comme outil pour améliorer la vitalité des entreprises</a></li>
<li><a href="../fr502924/index.html">Courte critique du téléphone IP Snom D735</a></li>
<li><a href="../fr502928/index.html">Mini-conférence "Travailler en toute sécurité avec les services cloud"</a></li>
<li><a href="../fr502930/index.html">Azure DevOps et App Center au lieu de batteries de tests: simplifiez et accélérez le développement mobile avec les services cloud</a></li>
<li><a href="../fr502932/index.html">La loi de Patrick Mackenzie: l'économie du logiciel est plus que vous ne le pensez, même compte tenu de la loi de Patrick Mackenzie</a></li>
<li><a href="../fr502934/index.html">Comment réduire les coûts publicitaires dans Yandex.Direct et Google Ads: 9 hacks à vie</a></li>
<li><a href="../fr502940/index.html">Comment ne pas transformer une newsletter en spam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>