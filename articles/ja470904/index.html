<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤚🏾 👏 👨‍👦 機械学習とディープニューラルネットワークで最も柔らかく、毛皮で覆われた道 ⤴️ 🕹️ ➿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最新の機械学習を使用すると、信じられないほどのことができます。ニューラルネットワークは社会の利益のために機能します。犯罪者を見つけ、脅威を認識し、病気の診断を助け、難しい決定を下します。アルゴリズムは創造性において人をしのぐことができます：彼らは絵を描き、歌を書き、そして普通の絵から傑作を作ります。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>機械学習とディープニューラルネットワークで最も柔らかく、毛皮で覆われた道</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/470904/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最新の機械学習を使用すると、信じられないほどのことができます。</font><font style="vertical-align: inherit;">ニューラルネットワークは社会の利益のために機能します。犯罪者を見つけ、脅威を認識し、病気の診断を助け、難しい決定を下します。</font><font style="vertical-align: inherit;">アルゴリズムは創造性において人をしのぐことができます：彼らは絵を描き、歌を書き、そして普通の絵から傑作を作ります。</font><font style="vertical-align: inherit;">そして、これらのアルゴリズムを開発する人々は、似顔絵の科学者としてしばしば提示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてがそれほど怖いわけではありません！</font><font style="vertical-align: inherit;">プログラミングにある程度慣れている人なら誰でも、基本モデルからニューラルネットワークを構築できます。</font><font style="vertical-align: inherit;">さらに、Pythonを学ぶ必要さえありません。すべてをネイティブJavaScriptで実行できます。</font><font style="vertical-align: inherit;">開始がどれほど簡単か、なぜフロントエンドベンダーの機械学習なのか、と</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexei Okhrimenko</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おべんじろう</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）をFrontendConfに送信し、テキストに転送しました-アーキテクチャの名前と便利なリンクが手元にあるように。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネタバレ。</font><font style="vertical-align: inherit;">警告！</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この物語：</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すでに</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機械学習</font><strong><font style="vertical-align: inherit;">を使用して</font></strong><font style="vertical-align: inherit;">いる</font><strong><font style="vertical-align: inherit;">人は対象外</font></strong><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">何か面白いことになるでしょうが、カットの下でオープニングを待っていることはまずありません。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">転移学習についてではありません。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pythonでニューラルネットワークを作成する方法については説明せず、JavaScriptからそれを操作します。</font><font style="vertical-align: inherit;">チートなし-特にJSでディープニューラルネットワークを作成します。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての詳細ではありません。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般に、すべての概念が1つの記事に収まるわけではありませんが、もちろん必要なものを分析します。</font></font></li>
</ul><a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/BX2M8t5BA3s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">講演者について：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アレクセイオフリメンコはフロントエンドアーキテクチャ部門のAvitoで働いており、彼の自由な時間にAngular Moscow Meetupを指揮し、「5 Minute Angular」をリリースしています。</font><font style="vertical-align: inherit;">長いキャリアの中で、彼は、PEG文法パーサーSimplePEGであるデザインパターンMALEVICHを開発しました。</font><font style="vertical-align: inherit;">Alexey CSSCombのメンテナは、会議や彼の</font><font style="vertical-align: inherit;">JS機械学習</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電報チャネル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で新しいテクノロジーに関する知識を定期的に共有してい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機械学習は非常に人気があります。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
音声アシスタント、Siri、Googleアシスタント、Aliceは人気があり、私たちの生活によく見られます。</font><font style="vertical-align: inherit;">多くの製品が、従来のアルゴリズムによるデータ処理から機械学習に切り替わりました。</font><font style="vertical-align: inherit;">顕著な例はグーグル翻訳です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/z3/cg/uz/z3cguzzlmogpjxmymmqhok5xw50.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スマートフォンのすべてのイノベーションとクールなチップは、機械学習に基づいています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qd/2m/1g/qd2m1gmmouw29qcfbytgd5gdcoc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、Google NightSightは機械学習を使用しています。</font><font style="vertical-align: inherit;">私たちが見るクールな写真は、レンズ、センサー、手ぶれ補正ではなく、機械学習で撮られたものです。</font><font style="vertical-align: inherit;">機械はついにDOTA2で人々を打ち負かしました。つまり、人工知能を倒す可能性はほとんどありません。</font><font style="vertical-align: inherit;">したがって、機械学習をできるだけ早く習得する必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単なことから始めましょう</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの日常のプログラミングルーチンは何ですか？通常、どのように関数を記述しますか？</font></font><br>
<img src="https://habrastorage.org/webt/n1/kn/ss/n1knssbigatyl2zrakkoaazsuai.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たち自身が発明した、または人気の既製のものから取得したデータとアルゴリズムを使用して、組み合わせ、小さな魔法をかけ、特定の状況で正しい答えを与える関数を取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはこの順序に慣れていますが、そのような機会はありますが、アルゴリズムを知らなくても、単にデータと答えを持っているだけで、それらからアルゴリズムを取得できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tq/6p/4w/tq6p4wwa4ctyhg_j7a4b_t2dhl0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「私はプログラマーです。いつでもアルゴリズムを書くことができます。」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
わかりましたが、たとえば、ここではどのアルゴリズムが必要ですか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mq/ey/ce/mqeycerayzppkiqobxr_-o13oka.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
猫の耳が鋭く、犬の耳がパグのように鈍くて小さいとします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nv/dp/-h/nvdp-h5hvyset6n3fz-q6ya03hs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰が誰であるかを耳で理解してみましょう。しかし、ある時点で、犬は耳が鋭くなることがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uk/j2/pr/ukj2prwe9ln0hdjj6x0qa5q9vxw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの仮説は良くありません。他の特性が必要です。</font><font style="vertical-align: inherit;">時間の経過とともに、私たちはますます詳細を学び、それによってますます自分自身をやる気にさせ、いつかはこのビジネスを完全にやめたいと思うでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はこのような理想的な画像を想像します：事前に回答があります（どのような種類の画像であるかを知っています）、データがあります（猫が描かれていることを知っています）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決策があります-これは機械学習、つまりその一部の1つであるディープニューラルネットワークです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディープニューラルネットワーク</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機械学習は非常に大きな領域です。それは膨大な量の方法を提供し、それぞれが独自の方法で良いです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qv/8t/kj/qv8tkjpyrk_qeia-hp4fxkvco7w.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その1つがディープニューラルネットワークです。ディープラーニングは、人気を博しているため、紛れもない利点があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この利点を理解するために、例として猫と犬を使用した古典的な分類問題を見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データがあります：写真または写真。最初に行うことは、埋め込み（埋め込み）です。つまり、データを変換して、マシンがデータを操作できるようにします。写真を扱うのは不便です。車にはもっとシンプルなものが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、画像を調整し、色を削除します。</font><font style="vertical-align: inherit;">犬や猫の色が何であれ、動物の種類を判別することは重要です。</font><font style="vertical-align: inherit;">次に、画像を配列に変換します。たとえば、0は暗い、1は明るいです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/th/st/aq/thstaqtmxfb1jqo-eacmrtlaxym.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このデータの表示により、ニューラルネットワークは既に機能しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに2つの配列を作成し、それらを特定の「レイヤー」にマージしましょう。</font><font style="vertical-align: inherit;">次に、単純な行列乗算を使用して、レイヤーの各要素とデータ配列を互いに乗算し、その結果を2つのアクティブ化関数に送ります（後でこれらの関数を分析します）。</font><font style="vertical-align: inherit;">アクティベーション関数が十分な数の値を受け取ると、「アクティベート」して結果が生成されます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の関数は、猫の場合は1を返し、猫でない場合は0を返します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目の関数は、犬の場合は1を返し、犬でない場合は0を返します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
応答をコーディングするこのアプローチは、「</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ワンホットエンコーディング」</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bb/-a/x5/bb-ax5li-ngkav87ibjjazse6m4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに、ディープニューラルネットワークのいくつかの機能が顕著です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニューラルネットワークを使用するには、入力でデータをエンコードし、出力でデコードする必要があります。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンコーディングにより、データから抽象化することができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入力データを変更することにより、異なるドメインドメインのニューラルネットワークを生成できます。</font><font style="vertical-align: inherit;">私たちが専門家ではない人でもです。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
猫と犬が何であるかを知る必要はありません。追加のレイヤーに必要な数を選択するだけで十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでのところ、不明な点は、これらのネットワークが「ディープ」と呼ばれる理由だけです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが非常に単純です。別のレイヤー（配列とそのアクティベーション関数）を作成できます。そして、あるレイヤーの結果を別のレイヤーに転送します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9n/8r/qh/9n8rqhrwuewcgwa17oq-beuj7r4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのレイヤーとアクティベーションのためのそれらの機能の多くはお互いに置くことができます。レイヤードアーキテクチャを組み合わせると、深いニューラルネットワークが得られます。その深さは多数のレイヤーです。まとめて</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「モデル」</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼び</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、これらのすべてのレイヤーに対して値が選択される方法を見てみましょう。</font><font style="vertical-align: inherit;">学習プロセスがどのように発生するかを理解できる</font><font style="vertical-align: inherit;">クールな</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">視覚化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/aw/ot/at/awotatoajim-4vykkxk5wgldodq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左側はデータ、右側はレイヤーの1つです。</font><font style="vertical-align: inherit;">レイヤー配列内の値を変更すると、座標系が変更されているように見えます。</font><font style="vertical-align: inherit;">したがって、データと学習に適応します。</font><font style="vertical-align: inherit;">したがって、学習はレイヤー配列に適切な値を選択するプロセスです。</font><font style="vertical-align: inherit;">これらの値は、重みまたは重みと呼ばれます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機械学習は難しい</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機械学習は難しいです。</font><font style="vertical-align: inherit;">上記のすべてが非常に単純化されています。</font><font style="vertical-align: inherit;">将来的には、非常に複雑な線形代数が見つかるでしょう。</font><font style="vertical-align: inherit;">悲しいかな、これからの脱出はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、コースもありますが、最速のトレーニングでさえ数ヶ月続き、安くはありません。</font><font style="vertical-align: inherit;">さらに、自分でそれを理解する必要があります。</font><font style="vertical-align: inherit;">機械学習の分野は非常に成長しており、すべてを追跡することはほとんど不可能です。</font><font style="vertical-align: inherit;">たとえば、以下は、1つの問題（オブジェクトの検出）のみを解決するための一連のモデル</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tw/bx/rs/twbxrs3-fary0wir6wd-e4x_2_i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
です。</font><font style="vertical-align: inherit;">ニューラルネットワークに近づき、それらを使って作業を始めることができませんでした。</font><font style="vertical-align: inherit;">しかし、私は方法を見つけて、それをあなたと共有したいと思います。</font><font style="vertical-align: inherit;">それは革命的なものではなく、そのようなものは何もありません、あなたはすでにそれに精通しています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブラックボックス-シンプルなアプローチ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ニューラルネットワークをビジネスタスクに適用する方法を学ぶために、機械学習のすべての側面を完全に理解する必要はありません。</font><font style="vertical-align: inherit;">うまくいけばあなたに刺激を与えるいくつかの例を紹介します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの人にとって、車はブラックボックスでもあります。</font><font style="vertical-align: inherit;">しかし、それがどのように機能するかわからない場合でも、ルールを学ぶ必要があります。</font><font style="vertical-align: inherit;">したがって、機械学習では、いくつかのルールを知る必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TensorFlow JS（ニューラルネットワークを操作するためのライブラリ）について学びます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルの選択方法を学びます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのタスクに焦点を当て、コードから始めます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード作成による学習</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TensorFlowライブラリは、Python、C / C ++、JavaScript、Go、Java、Swift、C＃、Haskell、Julia、R、Scala、Rust、OCaml、Crystalなど、多数の言語用に作成されています。</font><font style="vertical-align: inherit;">しかし、私たちは間違いなく最高のものを選択します-JavaScript。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TensorFlowは、CDNからスクリプトを接続することにより、ページに接続できます。</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;script src=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"</span>&gt;&lt;/script&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
またはnpmを使用します。</font></font><br>
<br>
<ul>
<li><code>npm install @tensorflow/tfjs-node</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -ノードプロセス（ウェブサイト）;</font></font></li>
<li><code>npm install @tensorflow/tfjs-node-gpu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Linux CUDA）-GPUの場合。ただし、LinuxマシンとビデオカードがCUDAテクノロジーをサポートしている場合のみ。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CUDAコンピューティング機能が</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリと一致</font><font style="vertical-align: inherit;">していることを確認</font><font style="vertical-align: inherit;">し、高価なハードウェアが適切でないことが判明しないようにしてください。</font></font></li>
<li><code>npm install @tensorflow/tfjs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> （最も遅い/ブラウザー）-Node.jsを使用しないブラウザーの場合。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TensorFlow JSを使用するには、上記のモジュールのいずれかをインポートするだけで十分です。</font><font style="vertical-align: inherit;">すべてがインポートされる多くのコード例が表示されます。</font><font style="vertical-align: inherit;">これを行う必要はありません。1つだけを選択してインポートします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テンソル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期データの準備ができたら、最初に</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TensorFlowをインポートします</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ビデオカードのパワーによる加速を取得するには、tensorflow / tfjs-node-gpuを使用します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  @tensorflow/tfjs-node-gpu  node.js</span>
<span class="hljs-keyword">const</span> tf = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@tensorflow/tfjs'</span>);<font></font>
<font></font>
<span class="hljs-keyword">const</span> a = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2次元のデータ配列があります-これで作業します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に行う重要なことは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、テンソルを作成する</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことです</font><font style="vertical-align: inherit;">。この場合、テンソルはランク2、つまり実際には2次元配列で作成されます。データを転送し、2x2テンソルを取得します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  rank-2  (/)</span>
<span class="hljs-keyword">const</span> b = tf.tensor([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'shape:'</span>, b.shape);<font></font>
b.print()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッドが呼び出されることに注意してください</font></font><code>print</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、とない</font></font><code>console.log</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ので、</font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（私たちが作成したテンソルは）通常のオブジェクト、つまりテンソルではありません。彼には独自のメソッドとプロパティがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、平面配列からテンソルを作成し、その形状を覚えておくこともできます。つまり、フォーム（2次元配列）を宣言して、単純なフラット配列を送信し、フォームを直接示すことです。結果は同じになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データとフォームを別々に保存できるため、テンソルの形状を変更できます。メソッド</font></font><code>reshape</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">呼び出して</font><font style="vertical-align: inherit;">、フォームを2x2から4x1に変更</font><font style="vertical-align: inherit;">できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の重要なステップは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、データを出力し、</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それを現実の世界に戻すことです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  </span>
<span class="hljs-keyword">const</span> g = tf.tensor([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]);<font></font>
g.data().then(<span class="hljs-function">(<span class="hljs-params">raw</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'async raw value of g:'</span>, raw);<font></font>
});<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'raw value of g:'</span>, g.dataSync());
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'raw multidimensional value of g:'</span>, g.arraySync());</code></pre><br>
<i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3つのステップすべての</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">コード</font></a><font style="vertical-align: inherit;">。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッド</font></font><code>data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はpromiseを返します。</font><font style="vertical-align: inherit;">解決後、生の値の即時値を取得しますが、非同期で取得します。</font><font style="vertical-align: inherit;">必要に応じて同期的に取得できますが、ここではパフォーマンスが低下する可能性があるため、可能な限り非同期メソッドを使用してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッドは</font></font><code>dataSync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常にデータをフラット配列形式で返します。</font><font style="vertical-align: inherit;">そして、テンソルに格納されている形式でデータを返したい場合は、それを呼び出す必要があります</font></font><code>arraySync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オペレーター</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TensorFlowのすべての演算子は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルト</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><strong><font style="vertical-align: inherit;">不変です</font></strong><font style="vertical-align: inherit;">。つまり、各操作で常に新しいテンソルが返されます。</font><font style="vertical-align: inherit;">上記では、単に配列を取り、そのすべての要素を二乗します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   Immutable</span>
<span class="hljs-keyword">const</span> x = tf.tensor([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]);
<span class="hljs-keyword">const</span> y = x.square(); <span class="hljs-comment">// tf.square(x);</span>
y.print();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純な数学的演算でなぜこのような困難が生じるのでしょうか？</font><font style="vertical-align: inherit;">必要なすべての演算子（合計、中央値など）があります。</font><font style="vertical-align: inherit;">これが必要なのは、実際にはテンソルとこのアプローチにより、計算のグラフを作成し、すぐにではなくWebGL（ブラウザー内）またはCUDA（マシン上のNode.js）で計算を実行できるためです。</font><font style="vertical-align: inherit;">つまり、ハードウェアアクセラレーションを実際に使用することは私たちには見えず、必要に応じて、CPUでフォールバックを実行します。</font><font style="vertical-align: inherit;">素晴らしいことは、それについて何も考える必要がないことです。</font><font style="vertical-align: inherit;">tfjs APIを学ぶ必要があるだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今最も重要なのはモデルです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型番</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルを作成する最も簡単な方法は、シーケンシャル、つまりシーケンシャルモデルであり、1つのレイヤーから次のレイヤーにデータが転送され、次のレイヤーにデータが転送されます。</font><font style="vertical-align: inherit;">ここで使用される最も単純なレイヤーが使用されます。</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイヤー自体は、テンソルと演算子の単なる抽象化です。</font><font style="vertical-align: inherit;">大まかに言えば、これらはあなたから膨大な数の数学を隠すヘルパー関数です。</font></font></blockquote><br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-keyword">const</span> model = tf.sequential({
  <span class="hljs-attr">layers</span>: [<font></font>
    tf.layers.dense({<font></font>
      <span class="hljs-attr">inputShape</span>: [<span class="hljs-number">784</span>],
      <span class="hljs-attr">units</span>: <span class="hljs-number">32</span>,
      <span class="hljs-attr">activation</span>: <span class="hljs-string">'relu'</span><font></font>
    }),<font></font>
    tf.layers.dense({<font></font>
      <span class="hljs-attr">units</span>: <span class="hljs-number">10</span>,
      <span class="hljs-attr">activation</span>: <span class="hljs-string">'softmax'</span><font></font>
    })<font></font>
  ]<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装の詳細に立ち入ることなく、モデルを操作する方法を理解してみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、ニューラルネットワークに分類されるデータの形式を示し</font></font><code>inputShape</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。これは必須パラメーターです。</font></font><code>units</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多次元配列</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">数と活性化関数</font><font style="vertical-align: inherit;">を示し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数は</font></font><code>relu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、偶然見つかったという点で注目に値し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">試してみたところ、うまく機能しました。そして、非常に長い間、これが起こる理由の数学的説明を探していました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後のレイヤーでは、カテゴリを作成するときにsoftmax関数がよく使用されます。これは、回答をワンホットエンコーディング形式で表示するのに非常に適しています。</font><font style="vertical-align: inherit;">モデルが作成された後、</font></font><code>model.summary()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルが正しく組み立てられていることを確認します。特に難しい状況では、関数型プログラミングを使用してモデルの作成に取り組むことができます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">const</span> input = tf.input({ <span class="hljs-attr">shape</span>: [<span class="hljs-number">784</span>] });
<span class="hljs-keyword">const</span> dense1 = tf.layers.dense({ <span class="hljs-attr">units</span>: <span class="hljs-number">32</span>, <span class="hljs-attr">activation</span>: <span class="hljs-string">'relu'</span> }).apply(input);
<span class="hljs-keyword">const</span> dense2 = tf.layers.dense({ <span class="hljs-attr">units</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">activation</span>: <span class="hljs-string">'softmax'</span> }).apply(dense1);
<span class="hljs-keyword">const</span> model = tf.model({ <span class="hljs-attr">inputs</span>: input, <span class="hljs-attr">outputs</span>: dense2 });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に複雑なモデルを作成する必要がある場合は、機能的アプローチを使用できます。各レイヤーが新しい変数になるたびに。例として、手動で次のレイヤーを取得し、前のレイヤーをそれに適用するため、より複雑なアーキテクチャを構築できます。これが便利な場合については後で説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の非常に重要な詳細は、入力層と出力層、つまりニューラルネットワークに入る層と回答の層である層をモデルに渡すことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この後の重要なステップは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、モデル</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><strong><font style="vertical-align: inherit;">コンパイルすることです</font></strong><font style="vertical-align: inherit;">。 tfjsの観点からコンパイルとは何かを理解してみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ニューラルネットワークで適切な値を見つけようとしたことを忘れないでください。偶然ではありません。オプティマイザ関数が言うように、それらは特定の方法で選択されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   (  )</span><font></font>
model.compile({<font></font>
  <span class="hljs-attr">optimizer</span>: <span class="hljs-string">'sgd'</span>,
  <span class="hljs-attr">loss</span>: <span class="hljs-string">'categoricalCrossentropy'</span>,
  <span class="hljs-attr">metrics</span>: [<span class="hljs-string">'accuracy'</span>]<font></font>
});</code></pre><br>
<i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シーケンシャルレイヤー</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">を</font></a><font style="vertical-align: inherit;">記述してコンパイルする</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ためのコード</font></a><font style="vertical-align: inherit;">。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オプティマイザとは何か、損失関数とは何かを説明します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/se/lt/1l/selt1lv8ppxvokzopux387dp0os.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オプティマイザはマップ全体です。</font><font style="vertical-align: inherit;">ランダムに実行して値を探すだけでなく、特定のアルゴリズムに従って賢く行うこともできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
損失関数は、最適値（小さな黒い矢印）を探す方法です。</font><font style="vertical-align: inherit;">ニューラルネットワークのトレーニングに使用する勾配値を理解するのに役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将来は、ニューラルネットワークを習得するときに、損失関数を自分で作成します。</font><font style="vertical-align: inherit;">ニューラルネットワークの成功の大部分は、この関数がどれだけ適切に記述されているかに依存します。</font><font style="vertical-align: inherit;">しかし、これは別の話です。</font><font style="vertical-align: inherit;">簡単に始めましょう。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワーク学習の例</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ランダムなデータとランダムな回答（ラベル）を生成します。</font><font style="vertical-align: inherit;">モジュール</font></font><code>fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">呼び出し、</font><font style="vertical-align: inherit;">データ、回答、およびいくつかの重要なパラメーターを転送します。</font></font><br>
<br>
<ul>
<li><code>epochs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -5回、つまり大まかに言えば、5回本格的な研修を実施します。</font></font></li>
<li><code>batchSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、一度に変更できるウェイトの数-同時に処理する要素の数を示します。</font><font style="vertical-align: inherit;">ビデオカードが優れているほど、搭載するメモリも多くなり、より多くの設定が可能になります</font></font><code>batchSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  </span>
<span class="hljs-keyword">const</span> data = tf.randomNormal([<span class="hljs-number">100</span>, <span class="hljs-number">784</span>]);
<span class="hljs-keyword">const</span> labels = tf.randomNormal([<span class="hljs-number">100</span>, <span class="hljs-number">10</span>]);<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
model.fit(data, labels, {<font></font>
  <span class="hljs-attr">epochs</span>: <span class="hljs-number">5</span>,
  <span class="hljs-attr">batchSize</span>: <span class="hljs-number">32</span>
}).then(<span class="hljs-function"><span class="hljs-params">info</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'  :'</span>, info.history.acc);<font></font>
})</code></pre><br>
<i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての最後のステップの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">コード</font></a><font style="vertical-align: inherit;">。</font></font></i><br>
<br>
<code>Model.fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期メソッド、promiseを返します。</font><font style="vertical-align: inherit;">しかし、async / awaitを使用して、そのように実行を待つことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">モデルをトレーニングしてから、処理するデータを取得し、メソッドを呼び出します</font></font><code>predict</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。たとえば、「実際にそこにあるものを予測しますか？」と言います。これにより、結果が得られます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準構造</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各ニューラルネットワークには3つのメインファイルがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">index.js-ニューラルネットワークのすべてのパラメーターが格納されているファイル。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">model.js-モデルとそのア​​ーキテクチャを直接格納するファイル。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data.js-データが収集され、処理され、システムに埋め込まれるファイル。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで、TensorFlow.jsを学ぶ方法について話しました。</font><font style="vertical-align: inherit;">事は小さいです、それは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルを選択するの</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に残り</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、これは完全に真実ではありません。</font><font style="vertical-align: inherit;">実際、モデルを選択するたびに、特定の手順を繰り返す必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データを準備します。つまり、埋め込みを行い、アーキテクチャに合わせて調整します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハイパー設定を構成します（これについては後で説明します）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各ニューラルネットワークをトレーニングまたはトレーニングします（各モデルには独自のニュアンスがある場合があります）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニューラルモデルを適用すると、さまざまな方法で適用できます。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルを選ぶ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
よくある基本的なオプションから始めましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">深い感覚</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ディープニューラルネットワークの一般的な例です。</font><font style="vertical-align: inherit;">すべてが非常に簡単に行われます。公開されているデータセット-MNISTデータセットがあります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/6g/yu/-4/6gyu-4wjgg4zfvf8w7byjx_z5yw.jpeg" width="600"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらは番号が付けられた画像にラベルが付けられており、それに基づいてニューラルネットワークをトレーニングすると便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ワンホットエンコーディングのアーキテクチャに従って、最後のレイヤーをそれぞれエンコードします。 10桁-したがって、最後に10個の最後のレイヤーがあります。入り口に白黒の写真を提出するだけです。これはすべて、最初に説明した内容とよく似ています。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> model = tf.sequential({ 
  <span class="hljs-attr">layers</span>: [ <font></font>
    tf.layers.dense({ <font></font>
      <span class="hljs-attr">inputShape</span>: [<span class="hljs-number">784</span>], <span class="hljs-attr">units</span>: <span class="hljs-number">512</span>, 
      <span class="hljs-attr">activation</span>: <span class="hljs-string">'relu'</span> <font></font>
    }), <font></font>
    tf.layers.dense({ <font></font>
      <span class="hljs-attr">units</span>: <span class="hljs-number">256</span>, <span class="hljs-attr">activation</span>: <span class="hljs-string">'relu'</span> <font></font>
    }), <font></font>
     tf.layers.dense({ <font></font>
      <span class="hljs-attr">units</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">activation</span>: <span class="hljs-string">'softmax'</span> <font></font>
    }), <font></font>
  ] <font></font>
}); </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像を1次元配列にまっすぐにし、784要素を取得します。</font><font style="vertical-align: inherit;">1つのレイヤーでは512アレイ。</font><font style="vertical-align: inherit;">アクティベーション機能</font></font><code>'relu'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列の次の層は少し小さく（256）、アクティブ化層も</font></font><code>'relu'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">より一般的な特性を探すために配列の数を減らしました。</font><font style="vertical-align: inherit;">ニューラルネットワークは学習方法を促され、彼女自身はそれを行わないため、より深刻で一般的な決定を迫られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、10個の行列を作成し、ワンホットエンコーディングにソフトマックスアクティベーションを使用します。このタイプのアクティベーションは、このタイプのレスポンスエンコーディングでうまく機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
深いネットワークにより、画像の80〜90％を正しく認識できます。</font><font style="vertical-align: inherit;">人は、約96％の品質で認識します。</font><font style="vertical-align: inherit;">ニューラルネットワークは人を捕まえて追い越すことができますか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CNN（たたみ込みニューラルネットワーク）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たたみ込みネットワークはめちゃくちゃ簡単に機能します。</font><font style="vertical-align: inherit;">結局、それらは前の例と同じアーキテクチャを持っています。</font><font style="vertical-align: inherit;">しかし、最初は何か他のことが起こります。</font><font style="vertical-align: inherit;">配列は、いくつかのソリューションを提供するだけでなく、全体像を縮小します。</font><font style="vertical-align: inherit;">彼らは絵の一部を取り、それを1桁に縮小、折りたたみます。</font><font style="vertical-align: inherit;">次に、それらはすべて一緒に収集され、再び削減されます。</font></font><br>
<img src="https://habrastorage.org/webt/mi/xc/gk/mixcgkl0kgopjxgams8szm0wr2q.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、画像のサイズは縮小されますが、同時に画像の一部がよりよく認識されます。</font><font style="vertical-align: inherit;">たたみ込みネットワークはパターン認識に非常によく機能し、人間よりも優れています。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写真を認識することは、人よりも車に任せるほうがよい。</font><font style="vertical-align: inherit;">特別な研究があり、残念ながらその人は負けました。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CNNは非常に単純に機能します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> model = tf.sequential({ 
  <span class="hljs-attr">layers</span>: [ <font></font>
    tf.layers.conv2d({       <font></font>
<span class="hljs-attr">inputShape</span>: [<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>], 
       <span class="hljs-attr">filters</span>: <span class="hljs-number">32</span>, <span class="hljs-attr">kernelSize</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">activation</span>: <span class="hljs-string">'relu'</span>, <font></font>
    }), <font></font>
    tf.layers.conv2d({ <font></font>
       <span class="hljs-attr">filters</span>: <span class="hljs-number">32</span>, <span class="hljs-attr">kernelSize</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">activation</span>: <span class="hljs-string">'relu'</span>, <font></font>
    }), <font></font>
    tf.layers.maxPooling2d({<span class="hljs-attr">poolSize</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>]}),     <font></font>
    tf.layers.conv2d({ <font></font>
       <span class="hljs-attr">filters</span>: <span class="hljs-number">64</span>, <span class="hljs-attr">kernelSize</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">activation</span>: <span class="hljs-string">'relu'</span>,     <font></font>
    })<font></font>
    tf.layers.flatten(tf.layers.maxPooling2d({       <font></font>
       <span class="hljs-attr">poolSize</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>] <font></font>
    })), <font></font>
    tf.layers.dense({<span class="hljs-attr">units</span>: <span class="hljs-number">512</span>, <span class="hljs-attr">activation</span>: <span class="hljs-string">'relu'</span>}),     <font></font>
    tf.layers.dense({<span class="hljs-attr">units</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">activation</span>: <span class="hljs-string">'softmax'</span>}) <font></font>
  ] <font></font>
}); </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我々は、入力特定多次元配列：28x28ピクセル、プラス輝度ための1次元の画像、第三の次元が1であるので、画像は、黒と白である。この場合には</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、設定アレイの数</font></font><code>filters</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>kernelSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのように多くの画素が狭くなります。アクティベーション機能はどこにでもあり</font></font><code>relu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">サイズをさらに効率的に削減するために必要な</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のレイヤーがあり</font></font><code>maxPooling2d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。たたみ込みネットワークは、サイズを非常に徐々に狭め、非常に深いたたみ込みネットワークを作成する必要がないことがよくあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少し遅れて非常に深い畳み込みネットワークを実行することが不可能である理由を説明しますが、ここでは覚えておいてください。時々、ネットワークを少し速く最小化する必要がある場合があります。これには別のmaxPoolingレイヤーがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に同じ密な層があります。</font><font style="vertical-align: inherit;">つまり、畳み込みニューラルネットワークを使用して、データからさまざまな兆候を引き出し、その後、標準的なアプローチを使用して結果を分類し、画像を認識します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uネット</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアーキテクチャモデルは、畳み込みネットワークに関連付けられています。その助けにより、癌細胞や緑内障の認識など、癌制御の分野で多くの発見がありました。さらに、このモデルは、この領域の教授よりも悪い悪性細胞を見つけることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単な例：ノイズの多いデータの中から、がん細胞（円）を見つける必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hj/9b/yr/hj9byresramxnetrg7t_kenia0a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
U-Netは非常に優れているため、ほぼ完璧に見つけることができます。アーキテクチャは非常にシンプルです</font></font><br>
<br>
<img src="https://habrastorage.org/webt/16/5_/vx/165_vxamsqm5eveub2tdhzxprc8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。サイズを縮小するMaxPoolingと同じように、同じたたみ込みネットワークがあります。唯一の違い：モデルは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スキャン</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワーク（</font><strong><font style="vertical-align: inherit;">デコンボリューションネットワーク）</font></strong><font style="vertical-align: inherit;">も使用し</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たたみ込みスキャンに加えて、各高レベルレイヤーが互いに結合され（開始と終了）、そのために膨大な数の関係が現れます。</font><font style="vertical-align: inherit;">このようなU-Netは、少量のデータでもうまく機能します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//First part (down climb) </span>
<span class="hljs-keyword">const</span> input = buildInput(...IMAGE_INPUT); 
<span class="hljs-keyword">const</span> conv1 = genConv2D(<span class="hljs-number">64</span>).apply(input); 
<span class="hljs-keyword">const</span> conv2 = genConv2D(<span class="hljs-number">64</span>).apply(conv1); 
<span class="hljs-keyword">const</span> pool1 = geMaxPool2D(<span class="hljs-number">2</span>).apply(conv2); 
<span class="hljs-keyword">const</span> conv3 = genConv2D(<span class="hljs-number">128</span>).apply(pool1); 
<span class="hljs-keyword">const</span> conv4 = genConv2D(<span class="hljs-number">128</span>).apply(conv3); 
<span class="hljs-keyword">const</span> pool2 = geMaxPool2D(<span class="hljs-number">2</span>).apply(conv4); 
<span class="hljs-keyword">const</span> conv5 = genConv2D(<span class="hljs-number">256</span>).apply(pool2); 
<span class="hljs-keyword">const</span> conv6 = genConv2D(<span class="hljs-number">256</span>).apply(conv5); 
<span class="hljs-keyword">const</span> pool3 = geMaxPool2D(<span class="hljs-number">2</span>).apply(conv6); 
<span class="hljs-keyword">const</span> conv7 = genConv2D(<span class="hljs-number">512</span>).apply(pool3); 
<span class="hljs-keyword">const</span> conv8 = genConv2D(<span class="hljs-number">512</span>).apply(conv7); 
<span class="hljs-keyword">const</span> pool4 = geMaxPool2D(<span class="hljs-number">2</span>).apply(conv8); 
<span class="hljs-keyword">const</span> conv9 = genConv2D(<span class="hljs-number">1024</span>).apply(pool4);
<span class="hljs-keyword">const</span> conv10 = genConv2D(<span class="hljs-number">1024</span>).apply(conv9); 
<span class="hljs-keyword">const</span> up1 = genUp2D().apply(conv10); 
<span class="hljs-keyword">const</span> merge1 = tf.layers.concatenate({ <span class="hljs-attr">axis</span>: <span class="hljs-number">3</span> }).apply([up1, conv8]); <font></font>
<font></font>
<span class="hljs-comment">//Second part (up climb) </span>
<span class="hljs-keyword">const</span> conv11 = genConv2D(<span class="hljs-number">512</span>).apply(merge1); 
<span class="hljs-keyword">const</span> conv12 = genConv2D(<span class="hljs-number">512</span>).apply(conv11); 
<span class="hljs-keyword">const</span> up2 = genUp2D().apply(conv12); 
<span class="hljs-keyword">const</span> merge2 = tf.layers.concatenate({ <span class="hljs-attr">axis</span>: <span class="hljs-number">3</span> }).apply([up2, conv6]); <font></font>
<font></font>
<span class="hljs-keyword">const</span> conv13 = genConv2D(<span class="hljs-number">256</span>).apply(merge2); 
<span class="hljs-keyword">const</span> conv14 = genConv2D(<span class="hljs-number">256</span>).apply(conv13); 
<span class="hljs-keyword">const</span> up3 = genUp2D().apply(conv14); 
<span class="hljs-keyword">const</span> merge3 = tf.layers.concatenate({ <span class="hljs-attr">axis</span>: <span class="hljs-number">3</span> }).apply([up3, conv4]); <font></font>
<font></font>
<span class="hljs-keyword">const</span> conv15 = genConv2D(<span class="hljs-number">128</span>).apply(merge3); 
<span class="hljs-keyword">const</span> conv16 = genConv2D(<span class="hljs-number">128</span>).apply(conv15); 
<span class="hljs-keyword">const</span> up4 = genUp2D().apply(conv16); 
<span class="hljs-keyword">const</span> merge4 = tf.layers.concatenate({ <span class="hljs-attr">axis</span>: <span class="hljs-number">3</span> }).apply([up4, conv2]); <font></font>
<font></font>
<span class="hljs-keyword">const</span> conv17 = genConv2D(<span class="hljs-number">64</span>).apply(merge4); 
<span class="hljs-keyword">const</span> conv18 = genConv2D(<span class="hljs-number">64</span>).apply(conv17);
<span class="hljs-keyword">const</span> conv19 = tf.layers <font></font>
  .conv2d({ <font></font>
    <span class="hljs-attr">kernelSize</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], <span class="hljs-attr">activation</span>: <span class="hljs-string">"sigmoid"</span>, 
    <span class="hljs-attr">filters</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">padding</span>: <span class="hljs-string">"same"</span> <font></font>
  }) <font></font>
 .apply(conv18); <font></font>
<span class="hljs-keyword">const</span> model = tf.model({ <span class="hljs-attr">inputs</span>: input, <span class="hljs-attr">outputs</span>: conv19 }); </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードはエディターで学習する方が簡単です。</font><font style="vertical-align: inherit;">一般に、ここでは膨大な数の畳み込みネットワークが作成され、それらを元に戻すため</font></font><code>concatenate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、いくつかのレイヤー</font><font style="vertical-align: inherit;">を作成</font><font style="vertical-align: inherit;">して組み合わせます。</font><font style="vertical-align: inherit;">これは単にコードの形式で、画像を視覚化したものです。</font><font style="vertical-align: inherit;">すべてが非常に単純です。このようなモデルのコピーと再現は簡単です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LSTM（長期短期記憶）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考慮されるすべての例には1つの機能があることに注意してください-入力データ形式は固定されています。</font><font style="vertical-align: inherit;">ネットワークへの入力、データは同じサイズであり、互いに一致している必要があります。</font><font style="vertical-align: inherit;">LSTMモデルは、これに対処する方法に焦点を当てています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、抽象を生成するサービスYandex.Referatsがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_o/g7/mh/_og7mh4hlaz87r6jpbkzjqsgdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼は完全なアブラカダブラを配りますが、同時に真実に非常に似ています。</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トピックに関する数学の要約：「公理としてのニュートンの二項式」前述のとおり</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
、表面積分は曲線積分を生成します。</font><font style="vertical-align: inherit;">下に凸の関数はまだ要求されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これから当然、表面への法線がまだ要求されています。</font><font style="vertical-align: inherit;">前述のとおり、ポアソン積分は基本的に三角ポアソン積分を指定します。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このサービスは、Seq-to-Seqニューラルネットワークに基づいています。それらのアーキテクチャはより複雑です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6r/3s/aw/6r3sawht3bnxadqmorz0vjqwzmw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レイヤーはかなり複雑なシステムに配置されています。しかし、心配する必要はありません。これらすべての矢を自分で行う必要はありません。必要であれば可能ですが、必須ではありません。これを行うヘルパーがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理解しておくべき主なことは、これらの各部分が前のものと組み合わされていることです。初期データからだけでなく、前の神経層からもデータを取得します。大まかに言えば、ある種のメモリを構築することは可能です-データのシーケンスを記憶し、それを再現し、そしてこの作業により「シーケンスへのシーケンス」。さらに、シーケンスは、入力と出力の両方で異なるサイズにすることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードではすべてが美しく見えます。</font></font><br>
<br>
<pre><code class="javascript hljs">tf.sequential({   
   <span class="hljs-attr">layers</span>: [    <font></font>
      tf.layers.lstm({       <font></font>
         <span class="hljs-attr">units</span>: <span class="hljs-number">512</span>,      
         <span class="hljs-attr">returnSequences</span>: <span class="hljs-literal">true</span>,       
         <span class="hljs-attr">inputShape</span>: [<span class="hljs-number">10000</span>, <span class="hljs-number">64</span>] <font></font>
      }),    <font></font>
      tf.layers.lstm({       <font></font>
         <span class="hljs-attr">units</span>: <span class="hljs-number">512</span>, 
         <span class="hljs-attr">returnSequences</span>: <span class="hljs-literal">false</span> <font></font>
      }),    <font></font>
      tf.layers.dense({ <font></font>
         <span class="hljs-attr">units</span>: <span class="hljs-number">64</span>, <span class="hljs-attr">activation</span>: ‘softmax<span class="hljs-string">' 
      }) 
   ] 
}) ;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
512個のオブジェクト（配列）があると言う特別なヘルパーがあります。</font><font style="vertical-align: inherit;">次に、シーケンスと入力フォームを返します（</font></font><code>inputShape: [10000, 64]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">次に、別のレイヤーを紹介しますが、シーケンス（</font></font><code>returnSequences: false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">は返しません。</font><font style="vertical-align: inherit;">結局、64個の異なる文字（小文字と大文字）にアクティベーション関数を適用する必要があるためです。</font><font style="vertical-align: inherit;">ワンホットエンコーディングを使用して64個のオプションがアクティブになります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もっとも興味深い</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、あなたは不思議に思うかもしれません。「これはもちろん、すべて良いことですが、なぜ必要なのですか？</font><font style="vertical-align: inherit;">「癌と闘うことは良いことですが、なぜ第一線でそれを必要とするのですか？」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてタンバリンを使ったダンスが始まります。たとえば、ニューラルネットワークをレイアウトに適用する方法を理解することです。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニューラルネットワークの助けを借りて、以前は解決できなかった問題を解決することが可能です。</font><font style="vertical-align: inherit;">あなたも考えられなかったいくつか。</font><font style="vertical-align: inherit;">それはすべてあなた、あなたの想像力と少しの練習に依存します。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 次に、検討したモデルの使用の興味深い例をライブで示します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CNN </font><font style="vertical-align: inherit;">オーディオチーム</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たたみ込みネットワークを使用すると、画像だけでなく音声コマンドも認識でき、97％の認識品質で、つまりGoogleアシスタントとYandex-Aliceのレベルで認識できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろんネットワークだけでは、本格的な音声や文章を認識することはできませんが、簡単な音声アシスタントを作成することはできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アリスについての詳細は</font><font style="vertical-align: inherit;">Nikita Dubko </font><font style="vertical-align: inherit;">の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レポートに記載され</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ていますが、Googleアシスタント、その中での音声の操作方法、およびブラウザの標準については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらをご覧ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事実は、どんな単語でも、どんなコマンドでもスペクトログラムに変えることができるということです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/au/_v/r8/au_vr8gdnqh3k6gkcgyhz0ybwoq.jpeg" width="500"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オーディオ情報をこのようなスペクトログラムに変換できます。</font><font style="vertical-align: inherit;">次に、オーディオを画像にエンコードし、CNNを画像に適用して、簡単な音声コマンドを認識できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U-Net。</font><font style="vertical-align: inherit;">スクリーンショットのテスト</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
U-Netは、がん診断の成功だけでなく、スクリーンショットのテストなどにも役立ちます。</font><font style="vertical-align: inherit;">詳細については、</font><font style="vertical-align: inherit;">リュドミラ・ムジャチク</font><font style="vertical-align: inherit;">の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">報告を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照してください</font><font style="vertical-align: inherit;">。基地自体についてもお伝えします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スクリーンショットを使用してテストするには、2つのスクリーンショットが必要です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比較する基本（参照）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト用のスクリーンショット。</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/kx/2g/ci/kx2gcib0rilb_zzhohk15dmnoi4.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、スクリーンショットテストでは、多くの場合、多くのフォールネガティブ（誤検知）があります。</font><font style="vertical-align: inherit;">しかし、これは高度な癌制御技術をフロントエンドに適用することで回避できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
覚えておいて、私たちは癌がない領域に画像をマークしました。</font><font style="vertical-align: inherit;">ここでも同じことができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/19/kk/uw/19kkuwktd9iv30ffolxasj3_l-k.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レイアウトが良好な画像が表示された場合は、マークを付けず、レイアウトが不良な画像にマークを付けます。</font><font style="vertical-align: inherit;">したがって、1つの画像でレイアウトをテストできます。</font><font style="vertical-align: inherit;">標準は必要ありません。レイアウトが壊れていると単純に判断できるたびに表示されます。</font><font style="vertical-align: inherit;">U-Netはこれに非常に適しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセスを完全に自動化することはまだできていませんが、テキストが進む範囲を決定することができました。</font><font style="vertical-align: inherit;">残念ながら、私はすべてのレイアウトの問題に対して独自のU-Netを開始する必要がありますが、それをトレーニングします。</font><font style="vertical-align: inherit;">これは長いですが、めちゃくちゃ面白いです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LSTM。</font><font style="vertical-align: inherit;">Twitter-Kozulya 2000</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エッセイを作成したり、ツイッターを作成したりできます。これは、ウラジスラフコズリよりもきらめくものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、実際のKozuliツイートをすべて取得して連結し、LSTMニューラルネットワークを適用します。</font><font style="vertical-align: inherit;">ネットワークを40回トレーニングし、すでにいくつかの提案を取得</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">します</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">たとえば、</font><em><font style="vertical-align: inherit;">「フロントランナーへ-足元に来るだけ</font></em><font style="vertical-align: inherit;">です。</font><em><font style="vertical-align: inherit;">」</font></em></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もっと練習すればもっとおもしろくなるでしょう：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yu/_6/xk/yu_6xkkdkak9jganrrpvxs6vd9g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何かこれに同意しますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらにもっと。</font><font style="vertical-align: inherit;">ネットワークはすでに生命について何かを理解し始めています</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lk/hz/sf/lkhzsfwyvs42ky2yi-k6m5reu7o.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/ai/a7/jv/aia7jvkjsgw35wpjixbsko4vjwe.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。最も賢いのは、「金属」という単語が元のサンプルに表示されないことです。つまり、ニューラルネットワークは単語を生成することを学び、ロシア語のスペリングと語彙を学習しました（当然、完全ではありません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、それは判明しました：</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「今、私はママと一緒に仕事をしています」</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「フロントエンドについてのフロントエンディmidlam」</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワークは名詞から動詞を作り始めました-これは進歩です。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ウェブパックの選挙でナザロフ。」</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、あなたはこれで議論することはできません：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lv/ud/dp/lvuddp8bnuagbh4kgmsao3j_qvo.jpeg"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EPOCS 250</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたが間違いなく遭遇する一つの問題についてお話します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想Kozulを長期間トレーニングすると、直感的に結果が良くなるはずです。問題は、この状況でオーバーフィッティングが発生することです-再トレーニング。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、レイヤーが特定の重みを持つ単純な配列であることです。ニューラルネットワークは遅延していることがわかります。データが少なく、ネットワークが大きい場合は、値を取得して配列に格納するだけです。つまり、すべてのオプションの値をハードフィックスします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ニューラルネットワークは非常にスマートであるため、背後にいるだけでトレーニングをやめれば、最も簡単な方法になる場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは疑似グラフィックであり、ネットワーク上にはより正確なものがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cv/_j/ft/cv_jftct2bzeb2_ik1apzezgjsg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要するに、ニューラルネットワークをトレーニングしたいほど、それに転送する必要があるデータが指数関数的に増えます。</font><font style="vertical-align: inherit;">膨大な量のデータをニューラルネットワークに強制的に学習させ（さらに、さらに多く）する必要があります。</font><font style="vertical-align: inherit;">そうでなければ、彼女は単にそれらを覚えて何もしません。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニューラルネットワークは非常に遅延しているので注意してください。</font><font style="vertical-align: inherit;">彼らは簡単にあなたをだます。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">過剰適合に対処するにはいくつかの方法があります。</font><font style="vertical-align: inherit;">私はそれらについて詳しく説明しません。これにはヘルパーレイヤーがあります。</font><font style="vertical-align: inherit;">BatchNormalization。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LSTM。</font><font style="vertical-align: inherit;">きれい</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が話したい最後のケースは、ニューラルネットワークのPrettierです。ここでは、フォーマットされていないコードを入力に与え、フォーマットされたコードを出力で取得できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あります</font></font><code>const a = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ペアにすることができます：</font></font><code>[]c co on ns st</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、およびスペースの前にスペースを追加し、スペースの前にスペースを削除できることをニューラルネットワークに説明し</font></font><code>[][] []c co on ns st</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。ただし、このデータにはアクセスできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワークをトレーニングするには大量のデータが必要であり、大量のコードを生成する必要があるため、この作業はまだ進行中です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチが機能するという仮説をどのようにテストしたのでしょうか。私は数の配列を取り、0がスペースであると判断し、ニューラルネットワークをどこかにゼロを追加して削除するようにトレーニングし始めました。私の仮説が確認されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、常に非常にシンプルで原始的な仮説から始めて、小さなデータセットでテストすることができます。</font><font style="vertical-align: inherit;">そしてその後、すでに深刻な大きな決断を始めます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論の代わりに</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、すべてを絶対に教えることはしませんでした。場所を不必要に簡略化。しかし、この記事がディープニューラルネットワークを使い始めるのに役立つことを願っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたはもっと新しくて興味深いものを見つけるでしょう。完璧な品質のニューラルネットワークを取得する前に、まだ理解すべきことがたくさんあります。しかし、今すぐ始めることができます。これはすでにシステムの改善や新しいプロジェクトの開始に役立ちます。ニューラルネットワークのアプリケーションの数は膨大です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、JSでニューラルネットワークを作成しています。これは、対応をローカルでのみ読み取り、だまそうとしているのかどうかを通知します。このヒントは、高齢者やナイジェリア文字に慣れていない人に特に役立ちます。これはJavaScriptのおかげで可能になります。個人的な通信をサーバーに転送する必要がないからです。これがTensorFlow.jsの主な利点です。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><em></em></a><em>  ,     .     </em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><em>telegram-</em></a><em>     JS.</em><br>
<blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">FrontendConf</a>    , 13 .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a> 32        . <br>
<br>
   ,    ,           .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>  Saint AppsConf,       .      ,  ,    ,     . <br>
</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja470884/index.html">ビットコインブロックチェーンでのデータの書き込みと読み取り</a></li>
<li><a href="../ja470888/index.html">個人データ保護の分野におけるロシアおよび国際法</a></li>
<li><a href="../ja470892/index.html">FPGA上の小さなCAMのシンプルな実装</a></li>
<li><a href="../ja470894/index.html">弾丸</a></li>
<li><a href="../ja470902/index.html">高性能でネイティブなパーティション分割：TimescaleDBをサポートするZabbix</a></li>
<li><a href="../ja470908/index.html">付加技術の助けを借りて世界で初めて、大型航空機エンジンアセンブリが入手されました</a></li>
<li><a href="../ja470910/index.html">マイクロサービスコントラクトのアノテーションで何ができますか？</a></li>
<li><a href="../ja470916/index.html">スマートフォンから制御されるロシアの「最も安い」電子チェックポイント</a></li>
<li><a href="../ja470918/index.html">F＃9：タイプオプション</a></li>
<li><a href="../ja470920/index.html">DataLine Cloudに接続する5つ以上の方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>