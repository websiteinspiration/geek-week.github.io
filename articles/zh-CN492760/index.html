<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌤️ 🧘🏻 📯 CSS网格：键入响应式20行杂志布局 🔥 👶🏼 🙋🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近，我致力于博客博客（外部有用/有趣的博客列表）的现代化实现。这样做的目的是为读者提供这些博客的最新帖子的精选内容，以杂志的形式打包，而不是侧边栏中的链接列表。
 
 该任务最简单的部分是从我们最喜欢的RSS提要中获取帖子及其摘录（摘录-kat之前的介绍性文字）的列表。为此，我们使用了Feedzy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>CSS网格：键入响应式20行杂志布局</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/492760/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/in/vy/fm/invyfmr9wggf_x3z20znmwfyn8y.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近，我致力于博客博客（外部有用/有趣的博客列表）的现代化实现。这样做的目的是为读者提供这些博客的最新帖子的精选内容，以杂志的形式打包，而不是侧边栏中的链接列表。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该任务最简单的部分是从我们最喜欢的RSS提要中获取帖子及其摘录（摘录-kat之前的介绍性文字）的列表。为此，我们使用了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feedzy lite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> WordPress插件</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">插件</font><font style="vertical-align: inherit;">可以将多个供稿汇总到一个列表中，</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">并按</font></a><font style="vertical-align: inherit;">时间排序-这是我们的理想解决方案。困难的部分是使一切变得美丽。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该插件的标准列表界面可能没什么味道，因此我想将其作为报纸或杂志网站的样式，混合使用大小不同的“选定”区域。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
听起来是使用CSS Grid的绝佳时机！为不同的布局（例如，一个五列和一个三列）创建一个网格布局，然后使用不同屏幕尺寸的媒体查询在它们之间切换。对？但是，如果您仅可以使用Grid参数</font></font><code>auto-fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">那么我们是否真的需要这些媒体查询，以及定义控制点的所有麻烦</font><font style="vertical-align: inherit;">，这将为我们提供自适应网格？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这个想法似乎吸引我，但是当我开始加入跨电网的若干列元素（</font></font><em><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">跨度</font></font></b></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），网格开始在狭窄的屏幕上爬出页面。</font><font style="vertical-align: inherit;">媒体查询似乎是唯一的解决方案。</font><font style="vertical-align: inherit;">但是我发现更好的东西！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
研究了CSS Grid上的许多文章后，我发现它们主要分为两种类型：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何创建具有跨度但具有给定列数的有趣布局。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何</font><font style="vertical-align: inherit;">在网格上</font><font style="vertical-align: inherit;">创建具有</font><font style="vertical-align: inherit;">相同宽度的列（即无跨度）</font><font style="vertical-align: inherit;">的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自适应</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">布局。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我希望网格既可以实现此功能又可以实现：使用自适应调整多列元素大小的完全自适应布局。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样做的好处是，一旦您开始了解自适应网格的局限性以及跨度为何以及何时打破适应性，就可以轻松创建</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有数十行代码</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和一个媒体查询</font><font style="vertical-align: inherit;">的杂志版式</font><font style="vertical-align: inherit;">（或者如果您想限制跨度的多样性，甚至不用它们）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是包装盒中RSS插件与我们的工作结果（可点击）的清晰对比：</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/webt/in/vy/fm/invyfmr9wggf_x3z20znmwfyn8y.png"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一种完全自适应的杂志版面，带有彩色的“选定”框，可根据列数动态地适应该版面。该页面显示大约50个帖子，但是布局代码不取决于元素的数量。您可以在插件设置中轻松地将帖子数增加到100，而布局在最底层仍然很有趣。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有这些都是通过CSS唯一实现的，并且仅使用一个媒体查询就可以在最窄的屏幕（小于460像素）的一列中显示内容。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最不可思议的是，整个布局仅用了21行CSS（不包括网站的常规样式）。但是，为了使用很少的代码来实现这种灵活性，我不得不深入研究CSS网格的最深层次，并学习如何克服其某些局限性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
整个布局所依赖的代码非常短，这要归功于CSS Grid的出色表现：</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.archive</span> {
  <span class="hljs-attribute">display</span>: grid;
  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fit, minmax(<span class="hljs-number">210px</span>, <span class="hljs-number">1</span>fr));
  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">32px</span>;
  <span class="hljs-attribute">grid-auto-flow</span>: dense;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/*    */</span>
<span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(31n</span> + 1) {
  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / -<span class="hljs-number">1</span>;<font></font>
}<font></font>
<span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(16n</span> + 2) {
  <span class="hljs-attribute">grid-column</span>: -<span class="hljs-number">3</span> / -<span class="hljs-number">1</span>;<font></font>
}<font></font>
<span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(16n</span> + 10) {
  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / -<span class="hljs-number">2</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/*     */</span>
<span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width:</span> <span class="hljs-number">459px</span>) {
  <span class="hljs-selector-class">.archive</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">flex-direction</span>: column;<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文中描述的技术可以安全地用于对任何动态生成的内容进行样式化，无论它是最新帖子，存档页面或搜索结果的小部件的输出。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建自适应网格</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我创建了17个元素来展示未来内容的多样性-标题，图片和摘录，并包装在 </font></font><code>&lt;div&gt;&lt;/div&gt;</code><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"archive"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"article"</span>&gt;</span>
    <span class="hljs-comment">&lt;!--  --&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><font></font>
<font></font>
  <span class="hljs-comment">&lt;!--  16  --&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将这些元素转换为自适应网格的代码特别紧凑：</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.archive</span> {
  <span class="hljs-comment">/*     - */</span>
  <span class="hljs-attribute">display</span>: grid;
  <span class="hljs-comment">/*        ,       180 . */</span>
  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fit, minmax(<span class="hljs-number">180px</span>, <span class="hljs-number">1</span>fr));
  <span class="hljs-comment">/*     */</span>
  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">1em</span>;<font></font>
}<font></font>
</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→CodePen上的演示</font></font></b></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
请注意，行高如何自动调整为行中最高的内容块。</font><font style="vertical-align: inherit;">如果从上面的链接更改演示中的宽度，您将看到元素自动增加和减少，列数分别从1更改为5。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们看到了名为的CSS Grid魔术</font></font><code>auto-fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此关键字与</font></font><code>minmax()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用于</font><font style="vertical-align: inherit;">的功能结合使用</font></font><code>grid-template-columns</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">怎么运行的</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
五列布局本身可以这样获得：</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.archive</span> {
  <span class="hljs-attribute">display</span>: grid;
  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>fr);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，这将创建五列布局，该布局在不同的屏幕宽度下会拉伸和收缩，但始终保持五列，这会导致小屏幕上的列非常狭窄。首先想到的是编写一堆媒体查询并重新定义具有不同列数的网格。那会起作用，但是关键字</font></font><code>auto-fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会自动完成所有操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要</font></font><code>auto-fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据需要使用该功能</font></font><code>minmax()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。因此，我们有点告诉浏览器您可以压缩多少列，以及可以压缩多少列。当达到边界之一时，列数分别增加或减少。</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.archive</span> {
  <span class="hljs-attribute">grid-template-columns</span>: repeat (auto-fit, <span class="hljs-built_in">minmax</span>(<span class="hljs-number">180px</span>, <span class="hljs-number">1</span>fr));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此示例中，浏览器将尝试容纳多达180像素宽的列。</font><font style="vertical-align: inherit;">如果有多余的空间，则所有列都会扩展，将它们平均分配。</font><font style="vertical-align: inherit;">这就是决定含义的原因</font></font><code>1fr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：使列大小等于</font><font style="vertical-align: inherit;">可用宽度的</font><font style="vertical-align: inherit;">分数（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fr个</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动作）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果拉伸浏览器窗口，则所有列将随着可用空间的增加而同等增长。</font><font style="vertical-align: inherit;">新发现的空间一旦达到180像素，就会在其位置出现一个新列。</font><font style="vertical-align: inherit;">而且，如果您缩小浏览器窗口，则所有操作都将以相反的方式进行，从而完美地拟合网格，直到它变成单列布局为止。</font><font style="vertical-align: inherit;">魔法！</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→视频演示</font></font></b></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
有了这行代码，所有这些适应性便得到了体现。</font><font style="vertical-align: inherit;">好酷吗？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用“自动流：密集”创建跨度</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，目前我们已经有了一个自适应网格，这就是它的所有元素-相同的宽度。</font><font style="vertical-align: inherit;">报纸或杂志的布局意味着存在选定的块，在这种情况下，这些块将覆盖两个，三个甚至所有可用的列。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要创建多列跨度，我们可以</font></font><code>grid-column: span</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在应该占用更多空间的元素中</font><font style="vertical-align: inherit;">使用属性</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">假设我们希望第三个列表项的宽度为两列：</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(3)</span> {
  <span class="hljs-attribute">grid-column</span>: span <span class="hljs-number">2</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，添加跨度后，可能会出现很多问题。</font><font style="vertical-align: inherit;">首先，在这种情况下，当宽元素不适合其线并将其</font></font><code>auto-fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转移到以下位置</font><font style="vertical-align: inherit;">时，可能会在网格中形成孔</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tg/xl/8i/tgxl8iziz5_tm6pnng4wpnbbghm.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过向</font></font><code>grid-auto-flow: dense</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网格</font><font style="vertical-align: inherit;">添加属性</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">可以轻松解决此问题</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由于具有此属性，浏览器知道需要用其他元素填充漏洞。</font><font style="vertical-align: inherit;">这围绕较窄的较宽元素创建了一个流程：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tt/j9/hn/ttj9hndgzfsxehzxw1iqdxz4fa4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意：元素的顺序已损坏，现在第四个元素位于第三个元素的前面。</font><font style="vertical-align: inherit;">据我所知，这不能被绕过，这是必须接受的CSS Grid的限制之一。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">识别跨度的方法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有几种方法可以指定项目应占用的列数。</font><font style="vertical-align: inherit;">最容易应用于</font></font><code>grid-columns: span [n]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元素之一，其中</font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元素将占据的列数为。</font><font style="vertical-align: inherit;">布局中的第三个元素的属性为register </font></font><code>grid-column: span 2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这说明了为什么其宽度是其他元素的两倍。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要使用其他方法，必须</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定网格线</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">网格线编号如下：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/xg/za/yn/xgzaynnxcflkzedtleek72epqcs.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以使用正数（例如1、2、3）从左至右指示网格线，或使用负数（-1，-2，-3）从右至左指示网格线。</font><font style="vertical-align: inherit;">它们可以用于使用属性将元素放置在网格中</font></font><code>grid-column</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如下所示：</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.grid-item</span> {
  <span class="hljs-attribute">grid-column</span>: ( ) / ( );<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，网格线扩展了我们定义跨度的能力。</font><font style="vertical-align: inherit;">通过使用关键字替换初始值或最终值的能力来增加灵活性</font></font><code>span</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">例如，可以通过将以下任何属性应用于第八个网格元素来创建以上示例中的三列蓝色块：</font></font><br>
<br>
<ul>
<li><code>grid-column: 3 / 6</code></li>
<li><code>grid-column: -4 / -1</code></li>
<li><code>grid-column: 3 / span 3</code></li>
<li><code>grid-column: -4 / span 3</code></li>
<li><code>grid-column: span 3 / -1</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等等</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在非自适应网格（即，具有固定的列数）中，这些属性中的每一个都给出相同的结果（与上面带有蓝色框的示例一样）。</font><font style="vertical-align: inherit;">但是，如果网格是自适应的并且列数发生了变化，则差异将变得非常明显。</font><font style="vertical-align: inherit;">某些跨度会在自动包装打开的情况下破坏布局，这似乎使这两种解决方案不兼容。</font><font style="vertical-align: inherit;">幸运的是，一些技巧将使我们能够安全地将它们组合在一起。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是首先，我们需要了解问题。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水平滚动问题</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是使用网格线方法（可单击）创建的一些“特色项目”：</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/webt/nz/9m/uq/nz9muqk1spn-eujmvhwutl9rblm.png"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在整个宽度（五列）上，一切看起来都不错，但是如果将屏幕缩小到应该有两列的大小，则布局会中断：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/bb/oh/uu/bbohuutkvjhpbtv4ocjhmx0uodu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，我们的网格已经失去了适应性，尽管容器已经缩小，但是网格正在尝试支持所有五列。为此，她继续尝试使用相同的列宽，并最终超出了右侧容器的边界。由此，出现水平滚动。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么会发生？问题在于浏览器正在尝试遵守我们关于网格线的确切指示。在此宽度下，</font></font><code>auto-fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网格仅应显示两列，但是我们的堆栈行编号系统与此相反，特别是指向第五行。这种矛盾导致混乱。为了正确显示我们隐含的两列网格，只能使用数字1、2、3和-3，-2，-1，如下所示：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/s3/7t/1q/s37t1qfemvneeuufd7jvsantkz4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，如果网格的元素之一包含</font></font><code>grid-column</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">超出这些限制的</font><font style="vertical-align: inherit;">指令</font><font style="vertical-align: inherit;">（例如4、5或-6），则浏览器会收到不明确的指令。一方面，我们要求您自动创建灵活的列（在此屏幕宽度下，应隐式地保留两个）。另一方面，我们明确提到了网格线，网格线不能以两列格式存在。当隐式（自动）列与其显式定义的编号之间存在矛盾时，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网格始终倾向于使用显式定义</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这是不需要的列和水平溢出出现的方式（它们称为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CSS数据丢失</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">跨度（如网格线号）可以创建显式的列定义。</font><font style="vertical-align: inherit;">grid-column：尽管我们想要两个隐式列，但跨度3（演示中的第八个网格元素）强制网格显式包含至少三列。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
似乎唯一的选择是使用媒体查询将值更改</font></font><code>grid-column</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为所需的宽度...但不要着急！</font><font style="vertical-align: inherit;">一开始我也这么认为。</font><font style="vertical-align: inherit;">但是，经过一番思考并使用了不同的设置，我发现有一些方法可以解决此问题，由于这种原因，对于最狭窄的设备，我们仍然只有一种媒体要求。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方案</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事实证明，诀窍是仅使用可用于计划显示的最窄网格的行号来确定跨度。</font><font style="vertical-align: inherit;">在这种情况下，我们谈论的是两列网格（回想一下，我们使用媒体查询来显示单列）。</font><font style="vertical-align: inherit;">因此，您可以安全地使用数字1、2、3及其负对，而不会破坏网格。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初，我认为我将使用这些数字组合将自己限制为两列的跨度宽度：</font></font><br>
<br>
<ul>
<li><code>grid column: span 2</code></li>
<li><code>grid-column: 1 /3</code></li>
<li><code>grid-column: -3 / -1</code></li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/m5/q5/q8/m5q5q8beij-uiipgfasj_cndegy.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最多可完美适应两个扬声器：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/m0/ln/xb/m0lnxbx2i2axufbbyde7nusr-v4.png"></div><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管这是可行的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但从设计的角度来看，这是一个严重的限制，并且不太明显。我想在宽屏幕上跨度为三，四甚至五列。但是如何？我最初的想法是再次返回媒体查询（糟糕，很难摆脱旧习惯），但我仍然尝试避免使用这种方法，而是从另一个角度来看响应式设计。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再次查看可用数字列表时，我突然意识到可以将初始值和最终值中的正数和负数</font></font><code>grid-column</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行组合，例如</font></font><code>1/-3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>2/-2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。似乎没什么意思。但是，当您在更改网格大小后了解了线条的位置时，似乎就不再像以前那样：跨距会根据屏幕的宽度来更改宽度。大量的自适应跨度机会开辟了新局面，尤其是那些跨越不同列数且屏幕宽度发生变化而无需任何媒体查询的元素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我发现的第一个示例是</font></font><code>grid-column: 1/-1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。此属性将元素变成全角的横幅，从头到尾填充所有列，即使只有一列也是如此！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用</font></font><code>grid-column: 1/-2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，您可以创建一个跨度“几乎全宽”，该跨度从左到右填充所有列，除了最后一个。在两列布局中，这样的跨度会自适应地变成一列中的普通元素。令人惊讶的是，即使将布局压缩到一列，它也可以工作。 （似乎原因是网格不会将元素减小到零宽度，因此它保持了一列的宽度，就像使用的情况一样</font></font><code>grid-column: 1/1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。）我假设它</font></font><code>grid-column: 2/-1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该以相同的方式工作，只保留一列在左侧而不是在右侧。结果几乎是正确的，当将布局压缩到一列时，仍然会发生溢出。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后我尝试了组合</font></font><code>1/-3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它在宽屏幕上效果很好-至少填充三列-在窄屏幕上-仅填充一列。我认为对于两列网格，结果会有些奇怪，因为网格的第一行与数字下的行相同</font></font><code>-3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。令我惊讶的是，该项目正确显示在一列中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
经过大量的实验，我发现</font></font><code>grid-column</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在两列网格中可以</font><font style="vertical-align: inherit;">找到11个合适的值</font><font style="vertical-align: inherit;">。其中三个甚至可以在单列布局中工作。其他七个可以正常工作到两列，并且为了在一列中正确显示，他们只需要一个媒体查询。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是完整列表：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/_t/dv/bd/_tdvbd8_atfcs8y8us61wq3xzws.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
演示自动调整网格中不同屏幕尺寸上的自适应网格列值。</font><font style="vertical-align: inherit;">（</font></font><em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演示</font></font></a></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，尽管自适应跨度的子集非常有限，但仍有很多机会。</font></font><br>
<br>
<ul>
<li><code>2/-2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -一个有趣的组合，创建了一个中心跨度，该跨度一直到单列网格！</font></font></li>
<li><code>3/-1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -最没有用，因为即使在两列上也会导致溢出。</font></font></li>
<li><code>3/-3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -一个惊喜。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于</font></font><code>grid-column</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此列表中</font><font style="vertical-align: inherit;">的值多种多样</font><font style="vertical-align: inherit;">，因此可以创建有趣且完全响应的布局。</font><font style="vertical-align: inherit;">通过对最窄的单列显示使用单个媒体查询，我们可以管理十种不同的模式</font></font><code>grid-column</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
相同的媒体查询非常简单，甚至可以说很简单。</font><font style="vertical-align: inherit;">在我们的示例中，他负责将网格显示切换到flexbox：</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width:</span> <span class="hljs-number">680px</span>) {
  <span class="hljs-selector-class">.archive</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">flex-direction</span>: column;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-selector-class">.article</span> {
    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">2em</span>;<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是最后一个网格，您可能已经注意到，它完全响应-从一到五列（可单击）：</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/939/9aa/ad0/9399aaad0e89f01d46745aae0efaa928.gif"></div></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用法：nth-​​child（）用于重复动态宽度</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了将代码减少到两行，我应用了另一个技巧。选择</font></font><code>:nth-child(n)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">器使我可以一次设置大量元素的样式。我对跨度的整个想法是应用于提要中的许多帖子，以便选定的块会定期出现在页面上。首先，我编写了一个用逗号分隔的选择器列表，其中包含明确定义的元素编号：</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(2)</span>,
<span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(18)</span>,
<span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(34)</span>,
<span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(50)</span>  {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">128</span>,<span class="hljs-number">0</span>,<span class="hljs-number">64</span>,<span class="hljs-number">0.8</span>);
  <span class="hljs-attribute">grid-column</span>: -<span class="hljs-number">3</span> / -<span class="hljs-number">1</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在速度上，我意识到这是一个非常耗时的过程，尤其是当您必须为文章中需要更改的每个子元素复制整个条件列表时，例如标题，链接等。在进行原型制作时，每次我要调整跨度的位置时，我都必须手动更改每个列表中的数字。一个无聊且容易出错的过程。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那时我意识到您可以利用伪选择器的出色功能</font></font><code>:nth-child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：例如</font></font><code>:nth-child(2n+ 2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">输入一个表达式（而不是整数值）</font><font style="vertical-align: inherit;">，这意味着每个第二个子元素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是我过去</font></font><code>:nth-child([])</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在网格中创建全角蓝色块的方式，该块出现在页面顶部，然后在列表的一半处：</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(31n</span> + 1) {
  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / -<span class="hljs-number">1</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">11</span>, <span class="hljs-number">111</span>, <span class="hljs-number">222</span>, <span class="hljs-number">0.5</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
方括号（</font></font><code>31n + 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）中的</font><font style="vertical-align: inherit;">一段代码</font><font style="vertical-align: inherit;">负责选择第1，第32，第63等。子元素。浏览器从n = 0（</font></font><code>31 * 0 + 1 = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">开始循环</font><font style="vertical-align: inherit;">，然后是</font></font><code>n=1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>31 * 1 + 1 = 32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），最后是</font></font><code>n=2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>31 * 2 + 1 = 63</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。在后一种情况下，浏览器了解没有第63个子元素，忽略该规则，停止循环并将该规则应用于第1个和第32个元素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我正在为整个页面左侧或右侧显示的紫色块执行类似的操作：</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(16n</span> + 2) {
  <span class="hljs-attribute">grid-column</span>: -<span class="hljs-number">3</span> / -<span class="hljs-number">1</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">128</span>, <span class="hljs-number">0</span>, <span class="hljs-number">64</span>, <span class="hljs-number">0.8</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(16n</span> + 10) {
  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / -<span class="hljs-number">2</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">128</span>, <span class="hljs-number">0</span>, <span class="hljs-number">64</span>, <span class="hljs-number">0.8</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一个选择器用于左边的紫色块。该表达式</font></font><code>16n + 2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">负责将样式从第一个栅格元素应用于每个第16个栅格元素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个选择器用于右边的紫色块。间隔相同（</font></font><code>16n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），但偏移量不同（</font></font><code>10</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。结果，这些块通常在网格的右侧，编号为10、26、42等的元素中找到。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于这些元素的视觉样式，我使用了另一个技巧来避免代码重复。对于常见的紫色块样式（</font></font><code>background-color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，</font><font style="vertical-align: inherit;">显而易见的</font><font style="vertical-align: inherit;">），可以使用一个选择器：</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.article</span><span class="hljs-selector-pseudo">:nth-child(8n</span> + 2) {
  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">128</span>, <span class="hljs-number">0</span>, <span class="hljs-number">64</span>, <span class="hljs-number">0.8</span>);
  <span class="hljs-comment">/* Other shared syling */</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此选择器将选择项目2、10、18、26、34、42、50等。</font><font style="vertical-align: inherit;">换句话说，他选择了左块和右块。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
之所以起作用，是因为</font></font><code>8n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这恰好是一半</font></font><code>16n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且两个选择器中的移位差也为8。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后的话</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CSS Grid现在可用于以最少的代码创建灵活的响应式网格。但是，如果避免使用逆向媒体查询，则网格中元素的位置将受到很大限制。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
能够创建不会导致水平滚动和在小屏幕上溢出的跨度将非常酷。现在我们可以告诉浏览器：“请创建一个自适应网格，”它做得很好。但是，您只需要添加：“哦，请把网格的这个元素拉伸成四列，”然后他将手柄摇到狭窄的屏幕上，从而优先选择四列跨度的请求，而不是自适应网格。可以使网格做相反的事情，例如像这样：</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.article</span> {
  <span class="hljs-attribute">grid-column</span>: span <span class="hljs-number">3</span>, autofit;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
响应网格的另一个问题是最后一行。</font><font style="vertical-align: inherit;">更改屏幕宽度通常会使其变为空白。</font><font style="vertical-align: inherit;">我花了很长时间尝试找到一种方法，以将网格的最后一个元素拉伸到其余的列（分别填充行），但这似乎是不可能的。</font><font style="vertical-align: inherit;">至少现在（是。</font><font style="vertical-align: inherit;">最好有机会像这样用关键字设置元素的初始位置</font></font><code>auto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，说“从左边缘开始将线填充到末尾”。</font><font style="vertical-align: inherit;">像这样：</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-class">.article</span> {
  <span class="hljs-attribute">grid-column</span>: auto, -<span class="hljs-number">1</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...这会将网格左边缘的跨度拉伸到行尾。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN492744/index.html">哪个系统最响亮，哪个将给出“绝对”静音：两个有趣的科学项目</a></li>
<li><a href="../zh-CN492746/index.html">如何避免编程大怒？积分技巧</a></li>
<li><a href="../zh-CN492748/index.html">专业DevOps工程师：系统管理员的观点</a></li>
<li><a href="../zh-CN492754/index.html">为什么JavaScript会吞噬HTML：代码示例</a></li>
<li><a href="../zh-CN492758/index.html">开发者播客</a></li>
<li><a href="../zh-CN492762/index.html">投资者字母：什么是追加保证金以及如何避免</a></li>
<li><a href="../zh-CN492766/index.html">我们在Angular中处理事件</a></li>
<li><a href="../zh-CN492768/index.html">Greybox Fuzzing以AFLSmart为例</a></li>
<li><a href="../zh-CN492770/index.html">远程学习，协商和咨询-第1部分：思维服务器及其免费版本</a></li>
<li><a href="../zh-CN492772/index.html">亚马逊如何起诉网站上风险最大的产品</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>