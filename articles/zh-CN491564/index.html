<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☘️ 👩🏽‍🔧 ☝🏻 Java 14：记录，更简洁的instanceof，jpackage包装器，开关lambda和文本块 👨‍👩‍👦‍👦 🏂🏽 🖍️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="UPD。今天将是人们期待已久的Java 14发行版-即使它不是LTS-其中也包含足够的新功能。Java 14将在几个小时内上市-但您现在就可以了解它。
 
 
 
 在Java 14中，无论是在编写代码的级别还是在API，GC和许多其他引擎罩的级别，都进行了足够的更改。我们可以肯定地说，如果您了解一...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Java 14：记录，更简洁的instanceof，jpackage包装器，开关lambda和文本块</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491564/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD。</font><font style="vertical-align: inherit;">今天将是人们期待已久的Java 14发行版-即使它不是LTS-其中也包含足够的新功能。</font><font style="vertical-align: inherit;">Java 14将在几个小时内上市-但您现在就可以了解它。</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/us/u0/ae/usu0aephljxik4pjtyk6baaapyc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Java 14中，无论是在编写代码的级别还是在API，GC和许多其他引擎罩的级别，都进行了足够的更改。</font><font style="vertical-align: inherit;">我们可以肯定地说，如果您了解一些Kotlin或Python超级芯片-不用担心，它们很有可能很快就会出现在Java中。</font><font style="vertical-align: inherit;">无论如何，今天的发行版包含其中一些。</font><font style="vertical-align: inherit;">但是首先是第一件事。</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Java 14中，以下创新正在等待着我们：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 305.为通过instanceof检查的对象分配引用。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 343.封隔器jpackage（孵化器）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP345。G1的基于NUMA的内存分配。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP349。通过JFR传输事件。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP352。不变的映射字节缓冲区。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP358。有关NullPointerException的提示。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">359年9月。记录。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP361。切换lambda。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP362。现已弃用Solaris和SPARC端口。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 363.删除先前标记为“已弃用”的并发标记扫描垃圾收集器。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP364。在macOS上移植ZGC。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP365。将ZGC移植到Windows。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP366。现已弃用ParallelScavenge + SerialOld GC的组合。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 367.从Pack200中删除工具和API（在Java 11中被标记为不推荐使用）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP368。文本块。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP370。外部存储器访问API（孵化器）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们谈谈每种改进，其中一些将被更详细地讨论。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 305.为通过instanceof检查的对象分配引用</font></font></h2><br>
<img src="https://habrastorage.org/webt/7a/pm/o-/7apmo-a8gbn7oj4tqu-9-iv6vcq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑通过instanceof检查对象类型的情况。</font><font style="vertical-align: inherit;">如果我们想显式地将对象自定义为所需的类型而不冒ClassCastException的风险，则首先需要确保该对象是我们所需的类型。</font></font><br>
<br>
<pre><code class="java hljs">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showNameIfToy</span><span class="hljs-params">(Object o)</span> </span>{
        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Toy) {  <span class="hljs-comment">//,    -  Toy</span>
            Toy t = (Toy) o;  <span class="hljs-comment">//  </span>
            System.out.println(<span class="hljs-string">"Toy's name: "</span> + t.getName());  <span class="hljs-comment">//-   </span><font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本示例中，这种情况一直发生，我们一直在：a）确保我们具有所需类型的对象，b）为其分配链接，c）根据我们的逻辑对它进行操作。</font><font style="vertical-align: inherit;">在Oracle看来，他们在这种特定的结构中看到了一定数量的代码，并决定将其精简一步。</font><font style="vertical-align: inherit;">现在您可以这样写：</font></font><br>
<br>
<pre><code class="java hljs">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showNameIfToy</span><span class="hljs-params">(Object o)</span> </span>{
        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Toy t) {  <span class="hljs-comment">//      </span>
            System.out.println(<span class="hljs-string">"Toy's name: "</span> + t.getName());  <span class="hljs-comment">//     </span><font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
读者，这一切真的是多么方便和有用，让我来判断一下。</font><font style="vertical-align: inherit;">是的，的确如此，这种构造可能在99％的与instanceof相关联的情况下发生，并且简化可能会扎根（或可能不会扎根）。</font><font style="vertical-align: inherit;">时间会证明一切。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 343. jpackage Packer（孵化器）</font></font></h2><br>
<img src="https://habrastorage.org/webt/qy/hk/2d/qyhk2diseyyhq_rysnopvdiq1gk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们是开发人员，是个有头脑的人，您不会安装dzharnik来吓我们，但是一个简单的用户又不想知道在另外30亿台计算机上安装了JVM的情况，又不想知道Java跨平台，只想戳2如果使用Windows，则将.exe文件加倍，或者将.app应用程序拖至Applications文件夹（如果它具有罂粟），然后不蒸它？</font><font style="vertical-align: inherit;">如何为程序员创造所有条件，以便他们将应用程序打包为最终用户熟悉的“可执行文件”？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oracle似乎意识到了这个问题，并决定编写一个打包器，该打包器将立即以适合该平台的格式打包应用程序：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux：deb和rpm </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">macOS：pkg和dmg </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows：MSI和EXE </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
看起来像这样：</font></font><br>
<br>
<pre><code class="bash hljs">$ jpackage --name myapp --input lib --main-jar main.jar --<span class="hljs-built_in">type</span> exe</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
--name </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
myapp- </font><font style="vertical-align: inherit;">应用程序的未来名称</font><font style="vertical-align: inherit;">--input lib-jar归档</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文件的</font><font style="vertical-align: inherit;">源--main </font><font style="vertical-align: inherit;">-jar main.jar-包含主类的归档文件的名称</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
--type exe-应用程序将打包到的类型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
打包后，可以双击myapp.exe（如果有Windows）并将其安装为常规Windows应用程序。图形界面由JavaFX提供。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们尝试使用Windows平台构建这样的应用程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，让我们从这里开始该项目：</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">//github.com/promoscow/bouncer</font></a></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在发送GET请求时，我们收到消息：“ Bounce successl”和时间戳。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
把一个dzharnik。既然有了gradle，它就在build / libs文件夹中。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bf/bz/eg/bfbzeg3ansxdehnqoudd76-fcbw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
转到构建文件夹，输入所需的最少命令：</font></font><br>
<br>
<pre><code class="bash hljs">jpackage --name bouncer --input libs --main-jar bouncer.jar --<span class="hljs-built_in">type</span> exe</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们得到了一个exe-shnik。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/56/-k/nm/56-knmpxzinlb7nwtm3owmkn2pa.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们在可执行文件中戳两次，通常会安装该应用程序。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
哇！</font></font><br>
<br>
<img src="https://habrastorage.org/webt/a3/ck/jk/a3ckjkvq0hs7flr4towxmah19h4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该应用程序已安装并且正在等待中。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在“程序文件”的bouncer文件夹中，可以运行bouncer.exe。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2k/y_/vc/2ky_vc98fu1a7msjhss9v_m59dk.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 345. G1的NUMA分配的内存分配</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
存在这样的问题-NUMA，非统一内存访问，不相等的内存访问。换句话说，访问多段机器中的远程套接字可能会花费大量时间，尤其是对于G1垃圾收集器而言。在Java 14中，他们尝试如下解决此问题：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
G1堆被组织为一组固定大小的区域。区域通常是物理页面的集合，尽管使用大页面（通过-XX：+ UseLargePages）时，多个区域可以组成一个物理页面。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果在JVM初始化期间添加+ XX：+ UseNUMA参数，则区域将平均分布在可用NUMA节点的总数上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oracle承诺，尽管这种方法并不完全灵活，但他们将来会改进它。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 349.通过JFR传输事件</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Java中有一个东西，例如JFR-Java Flight Recording-动态记录事件，它使您可以在应用程序运行时监视大约500种事件。</font><font style="vertical-align: inherit;">问题在于它们大多数只能在日志中查看。</font><font style="vertical-align: inherit;">Oracle提供的改进是实现一个处理程序，例如，一个lambda函数，该函数将响应事件而被调用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
看起来是这样的：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">try</span> (<span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">new</span> RecordingStream()) {<font></font>
  rs.enable(<span class="hljs-string">"jdk.CPULoad"</span>).withPeriod(Duration.ofSeconds(<span class="hljs-number">1</span>));<font></font>
  rs.onEvent(<span class="hljs-string">"jdk.CPULoad"</span>, event -&gt; System.out.println(event.getFloat(<span class="hljs-string">"machineTotal"</span>)));<font></font>
  rs.start();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此事件每秒都会显示处理器向控制台的负载。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8b/m_/bp/8bm_bpzyy8qacbkj7grka4oyr3c.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP358。关于NullPointerException的提示</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一个明显的便利，旨在简化对代码中错误的搜索。</font><font style="vertical-align: inherit;">想象一个建筑-一个星球，这个星球上有很多国家，每个国家都有很多城市。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Planet</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">private</span> List&lt;Country&gt; countries;
    <span class="hljs-comment">//...</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Country</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">private</span> List&lt;City&gt; cities;
    <span class="hljs-comment">//...</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">City</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-comment">//...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们决定显示地球上所有城市的哈希码：</font></font><br>
<br>
<pre><code class="java hljs">planet.getCountries().forEach(c -&gt; c.getCities().forEach(city -&gt; city.hashCode()));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是他们没有考虑字段的强制初始化。</font><font style="vertical-align: inherit;">在某些时候，他们得到了NullPointerException：</font></font><br>
<br>
<pre><code class="java hljs">Exception in thread <span class="hljs-string">"main"</span> java.lang.NullPointerException<font></font>
	at ru.xpendence.jep_358_nullpointerexception.Main.main(Main.java:<span class="hljs-number">19</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们哪个字段为空？</font><font style="vertical-align: inherit;">行星？</font><font style="vertical-align: inherit;">国家？</font><font style="vertical-align: inherit;">城市??? </font><font style="vertical-align: inherit;">我们不知道。</font><font style="vertical-align: inherit;">我们将断点放在最右边，然后叹了口气，降低了性能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Java 14中，NullPointerException具有更多信息：</font></font><br>
<br>
<pre><code class="java hljs">Exception in thread <span class="hljs-string">"main"</span> java.lang.NullPointerException: Cannot assign field <span class="hljs-string">"cities"</span> because <span class="hljs-string">"countries"</span> is <span class="hljs-keyword">null</span>
     at Main.main(Main.java:<span class="hljs-number">21</span>)<font></font>
     ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
立即一切都清楚了。</font><font style="vertical-align: inherit;">国家为空。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 359.记录</font></font></h2><br>
<img src="https://habrastorage.org/webt/us/7z/al/us7zaleyxjn5obz6_8gaufbpdgu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
难怪Oracle将发布周期更改为六个月。 IT行业的结构变化甚至使这些领导者的行动速度也更快。并且，例如，如果Kotlin和Python出现时受到Java的影响（无论如何，这就是Wikipedia所说的Python），那么Java可以说是在关注它的追随者。关于Python，它的价格会更低一些，但是在Kotlin中可以精确地看到Oracle的以下功能。它与数据类有关，在Java中现在称为记录。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
什么是数据类？让我们编写一个常规的POJO：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Station</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Coordinates coordinates;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> name;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Coordinates <span class="hljs-title">getCoordinates</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> coordinates;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCoordinates</span><span class="hljs-params">(Coordinates coordinates)</span> </span>{
        <span class="hljs-keyword">this</span>.coordinates = coordinates;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<font></font>
        PlainStation that = (PlainStation) o;<font></font>
        <span class="hljs-keyword">return</span> Objects.equals(name, that.name) &amp;&amp;<font></font>
                Objects.equals(coordinates, that.coordinates);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> Objects.hash(name, coordinates);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"PlainStation{"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", coordinates="</span> + coordinates +
                <span class="hljs-string">'}'</span>;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们拥有一切-getters，setters，equals，hashcode，toString ...为了以某种方式摆脱这种耻辱，好人提出了Lombok。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Jetbrains上，通过为Kotlin发明数据类，以一种更为彻底的方式一次解决了该问题。</font><font style="vertical-align: inherit;">具有所有标准方法的此类如下所示：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Station</span></span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> coordinates: Coordinates)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就是这样。</font><font style="vertical-align: inherit;">在Oracle中，似乎看了看这个设计并做了完全一样的事情，只记录了：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> record <span class="hljs-title">RecordStation</span><span class="hljs-params">(String name, List&lt;Coordinates&gt; coordinates)</span> </span>{}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它包含标准的getter，setter，equals，hashcode和toString。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种类型的类已经可以在IDEA 2020.1中创建。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与POJO有什么区别？</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记录不能从任何类继承。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Record不能具有对象的任何其他字段，除了描述类时在构造函数中声明的字段（是的，顺便说一下，这是默认的构造函数）。</font><font style="vertical-align: inherit;">静态-可以。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段隐式为final。</font><font style="vertical-align: inherit;">对象是隐式最终的。</font><font style="vertical-align: inherit;">具有所有后果，例如不可能被抽象化。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事实证明，这是一个不变的数据类，并非旨在用于与其相关的某些复杂逻辑操作，而是旨在用于数据传输，仅此而已。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 361.开关Lambdas</font></font></h2><br>
<img src="https://habrastorage.org/webt/td/bv/sa/tdbvsa6l6cmnjqbaxukwjggnrtg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
甲骨文似乎已经采取了紧紧的行动。</font><font style="vertical-align: inherit;">在当前版本之前，它是一个相当庞大的设计，看起来像这样：</font></font><br>
<br>
<pre><code class="java hljs">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">translateDayOfWeekOld</span><span class="hljs-params">(String dayOfWeek)</span> </span>{
        <span class="hljs-keyword">switch</span> (dayOfWeek) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">"MONDAY"</span>:<font></font>
                System.out.println(<span class="hljs-string">""</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"TUESDAY"</span>:<font></font>
                System.out.println(<span class="hljs-string">""</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"WEDNESDAY"</span>:<font></font>
                System.out.println(<span class="hljs-string">""</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"THURSDAY"</span>:<font></font>
                System.out.println(<span class="hljs-string">""</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"FRIDAY"</span>:<font></font>
                System.out.println(<span class="hljs-string">""</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"SATURDAY"</span>:<font></font>
                System.out.println(<span class="hljs-string">""</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"SUNDAY"</span>:<font></font>
                System.out.println(<span class="hljs-string">""</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:<font></font>
                System.out.println(<span class="hljs-string">"Day of week not found, try again with today day of week"</span>);<font></font>
                String displayName = LocalDate.now().getDayOfWeek().name();<font></font>
                translateDayOfWeek(displayName);<font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
处理一个条件至少需要三行-情况，动作，中断。</font><font style="vertical-align: inherit;">现在，借助开关的增强功能，我们可以将上述构造缩短为：</font></font><br>
<br>
<pre><code class="java hljs">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">translateDayOfWeek</span><span class="hljs-params">(String dayOfWeek)</span> </span>{
        <span class="hljs-keyword">switch</span> (dayOfWeek) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">"MONDAY"</span> -&gt; System.out.println(<span class="hljs-string">""</span>);
            <span class="hljs-keyword">case</span> <span class="hljs-string">"TUESDAY"</span> -&gt; System.out.println(<span class="hljs-string">""</span>);
            <span class="hljs-keyword">case</span> <span class="hljs-string">"WEDNESDAY"</span> -&gt; System.out.println(<span class="hljs-string">""</span>);
            <span class="hljs-keyword">case</span> <span class="hljs-string">"THURSDAY"</span> -&gt; System.out.println(<span class="hljs-string">""</span>);
            <span class="hljs-keyword">case</span> <span class="hljs-string">"FRIDAY"</span> -&gt; System.out.println(<span class="hljs-string">""</span>);
            <span class="hljs-keyword">case</span> <span class="hljs-string">"SATURDAY"</span> -&gt; System.out.println(<span class="hljs-string">""</span>);
            <span class="hljs-keyword">case</span> <span class="hljs-string">"SUNDAY"</span> -&gt; System.out.println(<span class="hljs-string">""</span>);
            <span class="hljs-keyword">default</span> -&gt; {<font></font>
                System.out.println(<span class="hljs-string">"Day of week not found, try again with today day of week"</span>);<font></font>
                String displayName = LocalDate.now().getDayOfWeek().name();<font></font>
                translateDayOfWeek(displayName);<font></font>
            }<font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同意，非常紧凑，时尚并且带有lambda。</font><font style="vertical-align: inherit;">决定是否值得。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顺便说一句，按照旧规则编写的IDEA 2020.1开关建议使用新的方式仔细地重写。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6g/vc/-k/6gvc-klmcnwryt4hnukssulzaqe.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP362。Solaris和SPARC端口现已弃用</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里的一切都很简单。</font><font style="vertical-align: inherit;">Oracle认为花在支持Solaris和SPARC端口上的资源是不值得的，因此有空的员工应该转向开发新功能。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 363.删除先前标记为“已弃用”的并发标记扫描垃圾收集器</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CMS垃圾收集器的删除在两年前的第9版中进行了讨论。</font><font style="vertical-align: inherit;">在这段时间里，两个垃圾收集器出来了-ZGC和Shenandoah。</font><font style="vertical-align: inherit;">同时，没有一个值得信赖的Oracle贡献者关注CMS支持。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，医生先说太平间，然后再说太平间。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 364、365。在macOS和Windows上移植ZGC</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们通常在Linux平台上部署应用程序，但是对于本地开发，我们经常使用Windows和Mac。</font><font style="vertical-align: inherit;">为了满足这些需求，Java 14将ZGC垃圾收集器移植到了这两个平台上。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP366。现在不建议使用ParallelScavenge + SerialOld GC组合</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当年轻的ParallelScavenge与SerialOld结合使用时，极少使用的垃圾收集器配置。</font><font style="vertical-align: inherit;">这样做的原因尚不清楚，因为ParallelScavenge是并行的，而SerialOld相反。</font><font style="vertical-align: inherit;">包括这种组合需要特殊的手鼓舞蹈，并且需要大量的血液开发者。</font><font style="vertical-align: inherit;">“ Oracle关心您”，因此它将此配置标记为过时的，希望将其尽快发送到CMS垃圾收集器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
兄弟们，让我们高兴。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 367.删除Pack200工具和API（在Java 11中被标记为不推荐使用）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
轮到pack200，unpack200和API pack200来进行应有的休息。</font><font style="vertical-align: inherit;">原因是该封隔器过时了。</font><font style="vertical-align: inherit;">曾几何时，当Internet成为调制解调器并且速度为56k（boomers记住）时，JDK必须被抽出数小时。</font><font style="vertical-align: inherit;">发明了一种压缩程序，可以更好地压缩JDK并减少下载时间。</font><font style="vertical-align: inherit;">而且，它们可以压缩applet和客户端应用程序。</font><font style="vertical-align: inherit;">但是时间过去了，以目前的速度，封隔器是无关紧要的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下软件包将被删除：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
java.util.jar.Pack200 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
java.util.jar.Pack200.Packer </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
java.util.jar.Pack200.Unpacker </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以及jdk.pack模块。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 368.文本块</font></font></h2><br>
<img src="https://habrastorage.org/webt/mr/g9/_v/mrg9_vzcquzspnav3ld9yl0ofcm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一次，Java对Python产生了影响（包括其他六种语言）。</font><font style="vertical-align: inherit;">由于Python迅速普及并与Java和C IT图表的其他领导者一起充满信心，因此偷窥无可厚非。</font><font style="vertical-align: inherit;">一次，Java 9引入了JShell，它与pythonium Jupiter非常相似。</font><font style="vertical-align: inherit;">现在，文本块的时机已到。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我们需要写一行时，我们写一行：</font></font><br>
<br>
<pre><code class="java hljs">String s = <span class="hljs-string">""</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我们需要编写一个格式化的字符串时，我们可以编写如下代码：</font></font><br>
<pre><code class="java hljs">String oldHtml = <span class="hljs-string">"&lt;html&gt;\n\t&lt;body&gt;\n\t\t&lt;p&gt;Hi all!&lt;/p&gt;\n\t&lt;/body&gt;\n&lt;/html&gt;"</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文本完全不可读。</font><font style="vertical-align: inherit;">因此，在Java 14中，问题得以解决。</font><font style="vertical-align: inherit;">现在，使用三引号，您可以编写任何文本：</font></font><br>
<br>
<pre><code class="java hljs">        String html = <span class="hljs-string">""</span><span class="hljs-string">"
                      &lt;html&gt;
                          &lt;body&gt;
                              &lt;p&gt;Hi all!&lt;/p&gt;
                          &lt;/body&gt;
                      &lt;/html&gt;
                      "</span><span class="hljs-string">""</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它更加方便和可读。</font><font style="vertical-align: inherit;">我们可以简单地将任何文本复制到代码中，而不必使用制表符和连字符。</font><font style="vertical-align: inherit;">美丽！</font><font style="vertical-align: inherit;">如果我们只需要在不做连字符的情况下将文本转移到该文本的另一行，则可以使用新的文字-反斜杠。</font><font style="vertical-align: inherit;">该符号概括地说，其后的转移不是转移。</font><font style="vertical-align: inherit;">例：</font></font><br>
<br>
<pre><code class="java hljs">        String text = <span class="hljs-string">""</span><span class="hljs-string">"
                    \
                 ,  , \
                     \
                   . \
                , ,  ! \
                  ; \
                    \
                   .
                "</span><span class="hljs-string">""</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结论：</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">众神仍给你金色的日子，金色的夜晚，懒的处女盯着你。</font><font style="vertical-align: inherit;">朋友们，玩，唱歌！</font><font style="vertical-align: inherit;">失去短暂的夜晚；</font><font style="vertical-align: inherit;">和你的粗心的喜悦通过眼泪我微笑。</font></font></blockquote><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 370.外部存储器访问API（孵化器）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
碰巧一个应用程序访问诸如Ignite，mapDB，memcached等的外部内存。用于访问它的现有API相当有效，但是Oracle需要全局的东西。</font><font style="vertical-align: inherit;">因此出现了MemorySegment，MemoryAddress和MemoryLayout的抽象。</font><font style="vertical-align: inherit;">当该功能处于孵化器中时，每个人仍然可以对ByteBuffer，Unsafe和JNI感到满意。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
读者，我不了解您，但是我喜欢自Java 9以来Oracle切换到的六个月发布周期。现在Oracle并没有设定发布绝对稳定版本的任务，但是复杂的javista并不难跟上一项功能或另一项功能的稳定性。用于开发和测试孵化器中的某些东西。</font><font style="vertical-align: inherit;">该语言已变得更加活跃，多变，非常大胆的创新，并从其他语言中汲取了灵感。</font><font style="vertical-align: inherit;">是的，有人无法跟上版本的变化，但是我们的专业要求我们跟上发行的步伐，因此无论我们是否想要满足Java 14 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
，我都会像往常一样将一个项目附加在github上，并附上代码示例：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[单击此处]</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN491554/index.html">我们通过Python绕过了消息API Vkontakte的禁止</a></li>
<li><a href="../zh-CN491556/index.html">Java微服务：实用指南</a></li>
<li><a href="../zh-CN491558/index.html">查找更多的复活节彩蛋：从神秘的讯息到打电话洗手和做家庭作业的信息</a></li>
<li><a href="../zh-CN491560/index.html">如何使航站楼成为您的助手，而不是敌人？</a></li>
<li><a href="../zh-CN491562/index.html">FOSS新闻6-2020年3月2日至8日免费和开源新闻的回顾</a></li>
<li><a href="../zh-CN491566/index.html">使用mlr3软件包的R语言机器学习</a></li>
<li><a href="../zh-CN491568/index.html">使用Debian 10在笔记本电脑上的SOCKS中构建路由器</a></li>
<li><a href="../zh-CN491570/index.html">为什么ICQ在购买Mail.Ru之后失去了一个古老的用户</a></li>
<li><a href="../zh-CN491572/index.html">上周第405期（2020年3月2日至8日）来自前端世界的新鲜材料摘要</a></li>
<li><a href="../zh-CN491574/index.html">管理拖延的简单技巧</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>