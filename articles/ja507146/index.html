<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹 🗻 🐌 マルチカラーウィンドウ：仮想コンストラクター、CRTP、複雑なテンプレート ☢️ 🙂 👩🏼‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="かなり長い間、派生クラスが基本パラメーターで渡されるとき、重要な設計パターンが知られていました。
 

template<class T> class Base { … };  class Derived : public Base<Derived> { … };
 このテンプレートには独自の名前が...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>マルチカラーウィンドウ：仮想コンストラクター、CRTP、複雑なテンプレート</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/507146/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">かなり長い間、</font><font style="vertical-align: inherit;">派生クラスが基本パラメーターで渡さ</font><font style="vertical-align: inherit;">れる</font><font style="vertical-align: inherit;">とき、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要な設計パターンが</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">知られ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">てい</font></a><font style="vertical-align: inherit;">ました。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">Base</span>
{</span><font></font>
	…<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base&lt;Derived&gt;<font></font>
{<font></font>
	…<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このテンプレートには独自の名前があります-CRTP：不思議な繰り返しのテンプレートパターン。これは「奇妙な繰り返しパターン」と解釈されます。私はこの奇妙な構造にさらに奇妙な点を加えました。それを継承のチェーン全体に一般化しました。はい、それは実際に行うことができますが、これのためにあなたは</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">魂</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に大きな代償を払わせる必要があります。私がそれをどのように行ったか、そして私が支払わなければならない価格を知るために、詳細についてこの記事をさらに読んでください。</font></font><a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここでは</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまな奇妙な方法やその他の悪いこと</font><s><font style="vertical-align: inherit;">によるひどい倒錯</font></s><font style="vertical-align: inherit;">を扱い</font><font style="vertical-align: inherit;">ます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すぐに警告したいと思います。ここで説明されている内容を深刻なものとして取り扱わないでください。 95〜99％のケースでは、これらすべてが実際に役立つことはないと思います。これは一種の面白い数学、心のワークアウトです。実際には役に立たないでしょうが、これに時間を費やすのは興味深いことです。この場合のみ、C ++言語とその機能は数学として機能します。事前に警告しますここで深刻で実用的なものを探しているなら、あなたは失望するかもしれません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すぐにエキゾチックなものに目を向けてください。まるで2つの月、3つの太陽、植物の葉が青や薄紫色である国に突然出会ったかのようです。実際、ここにある多くの通常のことは...奇妙で珍しい...灰色の日常生活に夢中で、それほど昔ではない場合そのようなものを読んで、それからあなたはアドレスに来ました...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチカラーウィンドウ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ずいぶん前のことです。</font><font style="vertical-align: inherit;">ほぼ3年前。</font><font style="vertical-align: inherit;">それから私は</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重い草の上に座って</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、C ++ 11/14の</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zenの</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基礎</font><font style="vertical-align: inherit;">だけを</font><font style="vertical-align: inherit;">Meyers S.の本から</font><font style="vertical-align: inherit;">理解しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このパターンについても触れています。</font><font style="vertical-align: inherit;">その後、私は</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">悟り</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><s><font style="vertical-align: inherit;">達成した</font></s><font style="vertical-align: inherit;">と感じたので</font><font style="vertical-align: inherit;">、新しい標準の基礎</font><s><font style="vertical-align: inherit;">を</font></s><font style="vertical-align: inherit;">習得し、古い方法を新しい方法で見る準備ができたので、記憶の中でWindows APIに関する本を更新し始めました。ShchupakYu。-「Win32 API。</font><font style="vertical-align: inherit;">効果的なアプリケーション開発。」</font><font style="vertical-align: inherit;">最初に、ウィンドウを作成および表示するための最小限のC言語プログラムについて説明します。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><font></font>
<font></font>
HWND hMainWnd;<font></font>
TCHAR szClassName[] = TEXT(<span class="hljs-string">"MyClass"</span>);<font></font>
MSG msg;<font></font>
WNDCLASSEX *wc;<font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>
</span>{<font></font>
	HDC hDC;<font></font>
	PAINTSTRUCT ps;<font></font>
	RECT rect;<font></font>
<font></font>
	<span class="hljs-keyword">switch</span>(uMsg)<font></font>
	{<font></font>
	<span class="hljs-keyword">case</span> WM_CREATE:<font></font>
		SetClassLongPtr(hWnd, <span class="hljs-number">-10</span>, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		hDC = BeginPaint(hWnd, &amp;ps);<font></font>
<font></font>
		GetClientRect(hWnd, &amp;rect);<font></font>
		DrawText(hDC, TEXT(<span class="hljs-string">"Hello, world!"</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<font></font>
<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_CLOSE:<font></font>
		DestroyWindow(hWnd);<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		PostQuitMessage(<span class="hljs-number">0</span>);
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="hljs-keyword">int</span> nCmdShow)</span>
</span>{	
	<span class="hljs-keyword">if</span>(!(wc = <span class="hljs-keyword">new</span> WNDCLASSEX))<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"  !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	wc-&gt;cbSize = <span class="hljs-keyword">sizeof</span>(WNDCLASSEX);<font></font>
	wc-&gt;style = CS_HREDRAW | CS_VREDRAW;<font></font>
	wc-&gt;lpfnWndProc = WndProc;<font></font>
	wc-&gt;cbClsExtra = <span class="hljs-number">0</span>;<font></font>
	wc-&gt;cbWndExtra = <span class="hljs-number">0</span>;<font></font>
	wc-&gt;hInstance = hInstance;<font></font>
	wc-&gt;hIcon = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
	wc-&gt;hCursor = LoadCursor(<span class="hljs-literal">NULL</span>, IDC_ARROW);<font></font>
	wc-&gt;hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);<font></font>
	wc-&gt;lpszMenuName = <span class="hljs-literal">NULL</span>;<font></font>
	wc-&gt;lpszClassName = szClassName;<font></font>
	wc-&gt;hIconSm = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	<span class="hljs-keyword">if</span>(!RegisterClassEx(wc))<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"     !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">delete</span> wc;<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	hMainWnd = CreateWindow(szClassName, TEXT(<span class="hljs-string">"A Hello1 Application"</span>), WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, <span class="hljs-number">0</span>, CW_USEDEFAULT, <span class="hljs-number">0</span>, (HWND)<span class="hljs-literal">NULL</span>, (HMENU)<span class="hljs-literal">NULL</span>, (HINSTANCE)hInstance, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
	<span class="hljs-keyword">if</span>(!hMainWnd)<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"   !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
	ShowWindow(hMainWnd, nCmdShow);<font></font>
	<span class="hljs-comment">//UpdateWindow(hMainWnd);</span><font></font>
<font></font>
	<span class="hljs-comment">//      </span>
	<span class="hljs-keyword">while</span>(GetMessage(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<font></font>
	{<font></font>
		TranslateMessage(&amp;msg);<font></font>
		DispatchMessage(&amp;msg);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//MessageBox(NULL, TEXT("Application is going to quit."), TEXT("Exit"), MB_OK);</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はすでにこれを何度も行っており、この本のモデルではさまざまなウィンドウを表示しています。</font><font style="vertical-align: inherit;">そして突然私は思いました：昨日ちょうどC ++について読んだだけです！</font><font style="vertical-align: inherit;">このウィンドウを表示する独自のクラスを作成できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
否や言うほどない：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClass</span>				//  <span class="hljs-title">Windows</span>
{</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;					<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List wndList;							<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">static</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">//  ( )</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span><font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">friend</span> List;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WindowClass&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClass();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスの構造は簡単です：いくつかのコンストラクターが宣言され（メインパラメーターとより詳細なWNDCLASSEX構造体へのリンクの両方で）、ウィンドウクラス登録のCreateWnd関数とコンストラクターから呼び出されるウィンドウ作成自体、およびアクションを実行する一連の仮想メンバー関数ウィンドウコールバックプロシージャ内の各Windowsメッセージを処理します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスデータのメンバーも最小限です：ウィンドウハンドルhWnd;クラスの作成に使用されるWNDCLASSEX構造。そしてウィンドウのタイトルバー。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィンドウコールバックプロシージャは、thisポインターをクラスオブジェクトに暗黙的に渡さないように静的として宣言されており、Windowsで受け入れられているウィンドウプロシージャの関数の型（シグネチャ）に関する合意に違反しています（この関数を自分自身ではなくWindowsと呼ぶことに注意してください）。この関数のパラメーターと戻り値の型は厳密に指定されています）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィンドウプロシージャとこのポインター</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはC ++で知られています。メンバー関数が静的として定義されている場合、クラスオブジェクトへのポインターを明示的に渡す必要があります。ただし、この関数の形式ではこの転送が許可されていないため、クラスオブジェクトへのポインターを静的ウィンドウプロシージャに渡すことはできません。これに関連して、根本的な問題が発生します。WindowClassクラスのオブジェクトが複数ある場合、唯一の静的ウィンドウプロシージャは、メッセージが受信した特定のクラスオブジェクトをどのようにして知るのでしょうか。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決方法は1つだけです。この接続を確立する方法はいくつかあります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windowsは、HWND hWndハンドルによってウィンドウを識別します。このウィンドウに対応するクラスオブジェクトは、このオブジェクトへのポインタによって識別できます。したがって、WindowClassオブジェクトへの接続hWnd &lt;-&gt;ポインタを確立する必要があります。たとえば、ウィンドウプロシージャは、同時にクラスのメンバーであり、hWndと各ウィンドウのオブジェクトポインターとの間の接続を確立し、クラスのオブジェクトが作成されるたびに更新される静的データ構造へのリンクまたはポインターを持つことができます。データ構造は静的である必要があります。そのため、まずクラスオブジェクトへのポインタなしで静的ウィンドウプロシージャ内からアクセスでき、次にクラスのすべてのオブジェクトに対して一意である必要があります（その目的から論理的に続く）。 ）、そして第三に、そのため、適切なアクセスレベルを持つクラスにバインドされ、外部グローバル変数にはなりません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、この構造をどのように説明するか、なぜそれが必要なのかを理解した後、この構造がどうあるべきかを見つけることは残ります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの動的配列を宣言できます。1つはHWNDウィンドウハンドル用、もう1つはWindowClassオブジェクトへのポインター用です。ただし、これは最良の解決策ではありません。配列のサイズを選択する方法、ウィンドウを使用するシナリオはどうなるか、サイズが誤って選択された場合に配列がほとんど空になることが判明し、メモリオーバーランが発生するかどうかは不明です。または、逆に、ウィンドウを作成するときにボリュームが使い果たされると、サイズを大きくする必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況でのより良い（そして私が言うには-理想的な）解決策はリスト（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）リストは、ペアで接続されたノードのセットで構成される動的データ構造です。各ノード（二重にリンクされたリストの場合）には、リストの前のノードと次のノードへのポインター、および追加の保存データがあります。この状況では、各ウィンドウノードは各ウィンドウに対応し、有用なデータはウィンドウハンドルとWindowClassクラスのオブジェクトへのポインターです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、新しいウィンドウが作成されるたびに、新しいリストノードが作成され、その最後に追加されます（最後になります）。閉じると、ノードが削除され、前のノードと次のノードのポインターが互いに調整されて、リモートノードが置き換えられます。この場合、メモリオーバーランはありません。ウィンドウが作成されたのと同じ数のノードが作成され、ウィンドウが閉じられると同時にノードも削除されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、新しい静的メンバーもWindowClassクラスに追加する必要があります。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> List wndList;	<span class="hljs-comment">// ,    </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、それがWindowClassメンバーにアクセスできるようにする特権を宣言します。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">friend</span> List;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（ここでは、リストクラスとノードクラスの定義は示しません。これはWindowClassクラスに直接適用されないため、このクラスの実装ロジックは既知であり、非常に簡単です。）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、新しいメッセージが到着した場合のウィンドウプロシージャWindowsから渡されたウィンドウ記述子hWndに従って、処理する数に属し、リストにアクセスし、指定されたhWndに従ってその中のノードを検索し、それを見つけて、WindowClassクラスのオブジェクトへの必要なポインターを取得します。次に、ポインターによって、処理中のメッセージに対応する仮想関数を呼び出します。オーバーライドされたクラスの場合、同じ名前の仮想関数が他のアクションを実行できます。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WindowClass::WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>
</span>{
	<span class="hljs-comment">// 	</span>
	ListElement * pListElem = <span class="hljs-literal">nullptr</span>;<font></font>
<font></font>
	<span class="hljs-keyword">switch</span> (uMsg)<font></font>
	{<font></font>
	<span class="hljs-keyword">case</span> WM_CREATE:<font></font>
		{<font></font>
			<span class="hljs-comment">//lParam      CREATESTRUCT,         WindowClass,  </span>
			<span class="hljs-comment">// (.  WindowClass::CreateWnd)</span>
			CREATESTRUCT *cs = <span class="hljs-keyword">reinterpret_cast</span>&lt;CREATESTRUCT *&gt;(lParam);<font></font>
			WindowClass *p_wndClass = <span class="hljs-keyword">reinterpret_cast</span>&lt;WindowClass *&gt;(cs-&gt;lpCreateParams);<font></font>
			p_wndClass-&gt;hWnd = hWnd;		<span class="hljs-comment">// hWnd   ,    </span>
			<span class="hljs-comment">//    </span><font></font>
			pListElem = wndList.add(p_wndClass);<font></font>
			<span class="hljs-keyword">if</span> (pListElem)<font></font>
				pListElem-&gt;p_wndClass-&gt;OnCreate(hWnd);			<span class="hljs-comment">//  ,   </span><font></font>
		}<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)	<font></font>
			pListElem-&gt;p_wndClass-&gt;OnPaint(hWnd);	<span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_CLOSE:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)<font></font>
			pListElem-&gt;p_wndClass-&gt;OnClose(hWnd);	<span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)<font></font>
			pListElem-&gt;p_wndClass-&gt;OnDestroy(hWnd);  <span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここには1つの微妙な点があります。これは、クラスの初期化とWM_CREATEメッセージの処理に関係しています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CreateWindow関数でウィンドウを作成するとき、その呼び出し時には、hWndウィンドウハンドルはまだ不明です。ウィンドウはまだ作成されていません。したがって、仮想OnCreateを呼び出せるようにするには、クラスオブジェクトへのポインターを知っている必要があります。これは、WindowClass :: CreateWnd関数からlParamポインターを介してCreateWindow関数にthisポインターを渡すことにより、かなり危険です。 WM_CREATEを処理するとき、ウィンドウプロシージャはパラメーターからこのポインターを受け取り、その助けを借りてオブジェクト内のhWndメンバーを初期化し、クラスオブジェクトへのポインターを使用してこのウィンドウの新しいリストノードを作成します。次に、ポインタで仮想OnCreateを呼び出します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残りのメッセージについては、上記のロジックが実行されます。Windowsから転送された現在のウィンドウハンドルhWndによってリストノードを検索し、リストノードからクラスオブジェクトへのポインターによって目的の仮想関数を呼び出します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムをコンパイルし、すべてが正しく機能することを確認した後、私</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行われた作業から</font><s><font style="vertical-align: inherit;">自分の偉大さの感覚に</font></s><font style="vertical-align: inherit;">手</font><s><font style="vertical-align: inherit;">を</font></s><font style="vertical-align: inherit;">こすりながら、</font><font style="vertical-align: inherit;">さらに読み始めました。</font><font style="vertical-align: inherit;">そして次のページにウィンドウのプロパティを変更する機能が示されています：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">DWORD <span class="hljs-title">SetClassLong</span><span class="hljs-params">(HWND hWnd, <span class="hljs-keyword">int</span> nIndex, LONG dwNewLong)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はすぐに、古いウィンドウに基づいて新しいウィンドウを作成することに決めました。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClass		<span class="hljs-comment">//         </span><font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerived(WindowClassDerived&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
派生クラスは、静的ウィンドウカウンターを追加し、OnCreate、OnPaint、およびOnDestroyを変更することで基本クラスとは異なります。OnCreate関数はウィンドウの背景色を変更し、OnPaintは異なるメッセージを表示し、OnDestroyは静的ウィンドウカウンターを減らします。</font><font style="vertical-align: inherit;">すべてが非常にシンプルで明確です。</font><font style="vertical-align: inherit;">組み立てて発売。</font><font style="vertical-align: inherit;">メッセージのテキストが変わってしまいました... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...しかし、ウィンドウの色は変更されていません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想コンストラクタ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、私はすでに薄い氷の上に足を踏み入れていることに気づきました。</font><font style="vertical-align: inherit;">主要な本の基本的な資料にすべてのニュアンスが記載されているわけではありません。</font><font style="vertical-align: inherit;">それらの1つは仮想コンストラクターです。</font><font style="vertical-align: inherit;">コンストラクターから派生クラスの仮想関数を呼び出すことは、プログラムの他の場所とまったく同じであると思いました。</font><font style="vertical-align: inherit;">これは実行できないことがわかりました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、コンストラクターから呼び出される仮想関数が非仮想として呼び出されることです。つまり、基本クラスオブジェクトのみが作成され、最後まで作成されず、派生オブジェクトがまだ作成されておらず、仮想関数のテーブルが生成されていません。この場合、チェーンを取得します。派生コンストラクター-&gt;基本コンストラクター-&gt; CreateWnd-&gt; CreateWindow-&gt;ウィンドウプロシージャ-&gt; OnCreate、つまり、OnCreateは実際にはコンストラクターから呼び出されます。派生オブジェクトはまだ作成されていないため、基本クラスに対してOnCreateが呼び出されます！派生物におけるその再定義は、結局のところ、意味がありません！何をすべきか？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++から、オーバーライドされた関数は、そのフルネームで呼び出せることがわかっています：class_name :: function_name。クラス名は単なる名前ではありません。それ自体、実際にはオブジェクトのタイプを識別します。 C ++からも、クラス（および関数）を（her）タイプをパラメーターとして渡すことにより、テンプレート（template）にすることができることが知られています。したがって、ウィンドウプロシージャ関数テンプレートを作成し、派生クラスの型を何らかの方法でそれに渡すと、</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスの</font><font style="vertical-align: inherit;">コンストラクターで目的のオーバーライドされた関数を直接呼び出すことができます</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストップストップストップ!!!同じことはできません!!!派生クラスはまだ作成されておらず、そのデータは初期化されていません。ここで呼び出す関数は何ですか？</font></font><br>
<s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">できないが本当にしたい場合は、できます。</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もちろん、派生クラスへの完全なアピールは目指していませんでした。</font><font style="vertical-align: inherit;">クラスとはまったく関係のない</font><font style="vertical-align: inherit;">、完全に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サードパーティの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> WinAPI関数</font><font style="vertical-align: inherit;">を呼び出す</font><font style="vertical-align: inherit;">つもりでした。</font><font style="vertical-align: inherit;">「しかし、これは完全に異なる方法で行うことができ、はるかに簡単です！」</font><font style="vertical-align: inherit;">- あなたは言う。</font><font style="vertical-align: inherit;">はい。</font><font style="vertical-align: inherit;">できる。</font><font style="vertical-align: inherit;">記事の最後に書いていきます。</font><font style="vertical-align: inherit;">しかし、その時点で私はこれらすべてを捨てて、質問の純粋に技術的な側面に集中しました。しかし、それでも、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、基本クラスのコンストラクターで派生物から何かを呼び出すこと</font><font style="vertical-align: inherit;">は可能</font><font style="vertical-align: inherit;">ですか？</font><font style="vertical-align: inherit;">あなたが望むなら、それは純粋にスポーツの興味でした。</font><font style="vertical-align: inherit;">現時点では、実際的な面については何も考えていませんでした。</font><font style="vertical-align: inherit;">それは簡単なことではありませんでした。解決できるかどうか疑問に思いました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィンドウテンプレートクラス-メソッド1</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、難しいのは、派生クラスの型をウィンドウプロシージャに渡す方法ですか。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WindowClassの基本クラス全体を一度にテンプレートクラスにしたくありませんでした。派生クラスごとに独自の基本クラスが生成されます。さらに、WindowClassがテンプレートになるので、リストノードとリスト自体もテンプレートにする必要があります。これらにはクラスオブジェクトへのポインターがあり、これらのポインターを使用するには、型、つまりWindowClassとパラメーター化の方法を知っている必要があります。 。リストクラスとノードクラスを定義する時点では、これは不明であるため、この型もパラメーターとして（WindowClassから）渡す必要があります。したがって、各派生クラスは、</font><b><i><font style="vertical-align: inherit;">この派生クラスに</font></i></b><font style="vertical-align: inherit;">対応する独自のリストを作成します</font></font><b><i><font style="vertical-align: inherit;"></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（そして彼だけ）！また、異なる派生物に対応する基本クラスへのポインタを1つの配列に入れることはできません。それらは異なる型を持っています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、クラス全体をパラメーター化せずに、派生クラスの型を渡す方法を探し始めました。型は、コンストラクタを介してのみ基本クラスに渡すことができます。これは、オブジェクトの作成時にアクセスされる唯一の関数です。したがって、定型文である必要があります。ただし、明らかにテンプレートパラメータを指定できないことがわかりました。これは、コンストラクタではなく、テンプレートクラス自体にパラメータを渡すように見えます。したがって、型は、コンストラクターに渡されたパラメーターからのみ推測できます。しかし、型推論にのみ役立つ特別なコンストラクターパラメーターを追加したくありませんでした。純粋にユーティリティパラメーターで引数のリストが乱雑になっています。たとえば、ユーザーが転送を忘れた場合、少なくとも些細な（DerivedClass *）nullptr？これはまだ怖いものではありません-コンパイラーは、クラスをインスタンス化できないというエラーメッセージを表示します。さらに悪いことに、ユーザーがクラス階層を作成し、間違った派生クラスへのポインターを渡した場合、コンパイルの観点からはすべてが正しくなりますが、理解できないエラーが発生し、プログラムが正しく機能しなくなります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要するに、この設計の誤った計算はそのような解決策です。</font><font style="vertical-align: inherit;">したがって、正しいインスタンス化の責任は、派生クラスの作成者に転送されるのではなく、それを使用する人にも転送されます。</font><font style="vertical-align: inherit;">そして、彼はそのようなニュアンスに関する夢でも精神でもないことがありえます、そして、心からエラーがどこにあるか理解しません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでも、あきらめて、結局、デザイナーのパラメーターを変更せずに、WindowClass自体と、関連するリストおよびリストノードクラスをパラメーター化することにしました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WindowClassテンプレートクラス：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndCls</span>&gt; <span class="hljs-title">struct</span> <span class="hljs-title">ListElement</span>				// 
{</span>
	<span class="hljs-comment">// </span>
	HWND hWnd;					<span class="hljs-comment">//  Windows</span>
	WindowClass&lt;WndCls&gt; *p_wndClass;	<span class="hljs-comment">//    WindowClass</span><font></font>
<font></font>
	ListElement *pNext;			<span class="hljs-comment">//    </span>
	ListElement *pPrev;			<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClass</span>				//  <span class="hljs-title">Windows</span>
{</span>
	<span class="hljs-keyword">using</span> WndProcCallback = LRESULT (*)(HWND, UINT, WPARAM, LPARAM);		<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:						<span class="hljs-comment">//   !</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;				<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List&lt;WndCls&gt; wndList;					<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//	</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span>
	<span class="hljs-function"><span class="hljs-keyword">static</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">//  ( )</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T, <span class="hljs-keyword">typename</span> </span>= T::OnCreate&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd, T *p_wndClass)</span>		<span class="hljs-comment">//! .  FirstWin32CPP_DerivedTemplate2</span>
	</span>{
		<span class="hljs-comment">//  OnCreate   WndCls,  OnCreate   </span><font></font>
		T::OnCreate(hWnd);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd, T *p_wndClass)</span>		<span class="hljs-comment">//  OnCreate         </span>
	</span>{<font></font>
		p_wndClass-&gt;OnCreate(hWnd);			<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">friend</span> List&lt;WndCls&gt;;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WindowClass&amp;);			<span class="hljs-comment">// </span><font></font>
	<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClass();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
派生クラス：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClass&lt;WindowClassDerived&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WindowClassDerived(WindowClassDerived&amp;);		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テンプレートクラスのテンプレートメンバーであり、渡された派生クラスの型にアクセスできるウィンドウプロシージャは、派生クラスのOnCreateを呼び出します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、CRTPテンプレートは当然のことです。ここではそれだけで判明しました。かなり後になって、私はこのデザインが対応する名前を持つ有名なテンプレートであることを知りました。でも、それを知らなかったので、初めて受け取ったようです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは解決策の半分にすぎないことにすぐに気付きました。</font><font style="vertical-align: inherit;">この派生物に基づいて別のクラスを簡単に作成したい場合があります。</font><font style="vertical-align: inherit;">それだけです。これは定型ではなく、パラメータを受け入れなくなりました。</font><font style="vertical-align: inherit;">だから私は二番目の派生クラスを一次導関数からベースクラスに渡すというアイデアを思いつきました。</font><font style="vertical-align: inherit;">（足元の細い氷が割れるようになりました...もう戻りのないところに行っていました。）でも、一度やれば、好きなだけやることができます。派生クラスが10個あったとしても、10回連続で（最後の1つ）チェーンに沿ってベース1に渡すと、必要なこの最後の導関数の関数が呼び出されます（一般的に言えば、必要に応じて中間の1つ）。</font><font style="vertical-align: inherit;">タスクは明確でした。</font><font style="vertical-align: inherit;">残ったのはそれをすることでした。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメーター化されたウィンドウクラス-メソッド2</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2回目の実行では、3つのタスクを設定しました。</font></font><br>
<ul>
<li>-     ;</li>
<li>   ;</li>
<li>   ,   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、これらの要件に準拠するには、デザイナーのテンプレートを作成し、それに特別なパラメーターを追加する必要があります。ただし、これは別の要件の違反を意味します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでの解決策は何ですか？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
元のWindowClass基本クラスを2つのコンポーネントに分割できます。単一の揺るぎない基盤であるWindowClass自体（ここではWindowClassBaseと呼びましょう）と、派生クラス（同じ元のWindowClass名と呼ぶことができる）を補完します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
補足クラスはOnCreateの実装を担当し、さらに、全体としてパラメーター化することもできます。そして彼のコンストラクターで、特別なパラメーターを通じて渡された型をWindowClassBaseクラスのコンストラクターに渡します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いずれにせよ、ソースに関連するWindowClassBaseでは、いくつかの変更を行う必要があります。まず、OnCreateを実際に削除することに加えて、それを補足するクラスにポインターメンバー（および将来的にはその派生物）を追加する必要があります。また、このポインターによってOnCreateを呼び出す呼び出し関数：基本のポインターを呼び出すことはできません。 OnCreateはもはや含まれていないため、補完的であり、そこから派生したクラスのOnCreateは、ベースのthisポインターで何かを試みるよりも、目的のクラスへの正しいポインターで呼び出す方が適切です。最終的に、WindowClassBaseコンストラクターの特別なパラメーターは、型推論のためだけでなく、OnCreateを通じて必要なクラスを保存して呼び出すためにも必要になります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、このポインタの型は無効にする必要がありました：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスはテンプレートではないため、型が不明なポインターを作成するようコンパイラーに指示することはできません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの派生物は基本クラスから継承され、それらはすべて異なるタイプを持っています-どのタイプのポインターを使用する必要がありますか？</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、私はそれをCスタイルで宣言しました。奇妙な状況では、voidへのポインターを使用します。</font><font style="vertical-align: inherit;">ポインターは物理的には型なしとして格納されますが、呼び出し時に、OnCreateは呼び出されたクラスの型にキャストされます。</font><font style="vertical-align: inherit;">これは、WindowClassBaseに属し、呼び出し時にパラメータタイプがわかっている特別なテンプレート呼び出し関数で行われます。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd)</span>
</span>{
	<span class="hljs-comment">//  OnCreate   WndCls,  OnCreate   </span>
	<span class="hljs-keyword">if</span> (p_drvWndCls)<font></font>
		(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;WndCls::OnCreate(hWnd);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（最初は、std :: true_typeまたはstd :: false_typeを2番目のパラメーターとして使用して、関数をオーバーライドする目的のオプションを選択しました。SFINAEメソッドを使用して、WndClsクラスにOnCreateメンバー関数があるかどうかをコンパイル段階で確認しました。そうである場合、上記のバージョンの関数が呼び出されます。そうでない場合、OnCreateの呼び出しは次の形式で行われました。</font></font><br>
<pre><code class="cpp hljs">(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;OnCreate(hWnd);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、SFINAEは不要であることが判明しました。WindowClassBaseを補完するクラスには、いずれの場合もOnCreateメンバー関数があるため、渡されたWndClsパラメータークラスにOnCreateが定義されていなくても、それに関する基本クラスの1つにあります。 、およびチェックはすべてのケースでtrueになります。奇跡によって、OnCreateが削除されるように補足クラスが変更され、それから派生したすべてのクラスでもそれが行われない場合、2番目のオプションに従ってそれを呼び出す意味はありません。そのようなコードは単にコンパイルされません。したがって、最終的には、上記のオプションがここに示されます。）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WindowClassBaseの基本クラス型を受け入れて使用するロジックは非常に簡単です。型はWindowClassBaseコンストラクターに渡された派生クラスのオブジェクトへのポインターから派生し、このポインターはこのコンストラクターに格納され、テンプレートウィンドウプロシージャへのポインターは渡された型によってインスタンス化され、上記のLaunchOnCreateにアクセスされます。 。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、WindowClassBaseクラスは次のようになります。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassBase</span>				//  <span class="hljs-title">Windows</span>
{</span>
<span class="hljs-keyword">protected</span>:						<span class="hljs-comment">//   !</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;				<span class="hljs-comment">// </span>
	<span class="hljs-keyword">void</span> *p_drvWndCls;								<span class="hljs-comment">//   ,    (..  -  </span>
													<span class="hljs-comment">//,   ( )   , ..   void</span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List wndList;							<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span><font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd)</span>
	</span>{
		<span class="hljs-comment">//  OnCreate   WndCls</span>
		<span class="hljs-keyword">if</span> (p_drvWndCls)<font></font>
			(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;WndCls::OnCreate(hWnd);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">friend</span> List;
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">friend</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//     </span>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassBase(WindowClassBase&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassBase();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、これが最も短いコンストラクタのコードです：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase::WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle)</span>
</span>{
	<span class="hljs-comment">// ,   ,   wc</span>
	<span class="hljs-comment">// : p_wndClass -    ,        , wc -    </span>
	<span class="hljs-comment">//    Windows, szWndTitle -   </span><font></font>
<font></font>
	WindowClassBase::wc = wc;<font></font>
	WindowClassBase::wc.lpfnWndProc = WndProc&lt;WndCls&gt;;<font></font>
	WindowClassBase::szWndTitle = szWndTitle;<font></font>
<font></font>
	p_drvWndCls = p_wndClass;		<span class="hljs-comment">//    ,   OnCreate()      WM_CREATE</span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	CreateWnd(WindowClassBase::wc, <span class="hljs-literal">false</span>, szWndTitle);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィンドウプロシージャ内では、LaunchOnCreateの呼び出しは次のとおりです。</font></font><br>
<pre><code class="cpp hljs">p_wndClass-&gt;LaunchOnCreate&lt;WndCls&gt;(hWnd);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼はウィンドウプロシージャ自体を外部のクラスから削除し、WindowClassBaseクラスで特権を宣言することにしました。おそらく、これはあまり意味がありませんでした。それは、どのような違いがあり、インスタンス化をどこで生成するのか-クラスの外部か内部かコードセグメントは1つです。確かに、同じカプセル化の観点からは、クラス内で静的にしておくべきでしょう。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
補足的なクラスを定義することは残っています：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClass</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase			<span class="hljs-comment">//,  WindowClassBase    </span><font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">this</span>, hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">this</span>, wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスには、分割前の元のWindowClassと同じように見える、つまり特別なパラメーターがないコンストラクターがあり、このポインターを渡すことによってWindowClassBaseコンストラクターにアクセスすると、この特別なパラメーターが内部的に生成されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この形式のこのWindowClassは、元のWindowClassとほぼ同等です。</font><font style="vertical-align: inherit;">そのため、OnCreateオーバーライドによる継承はサポートされていません。</font><font style="vertical-align: inherit;">ただし、これは継承をサポートするための開始点です（以下に示します）。</font><font style="vertical-align: inherit;">この形式では：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本クラスWindowClassBase自体はジェネリックではありません。つまり、派生クラスが何であれ、それがすべての派生クラスの唯一のクラスになります。</font><font style="vertical-align: inherit;">他のすべてのWindowsメッセージが正しく処理されることを確認するためのリストも唯一のものです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassコンストラクターには、特別なパラメーターはありません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、3つの要件のうち2つは満たされています。</font><font style="vertical-align: inherit;">後者を扱うことは残ります：継承です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassBaseの派生クラス型チェーン、コントロール型</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、WindowClassの初期化ロジックが適切ではなく、派生クラスを作成して（少なくとも現時点では）変更したい場合に、1回限りの継承を検討します。</font><font style="vertical-align: inherit;">これを確実にするためにWindowClassで何を変更する必要がありますか？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
補完クラスの新しいバリアントは定型になります。</font><font style="vertical-align: inherit;">実際にはデータが含まれておらず、OnCreate関数とコンストラクタのみが含まれているため、これは恐ろしいことではありません。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerWndCls *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerWndCls *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このクラスは、DerWndCls型のパラメーターを受け取り、thisポインターをそれに変換して、WindowClassBaseに渡します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
static_castに注意してください。私の変換はもともと次のようなCスタイルで記述されているため、これは重要です。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase((DerWndCls *)<span class="hljs-keyword">this</span>, hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase((DerWndCls *)<span class="hljs-keyword">this</span>, wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}	<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あらゆる場所でstatic_castに変換した後、コードの半分（下記を参照）がコンパイルされませんでした。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これもデリケートな点です。変換はコンパイル段階で実行されますが、このクラス自体にOnCreate関数があり、変換後、DerWndClsを使用してDerWndClsクラスのOnCreateを呼び出すことができます。</font><font style="vertical-align: inherit;">これは、WindowClassBase内で前述した変換ケースとの違いです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、特定のクラスWindowClassDerivedを作成し、その中でOnCreateをオーバーライドして、上記のWindowClassTemplateでインスタンス化し、記事の冒頭に示した同じ元の奇妙な繰り返しテンプレートを再び実装できます。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;WindowClassDerived&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerived(WindowClassDerived&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、このWindowClassDerivedのOnCreateは、必要に応じてWindowClassBase内で呼び出されます。</font></font><br>
<pre><code class="cpp hljs">WindowClassDerived::WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle) : WindowClassTemplate(hInstance, szClassName, szWndTitle)<font></font>
{<font></font>
	usiWndNum++;		<span class="hljs-comment">//    </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これは1回限りの継承です。</font><font style="vertical-align: inherit;">多重継承の場合は、WindowClassDerivedの代わりに、新しいテンプレートを宣言し、クラスを階層の1つ上のレベルにしてWindowClassTemplateに渡す必要があります。</font><font style="vertical-align: inherit;">特に2つの重要なポイントを強調します。</font></font><br>
<ol>
<li><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">階層内でクラスをホストする</font><b><font style="vertical-align: inherit;">可能性</font></b><font style="vertical-align: inherit;">があります。</font><font style="vertical-align: inherit;">つまり、どのクラスも受け入れない可能性があります。つまり、それ自体が階層の最上位クラスになり、オブジェクトを作成できるようになります。</font></font></li>
<li><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータWindowClassTemplateを</font><b><font style="vertical-align: inherit;">送信してい</font></b><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">つまり、受け入れられたテンプレート引数は、継承チェーン全体を通じて最下位のWindowClassTemplateにあり、そこからWindowClassBaseにクラス間で渡される必要があります。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、一方でクラスはテンプレートであり、特定のクラスをパラメーターとして受け取る必要があります。一方、それ自体が（インスタンス化の時点で）有限クラスである状況を監視し、転送された型ではなく、それ自体で基本クラスをインスタンス化する必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべてについて、コンパイラーによって自動的に行われることを望みます。既に作成されたクラスに基づいて新しいクラスを定義する場合、後者を変更する必要はありません。継承多相性の本質はすべて失われます。つまり、私は現在階層の最上位にあるクラスを作成しますが、</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おそらく</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これに基づいて新しいクラスが作成され、その定義を変更せずに現在のクラスを置き換えます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この機能を実装するには？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動化とインテリジェントな意思決定の問題を解決するために、テンプレートのデフォルト引数のバリアントがそれ自体を提案します。現在作成されているクラスが最上位であり、テンプレートパラメーターがそれに渡されない場合、このパラメーターをそれに割り当てる必要があります。これは、デフォルトの引数を使用して行われます。次に、次の質問が発生します。それを選択する方法と、明示的に渡されるパラメーターの状況に関連付ける方法、およびパラメーターが渡されない場合はそれ自体を転送する方法？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、独自の定義済みクラスをデフォルトのパラメーターとして作成することはできません。コンパイラは、次の形式のコードを見逃すことはありません。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">WindowClassDerived</span>&lt;&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;DerWndCls&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼は、再帰型の依存関係が複雑すぎると報告しています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
反対側に行きましょう。</font><font style="vertical-align: inherit;">機能的に何も実行せず、何も保存しない特定の架空のクラスを紹介します。ダミープラグのみの役割を果たし、その外観の場合は「上から」何も転送されないことをコンパイラーに通知します。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};	<span class="hljs-comment">//-,     </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてデフォルトの引数では、このギャグを自分で置き換えます：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;DerWndCls&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このオプションを使用すると、デフォルトの引数がある状況では、thisclassがWindowClassTemplateに渡されます。</font><font style="vertical-align: inherit;">thisclassクラスにはOnCreateメンバー関数がないため、このオプションはコンパイルされません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、どのタイプを渡すかを決定することに基づいて、2番目の補助制御パラメーターを導入してみましょう。</font><font style="vertical-align: inherit;">もちろん、これを行うには、たとえば次のようにWindowClassTemplateを変更する必要があります。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassControlBaseTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
	<span class="hljs-comment">//  ControlType == thisclass,      DerWndCls,    ,   WindowClassBase</span>
	<span class="hljs-comment">//  ControlType != thisclass,    ControlType,        ( </span>
	<span class="hljs-comment">//    ControlType     )</span>
	<span class="hljs-keyword">using</span> DerivedWndClassType = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;ControlType, thisclass&gt;::value, DerWndCls, ControlType&gt;;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassControlBaseTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassControlBaseTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}	<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
送信されるのは1つのタイプではなく、2つのタイプです。これら2つのタイプの組み合わせに基づいて、最終的なタイプは、&lt;type_traits&gt;ツールを使用して決定されます：std :: conditional_tおよびstd :: is_same。 WindowClassBaseに渡されるのはこのタイプです。選択ロジックはコメントで説明されています。このクラスがControlTypeに渡される場合は、DerWndClsを選択します。それ以外の場合は、ControlType自体が選択されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、継承時にそれを使用するテンプレートを作成します。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndClsDerivedTemplateClass</span> :</span> <span class="hljs-keyword">public</span> WindowClassControlBaseTemplate&lt;WndClsDerivedTemplateClass&lt;DerWndCls&gt;, ControlType&gt;		<span class="hljs-comment">//      </span><font></font>
{<font></font>
<span class="hljs-keyword">protected</span>:
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;		<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WndClsDerivedTemplateClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WndClsDerivedTemplateClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WndClsDerivedTemplateClass(WndClsDerivedTemplateClass&amp;);	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WndClsDerivedTemplateClass() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のパラメーターはデフォルトでthisclassを通じて初期化され、ControlTypeはDerWndCls自体に基づいて計算されます。DerWndCls= thisclassの場合、ControlType：= thisclass、それ以外の場合はControlType：= DerWndCls（特に、比較と区別するために指定されたPascalスタイルの割り当て）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、DerWndClsによってパラメーター化されたWndClsDerivedTemplateClassクラス自体が、（コンパイル段階で）計算されたコントロールタイプと共に渡されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このクラスのオブジェクトを作成する場合、つまり、WndClsDerivedTemplateClass自体が階層の最上位である場合、DerWndCls = ControlType = thisclassになり、&lt;WndClsDerivedTemplateClass、thisclass&gt;が渡されます。 WndClsDerivedTemplateClassがダミーでパラメーター化されているという事実は問題ではありません。この型、および実際に渡されたDerWndClsは、クラス内では決して使用されません。オブジェクトはオブジェクトから作成されず、関数は呼び出されません。したがって、正式にはWndClsDerivedTemplateClassは、文字どおり何でもインスタンス化できます。パラメーターの型は、継承の線に沿ってさらに渡すためにのみ機能します。しかし、ここでは、DerWndClsの代わりに、WndClsDerivedTemplateClass &lt;thisclass or other type&gt;が渡されました、それは重要です：WndClsDerivedTemplateClassにはOnCreate関数があり、これはWindowClassBase内で呼び出されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このオプションを使用すると、thisclassはControlTypeの代わりにWindowClassControlBaseTemplateになり、最終的なタイプは、OnCreate関数が必要なDerWndCls = WndClsDerivedTemplateClassとして表示されます。これが私たちに必要なものです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、WindowClassControlBaseTemplate（さらに継承）に基づいて新しいクラスを構築する場合のオプションを検討します。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、WndClsDerivedTemplateClassでは、thisclass以外のものがDerWndClsの代わりになり、ControlTypeはこの違いを確認して、DerWndClsに渡された値を取ります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、WindowClassControlBaseTemplateで、次のパラメーター化オプションが使用されます：&lt;WndClsDerivedTemplateClass &lt;WindowClassDerivedTemplateNext&gt;、WindowClassDerivedTemplateNext&gt;。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、WindowClassControlBaseTemplateでは、ControlType！= Thisclassなので、ControlType自体が使用されます。これは、OnCreateを選択するための適切なクラスであるWindowClassDerivedTemplateNextと同じです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一見すると、このようなスキームでは、すべてが良いようです。しかし、これはそうではありません。後者に基づいて別のクラスを構築します。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext2</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedTemplateNext&lt;WindowClassDerivedTemplateNext2&lt;DerWndCls&gt;&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WindowClassDerivedTemplateNextでは、WindowClassDerivedTemplateNext2がDerWndClsを置き換えます。 ControlTypeもWindowClassDerivedTemplateNext2として出力されます。次に、WindowClassDerivedTemplateNext </font><font style="vertical-align: inherit;">&lt;WindowClassDerivedTemplateNext2&gt; </font><font style="vertical-align: inherit;">が</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WndClsDerivedTemplateClass</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">渡され</font><font style="vertical-align: inherit;">、ControlTypeが同じWindowClassDerivedTemplateNext &lt;WindowClassDerivedTemplateNext2&gt;を表示します。次に、同じ値がWindowClassControlBaseTemplateに渡され、そこで、正しいWindowClassDerivedTemplateNext2 &lt;WindowClassDerivedTemplateNext&gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassDerivedTemplateNext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;WindowClassDerivedTemplateNext2erDerminalDiveTer WindowTextが呼び出されます。WindowClassだけでなく、OnCreate関数ClassDementTableplate Windowも呼び出されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このパラメーターの継承と受け渡しのスキームで</font><font style="vertical-align: inherit;">は、結果としてWindowClassControlBaseTemplateに渡されたクラス</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自体の</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプ</font><font style="vertical-align: inherit;">が重要であり、パラメーター化されたものではないことを思い出します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、OnCreateが呼び出される型が正しく表示されるようにするには、WindowClassDerivedTemplateNextクラスの定義を変更する必要があります。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;, ControlType&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、WndClsDerivedTemplateClassでは、WindowClassDerivedTemplateNext2と等しい正しい値が、間違った値で表示される代わりに、ControlTypeに渡されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、構築している最後のクラスはControlTypeを渡してはならず、最も近い基本1が独立して出力できるようにします。この基本1とすべての基本クラスは明示的にControlTypeを渡して、誤った値への自動出力を禁止する必要があります。このアプローチ</font><font style="vertical-align: inherit;">は、最も近い基本クラスの定義の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更を</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">意味し</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。これは、ソースコードを利用できる場合、または以前に自分でビルドした場合にのみ可能です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを忘れてこのルールに違反した場合、static_castを使用するとコンパイルエラーが発生し、WindowClassControlBaseTemplate内でCスタイルのポインターを変換すると、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正しく動作</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し</font><b><font style="vertical-align: inherit;">ない</font></b><font style="vertical-align: inherit;">プログラムが発生</font><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">ます。たとえば、クラスのオブジェクトを作成しようとすると</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;, ControlType&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、コンパイラーはエラーを出します。型が正しくなかったため変換できないため、WindowClassControlBaseTemplate内のポインター型を変換できません（WindowClassDerivedTemplateNextクラスのオブジェクトを作成するため、WindowClassDerivedTemplateNextクラス自体が一番上にあると想定します。階層、およびこの場合、上記のように、ControlTypeは渡されません）。 static_castがない場合、コードはコンパイルされ、間違ったクラスのOnCreateを呼び出すだけです。ただし、ControlType送信を削除すると、プログラムが再度コンパイルされます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結局のところ、これはすべて複雑すぎて信頼性が低く、すべてのクラスのソースコードを利用できる必要があります。</font><font style="vertical-align: inherit;">さらに、最後の派生クラスのオブジェクトしか作成できず、ControlTypeの転送が原因でその基本クラスの1つを作成できません（または、ポインターがCスタイルで渡された場合は作成できますが、これらのオブジェクトは正しく初期化されません）。</font><font style="vertical-align: inherit;">シンプルで信頼性の高い別のソリューションが必要です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数テンプレート</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでも、上記のテンプレート継承のバリアントと、作成されたオブジェクトのタイプをウィンドウが作成されてOnCreate呼び出しが行われるWindowClassBaseクラスに渡すことには、重大な欠点があります。他にも信頼性が高く効率的なオプションが必要です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 11では、新しいタイプのテンプレートが導入されています。引数の数が可変のテンプレート、または可変のテンプレートです。そのパラメータは、長さが不明な一連のタイプのシーケンスです。前の例でのコントロールタイプによる危険な操作の代わりに、私は別の方法をとることに決めました：階層の中間クラスが誤ったパラメーター化によって階層の親クラスを置き換える状況を回避するため（上​​記の例では、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassDerivedTemplateNextでした）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;WindowClassDerivedTemplateNext2&gt;）を使用すると、通常、これらのクラスを順番に並べて配置するだけで、このタイプのパラメーター化を取り除くことができます。たとえば、テンプレートパラメータに3つの連続した継承があると、最終的に次のリストが形成されます：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&lt;WndCls3 &lt;&gt;、WndCls2 &lt;&gt;、WndCls1 &lt;&gt;&gt; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このリストの処理、より正確には、最終的な要素の1つ（構成方法によって異なります）階層内の目的のクラスを抽出して操作できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、ルートWindowClassBaseに最も近く、他のすべての継承の基礎を形成する、前述のWindowClassTemplateおよびWindowClassControlBaseTemplateテンプレートの代わりに、新しい変数テンプレートクラスを作成する必要があります。最も単純なバージョンでは、次のようになります。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,      </span>
<span class="hljs-keyword">template</span>&lt;class... Classes&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadicTemplate</span>;</span>		<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-comment">//,          </span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>, <span class="hljs-title">class</span>... <span class="hljs-title">OtherWindowClasses</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassVariadicTemplate</span>&lt;DerWndCls, OtherWindowClasses...&gt; :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
	<span class="hljs-comment">//      :    - DerWndCls</span>
	<span class="hljs-keyword">using</span> DerivedWndClassType = DerWndCls;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassVariadicTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassVariadicTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、本文なしのクラステンプレートの一般的な説明が宣言されます。次に、最初のタイプが他のタイプから分離される彼の専門分野が決定されます。私たちに興味があるのは彼です。これは、階層チェーンをWindowClassBaseに移動するときに、後続の各クラスがそれ自体</font><font style="vertical-align: inherit;">をパラメーター</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リストの</font><b><font style="vertical-align: inherit;">最後に配置する</font></b><font style="vertical-align: inherit;">場合に当てはまり</font><font style="vertical-align: inherit;">ます。その後、必要なクラスは最初にあり、それを他のクラスから分離するのは非常に簡単です。あなたは別の方法で行うことができます：新しいクラスはそれぞれ</font><b><font style="vertical-align: inherit;">最初</font></b><font style="vertical-align: inherit;">に自分自身を置きます</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テンプレートオプションのリスト。すると、階層の最上位のクラスがリストの最後になり、そこからクラスを抽出することははるかに困難になります。この特定のケースでは、これら2つのアプローチは完全に同じですが、最初の方法ははるかに簡単に実装できます（コンパイル時を含む-リストから最後の要素を抽出してリスト全体を処理する必要はありません）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
階層の最上位のクラスである最初の要素は、リストから取得され、WindowClassBaseに渡されます。 OnCreateが定義されている場合は、呼び出されます。そうでない場合、最も近い基本クラスのOnCreateがそれに関連して呼び出されます。可変パラメーターリストが空の場合（WindowClassVariadicTemplateからオブジェクトを作成しようとしている）、コンパイルは失敗し、パラメーターリストに少なくとも1つの型が必要です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WindowClassVariadicTemplateに基づく最初のクラスは次のようになります。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic1</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadicTemplate&lt;PrevWndClasses..., WindowClassVariadic1&lt;&gt;&gt;<font></font>
{<font></font>
<span class="hljs-keyword">protected</span>:
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassVariadic1(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassVariadicTemplate(hInstance, szClassName, szWndTitle)<font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassVariadic1(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassVariadicTemplate(wc, szWndTitle)<font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
	WindowClassVariadic1(WindowClassVariadic1&amp; wcObj) : WindowClassVariadicTemplate(wcObj)			<span class="hljs-comment">// </span><font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassVariadic1() <span class="hljs-keyword">override</span>		<span class="hljs-comment">// </span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (hWnd)
			<span class="hljs-keyword">this</span>-&gt;OnClose(hWnd);		<span class="hljs-comment">// ,    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_PAINT   </span>
	</span>{<font></font>
		...<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_DESTROY   </span>
	</span>{<font></font>
		...<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このクラスは、PrevWndClassesパラメーターの未定義リストを受け入れ、それを基本クラスにさらに渡し、パラメーターの空のリストを持つ最初の要素としてその前に自分自身を挿入します。</font><font style="vertical-align: inherit;">このクラスWindowClassVariadic1自体は可変であるため、WindowClassVariadic1 &lt;&gt;もパラメータなしで可変であり、このクラスのシーケンス全体は実際には可変テンプレートであり、その各要素も可変テンプレートです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の派生クラスは次のとおりです。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic2</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadic1&lt;PrevWndClasses..., WindowClassVariadic2&lt;&gt;&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
派生物とベースの名前を変更することを除いて、クラスの形式は前のものとまったく同じです。</font><font style="vertical-align: inherit;">次のクラスも同様です。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic3</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadic2&lt;PrevWndClasses..., WindowClassVariadic3&lt;&gt;&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ポリモーフィックな多重継承の意味です。この方法でクラスを宣言することにより、このタイプのオブジェクトの作成だけでなく、それから派生する他のすべてのクラスのすべてのオブジェクトも、将来のオブジェクトの量に関係なく保証されます。この場合、正しいOnCreateは常にWindowClassBaseで呼び出されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、この変数テンプレートは、以前に設定されたすべての要件を完全に満たすウィンドウを作成するときにOnCreateを呼び出す問題を解決する最初の有効な方法です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今後、特定の状況で最適なメソッドが最終的に見つかった場所で、変数テンプレートによる継承の実装により、WindowClassBaseでより複雑なコンパイルロジックを実装できます。継承が発生したすべての型にアクセスできるため、必要な型から柔軟に選択できますまたは基準とそれに定義されたメンバー関数を呼び出します。</font><font style="vertical-align: inherit;">しかし、これはまだ少し異なるケースです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化クラス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
派生型へのstatic_castの反応を認識せずに、私は引き続き、階層の頂点クラスのWindowClassBaseへの転送を実装する他の方法を探しました。</font><font style="vertical-align: inherit;">ある時点で、OnCreate実装を特別に作成された別のクラスに持ってくることを考えました。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassInit1</span>
{</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span>				<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このクラスは、仮想関数の他のすべてのオーバーライドを実装する別のクラスをパラメーター化します。</font><font style="vertical-align: inherit;">これは、すでに説明したWindowClassTemplateから派生しています。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndClsInit</span> = <span class="hljs-title">WindowClassInit1</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedI1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;WndClsInit&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法では：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスの継承は、仮想関数に対して通常どおり発生します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnCreate実装用に特別に定義された初期化クラスのみが、継承チェーンに沿ってクラス間で転送されます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このクラスが階層の最上位にある場合、WndClsInitパラメータはWindowClassInit1（このクラスに定義されている初期化クラス）と等しくなり、階層チェーンに沿ってさらに転送されます。このクラスがチェーンの中間にある場合は、渡されたクラスをそのまま受け入れて渡します。次に、このオプションは以前のオプションと比較して、テンプレート自体は転送されませんが、実装が簡単な（実装されている）サードパーティクラスを転送するという点で優れています。この形式のテンプレートは、継承チェーン全体の実装に変更を加えることなく適しています。クラス名の変更のみが発生します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、static_castは、Cスタイルの変換とは異なり、WindowClassTemplate内でこの形式の継承を見逃すことはありません。これを（WindowClassTemplate *）から（WindowClassInit1 *）に渡すと、変換できません。</font><font style="vertical-align: inherit;">そしてこれは論理的です：WindowClassInit1は実際には無関係なクラスであり、単純にこのポイントに型として渡されます。これは、WindowClassTemplateおよびその派生クラス全体とはまったく接続されていないため、ポインタへの変換は受け入れられません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassBaseでの派生クラス型チェーン、条件付き転送</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に、この状況で、継承チェーン全体を通じて派生クラスのタイプをルートベースWindowClassBaseに転送するための最良の方法が見つかりました。これには、以前のものの欠点がなく、同時に変数テンプレートよりも簡単です。</font><font style="vertical-align: inherit;">WindowClassTemplateに基づいて次のテンプレートクラスを定義します。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative1&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassDerivedAlternative1(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassTemplate(hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerivedAlternative1(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassTemplate(wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerivedAlternative1() <span class="hljs-keyword">override</span>	<span class="hljs-comment">// </span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (hWnd)
			<span class="hljs-keyword">this</span>-&gt;OnClose(hWnd);	<span class="hljs-comment">// ,    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>			<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>	<span class="hljs-comment">//  WM_PAINT   </span>
	</span>{
		<span class="hljs-comment">//  WM_PAINT   </span><font></font>
		HDC hDC;<font></font>
		PAINTSTRUCT ps;<font></font>
		RECT rect;<font></font>
<font></font>
		hDC = BeginPaint(hWnd, &amp;ps);<font></font>
<font></font>
		GetClientRect(hWnd, &amp;rect);<font></font>
		DrawText(hDC, TEXT(<span class="hljs-string">"       ( )."</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<font></font>
<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このクラスは、パラメーターとしてDerWndClsを受け入れます。デフォルトでは、このクラスと同じです。</font><font style="vertical-align: inherit;">転送中に、DerWndClsはthisclassと比較されます。等しい場合（デフォルト値、つまり、指定されたクラスが階層の最上位にある場合）、パラメーターの空のリストを渡します。</font><font style="vertical-align: inherit;">それ以外の場合は、受信したDerWndClsが渡されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はこの解決策がすべての点でこの状況で最良であると考えています：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">継承チェーン全体の単一形式のクラス定義。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">継承チェーン全体に沿ったクラス転送のシンプルで透過的なロジック。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可変テンプレートによるオーバーヘッドはありません（この場合、このように、これが不要な場合）。</font></font></li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ひどい報復</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはどういう意味ですか？</font><font style="vertical-align: inherit;">つまり、このような型破りな継承形式を使用したい場合は、すべてのクラスを厳密に定義された方法で設計して、新しい派生クラスを自分で転送できるようにする必要があります。</font><font style="vertical-align: inherit;">これは非常に簡単な要件であり、必要に応じて従うことも簡単です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、もう1つ、もっと重要な問題があります。それは、型とポインタの関係です。</font><font style="vertical-align: inherit;">賢い人はこう書いています：コンストラクターでそのようなことをいじってはいけません。言語の原則とコンパイラーのロジックに反してください。</font><font style="vertical-align: inherit;">しかし、私は従わず、とにかくそれをしました。</font><font style="vertical-align: inherit;">今や自然な報復がやって来ます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、4つのクラスがあります。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative1&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
…<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative2</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative2&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	…<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative3</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative2&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative3&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	…<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative4</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative3&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative4&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	…<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上で書いたように、それらの特定の内容と作業のロジックは完全に重要ではありません。</font><font style="vertical-align: inherit;">唯一重要なのは、クラス定義のタイトルです。</font><font style="vertical-align: inherit;">これらのクラスに基づいて、4つのオブジェクトを作成します。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">WindowClassDerivedAlternative1&lt;&gt; <span class="hljs-title">w1</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative1"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative1"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative2&lt;&gt; <span class="hljs-title">w2</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative2"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative2"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative3&lt;&gt; <span class="hljs-title">w3</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative3"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative3"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative4&lt;&gt; <span class="hljs-title">w4</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative4"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative4"</span>))</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デフォルトの引数を使用して、空の大括弧の後ろに隠された型の定義を拡張します。タイプw1はWindowClassDerivedAlternative1です。タイプw2はWindowClassDerivedAlternative2で、その基本クラスはWindowClassDerivedAlternative1 &lt;WindowClassDerivedAlternative2&gt;です。タイプw3はWindowClassDerivedAlternative3、その基本クラスはWindowClassDerivedAlternative2 &lt;WindowClassDerivedAlternative3&gt;、およびその基本クラスはWindowClassDerivedAlternative1 &lt;WindowClassDerivedAlternative3&gt;です。同様に、4番目のオブジェクトについても同様です。次の図を見てください。</font></font><br>
<img src="https://habrastorage.org/webt/bu/b5/nn/bub5nnsttowpw1lhstypwm-3vfc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このように定義された特定の基本クラスに基づいて新しい派生クラスをそれぞれ作成することにより、新しいクラスだけでなく、その基本クラスのチェーン全体を繰り返し定義します。独自の基本クラスのチェーンと並列になります。クラスには独自の基本クラスがあり、これらすべてのクラスの生成コードが同じであるにもかかわらず、元の基本クラスに導くことはできません。それは本当のファンタジーのようですが、それは本当にです！つまり、継承されたクラスとポインタを操作する通常の方法はすべて機能しません。この特定のアーキテクチャでは、ベースWindowClassBaseのみが状況を保存します。それ以外の場合は、ベースクラスから配列を作成することもできません（たとえば、WindowClassTemplateに基づいて）。そのようなクラスにはすべて異なるタイプがあるためです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、よく知られている理解可能な形式の定義：</font></font><br>
<pre><code class="cpp hljs">WindowClassDerivedAlternative1&lt;&gt; *p2 = &amp;w2;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... 30分前にWindowClassDerivedAlternative1 &lt;&gt;クラスから派生したクラスを作成し、それに基づいてw2オブジェクトが作成されたにもかかわらず、w2オブジェクトのタイプと互換性のないタイプポインターを作成しようとしているため、コンパイルが停止します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
習慣的な法律が機能しなくなると、ショックを引き起こす可能性があります。</font><font style="vertical-align: inherit;">そしてこれらすべてにより、実際にはダーティーなコンパイラのハック、強制的な型変換、その他の本当に悪いことはありません。</font><font style="vertical-align: inherit;">テンプレート、デフォルトのパラメーター、タイプライブラリツールなど、すべてが非常にクリーンで合法です。</font><font style="vertical-align: inherit;">使い慣れたコード作成メソッドのみが機能を停止します。</font><font style="vertical-align: inherit;">これを実際のプロジェクトで使用することは、危険ゾーンを宣言することを意味します。危険ゾーンは、適切な保護対策を備えた資格のある専門の担当者のみが入ることができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード実験</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実験に興味のあるすべての人が簡単に入力できるようにするために、この記事の基礎となったすべてのプロジェクトをGitHubに投稿しました：</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/SkyCloud555/ECRTP最初の</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
プロジェクトとして順番に1つのプロジェクトを選択するだけです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「これがすべてこのような冗談だとしたら、費やされた努力を考えると、それはあまりにも深刻で自然に見えます。</font><font style="vertical-align: inherit;">そして、冗談ではないにしても、彼らの正しい心の通常の開発者は、実際にそのようなものを使用しません。</font><font style="vertical-align: inherit;">とにかく、おかしなことに、あなたはナンセンスに苦しんで</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お金をもたらす</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ような</font><s><font style="vertical-align: inherit;">ことをしに</font></s><font style="vertical-align: inherit;">行かないのではないでしょうか</font><s><font style="vertical-align: inherit;">、それは</font></s><font style="vertical-align: inherit;">役に立ちます。」</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そう思うならあなたは正しい。</font><font style="vertical-align: inherit;">この記事では、C ++ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これらの構造の実用化の問題は未解決のままです。そして一般的に、これは一般化されたメタプログラミングに適用される可能性が高くなります。これらのクラスのオブジェクトを作成する必要はまったくありませんが、クラス自体が何らかの理由で必要になる場合があります。はい、そしてあなたはこれに基づいてあなたがどのような有用な解決策を思いつくことができるかを決して知らない...オリジナルのCRTPが使われています！そして、それはどこでも使用されていませんが、標準ライブラリで使用されています！信じない人、覚えていない人、google std :: en_shared_from_this。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
、特に今...窓が元のタスクに戻るとまじめ</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や草なしで</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは、私はすでに万回を旅してきた陳腐な話題に触れているという事実を破棄した場合でも... 3年後、このすべての背中を見て、これは長いのでために、誰に興味のないされている</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際の男の子</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常の人々は</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MFC</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qtを</font><font style="vertical-align: inherit;">持っています</font><font style="vertical-align: inherit;">、私はいくつかの機能オブジェクトがウィンドウクラスに渡されることを保証するだけです。</font><font style="vertical-align: inherit;">継承のチェーンを通じて確実に転送することは難しくありませんが、すべてを単純に、明確に、歪みなしに実行し、副作用のない完全に通常の予測可能なクラスを取得します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事で起こったことは、私がまだ解決できた興味深い重要なタスクです。</font><font style="vertical-align: inherit;">これもおもしろかったと思います。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja507114/index.html">オードエクセル：34年の魔法</a></li>
<li><a href="../ja507116/index.html">「削除されました。」昨日のオフィスデベロッパーからのメモ。パート2</a></li>
<li><a href="../ja507124/index.html">PDBは貴重な毛皮だけではありません</a></li>
<li><a href="../ja507132/index.html">ウラジミール・キトフ：「先駆的な科学者が1950年代に普遍的なコンピューター化をどのように予見したかを理解することは不可能です！」</a></li>
<li><a href="../ja507138/index.html">地球データ科学としての21世紀の地質学</a></li>
<li><a href="../ja507148/index.html">Node.jsを使用してマジックリンクを送信する</a></li>
<li><a href="../ja507150/index.html">JavaScriptで干渉画像を描きます</a></li>
<li><a href="../pt486176/index.html">Memorando de correspondência por e-mail corporativo</a></li>
<li><a href="../pt486178/index.html">FOSS News No. 1 - revisão de notícias gratuitas e de código aberto de 27 de janeiro a 2 de fevereiro de 2020</a></li>
<li><a href="../pt486180/index.html">Dicas e fontes para criar aplicativos sem servidor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>