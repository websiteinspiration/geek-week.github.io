<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌎 💲 👨🏽‍🚀 枚举第二部分中的最大值数 ⚠️ 🔓 🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="第一部分，理论  | 第二部分，实用
 
 
 我们继续在枚举中搜索值的最大数量。
 这次，我们将专注于问题的实际方面，并了解IDE，编译器和JVM将如何响应我们的成就。
 
 内容
   
   Javac 工具
   提取方法
   动态类文件常量
     突如其来的困难
     光明的未来...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>枚举第二部分中的最大值数</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501870/"><nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一部分，理论</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;|&nbsp;</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二部分，实用</font></font></b></nobr><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们继续在枚举中搜索值的最大数量。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这次，我们将专注于问题的实际方面，并了解IDE，编译器和JVM将如何响应我们的成就。</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容</font></font></h1><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javac </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">工具</font></a></font><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提取方法</font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动态类文件常量</font></font></a><br>
    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">突如其来的困难</font></font></a><br>
    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">光明的未来</font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不安全的</font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试</font></font></a><br>
    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javac和开关</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">性能</font></a></font><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他资源</font></font></a><br>
<br>
<a name="Tools"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工具类</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javac会照顾我们：它</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会从标识符中切出不喜欢的字符，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并禁止从中继承</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">字符</font></a></font><code>java.lang.Enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此对于实验，我们需要其他工具。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asmtools</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -JVM的汇编器和反汇编器</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">测试</font></a><font style="vertical-align: inherit;">假设</font><font style="vertical-align: inherit;">，并使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库以工业规模生成类文件</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了便于理解，将在类似Java的伪代码中复制正在发生的本质。</font></font><br>
<br>
<a name="Javac"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java语言</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，在没有技巧的情况下，仅靠一个就能获得最佳结果，这是合乎逻辑的</font></font><code>javac</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">一切都很简单在这里-我们创造的源文件，枚举和元素添加到它，直到拒绝的javac编译</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与“代码太大”的诅咒。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从Java 1.7开始，很长一段时间以来，这个数字一直保持在2_746个元素的水平。</font><font style="vertical-align: inherit;">但是在Java 11之后的某个地方，用于在常量池中存储值的算法发生了变化，最大数量减少到2_743。</font><font style="vertical-align: inherit;">是的，是的，只是因为更改了常量池中元素的顺序！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将专注于最好的价值观。</font></font><br>
<br>
<a name="ExtractMethod"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提取方法</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于限制因素之一与静态初始化块中字节码的大小有关，因此我们将尝试使后者尽可能容易。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回顾一下</font></font><code>FizzBuzz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一部分</font><font style="vertical-align: inherit;">中的枚举示例的外观</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">注释提供适当的组装说明。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静态的 {}</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Fizz = <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Fizz"</span>, <span class="hljs-number">0</span>);
    <span class="hljs-comment">//  0: new           #2                  // class FizzBuzz</span>
    <span class="hljs-comment">//  3: dup</span>
    <span class="hljs-comment">//  4: ldc           #22                 // String Fizz</span>
    <span class="hljs-comment">//  6: iconst_0</span>
    <span class="hljs-comment">//  7: invokespecial #24                 // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span>
    <span class="hljs-comment">// 10: putstatic     #25                 // Field Fizz:LFizzBuzz;</span>
    Buzz = <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Buzz"</span>, <span class="hljs-number">1</span>);
    <span class="hljs-comment">// 13: new           #2                  // class FizzBuzz</span>
    <span class="hljs-comment">// 16: dup</span>
    <span class="hljs-comment">// 17: ldc           #28                 // String Buzz</span>
    <span class="hljs-comment">// 19: iconst_1</span>
    <span class="hljs-comment">// 20: invokespecial #24                 // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span>
    <span class="hljs-comment">// 23: putstatic     #30                 // Field Buzz:LFizzBuzz;</span>
    FizzBuzz = <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"FizzBuzz"</span>, <span class="hljs-number">2</span>);
    <span class="hljs-comment">// 26: new           #2                  // class FizzBuzz</span>
    <span class="hljs-comment">// 29: dup</span>
    <span class="hljs-comment">// 30: ldc           #32                 // String FizzBuzz</span>
    <span class="hljs-comment">// 32: iconst_2</span>
    <span class="hljs-comment">// 33: invokespecial #24                 // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span>
    <span class="hljs-comment">// 36: putstatic     #33                 // Field FizzBuzz:LFizzBuzz;</span><font></font>
<font></font>
    $VALUES = <span class="hljs-keyword">new</span> FizzBuzz[] {
    <span class="hljs-comment">// 39: iconst_3</span>
    <span class="hljs-comment">// 40: anewarray     #2                  // class FizzBuzz</span><font></font>
        Fizz, <font></font>
    <span class="hljs-comment">// 43: dup</span>
    <span class="hljs-comment">// 44: iconst_0</span>
    <span class="hljs-comment">// 45: getstatic     #25                 // Field Fizz:LFizzBuzz;</span>
    <span class="hljs-comment">// 48: aastore</span><font></font>
        Buzz, <font></font>
    <span class="hljs-comment">// 49: dup</span>
    <span class="hljs-comment">// 50: iconst_1</span>
    <span class="hljs-comment">// 51: getstatic     #30                 // Field Buzz:LFizzBuzz;</span>
    <span class="hljs-comment">// 54: aastore</span><font></font>
        FizzBuzz<font></font>
    <span class="hljs-comment">// 55: dup</span>
    <span class="hljs-comment">// 56: iconst_2</span>
    <span class="hljs-comment">// 57: getstatic     #33                 // Field FizzBuzz:LFizzBuzz;</span>
    <span class="hljs-comment">// 60: aastore</span><font></font>
    };<font></font>
    <span class="hljs-comment">// 61: putstatic     #1                  // Field $VALUES:[LFizzBuzz;</span>
    <span class="hljs-comment">// 64: return</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先想到的是将数组的创建和填充</font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">放入单独的方法中。</font></font><br>
<br>
<pre><code class="java hljs">$VALUES = createValues();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有了这个想法，就可以将枚举元素实例的创建转移到相同的方法中：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    FizzBuzz[] localValues = createValues();<font></font>
<font></font>
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<font></font>
    Fizz = localValues[index++];<font></font>
    Buzz = localValues[index++];<font></font>
    FizzBuzz = localValues[index++];<font></font>
<font></font>
    $VALUES = localValues;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz[] createValues() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FizzBuzz[] {
        <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Fizz"</span>, <span class="hljs-number">0</span>), 
        <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Buzz"</span>, <span class="hljs-number">1</span>), 
        <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"FizzBuzz"</span>, <span class="hljs-number">2</span>)<font></font>
    };<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
已经更好了，但是每次捕获数组元素和随后的索引增量都花费6个字节，这对于我们来说太昂贵了。</font><font style="vertical-align: inherit;">将它们放在单独的方法中。</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> valueIndex;<font></font>
<font></font>
<span class="hljs-keyword">static</span>  {<font></font>
    $VALUES = createValues();<font></font>
<font></font>
    valueIndex = <span class="hljs-number">0</span>;<font></font>
    Fizz = nextValue();<font></font>
    Buzz = nextValue();<font></font>
    FizzBuzz = nextValue();<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz <span class="hljs-title">nextValue</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> $VALUES[valueIndex++];<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它</font><font style="vertical-align: inherit;">需要11个字节来</font><font style="vertical-align: inherit;">初始化</font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>valueIndex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后从静态初始化块返回</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">还剩下65_524个字节来初始化字段。</font><font style="vertical-align: inherit;">每个字段的初始化需要6个字节，这使我们能够创建10_920个元素的枚举。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一定要用代码生成来庆祝与javac相比增长近四倍！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生成器源代码：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExtractMethodHugeEnumGenerator.java生成的</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
类示例：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExtractMethodHugeEnum.class</font></font></a><br>
<a name="ConDy"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动态类文件常量</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在是时候记住</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 309</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">及其神秘的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动态常数了</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
简而言之，创新的实质是：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在由一组常量支持的现有类型中添加了另一个常量</font></font><code>CONSTANT_Dynamic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。加载类时，此类常量的类型已知，但其值未知。第一次加载常量会导致调用其声明中指定的bootstrap方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该方法的结果变为恒定值。无法更改与已初始化的常量关联的值。这对于一个常量来说是很合逻辑的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您还想到了Singleton，请立即将其忘记。</font><font style="vertical-align: inherit;">该规范单独强调了在这种情况下不能保证线程安全，并且多线程代码中的初始化方法可以被多次调用。</font><font style="vertical-align: inherit;">仅保证在对同一常量多次调用bootstrap方法的情况下，JVM会抛出一个硬币并选择一个计算值作为常量值的作用，而其他值将被牺牲给垃圾收集器。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从行为上讲，可以通过对以下参数执行其bootstrap方法来解析CONSTANT_Dynamic常量： </font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本地查找对象，</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代表常量名称部分的字符串，</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代表期望的常量类型的Class，以及</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任何剩余的引导程序参数。</font></font></li>
</ol><br>
As with invokedynamic, multiple threads can race to resolve, but a unique winner will be chosen and any other contending answers discarded.<br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
到从字节码常量池负载值，提供的命令</font></font><code>ldc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>ldc_w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>ldc2_w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我们首先感兴趣的是- </font></font><code>ldc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与其他方法不同，它只能从常量池的前255个时隙中加载值，但字节码占用的字节数少1个字节。所有这些使我们节省了最多255个字节，并</font></font><code>255 + ((65_524 - (255 * 5)) / 6) = 10_963</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在枚举中</font><font style="vertical-align: inherit;">节省了一个</font><font style="vertical-align: inherit;">元素。这次增长不是那么令人印象深刻，但是仍然存在。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有了这些知识，让我们开始吧。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在静态初始化块中，</font></font><code>nextValue()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们现在将加载动态常量的值</font><font style="vertical-align: inherit;">，而不是方法调用</font><font style="vertical-align: inherit;">。</font></font><code>ordinal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">枚举元素</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">序数索引</font><font style="vertical-align: inherit;">的值</font><font style="vertical-align: inherit;">将被显式传递，从而摆脱了field </font></font><code>valueIndex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，factory方法</font></font><code>nextValue()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并对我们实现的线程安全性表示怀疑。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为引导方法，我们将使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHandle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的特殊子类型，</font><font style="vertical-align: inherit;">该</font><font style="vertical-align: inherit;">子类型</font><font style="vertical-align: inherit;">模仿</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java中</font><font style="vertical-align: inherit;">运算符的行为</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">用于获取此类方法句柄的标准库提供了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHandles.Lookup :: findConstructor（）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">，但在我们的情况下，JVM将负责所需方法句柄的构造。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要将枚举的构造函数用作引导程序方法，必须通过更改签名对其进行略微修改。</font><font style="vertical-align: inherit;">bootstrap方法所需的参数将添加到名称枚举元素和序列号的传统构造函数中：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">FizzBuzz</span><span class="hljs-params">(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; enumClass, <span class="hljs-keyword">int</span> ordinal)</span> </span>{
    <span class="hljs-keyword">super</span>(name, ordinal);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以伪代码的形式，初始化将如下所示：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Fizz = JVM_ldc(FizzBuzz::<span class="hljs-keyword">new</span>, <span class="hljs-string">"Fizz"</span>, <span class="hljs-number">0</span>);<font></font>
    Buzz = JVM_ldc(FizzBuzz::<span class="hljs-keyword">new</span>, <span class="hljs-string">"Buzz"</span>, <span class="hljs-number">1</span>);<font></font>
    FizzBuzz = JVM_ldc(FizzBuzz::<span class="hljs-keyword">new</span>, <span class="hljs-string">"FizzBuzz"</span>, <span class="hljs-number">2</span>);<font></font>
<font></font>
    $VALUES = createValues();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在上面的示例中，这些指令被</font></font><code>ldc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定为方法调用</font></font><code>JVM_ldc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在它们所在的字节码中将是相应的JVM指令。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于现在我们对枚举的每个元素都有一个单独的常量，因此数组的创建和填充</font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也可以通过动态常量来实现。</font><font style="vertical-align: inherit;">bootstrap方法非常简单：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz[] createValues(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; clazz, FizzBuzz... elements) {
    <span class="hljs-keyword">return</span> elements;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此动态常量的静态参数列表中的所有技巧，我们将列出要放入的所有元素</font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BootstrapMethods：</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1：＃54 REF_invokeStatic FizzBu​​zz.createValues：（Ljava / lang / invoke / MethodHandles $ Lookup; Ljava / lang / String; Ljava / lang / Class; [LFizzBu​​zz;）[LFizzBu​​zz;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    方法参数：</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      ＃1＃0：嘶嘶声：LFizzBu​​zz；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      ＃2＃0：嗡嗡声：LFizzBu​​zz；</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      ＃3＃0：FizzBu​​zz：LFizzBu​​zz；</font></font><font></font>
</pre><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVM从这些静态参数破坏数组，并将其作为vararg参数传递给我们的bootstrap方法</font></font><code>elements</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">静态参数的最大数目是传统的65_535，因此，保证枚举的所有元素都足够，无论有多少个元素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于具有大量元素的传输，此更改将减小生成的类文件的大小，并且在由于大量元素而</font></font><code>createValues()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不得不</font><font style="vertical-align: inherit;">将方法</font><font style="vertical-align: inherit;">拆分为几个部分</font><font style="vertical-align: inherit;">的情况下，该方法</font><font style="vertical-align: inherit;">还将时隙保存在常量池中。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，它只是美丽。</font></font><br>
<br>
<a name="Surprise"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">突如其来的困难</font></font></h1><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们通过手动生成类来克服了这一难题。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高级库提供了方便的界面，以换取某些限制的行动自由。</font><font style="vertical-align: inherit;">我们用于生成类文件的ASM库也不例外。</font><font style="vertical-align: inherit;">它没有提供直接控制常量池内容的机制。</font><font style="vertical-align: inherit;">这通常不是很重要，但就我们而言并非如此。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您还记得，我们需要常量池的前255个元素将宝贵的字节保存在静态初始化块中。</font><font style="vertical-align: inherit;">当以标准方式添加动态常量时，它们将位于随机索引处，并与对我们不太重要的其他元素混合。</font><font style="vertical-align: inherit;">这将阻止我们达到最大。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以传统方式形成的常数池的片段</font></font></b>
                        <div class="spoiler_text"><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">恒定池：</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
   ＃1 = Utf8 FizzBu​​zz</font></font><font></font>
   #2 = Class              #1             // FizzBuzz<font></font>
   #3 = Utf8               java/lang/Enum<font></font>
   #4 = Class              #3             // java/lang/Enum<font></font>
   #5 = Utf8               $VALUES<font></font>
   #6 = Utf8               [LFizzBuzz;<font></font>
   #7 = Utf8               valueIndex<font></font>
   #8 = Utf8               I<font></font>
   #9 = Utf8               Fizz<font></font>
  #10 = Utf8               LFizzBuzz;<font></font>
  #11 = Utf8               Buzz<font></font>
  #12 = Utf8               FizzBuzz<font></font>
  #13 = Utf8               values<font></font>
  #14 = Utf8               ()[LFizzBuzz;<font></font>
  #15 = NameAndType        #5:#6          // $VALUES:[LFizzBuzz;<font></font>
  #16 = Fieldref           #2.#15         // FizzBuzz.$VALUES:[LFizzBuzz;<font></font>
  #17 = Class              #6             // "[LFizzBuzz;"<font></font>
  #18 = Utf8               clone<font></font>
  #19 = Utf8               ()Ljava/lang/Object;<font></font>
  #20 = NameAndType        #18:#19        // clone:()Ljava/lang/Object;<font></font>
  #21 = Methodref          #17.#20        // "[LFizzBuzz;".clone:()Ljava/lang/Object;<font></font>
  ...<font></font>
  #40 = NameAndType        #9:#10         // Fizz:LFizzBuzz;<font></font>
  #41 = Dynamic            #0:#40         // #0:Fizz:LFizzBuzz;<font></font>
  #42 = Fieldref           #2.#40         // FizzBuzz.Fizz:LFizzBuzz;<font></font>
  #43 = NameAndType        #11:#10        // Buzz:LFizzBuzz;<font></font>
  #44 = Dynamic            #0:#43         // #0:Buzz:LFizzBuzz;<font></font>
  #45 = Fieldref           #2.#43         // FizzBuzz.Buzz:LFizzBuzz;<font></font>
  #46 = NameAndType        #12:#10        // FizzBuzz:LFizzBuzz;<font></font>
  #47 = Dynamic            #0:#46         // #0:FizzBuzz:LFizzBuzz;<font></font>
  #48 = Fieldref           #2.#46         // FizzBuzz.FizzBuzz:LFizzBuzz;<font></font>
</pre><br>
</blockquote><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸运的是，有一种解决方法-创建类时，您可以指定一个示例类，从中复制常量池和带有引导程序方法描述的属性。</font><font style="vertical-align: inherit;">只是现在，我们必须手动生成它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，它并不像乍看起来那样困难。</font><font style="vertical-align: inherit;">类文件的格式非常简单，其手动生成是一个乏味的过程，但是一点也不复杂。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里最重要的是一个清晰的计划。</font><font style="vertical-align: inherit;">要列举出</font></font><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们需要</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">元素：</font></font><br>
<br>
<ul>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型记录</font></font><code>CONSTANT_Dynamic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-我们的动态常数</font></font></li>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型记录</font></font><code>CONSTANT_NameAndType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-指向枚举元素名称及其类型的链接对。</font><font style="vertical-align: inherit;">每个人的类型都是相同的，这是我们枚举的类类型。</font></font></li>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型记录</font></font><code>CONSTANT_Utf8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-直接列出枚举元素的名称</font></font></li>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型的记录</font></font><code>CONSTANT_Integer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-作为参数值传递给构造函数的枚举元素的序列号</font></font><code>ordinal</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前和基类的名称，属性，方法签名以及其他令人厌烦的实现细节。</font><font style="vertical-align: inherit;">那些感兴趣的人可以查看生成器的源代码。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
常量池中有很多组成元素，它们通过索引引用池中的其他元素，因此我们需要预先计算所有索引，这</font></font><code>elementNames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是我们枚举元素名称的列表：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">int</span> elementCount = elementNames.size();<font></font>
<font></font>
<span class="hljs-keyword">int</span> baseConDy = <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> baseNameAndType = baseConDy + elementCount;
<span class="hljs-keyword">int</span> baseUtf8 = baseNameAndType + elementCount;
<span class="hljs-keyword">int</span> baseInteger = baseUtf8 + elementCount;
<span class="hljs-keyword">int</span> indexThisClass = baseInteger + elementCount;
<span class="hljs-keyword">int</span> indexThisClassUtf8 = indexThisClass + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexSuperClass = indexThisClassUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexSuperClassUtf8 = indexSuperClass + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodsUtf8 = indexSuperClassUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexConDyDescriptorUtf8 = indexBootstrapMethodsUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodHandle = indexConDyDescriptorUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodRef = indexBootstrapMethodHandle + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodNameAndType = indexBootstrapMethodRef + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodName = indexBootstrapMethodNameAndType + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodDescriptor = indexBootstrapMethodName + <span class="hljs-number">1</span>;<font></font>
<font></font>
<span class="hljs-keyword">int</span> constantPoolSize = indexBootstrapMethodDescriptor + <span class="hljs-number">1</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
之后，我们开始写。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在开始时-类文件的签名，每个人都知道的四个字节</font></font><nobr><code>0xCA 0xFE 0xBA 0xBE</code></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及文件格式版本：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// Class file header</span><font></font>
u4(CLASS_FILE_SIGNATURE);<font></font>
u4(version);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后-常量池：</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常数池</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-comment">// Constant pool</span><font></font>
u2(constantPoolSize);<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_Dynamic</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1u2u2(CONSTANT_Dynamic, i, baseNameAndType + i);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_NameAndType</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1u2u2(CONSTANT_NameAndType, baseUtf8 + i, indexConDyDescriptorUtf8);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_Utf8</span>
<span class="hljs-comment">//noinspection ForLoopReplaceableByForEach</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1(CONSTANT_Utf8);<font></font>
    utf8(elementNames.get(i));<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_Integer</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1(CONSTANT_Integer);<font></font>
    u4(i);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ThisClass</span><font></font>
u1(CONSTANT_Class);<font></font>
u2(indexThisClassUtf8);<font></font>
<font></font>
<span class="hljs-comment">// ThisClassUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(enumClassName);<font></font>
<font></font>
<span class="hljs-comment">// SuperClass</span><font></font>
u1(CONSTANT_Class);<font></font>
u2(indexSuperClassUtf8);<font></font>
<font></font>
<span class="hljs-comment">// SuperClassUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(JAVA_LANG_ENUM);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodsUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(ATTRIBUTE_NAME_BOOTSTRAP_METHODS);<font></font>
<font></font>
<span class="hljs-comment">// ConDyDescriptorUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(binaryEnumClassName);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodHandle</span><font></font>
u1(CONSTANT_MethodHandle);<font></font>
u1(REF_newInvokeSpecial);<font></font>
u2(indexBootstrapMethodRef);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodRef</span><font></font>
u1u2u2(CONSTANT_Methodref, indexThisClass, indexBootstrapMethodNameAndType);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodNameAndType</span><font></font>
u1u2u2(CONSTANT_NameAndType, indexBootstrapMethodName, indexBootstrapMethodDescriptor);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodName</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(BOOTSTRAP_METHOD_NAME);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodDescriptor</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(BOOTSTRAP_METHOD_DESCRIPTOR);<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
池常数谈论访问修饰符和标志后（</font></font><code>public</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>final</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>enun</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，等），类名和它的祖先：</font></font><br>
<br>
<pre><code class="java hljs">u2(access);<font></font>
u2(indexThisClass);<font></font>
u2(indexSuperClass);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们生成的虚拟类将没有接口，没有字段，没有方法，但是会有一个带有引导方法描述的属性：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// Interfaces count</span>
u2(<span class="hljs-number">0</span>);
<span class="hljs-comment">// Fields count</span>
u2(<span class="hljs-number">0</span>);
<span class="hljs-comment">// Methods count</span>
u2(<span class="hljs-number">0</span>);
<span class="hljs-comment">// Attributes count</span>
u2(<span class="hljs-number">1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是属性本身的主体：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// BootstrapMethods attribute</span><font></font>
u2(indexBootstrapMethodsUtf8);<font></font>
<span class="hljs-comment">// BootstrapMethods attribute size</span>
u4(<span class="hljs-number">2</span> <span class="hljs-comment">/* num_bootstrap_methods */</span> + <span class="hljs-number">6</span> * elementCount);
<span class="hljs-comment">// Bootstrap method count</span><font></font>
u2(elementCount);<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {
    <span class="hljs-comment">// bootstrap_method_ref</span><font></font>
    u2(indexBootstrapMethodHandle);<font></font>
    <span class="hljs-comment">// num_bootstrap_arguments</span>
    u2(<span class="hljs-number">1</span>);
    <span class="hljs-comment">// bootstrap_arguments[1]</span><font></font>
    u2(baseInteger + i);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就是这样，班级就形成了。</font><font style="vertical-align: inherit;">我们获取这些字节并从它们创建</font></font><code>ClassReader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> ClassReader <span class="hljs-title">getBootstrapClassReader</span><span class="hljs-params">(<span class="hljs-keyword">int</span> version, <span class="hljs-keyword">int</span> access, String enumClassName, List&lt;String&gt; elementNames)</span> </span>{
    <span class="hljs-keyword">byte</span>[] bootstrapClassBytes = <span class="hljs-keyword">new</span> ConDyBootstrapClassGenerator(<font></font>
        version,<font></font>
        access,<font></font>
        enumClassName,<font></font>
        elementNames<font></font>
    )<font></font>
    .generate();<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (bootstrapClassBytes == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ClassReader(bootstrapClassBytes);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并不是那么困难。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生成器源代码：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConDyBootstrapClassGenerator.java</font></font></a><br>
<a name="Future"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">光明的未来</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们简要介绍一下我们的清单：</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscoverConstantValueAttribute</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String STRING = <span class="hljs-string">"Habrahabr, world!"</span>;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object OBJECT = <span class="hljs-keyword">new</span> Object();<font></font>
<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此类的静态初始化块中，在该字段中突然只有一个写操作</font></font><code>OBJECT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">static</span> {<font></font>
    OBJECT = <span class="hljs-keyword">new</span> Object();
    <span class="hljs-comment">//  0: new           #2                  // class java/lang/Object</span>
    <span class="hljs-comment">//  3: dup</span>
    <span class="hljs-comment">//  4: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span>
    <span class="hljs-comment">//  7: putstatic     #7                  // Field OBJECT:Ljava/lang/Object;</span>
    <span class="hljs-comment">// 10: return</span><font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是呢</font></font><code>STRING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
团队将帮助您揭开这个谜语</font></font><nobr><code>javap -c -s -p -v DiscoverConstantValueAttribute.class</code></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这是我们感兴趣的片段：</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.String STRING;<font></font>
  descriptor: Ljava/lang/String;<font></font>
  flags: (<span class="hljs-number">0x0019</span>) ACC_PUBLIC, ACC_STATIC, ACC_FINAL<font></font>
  ConstantValue: String Habrahabr, world!<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
静态final字段的值已从初始化块移至单独的属性</font></font><code>ConstantValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是他们在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVMS11§4.7.2中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于此属性的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">内容</font></a><font style="vertical-align: inherit;">：</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConstantValue属性表示常量表达式的值（JLS§15.28），其用法如下：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果在field_info结构的access_flags项中设置了ACC_STATIC标志，则将field_info结构表示的字段分配为其ConstantValue属性表示的值，作为声明该字段的类或接口的初始化的一部分（第5.5节）。</font><font style="vertical-align: inherit;">这发生在调用该类或接口的类或接口初始化方法之前（第2.9.2节）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">否则，Java虚拟机必须静默忽略该属性。</font></font></li>
</ul><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果发生同时这样的属性</font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>final</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（尽管后者没有明确地阐述了在这里）中的字段，则这样的字段被初始化为从该属性的值。</font><font style="vertical-align: inherit;">而且甚至在调用静态初始化方法之前就发生了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用此属性来初始化枚举的元素很诱人，在上一章中，尽管有动态常量，但也只有常量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们并不是第一个朝这个方向思考的人，JEP 309中有提及</font></font><code>ConstantValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">不幸的是，此提及在“未来工作”一章中：</font></font><br>
<br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将来的工作</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
可能的将来扩展包括：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将动态常量附加到静态字段的ConstantValue属性</font></font></li>
</ul><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同时，我们只能梦到该功能将从“做好”状态变为“准备就绪”状态的时间。</font><font style="vertical-align: inherit;">然后，初始化块中对代码大小的限制将失去影响，枚举中元素的最大数量将确定常量池的限制。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据粗略估计，在这种情况下，我们可以希望有一个</font></font><code>65&nbsp;489 / 4 = 16_372</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素。</font><font style="vertical-align: inherit;">这</font></font><code>65_489</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是常量池中未占用的时隙数，理论上可能的65_535中有46个进入了开销。</font></font><code>4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-声明一个字段所需的时隙数和相应的动态常数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，确切的数字只有在支持此功能的JDK版本发布后才能找到。</font></font><br>
<br>
<a name="Unsafe"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不安全</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的敌人是初始化块的线性增长以及枚举元素数量的增加。</font><font style="vertical-align: inherit;">如果我们找到了减少循环初始化的方法，从而消除了枚举中的元素数量与初始化块的大小之间的关系，那么我们将取得另一个突破。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不幸的是，标准的公共API都不允许</font></font><code>static final</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在静态初始化块内</font><font style="vertical-align: inherit;">写入</font><font style="vertical-align: inherit;">字段。</font><font style="vertical-align: inherit;">Reflection和VarHandles都不会对这里有所帮助。</font><font style="vertical-align: inherit;">我们唯一的希望是伟大而可怕的</font></font><code>sun.misc.Unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不安全地执行FizzBu​​zz可能看起来像这样：</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不安全的FizzBu​​zz</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword">import</span> java.lang.reflect.Field;
<span class="hljs-keyword">import</span> sun.misc.Unsafe;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> FizzBuzz {<font></font>
<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz[] $VALUES;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz Fizz;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz Buzz;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz FizzBuzz;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FizzBuzz[] values() {
        <span class="hljs-keyword">return</span> (FizzBuzz[]) $VALUES.clone();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FizzBuzz <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">return</span> (FizzBuzz) Enum.valueOf(FizzBuzz.class, name);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">FizzBuzz</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> ordinal)</span> </span>{
        <span class="hljs-keyword">super</span>(name, ordinal);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz[] createValues() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FizzBuzz[] {<font></font>
            Fizz,<font></font>
            Buzz,<font></font>
            FizzBuzz<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span>  {<font></font>
        Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");<font></font>
        unsafeField.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="hljs-keyword">null</span>);<font></font>
<font></font>
        String[] fieldNames = "Fizz,Buzz,FizzBuzz".split(",");<font></font>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fieldNames.length; i++) {<font></font>
            String fieldName = fieldNames[i];<font></font>
            Field field = FizzBuzz.class.getDeclaredField(fieldName);<font></font>
            <span class="hljs-keyword">long</span> fieldOffset = unsafe.staticFieldOffset(field);<font></font>
            unsafe.putObject(FizzBuzz.class, fieldOffset, <span class="hljs-keyword">new</span> FizzBuzz(fieldName, i));<font></font>
        }<font></font>
<font></font>
        $VALUES = createValues();<font></font>
    }<font></font>
<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种方法使我们能够创建一个包含约21000个元素的枚举；更多的常量池的容量还不够。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Enum :: ordinal（）</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
上的文档</font><font style="vertical-align: inherit;">要求其值与枚举声明中相应元素的序列号匹配，因此您必须以正确的顺序显式存储字段名称列表，从而几乎使类文件的大小增加一倍。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">public final int ordinal（）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
返回此枚举常量的序数（其在枚举声明中的位置，其中初始常量的序数为零）。</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，用于常量池内容的公共API可能会有所帮助，我们已经知道如何按需要的顺序填充它，但是没有这样的API，而且不可能。 OpenJDK中提供的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Class :: getConstantPool（）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法被</font><font style="vertical-align: inherit;">声明为package-private，在用户代码中依赖它很容易。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，初始化块非常紧凑，并且几乎与枚举中的元素数量无关，因此您</font></font><code>createValues()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以通过将其主体嵌入循环来拒绝它：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");<font></font>
    unsafeField.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
    Unsafe unsafe = (Unsafe) unsafeField.get(<span class="hljs-keyword">null</span>);<font></font>
<font></font>
    String[] fieldNames = "Fizz,Buzz,FizzBuzz".split(",");<font></font>
    FizzBuzz[] localValues = <span class="hljs-keyword">new</span> FizzBuzz[fieldNames.length];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fieldNames.length; i++) {<font></font>
        String fieldName = fieldNames[i];<font></font>
        Field field = FizzBuzz.class.getDeclaredField(fieldName);<font></font>
        <span class="hljs-keyword">long</span> fieldOffset = unsafe.staticFieldOffset(field);<font></font>
        unsafe.putObject(<font></font>
            FizzBuzz.class,<font></font>
            fieldOffset,<font></font>
            (localValues[i] = <span class="hljs-keyword">new</span> FizzBuzz(fieldName, i))<font></font>
        );<font></font>
    }<font></font>
<font></font>
    $VALUES = localValues;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里发生了类似雪崩的过程：随着该方法的出现</font></font><code>createValues()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，用于读取枚举元素的字段的指令消失了，</font></font><code>Fieldref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些字段的</font><font style="vertical-align: inherit;">类型记录变得不必要了</font><font style="vertical-align: inherit;">，因此类型</font></font><code>NameAndType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记录的类型记录</font><font style="vertical-align: inherit;">也</font><font style="vertical-align: inherit;">随之</font><font style="vertical-align: inherit;">而来</font></font><code>Fieldref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在常量池中，释放了</font></font><code>2 * &lt;   &gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可用于声明其他枚举元素的插槽。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，并非所有事情都如此乐观，测试显示出明显的性能下降：初始化一个包含65,000个元素的枚举类需要花费一分半钟的时间。结果很快，“反射速度变慢了”。</font><font style="vertical-align: inherit;">OpenJDK </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Class :: getDeclaredField（）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的实现具有</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">类</font></a><font style="vertical-align: inherit;">中字段数的线性渐近行为，因此，我们的初始化块是平方的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管无法完全解决，但添加缓存可以稍微改善这种情况：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");<font></font>
    unsafeField.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
    Unsafe unsafe = (Unsafe) unsafeField.get(<span class="hljs-keyword">null</span>);<font></font>
<font></font>
    String[] fieldNames = "Fizz,Buzz,FizzBuzz".split(",");<font></font>
    Field[] fields = FizzBuzz.class.getDeclaredFields();<font></font>
    HashMap&lt;String, Field&gt; cache = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(fields.length);<font></font>
<font></font>
    <span class="hljs-keyword">for</span>(Field field : fields) {<font></font>
        cache.put(field.getName(), field);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fieldNames.length; i++) {<font></font>
        String fieldName = fieldNames[i];<font></font>
        Field field = cache.get(fieldName);<font></font>
        <span class="hljs-keyword">long</span> fieldOffset = unsafe.staticFieldOffset(field);<font></font>
        unsafe.putObject(<font></font>
            FizzBuzz.class,<font></font>
            fieldOffset,<font></font>
            (localValues[i] = <span class="hljs-keyword">new</span> FizzBuzz(fieldName, i))<font></font>
        );<font></font>
    }    <font></font>
<font></font>
    $VALUES = localValues;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本章中介绍的不安全方法允许您创建最多65_410个元素的传输，这几乎是javac可获得的结果的24倍，并且非常接近我们在循环的上一版中计算出的65_505个元素的理论极限。</font></font><br>
<br>
<a name="Testing"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查效果</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于测试，我们采用最大的枚举，并使用command生成它</font></font><nobr><code>java -jar HugeEnumGen.jar -a Unsafe UnsafeHugeEnum</code></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。结果，我们得到了一个大小为2兆字节和65_410个元素的类文件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在IDEA中创建一个新的Java项目，并将生成的类添加为外部库。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
几乎可以立即看出，IDEA尚未准备好进行这种压力测试：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m4/su/-6/m4su-6bvdkkqmf3pypqrmpzntnw.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在古老的移动i5和更现代的i7 8700K上，自动完成枚举元素都需要数十秒。而且，如果您尝试使用快速修复将缺少的元素添加到开关，则IDEA甚至会停止重绘窗口。我暂时怀疑，但没有等待完成。调试期间的响应能力也有很多不足之处。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们从中的少量元素开始</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFew</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> </span>{
        <span class="hljs-keyword">for</span>(String arg : args) {<font></font>
            System.out.print(arg + <span class="hljs-string">" : "</span>);<font></font>
<font></font>
            <span class="hljs-keyword">try</span> {<font></font>
                UnsafeHugeEnum value = UnsafeHugeEnum.valueOf(arg);<font></font>
<font></font>
                doSwitch(value);<font></font>
            } <span class="hljs-keyword">catch</span>(Throwable e) {<font></font>
                e.printStackTrace(System.out);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSwitch</span><span class="hljs-params">(UnsafeHugeEnum value)</span> </span>{
        <span class="hljs-keyword">switch</span>(value) {
            <span class="hljs-keyword">case</span> VALUE_00001:<font></font>
                System.out.println(<span class="hljs-string">"First"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> VALUE_31415:<font></font>
                System.out.println(<span class="hljs-string">"(int) (10_000 * Math.PI)"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> VALUE_65410:<font></font>
                System.out.println(<span class="hljs-string">"Last"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:<font></font>
                System.out.println(<span class="hljs-string">"Unexpected value: "</span> + value);
                <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
    }<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
毫不奇怪，编译和启动是常规的：</font></font><br>
<br>
<pre><code class="plaintext hljs">$ java TestFew VALUE_00001 VALUE_00400 VALUE_31415 VALUE_65410<font></font>
VALUE_00001 : First<font></font>
VALUE_00400 : Unexpected value: VALUE_00400<font></font>
VALUE_31415 : (int) (10_000 * Math.PI)<font></font>
VALUE_65410 : Last<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那更多的物品</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呢？</font><font style="vertical-align: inherit;">例如，</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们</font><font style="vertical-align: inherit;">可以</font><font style="vertical-align: inherit;">一次</font><font style="vertical-align: inherit;">处理</font><font style="vertical-align: inherit;">所有65,000个元素吗？</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">switch</span>(value) {
    <span class="hljs-keyword">case</span> VALUE_00001:
    <span class="hljs-keyword">case</span> VALUE_00002:<font></font>
        ...<font></font>
    <span class="hljs-keyword">case</span> VALUE_65410:<font></font>
        System.out.println(<span class="hljs-string">"One of known values: "</span> + value);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:<font></font>
        System.out.println(<span class="hljs-string">"Unexpected value: "</span> + value);
        <span class="hljs-keyword">break</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
las，不。</font><font style="vertical-align: inherit;">当我们尝试编译时，我们会收到一堆错误消息：</font></font><br>
<br>
<pre><code class="plaintext hljs">$ javac -fullversion<font></font>
javac full version "14.0.1+7"<font></font>
<font></font>
$ javac TestAll.java<font></font>
TestAll.java:18: error: code too large for try statement<font></font>
        switch(value) {<font></font>
        ^<font></font>
TestAll.java:65433: error: too many constants<font></font>
                break;<font></font>
                ^<font></font>
TestAll.java:17: error: code too large<font></font>
    private static void doSwitch(UnsafeHugeEnum value) {<font></font>
                        ^<font></font>
TestAll.java:1: error: too many constants<font></font>
public class TestAll {<font></font>
       ^<font></font>
4 errors<font></font>
</code></pre><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testfew.java</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TestAll.java</font></font></a></li>
</ul><br>
<a name="JavacSwitchTranslation"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javac和开关</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要了解正在发生的事情，我们必须弄清楚</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">枚举元素</font><font style="vertical-align: inherit;">的转换</font><font style="vertical-align: inherit;">是</font><font style="vertical-align: inherit;">如何发生的</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JVM规范在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVMS11§3.10编译开关中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有单独的章节</font><font style="vertical-align: inherit;">，其建议可以归结为</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用两个字节码指令之一</font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><code>lookupswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本章中，我们将找不到对字符串或枚举元素的</font><font style="vertical-align: inherit;">任何引用</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最好的文档是代码，因此该深入了解源代码了</font></font><code>javac</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">和</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
之间的选择</font><font style="vertical-align: inherit;">出现在</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Gen :: visitSwitch（）中，</font></a><font style="vertical-align: inherit;">并取决于中的选项数量</font><font style="vertical-align: inherit;">。在大多数情况下，获胜</font><font style="vertical-align: inherit;">：</font></font><code>tableswitch</code><font style="vertical-align: inherit;"></font><code>lookupswitch</code><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><code>switch</code><font style="vertical-align: inherit;"></font><code>tableswitch</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// Determine whether to issue a tableswitch or a lookupswitch</span>
<span class="hljs-comment">// instruction.</span>
<span class="hljs-keyword">long</span> table_space_cost = <span class="hljs-number">4</span> + ((<span class="hljs-keyword">long</span>) hi - lo + <span class="hljs-number">1</span>); <span class="hljs-comment">// words</span>
<span class="hljs-keyword">long</span> table_time_cost = <span class="hljs-number">3</span>; <span class="hljs-comment">// comparisons</span>
<span class="hljs-keyword">long</span> lookup_space_cost = <span class="hljs-number">3</span> + <span class="hljs-number">2</span> * (<span class="hljs-keyword">long</span>) nlabels;
<span class="hljs-keyword">long</span> lookup_time_cost = nlabels;
<span class="hljs-keyword">int</span> opcode =<font></font>
    nlabels &gt; <span class="hljs-number">0</span> &amp;&amp;<font></font>
    table_space_cost + <span class="hljs-number">3</span> * table_time_cost &lt;=<font></font>
    lookup_space_cost + <span class="hljs-number">3</span> * lookup_time_cost<font></font>
    ?<font></font>
    tableswitch : lookupswitch;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
标头</font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约为16个字节，每个值4个字节。</font><font style="vertical-align: inherit;">因此，</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在任何情况下都不能有更多</font></font><code>( 65_535 - 16 ) / 4 = 16_379</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
确实，</font></font><code>case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在将体内</font><font style="vertical-align: inherit;">的分支数减少</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到1.6万后，仅存在一个编译错误，这是最神秘的：</font></font><br>
<br>
<pre><code class="plaintext hljs">TestAll.java:18: error: code too large for try statement<font></font>
        switch(value) {<font></font>
        ^<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了寻找错误的根源，我们将更早返回到摆脱语法糖的阶段。</font><font style="vertical-align: inherit;">该</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法分别负责</font><font style="vertical-align: inherit;">翻译</font></font><code>visitEnumSwitch()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>mapForEnum()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和类</font></font><code>EnumMapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lower.java</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们还发现了一个小的纪实评论：</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">枚举JavaDoc</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-comment">/** This map gives a translation table to be used for enum
 *  switches.
 *
 *  &lt;p&gt;For each enum that appears as the type of a switch
 *  expression, we maintain an EnumMapping to assist in the
 *  translation, as exemplified by the following example:
 *
 *  &lt;p&gt;we translate
 *  &lt;pre&gt;
 *          switch(colorExpression) {
 *          case red: stmt1;
 *          case green: stmt2;
 *          }
 *  &lt;/pre&gt;
 *  into
 *  &lt;pre&gt;
 *          switch(Outer$0.$EnumMap$Color[colorExpression.ordinal()]) {
 *          case 1: stmt1;
 *          case 2: stmt2
 *          }
 *  &lt;/pre&gt;
 *  with the auxiliary table initialized as follows:
 *  &lt;pre&gt;
 *          class Outer$0 {
 *              synthetic final int[] $EnumMap$Color = new int[Color.values().length];
 *              static {
 *                  try { $EnumMap$Color[red.ordinal()] = 1; } catch (NoSuchFieldError ex) {}
 *                  try { $EnumMap$Color[green.ordinal()] = 2; } catch (NoSuchFieldError ex) {}
 *              }
 *          }
 *  &lt;/pre&gt;
 *  class EnumMapping provides mapping data and support methods for this translation.
 */</span>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这个神秘的人</font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原来是自动生成的帮助程序类的一部分</font></font><code>TestAll$0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。内部-静态数组的声明和用于初始化它的代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该数组固定枚举元素的名称与在编译过程中分配给它们的</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数值</font><font style="vertical-align: inherit;">之间的对应关系</font><font style="vertical-align: inherit;">，从而保护编译的代码免受重构的有害影响。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当重新排序，添加新的元素或删除现有的枚举元素时，其中一些元素可能会更改值</font></font><code>ordinal()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这是附加级别的间接保护的目标。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">try</span> {<font></font>
    $SwitchMap$UnsafeHugeEnum[UnsafeHugeEnum.VALUE_00001.ordinal()] = <span class="hljs-number">1</span>;
    <span class="hljs-comment">//  9: getstatic     #2                  // Field $SwitchMap$UnsafeHugeEnum:[I</span>
    <span class="hljs-comment">// 12: getstatic     #3                  // Field UnsafeHugeEnum.VALUE_00001:LUnsafeHugeEnum;</span>
    <span class="hljs-comment">// 15: invokevirtual #4                  // Method UnsafeHugeEnum.ordinal:()I</span>
    <span class="hljs-comment">// 18: iconst_1</span>
    <span class="hljs-comment">// 19: iastore</span><font></font>
}<font></font>
<span class="hljs-comment">// 20: goto          24</span>
<span class="hljs-keyword">catch</span>(NoSuchFieldError e) { }
<span class="hljs-comment">// 23: astore_0</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初始化代码很简单，每个元素占用15到17个字节。</font><font style="vertical-align: inherit;">结果，静态初始化块可容纳不超过3_862个元素的初始化。</font><font style="vertical-align: inherit;">这个数字</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是当前实现中</font><font style="vertical-align: inherit;">可以在一个枚举元素中使用的最大数量</font></font><code>javac</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="Conclusion"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们已经看到，即使使用分配枚举元素的创建并将数组初始化</font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为单独方法</font><font style="vertical-align: inherit;">的简单技术，也可以将枚举中</font><font style="vertical-align: inherit;">的最大元素数从2_746增加到10_920。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在先前成就的背景下获得的恒定动态结果看起来并不令人印象深刻，并且您只能获得43个元素，但是通过这种方法，可以为枚举添加新属性更加优雅-只需修改构造函数并将其通过动态常量的静态参数传递给必要的值即可。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果在未来的某个时候属性</font></font><code>ConstantValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将学习，了解动态常数，这个数字将上升到10万到16 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用</font></font><code>sun.misc.Unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使您可以飞跃，并将元素的最大数量增加到65_410。但是请不要忘记，</font></font><code>Unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一个专有的API，随着时间的流逝，它可能会消失，并且使用它会带来很大的风险，因为javac直接警告：</font></font><br>
<br>
<pre><code class="plaintext hljs">Test.java:3: warning: Unsafe is internal proprietary API and may be removed in a future release<font></font>
import sun.misc.Unsafe;<font></font>
               ^<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，事实证明，仅产生一个巨大的枚举是不够的，您还需要能够使用它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当前，IDE和Java编译器级别对此类枚举的支持都存在问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在编辑和调试期间，类中的大量字段可能会降低IDE的响应能力。</font><font style="vertical-align: inherit;">有时会完全死机。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
类文件格式和javac的实现细节所施加的限制使得不可能在代码</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中同时</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">3_862个以上的元素。</font><font style="vertical-align: inherit;">在积极方面，值得一提的是，这些可以是任意的3_862元素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仅通过改进Java编译器，才能进一步改善结果，但这是完全不同的故事。</font></font><br>
<br>
<a name="Appendix"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附加材料</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GitHub源代码：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">//github.com/Maccimo/HugeEnumGeneratorArticle</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
收集的JAR文件：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">https</font></a><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//github.com/Maccimo/HugeEnumGeneratorArticle/releases/tag/v1.0</font></font></a><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支持的启动帮助</font></font></b>
                        <div class="spoiler_text"><pre><font></font>
Huge enumeration generator<font></font>
<font></font>
    https://github.com/Maccimo/HugeEnumGeneratorArticle<font></font>
<font></font>
Additional information (in Russian):<font></font>
<font></font>
    https://habr.com/ru/post/483392/<font></font>
    https://habr.com/ru/post/501870/<font></font>
<font></font>
Usage:<font></font>
    java -jar HugeEnumGen.jar [ &lt;options&gt; ] &lt;enum name&gt;<font></font>
<font></font>
    &lt;enum name&gt;<font></font>
        An enumeration class name.<font></font>
        Should be a valid Java identifier. May contain package name.<font></font>
<font></font>
Options:<font></font>
<font></font>
    -d &lt;directory&gt;<font></font>
        Output directory path.<font></font>
        Current working directory by default.<font></font>
<font></font>
    -e &lt;item list file&gt;<font></font>
        Path to UTF8-encoded text file with list of enumeration item names.<font></font>
        Item names will be autogenerated if absent.<font></font>
        Mutually exclusive with the -c option.<font></font>
<font></font>
    -c &lt;count&gt;<font></font>
        Count of autogenerated enumeration item names.<font></font>
        Mutually exclusive with the -e option.<font></font>
        Default value: Algorithm-depended<font></font>
<font></font>
    -a &lt;algorithm&gt;<font></font>
        Enumeration generation algorithm.<font></font>
        Supported algorithms:<font></font>
          ConDy          - Employ Constant Dynamic (JEP 309) for enum elements initialization<font></font>
          ExtractMethod  - Extract enum elements initialization code to separate method<font></font>
          Unsafe         - Employ sun.misc.Unsafe for enum elements initialization<font></font>
<font></font>
        Default algorithm: ExtractMethod<font></font>
<font></font>
    -h / -?<font></font>
        Show this help page.<font></font>
<font></font>
Example:<font></font>
<font></font>
    java -jar HugeEnumGen.jar -d ./bin -c 2020 com.habr.maccimo.HugeEnum2020<font></font>
<font></font>
</pre><br>
</div>
                    </div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN501860/index.html">5月15日RU-Center可能会在没有您参与的情况下为您添加付费服务</a></li>
<li><a href="../zh-CN501862/index.html">引擎盖下飘动</a></li>
<li><a href="../zh-CN501864/index.html">助理或检查员：机器人要呼叫谁？</a></li>
<li><a href="../zh-CN501866/index.html">机器人将销毁多少工作</a></li>
<li><a href="../zh-CN501868/index.html">如何不让会计师丢脸，还是我们将1C转移到云端。分步指导</a></li>
<li><a href="../zh-CN501872/index.html">控制论系统中的学习地点</a></li>
<li><a href="../zh-CN501874/index.html">现代前端架构（第2部分）</a></li>
<li><a href="../zh-CN501880/index.html">关于没有开始，开始和开始的“开始”和“开始”的翻译</a></li>
<li><a href="../zh-CN501882/index.html">我们如何使用计算机视觉算法：使用OpenCV.js在移动浏览器中进行视频处理</a></li>
<li><a href="../zh-CN501884/index.html">电子医疗信息档案库将如何帮助更有效地诊断疾病</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>