<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¶üèΩ üé¥ üë©üèΩ‚Äçüåæ Generando ramas aleatorias en Python üêò üíù üë©‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recordando a Dawkins, la idea principal se puede expresar de la siguiente manera: si mantienes el tornado sobre la basura durante mucho tiempo , enton...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Generando ramas aleatorias en Python</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504296/"><img src="https://habrastorage.org/webt/fy/vd/nr/fyvdnr83rzvq1tow9chyg7e0kry.gif" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recordando a Dawkins, la idea principal se puede expresar de la siguiente manera: si </font><font style="vertical-align: inherit;">mantienes el tornado sobre la basura durante </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mucho tiempo</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , entonces se puede armar un Boeing 747. El surgimiento de una estructura del caos por un durik: clasificando y recombinando todo en una fila, de todos los procesos sin sentido y desordenados, uno puede ver los bastante significativos y ordenados. Si tales procesos se arreglan y repiten de alguna manera, entonces el sistema, que ayer era un movimiento browniano, hoy comienza a parecer que su comportamiento fue establecido por una mano invisible, y que est√° haciendo algunas acciones que son significativas desde nuestro punto de vista. Al mismo tiempo, no hay mano en absoluto. Ella se prepar√≥.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para asegurarme de esto nuevamente, me esfuerzo por escribir alg√∫n tipo de vida digital que, fuera del caos y sin instrucciones innecesarias de una persona, pueda generar al azar l√≥gica para s√≠ misma y existir en ella en su h√°bitat natural: el sistema operativo. S√≠, en esto, probablemente, hay una diferencia de muchos programas de la direcci√≥n de "Vida Artificial", que "viven" en corrales, producen "depredadores" y "herb√≠voros", y coexisten en campos artificiales con "alimentos" y entre s√≠. Ninguno de estos programas interact√∫a con los objetos del sistema (procesos, archivos, etc.), lo que significa que el c√≥digo realmente no vive. Adem√°s, este c√≥digo de una forma u otra todav√≠a realiza alg√∫n tipo de tarea que una persona necesita y tiene un alcance muy limitado debido a esto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para implementar c√≥digo con un alto grado de libertad de acci√≥n en el sistema operativo, que al mismo tiempo no ser√≠a solo un conjunto ca√≥tico de instrucciones ejecutables, apareci√≥ un modelo que consta de 3 m√≥dulos. </font></font><br>
<a name="habracut"></a><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El m√≥dulo de generaci√≥n aleatoria del c√≥digo ejecutable principal.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√≥dulo de educaci√≥n al azar</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El m√≥dulo de "visi√≥n por computadora" de los objetos del sistema operativo</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este art√≠culo, hablaremos sobre el primer m√≥dulo, que hasta ahora es solo la generaci√≥n de ramificaciones aleatorias, es decir, construcciones como "if-elif-else". ¬øPor qu√© ramificarse? Porque, en general, la vida de cualquier organismo vivo consiste en reacciones condicionadas: todo lo que hacemos es una respuesta a la informaci√≥n percibida. Las c√©lulas se dividen si ocurren ciertas condiciones, la v√≠ctima trata de escapar si ve un depredador m√°s fuerte, y si es m√°s d√©bil, puede intentar atacarlo, las cucarachas se dispersan si se enciende la luz, una persona va a comer, si tiene hambre, etc. etc. - Esta fila es interminable. No hay acciones independientes y separadas que no est√©n condicionadas por nada. En consecuencia, el comportamiento de los organismos vivos en particular se describe como una reacci√≥n a la condici√≥n: SI [algo] ENTONCES [algo]. Estamos tratando de generar este comportamiento.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øPor qu√© al azar? Para dejar el c√≥digo, la m√°xima oportunidad de actuar de forma independiente y alejar a la persona (programador) de este proceso lo m√°s lejos posible (idealmente excluir por completo). Este √∫ltimo es el m√°s dif√≠cil para el programador, porque La programaci√≥n est√°ndar, a la que todos est√°n acostumbrados, se asemeja a un duro entrenamiento de animales, que debe realizar exactamente lo que indica el programador, exactamente como √©l indica cuando lo indica. Aqu√≠ la situaci√≥n es la opuesta: el c√≥digo final generado debe actuar de manera que sea tan impredecible para el creador de su generador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de pasar a los diagramas y al c√≥digo del generador, es necesario detenerse en la funci√≥n de toma de decisiones, que se utiliza como conductor, permitiendo que se ejecute una u otra parte del c√≥digo. Escrib√≠ sobre ella antes</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Luego se me solicit√≥ que describiera la idea de Reinforcement Learning y el juego de John Conway, titulado "Life". Bien puede ser que no tengo nada en contra de usar lo que ya se ha desarrollado o abiertamente. Al final, todo lo nuevo es una s√≠ntesis de lo ya conocido, y yo mismo admit√≠ que adopt√© la idea de priorizar los flujos, que se usa en Windows. Aqu√≠ ella es muy adecuada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Actualmente, la funci√≥n mencionada se ha transformado ligeramente:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_solution</span>(<span class="hljs-params">p_random, p_deter</span>):</span>                       
    deter_flag = <span class="hljs-number">0</span>
    random_flag = <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> p_random &gt;= random.random():<font></font>
            p_random-=<span class="hljs-number">0.01</span>                                  <span class="hljs-comment">#  </span>
            p_deter+=<span class="hljs-number">0.01</span>
            random_flag = <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> p_deter &gt;= random.random():<font></font>
            p_deter-=<span class="hljs-number">0.01</span>                                   <span class="hljs-comment">#  </span>
            p_random+=<span class="hljs-number">0.01</span>
            deter_flag = <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> random_flag == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> deter_flag == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span>(p_random, p_deter, <span class="hljs-number">1</span>)
    <span class="hljs-keyword">elif</span> deter_flag == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> random_flag == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span>(p_random, p_deter, <span class="hljs-number">-1</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> (p_random, p_deter,<span class="hljs-number">0</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la entrada, se necesitan 2 probabilidades (de forma predeterminada al principio, ambas son iguales a 0,5), despu√©s de lo cual verifica su operaci√≥n una por una. La probabilidad disparada disminuye en un 1% y al mismo tiempo aumenta la otra en un 1%. Por lo tanto, cada vez que la probabilidad funciona, disminuye y la otra aumenta. Como resultado, ninguna probabilidad obtiene demasiada ventaja sobre otra, y se autoequilibran, formando una distribuci√≥n normal centrada en 0.5 y con una vecindad de trabajo de no m√°s de + -10%, lo que distingue esta funci√≥n del azar est√°ndar, donde la probabilidad en nuestro caso Siempre ser√≠a igual a 0.5 y no depender√≠a de c√°lculos previos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hablando en sentido figurado, es un p√©ndulo de probabilidad con una peque√±a amplitud. Si la primera probabilidad funcion√≥ y la segunda no funcion√≥, devuelve 1, de lo contrario -1 se devuelve, y si ambas funcionaron o no funcionaron, 0. Por lo tanto, la funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make_solution</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para 2 probabilidades entrantes devuelve una de 3 acciones posibles, dando un balance soluci√≥n bifurcada con 3 posibles opciones de continuaci√≥n. En el futuro, es probable que esta funci√≥n sea universal y pueda tomar un n√∫mero indefinido de probabilidades, porque la variaci√≥n en las horquillas puede ser m√°s de 3, pero en el caso del generador if-elif-else, tres opciones para continuar son suficientes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n debe tenerse en cuenta aqu√≠ que en el c√≥digo hay diferentes, por as√≠ decir, horquillas t√≠picas. Por ejemplo, como se ver√° a continuaci√≥n, en la funci√≥n principal del generador hay una bifurcaci√≥n en la que se puede elegir un esquema para construir una rama, del cual solo hay 3, pero tambi√©n hay otros casos en el c√≥digo: inserte un bloque de acci√≥n o comience una recursi√≥n, cu√°ntas l√≠neas de acci√≥n generar, qu√© tan complejo deber√≠a ser l√≠nea con la condici√≥n, poner o o y, elif o de lo contrario. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creo que el p√©ndulo probabil√≠stico, del que hablamos anteriormente, debe establecerse para cada tipo de acci√≥n: entonces la bifurcaci√≥n se equilibra solo en funci√≥n de lo que sucedi√≥ anteriormente en esta bifurcaci√≥n, y no en otras partes del c√≥digo. Aquellos. Al elegir la estructura de ramificaci√≥n general, tenemos nuestro propio par de probabilidades, y dentro, cuando se construyen sus elementos, otro.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, puede equilibrar todas las acciones con un par, pero la probabilidad en cada bifurcaci√≥n ser√° muy dif√≠cil y depender√° de todas las acciones anteriores en otros cruces. La aleatoriedad de dicho dise√±o ser√° a√∫n mayor, pero por ahora personalmente me inclino por el primer esquema, porque me gusta el dise√±o donde otros peque√±os se balancean dentro del marco de un p√©ndulo oscilante grande, es decir. saldos m√°s peque√±os nacen en un gran saldo. Adem√°s, en el segundo esquema, la aleatoriedad tambi√©n es m√°s que suficiente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al escribir el generador de rama, era necesario crear no solo un c√≥digo viable que produjera generaciones sin errores, sino tambi√©n un c√≥digo que </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pudiera</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generar las construcciones m√°ximas posibles de if-elif-else, pero no hay 2 o 3 de tales opciones posibles Considere, por ejemplo, los siguientes esquemas posibles. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qu/oj/i3/quoji3ppc2arksk-xwafu3lfiqm.jpeg" width="350" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por el icono </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[..]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en los esquemas me refiero a un conjunto de expresiones para una condici√≥n o un bloque de acciones aleatorias. El esquema m√°s elemental es 1, donde la condici√≥n simplemente va, y luego el bloque de acci√≥n. 2a y 2b son si hay variaciones con un elif u otro. En la opci√≥n 2c, si ya viene en combinaci√≥n con varios elif sin m√°s. Y finalmente, en la opci√≥n 2d, se presenta el esquema m√°s general, donde if contiene varios elif y 1 m√°s.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo ser√≠a simple si no fuera por la necesidad de construir sucursales ilimitadas. Despu√©s de cada if, elif o else, se puede llamar a la recursi√≥n, que a su vez tambi√©n puede repetirse m√°s y producir nuevos bloques elif-else a la "derecha". Veamos el esquema de posibles opciones. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y0/0z/vr/y00zvr1zkcwxuceu28olrpfabpo.jpeg" width="400" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las realizaciones 2e y 2f muestran casos especiales simples de tal ramificaci√≥n recursiva cuando se llama a la recursi√≥n despu√©s de un solo elif o de otro. La opci√≥n 2g describe el caso m√°s complejo y general de dicha recursi√≥n, cuando despu√©s de cada elif puede haber un bloque de acci√≥n + recursi√≥n (o recursividad inmediata), y lo mismo puede suceder despu√©s de lo contrario. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todav√≠a hay variaciones cuando la recursi√≥n ocurre inmediatamente despu√©s de if o after if y un bloque de acci√≥n.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/dv/ye/hxdvyem6hl667rv0v-e-mjhpiv8.jpeg" width="400" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto se ve en las opciones 3a y 3b. La opci√≥n 3c muestra dicho esquema en la forma m√°s general. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto no quiere decir que los esquemas anteriores cubren todas las opciones posibles para construir ramas, pero incluso en esta forma, el c√≥digo final da lugar f√°cilmente a ramas de 150 l√≠neas, yendo "a la derecha" por 10-15 pasos. En cualquier caso, complicar el esquema si es necesario no es dif√≠cil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede ver un ejemplo de </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una de</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> esas generaciones para asegurarse de que las ramas pueden ser muy diversas.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zs/8j/gd/zs8jgd-5efc6vzg0thgjztgfyq0.jpeg" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No es necesario prestar atenci√≥n a la composici√≥n de las expresiones condicionales y los bloques de acci√≥n; por simplicidad visual, se generan a partir de solo combinaciones de dos variables, 3 expresiones y un peque√±o n√∫mero de signos aritm√©ticos y l√≥gicos. Una discusi√≥n sobre la verdadera "carne" para la recombinaci√≥n est√° m√°s all√° del alcance de este art√≠culo (esto se discutir√° en la discusi√≥n de 3 m√≥dulos). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de proceder a un examen directo del c√≥digo del generador, es necesario recordar que los bloques generados deben desplazarse horizontalmente hacia la derecha, si es elif, de lo contrario, si son bloques de recursi√≥n o acci√≥n, y tambi√©n "regresar" a la izquierda despu√©s de que la rama se complete. Adem√°s, dado que Python es muy exigente con las sangr√≠as horizontales, es deseable que el paso sea el mismo (en nuestro caso, el paso es 3).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El siguiente diagrama ilustra c√≥mo se desplazan los desplazamientos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mu/p8/ue/mup8uegwtzj-fydzcdcsswbsutw.jpeg" width="500" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo m√°s importante aqu√≠ es que los desplazamientos con la profundizaci√≥n de las ramas siempre se desplazan hacia la derecha. Sin embargo, si tenemos, por ejemplo, un bloque elif-else en el que hay varios elif o un solo par elif-else, entonces es necesario "devolver" el carro que flot√≥ hacia la derecha, de modo que el siguiente elif (o sino) comience con Las mismas compensaciones que la anterior en el bloque. Para hacer esto, debe guardar el desplazamiento original ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wall_offset</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) y despu√©s del final de la generaci√≥n de sucursales (por ejemplo, la ramificaci√≥n completa de un elif), resta√∫relo. Esto asegura que el elif, de lo contrario, los elementos est√°n en el bloque de manera uniforme "uno encima del otro". Adem√°s, cada nuevo bloque tiene su propio desplazamiento. El mismo truco proporciona armon√≠a en la construcci√≥n general if-elif-else (incluidas las recursiones). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora pasemos al c√≥digo. El c√≥digo con un volumen total de aproximadamente 200 l√≠neas consta de 8 funciones, una de las cuales examinamos anteriormente. Debido a la recursividad y una gran cantidad de par√°metros pasados ‚Äã‚Äãa las funciones, puede ser poco legible en algunos lugares. Para comenzar, citar√© la misma "carne" que se usa para generar expresiones condicionales y bloques de acci√≥n.</font></font><br>
<br>
<pre><code class="python hljs">var_list = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>]<font></font>
exp_list = [<span class="hljs-string">'a+b'</span>,<span class="hljs-string">'b-a'</span>, <span class="hljs-string">'b//a'</span>]<font></font>
sign = [<span class="hljs-string">'+'</span>,<span class="hljs-string">'-'</span>,<span class="hljs-string">'/'</span>,<span class="hljs-string">'*'</span>,<span class="hljs-string">'//'</span>]<font></font>
sign2 = [<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'=='</span>,<span class="hljs-string">'&gt;='</span>,<span class="hljs-string">'&lt;='</span>,<span class="hljs-string">'!='</span>]<font></font>
a = <span class="hljs-number">3</span>
b = <span class="hljs-number">2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, se utilizan dos variables: a y b ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), que se inicializan, 3 expresiones aritm√©ticas ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exp_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), y tambi√©n dos hojas con signos ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sign, sign2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Como se mencion√≥ anteriormente, la composici√≥n de las expresiones resultantes no importa ahora y no se considera en este art√≠culo; se necesitan principalmente para ilustrar el c√≥digo. Se debe tener en cuenta una peculiaridad m√°s: en la generaci√≥n del bloque elif-else, debe realizar un seguimiento de la apariencia del else y detener la generaci√≥n; de lo contrario, puede aparecer otro antes del elif, lo que naturalmente causar√° un error. La bandera </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin_else_flag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se usa para este prop√≥sito </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comenzamos nuestra consideraci√≥n con la funci√≥n de generaci√≥n principal.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">if_gen</span>(<span class="hljs-params">exp_list, var_list, if_str, offset_koeff, fin_else_flag, prob_list</span>):</span>             <font></font>
    choice_list = [exp_list, var_list]<font></font>
    base_offset = <span class="hljs-string">' '</span>
    <span class="hljs-comment">#   </span>
    prob_list[<span class="hljs-number">0</span>],prob_list[<span class="hljs-number">1</span>],sol = make_solution(prob_list[<span class="hljs-number">0</span>],prob_list[<span class="hljs-number">1</span>])       
    <span class="hljs-comment"># if +   (1   )        </span>
    <span class="hljs-keyword">if</span> sol == <span class="hljs-number">0</span>: 
        <span class="hljs-comment">#     +3                                                                   </span>
        action_str = action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list)                 
        <span class="hljs-keyword">return</span>(base_offset*offset_koeff+<span class="hljs-string">'if '</span>+ if_sub(exp_list,var_list, sign, prob_list) +<span class="hljs-string">':\n'</span> + action_str, offset_koeff, fin_else_flag, prob_list) 
    <span class="hljs-comment"># if + elif/else (2   )           </span>
    <span class="hljs-keyword">elif</span> sol == <span class="hljs-number">-1</span>:                                                                         <font></font>
        if_str= base_offset*offset_koeff+<span class="hljs-string">'if '</span>+ if_sub(exp_list,var_list, sign, prob_list) +<span class="hljs-string">':\n'</span> + action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list) <span class="hljs-comment"># if [..]:</span>
        <span class="hljs-comment">#  elif/else</span>
        prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol2=make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])             
        <span class="hljs-keyword">if</span> sol2!=<span class="hljs-number">0</span>:<font></font>
            ee_string=<span class="hljs-string">'elif'</span>
        <span class="hljs-keyword">else</span>:<font></font>
             ee_string=<span class="hljs-string">'else'</span>
        <span class="hljs-comment">#   elif/else</span><font></font>
        if_str, offset_koeff, fin_else_flag, prob_list = elif_else_block(ee_string, offset_koeff, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
        <span class="hljs-keyword">return</span>(if_str, offset_koeff, fin_else_flag, prob_list)
    <span class="hljs-comment"># if + if() (3   )</span>
    <span class="hljs-keyword">else</span>:                                                                                   <font></font>
            if_str= base_offset*offset_koeff+<span class="hljs-string">'if '</span>+ if_sub(exp_list,var_list, sign, prob_list) +<span class="hljs-string">':\n'</span> <span class="hljs-comment"># if [..]:</span>
            <span class="hljs-comment">#  if/if+ </span>
            prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>],sol = make_solution(prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>])        
            <span class="hljs-keyword">if</span> sol==<span class="hljs-number">0</span>:
                <span class="hljs-comment">#     +3</span>
                if_str+=action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list)      
            <span class="hljs-comment">#          </span><font></font>
            wall_offset = offset_koeff                                                      <font></font>
            if_rek, offset_koeff, fin_else_flag, prob_list = if_gen(exp_list, var_list, if_str, offset_koeff+<span class="hljs-number">3</span>, fin_else_flag, prob_list) <span class="hljs-comment">#  if+if</span>
            <span class="hljs-comment">#    </span><font></font>
            if_str+=if_rek   <font></font>
            <span class="hljs-comment">#   elif-else/                                                                </span>
            prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>],sol2=make_solution(prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>])         
            <span class="hljs-keyword">if</span> sol2!=<span class="hljs-number">0</span>:<font></font>
                prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol3=make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])
                <span class="hljs-keyword">if</span> sol3!=<span class="hljs-number">0</span>:<font></font>
                    ee_string=<span class="hljs-string">'elif'</span>
                <span class="hljs-keyword">else</span>:<font></font>
                    ee_string=<span class="hljs-string">'else'</span><font></font>
                if_str, offset_koeff, fin_else_flag, prob_list = elif_else_block(ee_string, wall_offset, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)  <font></font>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-comment">#     +3</span>
                if_str+=action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list)              
            <span class="hljs-keyword">return</span>(if_str, offset_koeff,fin_else_flag, prob_list)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s de las listas con "carne" para la generaci√≥n (exp_list, var_list), la funci√≥n tambi√©n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acepta if_str</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : esta es la l√≠nea donde el c√≥digo generado se recopila a su vez. Se acepta aqu√≠ porque la funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_gen en s√≠ misma</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se puede llamar de forma recursiva, y ser√≠a aconsejable no perder el fragmento de c√≥digo generado anteriormente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El par√°metro </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offset_koeff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el coeficiente de desplazamiento, que es un factor para una l√≠nea con un espacio ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base_offset</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) y, en consecuencia, es responsable de los desplazamientos horizontales de los bloques de c√≥digo. </font><font style="vertical-align: inherit;">Hablamos </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sobre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin_else_flag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arriba, aqu√≠ simplemente se pasa a una funci√≥n que es responsable de generar if + elif / else (ver m√°s abajo). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno, hay otro par√°metro:</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que es una hoja con 10 probabilidades (5 pares de probabilidades)</font></font><pre><code class="python hljs">prob_list = [<span class="hljs-number">0.5</span> <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)] </code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y es utilizada por la funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make_solution</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como discutimos anteriormente: se le pasa uno u otro par de probabilidades correspondientes al tipo de bifurcaci√≥n (por ejemplo, la bifurcaci√≥n estructural principal usa las 2 primeras probabilidades en la hoja: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list [0]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list [1]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Los resultados de los cambios de probabilidad en esta hoja, como ejemplo, se pueden ver en la siguiente figura. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tw/_o/qc/tw_oqckdotydpm1m5djcmdc3rgw.jpeg" width="550" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las probabilidades en esta lista cambian de generaci√≥n en generaci√≥n, si durante la pr√≥xima generaci√≥n se ejecuta el c√≥digo correspondiente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la funci√≥n en s√≠, la lista anidada choice_list se inicializa al principio: es necesaria para la generaci√≥n aleatoria conveniente de expresiones a partir de "carne", y el desplazamiento base </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base_offset = ''</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en un espacio.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de eso viene la bifurcaci√≥n principal, que, a trav√©s de la funci√≥n make_solution, obtiene la soluci√≥n en la variable sol. Sol toma uno de los tres valores (0, -1.1) y determina, por lo tanto, de acuerdo con qu√© esquema se construir√° la estructura. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La primera opci√≥n implementa la opci√≥n m√°s simple si + [..]. La respuesta se forma como una cadena con el desplazamiento actual (¬°no es necesariamente igual a 0!), Una cadena "if", una condici√≥n aleatoria que es generada por la funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_sub</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (que se discutir√° m√°s adelante), retorno de carro y generaci√≥n de un bloque de acci√≥n usando la funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">action_str</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ver m√°s abajo) . Como resultado, obtenemos algo como:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a+b)==(b)):<font></font>
   b=b<font></font>
   a=b-a<font></font>
   a=a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La segunda opci√≥n es responsable de generar este tipo: if [..] + elif / else-block (opci√≥n 2 en los esquemas). </font><font style="vertical-align: inherit;">Primero, la l√≠nea if + [..] se forma all√≠, luego se produce la bifurcaci√≥n elif / else, que decide si se generar√° el bloque elif-else, solo if-elif o if-else (funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lif_else_block</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ver m√°s abajo). </font><font style="vertical-align: inherit;">Los resultados pueden variar. </font><font style="vertical-align: inherit;">Por ejemplo:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a+b)==(a)):<font></font>
   b=a+b<font></font>
<span class="hljs-keyword">elif</span> ((b//a)==(a)):
   <span class="hljs-literal">None</span>
<span class="hljs-keyword">elif</span> ((a+b)&lt;=(a)):<font></font>
   a=b//a<font></font>
<span class="hljs-keyword">else</span>:
   <span class="hljs-keyword">if</span> ((b)&lt;=(a)):<font></font>
      a=b-a<font></font>
      b=a</code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a)==(b-a)):<font></font>
   b=b-a<font></font>
   b=b<font></font>
   a=b<font></font>
   a=b-a<font></font>
<span class="hljs-keyword">elif</span> ((b)&gt;(b-a))<span class="hljs-keyword">and</span>((a)&lt;(b-a)):
   <span class="hljs-keyword">if</span> ((b//a)&lt;(a)):<font></font>
      b=b-a<font></font>
   <span class="hljs-keyword">elif</span> ((a+b)&lt;(b-a))<span class="hljs-keyword">and</span>((b)&lt;(a+b))<span class="hljs-keyword">or</span>((a+b)==(a+b)):<font></font>
      b=b<font></font>
      a=b-a<font></font>
   <span class="hljs-keyword">elif</span> ((a)&gt;(b-a)):
      <span class="hljs-literal">None</span></code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b)&lt;=(b-a))<span class="hljs-keyword">or</span>((a+b)&gt;=(b)):<font></font>
   a=a<font></font>
   b=b<font></font>
<span class="hljs-keyword">elif</span> ((b)&lt;=(b)):
   <span class="hljs-keyword">if</span> ((a)&gt;=(b)):<font></font>
      a=a+b<font></font>
      a=b<font></font>
<span class="hljs-keyword">elif</span> ((b)&gt;=(a)):<font></font>
   a=b-a<font></font>
   a=a<font></font>
   <span class="hljs-keyword">if</span> ((a)&gt;=(b))<span class="hljs-keyword">and</span>((b//a)==(a))<span class="hljs-keyword">and</span>((b//a)!=(b)):<font></font>
      b=b-a<font></font>
<span class="hljs-keyword">else</span>:<font></font>
   a=b//a<font></font>
   <span class="hljs-keyword">if</span> ((b//a)&lt;(b-a)):<font></font>
      a=b<font></font>
      a=b-a<font></font>
   <span class="hljs-keyword">else</span>:
      <span class="hljs-keyword">if</span> ((a)==(b)):<font></font>
         a=a<font></font>
         a=b//a<font></font>
         b=b<font></font>
         b=a+b<font></font>
         b=a<font></font>
      <span class="hljs-keyword">else</span>:
         <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La tercera opci√≥n implementa la recursividad desde el principio (opci√≥n 3 en los esquemas), es decir </font><font style="vertical-align: inherit;">da lugar a una rama de la forma:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a)==(a)):
   <span class="hljs-keyword">if</span> ((a+b)&lt;(b)):</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
o </font></font><pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b-a)&lt;=(a)):<font></font>
   a=a<font></font>
   <span class="hljs-keyword">if</span> ((b-a)==(b)):<font></font>
      a=a<font></font>
      a=a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, se forma la l√≠nea if (de manera similar), luego aparece una bifurcaci√≥n, que decide si se inserta m√°s el bloque de acci√≥n o no, despu√©s de lo cual se guarda el desplazamiento y se llama a la recursi√≥n. El desplazamiento debe guardarse de modo que despu√©s de que se complete la recursi√≥n y se devuelva el fragmento de c√≥digo, es posible agregar otro bloque elif-else en el mismo desplazamiento que la l√≠nea original con if. Aqu√≠ puede ver c√≥mo elif y dem√°s en la rama se encuentran en el mismo desplazamiento con su "nativo" si.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b-a)==(b)):<font></font>
<font></font>
   <span class="hljs-keyword">if</span> ((a)&gt;(a+b)):
      <span class="hljs-keyword">if</span> ((b)==(b-a)):<font></font>
         b=b<font></font>
         a=a<font></font>
      <span class="hljs-keyword">elif</span> ((b)&gt;(b)):
         <span class="hljs-literal">None</span>
      <span class="hljs-keyword">else</span>:
         <span class="hljs-literal">None</span><font></font>
         b=a<font></font>
         b=b</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego viene una bifurcaci√≥n en el bloque elif-else-block / action, que decide si agregar un bloque de acci√≥n o un bloque elif-else despu√©s de la recursividad. Si decide agregar un bloque elif-else, entonces, de manera similar al caso descrito anteriormente, en el esquema 2, se selecciona elif o else. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ es necesario prestar atenci√≥n al hecho de que se llama a la recursi√≥n con un desplazamiento de + 3 para desplazar el c√≥digo generado a la derecha por un paso, y el bloque elif-else se llama con un desplazamiento de wall_offset para que este bloque no vaya a la derecha despu√©s de la recursi√≥n, sino que permanezca con el "nativo" el desplazamiento del original si. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los resultados pueden ser bastante diferentes: de simples a complejos, pero la aparici√≥n de recurrencia produce inmediatamente las ramas m√°s ornamentadas.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b-a)&gt;(a+b))<span class="hljs-keyword">and</span>((b)&lt;(a+b)):
   <span class="hljs-keyword">if</span> ((b-a)&lt;=(a+b)):<font></font>
      b=b//a<font></font>
   <span class="hljs-keyword">elif</span> ((b)!=(a)):<font></font>
      a=b-a<font></font>
<span class="hljs-keyword">else</span>:
   <span class="hljs-keyword">if</span> ((a+b)!=(b-a)):<font></font>
      a=a</code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b)&lt;(b-a)):
   <span class="hljs-keyword">if</span> ((a+b)==(b-a))<span class="hljs-keyword">and</span>((b-a)&lt;(a+b))<span class="hljs-keyword">and</span>((b-a)==(a))<span class="hljs-keyword">and</span>((a)&gt;(b//a))<span class="hljs-keyword">or</span>((a+b)&gt;(b//a)):
      <span class="hljs-keyword">if</span> ((b)&gt;=(b-a)):<font></font>
         a=b<font></font>
         b=b<font></font>
         <span class="hljs-keyword">if</span> ((b)&gt;(b)):<font></font>
            a=a+b<font></font>
            b=a+b<font></font>
            a=a<font></font>
            b=a+b<font></font>
            b=b//a<font></font>
            b=a<font></font>
      <span class="hljs-keyword">else</span>:<font></font>
         b=a+b<font></font>
         a=b<font></font>
         a=b<font></font>
   <span class="hljs-keyword">elif</span> ((a)&lt;(b-a)):<font></font>
      a=b//a<font></font>
      a=b-a</code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a)&gt;=(b-a))<span class="hljs-keyword">or</span>((a)&gt;=(a))<span class="hljs-keyword">or</span>((b)&lt;=(b)):<font></font>
   a=a<font></font>
   a=a<font></font>
<span class="hljs-keyword">elif</span> ((a)==(a))<span class="hljs-keyword">and</span>((b)&gt;(b-a)):<font></font>
   a=b//a<font></font>
   <span class="hljs-keyword">if</span> ((a)&lt;(b)):
      <span class="hljs-keyword">if</span> ((a+b)==(b-a)):<font></font>
         a=a<font></font>
         <span class="hljs-keyword">if</span> ((a)!=(b//a)):
            <span class="hljs-keyword">if</span> ((b//a)!=(a))<span class="hljs-keyword">and</span>((b-a)&gt;=(b)):<font></font>
               a=b<font></font>
            <span class="hljs-keyword">else</span>:
               <span class="hljs-literal">None</span><font></font>
               a=b//a<font></font>
      <span class="hljs-keyword">else</span>:<font></font>
         b=b<font></font>
         b=a+b<font></font>
         <span class="hljs-keyword">if</span> ((b-a)&lt;=(b//a)):<font></font>
            a=b<font></font>
            a=b<font></font>
            a=a+b<font></font>
<span class="hljs-keyword">else</span>:<font></font>
   a=a+b<font></font>
   <span class="hljs-keyword">if</span> ((b-a)&gt;=(a)):<font></font>
      a=b<font></font>
      <span class="hljs-keyword">if</span> ((b-a)==(a))<span class="hljs-keyword">or</span>((b)!=(b//a)):<font></font>
         a=b-a<font></font>
         a=a<font></font>
         a=a<font></font>
         a=b//a<font></font>
         a=a+b<font></font>
         b=a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora veamos la funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else_block</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que es responsable de formar el bloque elif-else y se llama desde la funci√≥n principal </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_gen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">elif_else_block</span>(<span class="hljs-params">ee_string, offset_koeff, exp_list, var_list, sign, if_str, choice_list,  fin_else_flag, prob_list</span>):</span>
    <span class="hljs-keyword">if</span> ee_string==<span class="hljs-string">'elif'</span>:<font></font>
        sol3 = <span class="hljs-number">9</span>
        <span class="hljs-comment">#  </span><font></font>
        wall_offset = offset_koeff<font></font>
        <span class="hljs-comment">#  elif  </span>
        <span class="hljs-keyword">while</span> sol3!=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> fin_else_flag!=<span class="hljs-number">1</span>:<font></font>
            temp_str, offset_koeff, fin_else_flag, prob_list=elif_else(<span class="hljs-string">'elif'</span>, wall_offset, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
            if_str+=temp_str<font></font>
            prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol3 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-comment">#  -   else   elif?</span>
        prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol = make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])
        <span class="hljs-keyword">if</span> sol!=<span class="hljs-number">0</span>:
            <span class="hljs-comment">#  else,   </span>
            fin_else_flag=<span class="hljs-number">1</span>
            temp_str,offset_koeff, fin_else_flag, prob_list=elif_else(<span class="hljs-string">'else'</span>, wall_offset, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
            if_str+=temp_str<font></font>
        <span class="hljs-keyword">return</span>(if_str,offset_koeff, fin_else_flag, prob_list)
    <span class="hljs-comment">#  else</span>
    <span class="hljs-keyword">else</span>: <font></font>
          temp_str,offset_koeff, fin_else_flag, prob_list=elif_else(<span class="hljs-string">'else'</span>, offset_koeff, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
          if_str+=temp_str<font></font>
          <span class="hljs-keyword">return</span>(if_str, offset_koeff, fin_else_flag, prob_list)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta funci√≥n decide si agregar un bloque elif o elif / else al c√≥digo. Ella no decide si simplemente quiere decir otra cosa, sino que depende del valor de entrada e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e_string</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que recibe de la funci√≥n principal </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_gen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Primero, el bloque elif se genera en el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ciclo while</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , donde se verifican 2 condiciones: probabil√≠stico: el n√∫mero de elif en el bloque y la bandera </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin_else_flag dependen de √©l</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y si se enciende repentinamente, significa que m√°s se conect√≥ antes y, por lo tanto, debe salir del ciclo . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La decisi√≥n de adjuntar else y else al bloque elif se decide mediante una bifurcaci√≥n que utiliza la misma funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make_solution</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y si se adjunta m√°s, el indicador </font><b><font style="vertical-align: inherit;">fin_else_flag</font></b><font style="vertical-align: inherit;"> se </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">activa inmediatamente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que detiene la generaci√≥n de bloques. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La uni√≥n directa de elif y else se realiza mediante la funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ver m√°s abajo). Aqu√≠ es necesario prestar atenci√≥n a que al generar el bloque elif (y tambi√©n al adjuntarle otro), el offset </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wall_offset</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se usa para construir el bloque sin problemas en su conjunto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora considere la funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="python hljs">&lt;b&gt;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">elif_else</span>(<span class="hljs-params">ee_string, offset_koeff, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list</span>):</span>
    ee_str = <span class="hljs-string">''</span>
    <span class="hljs-comment">#   else:  elif [..]:</span>
    <span class="hljs-keyword">if</span> ee_string==<span class="hljs-string">'else'</span>:<font></font>
        ee_str += <span class="hljs-string">' '</span>*offset_koeff+ee_string + <span class="hljs-string">':\n'</span>
    <span class="hljs-keyword">elif</span> ee_string==<span class="hljs-string">'elif'</span>:<font></font>
        ee_str += <span class="hljs-string">' '</span>*offset_koeff+ee_string+<span class="hljs-string">' '</span>+if_sub(exp_list, var_list, sign, prob_list) + <span class="hljs-string">':\n'</span>
    <span class="hljs-comment">#   -None /  +</span>
    prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol = make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])
    <span class="hljs-keyword">if</span> sol!=<span class="hljs-number">0</span>:<font></font>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol2 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-keyword">if</span> sol2!=<span class="hljs-number">0</span>:
            <span class="hljs-comment">#  </span>
            ee_str+=action_str_gen(choice_list,offset_koeff+<span class="hljs-number">3</span>, prob_list)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># None</span>
            ee_str+=<span class="hljs-string">' '</span>*(offset_koeff+<span class="hljs-number">3</span>)+<span class="hljs-string">'None\n'</span>
        <span class="hljs-keyword">return</span>(ee_str, offset_koeff, fin_else_flag, prob_list)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-comment">#   </span>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol2 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-keyword">if</span> sol2==<span class="hljs-number">0</span>:
            <span class="hljs-comment">#  </span>
            ee_str+=action_str_gen(choice_list,offset_koeff+<span class="hljs-number">3</span>, prob_list)
        <span class="hljs-comment">#  if_gen</span>
        if_str, offset_koeff,  fin_else_flag, prob_list = if_gen(exp_list, var_list, if_str, offset_koeff+<span class="hljs-number">3</span>, fin_else_flag, prob_list)                 <font></font>
        ee_str+=if_str<font></font>
        <span class="hljs-keyword">return</span>(ee_str, offset_koeff, fin_else_flag, prob_list)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La funci√≥n es responsable de la formaci√≥n de la l√≠nea elif o de lo contrario, as√≠ como de la generaci√≥n posterior de bloques de acci√≥n o recursividad despu√©s de estas l√≠neas. Tambi√©n toma una variable </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ee_string</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que contiene elif o else, y forma la cadena correspondiente. Luego hay una bifurcaci√≥n, donde se determina qu√© pasar√° a continuaci√≥n: (bloque de acci√≥n o Ninguno), o (bloque de acci√≥n o bloque de acci√≥n + recursi√≥n). Dentro de esta bifurcaci√≥n, hay una divisi√≥n, respectivamente, en dos sub-bifurcaciones, y en cada caso la funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make_solution</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se </font><b><font style="vertical-align: inherit;">llama</font></b><font style="vertical-align: inherit;"> con los par√°metros apropiados para tomar una decisi√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cabe se√±alar que cuando ocurre en el c√≥digo</font></font><code>if sol!=0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, esto significa que intencionalmente le damos una ventaja a una parte del c√≥digo sobre otra, porque si sol! = 0, entonces es igual a -1 o 1, y por lo tanto, otro fragmento de c√≥digo se ejecutar√° con menos frecuencia (solo cuando sol == 0). Esto se usa, en particular, en la funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else_block</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , donde es m√°s rentable para nosotros dejar que se </font><b><font style="vertical-align: inherit;">formen</font></b><font style="vertical-align: inherit;"> m√°s </font><b><font style="vertical-align: inherit;">elifs</font></b><font style="vertical-align: inherit;"> en el bloque, en lugar de dar la misma probabilidad a elif y dem√°s. O, por ejemplo, en la funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> le damos una ventaja a la opci√≥n cuando se forma un bloque de acci√≥n o Ninguno en lugar de lo que est√° buscando la recursi√≥n; de lo contrario, las ramas pueden crecer hasta tama√±os muy indecentes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solo necesitamos considerar las funciones responsables de la generaci√≥n aleatoria de expresiones en condiciones y bloques de acciones. Como dije anteriormente, en esta etapa no juegan un papel decisivo y se presentan aqu√≠ para mostrar en general c√≥mo se ver√° el c√≥digo final generado. Pero como se usan en el generador, los veremos brevemente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La funci√≥n responsable de generar el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloque de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> acci√≥n </font><b><font style="vertical-align: inherit;">action_str</font></b><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action_str_gen</span>(<span class="hljs-params">choice_list, offset_koeff, prob_list</span>):</span>
    sol = <span class="hljs-number">9</span>
    curr_offset = <span class="hljs-string">' '</span>*offset_koeff<font></font>
    act_str = <span class="hljs-string">''</span>
    <span class="hljs-keyword">while</span> sol!=<span class="hljs-number">0</span>:<font></font>
        act_str+= curr_offset+rand(rand(choice_list[<span class="hljs-number">1</span>]))+<span class="hljs-string">'='</span>+rand(rand(choice_list))+<span class="hljs-string">'\n'</span>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
    <span class="hljs-keyword">return</span>(act_str)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ todo es bastante simple: de la lista anidada choise_list, que, como recordamos, consiste en v </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ar_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (lista de variables) y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exp_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (lista de expresiones), esta funci√≥n consta de una o m√°s l√≠neas de esta forma: a = a + b o b = b . </font><font style="vertical-align: inherit;">Aquellos. </font><font style="vertical-align: inherit;">se asigna una expresi√≥n a la variable u otra variable (incluida ella misma). </font><font style="vertical-align: inherit;">La funci√≥n rand selecciona aleatoriamente un elemento de la lista y se necesita aqu√≠ √∫nicamente para no producir cadenas monstruosas.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rand</span>(<span class="hljs-params">t_list</span>):</span>
    <span class="hljs-keyword">return</span>(t_list[random.randint(<span class="hljs-number">0</span>,len(t_list)<span class="hljs-number">-1</span>)])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La funci√≥n de generaci√≥n de expresiones </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_sub</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para condiciones parece m√°s grande.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">if_sub</span>(<span class="hljs-params">exp_list, var_list, sign, prob_list</span>):</span>
    sub_str = <span class="hljs-string">''</span>
    sol = <span class="hljs-number">9</span><font></font>
    choice_list = [exp_list, var_list]<font></font>
    flag = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> sol!=<span class="hljs-number">0</span>:<font></font>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])<font></font>
        sub_str+=<span class="hljs-string">'(('</span>+rand(rand(choice_list))+<span class="hljs-string">')'</span>+rand(sign2)+<span class="hljs-string">'('</span>+rand(rand(choice_list))+<span class="hljs-string">'))'</span>
        <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> sol==<span class="hljs-number">1</span>:<font></font>
            sub_str+=<span class="hljs-string">')'</span>
            flag=<span class="hljs-number">0</span><font></font>
        or_and_exp = or_and(prob_list)<font></font>
        <span class="hljs-keyword">if</span> len(or_and_exp):<font></font>
            sub_str+=or_and_exp<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol2 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-keyword">if</span> sol2 == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'D'</span> <span class="hljs-keyword">or</span> sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'R'</span>) <span class="hljs-keyword">and</span> flag == <span class="hljs-number">0</span>:<font></font>
            sub_str+=<span class="hljs-string">'('</span>
            flag = <span class="hljs-number">1</span><font></font>
    <font></font>
    <span class="hljs-keyword">if</span> sub_str[<span class="hljs-number">-1</span>] == <span class="hljs-string">'('</span>:
        <span class="hljs-keyword">if</span> sub_str[<span class="hljs-number">-2</span>]==<span class="hljs-string">'d'</span>:<font></font>
           sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-4</span>]
        <span class="hljs-keyword">elif</span> sub_str[<span class="hljs-number">-2</span>]==<span class="hljs-string">'r'</span>:<font></font>
             sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-3</span>]
        <span class="hljs-keyword">else</span>:<font></font>
            sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-1</span>]
    <span class="hljs-keyword">elif</span> sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'d'</span>:<font></font>
         sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-3</span>]
    <span class="hljs-keyword">elif</span> sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'r'</span>:<font></font>
         sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-2</span>]
    <span class="hljs-keyword">else</span>:
         <span class="hljs-literal">None</span>
    <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span>:<font></font>
        sub_str+=<span class="hljs-string">')'</span>
        <span class="hljs-keyword">return</span>(sub_str)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span>(sub_str)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Genera expresiones por tipo: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">((a)&gt; = (ba)) o ((a)&gt; = (a)) o ((b) &lt;= (b))</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Al mismo tiempo, los lados izquierdo y derecho pueden tener varias opciones y representarse como variables separadas, as√≠ como expresiones o sus grupos. </font><font style="vertical-align: inherit;">Los operadores l√≥gicos </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tambi√©n se utilizan aqu√≠ </font><font style="vertical-align: inherit;">, que se seleccionan por conveniencia usando el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or_and_exp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funci√≥n </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">or_and</span>(<span class="hljs-params">prob_list</span>):</span>
    prob_list[<span class="hljs-number">8</span>],prob_list[<span class="hljs-number">9</span>],sol = make_solution(prob_list[<span class="hljs-number">8</span>],prob_list[<span class="hljs-number">9</span>])
    <span class="hljs-keyword">if</span> sol==<span class="hljs-number">-1</span>:
        <span class="hljs-keyword">return</span>(<span class="hljs-string">'and'</span>)
    <span class="hljs-keyword">elif</span> sol==<span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span>(<span class="hljs-string">'or'</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span>(<span class="hljs-string">''</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resto de la funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_sub</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> corta las colas adicionales de las expresiones y agrega, cuando es necesario, cerrar los corchetes, para considerar estos bailes con panderetas aqu√≠, creo que es inoportuno. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno eso es todo. </font><font style="vertical-align: inherit;">Puede iniciar el generador, por ejemplo, as√≠:</font></font><br>
<br>
<pre><code class="python hljs">var_list = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>]<font></font>
exp_list = [<span class="hljs-string">'a+b'</span>,<span class="hljs-string">'b-a'</span>, <span class="hljs-string">'b//a'</span>]<font></font>
sign = [<span class="hljs-string">'+'</span>,<span class="hljs-string">'-'</span>,<span class="hljs-string">'/'</span>,<span class="hljs-string">'*'</span>,<span class="hljs-string">'//'</span>]<font></font>
sign2 = [<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'=='</span>,<span class="hljs-string">'&gt;='</span>,<span class="hljs-string">'&lt;='</span>,<span class="hljs-string">'!='</span>]<font></font>
a = <span class="hljs-number">3</span>
b = <span class="hljs-number">2</span>       
prob_list = [<span class="hljs-number">0.5</span> <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)]      
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
     if_str = <span class="hljs-string">''</span>
     if_str, offset_koeff, fin_else_flag, prob_list = if_gen(exp_list, var_list, if_str, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>, prob_list)
     <span class="hljs-keyword">try</span>:<font></font>
         exec(compile(if_str,<span class="hljs-string">'gen'</span>,<span class="hljs-string">'exec'</span>))<font></font>
         print(if_str)<font></font>
         input()<font></font>
         <font></font>
     <span class="hljs-keyword">except</span> ZeroDivisionError:
         <span class="hljs-literal">None</span>
     <span class="hljs-keyword">except</span>:<font></font>
         print(<span class="hljs-string">'error'</span>)<font></font>
         print(if_str)<font></font>
         input()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, la entrada, que incluye un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con probabilidades </font><font style="vertical-align: inherit;">, luego en un bucle infinito, llamando a la funci√≥n principal </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_gen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e iniciando la cadena generada generada para su ejecuci√≥n. Vale la pena procesar por separado ZeroDivisionError, porque La divisi√≥n por cero con una construcci√≥n de expresiones tan aleatoria es muy com√∫n. Despu√©s del lanzamiento, simplemente presione Entrar para que aparezca la pr√≥xima generaci√≥n. La mayor√≠a de las veces ser√°n bastante simples, pero a menudo ramificadas e incluso muy ramificadas. Bueno, </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">importar al azar</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al principio tambi√©n ser√≠a bueno para insertar;) Para aquellos que no quieren ver la recopilaci√≥n de todo a mano, puede descargar el archivo de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (archivo if_gen.py).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conclusi√≥n, quiero decir que el c√≥digo que present√© fue probado en cientos de miles de generaciones sin errores, mientras que demostr√≥ toda la paleta de esquemas if-elif-else que quer√≠a ver finalmente. Una vez, por error, le di a una parte del c√≥digo una probabilidad demasiado alta de recurrencia y obtuve 52,000 (!) L√≠neas de generaci√≥n y estaba funcionando (aunque la compilaci√≥n se suspendi√≥ por 30 segundos). Esto tambi√©n indica la fiabilidad del algoritmo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probablemente, fue posible escribir de manera m√°s concisa en alguna parte, optimizar en alguna parte, componer la funci√≥n principal de otra manera, pero lo principal es que este c√≥digo funciona y genera alrededor de 250 generaciones por segundo, lo cual, en mi opini√≥n, es bastante aceptable.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nunca consider√© este c√≥digo como autosuficiente: es solo un m√≥dulo del futuro organismo digital y fue escrito con fines de investigaci√≥n, por lo que apenas tiene aplicaciones pr√°cticas. </font><font style="vertical-align: inherit;">Al mismo tiempo, no soy responsable de las consecuencias de que alguien use el c√≥digo anterior, e insto a todos a cortar el pan con un cuchillo para cortar pan, y no otra cosa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el pr√≥ximo art√≠culo, consideraremos el segundo m√≥dulo, que ser√° responsable de la formaci√≥n aleatoria de la experiencia. </font><font style="vertical-align: inherit;">Este tema promete ser mucho m√°s interesante que el generador if, y definitivamente publicar√© los resultados tan pronto como los tenga.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es504270/index.html">¬øEs Svelte una buena opci√≥n para la implementaci√≥n de widgets?</a></li>
<li><a href="../es504276/index.html">Los 10 mejores libros para desarrolladores</a></li>
<li><a href="../es504282/index.html">Creaci√≥n de arquitectura empresarial en NSPK</a></li>
<li><a href="../es504284/index.html">El libro "√Ågil puro. Los fundamentos de la flexibilidad</a></li>
<li><a href="../es504290/index.html">Pruebas de carga como un servicio de CI para desarrolladores</a></li>
<li><a href="../es504306/index.html">¬øC√≥mo se fabrica el hardware ruso para el almacenamiento de Aerodisk Vostok en Elbrus?</a></li>
<li><a href="../es504310/index.html">Dicotom√≠a de datos: repensar la relaci√≥n con datos y servicios.</a></li>
<li><a href="../es504312/index.html">Registro unificado de programas rusos y GPL. Mis cinco centavos</a></li>
<li><a href="../es504314/index.html">Implementaci√≥n de los comandos docker pull y docker push sin el cliente docker a trav√©s de solicitudes HTTP</a></li>
<li><a href="../es504320/index.html">C√≥digo de l√≠nea √∫nica o validaci√≥n Nethermind usando PVS-Studio C # para Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>