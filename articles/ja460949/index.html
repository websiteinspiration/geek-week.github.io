<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎈 👨🏼‍🤝‍👨🏻 🔷 「そして不可能は可能です」：バイナリ分析を使用してブラックボックスを白に変えます 🐓 🤞🏿 🙆🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="現在、アプリケーションの脆弱性を検索するには、静的分析と動的分析の2つの主要なアプローチがあります。どちらのアプローチにも長所と短所があります。市場は、両方のアプローチを使用する必要があるという結論に達しました。どちらのアプローチも、わずかに異なる問題を解決し、結果は異なります。ただし、ソースコード...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>「そして不可能は可能です」：バイナリ分析を使用してブラックボックスを白に変えます</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/solarsecurity/blog/460949/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14e/362/af9/14e362af9999b5cdcee04915843352f4.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、アプリケーションの脆弱性を検索するには、静的分析と動的分析の2つの主要なアプローチがあります。</font><font style="vertical-align: inherit;">どちらのアプローチにも長所と短所があります。</font><font style="vertical-align: inherit;">市場は、両方のアプローチを使用する必要があるという結論に達しました。どちらのアプローチも、わずかに異なる問題を解決し、結果は異なります。</font><font style="vertical-align: inherit;">ただし、ソースコードがない場合など、静的分析の使用が制限される場合があります。</font><font style="vertical-align: inherit;">この記事では、非常にまれではありますが、静的アプローチと動的アプローチの利点を組み合わせることができる非常に有用なテクノロジー、つまり実行可能コードの静的分析について説明します。</font></font><br>
<a name="habracut"></a><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遠くから行こう</font></font></b><div class="spoiler_text">    McAfee,      2017    $600 ,   0.8%  .      ,         -     .      -    . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>      . <br>
<br>
     :      ,  90%         .      :<br>
<br>
<ul>
<li> SQL-,</li>
<li> ,</li>
<li> ,</li>
<li>  .</li>
</ul><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
宣言されていない機能（NDV）と脆弱性の存在に関するソフトウェア（ソフトウェア）の分析は、アプリケーションのセキュリティを確保するための主要な技術です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソフトウェアの脆弱性とNDV（情報セキュリティ要件への準拠）を分析するための古典的で定評のあるテクノロジーについて言えば、以下を区別できます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的コード分析（静的アプリケーションセキュリティテスト）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的コード分析（Dynamic Application Security Testing）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IAST（インタラクティブ分析）がありますが、それは本質的に動的です（分析のプロセスでは、追加のエージェントがアプリケーションの実行中に何が起こるかを観察します）。</font><font style="vertical-align: inherit;">RASP（ランタイムアプリケーションの自己防衛）は、いくつかの分析ツールでも時々言及されますが、保護ツールである可能性が高いです。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
動的分析（「ブラックボックス」メソッド）は、実行中のプログラムチェックです。</font><font style="vertical-align: inherit;">次の利点は、このアプローチと区別できます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行可能プログラムには脆弱性があり、その操作によってエラーが検出されるため、誤検知の発生は静的分析の発生よりも少なくなります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析を実行するためにソースコードは必要ありません。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、欠点もあります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードのカバレッジが不完全であるため、脆弱性を見逃すリスクがあります。</font><font style="vertical-align: inherit;">たとえば、動的分析では、弱い暗号化や「一時的な爆弾」などのブックマークの使用に関連する脆弱性を見つけることができません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションを実行する必要があり、場合によっては難しい場合があります。</font><font style="vertical-align: inherit;">アプリケーションを起動するには、複雑な構成とさまざまな統合の構成が必要になる場合があります。</font><font style="vertical-align: inherit;">また、できるだけ正確な結果を得るためには、「戦闘環境」を再現する必要がありますが、ソフトウェアを損なうことなくこれを完全に実現することは困難です。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
静的分析（ホワイトボックス法）は、プログラムが実行されないタイプのプログラムテストです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メリットを一覧表示します。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">より多くの脆弱性の検索につながるコードの完全なカバレッジ。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムが実行される環境に依存しません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行可能ファイルがない場合に、モジュールまたはプログラムのコードを書く初期段階でテストを実装する機能。</font><font style="vertical-align: inherit;">これにより、開発の開始時に、類似のソリューションをSDLC（ソフトウェア開発ライフサイクルソフトウェア開発ライフサイクル）に柔軟に統合できます。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法の唯一の欠点は、誤検知の存在です。アナライザーが実際のエラーを示しているかどうか、またはこの誤検知である可能性が高いかどうかを評価する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、どちらの分析方法にも長所と短所があります。</font><font style="vertical-align: inherit;">しかし、短所を最小限に抑えながら、これらの方法の利点を何らかの方法で使用することは可能ですか？</font><font style="vertical-align: inherit;">はい、バイナリ分析を適用する場合-静的分析による実行可能ファイルの脆弱性の検索。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイナリ分析または実行可能ファイル分析テクノロジー</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93b/ba8/662/93bba8662a8a8f2e6dcaf16c39193950.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイナリ分析では、サードパーティの請負業者の場合など、ソースコードなしで静的分析が可能です。</font><font style="vertical-align: inherit;">さらに、動的分析法の適用とは対照的に、コードカバレッジは完全になります。</font><font style="vertical-align: inherit;">バイナリ分析を使用すると、ソースコードがない開発プロセスで使用されるサードパーティライブラリを確認できます。</font><font style="vertical-align: inherit;">また、バイナリ分析を使用して、リポジトリからのソースコードと戦闘サーバーからの実行可能コードの分析結果を比較することにより、リリースの制御チェックを実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイナリ分析のプロセスでは、バイナリイメージは中間分析（内部表現またはコードモデル）に変換され、さらに分析されます。その後、静的解析アルゴリズムが内部表現に適用されます。その結果、現在のモデルには、脆弱性とNDVをさらに検出するために必要な情報が追加されます。次の段階では、脆弱性とNDVの検索に関するルールの適用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
静的解析スキームについては</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、以前の記事で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">詳しく</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">説明しました</font></a><font style="vertical-align: inherit;">。コンパイル理論の要素（字句解析、構文解析）を使用してモデルを構築するソースコード分析とは異なり、バイナリ解析では、逆アセンブリ、逆コンパイル、解読などの逆変換理論を使用してモデルを構築します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用語について少し</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デバッグ情報を持たない実行可能ファイルの分析について話している。</font><font style="vertical-align: inherit;">デバッグ情報を使用すると、タスクは大幅に簡略化されますが、デバッグ情報がある場合、ソースコードが最も可能性が高く、タスクは無関係になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、Javaバイトコード分析をバイナリ分析とも呼びますが、これは完全に正しいわけではありません。</font><font style="vertical-align: inherit;">これは、テキストを簡略化するために行います。</font><font style="vertical-align: inherit;">もちろん、JVMバイトコードを分析するタスクは、バイナリC / C ++コードやObjective-C / Swiftを分析するよりも簡単です。</font><font style="vertical-align: inherit;">しかし、バイトコードとバイナリコードの場合の一般的な分析スキームは似ています。</font><font style="vertical-align: inherit;">この記事で説明する主な問題は、特にバイナリコードの分析に関連しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
逆コンパイルは、バイナリコードからソースコードを復元するプロセスです。</font><font style="vertical-align: inherit;">逆変換の要素について話すことができます-逆アセンブル（バイナリイメージからのアセンブラコードの取得）、アセンブラを3アドレスコードまたはその他の表現に変換し、ソースコードレベルの構造を復元します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
難読化-ソースコードの機能を維持しながら、結果のバイナリイメージを逆コンパイルして理解することを困難にする変換。</font><font style="vertical-align: inherit;">解読は逆変換です。</font><font style="vertical-align: inherit;">難読化は、ソースコードレベルとバイナリコードレベルの両方で適用できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果を見るには？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後から少し始めましょうが、通常はバイナリ分析の結果を表示するという質問が最初に行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイナリコード分析の専門家は、脆弱性とNDVをソースコードにマッピングすることが重要です。これを行うには、混乱を招く変換が適用され、バイナリコードがソースに逆コンパイルされた場合、最終段階で解読（解読）のプロセスが開始されます。つまり、デコンパイルされたコードで脆弱性が示される可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
逆コンパイルのプロセスでは、JVMバイトコードを逆コンパイルしても、一部の情報が正しく復元されないため、分析自体はバイナリコードに近い表現で行われます。したがって、問題が発生します。バイナリコードの脆弱性を見つけて、それらをソースにローカライズする方法は？説明したJVMバイトコードの問題の解決策</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javaバイトコードの脆弱性の検索に関する記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">バイナリコードの解決策は似ています。つまり、技術的な質問です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要な警告を繰り返しましょう-デバッグ情報なしのバイナリコード分析について話しています。</font><font style="vertical-align: inherit;">デバッグ情報がある場合、タスクは大幅に簡素化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果の表示に関して私たちに尋ねられる主な質問は、逆コンパイルされたコードが脆弱性を理解してローカライズするのに十分であるかどうかです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d88/8c6/5f5/d888c65f519aa80b4c4281a2f16dfc4e.jpg" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、この問題に関するいくつかの考えです。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVMバイトコードについて話している場合、一般的には答えは「はい」です。バイトコードの逆コンパイル品質は素晴らしいです。</font><font style="vertical-align: inherit;">ほとんどの場合、脆弱性が何であるかを理解できます。</font></font></li>
<li>     ,          . ,    ,    ,  ,    .   ,  -   ,          ,  .</li>
<li>       (, C++), ,   .   ,     C++ .      ,       :   ,    .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほとんどの場合、見つかった脆弱性を理解するのに十分な逆コンパイル品質を達成できます。</font><font style="vertical-align: inherit;">これを行うには、多くの難しい問題を解決する必要がありますが、それらは解決できます（以下で簡単に説明します）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C / C ++の場合、脆弱性を特定することはさらに困難です-文字の名前はコンパイルプロセス中に多くの方法で失われ、それらを復元することはできません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objective-Cの状況は少し良くなっています。そこには関数名があり、脆弱性の特定が容易です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">難読化の問題は際立っています。</font><font style="vertical-align: inherit;">脆弱性の逆コンパイルとマッピングを複雑にする可能性のある複雑な変換がいくつかあります。</font><font style="vertical-align: inherit;">実際には、優れたデコンパイラーが混乱を招く変換のほとんどに対応していることがわかります（脆弱性を理解するのに十分なコード品質が必要であることを忘れないでください）。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論として-ほとんどの場合、脆弱性を示し、理解および検証できるようにします。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイナリ分析の複雑さと詳細 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、バイトコードについては触れません。これに関するすべての興味深いことは、すでに上で述べました。</font><font style="vertical-align: inherit;">最も興味深いのは、実際のバイナリコードの分析です。</font><font style="vertical-align: inherit;">ここでは、例としてC / C ++、Objective-C、Swiftの分析について説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分解する場合でも、かなりの困難が生じます。</font><font style="vertical-align: inherit;">最も重要な段階は、バイナリイメージをサブプログラムに分割することです。</font><font style="vertical-align: inherit;">次に、サブルーチンでアセンブラー命令を選択します-技術的な問題です。</font><font style="vertical-align: inherit;">これについて</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、「Issues of Cyber​​security No. 1（14）-2016」というジャーナルの記事で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">詳しく</font><font style="vertical-align: inherit;">説明しました。ここでは簡単に説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例として、x86アーキテクチャについて説明します。その中の命令は固定長ではありません。バイナリイメージでは、コードとデータのセクションに明確に分離されていません。インポートテーブル、仮想関数テーブルはコードセクションに配置でき、遷移テーブルはコードセクションの基本関数ブロック間の間隔に配置できます。したがって、コードをデータから分離し、ルーチンの開始位置と終了位置を理解できる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も一般的なのは、サブプログラムの開始アドレスを決定する問題を解決する2つの方法です。最初の方法では、サブプログラムのアドレスは標準のプロローグによって決定されます（x86アーキテクチャーの場合、それはpush ebp、mov ebp、espです）。 2番目の方法では、サブルーチンの呼び出し命令を認識して、コードのセクションをエントリポイントから再帰的にトラバースします。バイパスは、分岐命令を認識することによって行われます。説明されている方法の組み合わせは、プロローグによって検出された開始アドレスから再帰的トラバーサルが開始される場合にも使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、すべての関数に標準のプロローグがあるわけではなく、間接的な呼び出しと遷移があるため、このようなアプローチでは認識されるコードの割合がかなり低いことがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本的なアルゴリズムは、次のヒューリスティックによって改善できます。</font></font><br>
<br>
<ol>
<li>          (    ).</li>
<li>     ,       .</li>
<li>        ,     ,     .</li>
<li>                .</li>
<li>             .       no-return .        switch-.<br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常は後で脆弱性を探すことができるように、逆変換中に実行する必要があるもう1つの重要なことは、バイナリイメージの標準関数を認識することです。</font><font style="vertical-align: inherit;">標準関数は、画像に静的にリンクすることも、インラインにすることもできます。</font><font style="vertical-align: inherit;">主な認識アルゴリズムは、バリエーションを含む署名による検索です。解決策として、適応型のAho-Korasikアルゴリズムを提供できます。</font><font style="vertical-align: inherit;">署名を収集するには、さまざまな条件下で収集されたライブラリイメージを事前に分析し、それらを不変のバイトとして選択する必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次は何ですか</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前のセクションでは、バイナリイメージの逆変換の最初の段階である逆アセンブリについて検討しました。</font><font style="vertical-align: inherit;">ステージは確かに初期ですが、決定的です。</font><font style="vertical-align: inherit;">この段階では、一部のコードが失われる可能性があり、その場合、分析結果に劇的な影響を及ぼします。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/2a1/e8e/d0a2a1e8e1a55b64c97f10eca64df9b3.jpg" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、多くの興味深いことが起こります。主なタスクについて簡単に説明します。詳細については説明しません。ここでは明示的に書き込めないノウハウ、または非常に興味深い技術およびエンジニアリングソリューションのいずれかが詳細に含まれています。</font></font><br>
<br>
<ol>
<li>     ,     .    .  C-    LLVM. LLVM     , ,       ,     .       ,     . ,  ,     ,       .          .</li>
<li>    (, , ).         ,     .            CFG (  )      .</li>
<li>   .   .  ,   ,          —      CFG,        ,  .      ,   ,    .</li>
</ol><br>
<h2></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソースコードがないときに静的分析を行う方法について話しました。</font><font style="vertical-align: inherit;">顧客とのコミュニケーションの経験によると、このテクノロジーは非常に需要が高いことがわかりました。</font><font style="vertical-align: inherit;">ただし、この技術はまれです。バイナリ分析の問題は簡単ではありません。その解決策には、静的分析と逆変換の複雑なハイテクアルゴリズムが必要です。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事は、Solar appScreenerアナリストであるAnton Prokofievと共同で作成されました</font></font></i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja460939/index.html">ロシアの鉱業の歴史とそれに対する規制当局の態度について</a></li>
<li><a href="../ja460941/index.html">ビジネスメールの侵害：攻撃に対する防御なし</a></li>
<li><a href="../ja460943/index.html">Googleデータスタジオ（+テンプレート）でのシナリオ予測に基づいてSEOの有望なキーを選択する方法</a></li>
<li><a href="../ja460945/index.html">電報チャネルを使用してゲームスタジオの認知度を高め、収益を拡大した経験</a></li>
<li><a href="../ja460947/index.html">WASMミートアップ1/08</a></li>
<li><a href="../ja460951/index.html">Androidライブ壁紙を作成する</a></li>
<li><a href="../ja460953/index.html">ポインタは複雑ですか、またはバイトに何が格納されていますか？</a></li>
<li><a href="../ja460955/index.html">コンストラクターとセッターにパラメーターを値渡しするための教育プログラム（最新のC ++、例）</a></li>
<li><a href="../ja460959/index.html">マイクロソフトの新しいテクノロジーにより、実在する人物の3Dコピーで任意の言語を話すことができます</a></li>
<li><a href="../ja460961/index.html">混合Swift + Objective-Cプロジェクトでの単体テストのセットアップ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>