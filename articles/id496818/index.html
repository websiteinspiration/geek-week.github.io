<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰🏿 🆒 👩🏽‍🎤 Ratusan ribu rute per detik per inti. Yandex. Pengalaman Rute 🀄️ 🧔🏼 🥉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa minggu yang lalu, Danya Tararukhin memberi tahu Habré bagaimana layanan kami muncul, Yandex. Rute, dan bagaimana hal itu membantu perusahaan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Ratusan ribu rute per detik per inti. Yandex. Pengalaman Rute</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/496818/"><img src="https://habrastorage.org/webt/it/we/vn/itwevn4ivk3h4pncvonx-mh4w70.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beberapa minggu yang lalu, Danya Tararukhin </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memberi tahu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Habré bagaimana layanan kami muncul, Yandex. Rute, dan bagaimana hal itu membantu perusahaan dengan logistik. </font><font style="vertical-align: inherit;">Dengan membuat platform, kami memecahkan beberapa masalah menarik, salah satunya didedikasikan untuk posting hari ini. </font><font style="vertical-align: inherit;">Saya ingin berbicara tentang perencanaan rute itu sendiri dan sumber daya yang diperlukan untuk ini.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menemukan rute terbaik antara banyak titik adalah masalah optimasi diskrit klasik. </font><font style="vertical-align: inherit;">Untuk mengatasinya, Anda perlu mengetahui jarak dan waktu perjalanan antara semua titik. </font><font style="vertical-align: inherit;">Artinya, untuk mengetahui matriks jarak dan waktu. </font><font style="vertical-align: inherit;">Dua tahun lalu, perhitungan matriks yang panjang adalah masalah yang sangat penting bagi kami dan menghalangi pengembangan. </font><font style="vertical-align: inherit;">Pencarian untuk solusi optimal dengan matriks yang diketahui membutuhkan waktu 10 menit, tetapi perhitungan semua sel matriks untuk tugas-tugas besar (untuk beberapa ribu pesanan) membutuhkan waktu berjam-jam.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengatasi masalah dengan lima ribu pesanan, Anda perlu mengetahui jarak dan waktu perjalanan antara semua titik. Ini adalah dua matriks angka dengan dimensi 5000x5000. Kami merencanakan rute kurir sepanjang hari, dan di pagi hari kurir akan tiba dari titik ke titik dalam satu waktu, dan di malam hari - untuk yang lain. Jadi, Anda perlu menghitung matriks waktu dan jarak untuk setiap jam dalam sehari. Tidak semua jam dalam sehari adalah unik, tetapi waktu gabus (pagi dan sore) perlu ditutup dengan baik. Oleh karena itu, kami sampai pada konfigurasi dengan irisan tiga belas jam. Secara total, kita membutuhkan dua kubus (waktu dan jarak) masing-masing 13x5000x5000. Ini adalah 325 juta rute, dihitung menurut grafik jalan nyata, di mana 165 juta ujungnya. Penghitungan satu rute dalam algoritma yang dioptimalkan dengan baik dari tim Yandex.Maps membutuhkan waktu sekitar 10 ms, dengan total 900 jam perhitungan.Bahkan ketika diparalelkan dengan 900 CPU, Anda harus menunggu 1 jam. Kami tidak dapat memulai layanan seperti itu, kami membutuhkan algoritma yang lebih cocok.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk bacaan lebih lanjut, penting untuk mengetahui </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritma Dijkstra</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk menemukan jalur terpendek dalam grafik. Itu bisa dibayangkan sebagai "gelombang" yang berasal dari titik awal rute dan mengelilingi seluruh grafik sampai titik finish terpenuhi. Dalam hal ini, waktu berjalan algoritma sebanding dengan tepi grafik, yaitu area yang dicakup oleh gelombang: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cz/7s/em/cz7seml-ef9d058gdfhgkoe50_k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hampir setiap kandidat untuk wawancara pada wawancara mengetahui langkah pertama dalam mengoptimalkan tugas seperti itu: Anda dapat memulai gelombang dari dua sisi dan mengakhiri pencarian ketika gelombang bertemu. Luas total dua gelombang setengah jari-jari kurang dari satu besar.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2g/ch/2c/2gch2cvzqgbjwduk9_agsqhvrma.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grafik jalan sebenarnya cukup terstruktur, dan ini dapat digunakan. Ketika Anda mencari jarak terpendek antara Moskow dan St. Petersburg, di Dijkstra klasik Anda akan dipaksa untuk menyebarkan gelombang dalam lingkaran dan memilah-milah semua jalan-jalan dan lorong-lorong di Moskow, kota-kota dan desa-desa Wilayah Moskow, jalan-jalan Tver dan Novgorod. Ini adalah jumlah perhitungan yang sangat besar, tetapi Anda dapat mempersiapkan terlebih dahulu dan mengingat rute optimal antar kota (alias pintasan) dan tidak mengulanginya dalam runtime. Kemudian, untuk menemukan rute antara dua titik di Dijkstra hirarkis, Anda perlu menghitung jarak terpendek ke jalan pintas yang diinginkan. Karena level hierarki mungkin bukan dua, tetapi 5-6, mereka secara dramatis mengurangi waktu pencarian.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tim router Kartu telah mengimplementasikan optimasi semacam itu untuk beberapa waktu. Merekalah yang memungkinkan untuk mencapai 10 ms untuk menemukan rute antara dua titik. :) Jadi untuk saat ini, kami belum menyelesaikan masalah kami. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena mode pencarian point-to-point sudah sangat dioptimalkan, kami dapat mengoptimalkan perhitungan seri dalam matriks. Baris adalah jarak dari satu titik ke titik lainnya. Saat kami mencari jarak ke titik terjauh, kami secara bersamaan menghitung jarak ke titik terdekat. Oleh karena itu, menghitung deret sama dengan menghitung jarak ke titik terjauh. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jp/6i/qa/jp6iqadxummylqmj1suh0h2ppe8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami melihat pada saat menghitung seri menggunakan algoritma ini dan ingat bahwa perhitungan berurutan dari 5000 rute akan memakan waktu sekitar 5000 * 10 ms = 50 s:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jv/c_/v9/jvc_v98yos03l5xd5w57394s4dk.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grafik menunjukkan waktu perhitungan satu baris dalam matriks jarak ukuran 1 * N untuk N yang berbeda (menurut data nyata). Dapat dilihat bahwa perhitungan deretan ukuran 1 * 5000 yang menarik bagi kami cocok menjadi 1,3 detik. Garis tren telah ditambahkan ke grafik, yang menunjukkan bahwa waktu perhitungan tumbuh sedikit lebih lambat daripada linear di N, urutan N ** 0,74</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sudah tidak buruk! Dengan algoritma ini, kita dapat menghitung kubus kita dalam 13 * 5000 * 1,3 s = 84 500 s = hampir 24 jam. Dengan mudah paralel dengan baris, dan saat menggunakan 50 CPU, jarak dihitung dalam setengah jam. Urutan kompleksitas algoritma perhitungan kubus adalah O (N ** 1.74):</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9c/cr/xd/9ccrxdjoher2ks-ijoa7ur3rd2m.png"><br>
<i>    13   N*N    50 CPU (    13*N/50).      ,        5000 ,           .      10 000,   :      .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam formulir ini, dua setengah tahun yang lalu, kami meluncurkan versi pertama API kami, yang memecahkan masalah logistik. Klien sering mengeluh tentang waktu keputusan yang lama, dan mereka mudah dimengerti: Anda memulai tugas yang harus diselesaikan, tunggu 1 jam, Anda mendapatkan solusi dan Anda mengerti bahwa Anda lupa memperbaiki waktu shift dengan pengemudi, Anda memperbaikinya dan semuanya dimulai dari awal lagi. Pengemudi mulai merasa gugup, karena mereka berisiko masuk ke jam sibuk pagi hari, atau bahkan tidak punya waktu untuk mengirimkan pesanan tepat waktu. Itu perlu untuk melakukan sesuatu. Kami tidak ingin "melempar" masalah dengan besi: kami sedang bersiap untuk beban berat, itu akan membutuhkan banyak besi, dan pembelian server tidak terjadi sekaligus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebuah studi artikel akademik menunjukkan bahwa, ternyata, ada algoritma dengan kompleksitas linier untuk tugas ini </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! (Dalam artikel dengan referensi, ada ikhtisar besar dari semua jenis metode modern percepatan Dijkstra, termasuk untuk kasus matriks.) Menghitung matriks dalam waktu linier tidak cocok di kepala saya. Salah satu pengembang kami mengajukan diri untuk membuat prototipe, dan inilah yang terjadi: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/3o/lq/ag3olqspwhrjrvtodp699z6bl64.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Waktu untuk menghitung satu matriks ukuran N * N pada satu CPU menggunakan algoritma "matriks cepat". Kompleksitas diperoleh pada urutan O (N ** 1,1). Ns tinggi tersingkir dari garis tren, karena generasi jawaban dan pengunduhannya melalui jaringan sudah lebih mempengaruhi waktu.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
115 detik per 5000x5000 matriks menggunakan inti tunggal dan ketergantungan yang hampir linier pada N. Fiksi telah menjadi kenyataan! Ide algoritma menggabungkan dua ide yang dijelaskan di atas: Dijkstra untuk seri dan pencarian hierarkis. Jelas, mulai menghitung baris kedua, di beberapa titik kita akan kembali berkeliling area yang sama dari grafik yang baru saja kita lalui, menghitung baris sebelumnya. Oleh karena itu, mari kita mengingat jarak terpendek ke semua tujuan di simpul grafik hierarkis. Ketika kita mulai menghitung seri berikutnya, maka, setelah mencapai simpul seperti itu, kita akan segera mendapatkan hampir semua jarak ke titik lain. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ch/3y/os/ch3yosqi1h0od0dtee_tn_dsqem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setahun setengah yang lalu, ini memungkinkan kami menghemat setengah jam dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logistik dan secara signifikan mengurangi asupan zat besi. </font><font style="vertical-align: inherit;">Sebelumnya, untuk satu permintaan besar, kami membutuhkan 50 core selama setengah jam, tapi sekarang - 13 core selama 2 menit. </font><font style="vertical-align: inherit;">Ini adalah sekitar 200.000 rute per detik per inti. </font><font style="vertical-align: inherit;">Itu kasus langka ketika algoritma baru tidak hanya menutup kelas masalah, tetapi memperluas ide kami tentang kemungkinan.</font></font><br>
 <br>
<hr><sub><sup><a name="arxiv"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Artikel “Perencanaan Rute dalam Jaringan Transportasi”, lihat paragraf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.7.2 “Jalur Terpendek Batch”</font></font></a></sup></sub></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id496802/index.html">Simple Made Easy - Rich Hickey (dengan terjemahan Rusia)</a></li>
<li><a href="../id496804/index.html">Menginstal dan Mengkonfigurasi Docker di Windows Subsystem Linux (WSL)</a></li>
<li><a href="../id496810/index.html">Analisis Keuangan Umum dengan Python (Bagian 3)</a></li>
<li><a href="../id496812/index.html">Zoom - kelalaian dangkal atau spionase bertarget?</a></li>
<li><a href="../id496816/index.html">Bisakah Anda merasakan kandidat, apakah dia hidup?</a></li>
<li><a href="../id496820/index.html">Jebakan Terraform</a></li>
<li><a href="../id496822/index.html">Bagaimana startup di Amerika Serikat mati karena coronavirus</a></li>
<li><a href="../id496824/index.html">Lingkungan kerja Nordik Anda</a></li>
<li><a href="../id496826/index.html">Juta sprite di 120+ fps</a></li>
<li><a href="../id496828/index.html">Di mana menemukan freelance yang menyenangkan? (Spoiler: tidak Upwork)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>