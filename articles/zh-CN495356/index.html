<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕸️ 📞 👝 用Java实现分布式KV存储的RAFT共识算法。 🍘 👵🏽 🏦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="再一次问好。几天前，一个新的小组开始了关于“软件架构师”课程的培训，今天，我们想分享一个由该课程的学生之一Anton Pleshakov（Program Logistics开发负责人和Clusterra联合创始人）撰写的文章。
 
 
 
 当前，分布式微服务系统已经实际上已经成为行业标准，不仅在企...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>用Java实现分布式KV存储的RAFT共识算法。</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/495356/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再一次问好。几天前，一个新的小组开始了关于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“软件架构师”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">课程的培训</font><font style="vertical-align: inherit;">，今天，我们想分享一个由该课程的学生之一</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anton Pleshakov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Program Logistics开发负责</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">人和Clusterra</font></a><font style="vertical-align: inherit;">联合创始人）撰写的文章。</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/pb/5h/qq/pb5hqqeunfv8gkvyvspmegwuj4w.png"><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当前，分布式微服务系统已经实际上已经成为行业标准，不仅在企业界。已经多次描述和讨论了使用分布式系统的好处。微服务的优势早已为大家所熟知：任务技术，可组合性，可伸缩性，开发扩展，TTM缩减等。显然，分布式应用程序的开发提供了更多选择，以便及时响应不断增长的业务需求和周围所有事物的数字化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还需要注意的是，目前影响选择支持微服务的开发策略的一个非常重要的因素是各种现成的基础架构解决方案的可用性，这些解决方案解决了与操作分布式系统的额外成本相关的问题。我们正在谈论容器编排系统，服务mash，分布式跟踪，监视，日志记录等方法。可以肯定地说，今天提到的大多数今天作为微服务方法缺点的因素并没有几年前那么大的影响。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基于现代现实，大多数开发人员都在第一时间寻求从单一结构转换为微服务结构的机会。在不诉诸总重构和严重分解的情况下可以采取的第一步是实现水平可伸缩性系统。也就是说，将您的整体应用程序变成一个集群，甚至可能由相同的整体组件组成，但允许您动态更改其数量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当试图实现水平可伸缩性时，群集内的数据同步问题非常迅速且非常尖锐。幸运的是，所有现代DBMS都以一种或另一种方式支持节点之间的数据复制。开发人员只需选择用于任务的DBMS并根据CP或AP决定他需要的系统属性（根据CAP定理），CP或AP，问题就可以解决。在需要CP且一致性要求很高的情况下，解决数据同步问题的方法之一是使用支持RAFT共识算法的集群。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种相当新的算法（2012年开发）提供了高度的一致性保证，并且非常受欢迎。我决定弄清楚它是如何工作的，并用Java（Spring Boot）编写了一个一致的键值存储库的实现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自己实现任何分布式算法是否有意义？显然，您可以采用分布式算法的现成实现，并且以最高的概率实现比自制“自行车”更好。例如，您可以使用维护所需一致性级别的DBMS。或者，您可以部署</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zookeeper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。或者，您可以找到适合您的语言的框架。对于Java，有</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atomix</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它可以完美解决同步分布式数据的问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但另一方面。如果采用交钥匙解决方案，则通常使用外部应用程序会给系统增加一个额外的故障点。框架可能是多余的，或者难以操作和学习，或者对于您的编程语言而言，它们可能根本不存在。此外，共识算法的独立实现是一项非常有趣的工程任务，它可以拓宽您的视野，并使您了解如何使用更优化的方法解决服务在集群中交互时出现的问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于算法规范包含一组维护数据完整性的措施，因此您可以使用所获得的知识，甚至可以完整地使用算法。该算法的任何部分在现实生活中都可能有用。假设您有一组用于并行解析文件的工作程序。工人是等价的，但是您想指定其中一位工人作为协调员，当协调员跌倒时，请指派任何其他自由工人作为协调员。 RAFT算法的前半部分描述了如何在等效节点之间选择一个领导者，将为您提供帮助。例如，如果您只有两个与主从节点有关的节点，那么您可以很好地使用RAFT规范中描述的复制规则，以便在较简单的情况下组织数据交换。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文本质上是有关如何自己实施RAFT的实用指南。</font><font style="vertical-align: inherit;">该算法本身及其工作的理论方面将不被理解。</font><font style="vertical-align: inherit;">您可以在这篇</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出色的文章中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读简要说明，</font><font style="vertical-align: inherit;">或在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">学习完整的规范</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在那里，您可以找到算法的非常清晰的可视化。</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通用解决方案说明</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文分析了与算法实现直接相关的那部分代码。</font><font style="vertical-align: inherit;">本文结尾处有一个到存储库的链接，您可以在其中查看整个代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
任务如下。</font><font style="vertical-align: inherit;">开发一个分布式系统，使您可以将数据存储在键值数据库中。</font><font style="vertical-align: inherit;">每个节点的数据必须一致，即，如果数据进入一个节点的数据库，并且大多数节点确认它们也已接收到该数据，则该数据迟早会在每个节点的数据库中。</font><font style="vertical-align: inherit;">当集群的一部分断开连接并重新连接时，集群外部的节点必须赶上主集群并进行同步。</font><font style="vertical-align: inherit;">每个节点都提供用于写入和读取数据库数据的REST API。</font><font style="vertical-align: inherit;">该系统由用于两种类型的节点的两个模块组成：客户端和服务器。</font><font style="vertical-align: inherit;">下面我们考虑服务器本身实现的功能。</font><font style="vertical-align: inherit;">客户端代码在存储库中。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
服务器节点可以在三种状态下运行：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追随者（追随者）。</font><font style="vertical-align: inherit;">接受来自客户端的读取请求。</font><font style="vertical-align: inherit;">得到领导者的心跳</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">候选人（候选人）。</font><font style="vertical-align: inherit;">接受来自客户端的读取请求。</font><font style="vertical-align: inherit;">将投票请求发送到其他节点</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">领导 </font><font style="vertical-align: inherit;">接受读写请求。</font><font style="vertical-align: inherit;">将心跳请求发送到其他节点。</font><font style="vertical-align: inherit;">将附加请求数据发送到其他节点。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
节点之一的“领导”期间称为回合（任期）。</font><font style="vertical-align: inherit;">新的候选人开始新一轮。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据存储</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个节点都提供对操作日志存储库的访问，其中顺序记录了用于更改数据的操作。</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/pleshakoff/raft/blob/master/server/src/main/java/com/raft/server/operations/OperationsLog.java<br>
</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OperationsLog</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(Operation operation)</span></span>;
   <span class="hljs-function">Operation <span class="hljs-title">get</span><span class="hljs-params">(Integer index)</span></span>;
   <span class="hljs-function">List&lt;Operation&gt; <span class="hljs-title">all</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
   <span class="hljs-function">Long <span class="hljs-title">getTerm</span><span class="hljs-params">(Integer index)</span></span>;
   <span class="hljs-function">Integer <span class="hljs-title">getLastIndex</span><span class="hljs-params">()</span></span>;
   <span class="hljs-function">Long <span class="hljs-title">getLastTerm</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeAllFromIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newOperationIndex)</span></span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除数据和类型（插入，更改，删除）外，每个操作还包含创建操作的回合编号。此外，每个操作的索引都按顺序增加。重要的是，所有操作均应按照插入领导者日志的顺序插入跟随者的日志。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个节点都可以访问直接存储数据的数据库。</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/pleshakoff/raft/blob/master/server/src/main/java/com/raft/server/storage/Storage.java</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Storage</span> </span>{
   <span class="hljs-function">List&lt;Entry&gt; <span class="hljs-title">all</span><span class="hljs-params">()</span></span>;
   <span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(Long key)</span></span>;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Long key, String val)</span></span>;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Long key, String val)</span></span>;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Long key)</span></span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在当前的实现中，嵌入式内存解决方案既用于日志又用于数据库（普通竞争列表和地图）。如有必要，您可以简单地实现适当的接口以支持其他类型的存储。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从日志到数据库的操作应用是由分布式状态机执行的。状态机是一种机制，负责更改群集的状态，限制使用不正确的更改（乱序操作或认为自己是领导者的断开节点）。为了使更改被视为有效并将更改应用到数据库，它们必须通过一系列检查并满足某些条件，这正是状态机提供的条件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于领导者，如果大多数节点都已确认该操作也已复制到其日志中，那么该操作将应用于数据库。</font><font style="vertical-align: inherit;">对于跟随者，如果从领导者接收到进入其数据库的信号，则该操作将应用于数据库。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计时器 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个节点提供与其他节点的数据交换。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
支持两种查询：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行一轮投票时投票</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附加（也称为心跳）（如果没有数据）将日志数据复制到关注者，并防止开始新一轮投票。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事件发生的事实由计时器确定。</font><font style="vertical-align: inherit;">在节点上启动两种类型的计时器：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投票。</font><font style="vertical-align: inherit;">开始一轮投票。</font><font style="vertical-align: inherit;">每个节点都有其自己的间隔，在此间隔之后，它将尝试开始新的投票。</font><font style="vertical-align: inherit;">收到领导者的心跳后，倒数重新开始。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">心跳。</font><font style="vertical-align: inherit;">由追加领导者向关注者发送请求。</font><font style="vertical-align: inherit;">如果该节点未收到心跳并且投票计时器已过期，则它将成为候选者并发起选举，增加投票回合的数量并将投票请求发送到其他节点。</font><font style="vertical-align: inherit;">如果节点收集了多数票，则它将成为领导者并开始发出心跳信号。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">节点的当前状态</font></font></h3> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个节点都存储有关当前状态的数据。</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/pleshakoff/raft/blob/master/server/src/main/java/com/raft/server/context/Context.java</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Context</span> </span>{
   <span class="hljs-function">Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//    </span>
   <span class="hljs-function">State <span class="hljs-title">getState</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//: , ,  </span>
   <span class="hljs-function">Integer <span class="hljs-title">getVotedFor</span><span class="hljs-params">()</span></span>; 
               <span class="hljs-comment">//          </span>
   <span class="hljs-function">Long <span class="hljs-title">getCurrentTerm</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//  </span>
   <span class="hljs-function">Integer <span class="hljs-title">getCommitIndex</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//    </span>
   <span class="hljs-function">List&lt;Peer&gt; <span class="hljs-title">getPeers</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//      </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
领导节点还存储其向其复制数据的节点的元数据。</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/pleshakoff/raft/blob/master/server/src/main/java/com/raft/server/node/peers/Peer.java</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Peer</span> </span>{
   <span class="hljs-function">Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//  </span>
   <span class="hljs-function">Integer <span class="hljs-title">getNextIndex</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//  ,    </span>
   <span class="hljs-function">Integer <span class="hljs-title">getMatchIndex</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//   </span>
   <span class="hljs-function">Boolean <span class="hljs-title">getVoteGranted</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//     </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
领导者在收到来自跟随者的响应时，会更新节点元数据。</font><font style="vertical-align: inherit;">领导者使用它们来确定跟随者准备接受的下一个索引操作以及已经将哪些操作添加到跟随者的日志中。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表决</font></font></h3><br><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">ElectionService</font></a><font style="vertical-align: inherit;"> 
类负责投票</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ElectionService</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processElection</span><span class="hljs-params">()</span></span>;
   <span class="hljs-function">AnswerVoteDTO <span class="hljs-title">vote</span><span class="hljs-params">(RequestVoteDTO requestVoteDTO)</span></span>;<font></font>
} </code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发送投票请求 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果该节点是跟随者，并且在为等待设置的时间内未接收到心跳，则它将增加其当前回合，声明自己为候选者并开始向其他节点发送投票请求。</font><font style="vertical-align: inherit;">如果他设法达到法定人数，并且大多数节点都投了赞成票，那么他将成为新的领导人。</font><font style="vertical-align: inherit;">用RAFT术语来说，仲裁占所有节点的一半以上（51％）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们分析一下</font></font><code>processElection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class </font><font style="vertical-align: inherit;">方法</font></font><code>ElectionServiceImpl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，当投票到期时，投票计时器会调用它，并向节点</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发送投票请求</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
 <br>
<pre><code class="java hljs"><span class="hljs-comment">//1</span><font></font>
context.setState(CANDIDATE); <font></font>
Long term = context.incCurrentTerm(); <font></font>
context.setVotedFor(context.getId()); <font></font>
<font></font>
List&lt;Integer&gt; peersIds = context.getPeers().stream().map(Peer::getId).collect(Collectors.toList());<font></font>
<span class="hljs-keyword">long</span> voteGrantedCount = <span class="hljs-number">1L</span>;
<span class="hljs-keyword">long</span> voteRevokedCount = <span class="hljs-number">0L</span>;<font></font>
<font></font>
<span class="hljs-comment">//2</span>
<span class="hljs-keyword">while</span> (checkCurrentElectionStatus(term)) {<font></font>
   List&lt;AnswerVoteDTO&gt; answers = getVoteFromAllPeers(term, peersIds);<font></font>
   peersIds = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
   <span class="hljs-keyword">for</span> (AnswerVoteDTO answer : answers) {
       <span class="hljs-comment">//3</span>
       <span class="hljs-keyword">if</span> (answer.getStatusCode().equals(OK)) {
           <span class="hljs-comment">//4</span>
           <span class="hljs-keyword">if</span> (answer.getTerm()&gt;context.getCurrentTerm()) {<font></font>
               context.setTermGreaterThenCurrent(answer.getTerm());<font></font>
               <span class="hljs-keyword">return</span>;<font></font>
           }<font></font>
           <span class="hljs-keyword">if</span> (answer.isVoteGranted()) {
               <span class="hljs-comment">//5 </span>
               context.getPeer(answer.getId()).setVoteGranted(<span class="hljs-keyword">true</span>);<font></font>
               voteGrantedCount++;<font></font>
           } <span class="hljs-keyword">else</span>
               <span class="hljs-comment">//6 </span><font></font>
               voteRevokedCount++;<font></font>
       } <span class="hljs-keyword">else</span> {<font></font>
          peersIds.add(answer.getId());<font></font>
       }<font></font>
   }<font></font>
  <span class="hljs-comment">//7</span>
  <span class="hljs-keyword">if</span> (voteGrantedCount &gt;= context.getQuorum()) {<font></font>
       winElection(term);<font></font>
       <span class="hljs-keyword">return</span>;<font></font>
   } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (voteRevokedCount &gt;= context.getQuorum()) {<font></font>
       loseElection(term);<font></font>
       <span class="hljs-keyword">return</span>;<font></font>
   } </code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置状态为“候选”。</font><font style="vertical-align: inherit;">提高轮数并为自己投票。</font></font></li>
<li>  ,       (    ).  -  ,        ,           heartbeat                 .</li>
<li> -  ,    .    ,      ,     -. </li>
<li>       ,                            .     ,      heartbeat     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">节点投票给我们！</font><font style="vertical-align: inherit;">我们增加了为我们投票的节点数量，并确定该节点为我们投票。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们也相信不投票给我们。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果达到了法定人数，并且节点赢得了选举，我们将建立“领导者”状态。</font><font style="vertical-align: inherit;">否则，我们将成为追随者并等待。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还应注意，当节点成为领导者时，将为领导者存储的节点列表中的每个节点设置下一个索引，该索引等于领导者日志中的最后一个索引加1。从该索引开始，领导者将尝试更新跟随者日志。</font><font style="vertical-align: inherit;">实际上，领导者存储的该索引可能与追随者日志的真实索引不符，只有与追随者交换数据时才会获取实际值并进行调整。</font><font style="vertical-align: inherit;">但是需要一些</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">起点</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">winElection</span><span class="hljs-params">(Long term)</span> </span>{<font></font>
       context.setState(LEADER);<font></font>
       context.getPeers().forEach(peer -&gt;<font></font>
               peer.setNextIndex(operationsLog.getLastIndex()+<span class="hljs-number">1</span>)<font></font>
<font></font>
       );<font></font>
   }</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投票请求处理 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
投票时，每个节点都会收到来自候选人</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">形式</font></a><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">请求</font></a><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestVoteDTO</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long term; <span class="hljs-comment">//     </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer candidateId; <span class="hljs-comment">//  </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer lastLogIndex; <span class="hljs-comment">//     </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long lastLogTerm; <span class="hljs-comment">//       </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在让我们看一下</font></font><code>vote</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">课程</font><font style="vertical-align: inherit;">程序</font></font><code>ElectionServiceImpl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它处理候选人的投票请求，并返回有关其候选人担任领导职务的决定。</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/pleshakoff/raft/blob/eba5ea1984e2623702f4c299cf1b0af7a6ba0d14/server/src/main/java/com/raft/server/election/ElectionServiceImpl.java#L178 <br>
</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> AnswerVoteDTO <span class="hljs-title">vote</span><span class="hljs-params">(RequestVoteDTO dto)</span> </span>{<font></font>
   <font></font>
       <span class="hljs-keyword">boolean</span> termCheck;
       <span class="hljs-comment">//1</span>
       <span class="hljs-keyword">if</span> (dto.getTerm() &lt; context.getCurrentTerm())
           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerVoteDTO(context.getId(),context.getCurrentTerm(),<span class="hljs-keyword">false</span>);
       <span class="hljs-keyword">else</span> <span class="hljs-comment">//2</span>
       <span class="hljs-keyword">if</span> (dto.getTerm().equals(context.getCurrentTerm())) {<font></font>
           termCheck = (context.getVotedFor() == <span class="hljs-keyword">null</span>||<font></font>
                          context.getVotedFor().equals(dto.getCandidateId()));<font></font>
       }<font></font>
       <span class="hljs-keyword">else</span>
       {   <span class="hljs-comment">//3</span>
           termCheck = <span class="hljs-keyword">true</span>;<font></font>
             context.setTermGreaterThenCurrent(dto.getTerm());<font></font>
       }<font></font>
<font></font>
       <span class="hljs-comment">//4  </span>
       <span class="hljs-keyword">boolean</span> logCheck = !((operationsLog.getLastTerm() &gt; dto.getLastLogTerm()) ||<font></font>
               ((operationsLog.getLastTerm().equals(dto.getLastLogTerm())) &amp;&amp;<font></font>
                       (operationsLog.getLastIndex() &gt; dto.getLastLogIndex())));<font></font>
<font></font>
<font></font>
       <span class="hljs-keyword">boolean</span> voteGranted = termCheck&amp;&amp;logCheck;<font></font>
<font></font>
       <span class="hljs-comment">//5</span>
       <span class="hljs-keyword">if</span> (voteGranted) {<font></font>
           context.setVotedFor(dto.getCandidateId());<font></font>
       }<font></font>
       <span class="hljs-comment">//6   </span>
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerVoteDTO(context.getId(),context.getCurrentTerm(),voteGranted);<font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
收到候选人的请求后，节点会进行两项检查：检查候选人的回合和他的日志长度。</font><font style="vertical-align: inherit;">如果候选人的回合较高，并且其对数更长或相等，则该节点为其候选人投票给其节点</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果当前回合的结局大于候选人的回合，我们将拒绝，因为这是一些滞后结的请求，显然是在集群之外一段时间了，并开始选举程序，因为它没有看到现任领导人。 </font></font></li>
<li>   ,   , ,           ,        ,     ,       ;       .              —    .</li>
<li>     ,     </li>
<li> .                   ,            ,  ,        ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有了积极的结果，我们修复了该节点参加选举并为候选人投票的事实。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将结果发回考生</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，条件可以写得更短，更优雅，但是我留下了一个更“天真”的选择，以免使自己困惑，也不会使任何人感到困惑。 </font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复写 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
计时器领导者将心跳跟随者发送到所有节点以重置其投票计时器。由于领导者在他的元数据中存储了所有跟随者的最后操作的索引，因此他可以评估是否需要将操作发送到节点。如果领导者的操作日志变得比任何跟随者的日志都要长，那么他将与心跳一道，依次向他发送缺少的操作。称其为追加请求。如果大多数节点确认收到新操作，则领导者将这些操作应用于他的数据库，并增加上一次应用的操作的索引。该索引也随心跳请求一起发送给关注者。并且，如果领导者索引高于跟随者索引，那么跟随者还将对其数据库应用操作以使索引相等。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">领导者发送给跟随者的这种追加请求</font></font></a><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestAppendDTO</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long term; <span class="hljs-comment">//   </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer leaderId; <span class="hljs-comment">//   </span><font></font>
<font></font>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer prevLogIndex;<span class="hljs-comment">//   </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Long prevLogTerm;<span class="hljs-comment">//   </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer leaderCommit;<span class="hljs-comment">//      </span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Operation operation; <span class="hljs-comment">//</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在某些实现中，每个请求分批转移操作。</font><font style="vertical-align: inherit;">在当前的实现中，每个</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请求</font><font style="vertical-align: inherit;">只能发送一个操作</font><font style="vertical-align: inherit;">，该类响应心跳附加请求的发送和处理：</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/pleshakoff/raft/blob/eba5ea1984e2623702f4c299cf1b0af7a6ba0d14/server/src/main/java/com/raft/server/replication/ReplicationService.java</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ReplicationService</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendRequest</span><span class="hljs-params">()</span></span>;
   <span class="hljs-function">AnswerAppendDTO <span class="hljs-title">append</span><span class="hljs-params">(RequestAppendDTO requestAppendDTO)</span></span>;<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提交数据更改请求 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑一个</font></font><code>sendAppendForOnePeer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类</font></font><code>ReplicationServiceImpl</code><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个片段，</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">该方法负责产生一个请求给跟随者并发送给它</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> CompletableFuture&lt;AnswerAppendDTO&gt; <span class="hljs-title">sendAppendForOnePeer</span><span class="hljs-params">(Integer id)</span> </span>{
   <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; {
       <span class="hljs-keyword">try</span> {
           <span class="hljs-comment">//1</span><font></font>
           Peer peer = context.getPeer(id);<font></font>
<font></font>
           Operation operation;<font></font>
           Integer prevIndex;<font></font>
           <span class="hljs-comment">//2    </span>
           <span class="hljs-keyword">if</span> (peer.getNextIndex() &lt;= operationsLog.getLastIndex()) {<font></font>
               operation = operationsLog.get(peer.getNextIndex());<font></font>
               prevIndex = peer.getNextIndex() - <span class="hljs-number">1</span>;<font></font>
           } <span class="hljs-keyword">else</span> 
           <span class="hljs-comment">//3  </span><font></font>
           {<font></font>
               operation = <span class="hljs-keyword">null</span>;<font></font>
               prevIndex = operationsLog.getLastIndex();<font></font>
           }<font></font>
<font></font>
<font></font>
           RequestAppendDTO requestAppendDTO = <span class="hljs-keyword">new</span> RequestAppendDTO(<font></font>
                   context.getCurrentTerm(), <span class="hljs-comment">//   </span>
                   context.getId(), <span class="hljs-comment">//  </span>
                   prevIndex,<span class="hljs-comment">//      </span>
                   operationsLog.getTerm(prevIndex),<span class="hljs-comment">//  </span><font></font>
                   context.getCommitIndex(),<font></font>
                               <span class="hljs-comment">//      </span>
                   Operation <span class="hljs-comment">//</span><font></font>
           );<font></font>
<font></font>
...<font></font>
<span class="hljs-comment">/*   http     */</span>
}</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追随者元数据</font></font></li>
<li>   ,   .             (      ),          ,      ,  ,   .    ,       ,    ,   ,     </li>
<li>   ,    ,       ;        ,     ,       ,  </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，考虑</font></font><code>appendRequest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">方法</font></font><code>ReplicationServiceImpl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该方法负责发送附加请求并将结果处理给所有关注者。</font></font><br>
<br>
<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/pleshakoff/raft/blob/eba5ea1984e2623702f4c299cf1b0af7a6ba0d14/server/src/main/java/com/raft/server/replication/ReplicationServiceImpl.java#L109</a></code><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendRequest</span><span class="hljs-params">()</span> </span>{<font></font>
       List&lt;Integer&gt; peersIds = context.getPeers().stream().map(Peer::getId).collect(Collectors.toList());<font></font>
<font></font>
       <span class="hljs-comment">//1 </span>
       <span class="hljs-keyword">while</span> (peersIds.size() &gt; <span class="hljs-number">0</span>) {
           <span class="hljs-comment">//2 </span><font></font>
           List&lt;AnswerAppendDTO&gt; answers = sendAppendToAllPeers(peersIds);<font></font>
           peersIds = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
           <span class="hljs-keyword">for</span> (AnswerAppendDTO answer : answers) {
               <span class="hljs-comment">//3</span>
               <span class="hljs-keyword">if</span> (answer.getStatusCode().equals(OK)) {
                   <span class="hljs-comment">//4</span>
                   <span class="hljs-keyword">if</span> (answer.getTerm() &gt; context.getCurrentTerm()) {<font></font>
                        context.setTermGreaterThenCurrent(answer.getTerm());<font></font>
                       <span class="hljs-keyword">return</span>;<font></font>
                   }<font></font>
                   Peer peer = context.getPeer(answer.getId());<font></font>
                   <span class="hljs-comment">//5     </span>
                   <span class="hljs-keyword">if</span> (answer.getSuccess()) {                      <font></font>
                       peer.setNextIndex(answer.getMatchIndex() + <span class="hljs-number">1</span>);<font></font>
                       peer.setMatchIndex(answer.getMatchIndex());<font></font>
                       <span class="hljs-keyword">if</span> (peer.getNextIndex() &lt;= operationsLog.getLastIndex())<font></font>
                           peersIds.add(answer.getId());<font></font>
                   <span class="hljs-comment">//6      </span>
                   } <span class="hljs-keyword">else</span> {<font></font>
                       peer.decNextIndex();<font></font>
                       peersIds.add(answer.getId());<font></font>
                   }<font></font>
               }<font></font>
           }<font></font>
           <span class="hljs-comment">//7</span><font></font>
           tryToCommit();<font></font>
       }<font></font>
}<font></font>
</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们重复该请求，直到收到所有关注者的复制成功的响应。</font><font style="vertical-align: inherit;">由于每个请求都会发送一个操作，因此可能需要进行多次迭代才能同步关注者的日志</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向所有关注者发送请求并获取答案列表 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们仅考虑来自可用关注者的答案</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果事实证明某个跟随者的回合超过了领导者的回合，我们将停止一切并变成跟随者 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果关注者回答一切都成功，则我们将更新关注者元数据：我们将保存关注者日志的最后一个索引以及关注者期望的下一个操作的索引。 </font></font></li>
<li>  ,    ,  ,           ,           .  ,                  ,      .     ,         .    ,          .</li>
<li>        ,      .     . </li>
</ol><br>
<h3>     </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们看看</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">跟随者如何精确地处理领导者的追加请求。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
方法</font></font><code>append</code><font style="vertical-align: inherit;"></font><code>ReplicationServiceImpl</code><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> AnswerAppendDTO <span class="hljs-title">append</span><span class="hljs-params">(RequestAppendDTO dto)</span> </span>{<font></font>
     <font></font>
       <span class="hljs-comment">//1     </span>
       <span class="hljs-keyword">if</span> (dto.getTerm() &lt; context.getCurrentTerm()) {
           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerAppendDTO(context.getId(),context.getCurrentTerm(),<span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<font></font>
       } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dto.getTerm() &gt; context.getCurrentTerm()) {
           <span class="hljs-comment">//2 </span><font></font>
           context.setCurrentTerm(dto.getTerm());<font></font>
           context.setVotedFor(<span class="hljs-keyword">null</span>);<font></font>
       }<font></font>
       <span class="hljs-comment">//3  </span>
       applicationEventPublisher.publishEvent(<span class="hljs-keyword">new</span> ResetElectionTimerEvent(<span class="hljs-keyword">this</span>));<font></font>
<font></font>
       <span class="hljs-keyword">if</span> (!context.getState().equals(FOLLOWER)) {<font></font>
           context.setState(FOLLOWER);<font></font>
       }<font></font>
        <font></font>
       <span class="hljs-comment">//4  </span>
       <span class="hljs-keyword">if</span> ((dto.getPrevLogIndex() &gt; operationsLog.getLastIndex()) ||                                                                                        !dto.getPrevLogTerm().equals(operationsLog.getTerm(dto.getPrevLogIndex()))) {
                      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerAppendDTO(context.getId(), context.getCurrentTerm(), <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<font></font>
       }<font></font>
<font></font>
<font></font>
       Operation newOperation = dto.getOperation();<font></font>
       <span class="hljs-keyword">if</span> (newOperation != <span class="hljs-keyword">null</span>) {
           <span class="hljs-keyword">int</span> newOperationIndex = dto.getPrevLogIndex() + <span class="hljs-number">1</span>;<font></font>
           <font></font>
         <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {
               <span class="hljs-comment">//5</span>
               <span class="hljs-keyword">if</span> ((newOperationIndex &lt;= operationsLog.getLastIndex()) &amp;&amp;<font></font>
                      (!newOperation.getTerm().equals(operationsLog.getTerm(newOperationIndex)))){<font></font>
                   operationsLog.removeAllFromIndex(newOperationIndex);<font></font>
               }<font></font>
               <span class="hljs-comment">//6</span>
               <span class="hljs-keyword">if</span> (newOperationIndex &lt;= operationsLog.getLastIndex())<font></font>
               {<font></font>
                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerAppendDTO(context.getId(), context.getCurrentTerm(), <span class="hljs-keyword">true</span>,      operationsLog.getLastIndex());<font></font>
               }<font></font>
               <span class="hljs-comment">//7</span><font></font>
               operationsLog.append(newOperation);<font></font>
           }<font></font>
        }<font></font>
        <span class="hljs-comment">//8 </span>
        <span class="hljs-keyword">if</span> (dto.getLeaderCommit() &gt; context.getCommitIndex()) {<font></font>
           context.setCommitIndex(Math.min(dto.getLeaderCommit(), operationsLog.getLastIndex()));<font></font>
       }<font></font>
<font></font>
                 <font></font>
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AnswerAppendDTO(context.getId(), context.getCurrentTerm(), <span class="hljs-keyword">true</span>, operationsLog.getLastIndex());<font></font>
   }</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果领导者的回合少于跟随者的回合，则我们向领导发送一回合，并发出拒绝其要求的标志。</font><font style="vertical-align: inherit;">领导者收到一轮大于其回应的回合后，就会变成跟随者</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果领导者的回合大于关注者的回合，请将此回合设置为关注者。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于是从领导者那里收到请求的，所以不管那里是否有数据，我们都会重置投票计时器，如果我们不是追随者，那么我们将成为投票者 </font></font></li>
<li>   ,   ,            ,  ,   ,    ,   .        ,    ,      </li>
<li>              ,   .            .   ,     , - ,   ,      ,      ,      .             ,    .</li>
<li>  ,   .  ,    </li>
<li>  ,     </li>
<li>        ,   ,       ,    . </li>
</ol><br>
<h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仅需弄清楚领导者如何将日志中的操作应用于数据库。在将操作发送给跟随者并处理来自跟随者的响应的过程中，领导者更新节点的元数据。一旦日志中最后一个操作的索引大于领导者对数据库执行的最后一个操作的索引的节点数等于定额，我们就可以说大多数节点已接收到该操作并将其应用于领导者数据库。换句话说，如果领导者将操作发送给关注者，并且大多数人将其插入他的日志中并回答了领导者，那么我们可以将此操作应用于领导者的数据库并增加上一次应用操作的索引。具有下一个append-heartbeat请求的索引将飞向跟随者，并将</font><font style="vertical-align: inherit;">从日志</font><font style="vertical-align: inherit;">中将</font><font style="vertical-align: inherit;">具有相同索引</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的操作</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用于其数据库。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们分析</font></font><code>tryToCommit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">方法</font></font><code>ReplicationServiceImpl</code><br>
<br>
<pre><code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryToCommit</span><span class="hljs-params">()</span> </span>{
       <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
           <span class="hljs-comment">//1</span>
           <span class="hljs-keyword">int</span> N = context.getCommitIndex() + <span class="hljs-number">1</span>;
           <span class="hljs-comment">//2</span><font></font>
           Supplier&lt;Long&gt; count = () -&gt;<font></font>
               context.getPeers().stream().map(Peer::getMatchIndex).<font></font>
                       filter(matchIndex -&gt; matchIndex &gt;= N).count() + <span class="hljs-number">1</span>;<font></font>
<font></font>
           <span class="hljs-comment">//3 </span>
           <span class="hljs-keyword">if</span> (operationsLog.getLastIndex() &gt;= N &amp;&amp;<font></font>
                   operationsLog.getTerm(N).equals(context.getCurrentTerm())&amp;&amp;<font></font>
                      count.get()&gt;=context.getQuorum()<font></font>
           )<font></font>
           {<font></font>
               context.setCommitIndex(N);<font></font>
           } <span class="hljs-keyword">else</span>
               <span class="hljs-keyword">return</span>;<font></font>
       }<font></font>
   }</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们得到以下应用于数据库的操作的索引</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们计算有多少追随者在其日志中使用该索引进行操作，并且不要忘记添加领导者 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果此类关注者的数量为法定人数，并且具有此类索引的操作位于领导者的日志中，并且此操作的轮次与当前操作相等，则领导者将操作应用于数据库并增加上一次应用的操作的索引。</font><font style="vertical-align: inherit;">上一轮的操作无法应用，因为另一位领导人对此负责，可能会发生冲突。</font><font style="vertical-align: inherit;">每个领导者仅应用当前轮次的操作。</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
任何分布式算法（以该家族的代表为RAFT）都是功能强大的集成解决方案，可以保证在遵循本规范中描述的所有规则的前提下实现结果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分布式算法有很多，它们是不同的。 ZAB是在Zookeeper中实现的，例如用于在Kafka中同步数据。有些算法对一致性的要求不那么严格，例如，在AP系统中使用的Gossip协议的实现量很大。有些算法遵循RAFT原理，同时使用八卦协议交换日志，例如MOKKA，它也使用加密。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我相信尝试找出这些算法中的任何一种对任何开发人员都非常有用，并且如上所述，解决方案可能会很有趣，无论是全面的还是单独的部分。</font><font style="vertical-align: inherit;">显然，您绝对需要朝着那些与分布式系统开发以及数据同步问题相关的活动的方向看，即使他们使用标准的工业解决方案。</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仓库</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规格</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简短的介绍</font></font></a></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们希望这些材料对您有用。</font><font style="vertical-align: inherit;">而且，如果您想</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">学习一门课程</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，可以立即进行。</font></font></b></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN495342/index.html">交易中银行卡的结算-在Google Data Studio中创建一个开放的数据集和信息图</a></li>
<li><a href="../zh-CN495344/index.html">统一它：Lamoda如何使其Go服务保持一致</a></li>
<li><a href="../zh-CN495346/index.html">从错误到行动警报</a></li>
<li><a href="../zh-CN495350/index.html">家用Web服务器或您自己的托管服务提供商</a></li>
<li><a href="../zh-CN495354/index.html">如何以20种语言连续发布产品而不死？</a></li>
<li><a href="../zh-CN495360/index.html">我们如何自动将产品从C＃移植到C ++</a></li>
<li><a href="../zh-CN495362/index.html">自我隔离和编程：如何不发疯在家并有用地度过时间</a></li>
<li><a href="../zh-CN495364/index.html">API样式指南，或者不要让用户思考</a></li>
<li><a href="../zh-CN495366/index.html">16种类型的程序员或开发人员不是同一台机器人</a></li>
<li><a href="../zh-CN495368/index.html">在自我隔离的情况下，我们会自行注册自我行走的狗</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>