<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦🏽 👩🏼‍🔬 👨🏽‍🎤 使用C ++和Vulkan在一周内进行Minecraft创作 🛑 🙆 😏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我将自己的任务设定为在一周内使用自己的C ++和Vulkan引擎从头开始重新创建Minecraft。我受到Hopson的启发，他对C ++和OpenGL也做了同样的事情。反过来，他的灵感来自谢恩·贝克（Shane Beck），他的灵感来自Minecraft，灵感来源是Infiniminer，其创作大...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>使用C ++和Vulkan在一周内进行Minecraft创作</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487832/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我将自己的任务设定为在一周内使用自己的C ++和Vulkan引擎从头开始重新创建Minecraft。</font><font style="vertical-align: inherit;">我受到</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hopson的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启发</font><font style="vertical-align: inherit;">，他对C ++和OpenGL也做了同样的事情。</font><font style="vertical-align: inherit;">反过来，他的灵感来自</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谢恩·贝克</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">Shane Beck）</font></a><font style="vertical-align: inherit;">，他的灵感来自Minecraft，灵感来源是Infiniminer，其创作大概是受真实采矿启发的。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/8b2/50c/aa18b250ce4120bd3a0dc94c01a63621.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此项目的GitHub存储库</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">每天都有自己的git标签。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，我并不打算从字面上重新创建《我的世界》。</font><font style="vertical-align: inherit;">这个项目本来应该是一个教育性项目。</font><font style="vertical-align: inherit;">我想学习在比</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vulkan-tutorial.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或Sasha Willem演示</font><font style="vertical-align: inherit;">更复杂的内容中使用Vulkan的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">知识</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，主要重点是Vulkan引擎的设计，而不是游戏的设计。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任务</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Vulkan上的开发要比在OpenGL上慢得多，因此我无法将此Minecraft的许多功能集成到游戏中。</font><font style="vertical-align: inherit;">没有暴民，没有手工艺，没有红石头，没有块物理，等等。</font><font style="vertical-align: inherit;">从一开始，该项目的目标如下：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建地形渲染系统</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">捣碎</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">灯光</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建地形生成器系统</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浮雕</font></font></li>
</ul><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">树木</font></font></li>
</ul><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生物群落</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增加了改变地形和移动方块的能力</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我需要找到一种无需在游戏中添加GUI即可实现所有这些功能的方法，因为我找不到任何适用于Vulkan且易于集成的GUI库。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图书馆</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，我不会从头开始编写Vulkan应用程序。</font><font style="vertical-align: inherit;">为了加快开发过程，我将尽可能使用现成的库。</font><font style="vertical-align: inherit;">即：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VulkanWrapper-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我自己的Vulkan API的C ++包装器</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GLFW-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于Windows和用户输入</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VulkanMemoryAllocator-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于分配Vulkan内存</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GLM-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于数学向量和矩阵</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entt-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于信号/插槽和ECS</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stb-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于图像加载实用程序</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FastNoise-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">产生3D噪声</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一天</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第一天，我准备了Vulkan样板和引擎骨架。</font><font style="vertical-align: inherit;">大部分代码都是样板，我可以从</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vulkan-tutorial.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复制它</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它还包括将顶点数据存储为顶点着色器一部分的技巧。</font><font style="vertical-align: inherit;">这意味着我什至不必调整内存分配。</font><font style="vertical-align: inherit;">只是一个只能做一件事的简单传送带：画一个三角形。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该引擎非常简单，可以支持三角形的渲染器。</font><font style="vertical-align: inherit;">它具有一个窗口和一个可以连接系统的游戏循环。</font><font style="vertical-align: inherit;">GUI受窗口标题中显示的帧速率限制。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该项目分为两个部分：</font></font><code>VoxelEngine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>VoxelGame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/875/3cd/190/8753cd190975239ad550e8c0c8b27d00.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二天</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我集成了Vulkan内存分配器库。</font><font style="vertical-align: inherit;">该库负责处理大多数Vulkan内存分配样板：内存类型，设备内存堆和辅助分配。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我有了内存分配，我为网格和顶点缓冲区创建了类。</font><font style="vertical-align: inherit;">我更改了三角形的渲染器，以便它使用网格的类别，而不是着色器中内置的数组。</font><font style="vertical-align: inherit;">当前，通过手动渲染三角形将网格数据传输到GPU。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/627/28d/0fc/62728d0fce9015f2be4dad88f18c7b7a.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几乎没有改变</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三天</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我添加了图形渲染系统。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这篇文章被</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用作创建此类的基础</font><font style="vertical-align: inherit;">，但是该类非常简化。我的渲染图仅包含处理与Vulkan同步的基本要素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
渲染图允许我设置</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">节点</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">边</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。节点是GPU执行的工作。肋骨是节点之间的数据依赖关系。每个节点接收其自己的指令缓冲区，并在其中写入数据。该图参与双缓冲命令缓冲区，并将它们与先前的帧同步。边用于在节点写入每个指令缓冲区之前和之后自动插入传送带屏障。管道障碍会同步所有资源的使用，并在队列之间转移所有权。另外，边缘在节点之间插入信号量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
节点和边形成有</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向无环图</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。然后，渲染图执行</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拓扑排序。</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">节点，这将导致创建一个已排序节点的平面列表，以便每个节点都跟随它所依赖的所有节点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
引擎具有三种类型的节点。</font></font><code>AcquireNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从缓冲区链（交换链）接收图像，</font></font><code>TransferNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将数据从CPU传输到GPU，并</font></font><code>PresentNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供要显示的缓冲区链的图像。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个节点都可以实现</font></font><code>preRender</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且</font></font><code>postRender</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其在每一帧执行。</font></font><code>AcquireNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在期间获取缓冲区链的图像</font></font><code>preRender</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>PresentNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按时提供此图片</font></font><code>postRender</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我重构了三角形渲染器，以便它使用渲染图系统，而不是自己处理所有内容。</font></font><code>AcquireNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">之间有一条边</font></font><code>TriangleRenderer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间以及</font></font><code>TriangleRenderer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>PresentNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这样可以确保缓冲区链的图像在帧中使用期间正确同步。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12b/d88/6ba/12bd886ba9b41891ae1e2d0ff47b9929.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我发誓引擎里面变了</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第四天</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我创建了相机和3D渲染系统。到目前为止，摄像机收到了自己的持久缓冲区和描述符池。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那天我放慢了速度，因为我试图为Vulkan寻找3D渲染的正确配置。大多数在线资料都集中在使用OpenGL渲染上，OpenGL使用的坐标系与Vulkan略有不同。在OpenGL中，剪辑空间的Z轴指定为</font></font><code>[-1, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，屏幕的上边缘为</font></font><code>Y = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在Vulkan中，Z轴指定为</font></font><code>[0, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，屏幕的上边缘位于</font></font><code>Y = -1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。由于这些微小的差异，标准的GLM投影矩阵无法正常工作，因为它们是为OpenGL设计的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GLM有一个选择</font></font><code>GLM_FORCE_DEPTH_ZERO_TO_ONE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，消除了Z轴的问题，此后，只需更改</font></font><code>(1, 1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投影矩阵</font><font style="vertical-align: inherit;">元素的符号即可消除Y轴的问题</font><font style="vertical-align: inherit;">（GLM使用从0开始的索引）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果翻转Y轴，则需要翻转顶点数据，因为在此之前，Y轴的负方向向上。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/05d/464/8d905d4643a189400471c7e8d4fbd3f6.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在处于3D模式！</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第五天</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我添加了用户输入以及使用鼠标移动相机的功能。</font><font style="vertical-align: inherit;">输入系统过于复杂，但消除了GLFW输入的怪异之处。</font><font style="vertical-align: inherit;">特别是，我遇到了在锁定鼠标时更改鼠标位置的问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
键盘和鼠标输入本质上是通过信号处理程序打开的GLFW顶部的薄包装</font></font><code>entt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
只是为了进行比较-霍普森在项目的第一天所做的事情差不多。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的浏览器不支持HTML5视频。</font></font><source src="https://vazgriz.com/wp-content/uploads/2020/01/voxels.webm" type="video/webm"></video></div></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第六天</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我开始添加代码以生成和渲染体素块。</font><font style="vertical-align: inherit;">编写网格代码很容易，因为我以前做过，并且知道抽象使我犯了更少的错误。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其中一个抽象是模板类</font></font><code>ChunkData&lt;T, chunkSize&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它定义了一个</font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大小</font></font><code>chunkSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为每边</font><font style="vertical-align: inherit;">大小</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">多维数据集</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此类将数据存储在1D数组中，并使用3D坐标处理索引数据。</font><font style="vertical-align: inherit;">每个块的大小为16 x 16 x 16，因此内部数据是一个长度为4096的简单数组。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一种抽象方法是创建位置的迭代器，该迭代器从生成坐标</font></font><code>(0, 0, 0)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为</font></font><code>(15, 15, 15)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这两类确保以线性顺序执行具有块数据的迭代，以增加缓存的局部性。</font><font style="vertical-align: inherit;">3D坐标仍可用于需要它的其他操作。</font><font style="vertical-align: inherit;">例如：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (glm::ivec3 pos : Chunk::Positions()) {
    <span class="hljs-keyword">auto</span>&amp; data = chunkData[pos];<font></font>
    glm::ivec3 offset = ...;<font></font>
    <span class="hljs-keyword">auto</span>&amp; neighborData = chunkData[pos + offset];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我有几个静态数组指定游戏中常用的偏移量。</font><font style="vertical-align: inherit;">例如，它</font></font><code>Neighbors6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定义立方体具有共同面的6个邻居。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;glm::ivec3, 6&gt; Neighbors6 = {<font></font>
        glm::ivec3(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),    <span class="hljs-comment">//right</span>
        glm::ivec3(<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),   <span class="hljs-comment">//left</span>
        glm::ivec3(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>),    <span class="hljs-comment">//top</span>
        glm::ivec3(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>),   <span class="hljs-comment">//bottom</span>
        glm::ivec3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),    <span class="hljs-comment">//front</span>
        glm::ivec3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)    <span class="hljs-comment">//back</span>
    };</code></pre><br>
<code>Neighbors26</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这些都是立方体具有共同的面，边或顶点的邻居。</font><font style="vertical-align: inherit;">也就是说，它是一个没有中央立方体的3x3x3网格。</font><font style="vertical-align: inherit;">对于其他邻居集合和2D邻居集合，也存在类似的数组。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有一个数组定义创建多维数据集的一个面所需的数据。</font><font style="vertical-align: inherit;">此数组中每个面的方向与数组中的方向相对应</font></font><code>Neighbors6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;FaceArray, 6&gt; NeighborFaces = {
    <span class="hljs-comment">//right face</span><font></font>
    FaceArray {<font></font>
        glm::ivec3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<font></font>
        glm::ivec3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>),<font></font>
        glm::ivec3(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),<font></font>
        glm::ivec3(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<font></font>
    },<font></font>
    ...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，网格创建代码非常简单。它只是绕过块的数据，并在块为实体时添加一个面，但其邻居不是。该代码仅检查块中每个多维数据集的每个面。这类似于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述的“幼稚”方法</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (glm::ivec3 pos : Chunk::Positions()) {<font></font>
    Block block = chunk.blocks()[pos];<font></font>
    <span class="hljs-keyword">if</span> (block.type == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; Chunk::Neighbors6.size(); i++) {<font></font>
        glm::ivec3 offset = Chunk::Neighbors6[i];<font></font>
        glm::ivec3 neighborPos = pos + offset;<font></font>
<font></font>
        <span class="hljs-comment">//<span class="hljs-doctag">NOTE:</span> bounds checking omitted</span><font></font>
<font></font>
        <span class="hljs-keyword">if</span> (chunk.blocks()[neighborPos].type == <span class="hljs-number">0</span>) {<font></font>
            Chunk::FaceArray&amp; faceArray = Chunk::NeighborFaces[i];<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> j = <span class="hljs-number">0</span>; j &lt; faceArray.size(); j++) {<font></font>
                m_vertexData.push_back(pos + faceArray[j]);<font></font>
                m_colorData.push_back(glm::i8vec4(pos.x * <span class="hljs-number">16</span>, pos.y * <span class="hljs-number">16</span>, pos.z * <span class="hljs-number">16</span>, <span class="hljs-number">0</span>));<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我换成</font></font><code>TriangleRenderer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用</font></font><code>ChunkRenderer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我还添加了深度缓冲区，以便可以正确渲染块网格。有必要在</font></font><code>TransferNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">之间的渲染图上再增加一条边</font></font><code>ChunkRenderer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。此边缘在传输队列和图形队列之间转移队列系列资源的所有权。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，我更改了引擎，以便它可以正确处理窗口更改事件。在OpenGL中，这很简单，但是在Vulkan中却很混乱。由于必须明确创建缓冲区链并具有恒定的大小，因此在调整窗口大小时，需要重新创建它。您必须重新创建依赖于缓冲区链的所有资源。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有依赖于缓冲区链的命令（现在这些都是绘图命令）必须在销毁旧缓冲区链之前完成执行。</font><font style="vertical-align: inherit;">这意味着整个GPU将处于空闲状态。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您需要更改图形管道以提供动态视口并调整其大小。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果窗口在X或Y轴上的大小为0（包括最小化窗口），则无法创建缓冲链。</font><font style="vertical-align: inherit;">也就是说，发生这种情况时，整个游戏将暂停并仅在窗口打开时才继续。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，网格是一个简单的三维棋盘。</font><font style="vertical-align: inherit;">网格的RGB颜色根据其XYZ位置乘以16来设置。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的浏览器不支持HTML5视频。</font></font><source src="https://vazgriz.com/wp-content/uploads/2020/01/voxels2.webm" type="video/webm"></video></div></div></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第七天</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我使游戏过程不是一个，而是一次几个块。多个块及其网格由ECS库管理</font></font><code>entt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。然后，我重构了块渲染器，以便渲染ECS中的所有块。我仍然只有一个街区，但</font><font style="vertical-align: inherit;">如有必要</font><font style="vertical-align: inherit;">，我</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加新</font><font style="vertical-align: inherit;">街区</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我重构了网格，以便在创建之后可以更新其数据。当我添加添加和删除多维数据集的功能时，这将使我将来可以更新块网格。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
添加或删除多维数据集时，网格中的顶点数量可能会增加或减少。仅当新的网格大小相同或更小时，才可以使用先前选择的顶点缓冲区。但是，如果网格较大，则必须创建新的顶点缓冲区。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
先前的顶点缓冲区无法立即删除。可能存在从特定于特定对象的先前帧执行的指令缓冲区</font></font><code>VkBuffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。引擎必须保留一个缓冲区，直到这些命令缓冲区完成。也就是说，如果我们在框架中绘制网格</font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，GPU可以在框架开始之前使用此缓冲区</font></font><code>i + 2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在GPU使用完缓冲区之前，无法从CPU删除缓冲区。因此，我更改了渲染图，以便它跟踪资源的生存期。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果渲染图节点想要使用资源（缓冲区或图像），则它必须在方法中调用</font></font><code>sync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font><code>preRender</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。此方法获取指向</font></font><code>shared_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源</font><font style="vertical-align: inherit;">的指针</font><font style="vertical-align: inherit;">。这个</font></font><code>shared_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确保在执行命令缓冲区时不会删除资源。</font><font style="vertical-align: inherit;">（就性能而言，此解决方案不是很好。稍后将对此进行更多介绍。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，在每个帧中都重新生成块网格。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的浏览器不支持HTML5视频。</font></font><source src="https://vazgriz.com/wp-content/uploads/2020/01/voxels3.webm" type="video/webm"></video></div></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就是我一周内所做的全部工作-准备了使用多个体素块渲染世界的基础知识，并将在第二周继续工作。</font></font></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN487812/index.html">测试波兰LED光谱LED E27</a></li>
<li><a href="../zh-CN487814/index.html">速度和可靠性更高，价格更低。新的金士顿KC2000固态驱动器</a></li>
<li><a href="../zh-CN487822/index.html">AvitoTech巡回演出：下诺夫哥罗德的Android聚会</a></li>
<li><a href="../zh-CN487824/index.html">来自欧洲的Spectrum Led GU10 LED灯概述</a></li>
<li><a href="../zh-CN487826/index.html">波兰Spectrum Led E14的LED灯概述</a></li>
<li><a href="../zh-CN487834/index.html">安全周07：Android蓝牙堆栈漏洞</a></li>
<li><a href="../zh-CN487836/index.html">使用RxJS交互式将文件上传到服务器</a></li>
<li><a href="../zh-CN487838/index.html">数据验证：另一种方法</a></li>
<li><a href="../zh-CN487842/index.html">2个用于乡村路由器的SIM卡-是很多还是少一点？</a></li>
<li><a href="../zh-CN487844/index.html">闻到气味</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>