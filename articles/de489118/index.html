<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕷️ 🧑🏼‍🤝‍🧑🏼 👨🏽‍🤝‍👨🏻 Das Reverse Engineering des Renderings von The Witcher 3: verschiedene Himmelseffekte 🤑 ⛄️ 🙁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Vorherige Teile der Analyse: erster und zweiter und dritter .]
 
 Teil 1. Cirruswolken
 Wenn das Spiel auf freiem Feld stattfindet, ist der Himmel ei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Das Reverse Engineering des Renderings von The Witcher 3: verschiedene Himmelseffekte</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489118/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f2/033/d27/8f2033d27bc9d8a498716c85be1be1c0.png" alt="Bild"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Vorherige Teile der Analyse: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erster</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zweiter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dritter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .]</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 1. Cirruswolken</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Spiel auf freiem Feld stattfindet, ist der Himmel einer der Faktoren, die die Glaubwürdigkeit der Welt bestimmen. Denken Sie darüber nach - die meiste Zeit nimmt der Himmel buchstäblich 40-50% des gesamten Bildschirms ein. Der Himmel ist viel mehr als ein schönes Gefälle. Es hat Sterne, die Sonne, den Mond und schließlich Wolken. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl aktuelle Trends in der volumetrischen Darstellung von Wolken mithilfe von Raymarching zu bestehen scheinen (siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesen Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), basieren die Wolken in The Witcher 3 vollständig auf Texturen. Ich habe sie bereits zuvor untersucht, aber es stellte sich heraus, dass bei ihnen alles komplizierter ist, als ich ursprünglich erwartet hatte. Wenn Sie meiner Artikelserie gefolgt sind, wissen Sie, dass es einen Unterschied zwischen dem Blood and Wine DLC und dem Rest des Spiels gibt. Und wie Sie sich vorstellen können, gibt es einige Änderungen in der Arbeit mit Wolken im DLC.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Hexer 3 hat mehrere Wolkenschichten. Je nach Wetter können es sich nur um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zirruswolken</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hohe Cumuluswolken</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , möglicherweise einige Wolken aus der Familie der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schichtwolken handeln</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (z. B. während eines Sturms). Am Ende kann es überhaupt keine Wolken geben.</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige Ebenen unterscheiden sich hinsichtlich der Texturen und Shader, mit denen sie gerendert werden. Dies wirkt sich offensichtlich auf die Komplexität und Länge des Assembler-Codes für den Pixel-Shader aus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz all dieser Vielfalt gibt es einige gängige Muster, die beim Rendern von Wolken in Witcher 3 beobachtet werden können. Erstens werden alle in einem proaktiven Durchgang gerendert, und dies ist die perfekte Wahl. Alle verwenden Mischen (siehe unten). Dies macht es viel einfacher zu steuern, wie eine separate Ebene den Himmel bedeckt - dies wird durch den Alpha-Wert des Pixel-Shaders beeinflusst.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/aec/b8a/263aecb8afa21e2b79b0333bcde55011.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Interessanterweise werden einige Ebenen zweimal mit denselben Parametern gerendert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem ich mir den Code angesehen hatte, wählte ich den kürzesten Shader, um (1) höchstwahrscheinlich sein vollständiges Reverse Engineering durchzuführen, (2) alle seine Aspekte herauszufinden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe mir die Zirruswolken aus Witcher 3: Blut und Wein genauer angesehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein Beispielrahmen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f81/eb8/a49/f81eb8a49dc315ef04d72b582fba869b.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor dem Rendern</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/885/b27/206/885b2720624e7a455987bb6239d0e371.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem ersten Renderpass</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f2/033/d27/8f2033d27bc9d8a498716c85be1be1c0.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem zweiten Renderdurchgang</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In diesem speziellen Frame sind Zirruswolken die erste Ebene beim Rendern. </font><font style="vertical-align: inherit;">Wie Sie sehen können, wird es zweimal gerendert, wodurch die Helligkeit erhöht wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geometrischer und Vertex-Shader</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor dem Pixel-Shader werden wir kurz auf die verwendeten geometrischen und Vertex-Shader eingehen. </font><font style="vertical-align: inherit;">Das Netz zum Anzeigen von Wolken ähnelt einer normalen Himmelskuppel:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4c/774/8de/b4c7748de95ad07f2dddfc090e62e0d2.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Scheitelpunkte liegen im Intervall [0-1]. Um das Netz auf den Punkt (0,0,0) zu zentrieren, werden vor der Konvertierung in worldViewProj Skalierung und Abweichung verwendet (dieses Muster kennen wir bereits aus den vorherigen Teilen der Serie). </font><font style="vertical-align: inherit;">Bei Wolken erstreckt sich das Netz stark entlang der XY-Ebene (die Z-Achse zeigt nach oben), um mehr Raum als die Sichtbarkeitspyramide abzudecken. </font><font style="vertical-align: inherit;">Das Ergebnis ist wie folgt:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/341/0ca/95e/3410ca95ea9f0b3ef1fafe62cb5dba13.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich hat das Netz normale und tangentiale Vektoren. </font><font style="vertical-align: inherit;">Der Vertex-Shader berechnet auch den Bi-Tangenten-Vektor anhand des Vektorprodukts - alle drei werden in normalisierter Form angezeigt. </font><font style="vertical-align: inherit;">Es gibt auch eine Top-Berechnung des Nebels (Farbe und Helligkeit).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pixel Shader</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Code für die Pixel-Shader-Assembly sieht folgendermaßen aus:</font></font><br>
<br>
<pre><code class="cpp hljs"> ps_5_0  <font></font>
    dcl_globalFlags refactoringAllowed  <font></font>
    dcl_constantbuffer cb0[<span class="hljs-number">10</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb1[<span class="hljs-number">9</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb12[<span class="hljs-number">238</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb4[<span class="hljs-number">13</span>], immediateIndexed  <font></font>
    dcl_sampler s0, <span class="hljs-function">mode_default  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t0  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t1  
    dcl_input_ps linear v0.xyzw  
    dcl_input_ps linear v1.xyzw  
    dcl_input_ps linear v2.w  
    dcl_input_ps linear v3.xyzw  
    dcl_input_ps linear v4.xyz  
    dcl_input_ps linear v5.xyz  
    dcl_output o0.xyzw  
    dcl_temps 4  
   0: mul r0.xyz, cb0[9].xyzx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">-1.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
   1: dp3 r0.w, r0.xyzx, r0.xyzx  
   2: rsq r0.w, r0.w  
   3: mul r0.xyz, r0.wwww, r0.xyzx  
   4: mul r1.xy, cb0[0].xxxx, cb4[5].xyxx  
   5: mad r1.xy, v1.xyxx, cb4[4].xyxx, r1.xyxx  
   6: <span class="hljs-title">sample_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r1.xyzw, r1.xyxx, t0.xyzw, s0  
   7: add r1.xyz, r1.xyzx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-0.500000</span>, <span class="hljs-number">-0.500000</span>, <span class="hljs-number">-0.500000</span>, <span class="hljs-number">0.000000</span>)</span>  
   8: add r1.xyz, r1.xyzx, r1.xyzx  
   9: dp3 r0.w, r1.xyzx, r1.xyzx  
  10: rsq r0.w, r0.w  
  11: mul r1.xyz, r0.wwww, r1.xyzx  
  12: mul r2.xyz, r1.yyyy, v3.xyzx  
  13: mad r2.xyz, v5.xyzx, r1.xxxx, r2.xyzx  
  14: mov r3.xy, v1.zwzz  
  15: mov r3.z, v3.w  
  16: mad r1.xyz, r3.xyzx, r1.zzzz, r2.xyzx  
  17: dp3_sat r0.x, r0.xyzx, r1.xyzx  
  18: add r0.y, -cb4[2].x, cb4[3].x  
  19: mad r0.x, r0.x, r0.y, cb4[2].x  
  20: dp2 r0.y, -cb0[9].xyxx, -cb0[9].xyxx  
  21: rsq r0.y, r0.y  
  22: mul r0.yz, r0.yyyy, -cb0[9].xxyx  
  23: add r1.xyz, -v4.xyzx, cb1[8].xyzx  
  24: dp3 r0.w, r1.xyzx, r1.xyzx  
  25: rsq r1.z, r0.w  
  26: <span class="hljs-built_in">sqrt</span> r0.w, r0.w  
  27: add r0.w, r0.w, -cb4[7].x  
  28: mul r1.xy, r1.zzzz, r1.xyxx  
  29: dp2_sat r0.y, r0.yzyy, r1.xyxx  
  30: add r0.y, r0.y, r0.y  
  31: min r0.y, r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  32: add r0.z, -cb4[0].x, cb4[1].x  
  33: mad r0.z, r0.y, r0.z, cb4[0].x  
  34: mul r0.x, r0.x, r0.z  
  35: <span class="hljs-built_in">log</span> r0.x, r0.x  
  36: mul r0.x, r0.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">2.200000</span>)</span>  
  37: <span class="hljs-built_in">exp</span> r0.x, r0.x  
  38: add r1.xyz, cb12[236].xyzx, -cb12[237].xyzx  
  39: mad r1.xyz, r0.yyyy, r1.xyzx, cb12[237].xyzx  
  40: mul r2.xyz, r0.xxxx, r1.xyzx  
  41: mad r0.xyz, -r1.xyzx, r0.xxxx, v0.xyzx  
  42: mad r0.xyz, v0.wwww, r0.xyzx, r2.xyzx  
  43: add r1.x, -cb4[7].x, cb4[8].x  
  44: div_sat r0.w, r0.w, r1.x  
  45: mul r1.x, r1.w, cb4[9].x  
  46: mad r1.y, -cb4[9].x, r1.w, r1.w  
  47: mad r0.w, r0.w, r1.y, r1.x  
  48: mul r1.xy, cb0[0].xxxx, cb4[11].xyxx  
  49: mad r1.xy, v1.xyxx, cb4[10].xyxx, r1.xyxx  
  50: <span class="hljs-title">sample_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r1.x, r1.xyxx, t1.xyzw, s0  
  51: mad r1.x, r1.x, cb4[12].x, -cb4[12].x  
  52: mad_sat r1.x, cb4[12].x, v2.w, r1.x  
  53: mul r0.w, r0.w, r1.x  
  54: mul_sat r0.w, r0.w, cb4[6].x  
  55: mul o0.xyz, r0.wwww, r0.xyzx  
  56: mov o0.w, r0.w  
  57: ret </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es werden zwei nahtlose Texturen eingegeben. </font><font style="vertical-align: inherit;">Eine davon enthält eine normale Karte ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xyz-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kanäle </font><font style="vertical-align: inherit;">) und eine Wolkenform (Kanal </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Das zweite ist Rauschen, um die Form zu verzerren.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f3/c27/a5e/1f3c27a5eea1412d5fa1fa632861a342.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normale Karte, CD Projekt Red Property</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/37b/a53/d41/37ba53d412d20f476ddf71e81892b62a.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wolkenform, Immobilien-CD Projekt Rot</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05e/1bb/edd/05e1bbedded7c16acefc1f67d5b3fd49.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rauschstruktur, Eigenschaft von CD Projekt Red</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Der Hauptpuffer von Konstanten mit Cloud-Parametern ist cb4. </font><font style="vertical-align: inherit;">Für diesen Rahmen hat er folgende Bedeutung:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/229/4de/9422294de7d9ead5e2bec154eb897c7a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich werden andere Werte aus anderen Cbuffern verwendet. </font><font style="vertical-align: inherit;">Mach dir keine Sorgen, wir werden sie auch berücksichtigen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Invertiertes Sonnenlicht in Z-Richtung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste, was im Shader passiert, ist die Berechnung der normalisierten Richtung des Sonnenlichts, das entlang der Z-Achse invertiert ist:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-number">0</span>: mul r0.xyz, cb0[<span class="hljs-number">9</span>].xyzx, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">-1.000000</span>, <span class="hljs-number">0.000000</span>)  
   <span class="hljs-number">1</span>: dp3 r0.w, r0.xyzx, r0.xyzx  
   <span class="hljs-number">2</span>: rsq r0.w, r0.w  
   <span class="hljs-number">3</span>: mul r0.xyz, r0.wwww, r0.xyzx  <font></font>
<font></font>
   float3 invertedSunlightDir = normalize(lightDir * float3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>) );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits erwähnt, ist die Z-Achse nach oben gerichtet, und cb0 [9] ist die Richtung des Sonnenlichts. </font><font style="vertical-align: inherit;">Dieser Vektor ist </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf die</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sonne gerichtet - es ist wichtig! </font><font style="vertical-align: inherit;">Sie können dies überprüfen, indem Sie einen einfachen Computer-Shader schreiben, der eine einfache NdotL ausführt, und ihn in den verzögerten Shader-Durchlauf einfügen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloud Texture Sampling</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der nächste Schritt besteht darin, Texcoords zu berechnen, um die Wolkentextur abzutasten, den normalen Vektor zu entpacken und zu normalisieren.</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-number">4</span>: mul r1.xy, cb0[<span class="hljs-number">0</span>].xxxx, cb4[<span class="hljs-number">5</span>].xyxx   
   <span class="hljs-number">5</span>: mad r1.xy, v1.xyxx, cb4[<span class="hljs-number">4</span>].xyxx, r1.xyxx   
   <span class="hljs-number">6</span>: sample_indexable(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r1.xyzw, r1.xyxx, t0.xyzw, s0   
   <span class="hljs-number">7</span>: add r1.xyz, r1.xyzx, l(<span class="hljs-number">-0.500000</span>, <span class="hljs-number">-0.500000</span>, <span class="hljs-number">-0.500000</span>, <span class="hljs-number">0.000000</span>)   
   <span class="hljs-number">8</span>: add r1.xyz, r1.xyzx, r1.xyzx   
   <span class="hljs-number">9</span>: dp3 r0.w, r1.xyzx, r1.xyzx   
  <span class="hljs-number">10</span>: rsq r0.w, r0.w   <font></font>
   <font></font>
   <font></font>
   <span class="hljs-comment">// Calc sampling coords  </span><font></font>
   float2 cloudTextureUV = Texcoords * textureScale + elapsedTime * speedFactors;  <font></font>
   <font></font>
   <span class="hljs-comment">// Sample texture and get data from it  </span><font></font>
   float4 cloudTextureValue = texture0.Sample( sampler0, cloudTextureUV ).rgba;  <font></font>
   float3 normalMap = cloudTextureValue.xyz;  <font></font>
   <span class="hljs-keyword">float</span> cloudShape = cloudTextureValue.a;  <font></font>
   <font></font>
   <span class="hljs-comment">// Unpack normal and normalize it  </span>
   float3 unpackedNormal = (normalMap - <span class="hljs-number">0.5</span>) * <span class="hljs-number">2.0</span>;  <font></font>
   unpackedNormal = normalize(unpackedNormal);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns schrittweise damit umgehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Bewegung der Wolken zu erhalten, benötigen wir die verstrichene Zeit in Sekunden ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cb [0] .x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) multipliziert mit dem Geschwindigkeitskoeffizienten, der beeinflusst, wie schnell sich die Wolken über den Himmel bewegen ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cb4 [5] .xy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie ich bereits sagte, werden UV-Strahlen entlang der Geometrie der Himmelskuppel gestreckt, und wir benötigen auch Textur-Skalierungsfaktoren, die die Größe der Wolken beeinflussen ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cb4 [4] .xy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die endgültige Formel lautet:</font></font><br>
<br>
<pre><code class="cpp hljs">samplingUV = Input.TextureUV * textureScale + time * speedMultiplier;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Abtasten aller 4 Kanäle haben wir eine normale Karte (RGB-Kanäle) und eine Wolkenform (Kanal a). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So entpacken Sie die normale Karte aus dem Intervall [0; </font><font style="vertical-align: inherit;">1] im Intervall [-1; </font><font style="vertical-align: inherit;">1] Wir verwenden die folgende Formel:</font></font><br>
<br>
<pre><code class="cpp hljs">unpackedNormal = (packedNormal - <span class="hljs-number">0.5</span>) * <span class="hljs-number">2.0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können dies auch verwenden:</font></font><br>
<br>
<pre><code class="cpp hljs">unpackedNormal = packedNormal * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließlich normalisieren wir den entpackten Normalenvektor.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normalen überlagern</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit den Normalenvektoren, den Tangenten- und den Bi-Tangentenvektoren aus dem Vertex-Shader und dem Normalenvektor aus der Normalkarte bilden wir normalerweise die Normalen ab.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">11</span>: mul r1.xyz, r0.wwww, r1.xyzx  
  <span class="hljs-number">12</span>: mul r2.xyz, r1.yyyy, v3.xyzx  
  <span class="hljs-number">13</span>: mad r2.xyz, v5.xyzx, r1.xxxx, r2.xyzx  
  <span class="hljs-number">14</span>: mov r3.xy, v1.zwzz  
  <span class="hljs-number">15</span>: mov r3.z, v3.w  
  <span class="hljs-number">16</span>: mad r1.xyz, r3.xyzx, r1.zzzz, r2.xyzx  <font></font>
    <font></font>
   <span class="hljs-comment">// Perform bump mapping  </span><font></font>
   float3 SkyTangent = Input.Tangent;  <font></font>
   float3 SkyNormal = (float3( Input.Texcoords.zw, Input.param3.w ));  <font></font>
   float3 SkyBitangent = Input.param3.xyz;  <font></font>
        <font></font>
   float3x3 TBN = float3x3(SkyTangent, SkyBitangent, SkyNormal);  <font></font>
   float3 finalNormal = (float3)mul( unpackedNormal, (TBN) );</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Helligkeit (1)</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im nächsten Schritt wird die NdotL-Berechnung angewendet, die sich auf die Beleuchtungsstärke eines bestimmten Pixels auswirkt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie den folgenden Assembler-Code:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">17</span>: dp3_sat r0.x, r0.xyzx, r1.xyzx  
  <span class="hljs-number">18</span>: add r0.y, -cb4[<span class="hljs-number">2</span>].x, cb4[<span class="hljs-number">3</span>].x  
  <span class="hljs-number">19</span>: mad r0.x, r0.x, r0.y, cb4[<span class="hljs-number">2</span>].x  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist die Visualisierung von NdotL auf dem fraglichen Frame:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/283/f29/1a1/283f291a18105785a51af59dbbe8905a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Skalarprodukt (mit Sättigung) wird verwendet, um zwischen minIntensity und maxIntensity zu interpolieren. </font><font style="vertical-align: inherit;">Dank dessen werden Teile der vom Sonnenlicht beleuchteten Wolken heller.</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// Calculate cosine between normal and up-inv lightdir  </span>
   <span class="hljs-keyword">float</span> NdotL = saturate( dot(invertedSunlightDir, finalNormal) );  <font></font>
   <font></font>
   <span class="hljs-comment">// Param 1, line 19, r0.x  </span>
   <span class="hljs-keyword">float</span> intensity1 = lerp( param1Min, param1Max, NdotL );</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Helligkeit (2)</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer Faktor beeinflusst die Helligkeit der Wolken. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wolken, die sich in dem Teil des Himmels befinden, in dem sich die Sonne befindet, sollten stärker hervorgehoben werden. </font><font style="vertical-align: inherit;">Dazu berechnen wir den Gradienten basierend auf der XY-Ebene. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Gradient wird verwendet, um die lineare Interpolation zwischen den Min / Max-Werten zu berechnen, ähnlich wie in Teil (1). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, theoretisch können wir darum bitten, die Wolken auf der gegenüberliegenden Seite der Sonne abzudunkeln, aber dies geschieht in diesem speziellen Rahmen nicht, da </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param2Min</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param2Max</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cb4 [0] .x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cb4 [1] .x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) auf 1.0f gesetzt sind.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">20</span>: dp2 r0.y, -cb0[<span class="hljs-number">9</span>].xyxx, -cb0[<span class="hljs-number">9</span>].xyxx  
  <span class="hljs-number">21</span>: rsq r0.y, r0.y  
  <span class="hljs-number">22</span>: mul r0.yz, r0.yyyy, -cb0[<span class="hljs-number">9</span>].xxyx  
  <span class="hljs-number">23</span>: add r1.xyz, -v4.xyzx, cb1[<span class="hljs-number">8</span>].xyzx  
  <span class="hljs-number">24</span>: dp3 r0.w, r1.xyzx, r1.xyzx  
  <span class="hljs-number">25</span>: rsq r1.z, r0.w  
  <span class="hljs-number">26</span>: <span class="hljs-built_in">sqrt</span> r0.w, r0.w  
  <span class="hljs-number">27</span>: add r0.w, r0.w, -cb4[<span class="hljs-number">7</span>].x  
  <span class="hljs-number">28</span>: mul r1.xy, r1.zzzz, r1.xyxx  
  <span class="hljs-number">29</span>: dp2_sat r0.y, r0.yzyy, r1.xyxx  
  <span class="hljs-number">30</span>: add r0.y, r0.y, r0.y  
  <span class="hljs-number">31</span>: min r0.y, r0.y, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">32</span>: add r0.z, -cb4[<span class="hljs-number">0</span>].x, cb4[<span class="hljs-number">1</span>].x  
  <span class="hljs-number">33</span>: mad r0.z, r0.y, r0.z, cb4[<span class="hljs-number">0</span>].x  
  <span class="hljs-number">34</span>: mul r0.x, r0.x, r0.z  
  <span class="hljs-number">35</span>: <span class="hljs-built_in">log</span> r0.x, r0.x  
  <span class="hljs-number">36</span>: mul r0.x, r0.x, l(<span class="hljs-number">2.200000</span>)  
  <span class="hljs-number">37</span>: <span class="hljs-built_in">exp</span> r0.x, r0.x   <font></font>
   <font></font>
   <font></font>
   <span class="hljs-comment">// Calculate normalized -lightDir.xy (20-22)  </span><font></font>
   float2 lightDirXY = normalize( -lightDir.xy );  <font></font>
   <font></font>
   <span class="hljs-comment">// Calculate world to camera  </span><font></font>
   float3 vWorldToCamera = ( CameraPos - WorldPos );  <font></font>
   <span class="hljs-keyword">float</span> worldToCamera_distance = length(vWorldToCamera);  <font></font>
        <font></font>
   <span class="hljs-comment">// normalize vector  </span><font></font>
   vWorldToCamera = normalize( vWorldToCamera );  <font></font>
        <font></font>
   <font></font>
   <span class="hljs-keyword">float</span> LdotV = saturate( dot(lightDirXY, vWorldToCamera.xy) );  
   <span class="hljs-keyword">float</span> highlightedSkySection = saturate( <span class="hljs-number">2</span>*LdotV );  
   <span class="hljs-keyword">float</span> intensity2 = lerp( param2Min, param2Max, highlightedSkySection );  <font></font>
   <font></font>
   <span class="hljs-keyword">float</span> finalIntensity = <span class="hljs-built_in">pow</span>( intensity2 *intensity1, <span class="hljs-number">2.2</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ganz am Ende multiplizieren wir beide Helligkeiten und erhöhen das Ergebnis auf eine Potenz von 2,2.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wolkenfarbe</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Berechnung der Farbe der Wolken beginnt mit dem Erhalten von zwei Werten aus den Pufferkonstanten, die die Farbe der Wolken neben der Sonne und der Wolken auf der gegenüberliegenden Seite des Himmels angeben. </font><font style="vertical-align: inherit;">Zwischen ihnen wird eine lineare Interpolation basierend auf </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hervorgehobenem</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SkySection durchgeführt </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann wird das Ergebnis mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finalIntensity</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> multipliziert </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und am Ende wird das Ergebnis mit Nebel gemischt (aus Leistungsgründen wurde es vom Vertex-Shader berechnet).</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">38</span>: add r1.xyz, cb12[<span class="hljs-number">236</span>].xyzx, -cb12[<span class="hljs-number">237</span>].xyzx  
  <span class="hljs-number">39</span>: mad r1.xyz, r0.yyyy, r1.xyzx, cb12[<span class="hljs-number">237</span>].xyzx  
  <span class="hljs-number">40</span>: mul r2.xyz, r0.xxxx, r1.xyzx  
  <span class="hljs-number">41</span>: mad r0.xyz, -r1.xyzx, r0.xxxx, v0.xyzx  
  <span class="hljs-number">42</span>: mad r0.xyz, v0.wwww, r0.xyzx, r2.xyzx  <font></font>
   <font></font>
  float3 cloudsColor = lerp( cloudsColorBack, cloudsColorFront, highlightedSunSection );  <font></font>
  cloudsColor *= finalIntensity;  <font></font>
  cloudsColor = lerp( cloudsColor, FogColor, FogAmount );</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Machen Sie Cirruswolken am Horizont besser sichtbar</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist auf dem Rahmen nicht sehr auffällig, aber tatsächlich ist diese Schicht in der Nähe des Horizonts besser sichtbar als über Geralts Kopf. </font><font style="vertical-align: inherit;">Hier erfahren Sie, wie es geht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie konnten feststellen, dass wir bei der Berechnung der zweiten Helligkeit die Länge des Vektors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">worldToCamera</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berechnet </font><i><font style="vertical-align: inherit;">haben</font></i><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">23</span>: add r1.xyz, -v4.xyzx, cb1[<span class="hljs-number">8</span>].xyzx  
  <span class="hljs-number">24</span>: dp3 r0.w, r1.xyzx, r1.xyzx  
  <span class="hljs-number">25</span>: rsq r1.z, r0.w  
  <span class="hljs-number">26</span>: <span class="hljs-built_in">sqrt</span> r0.w, r0.w</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns die folgenden Vorkommen dieser Länge im Code finden:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">26</span>: <span class="hljs-built_in">sqrt</span> r0.w, r0.w  
  <span class="hljs-number">27</span>: add r0.w, r0.w, -cb4[<span class="hljs-number">7</span>].x  <font></font>
  ...  <font></font>
  <span class="hljs-number">43</span>: add r1.x, -cb4[<span class="hljs-number">7</span>].x, cb4[<span class="hljs-number">8</span>].x  
  <span class="hljs-number">44</span>: div_sat r0.w, r0.w, r1.x</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wow, was ist los mit uns? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cb [7] .x und cb [8] .x haben die Werte 2000.0 und 7000.0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellt sich heraus, dass dies das Ergebnis der Verwendung der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linstep-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion ist </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie erhält drei Parameter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min / max</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Intervall und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Wert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies funktioniert wie folgt: Wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Intervall [ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">max</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] liegt, gibt die Funktion im Intervall [0.0 - 1.0] eine lineare Interpolation zurück. </font><font style="vertical-align: inherit;">Wenn andererseits </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> außerhalb des Bereichs liegt, gibt linstep 0.0 oder 1.0 zurück. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein einfaches Beispiel:</font></font><br>
<br>
<pre><code class="cpp hljs">linstep( <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>, <span class="hljs-number">999.0</span>) = <span class="hljs-number">0.0</span>
linstep( <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>, <span class="hljs-number">1500.0</span>) = <span class="hljs-number">0.5</span>
linstep( <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>, <span class="hljs-number">2000.0</span>) = <span class="hljs-number">1.0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, es ist dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glatten Schritt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von HLSL </font><font style="vertical-align: inherit;">ziemlich ähnlich </font><font style="vertical-align: inherit;">, außer dass in diesem Fall anstelle der hermitischen Interpolation eine lineare durchgeführt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linstep ist keine Funktion in HLSL, aber sehr nützlich. </font><font style="vertical-align: inherit;">Es lohnt sich, es in Ihrem Toolkit zu haben.</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-comment">// linstep:  </span>
 <span class="hljs-comment">//  </span>
 <span class="hljs-comment">// Returns a linear interpolation between 0 and 1 if t is in the range [min, max]   </span>
 <span class="hljs-comment">// if "v" is &lt;= min, the output is 0  </span>
 <span class="hljs-comment">// if "v" i &gt;= max, the output is 1  </span><font></font>
   <font></font>
 <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">linstep</span><span class="hljs-params">( <span class="hljs-keyword">float</span> min, <span class="hljs-keyword">float</span> max, <span class="hljs-keyword">float</span> v )</span>  
 </span>{  
   <span class="hljs-keyword">return</span> saturate( (v - min) / (max - min) );  <font></font>
 } </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kehren wir zu Hexer 3 zurück: Nachdem wir diesen Indikator berechnet und angegeben haben, wie weit ein bestimmter Teil des Himmels von Geralt entfernt ist, verwenden wir ihn, um die Helligkeit der Wolken zu schwächen:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">45</span>: mul r1.x, r1.w, cb4[<span class="hljs-number">9</span>].x  
  <span class="hljs-number">46</span>: mad r1.y, -cb4[<span class="hljs-number">9</span>].x, r1.w, r1.w  
  <span class="hljs-number">47</span>: mad r0.w, r0.w, r1.y, r1.x  <font></font>
   <font></font>
   <span class="hljs-keyword">float</span> distanceAttenuation = linstep( fadeDistanceStart, fadeDistanceEnd, worldToCamera_distance );  <font></font>
    <font></font>
   <span class="hljs-keyword">float</span> fadedCloudShape = closeCloudsHidingFactor * cloudShape;  <font></font>
   cloudShape = lerp( fadedCloudShape, cloudShape, distanceAttenuation );</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloudShape</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der .a-Kanal aus der ersten Textur, und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">closeCloudsHidingFactor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein konstanter Pufferwert, der die Sichtbarkeit der Wolken über Geralts Kopf steuert. </font><font style="vertical-align: inherit;">In allen von mir getesteten Frames war es gleich 0,0, was dem Fehlen von Wolken entspricht. </font><font style="vertical-align: inherit;">Wenn sich die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entfernungsabschwächung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1,0 nähert (die Entfernung von der Kamera zur Kuppel des Himmels nimmt zu), werden die Wolken sichtbarer.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probenahme von Rauschtexturen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berechnung der Koordinaten der Abtastrauschtextur ähnliche Berechnungen für die Textur von Wolken, außer dass Sie einen anderen Satz von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">textureScale</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speedMultiplier verwenden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich wird ein Sampler mit aktiviertem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wrap-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adressierungsmodus verwendet, um alle diese Texturen abzutasten </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">48</span>: mul r1.xy, cb0[<span class="hljs-number">0</span>].xxxx, cb4[<span class="hljs-number">11</span>].xyxx  
  <span class="hljs-number">49</span>: mad r1.xy, v1.xyxx, cb4[<span class="hljs-number">10</span>].xyxx, r1.xyxx  
  <span class="hljs-number">50</span>: sample_indexable(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r1.x, r1.xyxx, t1.xyzw, s0  <font></font>
   <font></font>
   <span class="hljs-comment">// Calc sampling coords for noise  </span><font></font>
   float2 noiseTextureUV = Texcoords * textureScaleNoise + elapsedTime * speedFactorsNoise;  <font></font>
   <font></font>
   <span class="hljs-comment">// Sample texture and get data from it  </span>
   <span class="hljs-keyword">float</span> noiseTextureValue = texture1.Sample( sampler0, noiseTextureUV ).x;</code></pre> <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles zusammenfügen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir den Rauschwert erhalten haben, müssen wir ihn mit cloudShape kombinieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hatte einige Probleme beim Verständnis dieser Zeilen, in denen param2.w (immer 1.0) und NoiseMult (Wert 5.0 aus dem konstanten Puffer) vorhanden sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie auch immer, das Wichtigste hier ist der Endwert von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generalCloudsVisibility</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der sich auf die Sichtbarkeit der Wolken auswirkt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sehen Sie sich auch den Endwert des Rauschens an. </font><font style="vertical-align: inherit;">Die Ausgabefarbe von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloudColor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird mit dem endgültigen Rauschen multipliziert, das auch an den Alphakanal ausgegeben wird.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">51</span>: mad r1.x, r1.x, cb4[<span class="hljs-number">12</span>].x, -cb4[<span class="hljs-number">12</span>].x
  <span class="hljs-number">52</span>: mad_sat r1.x, cb4[<span class="hljs-number">12</span>].x, v2.w, r1.x
  <span class="hljs-number">53</span>: mul r0.w, r0.w, r1.x
  <span class="hljs-number">54</span>: mul_sat r0.w, r0.w, cb4[<span class="hljs-number">6</span>].x
  <span class="hljs-number">55</span>: mul o0.xyz, r0.wwww, r0.xyzx
  <span class="hljs-number">56</span>: mov o0.w, r0.w
  <span class="hljs-number">57</span>: ret   <font></font>
<font></font>
   <span class="hljs-comment">// Sample noise texture and get data from it  </span>
   <span class="hljs-keyword">float</span> noiseTextureValue = texture1.Sample( sampler0, noiseTextureUV ).x;  <font></font>
   noiseTextureValue = noiseTextureValue * noiseMult - noiseMult;  <font></font>
     <font></font>
   <span class="hljs-keyword">float</span> noiseValue = saturate( noiseMult * Input.param2.w + noiseTextureValue);  <font></font>
   noiseValue *= cloudShape;  <font></font>
     <font></font>
   <span class="hljs-keyword">float</span> finalNoise = saturate( noiseValue * generalCloudsVisibility);  <font></font>
   <font></font>
   <span class="hljs-keyword">return</span> float4( cloudsColor*finalNoise, finalNoise ); </code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesamt</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Endergebnis sieht sehr glaubwürdig aus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können vergleichen. </font><font style="vertical-align: inherit;">Das erste Bild ist mein Shader, das zweite ist der Game Shader:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4cc/331/897/4cc3318976e9c1c54178683a2fee44c0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie neugierig sind, finden Sie den Shader </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 2. Nebel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nebel kann auf verschiedene Arten implementiert werden. Die Zeiten, in denen wir einen einfachen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entfernungsabhängigen Nebel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> anwenden </font><font style="vertical-align: inherit;">und ihn beseitigen konnten, waren jedoch (höchstwahrscheinlich) für immer in der Vergangenheit. Das Leben in der Welt der programmierbaren Shader hat die Tür für neue verrückte, aber vor allem physikalisch genaue und visuell realistische Lösungen geöffnet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aktuelle Trends bei der Nebelwiedergabe basieren auf Computer-Shadern (Details siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diese</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Präsentation von Bart Wronsky). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der Tatsache, dass diese Präsentation im Jahr 2014 erschien und The Witcher 3 im Jahr 2015/2016 veröffentlicht wurde, ist der Nebel im letzten Teil von Geralts Abenteuern vollständig vom Bildschirm abhängig und wird als typische Nachbearbeitung implementiert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir mit der nächsten Reverse Engineering-Sitzung beginnen, muss ich sagen, dass ich im vergangenen Jahr mindestens fünf Mal versucht habe, den Nebel von Witcher 3 herauszufinden, und jedes Mal fehlgeschlagen ist. Der Assembler-Code ist, wie Sie gleich sehen werden, ziemlich kompliziert, und dies macht das Erstellen eines lesbaren Fog-Shaders auf HLSL fast unmöglich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gelang mir jedoch, im Internet einen Nebel-Shader zu finden, der meine Aufmerksamkeit sofort auf sich zog, da er hinsichtlich der Variablennamen und der allgemeinen Reihenfolge der Anweisungen dem Nebel von The Witcher 3 ähnlich war. Dieser Shader war nicht genau der gleiche wie im Spiel, also musste ich ihn ein bisschen überarbeiten. Ich möchte sagen, dass der Hauptteil des HLSL-Codes, den Sie hier sehen, mit zwei Ausnahmen nicht von mir erstellt / analysiert wurde. Merk dir das.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist der Assembler-Code für den Pixel Fog Shader - es ist erwähnenswert, dass er für das gesamte Spiel (den Hauptteil von 2015 und beide DLCs) gleich ist:</font></font><br>
<br>
<pre><code class="cpp hljs"> ps_5_0  <font></font>
    dcl_globalFlags refactoringAllowed  <font></font>
    dcl_constantbuffer cb3[<span class="hljs-number">2</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb12[<span class="hljs-number">214</span>], <span class="hljs-function">immediateIndexed  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t0  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t1  
    <span class="hljs-title">dcl_resource_texture2d</span> <span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> t2  
    dcl_input_ps_siv v0.xy, position  
    dcl_output o0.xyzw  
    dcl_temps 7  
   0: ftou r0.xy, v0.xyxx  
   1: mov r0.zw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
   2: <span class="hljs-title">ld_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r1.x, r0.xyww, t0.xyzw  
   3: mad r1.y, r1.x, cb12[22].x, cb12[22].y  
   4: lt r1.y, r1.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
   5: if_nz r1.y  
   6:  utof r1.yz, r0.xxyx  
   7:  mul r2.xyzw, r1.zzzz, cb12[211].xyzw  
   8:  mad r2.xyzw, cb12[210].xyzw, r1.yyyy, r2.xyzw  
   9:  mad r1.xyzw, cb12[212].xyzw, r1.xxxx, r2.xyzw  
  10:  add r1.xyzw, r1.xyzw, cb12[213].xyzw  
  11:  div r1.xyz, r1.xyzx, r1.wwww  
  12:  <span class="hljs-title">ld_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r2.xyz, r0.xyww, t1.xyzw  
  13:  <span class="hljs-title">ld_indexable</span><span class="hljs-params">(texture2d)</span><span class="hljs-params">(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>)</span> r0.x, r0.xyzw, t2.xyzw  
  14:  max r0.x, r0.x, cb3[1].x  
  15:  add r0.yzw, r1.xxyz, -cb12[0].xxyz  
  16:  dp3 r1.x, r0.yzwy, r0.yzwy  
  17:  <span class="hljs-built_in">sqrt</span> r1.x, r1.x  
  18:  add r1.y, r1.x, -cb3[0].x  
  19:  add r1.zw, -cb3[0].xxxz, cb3[0].yyyw  
  20:  div_sat r1.y, r1.y, r1.z  
  21:  mad r1.y, r1.y, r1.w, cb3[0].z  
  22:  add r0.x, r0.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-1.000000</span>)</span>  
  23:  mad r0.x, r1.y, r0.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  24:  div r0.yzw, r0.yyzw, r1.xxxx  
  25:  mad r1.y, r0.w, cb12[22].z, cb12[0].z  
  26:  add r1.x, r1.x, -cb12[22].z  
  27:  max r1.x, r1.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>  
  28:  min r1.x, r1.x, cb12[42].z  
  29:  mul r1.z, r0.w, r1.x  
  30:  mul r1.w, r1.x, cb12[43].x  
  31:  mul r1.zw, r1.zzzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.062500</span>, <span class="hljs-number">0.062500</span>)</span>  
  32:  dp3 r0.y, cb12[38].xyzx, r0.yzwy  
  33:  add r0.z, r0.y, cb12[42].x  
  34:  add r0.w, cb12[42].x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  35:  div_sat r0.z, r0.z, r0.w  
  36:  add r0.w, -cb12[43].z, cb12[43].y  
  37:  mad r0.z, r0.z, r0.w, cb12[43].z  
  38:  mul r0.w, <span class="hljs-title">abs</span><span class="hljs-params">(r0.y)</span>, <span class="hljs-title">abs</span><span class="hljs-params">(r0.y)</span>  
  39:  mad_sat r2.w, r1.x, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.002000</span>)</span>, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-0.300000</span>)</span>  
  40:  mul r0.w, r0.w, r2.w  
  41:  lt r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, r0.y  
  42:  movc r3.xyz, r0.yyyy, cb12[39].xyzx, cb12[41].xyzx  
  43:  add r3.xyz, r3.xyzx, -cb12[40].xyzx  
  44:  mad r3.xyz, r0.wwww, r3.xyzx, cb12[40].xyzx  
  45:  movc r4.xyz, r0.yyyy, cb12[45].xyzx, cb12[47].xyzx  
  46:  add r4.xyz, r4.xyzx, -cb12[46].xyzx  
  47:  mad r4.xyz, r0.wwww, r4.xyzx, cb12[46].xyzx  
  48:  ge r0.y, r1.x, cb12[48].y  
  49:  if_nz r0.y  
  50:   add r0.y, r1.y, cb12[42].y  
  51:   mul r0.w, r0.z, r0.y  
  52:   mul r1.y, r0.z, r1.z  
  53:   mad r5.xyzw, r1.yyyy, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">16.000000</span>, <span class="hljs-number">15.000000</span>, <span class="hljs-number">14.000000</span>, <span class="hljs-number">13.000000</span>)</span>, r0.wwww  
  54:   max r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  55:   add r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  56:   div_sat r5.xyzw, r1.wwww, r5.xyzw  
  57:   add r5.xyzw, -r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  58:   mul r1.z, r5.y, r5.x  
  59:   mul r1.z, r5.z, r1.z  
  60:   mul r1.z, r5.w, r1.z  
  61:   mad r5.xyzw, r1.yyyy, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">12.000000</span>, <span class="hljs-number">11.000000</span>, <span class="hljs-number">10.000000</span>, <span class="hljs-number">9.000000</span>)</span>, r0.wwww  
  62:   max r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  63:   add r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  64:   div_sat r5.xyzw, r1.wwww, r5.xyzw  
  65:   add r5.xyzw, -r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  66:   mul r1.z, r1.z, r5.x  
  67:   mul r1.z, r5.y, r1.z  
  68:   mul r1.z, r5.z, r1.z  
  69:   mul r1.z, r5.w, r1.z  
  70:   mad r5.xyzw, r1.yyyy, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">8.000000</span>, <span class="hljs-number">7.000000</span>, <span class="hljs-number">6.000000</span>, <span class="hljs-number">5.000000</span>)</span>, r0.wwww  
  71:   max r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  72:   add r5.xyzw, r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  73:   div_sat r5.xyzw, r1.wwww, r5.xyzw  
  74:   add r5.xyzw, -r5.xyzw, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)</span>  
  75:   mul r1.z, r1.z, r5.x  
  76:   mul r1.z, r5.y, r1.z  
  77:   mul r1.z, r5.z, r1.z  
  78:   mul r1.z, r5.w, r1.z  
  79:   mad r5.xy, r1.yyyy, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">4.000000</span>, <span class="hljs-number">3.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>, r0.wwww  
  80:   max r5.xy, r5.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  81:   add r5.xy, r5.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  82:   div_sat r5.xy, r1.wwww, r5.xyxx  
  83:   add r5.xy, -r5.xyxx, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  84:   mul r1.z, r1.z, r5.x  
  85:   mul r1.z, r5.y, r1.z  
  86:   mad r0.w, r1.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">2.000000</span>)</span>, r0.w  
  87:   max r0.w, r0.w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>  
  88:   add r0.w, r0.w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  89:   div_sat r0.w, r1.w, r0.w  
  90:   add r0.w, -r0.w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  91:   mul r0.w, r0.w, r1.z  
  92:   mad r0.y, r0.y, r0.z, r1.y  
  93:   max r0.y, r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>  
  94:   add r0.y, r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  95:   div_sat r0.y, r1.w, r0.y  
  96:   add r0.y, -r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  97:   mad r0.y, -r0.w, r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  98:   add r0.z, r1.x, -cb12[48].y  
  99:   mul_sat r0.z, r0.z, cb12[48].z  
  100:  <span class="hljs-keyword">else</span>  
  101:   mov r0.yz, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)</span>  
  102:  endif  
  103:  <span class="hljs-built_in">log</span> r0.y, r0.y  
  104:  mul r0.w, r0.y, cb12[42].w  
  105:  <span class="hljs-built_in">exp</span> r0.w, r0.w  
  106:  mul r0.y, r0.y, cb12[48].x  
  107:  <span class="hljs-built_in">exp</span> r0.y, r0.y  
  108:  mul r0.yw, r0.yyyw, r0.zzzz  
  109:  mad_sat r1.xy, r0.wwww, cb12[189].xzxx, cb12[189].ywyy  
  110:  add r5.xyz, -r3.xyzx, cb12[188].xyzx  
  111:  mad r5.xyz, r1.xxxx, r5.xyzx, r3.xyzx  
  112:  add r0.z, cb12[188].w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-1.000000</span>)</span>  
  113:  mad r0.z, r1.y, r0.z, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  114:  mul_sat r5.w, r0.z, r0.w  
  115:  lt r0.z, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, cb12[192].x  
  116:  if_nz r0.z  
  117:   mad_sat r1.xy, r0.wwww, cb12[191].xzxx, cb12[191].ywyy  
  118:   add r6.xyz, -r3.xyzx, cb12[190].xyzx  
  119:   mad r3.xyz, r1.xxxx, r6.xyzx, r3.xyzx  
  120:   add r0.z, cb12[190].w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">-1.000000</span>)</span>  
  121:   mad r0.z, r1.y, r0.z, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  122:   mul_sat r3.w, r0.z, r0.w  
  123:   add r1.xyzw, -r5.xyzw, r3.xyzw  
  124:   mad r5.xyzw, cb12[192].xxxx, r1.xyzw, r5.xyzw  
  125:  endif  
  126:  mul r0.z, r0.x, r5.w  
  127:  mul r0.x, r0.x, r0.y  
  128:  dp3 r0.y, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0.333000</span>, <span class="hljs-number">0.555000</span>, <span class="hljs-number">0.222000</span>, <span class="hljs-number">0.000000</span>)</span>, r2.xyzx  
  129:  mad r1.xyz, r0.yyyy, r4.xyzx, -r2.xyzx  
  130:  mad r0.xyw, r0.xxxx, r1.xyxz, r2.xyxz  
  131:  add r1.xyz, -r0.xywx, r5.xyzx  
  132:  mad r0.xyz, r0.zzzz, r1.xyzx, r0.xywx  
  133: <span class="hljs-keyword">else</span>  
  134:  mov r0.xyz, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>  
  135: endif  
  136: mov o0.xyz, r0.xyzx  
  137: mov o0.w, <span class="hljs-title">l</span><span class="hljs-params">(<span class="hljs-number">1.000000</span>)</span>  
  138: ret </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ehrlich gesagt ist der Shader ziemlich lang. </font><font style="vertical-align: inherit;">Wahrscheinlich zu lang für einen effektiven Reverse Engineering-Prozess. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein Beispiel einer Sonnenuntergangsszene mit Nebel:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/375/d59/f51/375d59f5199e791efd99c218a0ea6f53.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Werfen wir einen Blick auf die Eingabe: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für Texturen haben wir einen Tiefenpuffer, Ambient Occlusion und einen HDR-Farbpuffer.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ea/24d/ff0/9ea24dff07dad409a78834272d553b29.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eingehender Tiefenpuffer</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/c8f/e3e/3e7c8fe3ee0dc58e3007f9a1bad7f877.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eingehende Umgebungsokklusion</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/748/51f/f3c/74851ff3ce8d38b77d9319329a334d4f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der eingehende HDR-Farbpuffer</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
... und das Ergebnis der Anwendung des Nebel-Shaders in dieser Szene sieht folgendermaßen aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ee/2f8/5ad/1ee2f85adc2cc870769985308b6dcc48.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HDR-Textur nach dem Auftragen von Nebel. Der</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Tiefenpuffer wird verwendet, um die Position in der Welt wiederherzustellen. Dies ist das Standardmuster für Witcher 3-Shader. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir Umgebungsokklusionsdaten haben (falls aktiviert), können wir den Nebel verdecken. Eine sehr kluge Idee, vielleicht eine offensichtliche, aber ich habe es nie so gesehen. Ich werde später auf diesen Aspekt zurückkommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Shader ermittelt zunächst, ob sich ein Pixel am Himmel befindet. Wenn das Pixel am Himmel liegt (Tiefe == 1,0), gibt der Shader Schwarz zurück. Befindet sich das Pixel in der Szene (Tiefe &lt;1,0), erstellen wir die Position in der Welt mithilfe des Tiefenpuffers (Zeilen 7-11) neu und berechnen den Nebel weiter.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Durchgang von Nebel erfolgt kurz nach dem verzögerten Beschattungsprozess. </font><font style="vertical-align: inherit;">Möglicherweise stellen Sie fest, dass einige Elemente im Zusammenhang mit dem Vorwärtslauf noch nicht verfügbar sind. </font><font style="vertical-align: inherit;">In dieser speziellen Szene wurden verzögerte Beleuchtungsvolumina angewendet, und danach haben wir Geralts Haare / Gesicht / Augen gerendert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste, was Sie über Nebel in „The Witcher 3“ wissen müssen: Es besteht aus zwei Teilen - „Farbe des Nebels“ und „Farbe der Atmosphäre“.</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FogResult</span>  
 {</span>  
    float4 paramsFog;     <span class="hljs-comment">// RGB: color, A: influence  </span>
    float4 paramsAerial;  <span class="hljs-comment">// RGB: color, A: influence  </span>
 };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für jedes Teil gibt es drei Farben: vorne, in der Mitte und hinten. </font><font style="vertical-align: inherit;">Das heißt, im konstanten Puffer befinden sich Daten wie "FogColorFront", "FogColorMiddle", "AerialColorBack" usw. ... Schauen wir uns die eingehenden Daten an:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b2/cd0/55d/0b2cd055d9f6876c57527b9934b3b6ad.png"></div><br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// *** Inputs *** //  </span><font></font>
   float3 FogSunDir = cb12_v38.xyz;  <font></font>
   float3 FogColorFront = cb12_v39.xyz;  <font></font>
   float3 FogColorMiddle = cb12_v40.xyz;  <font></font>
   float3 FogColorBack = cb12_v41.xyz;  <font></font>
     <font></font>
   float4 FogBaseParams = cb12_v42;  <font></font>
   float4 FogDensityParamsScene = cb12_v43;  <font></font>
   float4 FogDensityParamsSky = cb12_v44;  <font></font>
     <font></font>
   float3 AerialColorFront = cb12_v45.xyz;  <font></font>
   float3 AerialColorMiddle = cb12_v46.xyz;  <font></font>
   float3 AerialColorBack = cb12_v47.xyz;  <font></font>
   float4 AerialParams = cb12_v48;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir die endgültigen Farben berechnen, müssen wir die Vektoren und Skalarprodukte berechnen. </font><font style="vertical-align: inherit;">Der Shader hat Zugriff auf die Pixelposition in der Welt, die Kameraposition (cb12 [0] .xyz) und die Nebel- / Beleuchtungsrichtung (cb12 [38] .xyz). </font><font style="vertical-align: inherit;">Dies ermöglicht es uns, das Skalarprodukt des Vektors der Form und Richtung des Nebels zu berechnen.</font></font><br>
<br>
<pre><code class="cpp hljs">   float3 frag_vec = fragPosWorldSpace.xyz - customCameraPos.xyz;  
   <span class="hljs-keyword">float</span> frag_dist = length(frag_vec);  <font></font>
     <font></font>
   float3 frag_dir = frag_vec / frag_dist;  <font></font>
   <font></font>
   <span class="hljs-keyword">float</span> dot_fragDirSunDir = dot(GlobalLightDirection.xyz, frag_dir);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Mischungsgradienten zu berechnen, müssen Sie das Quadrat des absoluten Skalarprodukts verwenden und das Ergebnis erneut mit einem Parameter multiplizieren, der von der Entfernung abhängt:</font></font><br>
<br>
<pre><code class="cpp hljs">   float3 curr_col_fog;  <font></font>
   float3 curr_col_aerial;  <font></font>
   {  <font></font>
     <span class="hljs-keyword">float</span> _dot = dot_fragDirSunDir;  <font></font>
   <font></font>
     <span class="hljs-keyword">float</span> _dd = _dot;  <font></font>
     {  <font></font>
       <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> _distOffset = <span class="hljs-number">-150</span>;  
       <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> _distRange = <span class="hljs-number">500</span>;  
       <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> _mul = <span class="hljs-number">1.0</span> / _distRange;  
       <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> _bias = _distOffset * _mul;  <font></font>
   <font></font>
       _dd = <span class="hljs-built_in">abs</span>(_dd);  <font></font>
       _dd *= _dd;  <font></font>
       _dd *= saturate( frag_dist * _mul + _bias );  <font></font>
     }  <font></font>
   <font></font>
     curr_col_fog = lerp( FogColorMiddle.xyz, (_dot&gt;<span class="hljs-number">0.0f</span> ? FogColorFront.xyz : FogColorBack.xyz), _dd );  <font></font>
     curr_col_aerial = lerp( AerialColorMiddle.xyz, (_dot&gt;<span class="hljs-number">0.0f</span> ? AerialColorFront.xyz : AerialColorBack.xyz), _dd );  <font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Codeblock macht uns klar, woher diese 0,002 und -0,300 stammen. </font><font style="vertical-align: inherit;">Wie wir sehen können, ist das Skalarprodukt zwischen den Vektoren von Ansicht und Beleuchtung für die Wahl zwischen den Farben „vorne“ und „hinten“ verantwortlich. </font><font style="vertical-align: inherit;">Klug! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist eine Visualisierung des resultierenden endgültigen Gradienten (_dd).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d43/f03/ca0/d43f03ca005d504abd5cd236007f34f4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Berechnung der Wirkung der Atmosphäre / des Nebels ist jedoch viel komplizierter. Wie Sie sehen können, haben wir viel mehr Optionen als nur RGB-Farben. Dazu gehört beispielsweise die Szenendichte. Wir verwenden Raymarching (16 Schritte, und deshalb kann der Zyklus erweitert werden), um die Größe des Nebels und den Skalierungsfaktor zu bestimmen: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit einem Vektor [Kamera ---&gt; Welt] können wir alle seine Komponenten in 16 Teile unterteilen - dies ist ein Raymarching-Schritt. Wie wir unten sehen, ist nur die .z (Höhe) -Komponente ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">curr_pos_z_step</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">an den Berechnungen beteiligt </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lesen Sie </font><font style="vertical-align: inherit;">mehr über die von raymarching implementiert Nebel zum Beispiel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">float</span> fog_amount = <span class="hljs-number">1</span>;  
   <span class="hljs-keyword">float</span> fog_amount_scale = <span class="hljs-number">0</span>;  <font></font>
   [branch]  <font></font>
   <span class="hljs-keyword">if</span> ( frag_dist &gt;= AerialParams.y )  <font></font>
   {  <font></font>
     <span class="hljs-keyword">float</span> curr_pos_z_base = (customCameraPos.z + FogBaseParams.y) * density_factor;  
     <span class="hljs-keyword">float</span> curr_pos_z_step = frag_step.z * density_factor;  <font></font>
   <font></font>
     [unroll]  <font></font>
     <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i=<span class="hljs-number">16</span>; i&gt;<span class="hljs-number">0</span>; --i )  <font></font>
     {  <font></font>
       fog_amount *= <span class="hljs-number">1</span> - saturate( density_sample_scale / (<span class="hljs-number">1</span> + max( <span class="hljs-number">0.0</span>, curr_pos_z_base + (i) * curr_pos_z_step ) ) );  <font></font>
     }  <font></font>
   <font></font>
     fog_amount = <span class="hljs-number">1</span> - fog_amount;  <font></font>
     fog_amount_scale = saturate( (frag_dist - AerialParams.y) * AerialParams.z );  <font></font>
   }  <font></font>
   <font></font>
   FogResult ret;  <font></font>
   <font></font>
   ret.paramsFog = float4 ( curr_col_fog, fog_amount_scale * <span class="hljs-built_in">pow</span>( <span class="hljs-built_in">abs</span>(fog_amount), final_exp_fog ) );  <font></font>
   ret.paramsAerial = float4 ( curr_col_aerial, fog_amount_scale * <span class="hljs-built_in">pow</span>( <span class="hljs-built_in">abs</span>(fog_amount), final_exp_aerial ) );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Nebelmenge hängt offensichtlich von der Höhe ab (Komponenten .z), am Ende wird die Nebelmenge auf den Grad Nebel / Atmosphäre erhöht. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">final_exp_fog</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">final_exp_aerial</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden aus dem konstanten Puffer entnommen; </font><font style="vertical-align: inherit;">Mit ihnen können Sie steuern, wie sich die Farben von Nebel und Atmosphäre mit zunehmender Höhe auf die Welt auswirken.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nebel außer Kraft setzen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Shader, den ich gefunden habe, hatte nicht das folgende Assemblycode-Fragment:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">109</span>:  mad_sat r1.xy, r0.wwww, cb12[<span class="hljs-number">189</span>].xzxx, cb12[<span class="hljs-number">189</span>].ywyy  
  <span class="hljs-number">110</span>:  add r5.xyz, -r3.xyzx, cb12[<span class="hljs-number">188</span>].xyzx  
  <span class="hljs-number">111</span>:  mad r5.xyz, r1.xxxx, r5.xyzx, r3.xyzx  
  <span class="hljs-number">112</span>:  add r0.z, l(<span class="hljs-number">-1.000000</span>), cb12[<span class="hljs-number">188</span>].w  
  <span class="hljs-number">113</span>:  mad r0.z, r1.y, r0.z, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">114</span>:  mul_sat r5.w, r0.w, r0.z  
  <span class="hljs-number">115</span>:  lt r0.z, l(<span class="hljs-number">0.000000</span>), cb12[<span class="hljs-number">192</span>].x  
  <span class="hljs-number">116</span>:  if_nz r0.z  
  <span class="hljs-number">117</span>:   mad_sat r1.xy, r0.wwww, cb12[<span class="hljs-number">191</span>].xzxx, cb12[<span class="hljs-number">191</span>].ywyy  
  <span class="hljs-number">118</span>:   add r6.xyz, -r3.xyzx, cb12[<span class="hljs-number">190</span>].xyzx  
  <span class="hljs-number">119</span>:   mad r3.xyz, r1.xxxx, r6.xyzx, r3.xyzx  
  <span class="hljs-number">120</span>:   add r0.z, l(<span class="hljs-number">-1.000000</span>), cb12[<span class="hljs-number">190</span>].w  
  <span class="hljs-number">121</span>:   mad r0.z, r1.y, r0.z, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">122</span>:   mul_sat r3.w, r0.w, r0.z  
  <span class="hljs-number">123</span>:   add r1.xyzw, -r5.xyzw, r3.xyzw  
  <span class="hljs-number">124</span>:   mad r5.xyzw, cb12[<span class="hljs-number">192</span>].xxxx, r1.xyzw, r5.xyzw  
  <span class="hljs-number">125</span>:  endif</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem, was ich verstehen konnte, ist dies wie eine Neudefinition der Farbe und der Wirkung des Nebels: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meistens wird nur eine Neudefinition durchgeführt (cb12_v192.x ist 0.0), aber in diesem speziellen Fall beträgt der Wert ~ 0.22, also machen wir die zweite Überschreibung.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc7/2bd/1b8/cc72bd1b8cff0742cf4aad51a7e6ab3f.png"></div><br>
<pre><code class="cpp hljs"> <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> OVERRIDE_FOG  </span><font></font>
     <font></font>
   <span class="hljs-comment">// Override  </span>
   <span class="hljs-keyword">float</span> fog_influence = ret.paramsFog.w; <span class="hljs-comment">// r0.w  </span><font></font>
   <font></font>
   <span class="hljs-keyword">float</span> override1ColorScale = cb12_v189.x;  
   <span class="hljs-keyword">float</span> override1ColorBias = cb12_v189.y;  <font></font>
   float3 override1Color = cb12_v188.rgb;  <font></font>
     <font></font>
   <span class="hljs-keyword">float</span> override1InfluenceScale = cb12_v189.z;  
   <span class="hljs-keyword">float</span> override1InfluenceBias = cb12_v189.w;  
   <span class="hljs-keyword">float</span> override1Influence = cb12_v188.w;  <font></font>
     <font></font>
   <span class="hljs-keyword">float</span> override1ColorAmount = saturate(fog_influence * override1ColorScale + override1ColorBias);  
   <span class="hljs-keyword">float</span> override1InfluenceAmount = saturate(fog_influence * override1InfluenceScale + override1InfluenceBias);    <font></font>
     <font></font>
<font></font>
   float4 paramsFogOverride;  <font></font>
   paramsFogOverride.rgb = lerp(curr_col_fog, override1Color, override1ColorAmount ); <span class="hljs-comment">// ***r5.xyz   </span><font></font>
     <font></font>
   <span class="hljs-keyword">float</span> param1 = lerp(<span class="hljs-number">1.0</span>, override1Influence, override1InfluenceAmount); <span class="hljs-comment">// r0.x  </span>
   paramsFogOverride.w = saturate(param1 * fog_influence ); <span class="hljs-comment">// ** r5.w  </span><font></font>
   <font></font>
     <font></font>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> extraFogOverride = cb12_v192.x;  <font></font>
     <font></font>
   [branch]   <font></font>
   <span class="hljs-keyword">if</span> (extraFogOverride &gt; <span class="hljs-number">0.0</span>)  <font></font>
   {  <font></font>
     <span class="hljs-keyword">float</span> override2ColorScale = cb12_v191.x;  
     <span class="hljs-keyword">float</span> override2ColorBias = cb12_v191.y;  <font></font>
     float3 override2Color = cb12_v190.rgb;  <font></font>
     <font></font>
     <span class="hljs-keyword">float</span> override2InfluenceScale = cb12_v191.z;  
     <span class="hljs-keyword">float</span> override2InfluenceBias = cb12_v191.w;  
     <span class="hljs-keyword">float</span> override2Influence = cb12_v190.w;  <font></font>
       <font></font>
     <span class="hljs-keyword">float</span> override2ColorAmount = saturate(fog_influence * override2ColorScale + override2ColorBias);  
     <span class="hljs-keyword">float</span> override2InfluenceAmount = saturate(fog_influence * override2InfluenceScale + override2InfluenceBias);  <font></font>
      <font></font>
<font></font>
     float4 paramsFogOverride2;  <font></font>
     paramsFogOverride2.rgb = lerp(curr_col_fog, override2Color, override2ColorAmount); <span class="hljs-comment">// r3.xyz   </span><font></font>
           <font></font>
     <span class="hljs-keyword">float</span> ov_param1 = lerp(<span class="hljs-number">1.0</span>, override2Influence, override2InfluenceAmount); <span class="hljs-comment">// r0.z  </span>
     paramsFogOverride2.w = saturate(ov_param1 * fog_influence); <span class="hljs-comment">// r3.w  </span><font></font>
   <font></font>
     paramsFogOverride = lerp(paramsFogOverride, paramsFogOverride2, extraFogOverride);  <font></font>
   <font></font>
   }  <font></font>
   ret.paramsFog = paramsFogOverride;  <font></font>
     <font></font>
 <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist unser Endpreis ohne Neudefinition von Nebel (erstes Bild) mit einer Neudefinition (zweites Bild) und einer doppelten Neudefinition (drittes Bild, Endergebnis):</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b9/011/3c8/3b90113c8ad27f287cdb29a25a37470d.jpg"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03a/791/d39/03a791d39e2082b80e86ea8daa488a64.jpg"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/375/d59/f51/375d59f5199e791efd99c218a0ea6f53.jpg"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regulierung der Umgebungsokklusion</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Shader, den ich gefunden habe, hat auch überhaupt keine Umgebungsokklusion verwendet. </font><font style="vertical-align: inherit;">Schauen wir uns noch einmal die Textur von AO und den Code an, der uns interessiert:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/c8f/e3e/3e7c8fe3ee0dc58e3007f9a1bad7f877.jpg"></div><br>
<pre><code class="cpp hljs">  <span class="hljs-number">13</span>:  ld_indexable(texture2d)(<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>,<span class="hljs-keyword">float</span>) r0.x, r0.xyzw, t2.xyzw  
  <span class="hljs-number">14</span>:  max r0.x, r0.x, cb3[<span class="hljs-number">1</span>].x  
  <span class="hljs-number">15</span>:  add r0.yzw, r1.xxyz, -cb12[<span class="hljs-number">0</span>].xxyz  
  <span class="hljs-number">16</span>:  dp3 r1.x, r0.yzwy, r0.yzwy  
  <span class="hljs-number">17</span>:  <span class="hljs-built_in">sqrt</span> r1.x, r1.x  
  <span class="hljs-number">18</span>:  add r1.y, r1.x, -cb3[<span class="hljs-number">0</span>].x  
  <span class="hljs-number">19</span>:  add r1.zw, -cb3[<span class="hljs-number">0</span>].xxxz, cb3[<span class="hljs-number">0</span>].yyyw  
  <span class="hljs-number">20</span>:  div_sat r1.y, r1.y, r1.z  
  <span class="hljs-number">21</span>:  mad r1.y, r1.y, r1.w, cb3[<span class="hljs-number">0</span>].z  
  <span class="hljs-number">22</span>:  add r0.x, r0.x, l(<span class="hljs-number">-1.000000</span>)  
  <span class="hljs-number">23</span>:  mad r0.x, r1.y, r0.x, l(<span class="hljs-number">1.000000</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielleicht ist diese Szene nicht das beste Beispiel, weil wir die Details auf einer fernen Insel nicht sehen. </font><font style="vertical-align: inherit;">Schauen wir uns jedoch den konstanten Puffer an, mit dem der Umgebungsokklusionswert festgelegt wird:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/343/c52/af4/343c52af44338628770912801bc3b32c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir beginnen mit dem Laden von AO aus der Textur und führen dann den Befehl max aus. In dieser Szene ist cb3_v1.x sehr hoch (0,96888), was die AO sehr schwach macht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der nächste Teil des Codes berechnet den Abstand zwischen den Positionen der Kamera und den Pixeln in der Welt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich glaube, dass der Code manchmal für sich selbst spricht. Schauen wir uns also HLSL an, das den Großteil dieses Setups erledigt:</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">AdjustAmbientOcclusion</span><span class="hljs-params">(in <span class="hljs-keyword">float</span> inputAO, in <span class="hljs-keyword">float</span> worldToCameraDistance)</span>  
 </span>{  
   <span class="hljs-comment">// *** Inputs *** //  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> aoDistanceStart = cb3_v0.x;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> aoDistanceEnd = cb3_v0.y;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> aoStrengthStart = cb3_v0.z;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> aoStrengthEnd = cb3_v0.w;  <font></font>
      <font></font>
   <span class="hljs-comment">// * Adjust AO  </span>
   <span class="hljs-keyword">float</span> aoDistanceIntensity = linstep( aoDistanceStart, aoDistanceEnd, worldToCameraDistance );  
   <span class="hljs-keyword">float</span> aoStrength = lerp(aoStrengthStart, aoStrengthEnd, aoDistanceIntensity);   
   <span class="hljs-keyword">float</span> adjustedAO = lerp(<span class="hljs-number">1.0</span>, inputAO, aoStrength);  <font></font>
     <font></font>
   <span class="hljs-keyword">return</span> adjustedAO;   <font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der berechnete Abstand zwischen Kamera und Welt wird für die Linstep-Funktion verwendet. </font><font style="vertical-align: inherit;">Wir kennen diese Funktion bereits, sie erschien im Cirrus Cloud Shader. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, haben wir im konstanten Puffer die AO-Start- / Endabstandswerte. </font><font style="vertical-align: inherit;">Die Ausgabe von linstep beeinflusst die Stärke des AO (sowie von cbuffer), und die Stärke beeinflusst die Ausgabe des AO. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein kurzes Beispiel: Das Pixel ist weit entfernt, der Abstand beträgt beispielsweise 500. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
linstep gibt 1,0 zurück; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aoStrength ist gleich aoStrengthEnd; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies führt zu einer AO-Rückgabe, die ungefähr 77% (Endkraft) des Eingabewerts beträgt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der eingehende AO für diese Funktion wurde zuvor der Maximaloperation unterzogen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles zusammenfügen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem Sie die Farbe und den Effekt für die Farbe des Nebels und die Farbe der Atmosphäre erhalten haben, können Sie sie endlich kombinieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir beginnen damit, den Effekt mit dem resultierenden AO abzuschwächen:</font></font><br>
<br>
<pre><code class="cpp hljs">   ...<font></font>
   FogResult fog = CalculateFog( worldPos, CameraPosition, fogStart, ao, <span class="hljs-literal">false</span> );  <font></font>
      <font></font>
   <span class="hljs-comment">// Apply AO to influence  </span><font></font>
   fog.paramsFog.w *= ao;  <font></font>
   fog.paramsAerial.w *= ao; <font></font>
      <font></font>
   <span class="hljs-comment">// Mix fog with scene color  </span>
   outColor = ApplyFog(fog, colorHDR);</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ganze Magie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geschieht</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der </font><b><font style="vertical-align: inherit;">ApplyFog-</font></b><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-function">float3 <span class="hljs-title">ApplyFog</span><span class="hljs-params">(FogResult fog, float3 color)</span>  
 </span>{  
   <span class="hljs-keyword">const</span> float3 LuminanceFactors = float3(<span class="hljs-number">0.333f</span>, <span class="hljs-number">0.555f</span>, <span class="hljs-number">0.222f</span>);  <font></font>
   <font></font>
   float3 aerialColor = dot(LuminanceFactors, color) * fog.paramsAerial.xyz;  <font></font>
   color = lerp(color, aerialColor, fog.paramsAerial.w);  <font></font>
   color = lerp(color, fog.paramsFog.xyz, fog.paramsFog.w);  <font></font>
    <font></font>
   <span class="hljs-keyword">return</span> color.xyz;  <font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst berechnen wir die Leuchtkraft von Pixeln:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6bd/b00/570/6bdb005708a11953aeb8ce711a942f0d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann multiplizieren wir es mit der Farbe der Atmosphäre:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7d/f89/f04/e7df89f04524c4e547a91a645317a387.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann kombinieren wir die HDR-Farbe mit der Farbe der Atmosphäre:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cae/40a/912/cae40a9124b33e97aa38ac5b72b9a5ae.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der letzte Schritt besteht darin, das Zwischenergebnis mit der Farbe des Nebels zu kombinieren:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ee/2f8/5ad/1ee2f85adc2cc870769985308b6dcc48.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige Debugging-Screenshots</font></font></h4><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/012/b08/e69/012b08e69615702c9267f24f167dfa98.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atmosphärischer Effekt</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1b/c3a/f2c/b1bc3af2c5d59db606570a54e861659b.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atmosphärenfarbe</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d10/b17/0ab/d10b170ab255b3ff9b4d6fad60e1c1e3.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nebeleffekt</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d76/9ae/dde/d769aedde1917ab6024e524d9c99625d.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nebelfarbe</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ad/b15/0dd/7adb150dddf4df73c8dc75e51aa9e138.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertige Szene ohne Nebel</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/fdc/507/f53fdc5076e000acb24a775ba7558e8a.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertige Szene nur mit Nebel</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad1/223/e4a/ad1223e4aabc3dc3f07a77125b54211f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die fertige Szene ist nur der Hauptnebel</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/375/d59/f51/375d59f5199e791efd99c218a0ea6f53.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wieder eine fertige Szene mit all dem Nebel zum leichteren Vergleich</font></font></i><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesamt</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich denke, Sie können viel von dem oben genannten verstehen, wenn Sie sich den Shader ansehen, ist er </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich kann mit Vergnügen sagen, dass dieser Shader </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genau</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der gleiche ist wie der ursprüngliche - es macht mich sehr glücklich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen hängt das Endergebnis stark von den an den Shader übergebenen Werten ab. Dies ist keine „magische“ Lösung, die perfekte Farben für die Ausgabe liefert. Es sind viele Iterationen und Künstler erforderlich, damit das Endergebnis anständig aussieht. Ich denke, es kann ein langer Prozess sein, aber nachdem Sie ihn abgeschlossen haben, wird das Ergebnis sehr überzeugend sein, genau wie diese Sonnenuntergangsszene.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Witcher 3 Sky Shader verwendet auch Nebelberechnungen, um einen reibungslosen Farbübergang in der Nähe des Horizonts zu erzielen. </font><font style="vertical-align: inherit;">Ein anderer Satz von Dichtekoeffizienten wird jedoch an den Sky Shader übergeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich möchte Sie daran erinnern, dass der größte Teil dieses Shaders nicht von mir erstellt / analysiert wurde. </font><font style="vertical-align: inherit;">Alle Bestätigungen sollten an CD PROJEKT RED gesendet werden. </font><font style="vertical-align: inherit;">Unterstützen Sie sie, sie machen einen exzellenten Job.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 3. Sternschnuppen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In The Witcher 3 gibt es ein kleines, aber merkwürdiges Detail - Sternschnuppen. </font><font style="vertical-align: inherit;">Interessanterweise scheinen sie nicht im Blood and Wine DLC zu sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Video können Sie sehen, wie sie aussehen:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/IWtutrr6ilE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie wir diesen Effekt erzielt haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, ist der Körper eines Sternschnuppen viel heller als der Schwanz. </font><font style="vertical-align: inherit;">Dies ist eine wichtige Eigenschaft, die wir später verwenden werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unsere Agenda ist ziemlich vertraut: Zuerst werde ich die allgemeinen Eigenschaften beschreiben, dann werde ich über Themen im Zusammenhang mit Geometrie sprechen, und am Ende werden wir zum Pixel-Shader übergehen, wo die interessantesten Dinge passieren.</font></font><br>
<cut></cut><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Allgemeiner Überblick</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beschreiben Sie kurz, was passiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sternschnuppen werden in einer proaktiven Passage unmittelbar nach der Kuppel von Himmel, Himmel und Mond gezeichnet:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c5/a71/7db/1c5a717dbd047aeaa183ce2a25e394d9.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexed (720) - die Kuppel des Himmels, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexed (2160) - die Kugel für Himmel / Mond, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexed (36) - ist irrelevant, sieht aus wie ein Parallelepiped der Okklusion der Sonne (?) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexed (12) - der Sternschnuppe </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DrawIndexedInstanced (1116, 1) - Zirruswolken </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zirruswolken</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird jeder Sternschnuppen zweimal hintereinander gezeichnet.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/baa/27d/e4c/baa27de4ced017770e9c89a01e136abd.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor dem ersten Draw Call</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc8/78b/cef/cc878bcef6dcc4b58e85f3a62f90be31.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnis des ersten Draw Calls</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ee/33f/f6c/0ee33ff6cef3d11ca7cd460f21dc2b3f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnis des zweiten Draw Calls</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Zusätzlich wird, wie in vielen Elementen des präventiven Passes dieses Spiels, der folgende Mischungszustand verwendet:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/aec/b8a/263aecb8afa21e2b79b0333bcde55011.jpg"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Geometrie</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Bezug auf die Geometrie ist zunächst zu erwähnen, dass jeder Sternschnuppen durch ein dünnes Quad mit Texkoordinaten dargestellt wird: 4 Eckpunkte, 6 Indizes. </font><font style="vertical-align: inherit;">Dies ist das einfachste Quad, das möglich ist.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82c/fbf/96b/82cfbf96bbc652ea5ac32a5e568434a3.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ungefähres Quad eines Shooting Stars. </font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/83c/59e/3f7/83c59e3f7e685d6e7f2080e88ff5be25.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Noch näher ist das ungefähre Quad eines Shooting Stars. </font><font style="vertical-align: inherit;">Sie können das Drahtmodell der Linie sehen, die zwei Dreiecke kennzeichnet. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warte eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minute</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aber es gibt </font><i><font style="vertical-align: inherit;">DrawIndexed (12)</font></i><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">Bedeutet das, dass wir zwei Sternschnuppen gleichzeitig zeichnen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ja.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d55/b39/bb2/d55b39bb2d2ea5908f4576d6396455fa.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Rahmen befindet sich einer der Sternschnuppen vollständig außerhalb der Sichtbarkeitspyramide. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns den Assembler-Code für den Vertex-Shader an:</font></font><br>
<br>
<pre><code class="cpp hljs"> vs_5_0  <font></font>
    dcl_globalFlags refactoringAllowed  <font></font>
    dcl_constantbuffer cb1[<span class="hljs-number">9</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb2[<span class="hljs-number">3</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb12[<span class="hljs-number">193</span>], immediateIndexed  <font></font>
    dcl_input v0.xyz  <font></font>
    dcl_input v1.xyzw  <font></font>
    dcl_input v2.xy  <font></font>
    dcl_input v3.xy  <font></font>
    dcl_input v4.xy  <font></font>
    dcl_input v5.xyz  <font></font>
    dcl_input v6.x  <font></font>
    dcl_input v7.x  <font></font>
    dcl_output o0.xyzw  <font></font>
    dcl_output o1.xyzw  <font></font>
    dcl_output o2.xy  <font></font>
    dcl_output o3.xyzw  <font></font>
    dcl_output_siv o4.xyzw, position  <font></font>
    dcl_temps <span class="hljs-number">5</span>  
   <span class="hljs-number">0</span>: mov r0.xyz, v0.xyzx  
   <span class="hljs-number">1</span>: mov r0.w, l(<span class="hljs-number">1.000000</span>)  
   <span class="hljs-number">2</span>: dp4 r1.x, r0.xyzw, cb2[<span class="hljs-number">0</span>].xyzw  
   <span class="hljs-number">3</span>: dp4 r1.y, r0.xyzw, cb2[<span class="hljs-number">1</span>].xyzw  
   <span class="hljs-number">4</span>: dp4 r1.z, r0.xyzw, cb2[<span class="hljs-number">2</span>].xyzw  
   <span class="hljs-number">5</span>: add r0.x, v2.x, v2.y  
   <span class="hljs-number">6</span>: add r0.y, -v2.y, v2.x  
   <span class="hljs-number">7</span>: add r2.xyz, -r1.zxyz, cb1[<span class="hljs-number">8</span>].zxyz  
   <span class="hljs-number">8</span>: dp3 r0.z, r2.xyzx, r2.xyzx  
   <span class="hljs-number">9</span>: rsq r0.z, r0.z  
  <span class="hljs-number">10</span>: mul r2.xyz, r0.zzzz, r2.xyzx  
  <span class="hljs-number">11</span>: dp3 r0.z, v5.xyzx, v5.xyzx  
  <span class="hljs-number">12</span>: rsq r0.z, r0.z  
  <span class="hljs-number">13</span>: mul r3.xyz, r0.zzzz, v5.xyzx  
  <span class="hljs-number">14</span>: mul r4.xyz, r2.xyzx, r3.yzxy  
  <span class="hljs-number">15</span>: mad r2.xyz, r2.zxyz, r3.zxyz, -r4.xyzx  
  <span class="hljs-number">16</span>: dp3 r0.z, r2.xyzx, r2.xyzx  
  <span class="hljs-number">17</span>: rsq r0.z, r0.z  
  <span class="hljs-number">18</span>: mul r2.xyz, r0.zzzz, r2.xyzx  
  <span class="hljs-number">19</span>: mad r0.z, v7.x, v6.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">20</span>: mul r3.xyz, r0.zzzz, r3.xyzx  
  <span class="hljs-number">21</span>: mul r3.xyz, r3.xyzx, v3.xxxx  
  <span class="hljs-number">22</span>: mul r2.xyz, r2.xyzx, v3.yyyy  
  <span class="hljs-number">23</span>: mad r0.xzw, r3.xxyz, r0.xxxx, r1.xxyz  
  <span class="hljs-number">24</span>: mad r0.xyz, r2.xyzx, r0.yyyy, r0.xzwx  
  <span class="hljs-number">25</span>: mov r0.w, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">26</span>: dp4 o4.x, r0.xyzw, cb1[<span class="hljs-number">0</span>].xyzw  
  <span class="hljs-number">27</span>: dp4 o4.y, r0.xyzw, cb1[<span class="hljs-number">1</span>].xyzw  
  <span class="hljs-number">28</span>: dp4 o4.z, r0.xyzw, cb1[<span class="hljs-number">2</span>].xyzw  
  <span class="hljs-number">29</span>: dp4 o4.w, r0.xyzw, cb1[<span class="hljs-number">3</span>].xyzw  
  <span class="hljs-number">30</span>: add r0.xyz, r0.xyzx, -cb12[<span class="hljs-number">0</span>].xyzx  
  <span class="hljs-number">31</span>: dp3 r0.w, r0.xyzx, r0.xyzx  
  <span class="hljs-number">32</span>: <span class="hljs-built_in">sqrt</span> r0.w, r0.w  
  <span class="hljs-number">33</span>: div r0.xyz, r0.xyzx, r0.wwww  
  <span class="hljs-number">34</span>: add r0.w, r0.w, -cb12[<span class="hljs-number">22</span>].z  
  <span class="hljs-number">35</span>: max r0.w, r0.w, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">36</span>: min r0.w, r0.w, cb12[<span class="hljs-number">42</span>].z  
  <span class="hljs-number">37</span>: dp3 r0.x, cb12[<span class="hljs-number">38</span>].xyzx, r0.xyzx  
  <span class="hljs-number">38</span>: mul r0.y, <span class="hljs-built_in">abs</span>(r0.x), <span class="hljs-built_in">abs</span>(r0.x)  
  <span class="hljs-number">39</span>: mad_sat r1.x, r0.w, l(<span class="hljs-number">0.002000</span>), l(<span class="hljs-number">-0.300000</span>)  
  <span class="hljs-number">40</span>: mul r0.y, r0.y, r1.x  
  <span class="hljs-number">41</span>: lt r1.x, l(<span class="hljs-number">0</span>), r0.x  
  <span class="hljs-number">42</span>: movc r1.yzw, r1.xxxx, cb12[<span class="hljs-number">39</span>].xxyz, cb12[<span class="hljs-number">41</span>].xxyz  
  <span class="hljs-number">43</span>: add r1.yzw, r1.yyzw, -cb12[<span class="hljs-number">40</span>].xxyz  
  <span class="hljs-number">44</span>: mad r1.yzw, r0.yyyy, r1.yyzw, cb12[<span class="hljs-number">40</span>].xxyz  
  <span class="hljs-number">45</span>: movc r2.xyz, r1.xxxx, cb12[<span class="hljs-number">45</span>].xyzx, cb12[<span class="hljs-number">47</span>].xyzx  
  <span class="hljs-number">46</span>: add r2.xyz, r2.xyzx, -cb12[<span class="hljs-number">46</span>].xyzx  
  <span class="hljs-number">47</span>: mad o0.xyz, r0.yyyy, r2.xyzx, cb12[<span class="hljs-number">46</span>].xyzx  
  <span class="hljs-number">48</span>: ge r0.y, r0.w, cb12[<span class="hljs-number">48</span>].y  
  <span class="hljs-number">49</span>: if_nz r0.y  
  <span class="hljs-number">50</span>:  mad r0.y, r0.z, cb12[<span class="hljs-number">22</span>].z, cb12[<span class="hljs-number">0</span>].z  
  <span class="hljs-number">51</span>:  mul r0.z, r0.w, r0.z  
  <span class="hljs-number">52</span>:  mul r0.z, r0.z, l(<span class="hljs-number">0.062500</span>)  
  <span class="hljs-number">53</span>:  mul r1.x, r0.w, cb12[<span class="hljs-number">43</span>].x  
  <span class="hljs-number">54</span>:  mul r1.x, r1.x, l(<span class="hljs-number">0.062500</span>)  
  <span class="hljs-number">55</span>:  add r0.x, r0.x, cb12[<span class="hljs-number">42</span>].x  
  <span class="hljs-number">56</span>:  add r2.x, cb12[<span class="hljs-number">42</span>].x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">57</span>:  div_sat r0.x, r0.x, r2.x  
  <span class="hljs-number">58</span>:  add r2.x, -cb12[<span class="hljs-number">43</span>].z, cb12[<span class="hljs-number">43</span>].y  
  <span class="hljs-number">59</span>:  mad r0.x, r0.x, r2.x, cb12[<span class="hljs-number">43</span>].z  
  <span class="hljs-number">60</span>:  add r0.y, r0.y, cb12[<span class="hljs-number">42</span>].y  
  <span class="hljs-number">61</span>:  mul r2.x, r0.x, r0.y  
  <span class="hljs-number">62</span>:  mul r0.z, r0.x, r0.z  
  <span class="hljs-number">63</span>:  mad r3.xyzw, r0.zzzz, l(<span class="hljs-number">16.000000</span>, <span class="hljs-number">15.000000</span>, <span class="hljs-number">14.000000</span>, <span class="hljs-number">13.000000</span>), r2.xxxx  
  <span class="hljs-number">64</span>:  max r3.xyzw, r3.xyzw, l(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  
  <span class="hljs-number">65</span>:  add r3.xyzw, r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">66</span>:  div_sat r3.xyzw, r1.xxxx, r3.xyzw  
  <span class="hljs-number">67</span>:  add r3.xyzw, -r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">68</span>:  mul r2.y, r3.y, r3.x  
  <span class="hljs-number">69</span>:  mul r2.y, r3.z, r2.y  
  <span class="hljs-number">70</span>:  mul r2.y, r3.w, r2.y  
  <span class="hljs-number">71</span>:  mad r3.xyzw, r0.zzzz, l(<span class="hljs-number">12.000000</span>, <span class="hljs-number">11.000000</span>, <span class="hljs-number">10.000000</span>, <span class="hljs-number">9.000000</span>), r2.xxxx  
  <span class="hljs-number">72</span>:  max r3.xyzw, r3.xyzw, l(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  
  <span class="hljs-number">73</span>:  add r3.xyzw, r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">74</span>:  div_sat r3.xyzw, r1.xxxx, r3.xyzw  
  <span class="hljs-number">75</span>:  add r3.xyzw, -r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">76</span>:  mul r2.y, r2.y, r3.x  
  <span class="hljs-number">77</span>:  mul r2.y, r3.y, r2.y  
  <span class="hljs-number">78</span>:  mul r2.y, r3.z, r2.y  
  <span class="hljs-number">79</span>:  mul r2.y, r3.w, r2.y  
  <span class="hljs-number">80</span>:  mad r3.xyzw, r0.zzzz, l(<span class="hljs-number">8.000000</span>, <span class="hljs-number">7.000000</span>, <span class="hljs-number">6.000000</span>, <span class="hljs-number">5.000000</span>), r2.xxxx  
  <span class="hljs-number">81</span>:  max r3.xyzw, r3.xyzw, l(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  
  <span class="hljs-number">82</span>:  add r3.xyzw, r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">83</span>:  div_sat r3.xyzw, r1.xxxx, r3.xyzw  
  <span class="hljs-number">84</span>:  add r3.xyzw, -r3.xyzw, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">85</span>:  mul r2.y, r2.y, r3.x  
  <span class="hljs-number">86</span>:  mul r2.y, r3.y, r2.y  
  <span class="hljs-number">87</span>:  mul r2.y, r3.z, r2.y  
  <span class="hljs-number">88</span>:  mul r2.y, r3.w, r2.y  
  <span class="hljs-number">89</span>:  mad r2.zw, r0.zzzz, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">4.000000</span>, <span class="hljs-number">3.000000</span>), r2.xxxx  
  <span class="hljs-number">90</span>:  max r2.zw, r2.zzzw, l(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)  
  <span class="hljs-number">91</span>:  add r2.zw, r2.zzzw, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">92</span>:  div_sat r2.zw, r1.xxxx, r2.zzzw  
  <span class="hljs-number">93</span>:  add r2.zw, -r2.zzzw, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">1.000000</span>, <span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">94</span>:  mul r2.y, r2.z, r2.y  
  <span class="hljs-number">95</span>:  mul r2.y, r2.w, r2.y  
  <span class="hljs-number">96</span>:  mad r2.x, r0.z, l(<span class="hljs-number">2.000000</span>), r2.x  
  <span class="hljs-number">97</span>:  max r2.x, r2.x, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">98</span>:  add r2.x, r2.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">99</span>:  div_sat r2.x, r1.x, r2.x  
  <span class="hljs-number">100</span>:  add r2.x, -r2.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">101</span>:  mul r2.x, r2.x, r2.y  
  <span class="hljs-number">102</span>:  mad r0.x, r0.y, r0.x, r0.z  
  <span class="hljs-number">103</span>:  max r0.x, r0.x, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">104</span>:  add r0.x, r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">105</span>:  div_sat r0.x, r1.x, r0.x  
  <span class="hljs-number">106</span>:  add r0.x, -r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">107</span>:  mad r0.x, -r2.x, r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">108</span>:  add r0.y, r0.w, -cb12[<span class="hljs-number">48</span>].y  
  <span class="hljs-number">109</span>:  mul_sat r0.y, r0.y, cb12[<span class="hljs-number">48</span>].z  
  <span class="hljs-number">110</span>: <span class="hljs-keyword">else</span>  
  <span class="hljs-number">111</span>:  mov r0.xy, l(<span class="hljs-number">1.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">112</span>: endif  
  <span class="hljs-number">113</span>: <span class="hljs-built_in">log</span> r0.x, r0.x  
  <span class="hljs-number">114</span>: mul r0.z, r0.x, cb12[<span class="hljs-number">42</span>].w  
  <span class="hljs-number">115</span>: <span class="hljs-built_in">exp</span> r0.z, r0.z  
  <span class="hljs-number">116</span>: mul r0.z, r0.z, r0.y  
  <span class="hljs-number">117</span>: mul r0.x, r0.x, cb12[<span class="hljs-number">48</span>].x  
  <span class="hljs-number">118</span>: <span class="hljs-built_in">exp</span> r0.x, r0.x  
  <span class="hljs-number">119</span>: mul o0.w, r0.x, r0.y  
  <span class="hljs-number">120</span>: mad_sat r0.xy, r0.zzzz, cb12[<span class="hljs-number">189</span>].xzxx, cb12[<span class="hljs-number">189</span>].ywyy  
  <span class="hljs-number">121</span>: add r2.xyz, -r1.yzwy, cb12[<span class="hljs-number">188</span>].xyzx  
  <span class="hljs-number">122</span>: mad r2.xyz, r0.xxxx, r2.xyzx, r1.yzwy  
  <span class="hljs-number">123</span>: add r0.x, cb12[<span class="hljs-number">188</span>].w, l(<span class="hljs-number">-1.000000</span>)  
  <span class="hljs-number">124</span>: mad r0.x, r0.y, r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">125</span>: mul_sat r2.w, r0.x, r0.z  
  <span class="hljs-number">126</span>: lt r0.x, l(<span class="hljs-number">0</span>), cb12[<span class="hljs-number">192</span>].x  
  <span class="hljs-number">127</span>: if_nz r0.x  
  <span class="hljs-number">128</span>:  mad_sat r0.xy, r0.zzzz, cb12[<span class="hljs-number">191</span>].xzxx, cb12[<span class="hljs-number">191</span>].ywyy  
  <span class="hljs-number">129</span>:  add r3.xyz, -r1.yzwy, cb12[<span class="hljs-number">190</span>].xyzx  
  <span class="hljs-number">130</span>:  mad r1.xyz, r0.xxxx, r3.xyzx, r1.yzwy  
  <span class="hljs-number">131</span>:  add r0.x, cb12[<span class="hljs-number">190</span>].w, l(<span class="hljs-number">-1.000000</span>)  
  <span class="hljs-number">132</span>:  mad r0.x, r0.y, r0.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">133</span>:  mul_sat r1.w, r0.x, r0.z  
  <span class="hljs-number">134</span>:  add r0.xyzw, -r2.xyzw, r1.xyzw  
  <span class="hljs-number">135</span>:  mad o1.xyzw, cb12[<span class="hljs-number">192</span>].xxxx, r0.xyzw, r2.xyzw  
  <span class="hljs-number">136</span>: <span class="hljs-keyword">else</span>  
  <span class="hljs-number">137</span>:  mov o1.xyzw, r2.xyzw  
  <span class="hljs-number">138</span>: endif  
  <span class="hljs-number">139</span>: mov o3.xyzw, v1.xyzw  
  <span class="hljs-number">140</span>: mov o2.xy, v4.yxyy  
  <span class="hljs-number">141</span>: ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier kann die Berechnung des Nebels sofort Aufmerksamkeit erregen (Zeilen 30-138). Die Berechnung der Nebelspitze ist aus Leistungsgründen sinnvoll. Außerdem brauchen wir keine solche Genauigkeit des Nebels - Meteoroiden fliegen normalerweise über Geralts Kopf und erreichen den Horizont nicht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die atmosphärischen Parameter (rgb = Farbe, a = Einfluss) werden in o0.xyzw und die Nebelparameter in o1.xyzw gespeichert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
o2.xy (Zeile 140) ist nur Texcoords. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
o3.xyzw (Zeile 139) ist irrelevant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns nun ein paar Worte zur Berechnung einer Position in der Welt sagen. Vertex-Shader führen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Billboarding durch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Zuallererst kommen eingehende Daten für Werbetafeln aus dem Scheitelpunktpuffer - schauen wir sie uns an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ersten Daten sind Position:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99a/470/7d5/99a4707d5f914222e7d55e2435f5692f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie oben erwähnt, haben wir hier 2 Quad-a: 8 Eckpunkte, 12 Indizes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber warum ist die Position für jedes Quad gleich? </font><font style="vertical-align: inherit;">Ganz einfach - das ist die Position der Mitte des Quad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ferner hat jeder Scheitelpunkt einen Versatz von der Mitte zum Rand des Quadrats:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cde/fdf/7e0/cdefdf7e0e5cfe91c4b9d20257b529b4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet, dass jeder Shooting Star eine Größe von (400, 3) Einheiten im Weltraum hat. </font><font style="vertical-align: inherit;">(In der XY-Ebene in Hexer 3 ist die Z-Achse nach oben gerichtet.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das letzte Element, das jeder Scheitelpunkt hat, ist ein Einheitsrichtungsvektor im Weltraum, der die Bewegung eines Sternschnuppen steuert:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/416/06d/71a/41606d71a99d2f751f8b1d5a609b6c96.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da die Daten von der CPU stammen, ist es schwierig zu verstehen, wie sie berechnet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fahren wir nun mit dem Billboarding-Code fort. </font><font style="vertical-align: inherit;">Die Idee ist ganz einfach: Zuerst erhalten Sie einen Einheitsvektor von der Mitte des Quad zur Kamera:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-number">7</span>: add r2.xyz, -r1.zxyz, cb1[<span class="hljs-number">8</span>].zxyz  
   <span class="hljs-number">8</span>: dp3 r0.z, r2.xyzx, r2.xyzx  
   <span class="hljs-number">9</span>: rsq r0.z, r0.z  
  <span class="hljs-number">10</span>: mul r2.xyz, r0.zzzz, r2.xyzx</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann erhalten wir einen einzelnen Tangentenvektor, der die Bewegung des Sternschnuppen steuert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da dieser Vektor auf der CPU-Seite bereits normalisiert ist, ist diese Normalisierung redundant.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">11</span>: dp3 r0.z, v5.xyzx, v5.xyzx  
  <span class="hljs-number">12</span>: rsq r0.z, r0.z  
  <span class="hljs-number">13</span>: mul r3.xyz, r0.zzzz, v5.xyzx</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn zwei Vektoren vorhanden sind, wird ein Vektorprodukt verwendet, um den Bi-Tangentenvektor senkrecht zu beiden eingehenden Vektoren zu bestimmen.</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">14</span>: mul r4.xyz, r2.xyzx, r3.yzxy  
  <span class="hljs-number">15</span>: mad r2.xyz, r2.zxyz, r3.zxyz, -r4.xyzx  
  <span class="hljs-number">16</span>: dp3 r0.z, r2.xyzx, r2.xyzx  
  <span class="hljs-number">17</span>: rsq r0.z, r0.z  
  <span class="hljs-number">18</span>: mul r2.xyz, r0.zzzz, r2.xyzx</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt haben wir die Vektoren </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tangente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (r3.xyz) und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitangente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (r2.xyz) normalisiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xsize</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ysize einführen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die dem eingehenden Element TEXCOORD1 entsprechen, also zum Beispiel (-200, 1,50). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die endgültige Berechnung der Position im Weltraum erfolgt wie folgt:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">19</span>: mad r0.z, v7.x, v6.x, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">20</span>: mul r3.xyz, r0.zzzz, r3.xyzx  
  <span class="hljs-number">21</span>: mul r3.xyz, r3.xyzx, v3.xxxx  
  <span class="hljs-number">22</span>: mul r2.xyz, r2.xyzx, v3.yyyy  
  <span class="hljs-number">23</span>: mad r0.xzw, r3.xxyz, r0.xxxx, r1.xxyz  
  <span class="hljs-number">24</span>: mad r0.xyz, r2.xyzx, r0.yyyy, r0.xzwx  
  <span class="hljs-number">25</span>: mov r0.w, l(<span class="hljs-number">1.000000</span>) </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da r0.x, r0.y und r0.z gleich 1,0 sind, wird die endgültige Berechnung vereinfacht: </font></font><br>
<br>
<code>worldSpacePosition = quadCenter + tangent * Xsize + bitangent * Ysize</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der letzte Teil ist eine einfache Multiplikation einer Position im Weltraum mit einer Ansichtsprojektionsmatrix, um SV_Position zu erhalten:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-number">26</span>: dp4 o4.x, r0.xyzw, cb1[<span class="hljs-number">0</span>].xyzw  
  <span class="hljs-number">27</span>: dp4 o4.y, r0.xyzw, cb1[<span class="hljs-number">1</span>].xyzw  
  <span class="hljs-number">28</span>: dp4 o4.z, r0.xyzw, cb1[<span class="hljs-number">2</span>].xyzw  
  <span class="hljs-number">29</span>: dp4 o4.w, r0.xyzw, cb1[<span class="hljs-number">3</span>].xyzw  </code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Pixel Shader</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie im Abschnitt "Allgemeine Übersicht" angegeben, wird der folgende </font><i><font style="vertical-align: inherit;">Mischstatus</font></i><font style="vertical-align: inherit;"> verwendet: </font><font style="vertical-align: inherit;">
Dabei sind </font><i><font style="vertical-align: inherit;">SrcColor</font></i><font style="vertical-align: inherit;"> und </font><i><font style="vertical-align: inherit;">SrcAlpha</font></i><font style="vertical-align: inherit;"> die .rgb- und .a-Komponenten des Pixel- </font><i><font style="vertical-align: inherit;">Shaders</font></i><font style="vertical-align: inherit;"> und </font><i><font style="vertical-align: inherit;">DestColor die .rgb-</font></i><font style="vertical-align: inherit;"> Farbe, die sich derzeit im Rendertarget befindet. </font><font style="vertical-align: inherit;">
Der Hauptindikator, der die Transparenz steuert, ist </font><i><font style="vertical-align: inherit;">SrcAlpha</font></i><font style="vertical-align: inherit;"> . Viele proaktive Game-Shader berechnen es als Deckkraft und wenden es am Ende wie folgt an: Der </font><font style="vertical-align: inherit;">
Falling-Star-Shader war keine Ausnahme. Nach diesem Muster betrachten wir drei Fälle, in denen die </font><i><font style="vertical-align: inherit;">Opazität</font></i><font style="vertical-align: inherit;"> 1,0, 0,1 und 0,0 beträgt.</font></font><br>
<br>
<code>FinalColor = SrcColor * One + DestColor * (1.0 - SrcAlpha) =<br>
FinalColor = SrcColor + DestColor * (1.0 - SrcAlpha)</code><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<code>return float4( color * opacity, opacity )</code><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<code>a) opacity = 1.0<br>
<br>
FinalColor = color * opacity + DestColor * (1.0 - opacity) =<br>
FinalColor = color = SrcColor</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/934/711/31c/93471131c99ec7b2249cff6edb698859.jpg"></div><br>
<code>b) opacity = 0.1<br>
<br>
FinalColor = color * opacity + DestColor * (1.0 - opacity) =<br>
FinalColor = 0.1 * color + 0.9 * DestColor</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/269/b24/d90/269b24d90592abb5065fba0f2a0aaf9f.jpg"></div><br>
<code>c) opacity = 0.0<br>
<br>
FinalColor = color * opacity + DestColor * (1.0 - opacity) =<br>
FinalColor = DestColor</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/191/75e/b6e/19175eb6e6757c04a0a063e75bad96f2.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Grundidee dieses Shaders besteht darin, die Deckkraftfunktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu modellieren und zu verwenden </font><font style="vertical-align: inherit;">, die die Deckkraft eines Pixels entlang eines Sternschnuppen steuert. Die Hauptanforderung ist, dass die Opazität am Ende des Sterns (seines „Körpers“) Maximalwerte erreicht und sanft auf 0,0 (zu seinem „Schwanz“) verblasst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir beginnen, den Assembler-Code des Pixel-Shaders zu verstehen, wird dies offensichtlich:</font></font><br>
<br>
<pre><code class="cpp hljs"> ps_5_0  <font></font>
    dcl_globalFlags refactoringAllowed  <font></font>
    dcl_constantbuffer cb0[<span class="hljs-number">10</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb2[<span class="hljs-number">3</span>], immediateIndexed  <font></font>
    dcl_constantbuffer cb4[<span class="hljs-number">2</span>], immediateIndexed  <font></font>
    dcl_input_ps linear v0.xyzw  <font></font>
    dcl_input_ps linear v1.xyzw  <font></font>
    dcl_input_ps linear v2.y  <font></font>
    dcl_input_ps linear v3.w  <font></font>
    dcl_output o0.xyzw  <font></font>
    dcl_temps <span class="hljs-number">4</span>  
   <span class="hljs-number">0</span>: mov_sat r0.x, v2.y  
   <span class="hljs-number">1</span>: ge r0.y, r0.x, l(<span class="hljs-number">0.052579</span>)  
   <span class="hljs-number">2</span>: ge r0.z, l(<span class="hljs-number">0.965679</span>), r0.x  
   <span class="hljs-number">3</span>: <span class="hljs-keyword">and</span> r0.y, r0.z, r0.y  
   <span class="hljs-number">4</span>: if_nz r0.y  
   <span class="hljs-number">5</span>:  ge r0.y, l(<span class="hljs-number">0.878136</span>), r0.x  
   <span class="hljs-number">6</span>:  add r0.z, r0.x, l(<span class="hljs-number">-0.052579</span>)  
   <span class="hljs-number">7</span>:  mul r1.w, r0.z, l(<span class="hljs-number">1.211303</span>)  
   <span class="hljs-number">8</span>:  mov_sat r0.z, r1.w  
   <span class="hljs-number">9</span>:  mad r0.w, r0.z, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">10</span>:  mul r0.z, r0.z, r0.z  
  <span class="hljs-number">11</span>:  mul r0.z, r0.z, r0.w  
  <span class="hljs-number">12</span>:  mul r2.x, r0.z, l(<span class="hljs-number">0.084642</span>)  
  <span class="hljs-number">13</span>:  mov r1.yz, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.084642</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">14</span>:  movc r2.yzw, r0.yyyy, r1.yyzw, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.500000</span>)  
  <span class="hljs-number">15</span>:  <span class="hljs-keyword">not</span> r0.z, r0.y  
  <span class="hljs-number">16</span>:  if_z r0.y  
  <span class="hljs-number">17</span>:   ge r0.y, l(<span class="hljs-number">0.924339</span>), r0.x  
  <span class="hljs-number">18</span>:   add r0.w, r0.x, l(<span class="hljs-number">-0.878136</span>)  
  <span class="hljs-number">19</span>:   mul r1.w, r0.w, l(<span class="hljs-number">21.643608</span>)  
  <span class="hljs-number">20</span>:   mov_sat r0.w, r1.w  
  <span class="hljs-number">21</span>:   mad r3.x, r0.w, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">22</span>:   mul r0.w, r0.w, r0.w  
  <span class="hljs-number">23</span>:   mul r0.w, r0.w, r3.x  
  <span class="hljs-number">24</span>:   mad r1.x, r0.w, l(<span class="hljs-number">0.889658</span>), l(<span class="hljs-number">0.084642</span>)  
  <span class="hljs-number">25</span>:   mov r1.yz, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.084642</span>, <span class="hljs-number">0.974300</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">26</span>:   movc r2.xyzw, r0.yyyy, r1.xyzw, r2.xyzw  
  <span class="hljs-number">27</span>:  <span class="hljs-keyword">else</span>  
  <span class="hljs-number">28</span>:   mov r2.y, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">29</span>:   mov r0.y, l(<span class="hljs-number">-1</span>)  
  <span class="hljs-number">30</span>:  endif  
  <span class="hljs-number">31</span>:  <span class="hljs-keyword">not</span> r0.w, r0.y  
  <span class="hljs-number">32</span>:  <span class="hljs-keyword">and</span> r0.z, r0.w, r0.z  
  <span class="hljs-number">33</span>:  if_nz r0.z  
  <span class="hljs-number">34</span>:   ge r0.y, r0.x, l(<span class="hljs-number">0.924339</span>)  
  <span class="hljs-number">35</span>:   add r0.x, r0.x, l(<span class="hljs-number">-0.924339</span>)  
  <span class="hljs-number">36</span>:   mul r1.w, r0.x, l(<span class="hljs-number">24.189651</span>)  
  <span class="hljs-number">37</span>:   mov_sat r0.x, r1.w  
  <span class="hljs-number">38</span>:   mad r0.z, r0.x, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">39</span>:   mul r0.x, r0.x, r0.x  
  <span class="hljs-number">40</span>:   mul r0.x, r0.x, r0.z  
  <span class="hljs-number">41</span>:   mad r1.x, r0.x, l(<span class="hljs-number">-0.974300</span>), l(<span class="hljs-number">0.974300</span>)  
  <span class="hljs-number">42</span>:   mov r1.yz, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.974300</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>)  
  <span class="hljs-number">43</span>:   movc r2.xyzw, r0.yyyy, r1.xyzw, r2.xyzw  
  <span class="hljs-number">44</span>:  endif  
  <span class="hljs-number">45</span>: <span class="hljs-keyword">else</span>  
  <span class="hljs-number">46</span>:  mov r2.yzw, l(<span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.000000</span>, <span class="hljs-number">0.500000</span>)  
  <span class="hljs-number">47</span>:  mov r0.y, l(<span class="hljs-number">0</span>)  
  <span class="hljs-number">48</span>: endif  
  <span class="hljs-number">49</span>: mov_sat r2.w, r2.w  
  <span class="hljs-number">50</span>: mad r0.x, r2.w, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)  
  <span class="hljs-number">51</span>: mul r0.z, r2.w, r2.w  
  <span class="hljs-number">52</span>: mul r0.x, r0.z, r0.x  
  <span class="hljs-number">53</span>: add r0.z, -r2.y, r2.z  
  <span class="hljs-number">54</span>: mad r0.x, r0.x, r0.z, r2.y  
  <span class="hljs-number">55</span>: movc r0.x, r0.y, r2.x, r0.x  
  <span class="hljs-number">56</span>: mad r0.y, cb4[<span class="hljs-number">1</span>].x, -cb0[<span class="hljs-number">9</span>].w, l(<span class="hljs-number">1.000000</span>)  
  <span class="hljs-number">57</span>: mul_sat r0.y, r0.y, v3.w  
  <span class="hljs-number">58</span>: mul r0.x, r0.y, r0.x  
  <span class="hljs-number">59</span>: mul r0.yzw, cb2[<span class="hljs-number">2</span>].xxyz, cb4[<span class="hljs-number">0</span>].xxxx  
  <span class="hljs-number">60</span>: mul r0.x, r0.x, cb2[<span class="hljs-number">2</span>].w  
  <span class="hljs-number">61</span>: dp3 r1.x, l(<span class="hljs-number">0.333000</span>, <span class="hljs-number">0.555000</span>, <span class="hljs-number">0.222000</span>, <span class="hljs-number">0.000000</span>), r0.yzwy  
  <span class="hljs-number">62</span>: mad r1.xyz, r1.xxxx, v0.xyzx, -r0.yzwy  
  <span class="hljs-number">63</span>: mad r0.yzw, v0.wwww, r1.xxyz, r0.yyzw  
  <span class="hljs-number">64</span>: add r1.xyz, -r0.yzwy, v1.xyzx  
  <span class="hljs-number">65</span>: mad r0.yzw, v1.wwww, r1.xxyz, r0.yyzw  
  <span class="hljs-number">66</span>: mul o0.xyz, r0.xxxx, r0.yzwy  
  <span class="hljs-number">67</span>: mov o0.w, r0.x  
  <span class="hljs-number">68</span>: ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen ist der Shader etwas überkompliziert und es fiel mir schwer herauszufinden, was darin vor sich ging. </font><font style="vertical-align: inherit;">Woher stammen beispielsweise alle Werte wie 1.211303, 21.643608 und 24.189651? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir über die Opazitätsfunktion sprechen, benötigen wir einen Eingabewert. </font><font style="vertical-align: inherit;">Damit ist es ganz einfach - Texcoord im Bereich von [0,1] (Zeile 0) ist hier nützlich, damit wir die Funktion auf die gesamte Länge des Meteoriten anwenden können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Opazitätsfunktion hat drei Segmente / Intervalle, die durch vier Kontrollpunkte definiert sind:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// current status: no idea how these are generated  </span>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> controlPoint0 = <span class="hljs-number">0.052579</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> controlPoint1 = <span class="hljs-number">0.878136</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> controlPoint2 = <span class="hljs-number">0.924339</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> controlPoint3 = <span class="hljs-number">0.965679</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe keine Ahnung, wie sie ausgewählt / berechnet wurden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie aus dem Assembler-Code ersichtlich ist, besteht die erste Bedingung lediglich darin, zu überprüfen, ob der Eingabewert im Bereich [controlPoint0 - controlPoint3] liegt. </font><font style="vertical-align: inherit;">Wenn nicht, beträgt die Deckkraft nur 0,0.</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// Input for the opacity function</span>
   <span class="hljs-keyword">float</span> y = saturate(Input.Texcoords.y);  <span class="hljs-comment">// r0.x</span><font></font>
     <font></font>
   <span class="hljs-comment">// Value of opacity function.  </span>
   <span class="hljs-comment">// 0 - no change  </span>
   <span class="hljs-comment">// 1 - full color  </span>
   <span class="hljs-keyword">float</span> opacity = <span class="hljs-number">0.0</span>;  <font></font>
     <font></font>
   [branch]   <font></font>
   <span class="hljs-keyword">if</span> (y &gt;= controlPoint0 &amp;&amp; y &lt;= controlPoint3)  <font></font>
   {  <font></font>
      ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Entschlüsselung des folgenden Assembler-Codes ist </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erforderlich,</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wenn wir verstehen möchten, wie die Opazitätsfunktion funktioniert:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-number">6</span>: add r0.z, r0.x, l(<span class="hljs-number">-0.052579</span>)   
   <span class="hljs-number">7</span>: mul r1.w, r0.z, l(<span class="hljs-number">1.211303</span>)   
   <span class="hljs-number">8</span>: mov_sat r0.z, r1.w   
   <span class="hljs-number">9</span>: mad r0.w, r0.z, l(<span class="hljs-number">-2.000000</span>), l(<span class="hljs-number">3.000000</span>)   
  <span class="hljs-number">10</span>: mul r0.z, r0.z, r0.z   
  <span class="hljs-number">11</span>: mul r0.z, r0.z, r0.w   
  <span class="hljs-number">12</span>: mul r2.x, r0.z, l(<span class="hljs-number">0.084642</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zeile 9 hat die Koeffizienten '-2.0' und '3.0', was auf die Verwendung der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Smoothstep-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">hinweist</font></a><font style="vertical-align: inherit;"> . Ja, das ist eine gute Vermutung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die HLSL-Smoothstep-Funktion mit Prototyp: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ret Smoothstep (min, max, x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> begrenzt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> immer </font><i><font style="vertical-align: inherit;">auf</font></i><font style="vertical-align: inherit;"> [ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min-max</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]. Aus Assembler-Sicht subtrahiert dies </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vom Eingabewert (d. H. Von r0.z in Zeile 9), aber es gibt nichts Vergleichbares im Code. Für </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">max</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bedeutet dies eine Multiplikation des Eingabewerts, aber der Code enthält nichts Vergleichbares wie 'mul_sat'. Stattdessen gibt es 'mov_sat'. Dies sagt uns , </font><font style="vertical-align: inherit;">dass die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">max</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktionen von smoothstep sind 0 und 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt wissen wir , </font><font style="vertical-align: inherit;">dass </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss im Intervall [0, 1] liegen. Wie oben angegeben, gibt es drei Segmente in der Opazitätsfunktion. Dies deutet eindeutig darauf hin, dass der Code sucht, wo wir uns im Intervall [segmentStart-segmentEnd] befinden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Antwort ist die Linstep-Funktion!</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">linstep</span><span class="hljs-params">(<span class="hljs-keyword">float</span> min, <span class="hljs-keyword">float</span> max, <span class="hljs-keyword">float</span> v)</span>  
 </span>{  
   <span class="hljs-keyword">return</span> ( (v-min) / (max-min) );  <font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir zum Beispiel das erste Segment: [0.052579 - 0.878136]. </font><font style="vertical-align: inherit;">Die Subtraktion erfolgt in Zeile 6. Wenn wir die Division durch Multiplikation ersetzen -&gt; 1,0 / (0,878136 - 0,052579) = 1,0 / 0,825557 = ~ 1,211303. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis von Smoothstep liegt im Bereich [0, 1]. </font><font style="vertical-align: inherit;">Die Multiplikation in Zeile 12 ist das Gewicht des Segments. </font><font style="vertical-align: inherit;">Jedes Segment hat sein eigenes Gewicht, sodass Sie die maximale Deckkraft dieses bestimmten Segments steuern können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet, dass für das erste Segment [0,052579 - 0,878136] die Opazität im Bereich [0 - 0,084642] liegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine HLSL-Funktion, die die Opazität für ein beliebiges Segment berechnet, kann wie folgt geschrieben werden:</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">getOpacityFunctionValue</span><span class="hljs-params">(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> cpLeft, <span class="hljs-keyword">float</span> cpRight, <span class="hljs-keyword">float</span> weight)</span>  
 </span>{  
   <span class="hljs-keyword">float</span> val = smoothstep( <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, linstep(cpLeft, cpRight, x) );  
   <span class="hljs-keyword">return</span> val * weight;  <font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der springende Punkt ist also, diese Funktion einfach für das entsprechende Segment aufzurufen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich die Gewichte an:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> weight0 = <span class="hljs-number">0.084642</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> weight1 = <span class="hljs-number">0.889658</span>;  
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> weight2 = <span class="hljs-number">0.974300</span>; <span class="hljs-comment">// note: weight0+weight1 = weight2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gemäß dem Assembler-Code wird die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opazitätsfunktion (x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wie folgt berechnet:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-keyword">float</span> opacity = <span class="hljs-number">0.0</span>;<font></font>
<font></font>
   [branch]   <font></font>
   <span class="hljs-keyword">if</span> (y &gt;= controlPoint0 &amp;&amp; y &lt;= controlPoint3)  <font></font>
   {  <font></font>
     <span class="hljs-comment">// Range of v: [0, weight0]  </span>
     <span class="hljs-keyword">float</span> v = getOpacityFunctionValue(y, controlPoint0, controlPoint1, weight0);  <font></font>
     opacity = v;  <font></font>
     <font></font>
     [branch]  <font></font>
     <span class="hljs-keyword">if</span> ( y &gt;= controlPoint1 )  <font></font>
     {  <font></font>
       <span class="hljs-comment">// Range of v: [0, weight1]  </span>
       <span class="hljs-keyword">float</span> v = getOpacityFunctionValue(y, controlPoint1, controlPoint2, weight1);  <font></font>
       opacity = weight0 + v;  <font></font>
   <font></font>
       [branch]  <font></font>
       <span class="hljs-keyword">if</span> (y &gt;= controlPoint2)  <font></font>
       {  <font></font>
         <span class="hljs-comment">// Range of v: [0, weight2]  </span>
         <span class="hljs-keyword">float</span> v = getOpacityFunctionValue(y, controlPoint2, controlPoint3, weight2);<font></font>
         opacity = weight2 - v;          <font></font>
       }  <font></font>
     }  <font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein Diagramm der Opazitätsfunktion. </font><font style="vertical-align: inherit;">Sie können leicht einen starken Anstieg der Deckkraft erkennen, der auf den Beginn des Körpers eines Sternschnuppen hinweist:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5da/326/1f0/5da3261f0f88fa41ac963ca84fc79f99.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grafikopazitätsfunktion. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Roter Kanal - Opazitätswert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grüner Kanal - Kontrollpunkte. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Blauer Kanal - Gewichte.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nach der Berechnung der Opazität ist alles andere nur der letzte Schliff. </font><font style="vertical-align: inherit;">Dann gibt es zusätzliche Multiplikationen: die Opazität der Sterne, die Farbe des Sternschnuppen und den Einfluss des Nebels. </font><font style="vertical-align: inherit;">Wie bei TW3-Shadern üblich, finden Sie hier auch redundante Multiplikationen mit 1,0:</font></font><br>
<br>
<pre><code class="cpp hljs">   <span class="hljs-comment">// cb4_v1.x = 1.0  </span>
   <span class="hljs-keyword">float</span> starsOpacity = <span class="hljs-number">1.0</span> - cb0_v9.w * cb4_v1.x;    <font></font>
   opacity *= starsOpacity;  <font></font>
<font></font>
   <span class="hljs-comment">// Calculate color of a shooting star  </span>
   <span class="hljs-comment">// cb4_v0.x = 10.0</span>
   <span class="hljs-comment">// cb2_v2.rgb = (1.0, 1.0, 1.0)</span><font></font>
   float3 color = cb2_v2.rgb * cb4_v0.x;<font></font>
     <font></font>
   <span class="hljs-comment">// cb2_v2.w = 1  </span><font></font>
   opacity *= cb2_v2.w;<font></font>
     <font></font>
   FogResult fr = { Input.FogParams, Input.AerialParams };  <font></font>
   color = ApplyFog(fr, color);<font></font>
     <font></font>
   <span class="hljs-keyword">return</span> float4( color*opacity, opacity);  <font></font>
 }</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Zusammenfassung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hauptschwierigkeit liegt im Teil mit der Opazitätsfunktion. Nach dem Entschlüsseln ist alles andere recht einfach zu verstehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe oben gesagt, dass der Pixel-Shader etwas überkompliziert ist. Tatsächlich kümmern wir uns nur um den Wert der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opazitätsfunktion (x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die in r2.x gespeichert ist (beginnend mit Zeile 49). Die Deckkraftfunktion im Assembler-Code erstellt jedoch drei zusätzliche Variablen: minRange (r2.y), maxRange (r2.z) und value (r2.w). Alle von ihnen sind Parameter, die zur Berechnung der Opazität verwendet werden, wenn die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opazität (x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht verwendet wird: </font></font><br>
<br>
<code>lerp( minRange, maxRange, smoothstep(0, 1, value) );</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich wird der endgültige Opazitätswert im bedingten Zweig in Zeile 55 erhalten - wenn der Eingabewert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">liegt im Bereich [controlPoint0 - controlPoint3], bedeutet dies, dass die Opazitätsfunktion verwendet wird, sodass r2.x ausgewählt ist. </font><font style="vertical-align: inherit;">Andernfalls wird, wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> außerhalb des Intervalls liegt, die Opazität aus r0.x berechnet, dh gemäß der obigen Gleichung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe einige Pixel außerhalb des Intervalls [controlPoint0 - controlPoint3] debuggt, und die endgültige Deckkraft stellte sich immer als Null heraus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles für heute. </font><font style="vertical-align: inherit;">Und wie immer vielen Dank fürs Lesen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de489092/index.html">Wie ich in 12 Monaten selbständig eine neue Sprache gelernt habe: ein totaler Leitfaden</a></li>
<li><a href="../de489100/index.html">SARS-CoV-2 Coronavirus-Datenanalyse (2019-nCov)</a></li>
<li><a href="../de489102/index.html">Gefälschtes Bildschirmleben. "Ja, ich persönlich kenne Madonna"</a></li>
<li><a href="../de489106/index.html">Wie ich aus dem Journalismus ausstieg und Programmierer wurde</a></li>
<li><a href="../de489108/index.html">Hinzufügen Ihrer Felder zu einem Pytest-Bericht</a></li>
<li><a href="../de489122/index.html">Typisierte OData-Abfragen in TypeScript</a></li>
<li><a href="../de489128/index.html">Internationalisierung: Wie man das Produkt auf den internationalen Markt bringt (und nicht verrückt wird)</a></li>
<li><a href="../de489132/index.html">Highlights mit Integrated Systems Europe 2020</a></li>
<li><a href="../de489134/index.html">Forschung von Designteams in russischen Lebensmittelunternehmen</a></li>
<li><a href="../de489136/index.html">Mit zwanzig Haskell-Zeilen gewinnen: Schreiben Sie Ihre Wc</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>