<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏼 ⛹🏼 👉🏼 使用DOM的最佳方法 🐿️ 🚍 🦉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在撰写Solid时，我有机会估算了优化图（基准）性能的尝试次数。
 
 DOM是前端瓶颈开发。不同的解决方案可能导致相似的结果。每周都会出现新的图书馆，这些图书馆结合了以往的所有内容，以实现完美的组合。一段时间后，我的视线开始逃离各种解决方案。
 
 不要误解我。我喜欢看到新的想法变成现实，但是它们...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>使用DOM的最佳方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501170/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在撰写</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solid时</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我有机会估算了优化图（基准）性能的尝试次数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DOM是前端瓶颈开发。</font><font style="vertical-align: inherit;">不同的解决方案可能导致相似的结果。</font><font style="vertical-align: inherit;">每周都会出现新的图书馆，这些图书馆结合了以往的所有内容，以实现完美的组合。</font><font style="vertical-align: inherit;">一段时间后，我的视线开始逃离各种解决方案。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不要误解我。</font><font style="vertical-align: inherit;">我喜欢看到新的想法变成现实，但是它们都有缺陷，有时会带来便利性或生产力的损失。</font><font style="vertical-align: inherit;">我理解这种决定的后果，但我想分享我的看法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
什么是使用DOM最快的方法：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虚拟dom</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标记模板文字 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">细粒度的可观察物</font></font></li>
</ul><a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比较方式</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JS Frameworks Benchmark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是比较JavaScript UI框架性能的最佳开源项目。</font><font style="vertical-align: inherit;">最好在本地运行测试，而不要使用官方结果。</font><font style="vertical-align: inherit;">结果可能因机器而异。</font><font style="vertical-align: inherit;">由于我是在性能较差的机器上进行测试，因此性能会明显下降。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将采用最佳方法来渲染DOM树，以说明某些解决方案的冗余性。</font><font style="vertical-align: inherit;">我将使用Solid支持不同渲染选项的功能来进行此操作，以便在变量更改时施加成本，并将其与其他框架的相似结果进行比较。</font><font style="vertical-align: inherit;">让我们看看它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各种固体：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">固体</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -版本与内置到克隆DOM节点模板更改跟踪功能顶ES2015代理二传手框架。</font><font style="vertical-align: inherit;">这是通过预编译JSX模板</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（代码）来实现的</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实体信号</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -此版本与前一个版本相同，但是使用原始信号代替代理。</font><font style="vertical-align: inherit;">这使该库的使用复杂化，但是最终，我们得到了更小的捆绑包和更好的性能</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（代码）</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">稳定点亮</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -此版本在运行时不使用JSX预编译</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（代码）</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solid-h-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此版本使用HyperScript即时创建`document.createElement`。</font><font style="vertical-align: inherit;">其余使用与Solid </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">（代码）</font></a><font style="vertical-align: inherit;">相同的实现</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其他库：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">domc</a> — -,       DOM     DSL (domain specific language)   HTML,    index.html<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"> (Code)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">surplus</a> —       JSX     `document.createElement`. Solid     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"> (Code)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">ivi </a> —     Inferno,      DOM.   HyperScript Helpers-esque  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"> (Code)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">lit-html</a> —      ,  c  .     Tagged Template Literals   DOM-<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"> (Code)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inferno</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是最快的React克隆，也是最快的虚拟DOM库之一。</font><font style="vertical-align: inherit;">使用特殊的JSX指令以获得最佳性能</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（代码）</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您最喜欢的一些框架可能不在这里，但是此列表显示了在最流行的框架中将看到的所有技术的优化版本。</font><font style="vertical-align: inherit;">您可以将其视为评估磁带库最大功能的指标。</font><font style="vertical-align: inherit;">如果您有兴趣比较流行框架的性能，建议您使用此图表。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了进行比较，我想添加Web Assembly。</font><font style="vertical-align: inherit;">不幸的是，在撰写本文时，WASM记录是没有高级抽象的原始实现。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（后来他们将wasm-bindgen添加到框架中-大约是翻译器）</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HyperScript（Inferno，ivi，solid-h）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HyperScript将标记显示为功能的组合（例如h或React.createElement）。</font><font style="vertical-align: inherit;">例如：</font></font><br>
<br>
<pre><code class="javascript hljs">h(<span class="hljs-string">'div'</span>, {<span class="hljs-attr">id</span>: <span class="hljs-string">'my-element'</span>}, [<font></font>
  h(<span class="hljs-string">'span'</span>, <span class="hljs-string">'Hello'</span>),<font></font>
  h(<span class="hljs-string">'span'</span>, <span class="hljs-string">'John'</span>)<font></font>
])<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
虚拟DOM框架具有此属性。即使它们使用JSX或其他DSL模板引擎-在引擎盖下，它们仍将转换为逐个元素的渲染方法。这用于为每个渲染周期构造一个虚拟DOM树。但是，如此处所示，与Solid一样，渲染的函数可用于创建反应性依赖图。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1t/lp/av/1tlpavyaaxibat0dsnz84dlgcv4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，具有虚拟DOM的库要快得多。由于过度创建反应曲线图，Solid的性能下降。注意基准测试＃1，＃2，＃7，＃8，＃9的差异。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uf/jo/ne/ufjonerq7jqkd4r31x3sfwtcy7o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
记忆力不足。 Inferno和此版本的Solid显示大致相同的结果。虽然ivi使用更多的内存。</font></font><br>
<blockquote>   ,  Solid,  ,    VDOM. Solid            ,     DOM,     DOM. Solid  JSX    DOM .               ,  . Solid  fine grained evaluation    .  -  .<br>
 — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"></a><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反应性更新跟踪框架在更新行时显示出更好的结果。</font><font style="vertical-align: inherit;">该图可以解释近年来VDOM的流行。</font><font style="vertical-align: inherit;">可以说，如果您在此更新中使用HyperScript，则最好切换到虚拟DOM。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字符串模板（domc，lit-html，solid-lit）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里的每个库都有一些共同点。它们是基于克隆元素模板呈现的，可以在运行时运行，并且不使用VDOM。但是它们仍然存在差异。 DomC和lit-html使用类似于虚拟DOM的自上而下的差异，而Solid使用反应性图。 Lit-html将模板拆分为多个部分。 DomC和Solid在运行时将模板编译为单独的路径并进行更新。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h3/iu/lv/h3iulvmkhg6y1og6dslnc3pt8i8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此类别具有最广泛的性能。 DomC是最快的，而lit-html是最慢的。 Solid Lit在中间。 DomC证明，简单的代码可带来最佳性能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DomC仅在第4节中下垂，因为它计算节点的差异，随着深度的增加，该差异变得更加复杂。这非常快，但是您需要验证大数据的结果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solid Lit比Solid HyperScript更具生产力。运行时即时编译消除了创建反应式图形的弊端，使框架可以赶上最快的VDOM库ivi（请参阅本文末尾的完整表）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0m/h1/vo/0mh1vo1qzvthbjsvsol1mpopdgg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DomC在内存消耗方面显示出良好的结果。这是由于模板元素的克隆而发生的。值得注意的是，与构建阶段的编译相比，运行时中的代码生成可以将性能开销降至最低。对于lit-html来说，这可能是不公平的比较，因为该框架未使用此技术。公平地说，lit-html或类似的库（例如hyperHTML或lighterHTML）不是实现标记模板文字的最佳方法。即使在没有VDOM的运行时，您也可以获得良好的结果。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预编译的JSX（固定，固定信号，剩余）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些库使用JSX，在构建阶段将其编译为DOM或反应图。</font><font style="vertical-align: inherit;">模板可以是任何东西，但是JSX提供了干净的语法树，可以增强开发人员的体验。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/q5/ik/c7/q5ikc7iohyy8m5lyydzhijzylaq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该组的结果相似，但区别非常重要。</font><font style="vertical-align: inherit;">这三个都使用相同的库来管理</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用Solid Signals示例，您可以看到带有克隆模板元素的跟踪功能可提供更高的性能。</font><font style="vertical-align: inherit;">使用ES2015代理会重载Solid的标准实现，这会使所有图形的结果恶化。</font><font style="vertical-align: inherit;">盈余使用`document.createElement`，这会降低在创建＃1，＃2，＃7，＃8行的测试中的性能。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fv/7_/by/fv7_bynjjqiyp8u_ss3l0cqsmtc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内存消耗也有类似的结果。</font><font style="vertical-align: inherit;">在这种情况下，代理比克隆模板元素要复杂得多。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里的结论是代理会降低性能，并且更多的库应该克隆模板。</font><font style="vertical-align: inherit;">另一方面，您可以将由于代理造成的性能损失视为一项投资。</font><font style="vertical-align: inherit;">在其他示例中，Solid示例的代码量最少-仅66行，它的非空白比Svelte少13％-该库以其极简主义而自豪。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一流的（domc，ivi，固态信号，vanillajs）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们来看看每个类别的获奖者，并将它们与香草JavaScript中残酷，有效，手写的示例进行比较。每个实现都代表一种流行的状态跟踪解决方案。您甚至可以在以下三个库之间进行类比：Solid→Vue，DomC→Angular，ivi→React。如果除去渲染以外的所有多余内容，并摆脱60-200kb的代码，就会得到此结果。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sy/lj/9c/sylj9c8bd1xzzwehg0o-z7mvyei.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在性能方面，DomC和Solid接近，ivi明显落后，但总体而言DomC更快。与vanillaJS相比，它的复杂性要低得多，但在进行部分更新时效果不佳。仅此标准不是指示性的。任何认为V​​DOM速度慢或有不必要的复杂性的人都应该自己检查一下。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大多数库永远不会具有这种性能。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mz/zp/bx/mzzpbxqifmdadvbjm3ydk3pxy2a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DomC在内存方面也处于领先地位。</font><font style="vertical-align: inherit;">在内存消耗方面，细粒度的Solid优于VDOM ivi。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有趣的是，无论使用哪种方法，这些库都不会比vanillaJS差很多。</font><font style="vertical-align: inherit;">他们都非常快。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">捆束尺寸</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，我想谈谈捆绑商品的大小。</font><font style="vertical-align: inherit;">许多实际测试仅关注这些指标。</font><font style="vertical-align: inherit;">是的，捆绑包的大小很重要，并且与性能直接相关，但是有什么区别呢？</font><font style="vertical-align: inherit;">我怀疑代码复杂度比大小更重要。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-t/m7/yb/-tm7ybrxshulxxcbcufybomwzjq.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
像往常一样，此类图中的结果永远不会完全令人信服。过程本身和我们得出的结论很重要。在这种情况下，我们看到DOM本身在性能方面是一个很大的瓶颈。如此之多，以至于没有明确的技术来规避它。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ll/7v/qa/ll7vqadwntgwoae6oepqwwbsalc.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Christoper Lambert饰演Highlander</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
不，不是那么简单。 DOM和VDOM都不慢。但是我相信他们彼此值得。我承认，VDOM Performance React的言论使我想到了这些想法。围绕该主题的观点的无知正在激怒。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VDOM缓慢的说法是由于意识不足。与不执行VDOM相比，渲染VDOM并计算状态差异是一个复杂的过程。但是它的缺失是否可以扩展？以及如何进行数据更改？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我看到每条规则都有一个例外。通常，在反应框架中将预编译与精细结合起来是最快的解决方案。但是，DomC显示出没有它的高性能。本地JS方法（例如使用Tagged Template Literals克隆模板元素）可能是实现大型公司（Google）的lit-html的最佳解决方案。但这是此表中最慢的框架之一，甚至不是这些技术的最佳实现。 Svelte被认为是社区中最快的图书馆，但它甚至无法与提出的解决方案竞争。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果反应式编程获胜，这并不意味着所有反应式库都很快，或者指标意味着一切。</font><font style="vertical-align: inherit;">尽管本文进行了深入的比较，但我认为实际上有快速的库和较慢的库。</font><font style="vertical-align: inherit;">即使我们找到了超级技术，我们仍将面临其局限性。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一张表中所有库的测试结果：</font></font></b><br>
<br>
<img src="https://habrastorage.org/webt/gg/3u/oq/gg3uoqckygryprsownwet3r12jq.png"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN501158/index.html">使用Kotlin方便地进行Android View绑定</a></li>
<li><a href="../zh-CN501162/index.html">使用R和文本挖掘技术比较俄罗斯说唱场景。诺伊兹·麦卡斯塔（Noize Mc and Kasta）与法老（Pharaoh）和摩根施特恩（Morgenshtern）</a></li>
<li><a href="../zh-CN501164/index.html">可视化网络拓扑，或者为什么还要使用Python＃2网络工程师</a></li>
<li><a href="../zh-CN501166/index.html">oVirt在2小时内。第1部分。开放式故障转移虚拟化平台</a></li>
<li><a href="../zh-CN501168/index.html">有序的人会救自己-他们会保存，保存，精疲力尽吗？</a></li>
<li><a href="../zh-CN501172/index.html">我的Mikrosh电脑：继续怀旧的一周</a></li>
<li><a href="../zh-CN501178/index.html">看色情片如何影响工作和学习的生产力</a></li>
<li><a href="../zh-CN501180/index.html">[问题后]您需要有关冠状病毒和“副作用”的FACTS的IT运动吗？</a></li>
<li><a href="../zh-CN501182/index.html">oVirt在2小时内。第2部分。安装管理器和主机</a></li>
<li><a href="../zh-CN501184/index.html">如何配置Apollo以在Android中使用GraphQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>