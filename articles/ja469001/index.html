<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🚀 👩🏿‍🤝‍👩🏻 🔇 マイクロサービスからお粥を調理する方法 ☪️ 👨🏼‍💼 👶🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="マイクロサービスの人気の理由の1つは、自律的で独立した開発の可能性です。本質的に、マイクロサービスアーキテクチャは、（モノリスと比較して）より複雑な展開、テスト、デバッグ、モニタリングのための自律的な開発の可能性の交換です。ただし、マイクロサービスは責任の分離を許さないことに注意してください。職務の...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>マイクロサービスからお粥を調理する方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469001/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイクロサービスの人気の理由の1つは、自律的で独立した開発の可能性です。</font><font style="vertical-align: inherit;">本質的に、マイクロサービスアーキテクチャは、（モノリスと比較して）より複雑な展開、テスト、デバッグ、モニタリングのための自律的な開発の可能性の交換です。</font><font style="vertical-align: inherit;">ただし、マイクロサービスは責任の分離を許さないことに注意してください。</font><font style="vertical-align: inherit;">職務の分離が正しくない場合、さまざまなサービスで頻繁に依存する変更が発生します。</font><font style="vertical-align: inherit;">そして、これは、モノリス内の異なるモジュールまたはパッケージのフレームワーク内の調整された変更よりもはるかに苦痛で複雑です。</font><font style="vertical-align: inherit;">マイクロサービスの一貫した変更は、一貫したレイアウト、デプロイ、テストなどによって複雑になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、責任をマイクロサービスに分割するさまざまなパターンとアンチパターンについてお話ししたいと思います。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アンチパターンとしてのサービスエンティティ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「サービスエンティティ」は、マイクロサービスアーキテクチャを設計する際の考えられる（反）パターンの1つです。これにより、さまざまなサービスで依存度の高いコードが作成され、サービス内で疎結合になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの開発者にとって、「取引」、「人物」、「クライアント」、「注文」、「写真」という主題領域の本質に従ってサービスを選択するとき、彼は単一の責任の原則に従い、さらにこれはしばしば論理的であるように見えます。ただし、サービスエンティティアプローチはアンチパターンに変わる可能性があります。これは、ほとんどの機能または変更が1つのエンティティではなく複数のエンティティに影響するために発生します。その結果、そのような各サービスは、異なるビジネスプロセスのロジックを組み合わせます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、オンラインストアを見てみましょう。サービス「製品」、「注文」、「クライアント」を強調することにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
宅配便を追加するにはどのような変更やサービスを行う必要がありますか？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、これを行うことができます：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスの「注文」に、配送先住所、希望する時間、配送人を追加します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントサービスで、クライアントの選択された配信アドレスのリストを追加します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービス「製品」に商品のエンティティリストを追加します </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロバイダーのインターフェースについては、「オーダー」サービスで個別のAPIメソッドを作成する必要があります。これにより、この特定のプロバイダーに割り当てられたオーダーのリストが提供されます。</font><font style="vertical-align: inherit;">さらに、注文に合わなかった商品、または配達時にクライアントが拒否した商品を削除するための方法が必要になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、プロモーションコードに割引を追加するには、どのような変更やサービスを行う必要がありますか？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最低限必要なもの：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「注文」サービスにプロモーションコードを追加する</font></font></li>
<li>  «»          </li>
<li>  «»   ,   </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マネージャーのインターフェースでは、パーソナライズされたプロモーションコードをクライアントに追加することはクライアントサービスの別の方法であり、ストアマネージャーのみが利用でき、クライアント自身は利用できません。そして、「製品」サービスで、プロモーションコードの影響を受ける製品のリストを提供するメソッドを作成します。これにより、クライアントが自分のインターフェースで選択しやすくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サービスの変更の原因には、選択と設計、支払いと請求、配信など、いくつかのビジネスプロセスがあります。それぞれの問題領域には、注文に対する独自の制限、不変条件、および要件があります。その結果、「製品」サービスでは、製品に関する情報、割引、および製品の残高が倉庫に保存されることがわかりました。そして「注文」には配達人のロジックが格納されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、いくつかのサービスにまたがるビジネスロジックの変更は、いくつかのサービスに依存する変更をもたらします。</font><font style="vertical-align: inherit;">同時に、1つのサービスには、互いに接続されていないコードがあります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストレージサービス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題は、ロジック全体をカプセル化するエンティティサービス上に別の「レイヤー」サービスを作成すると解決できるようです。</font><font style="vertical-align: inherit;">しかし、通常これもひどく終わります。</font><font style="vertical-align: inherit;">それは、エンティティサービスがストレージサービスになるからです。</font><font style="vertical-align: inherit;">ストレージを除いて、すべてのビジネスロジックはそれらから洗い流されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データが異なるデータベース、異なるマシンに保存されている場合、</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースから直接データを提供するのではなく、サービス層を介してパフォーマンスを低下させます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常、サービスAPIはSQLやその他のクエリ言語よりはるかに柔軟性が低いため、柔軟性が失われます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまなサービスからデータをマージすることが難しいため、柔軟性が失われます</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
異なるエンティティサービスが他のデータベースにアクセスできる場合、サービス間の通信は暗黙的に行われます-共通データベースを介して、データスキーマの変更に影響を与える変更を行うには、この変更がこのデータベースまたはタブレットを使用する他のすべてのサービスを中断しないことを確認した後でのみ可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複雑な開発に加えて、そのようなサービスは非常に重要になり、負荷が高くなります。トップレベルのサービスのほとんどすべてのリクエストで、さまざまなサービスエンティティに対して複数のリクエストを行う必要があります。つまり、信頼性とパフォーマンスの要件の向上を満たすために、それらを編集することはさらに困難になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
純粋な形式でのエンティティサービスの開発とサポートには困難があるため、パターンが表示されることはほとんどありません。通常、エンティティサービスは1つまたは2つの中心的な「マイクロサービスモノリス」に変わります。まれに変化する小さなもの。 </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題領域による分離</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自分自身の変化は生まれません、彼らはいくつかの問題領域から来ます。問題領域は、コードの変更を必要とする問題が1つの言語で定式化され、1つの概念のセットを使用するか、ビジネスロジックによって相互接続されるタスク領域です。したがって、1つの問題領域のフレームワーク内では、コードを作成するときに信頼できる1セットの制限、不変条件が存在する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンティティではなく問題領域ごとにサービスの責任を分離すると、通常、よりサポートされ、理解しやすいアーキテクチャになります。問題のある領域は、ほとんどの場合ビジネスプロセスに対応しています。オンラインストアの場合、最も可能性の高い問題領域は、「支払いと請求」、「配達」、「注文プロセス」です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数の問題領域に同時に影響を与える変更は、複数のエンティティに影響を与える変更よりも少ないです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、ビジネスプロセスごとに分類されたサービスは、将来再利用できます。</font><font style="vertical-align: inherit;">たとえば、オンラインショップの横で飛行機のチケットをもう一度販売したい場合は、「Billing and Payment」という一般サービスを再利用できます。</font><font style="vertical-align: inherit;">そして、別の同様のものを作成しないでくださいが、チケットの販売に固有です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、サービスを次のように分割できます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスまたはサービスのグループ「配信」。これには、特定の注文の配信に伴う作業のロジック、サプライヤの作業の編成、作業の品質の評価、サプライヤのモバイルアプリケーションなどが格納されます。 </font></font></li>
<li>    «  »,        ,     ,     .</li>
<li>    « »,        , , ,    ..</li>
<li> “  ”.</li>
<li>         .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サービスは相互に対話するために、イベントモデルを使用したり、単純なオブジェクト（restful api、grpcなど）を相互に交換したりできます。確かに、そのようなサービス間の相互作用を正しく構成することは容易ではないことは注目に値します。少なくとも、データの分散化には、一貫性（最終的には一貫性）とトランザクション性（重要な場合）の問題があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データの分散化、単純なオブジェクトの交換には、長所、短所、および落とし穴があります。一方、分散化により、複数のサービスを独立して開発および運用することが可能になります。一方、2つまたは3つのデータのコピーを保存し、異なるシステムで一貫性を維持するためのコスト。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実生活では、その間に何かがしばしば発生します。すべてのサービスがコンシューマーによって使用される最小限の属性セットを持つサービスエンティティ。そして、いくつかの最小限のロジック層-たとえば、ステータスモデル、およびエンティティ内のすべての変更の通知を伴うキュー内のイベント。同時に、サービス利用者は依然としてかなり頻繁にデータの「キャッシュ」を保持しています。そのようなサービスでの変更ができるだけ少なくなるように可能な限りのことを行っていますが、これは原則として、多くの消費者がいるという事実のために行うことは困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、すべてのパーティション（エンティティ別および問題領域別）は特効薬ではなく、常にいくつかのサービスに依存する変更が必要になる機能があることを理解することが重要です。</font><font style="vertical-align: inherit;">ある内訳では、他の内訳よりもはるかに多くのそのような変化があるでしょう。</font><font style="vertical-align: inherit;">また、開発のタスクは、依存する変更の数を最小限に抑えることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理想的な分割は、2つの完全に独立した製品がある場合にのみ可能です。</font><font style="vertical-align: inherit;">どのビジネスでも、すべてがすべてとつながっています。唯一の問題は、どれだけつながっているかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして問題は、責任の分離と抽象化への障壁の高さです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスAPIの設計</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サービス内のインターフェースを設計すると、小規模なスケールでのみ、サービスに分解して履歴が繰り返されます。</font><font style="vertical-align: inherit;">（単なる拡張ではなく）インターフェースの変更は複雑で時間がかかります。</font><font style="vertical-align: inherit;">複雑なアプリケーションでは、インターフェースは、一定の変化を引き起こさないように十分に普遍的である必要があり、責任とセマンティクスの広がりを引き起こさないように十分に具体的でなければなりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、サービスインターフェイスは、そのセマンティクスが変更に耐えられるように設計する必要があります。</font><font style="vertical-align: inherit;">そして、これは、インターフェースのセマンティクスまたは責任の領域が問題領域の制限に依存している場合に可能です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複雑なビジネスロジックを持つサービスのCRUDインターフェイス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターフェースが広すぎて非特定的であると、責任が損なわれるか、過度に複雑になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、複雑なビジネスロジックを持つサービス用のCRUD APIこのようなインターフェースは動作をカプセル化しません。これらはビジネスロジックが他のサービスに漏れてサービスの責任を侵食することを可能にするだけでなく、ビジネスロジックの広がりを引き起こします-制限、不変量、およびデータの操作方法は現在、他のサービスにあります。インターフェイスユーザーサービス（API）は、ロジック自体を実装する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターフェースを大幅に変更することなく、ビジネスロジックをサービスに転送しようとすると、あまりに普遍的で複雑すぎるメソッドになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、チケットサービスがあります。チケットにはさまざまなタイプがあります。各タイプには、異なるフィールドのセットとわずかに異なる検証があります。チケットにはステータスモデルもあります。ステータスモデルは、あるステータスから別のステータスに移行するためのステートマシンです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
APIを次のようにします：POST / PATCH / GETメソッド、url /api/v1/tickets/{ticket_idasket.json </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、チケットを更新できます</font></font><br>
<br>
<pre><code class="json hljs">PATCH /api/v1/tickets/{ticket_id}.json <font></font>
{ <font></font>
    <span class="hljs-attr">"type"</span>: <span class="hljs-string">"bug"</span>, 
    <span class="hljs-attr">"status"</span>: <span class="hljs-string">"closed"</span>,
    <span class="hljs-attr">"description"</span>: <span class="hljs-string">"   "</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ステータスモデルがチケットに依存する場合、ビジネスロジックの競合が発生する可能性があります。まず、古いステータスモデルに従ってステータスを変更し、次にチケットのタイプを変更します。またはその逆？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
APIメソッド内には、相互に接続されていないコードが存在することがわかります-エンティティフィールド、チケットのタイプに応じて使用可能なフィールドのリスト、およびステータスモデルを変更します。これらはさまざまな理由で変更されるため、さまざまなAPIメソッドおよびインターフェースに従ってそれらを配布することは理にかなっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
APIのCRUDメソッドのフレームワーク内でフィールドを変更することがデータの変更だけでなく、エンティティの状態の調整された変更に関連する操作である場合、この操作は別のメソッドに移動し、直接変更することはできません。下位互換性なしでAPIを変更することが非常に悪い場合（パブリックAPIの場合）、APIを設計するときにすぐに検討することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、このような問題を回避するには、データ中心のユニバーサルなインターフェイスではなく、インターフェイスを小さく、具体的で、できるだけ問題指向にする方がよいでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この（アンチ）パターンは、デフォルトでは、作成、削除、更新、読み取りを行うアクションのデータ中心の「動詞」がほんのわずかしかないため、RESTfulインターフェースに特徴的です。ビジネス固有のエンティティ操作はありません</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RESTfulをより問題指向にするために何ができるでしょうか？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、エンティティにメソッドを追加できます。インターフェースは落ち着きがなくなってきています。しかし、そのような機会があります。レースの純粋さのために戦うことはありませんが、実用的な問題を解決します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユニバーサルリソースの代わりに、リソースを</font></font><code>/api/v1/tickets.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加します</font></font><br>
<br>
<code>/api/v1/tickets/{ticket_id}/migrate.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。-あるタイプから別のタイプに移行し</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">- </font></font><br>
<code>/api/v1/tickets/{ticket_id}/status.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステータスモデルがある場合</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、RESTのフレームワーク内のリソースとして任意の操作を想像できます。あるタイプから別のタイプへの（またはあるプロジェクトから別のプロジェクトへの）チケット移行操作はありますか？わかりましたので、リソースがあります。</font></font><br>
<code>/api/v1/tickets/migration.json</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
試用版サブスクリプションを作成するビジネスオペレーションはありますか？</font></font><br>
<code>/api/v1/subscriptions/trial.json</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
送金操作はありますか？</font></font><br>
<code>/api/v1/money_transfers.json</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データ中心のAPIを使用したアンチパターンは、実際にはRPCの相互作用も指します。</font><font style="vertical-align: inherit;">たとえば、editAccount（）やeditTicket（）などの一般的すぎるメソッドが存在します。</font><font style="vertical-align: inherit;">「オブジェクトの変更」は、問題領域に関連するセマンティックロードを実行しません。</font><font style="vertical-align: inherit;">つまり、このメソッドは、さまざまな理由で、さまざまな理由で呼び出されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題のある領域にデータの保存、受信、変更のみが含まれる場合は、データ中心のインターフェースでも問題ありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントモデル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードを解く1つの方法は、メッセージキューを介してサービス間の相互作用を整理することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、サービス内でユーザーを登録するときに、ウェルカムレターを送信したり、CRMでクライアントマネージャーにリクエストを作成したりする必要がある場合、外部サービスを呼び出さずに、登録サービスに「ユーザー123が登録されました」というメッセージを入れるのが合理的です。 」、そして必要なすべてのサービスがこのメッセージを読み、必要なアクションを実行します。同時に、ビジネスロジックを変更しても、登録サービスを変更する必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、メッセージがキューにスローされるだけでなく、イベントもスローされます。キューはトランスポートプロトコルにすぎないため、通常の同期インターフェイスと同じ制限がデータインターフェイスに適用されます。したがって、インターフェースの変更や他のサービスでのその後の編集に関する問題を回避するには、イベントをできるだけ問題指向にすることが最善です。それでも、そのようなイベントはしばしばドメインイベントと呼ばれます。同時に、イベントモデルの使用は通常、（マイクロ）サービスが戦う境界に大きな影響を与えません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドメインイベントは実質的に1対1で同期APIメソッドに変換されるため、API呼び出しではなくイベントストリームの代わりにイベントストリームを使用することを提案することもあります（イベントソーシング）。</font><font style="vertical-align: inherit;">イベントのフローにより、常にオブジェクトの状態を復元できますが、履歴も自由です。</font><font style="vertical-align: inherit;">実際、通常、このアプローチはそれほど柔軟ではありません。すべてのイベントをサポートする必要があり、通常のAPIと一緒にストーリーを維持する方が簡単な場合がよくあります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイクロサービスとパフォーマンス。</font><font style="vertical-align: inherit;">CQRS</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原則として、問題の領域は、機能的なビジネス要件だけでなく、機能的なもの（たとえば、パフォーマンス）にも関連するコードの変更を意味します。パフォーマンス要件が異なる2つのコードがある場合、これは、これらの2つのコードを分離することが理にかなっている可能性があることを意味します。そして、それらは通常、タスクに適したさまざまな言語とテクノロジーを使用できるようにするために、別々のサービスに分割されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、複雑な計算を実行するPHPで記述されたサービスには、CPUにバインドされた電卓メソッドがあります。負荷とデータ量の増加に伴い、彼は対処を停止しました。そしてもちろん、オプションの1つとして、phpコードではなく、別の高性能システムデーモンで計算を行うことは理にかなっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パフォーマンスの原則によるサービスの分割の一例として、サービスの読み取りと変更（CQRS）への分離。読み取りサービスと書き込みのパフォーマンス要件が異なるため、このような分離がしばしば提案されます。多くの場合、読み取り負荷は書き込み負荷よりも1桁高くなります。また、読み取り要求の応答速度の要件は、書き込みの場合よりもはるかに高くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントは商品の検索に99％の時間を費やし、注文プロセスには1％の時間しか費やしません。検索状態のクライアントにとって、表示速度は重要であり、フィルターに関連する機能、商品を表示するためのさまざまなオプションなど。したがって、商品の検索、フィルタリング、表示を担当する個別のサービスを強調表示することは理にかなっています。そのようなサービスは、非正規化されたデータを持つドキュメント指向データベースである、ある種のELKで動作する可能性が高いです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、サービスの読み取りと変更を単純に分離することが必ずしも良いとは限りません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例。</font><font style="vertical-align: inherit;">製品の範囲を埋める作業を行うマネージャーの主な機能は、商品を簡単に追加、削除、変更、表示できる機能です。</font><font style="vertical-align: inherit;">負荷がそれほど大きくないので、読み取りと変更を別々のサービスに分けても、サービスを調整して変更する必要がある場合の問題を除いて、そのような分離から何も得られません。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja468991/index.html">モジュラースプライトキャラクターとそのアニメーション</a></li>
<li><a href="../ja468993/index.html">Oculus QuestがPCに接続し、手を見る</a></li>
<li><a href="../ja468995/index.html">オープン性ポリシー：ユーザーがプロジェクトに与える影響</a></li>
<li><a href="../ja468997/index.html">メンタリング-必須または素晴らしいボーナス？</a></li>
<li><a href="../ja468999/index.html">「最も遅い」インターネットを利用している国、および到達困難な地域の状況を修正している国</a></li>
<li><a href="../ja469003/index.html">「人々とそのニーズを解決するための会議」：コミュニティ会議とは何かに関するDevOpsDaysプログラム委員会</a></li>
<li><a href="../ja469005/index.html">オハイオチャレンジャー2Pとその4 KB RAM</a></li>
<li><a href="../ja469007/index.html">RubyRussia2019。代数効果に関するNikita Shilnikov</a></li>
<li><a href="../ja469009/index.html">ソフトウェア開発における貨物カルト</a></li>
<li><a href="../ja469011/index.html">USB Type-Cに関する11の神話</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>