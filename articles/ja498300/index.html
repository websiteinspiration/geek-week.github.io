<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😖 👨🏾‍⚕️ 👨‍👦‍👦 Blitz.Engine：アセットシステム 🧝🏾 🎁 👈🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Blitz.Engine エンジンのアセットシステムがどのように機能するかを理解する前に、アセットシステムとは何か、アセットシステムが正確に何を意味するかを決定する必要があります。 Wikipediaによると、ゲームアセットはデジタルオブジェクトであり、主に同じデータで構成され、ゲームコンテンツの一...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Blitz.Engine：アセットシステム</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498300/"><img src="https://habrastorage.org/webt/yk/rv/sv/ykrvsv2-nadxe5rvvs7gj8iw-9w.jpeg"><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blitz.Engine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
エンジンのアセットシステムがどのように機能するかを理解する前に、アセットシステムとは</font><b><font style="vertical-align: inherit;">何か</font></b><font style="vertical-align: inherit;">、アセットシステムが</font><font style="vertical-align: inherit;">正確に何を意味するかを決定する必要があります。 Wikipediaによると、ゲームアセットはデジタルオブジェクトであり、主に同じデータで構成され、ゲームコンテンツの一部を表し、特定のプロパティを持つ分割できないエンティティです。プログラムモデルの観点から見ると、アセットは、あるデータセットで作成されたオブジェクトとして表示できます。アセットは個別のファイルとして保存できます。次に、資産システムは、さまざまなタイプの資産のロードと操作を担当する多くのプログラムコードです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、アセットシステムはゲームエンジンの大部分を占めており、ゲーム開発者にとって忠実なアシスタントになったり、人生を地獄に変えたりする可能性があります。</font><font style="vertical-align: inherit;">私の観点から、論理的な決定は、この「地獄」を1か所に集中させ、他のチーム開発者を慎重に保護することでした。</font><font style="vertical-align: inherit;">このシリーズの記事で私たちがやったことをお伝えします-行きましょう！</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トピックに関する計画された記事：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要件とアーキテクチャの概要のステートメント</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">資産のライフサイクル</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AssetManagerクラスの詳細な概要</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECSへの統合</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GlobalAssetCache</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要件と理由</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アセットローディングシステムの要件は、岩と堅い場所の間に生まれました。</font><font style="vertical-align: inherit;">アンビルは、外部コードを記述せずに機能するように、それ自体で何かを実行したいという願望でした。</font><font style="vertical-align: inherit;">まあ、またはほとんど外部コードを書かずに。</font><font style="vertical-align: inherit;">ハンマーが現実になった。</font><font style="vertical-align: inherit;">そして、これが私たちが最終的に何をしたかです：</font></font><br>
<br>
<ol>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動メモリ管理</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、アセットのリリース関数を呼び出す必要がないことを意味します。</font><font style="vertical-align: inherit;">つまり、アセットを使用するすべての外部オブジェクトが破棄されるとすぐに、アセットが破棄されます。</font><font style="vertical-align: inherit;">ここでの動機は単純です-少ないコードを記述します。</font><font style="vertical-align: inherit;">コードが少ないほど、エラーが少なくなります。</font></font></li>
<li><i> <b></b>  </i>,           (    AssetManager’a).   ,      .   —      .       ,     «»    .<br>
    ,      ,       ().       —    ,  . ,     ,              .         ,      ,    .        ,   ,    .</li>
<li><i>   </i>      .  :        .         ,         .</li>
<li><i> (shared)  </i>. ,         .  ,    .           «» ,               .</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセットの読み込みを優先し</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">優先レベルは、高、中、低の3つだけです。</font><font style="vertical-align: inherit;">同じ優先度内で、アセットはリクエストの順序で読み込まれます。</font><font style="vertical-align: inherit;">ある状況を想像してみてください。プレーヤーが「戦闘する」をクリックすると、レベルのロードが始まります。</font><font style="vertical-align: inherit;">これに伴い、ロード画面のスプライトを準備するタスクがダウンロードキューに入ります。</font><font style="vertical-align: inherit;">しかし、レベルアセットの一部がスプライトの前にキューに入ったため、プレイヤーはかなり長い間黒い画面を見ます。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、「AssetManagerスレッドで実行できることはすべてAssetManagerスレッドで実行する必要があります」という簡単なルールを独自に作成しました。</font><font style="vertical-align: inherit;">たとえば、高さマップに基づく法線の風景とテクスチャのパーティションの準備、GPUプログラムのリンクなど。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかの実装の詳細</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アセット読み込みシステムの仕組みを理解する前に、Blitz.Engineエンジンで広く使用されている2つのクラスを理解する必要があります。</font></font><br>
<br>
<ul>
<li><code>Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：あるタイプに関するランタイム情報。</font><font style="vertical-align: inherit;">この型は</font></font><code>Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C＃言語の</font><font style="vertical-align: inherit;">型に似</font><font style="vertical-align: inherit;">ていますが、型のフィールドとメソッドへのアクセスを提供しない点が異なります。</font><font style="vertical-align: inherit;">含む：タイプ名、のようないくつかの記号</font></font><code>is_floating, is_pointer, is_const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">など </font><font style="vertical-align: inherit;">このメソッド</font></font><code>Type::instance&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、1回のアプリケーション起動</font></font><code>const Type*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">定数を返します</font><font style="vertical-align: inherit;">。これにより、フォームのチェックを行うことができます</font></font><code>if (type == Type::instance&lt;T&gt;())</code></li>
<li><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：移動可能なタイプまたはコピー可能なタイプの値をパッケージ化できます。</font><font style="vertical-align: inherit;">パッケージ化されているタイプの情報は</font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、constとして格納され</font></font><code>Type*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容に応じてハッシュを計算する方法と、内容が等しいかどうかを比較する方法を知っています。</font><font style="vertical-align: inherit;">途中で、現在のタイプから別のタイプに変換できます。</font><font style="vertical-align: inherit;">これは、標準ライブラリまたはブーストライブラリの任意のクラスを再考したものです。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのアセットリスト読み込みシステムは、3つのクラスに基づいています</font></font><code>AssetManager, AssetBase, IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、これらのクラスの説明に進む前に、外部コード</font></font><code>Asset&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が次のように宣言され</font><font style="vertical-align: inherit;">ているエイリアス</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用していることを述べておく必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs">Asset = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、TはAssetBaseまたは特定のタイプのアセットです。どこでもshared_ptrを使用して、要件番号1（自動メモリ管理）の達成を達成します。</font></font><br>
<br>
<code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これは、相続人のいない有限クラスです。このクラスは、アセットのライフサイクルを定義し、アセットの状態の変化に関するメッセージを送信します。また</font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、アセットとディスク上のファイルにバインドされているアセット間の依存関係ツリーを格納し</font></font><code>FileWatcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、アセットのリロードを</font><font style="vertical-align: inherit;">リッスン</font><font style="vertical-align: inherit;">して実装します。そして最も重要なこと</font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、別のスレッドを起動し、アセットを準備するためのタスクキューを実装し、他のアプリケーションスレッドとのすべての同期をカプセル化します（アセットリクエストは、ダウンロードストリームを含む任意のアプリケーションスレッドから行うことができます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、</font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象的なアセットで動作します</font></font><code>AssetBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、特定のタイプのアセットを作成およびロードするタスクをからの相続人に委任します</font></font><code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これがどのように行われるかについては、後続の記事で詳しく説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要件番号4（アセットの共有）の一環として、最もホットな質問の1つは「アセットIDとして何を使用するか」でした。</font><font style="vertical-align: inherit;">最も簡単で一見明白な解決策は、ダウンロードするファイルへのパスを使用することです。</font><font style="vertical-align: inherit;">ただし、この決定にはいくつかの重大な制限があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセットを作成するには、後者をディスク上のファイルとして表す必要があります。これにより、他のアセットに基づいてランタイムアセットを作成する機能が削除されます。</font></font></li>
<li>    . ,    GPUProgram     (defines).      ,       .</li>
<li>         ,   .</li>
<li>        .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラグラフ3と4は、最初は議論と見なしませんでした。これが役立つかもしれないという考えすらなかったからです。ただし、これらの機能により、エディターの開発が大幅に促進されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、アセットキーを識別子として使用することを決定しました。これは、レベル</font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でtypeによって表され</font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相続人は</font><font style="vertical-align: inherit;">解釈する方法を</font><font style="vertical-align: inherit;">知ってい</font><font style="vertical-align: inherit;">ます</font></font><code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。それ自体</font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、鍵のタイプと相続人の間の関係だけを知っています</font></font><code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。アセットをリクエストするコードは通常、どのタイプのアセットが必要かを知っており、特定のタイプのキーで動作します。それはすべてこのようになります：</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Texture</span>:</span> <span class="hljs-keyword">public</span> AssetBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PathKey</span>
    {</span><font></font>
        FilePath path;<font></font>
        <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">hash</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
        <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> PathKey&amp; other);<font></font>
    };<font></font>
<font></font>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryKey</span>
    {</span>
        u32 width = <span class="hljs-number">1</span>;<font></font>
        u32 height = <span class="hljs-number">1</span>;<font></font>
        u32 level_count = <span class="hljs-number">1</span>;<font></font>
        TextureFormat format = RBGA8;<font></font>
        TextureType type = TEX_2D;<font></font>
        <span class="hljs-function">Vector&lt;Vector&lt;u8*&gt;&gt; data</span>; <span class="hljs-comment">// Face&lt;MipLevels&lt;Image&gt;&gt;</span><font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">hash</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
        <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> MemoryKey&amp; other);<font></font>
    };<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextureSerializer</span>:</span> <span class="hljs-keyword">public</span> IAssetSerializer<font></font>
{<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AssetManager</span> <span class="hljs-title">final</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
    Asset&lt;T&gt; <span class="hljs-title">get_asset</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Any&amp; key, ...)</span></span>;
    <span class="hljs-function">Asset&lt;AssetBase&gt; <span class="hljs-title">get_asset</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Any&amp; key, ...)</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
   ...<font></font>
   <span class="hljs-function">Texture::PathKey <span class="hljs-title">key</span><span class="hljs-params">(<span class="hljs-string">"/path_to_asset"</span>)</span></span>;<font></font>
   Asset&lt;Texture&gt; asset = asset_manager-&gt;get_asset&lt;Texture&gt;(key);<font></font>
   ...<font></font>
<font></font>
   Texture::MemoryKey mem_key;<font></font>
   mem_key.width = <span class="hljs-number">128</span>;<font></font>
   mem_key.format = <span class="hljs-number">128</span>;<font></font>
   mem_key.level_count = <span class="hljs-number">1</span>;<font></font>
   mem_key.format = A8;<font></font>
   mem_key.type = TEX_2D;<font></font>
   Vector&lt;u8*&gt;&amp; mip_chain = mem_key.data.emplace_back();<font></font>
   mip_chain.push_back(generage_sdf_font());<font></font>
   <font></font>
   Asset&lt;Texture&gt; sdf_font_texture = asset_manager-&gt;get_asset&lt;Texture&gt;(mem_key);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"></font><code>hash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部</font><font style="vertical-align: inherit;">
のメソッド</font><font style="vertical-align: inherit;">と比較演算子</font></font><code>PathKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、対応するクラス操作を機能させるために必要ですが、</font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これについては詳しく説明しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、上記のコードで何が発生するか：呼び出し時に、</font></font><code>get_asset(key)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーがタイプの一時オブジェクトにコピーされ、</font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次にそれがメソッドに渡され</font></font><code>get_asset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。次に、</font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引数からキーのタイプを取得します。私たちの場合、それは：</font></font><br>
<br>
<pre><code class="cpp hljs">Type::instance&lt;MyAsset::PathKey&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このタイプにより、彼はシリアライザオブジェクトを見つけ、後続のすべての操作（作成とロード）をシリアライザに委任します。</font></font><br>
<br>
<code>AssetBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これは、エンジン内のすべてのタイプのアセットの基本クラスです。</font><font style="vertical-align: inherit;">このクラスには、アセットキー、アセットの現在の状態（ロード済み、キューイング済みなど）、およびアセットのロードに失敗した場合のエラーテキストが格納されます。</font><font style="vertical-align: inherit;">実際、内部構造はもう少し複雑ですが、これを資産のライフサイクルと一緒に検討します。</font></font><br>
<br>
<code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、その名前が示すように、アセットを準備しているエンティティの基本クラスです。</font><font style="vertical-align: inherit;">実際、このクラスの継承者はアセットをロードするだけではありません。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のタイプのアセットオブジェクトの割り当てと割り当て解除。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のタイプのアセットをロードする。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセットの構築に基づいてファイルパスのリストをコンパイルします。</font><font style="vertical-align: inherit;">このリストは、ファイルが変更されたときのアセットリロードメカニズムに必要です。</font><font style="vertical-align: inherit;">問題が発生します：なぜパスのリストであり、1つのパスではないのですか？</font><font style="vertical-align: inherit;">テクスチャのような単純なアセットは、実際には単一のファイルに基づいて構築できます。</font><font style="vertical-align: inherit;">ただし、シェーダーを見ると、シェーダーテキストが変更された場合だけでなく、シェーダーに接続されているファイルがincludeディレクティブを介して変更された場合にも、再起動が発生することがわかります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセットをディスクに保存しています。</font><font style="vertical-align: inherit;">アセットを編集するときとゲームのアセットを準備するときの両方でアクティブに使用されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サポートするキーのタイプを報告します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、この記事のフレームワークでカバーしたい最後の質問：なぜ1つのシリアライザー/アセットに複数のタイプのキーが必要になるのでしょうか？</font><font style="vertical-align: inherit;">順番に整理しましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのシリアライザー-複数のタイプのキー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アセット</font></font><code>GPUProgram</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（つまり、シェーダー）の</font><font style="vertical-align: inherit;">例を見てみましょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">エンジンにシェーダーをロードするには、次の情報が必要です。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェーダーファイルへのパス。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プリプロセッサ定義のリスト。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェーダーがアセンブルおよびコンパイルされるステージ（頂点、フラグメント、計算）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エントリポイントの名前。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この情報を一緒に収集して、ゲームで使用されるシェーダーキーを取得します。ただし、ゲームまたはエンジンの開発中は、画面にデバッグ情報を表示する必要がある場合があり、特定のシェーダーが使用される場合もあります。この状況では、シェーダーのテキストをコードに直接書き込むと便利です。これを行うには、2番目のタイプのキーを取得します。これには、ファイルへのパスの代わりに、プリプロセッサ定義のリストにシェーダーのテキストが含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の例を考えてみましょう：テクスチャ。テクスチャを作成する最も簡単な方法は、ディスクからロードすることです。これを行うには、ファイルへのパス（</font></font><code>PathKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">が必要</font><font style="vertical-align: inherit;">です。ただし、テクスチャのコンテンツをアルゴリズムで生成し、バイトの配列からテクスチャを作成することもできます（</font></font><code>MemoryKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。 3番目のタイプのキーは、</font></font><code>RenderTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テクスチャ</font><font style="vertical-align: inherit;">を作成するためのキーにすることができます</font><font style="vertical-align: inherit;">（</font></font><code>RTKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーの種類に応じて、stb（StbFontKey）、FreeType（FTFontKet）、または自己署名された署名付き距離フィールドフォントジェネレーター（SDFFontKey）など、さまざまなグリフラスタライズエンジンを使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーフレームアニメーションは、ロード（</font></font><code>PathKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）またはコードによって生成</font><font style="vertical-align: inherit;">（</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">できます</font></font><code>MemoryKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのアセット-複数のタイプのキー</font></font></h3><br><font style="vertical-align: inherit;"></font><code>ParticleEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">粒子生成のルールを説明</font><font style="vertical-align: inherit;">
する</font><font style="vertical-align: inherit;">資産</font><font style="vertical-align: inherit;">があると想像してください</font><font style="vertical-align: inherit;">。さらに、このアセットには便利なエディターがあります。同時に、レベルエディターとパーティクルエディターは1つのマルチウィンドウアプリケーションです。これは、エフェクト自体を編集しながら、レベルを開いてその中にパーティクルのソースを配置し、レベルの環境でエフェクトを確認できるので便利です。キーのタイプが1つの場合、エフェクト編集の世界とレベルの世界で使用されるエフェクトオブジェクトはまったく同じです。エフェクトエディターで行われたすべての変更は、すぐにレベルに表示されます。一見すると、これはクールなアイデアに思えるかもしれませんが、次のシナリオを見てみましょう。</font></font><br>
<br>
<ol>
<li>    ,   ,    ,    .   ,            . </li>
<li>-       ,    .        ,            .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、2つの異なるタイプのキーを使用して、ディスク上の1つのファイルから2つの異なるタイプのアセットを作成する状況も考えられます。</font><font style="vertical-align: inherit;">「ゲーム」タイプのキーを使用して、ゲームでの迅速な作業に最適化されたデータ構造を作成します。</font><font style="vertical-align: inherit;">「編集」タイプのキーを使用して、編集に便利なデータ構造を作成します。</font><font style="vertical-align: inherit;">このようにして、エディタ</font></font><code>BlendTree</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は骨格アニメーションの</font><font style="vertical-align: inherit;">編集</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">実装し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">あるタイプのキーに基づいて、アセットシステムは内部に正直なツリーとトポロジの変更に関する信号の束を備えたアセットを構築します。これは編集時には非常に便利ですが、ゲームではゆっくりです。</font><font style="vertical-align: inherit;">別のタイプのキーを使用して、シリアライザーは別のタイプのアセットを作成します。アセットにはツリーを変更するメソッドがなく、ツリー自体はノードの配列に変換されます。ノードへのリンクは配列内のインデックスです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エピローグ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まとめると、私はあなたの注意を、エンジンのさらなる開発に最も影響を与えたソリューションに集中したいと思います。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイルパスではなく、カスタム構造をアセットキーとして使用する。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセットは非同期モードでのみロードされます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセット共有を管理するための柔軟なスキーム（1つのアセット-複数のタイプのキー）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なるデータソースを使用して同じタイプのアセットを受信する機能（1つのシリアライザーで複数のタイプのキーをサポート）。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のシリーズでは、これらの決定が内部コードと外部コードの両方の実装にどのように影響したかを学びます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
著者：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エクスミックス</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja498290/index.html">手続き型水文学：川と湖の動的シミュレーション</a></li>
<li><a href="../ja498292/index.html">PostgreSQLで大量にお金を節約する</a></li>
<li><a href="../ja498294/index.html">オブジェクト検出 認識し、支配する。パート1</a></li>
<li><a href="../ja498296/index.html">システムレベルでの設計。パート1.アイデアからシステムへ</a></li>
<li><a href="../ja498298/index.html">企業はバグ報奨金を使用してハッカーの沈黙を購入</a></li>
<li><a href="../ja498302/index.html">ILO Advancedライセンス。なぜ今必要なのですか？</a></li>
<li><a href="../ja498304/index.html">Ansibleを使用したVMware vSphere API管理タスクの自動化</a></li>
<li><a href="../ja498308/index.html">グローバル極値を見つけるためのPython遺伝的アルゴリズム</a></li>
<li><a href="../ja498310/index.html">機械学習の3つの落とし穴とその回避方法</a></li>
<li><a href="../ja498312/index.html">モデル指向設計を使用した航空機の電気ネットワークの開発</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>