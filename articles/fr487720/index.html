<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👩‍👦‍👦 👂🏽 ♦️ Sur le corutinisme concurrentiel (en utilisant la programmation réactive comme exemple) 👨🏽‍🚒 🤴🏾 🔍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introduction
 La compétition pour les esprits, les humeurs et les aspirations des programmeurs est, il me semble, une tendance moderne dans le déve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Sur le corutinisme concurrentiel (en utilisant la programmation réactive comme exemple)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487720/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Introduction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La compétition pour les esprits, les humeurs et les aspirations des programmeurs est, il me semble, une tendance moderne dans le développement de la programmation. Quand presque rien n'est proposé, bien que sous le slogan de la lutte pour cela. Il est très, très difficile de reconnaître dans l'écrasement des paradigmes logiciels quelque chose de nouveau, qui s'avère en fait souvent assez connu et parfois simplement dépassé. Tout est «emporté» par les délices terminologiques, l'analyse détaillée et les exemples multilignes dans de nombreux langages de programmation. Dans le même temps, les demandes d'ouverture et / ou de réflexion sur le fond de la solution, l'essence des innovations sont obstinément évitées, les tentatives de savoir combien cela est nécessaire et ce qui en fin de compte, qui distingue qualitativement l'innovation des approches et des outils de programmation déjà connus, sont contrecarrées à l'œuf.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je suis apparu sur Habré, comme on l'a bien vu dans l'une des discussions, après un certain gel. Ça ne me dérange même pas. Du moins, l'impression, apparemment, n'est que cela. Par conséquent, je suis d'accord, je l'avoue, même si, si c'est ma faute, ce n'est que partiellement. J'avoue, je vis des idées sur la programmation parallèle, formées dans les années 80 du siècle dernier. Antiquité? Peut être. Mais dites-moi ce qu'il y a de nouveau, à propos duquel la science de la programmation [parallèle] ne serait pas déjà connue à l'époque (voir détails [1]). À cette époque, les programmes parallèles étaient divisés en deux classes - parallèle-série et asynchrone. Si les premiers étaient déjà considérés comme archaïques, alors les seconds - avancés et vraiment parallèles. Parmi ces derniers, la programmation avec contrôle des événements (ou simplement la programmation des événements), le contrôle des flux et la programmation dynamique ont été distingués.C'est tout en général. Plus de détails déjà.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et qu'offre la programmation actuelle en plus de ce qui est déjà connu il y a au moins 40 ans? Dans mon "regard gelé" - rien. Les coroutines, comme il s'est avéré, sont maintenant appelées coroutines ou même goroutines; les termes concurrence et concurrence entrent dans une stupeur, semble-t-il, pas seulement des traducteurs. Et il n'y a pas de tels exemples. Par exemple, quelle est la différence entre la programmation réactive (RP) et la programmation d'événements ou le streaming? À laquelle des catégories et / ou classifications connues appartient-il? Personne ne semble intéressé par cela, et personne ne peut le clarifier. Ou pouvez-vous maintenant classer par nom? Alors, en effet, les coroutines et les coroutines sont des choses différentes, et la programmation parallèle est simplement obligée de différer de la concurrence. Et les machines d'état? De quel genre de technique miracle s'agit-il?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les «spaghettis» dans la tête proviennent de l'oubli de la théorie où, lorsqu'un nouveau modèle est introduit, il est comparé à des modèles déjà connus et bien étudiés. </font><font style="vertical-align: inherit;">Si cela se fera bien, mais au moins vous pouvez le découvrir, car le processus est formalisé. </font><font style="vertical-align: inherit;">Mais comment aller au fond des choses si vous donnez un nouveau surnom aux coroutines puis choisissez le «code de capot moteur» simultanément en cinq langues, évaluant en outre la perspective de migration vers les streams. </font><font style="vertical-align: inherit;">Et ce ne sont que des coroutines, qui, franchement, devraient déjà être oubliées en raison de leur nature élémentaire et de leur faible utilisation (il s'agit bien sûr de mon expérience).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Programmation réactive et tout, tout, tout</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous ne nous fixerons pas l'objectif de bien comprendre le concept de «programmation réactive», même si nous prendrons «l'exemple réactif» comme base pour une discussion plus approfondie. </font><font style="vertical-align: inherit;">Son modèle formel sera créé sur la base du modèle formel bien connu. </font><font style="vertical-align: inherit;">Et cela, je l'espère, nous permettra de comprendre clairement, avec précision et en détail l'interprétation et le fonctionnement du programme original. </font><font style="vertical-align: inherit;">Mais dans quelle mesure le modèle créé et sa mise en œuvre seront «réactifs», c'est aux apologistes de ce type de programmation de décider. </font><font style="vertical-align: inherit;">Pour le moment, il suffira pour l'instant que le nouveau modèle devra implémenter / modéliser toutes les nuances de l'exemple d'origine. </font><font style="vertical-align: inherit;">Si quelque chose n'est pas pris en compte, alors j'espère qu'il y a ceux qui me corrigent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, dans [2], un exemple de programme réactif a été considéré, dont le code est montré dans le Listing 1.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 1. Code de programme réactif</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">1. 1 = 2 <font></font>
2. 2 = 3 <font></font>
3. 3 = 1 + 2 <font></font>
4.  1, 2, 3 <font></font>
5. 1 = 4 <font></font>
6.  1, 2, 3</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le monde de la programmation réactive, le résultat de son travail sera différent du résultat d'un programme régulier du même genre. Cela seul est mauvais, pour ne pas dire laideur, car Le résultat du programme doit être sans ambiguïté et ne pas dépendre de la mise en œuvre. Mais plus confond l'autre. Premièrement, en apparence, il n'est guère possible de distinguer un code similaire régulier d'un code réactif. Deuxièmement, apparemment, l'auteur lui-même n'est pas entièrement sûr du travail du programme réactif, parlant du résultat «très probablement». Et troisièmement, lequel des résultats est considéré comme correct?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une telle ambiguïté dans l'interprétation du code a conduit au fait qu'il n'est pas immédiatement possible de le «couper». </font><font style="vertical-align: inherit;">Mais alors, comme cela arrive souvent, tout s'est avéré être beaucoup plus simple que ce à quoi on aurait pu s'attendre. </font><font style="vertical-align: inherit;">La figure 1 montre deux diagrammes structurels qui, espérons-le, correspondent à la structure et expliquent le fonctionnement de l'exemple. </font><font style="vertical-align: inherit;">Dans le diagramme supérieur, les blocs X1 et X2 organisent la saisie des données, signalant au bloc X3 leur modification. </font><font style="vertical-align: inherit;">Ce dernier effectue la sommation et permet au bloc Pr d'imprimer les valeurs actuelles des variables. </font><font style="vertical-align: inherit;">Après avoir imprimé, le bloc Pr signale au bloc X3, d'ailleurs, à lui et seulement à lui qu'il est prêt à imprimer de nouvelles valeurs.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. </font><font style="vertical-align: inherit;">1. Deux modèles structurels de l'exemple</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/tw/hs/rq/twhsrqxfdfuyxi4txtd9ciat6hs.jpeg" alt="image"><br>
</div></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxième schéma, par rapport au premier, est assez élémentaire. Dans le cadre d'un seul bloc, il entre des données et implémente séquentiellement: 1) le calcul de la somme des données d'entrée et 2) leur impression. Le remplissage interne du bloc à ce niveau de présentation n'est pas divulgué. Bien que l'on puisse dire qu'au niveau structurel, il peut s'agir d'une «boîte noire comprenant un schéma à quatre blocs. Mais encore, son appareil [algorithmique] est censé être différent. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commentaire. L'approche du programme comme une boîte noire reflète essentiellement l'attitude de l'utilisateur à son égard. Ce dernier ne s'intéresse pas à sa mise en œuvre, mais au résultat des travaux. Qu'il s'agisse d'un programme réactif, d'un programme événementiel ou d'un autre, mais le résultat conforme à la théorie des algorithmes doit être sans ambiguïté et prévisible.</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En figue. </font><font style="vertical-align: inherit;">2 présente des modèles algorithmiques qui clarifient en détail la structure interne [algorithmique] des blocs de circuits. </font><font style="vertical-align: inherit;">Le modèle supérieur est représenté par un réseau d'automates, où chacun des automates est un modèle algorithmique d'un bloc séparé. </font><font style="vertical-align: inherit;">Les connexions entre les automates représentées par des arcs en pointillés correspondent aux connexions du circuit. </font><font style="vertical-align: inherit;">Un modèle à un seul automate décrit l'algorithme de fonctionnement d'un schéma fonctionnel composé d'un bloc (voir un bloc Pr séparé sur la figure 1).</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. </font><font style="vertical-align: inherit;">2. Modèles algorithmiques pour les schémas structurels</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/rj/4f/ds/rj4fdsx8kekihnbqqebmpji1y9e.jpeg" alt="image"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les automates X1 et X2 (les noms des automates et des blocs coïncident avec les noms de leurs variables), détectent les changements et, si l'automate X3 est prêt à effectuer l'opération d'addition (dans l'état "s0"), passez dans l'état "s1" en se souvenant de la valeur actuelle de la variable. La machine X3, ayant reçu l'autorisation d'entrer dans l'état "s1", effectue l'opération d'addition et, si nécessaire, attend la fin de l'impression des variables. «Machine d'impression» Pr, ayant terminé l'impression, revient à l'état initial «p0», où il attend la commande suivante. Notez que son état "p1" démarre une chaîne de transitions inverses - l'automate X3 à l'état "s0", et X1 et X2 à l'état "s0". Après cela, l'analyse des données d'entrée, puis leur sommation et leur impression ultérieure sont répétées.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comparé au réseau d'automates, l'algorithme d'un automate Pr séparé est assez simple, mais, notons-le, fait le même travail et peut-être même plus rapidement. </font><font style="vertical-align: inherit;">Ses prédicats révèlent un changement de variables. </font><font style="vertical-align: inherit;">Dans ce cas, le passage à l'état «p1» est effectué au début de l'action y1 (voir Fig. 2), qui résume les valeurs actuelles des variables, tout en les mémorisant. </font><font style="vertical-align: inherit;">Ensuite, lors d'une transition inconditionnelle de l'état "p1" à l'état "p0", l'action y2 imprime les variables. </font><font style="vertical-align: inherit;">Après cela, le processus revient à l'analyse des données d'entrée. </font><font style="vertical-align: inherit;">Le code d'implémentation du dernier modèle est indiqué dans le Listing 2.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 2. Implémentation de l'automate Pr</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span>
<span class="hljs-keyword">extern</span> LArc TBL_PlusX3[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FPlusX3</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FPlusX3(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FPlusX3(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_PlusX3, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarY;        		<span class="hljs-comment">// </span>
    CVar *pVarX1;        		<span class="hljs-comment">// </span>
    CVar *pVarX2;        		<span class="hljs-comment">// </span>
    CVar *pVarX3;        		<span class="hljs-comment">// </span>
    CVar *pVarStrNameX1;		<span class="hljs-comment">//   X1</span>
    CVar *pVarStrNameX2;		<span class="hljs-comment">//   X2</span>
    CVar *pVarStrNameX3;		<span class="hljs-comment">//   X3</span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pVarX2 &amp;&amp; pVarX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };
    <span class="hljs-keyword">double</span> dSaveX1{<span class="hljs-number">0</span>};
    <span class="hljs-keyword">double</span> dSaveX2{<span class="hljs-number">0</span>};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fplusx3.h"</span></span><font></font>
<font></font>
LArc TBL_PlusX3[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x2"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p1"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"--"</span>,  <span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FPlusX3::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"strY"</span>, CLocVar::vtString, <span class="hljs-string">"print of output string"</span>);			<span class="hljs-comment">//  </span>
    pVarX1 = CreateLocVar(<span class="hljs-string">"dX1"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarX2 = CreateLocVar(<span class="hljs-string">"dX2"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarX3 = CreateLocVar(<span class="hljs-string">"dX3"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX3 = CreateLocVar(<span class="hljs-string">"strNameX3"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;<font></font>
    str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    str = pVarStrNameX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    str = pVarStrNameX3-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX3 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPlusX3::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1-&gt;GetDataSrc() != dSaveX1; }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPlusX3::x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX2-&gt;GetDataSrc() != dSaveX2; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FPlusX3::y1</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// X3 = X1 + X2</span>
    <span class="hljs-keyword">double</span> dX1 = pVarX1-&gt;GetDataSrc(); <span class="hljs-keyword">double</span> dX2 = pVarX2-&gt;GetDataSrc();
    <span class="hljs-keyword">double</span> dX3 = dX1 + dX2;<font></font>
    pVarX3-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, dX3);<font></font>
    dSaveX1 = dX1; dSaveX2 = dX2;<font></font>
<span class="hljs-comment">//  1, 2, 3</span><font></font>
    QString strX1; strX1.setNum(dX1); QString strX2; strX2.setNum(dX2);<font></font>
    QString strX3; strX3.setNum(dX3);<font></font>
    QString qstr = <span class="hljs-string">"X1="</span> + strX1 + <span class="hljs-string">", X2="</span> + strX2 + <span class="hljs-string">", X3="</span> + strX3;<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, qstr.toStdString(), <span class="hljs-literal">nullptr</span>);<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La quantité de code est clairement incomparablement plus grande que l'exemple d'origine. Mais, notez, pas un seul code. La nouvelle solution supprime tous les problèmes de fonctionnement, ne permettant pas de se heurter à des fantasmes dans l'interprétation du programme. Un exemple qui semble compact et élégant, mais dont vous pouvez dire «très probablement», ne provoque pas, disons, d'émotions positives et le désir de travailler avec. Il faut aussi noter qu'il faut comparer effectivement avec l'action de l'automate y1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le reste du code est lié aux exigences de "l'environnement automatique", qui, je le note, n'est pas énoncé dans le code source. Ainsi, la méthode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FCreationOfLinksForVariables</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la </font><font style="vertical-align: inherit;">classe d'automate de base </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LFsaAppl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crée des variables locales pour la machine et les relie à celles-ci lorsque, au niveau de l'environnement VKPA, les noms symboliques des autres variables d'environnement qui leur sont associées sont indiqués. La première fois qu'il démarre lors de la création d'un automate, puis dans le cadre de la méthode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FInit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (voir étape y12), car tous les liens ne sont pas connus lors de la création d'un objet. La machine sera dans l'état "st" jusqu'à ce que tous les liens nécessaires que les vérifications de prédicat x12 soient initialisés. Une référence à une variable, si son nom lui est renvoyé, renvoie la méthode GetAddressVar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour supprimer d'éventuelles questions, nous vous présentons le code du réseau d'automates. </font><font style="vertical-align: inherit;">Il est montré dans le Listing 3 et inclut le code de trois classes d'automates. </font><font style="vertical-align: inherit;">C'est sur leur base que de nombreux objets sont créés qui correspondent au schéma structurel du réseau représenté sur la Fig. </font><font style="vertical-align: inherit;">1. Notez que les objets X1 et X2 sont dérivés de la classe générale FSynch.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3. Classes de réseau automatisées</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_Synch[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSynch</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dGetData</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX-&gt;GetDataSrc(); };
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FSynch(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FSynch(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_Synch, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarX;			<span class="hljs-comment">// </span>
    CVar *pVarStrNameX;		<span class="hljs-comment">//   </span>
    CVar *pVarStrNameObject;<span class="hljs-comment">//  -</span>
    LFsaAppl *pL {<span class="hljs-literal">nullptr</span>};
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX-&gt;GetDataSrc() != dSaveX; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pL-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pL != <span class="hljs-literal">nullptr</span>; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span> </span>{ dSaveX = pVarX-&gt;GetDataSrc(); }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };
    <span class="hljs-keyword">double</span> dSaveX{<span class="hljs-number">0</span>};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
LArc TBL_Synch[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x2"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FSynch::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX = CreateLocVar(<span class="hljs-string">"x"</span>, CLocVar::vtDouble, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameX = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameObject = CreateLocVar(<span class="hljs-string">"strNameObject"</span>, CLocVar::vtString, <span class="hljs-string">"name of function"</span>);                   <span class="hljs-comment">//  </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">if</span> (pVarStrNameX) {<font></font>
        str = pVarStrNameX-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    str = pVarStrNameObject-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pL = FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_X1X2X3[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FX1X2X3</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dGetData</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX3-&gt;GetDataSrc(); };
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FX1X2X3(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FX1X2X3(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_X1X2X3, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarX1{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarX2{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarX3{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarStrNameFX1;		<span class="hljs-comment">//  X1</span>
    CVar *pVarStrNameFX2;		<span class="hljs-comment">//  X2</span>
    CVar *pVarStrNameFPr;		<span class="hljs-comment">//  Pr</span>
    CVar *pVarStrNameX3;		<span class="hljs-comment">//   </span>
    FSynch *pLX1 {<span class="hljs-literal">nullptr</span>};<font></font>
    FSynch *pLX2 {<span class="hljs-literal">nullptr</span>};<font></font>
    LFsaAppl *pLPr {<span class="hljs-literal">nullptr</span>};
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX1-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX2-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x3</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLPr-&gt;FGetState() == <span class="hljs-string">"p1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLPr != <span class="hljs-literal">nullptr</span> &amp;&amp; pLX1 &amp;&amp; pLX2 &amp;&amp; pVarX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span> </span>{ pVarX3-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, pLX1-&gt;dGetData() + pLX2-&gt;dGetData()); }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };<font></font>
};<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fx1x2x3.h"</span></span><font></font>
<font></font>
LArc TBL_X1X2X3[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x2"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x3"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FX1X2X3::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX3 = CreateLocVar(<span class="hljs-string">"x"</span>, CLocVar::vtDouble, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameFX1 = CreateLocVar(<span class="hljs-string">"strNameFX1"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameFX2 = CreateLocVar(<span class="hljs-string">"strNameFX2"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameFPr = CreateLocVar(<span class="hljs-string">"strNameFPr"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameX3 = CreateLocVar(<span class="hljs-string">"strNameX3"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str; str = pVarStrNameFX1-&gt;strGetDataSrc();
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX1 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX2 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFPr-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLPr = FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_Print[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FX1X2X3</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FPrint</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FPrint(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FPrint(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_Print, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarY;        		<span class="hljs-comment">// </span>
    CVar *pVarStrNameFX1;		<span class="hljs-comment">//    X1</span>
    CVar *pVarStrNameFX2;		<span class="hljs-comment">//    X2</span>
    CVar *pVarStrNameFX3;		<span class="hljs-comment">//    X3</span>
    FSynch *pLX1 {<span class="hljs-literal">nullptr</span>};     <span class="hljs-comment">//    X1</span>
    FSynch *pLX2 {<span class="hljs-literal">nullptr</span>};     <span class="hljs-comment">//    X2</span>
    FX1X2X3 *pLX3 {<span class="hljs-literal">nullptr</span>};    <span class="hljs-comment">//    X3</span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX3 != <span class="hljs-literal">nullptr</span> &amp;&amp; pLX1 &amp;&amp; pLX2 &amp;&amp; pLX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };<font></font>
};<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fprint.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fx1x2x3.h"</span></span><font></font>
<font></font>
LArc TBL_Print[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p1"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FPrint::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"strY"</span>, CLocVar::vtString, <span class="hljs-string">"print of output string"</span>);			<span class="hljs-comment">//  </span>
    pVarStrNameFX1 = CreateLocVar(<span class="hljs-string">"strNameFX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameFX2 = CreateLocVar(<span class="hljs-string">"strNameFX2"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(x2)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameFX3 = CreateLocVar(<span class="hljs-string">"strNameFX3"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(pr)"</span>);			<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;<font></font>
    str = pVarStrNameFX1-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX1 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX2 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX3-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX3 = (FX1X2X3*)FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPrint::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX3-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FPrint::y1</span><span class="hljs-params">()</span> </span>{<font></font>
    QString strX1; strX1.setNum(pLX1-&gt;dGetData());<font></font>
    QString strX2; strX2.setNum(pLX2-&gt;dGetData());<font></font>
    QString strX3; strX3.setNum(pLX3-&gt;dGetData());<font></font>
    QString qstr = <span class="hljs-string">"X1="</span> + strX1 + <span class="hljs-string">", X2="</span> + strX2 + <span class="hljs-string">", X3="</span> + strX3;<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, qstr.toStdString(), <span class="hljs-literal">nullptr</span>);<font></font>
}<font></font>
</code></pre> <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce code est différent du Listing 1, comme une photo d'un avion de sa documentation de conception. Mais, je pense, nous sommes principalement des programmeurs, et, aucune infraction ne leur sera dite, certains designers. Notre «code de conception» doit être facile à comprendre et à interpréter sans ambiguïté afin que notre «avion» ne s'écrase pas lors du premier vol. Et si un tel malheur arrivait, et avec les programmes, cela se produit plus souvent qu'avec les avions, alors la raison peut être trouvée facilement et rapidement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, en considérant le Listing 3, vous devez imaginer que le nombre de classes n'est pas directement lié au nombre d'objets correspondants dans le programme parallèle. Le code ne reflète pas la relation entre les objets, mais contient les mécanismes qui les créent. Ainsi, la classe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSynch</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contient un pointeur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vers un objet de type</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LFsaAppl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Le nom de cet objet est déterminé par une variable locale, qui dans l'environnement VKPa correspondra à une variable automate avec le nom </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strNameObject</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Un pointeur est nécessaire pour utiliser la méthode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FGetState pour</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> surveiller l'état actuel d'un objet automate de type </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSynch</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (voir le code de prédicat x2). Des pointeurs similaires aux objets, des variables pour spécifier les noms des objets et des prédicats nécessaires à l'organisation des relations contiennent d'autres classes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, quelques mots sur la «construction» d'un programme parallèle dans l'environnement VKPA. Il est créé lors du chargement de la configuration du programme. Dans ce cas, les premiers objets sont créés à partir de classes issues de bibliothèques thématiques dynamiques de type automate (leur ensemble est déterminé par la configuration de l'application / du programme). Les objets créés sont identifiés par leurs noms (appelons-les </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables automatiques</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Ensuite, les valeurs nécessaires sont écrites dans les variables locales des automates. </font><font style="vertical-align: inherit;">Dans notre cas, les variables avec un type de chaîne sont définies sur les noms de variables d'autres objets et / ou les noms des objets. </font><font style="vertical-align: inherit;">De cette façon, les connexions entre les objets d'un programme d'automate parallèle sont établies (voir Fig. 1). </font><font style="vertical-align: inherit;">De plus, en modifiant les valeurs des variables d'entrée (en utilisant des boîtes de dialogue de contrôle d'objet individuelles ou les boîtes de dialogue standard / environnement pour définir les valeurs des variables d'environnement), nous fixons le résultat. </font><font style="vertical-align: inherit;">Il peut être vu à l'aide d'une boîte de dialogue d'environnement standard pour afficher les valeurs des variables.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. À l'analyse des programmes parallèles</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Concernant le fonctionnement d'un programme parallèle, à moins qu'il ne soit assez simple séquentiellement parallèle, il est très, très difficile de dire quelque chose de concret. Le réseau d'automates considéré ne fait pas exception. Ensuite, nous verrons cela, en comprenant ce que l'on peut en attendre.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'automate résultant et le réseau pour lequel il est construit sont illustrés à la Fig. </font><font style="vertical-align: inherit;">3. Depuis le réseau de la Fig. </font><font style="vertical-align: inherit;">2, en plus de renommer ses éléments - automates, signaux d'entrée et de sortie, il se distingue par l'absence d'une «machine d'impression» de variables. </font><font style="vertical-align: inherit;">Ce dernier n'est pas indispensable pour le fonctionnement du réseau, et le renommage vous permet d'utiliser l'opération de composition pour construire l'automate résultant. </font><font style="vertical-align: inherit;">De plus, pour créer des noms plus courts, un codage a été introduit lorsque, par exemple, l'état "a0" de l'automate A est représenté par le symbole "0", et "a1" par le symbole "1". </font><font style="vertical-align: inherit;">De même pour les autres machines. </font><font style="vertical-align: inherit;">Dans ce cas, l'état des composants du réseau, par exemple «a1b0c1», est affecté du nom «101». </font><font style="vertical-align: inherit;">De même, des noms sont formés pour tous les états des composants du réseau, dont le nombre est déterminé par le produit des états des automates des composants.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure. </font><font style="vertical-align: inherit;">3. L'automate réseau résultant</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/a8/oc/9k/a8oc9kfwbbm3apemxhjzpbz5mxw.jpeg" alt="image"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 L'automate résultant peut, bien sûr, être calculé de manière purement formelle, mais pour cela, nous avons besoin d'une «calculatrice» appropriée. Mais si ce n'est pas le cas, vous pouvez utiliser un algorithme intuitif assez simple. Dans son cadre, l'un ou l'autre état des composants du réseau est enregistré puis, en triant toutes les situations d'entrée possibles, les états des composants cibles sont déterminés par des «poignées». Ainsi, après avoir fixé l'état "000" correspondant aux états actuels des automates composants - "a0", "b0", "c0", les transitions pour les conjonctions des variables d'entrée ^ x1 ^ x2, ^ x1x2, x1 ^ x2, x1x2 sont déterminées. Nous obtenons les transitions respectivement dans indique "a0b0c0", "a0b1c0", "a1b0c0", "a1b1c0", qui sont marqués "000", "010", "100" et "110" sur la machine résultante. bouclesqui ne sont pas chargés d'actions peuvent être exclus du graphique.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce que nous avons "dans le résidu sec". Nous avons atteint l'essentiel - nous avons reçu l'automate résultant, qui décrit avec précision le fonctionnement du réseau. Nous avons découvert que sur huit états de réseau possibles, un est inaccessible (isolé) - état «001». Cela signifie que l'opération de sommation ne sera en aucun cas déclenchée pour les variables d'entrée qui n'ont pas modifié la valeur actuelle.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce qui est inquiétant, même si les tests n'ont pas révélé d'erreurs. Sur le graphique de l'automate résultant, des transitions conflictuelles dans les actions de sortie ont été trouvées. Ils sont marqués par une combinaison des actions y1y3 et y2y3. Les actions y1 et y2 sont déclenchées lorsque les données d'entrée changent, puis une autre action y3 calcule la somme des variables en parallèle avec elles. Sur quelles valeurs fonctionnera-t-elle - ancienne ou simplement changée par de nouvelles? Pour éliminer l'ambiguïté, vous pouvez simplement modifier les actions de y3 et y4. Dans ce cas, leur code sera le suivant: X3 = X1Sav + X2Sav et imprimer (X1Sav, X2Sav, X3).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc. </font><font style="vertical-align: inherit;">La construction de l'automate résultant a révélé des problèmes évidents dans le modèle parallèle créé. </font><font style="vertical-align: inherit;">Qu'ils apparaissent dans le programme réactif est une question. </font><font style="vertical-align: inherit;">Tout dépendra, apparemment, de l'approche de la mise en œuvre du parallélisme dans le paradigme réactif. </font><font style="vertical-align: inherit;">Dans tous les cas, une telle dépendance doit être prise en compte et en quelque sorte éliminée. </font><font style="vertical-align: inherit;">Dans le cas d'un réseau automatisé, il est plus facile de quitter la version modifiée que d'essayer de changer le réseau. </font><font style="vertical-align: inherit;">Ce n'est pas grave si les «anciennes» données qui ont déclenché le fonctionnement du réseau sont imprimées en premier, puis les données actuelles sont imprimées ensuite.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Conclusions </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chacune des solutions envisagées a ses avantages et ses inconvénients. Le premier est très simple, le réseau est plus compliqué, et créé à partir d'une seule machine, il ne commencera à analyser les données d'entrée qu'après sa visualisation. En raison de son parallélisme, le même réseau automatique commencera l'analyse des données d'entrée avant la fin de la procédure d'impression. Et si le temps de visualisation est long, mais ce sera le cas contre l'opération de sommation, alors le réseau sera plus rapide du point de vue du contrôle d'entrée. Ceux. une évaluation basée sur une estimation de la quantité de code dans le cas de programmes parallèles n'est pas toujours objective. En termes plus simples, le réseau est parallèle, la solution à un composant est largement séquentielle (ses prédicats et ses actions sont parallèles). Et nous parlons tout d'abord de programmes parallèles.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le modèle de réseau est également un exemple de solution flexible. Premièrement, les composants peuvent être conçus indépendamment les uns des autres. Deuxièmement, tout composant peut être remplacé par un autre. Et troisièmement, tout composant réseau peut être un élément d'une bibliothèque de processus automatiques et est utilisé dans une autre solution réseau. Et ce ne sont que les avantages les plus évidents d'une solution parallèle.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais revenons à une programmation réactive. RP considère-t-il que toutes les instructions de programme sont initialement parallèles? On peut seulement supposer que sans cela, il est difficile de parler d'un paradigme de programmation «orienté vers les flux de données et la propagation des changements» (voir la définition de la programmation réactive dans [3]). Mais alors quelle est sa différence par rapport à la programmation avec contrôle de streaming (pour plus de détails, voir [1])? Nous revenons donc à notre point de départ: comment classer la programmation réactive dans le cadre de classifications bien connues? Et, si RP est une programmation spéciale, qu'est-ce qui est différent des paradigmes de programmation connus?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, sur la théorie. Sans cela, l'analyse d'algorithmes parallèles ne serait pas seulement difficile, voire impossible. Dans le processus d'analyse, des problèmes sont parfois identifiés qui, même avec un regard attentif et réfléchi sur le programme, comme, accessoirement, sur le «document de conception», sont impossibles à deviner. En tout cas, je suis pour le fait que les avions, au figuré comme dans tout autre sens, ne plantent pas. C'est moi au fait que, bien sûr, vous devez viser la simplicité et la grâce de la forme, mais sans perte de qualité. Nous, programmeurs, ne nous contentons pas de «dessiner» des programmes, mais nous contrôlons souvent ce qui y est caché, y compris par les avions!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oui, j'ai presque oublié. Je classerais la programmation automatique (AP) comme une programmation avec contrôle dynamique. Quant à l'asynchronie - je parie. Étant donné que la base du modèle de contrôle AP est un réseau en un seul instant, c'est-à-dire réseaux synchrones d'automates, alors il est synchrone. Mais puisque l'environnement VKPa implémente également de nombreux réseaux à travers le concept de «mondes d'automates», il est complètement asynchrone. En général, je suis contre tout cadre de classification très rigide, mais pas pour l'anarchie. En ce sens, en VKPa, j'espère qu'un certain compromis a été trouvé entre la rigidité de la programmation série-parallèle et un certain anarchisme asynchrone. Étant donné que la programmation automatique couvre également la classe des programmes d'événements (voir [4]) et que les programmes de flux y sont facilement modélisés,de quelle programmation pouvez-vous encore rêver? Bien sûr - pour moi.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Littérature</font></font></b><div class="spoiler_text">1.   /.. , .. , .. , .. ;  . .. . – .:   , 1983. – 240.<br>
2.      . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habr.com/ru/post/486632</a> . . . (  07.02.2020).<br>
3.  . . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ru.wikipedia.org/wiki/_</a> . . . (  07.02.2020).<br>
4.  —  ? [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habr.com/ru/post/483610</a> . . . (  07.02.2020).<br>
</div></div></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr487698/index.html">Événements numériques à Saint-Pétersbourg du 10 au 16 février</a></li>
<li><a href="../fr487702/index.html">Une sélection d'articles sur l'apprentissage automatique: études de cas, guides et recherches pour janvier 2020</a></li>
<li><a href="../fr487704/index.html">Comment nous avons créé des rapports dynamiques au SSRS 2014</a></li>
<li><a href="../fr487706/index.html">Découverte de service dans les systèmes distribués à l'aide de l'exemple Consul. Alexander Sigachev</a></li>
<li><a href="../fr487716/index.html">Parfait SAST. Analyseur</a></li>
<li><a href="../fr487724/index.html">BlazingPizza: application Blazor du début à la fin. Partie 2. Ajouter un composant</a></li>
<li><a href="../fr487728/index.html">@Pythonetc compilation, janvier 2020</a></li>
<li><a href="../fr487730/index.html">Traitement du langage naturel. Résultats 2019 et tendances 2020</a></li>
<li><a href="../fr487734/index.html">Accélération du noyau Entity Framework</a></li>
<li><a href="../fr487738/index.html">Animation de schéma dans SCADA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>