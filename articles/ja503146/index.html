<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👯 🛌 🕴🏼 LLVMに基づくTypeScriptでのTypeScriptのコンパイラ開発 📬 📐 🗃️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="時々、開発者は作業中にクレイジーなプロジェクトのアイデアを思いつき、それらを実装しようとさえします。フルスタックの開発者であるDmitry Patsuraは、LLVMを使用してTypeScriptのTypeScript用のコンパイラーを作成することを決めたときも同様に感じました。
 
 そしてこれか...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>LLVMに基づくTypeScriptでのTypeScriptのコンパイラ開発</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/503146/"><img src="https://habrastorage.org/webt/-n/mf/f1/-nmff1duu99ajagwesvtmu3ass0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時々、開発者は作業中にクレイジーなプロジェクトのアイデアを思いつき、それらを実装しようとさえします。</font><font style="vertical-align: inherit;">フルスタックの開発者であるDmitry Patsuraは、LLVMを使用してTypeScriptのTypeScript用のコンパイラーを作成することを決めたときも同様に感じました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてこれから何が起こったのか、ドミトリーは最後のHolyJS 2019モスクワで概説しました。</font><font style="vertical-align: inherit;">カットの下には、ビデオと彼のレポートの要約があります。</font></font><a name="habracut"></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/gS9a_NBHdw0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、Dmitryは、JavaScriptがAoTコンパイラーの代わりにインタープリターと最適化JITコンパイラーで構成される仮想マシンを使用する理由の質問に答えようとしました。</font><font style="vertical-align: inherit;">この文脈では、スピーカーは、トランスレータ、バイトコード、仮想マシンのデバイス、JITコンパイラに触れました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、Dmitryは主な質問に答えました。なぜTypeScriptにコンパイラがないのか、そしてその実装に何が必要なのかです。</font><font style="vertical-align: inherit;">これを行うために、講演者は、LLVM、フレームワークとしてのTypeScript、タイプシステム、V8内のデバイスオブジェクト、配列などのトピックに触れました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">GitHubで</font></a><font style="vertical-align: inherit;">コードを見つけることができます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポスト構造</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳者対 </font><font style="vertical-align: inherit;">通訳対 </font><font style="vertical-align: inherit;">コンパイラと </font><font style="vertical-align: inherit;">JITコンパイラの最適化</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">神秘的なバイトコード</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想マシン</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラ</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最終的なアーキテクチャ</font></font></a></li>
</ul><br>
<a name="trans"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳者対 </font><font style="vertical-align: inherit;">通訳対 </font><font style="vertical-align: inherit;">コンパイラと </font><font style="vertical-align: inherit;">JITコンパイラの最適化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トランスレータは、コードをある言語から別の言語に変換するプログラムです。</font><font style="vertical-align: inherit;">インタープリター、コンパイラー、JITコンパイラーの3つのタイプがあります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通訳</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インタープリターは、ある種のソースファイルを取得して実行するプログラムです。</font><font style="vertical-align: inherit;">たとえば、JavaScriptをバイトコードにコンパイルするインタープリターの前にコンパイラーがあり、これはすでにバイトコードインタープリターによって処理されていますが、これは正しいことです。</font><font style="vertical-align: inherit;">しかし、だれもそう言っているわけではありません。そのようなアプローチは、すでに書面で一種の標準になっているからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通訳の主な仕事は高速であることです。</font><font style="vertical-align: inherit;">彼のオーバーヘッドが少ないほど、作業が速くなり、プログラムの実行時間を短縮できます。</font><font style="vertical-align: inherit;">インタプリタにはマイナスがあります：</font></font><br>
<br>
<ul>
<li>  .      ,        .</li>
<li> « ».     ,   ,   -.      ,  ,      .</li>
<li> ,   .</li>
<li>    .</li>
</ul><br>
<h3></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScriptのコンパイラはTypeScriptをJSコードに変換し、C ++のコンパイラはC ++をマシンコードに変換します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーの主なタスクは効率的な翻訳です。</font><font style="vertical-align: inherit;">コンパイル時間はそれほど重要ではありません。</font><font style="vertical-align: inherit;">主なことは、コンパイラーが非常に高品質のコードを生成し、すばやく動作し、ほとんどのチェックを事前に実行することです。</font><font style="vertical-align: inherit;">ここから、コンパイラのマイナスが続きます：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラーは事前にすべてを行うため、JIT最適化が欠如しています。</font><font style="vertical-align: inherit;">しかし、たとえば、GCCにはプロファイルガイドの最適化機能があります。これにより、特定のアナライザーを使用してプログラムをコンパイルでき、実行時にレポートをコンパイルし、それに基づいてプログラムを再コンパイルして、パフォーマンスを向上させることができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリの消費とランタイムに関する問題。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jitコンパイラ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ランタイムで動作する別のカテゴリのコンパイラがあります-ジャストインタイムコンパイラまたはJITコンパイラだけです。</font><font style="vertical-align: inherit;">コードをバイナリファイルにコンパイルするのではなく、メモリページに直接コンパイルします。</font><font style="vertical-align: inherit;">これはいくつかの問題を引き起こします：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全性。</font><font style="vertical-align: inherit;">W ^ Xでは、プロセッサはメモリのページを実行し、そのコードを直接実行することができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランタイムでコンパイルせずにプログラムを実行できないこと。</font><font style="vertical-align: inherit;">したがって、プログラムのランタイムはコンパイル時間とランタイムで構成されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高メモリ消費。</font></font></li>
</ul><br>
<a name="byte"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">神秘的なバイトコード</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイトコードは、JavaScriptより低いレベルですが、Assemblerより高いレベルの一種の中間表現またはレイヤーです。それはいくつかの原則に基づいていました：シンプルさ、移植性、効率的なストレージ、そしてその結果、SSA表記とCFG（制御フローグラフ）のための追加機能を得ました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mv/vv/bo/mvvvbotqo0lwlut7apek8sjit5o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記は、番号4と3を追加するためのV8のバイトコードの例です。左側は16進形式のバイトコードで、右側は人間が読める形式です。それが何であるかを考えてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の列は、オペレーションコード番号またはオペレーションIDです。これは1バイトで書き込まれます。つまり、16進形式で0〜255または00〜FFの数値のみを受け入れます。 IDにより、0cがLdaSmi命令であり、26がStar命令であることは明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2列目は、関数のオペランドまたは引数です。</font><font style="vertical-align: inherit;">明らかに、04は[4]であり、fbはレジスタr0です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイトコードが登場したとき、これはすべて大きく変化しました。</font><font style="vertical-align: inherit;">彼らはそれを至る所に突き出し始めました-インタープリター、コンパイラー、違いはありません。</font><font style="vertical-align: inherit;">これは、仮想マシンとコンパイラの両方に書き込むのに便利なレイヤーにすぎません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tr/zv/ye/trzvyegsy50kxpqc6jwux4k-efm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、バイトコードはまったく異なる方法で使用できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP</font></font></h3><br>
<img src="https://habrastorage.org/webt/s7/s8/zs/s7s8zs5z-awryby6atsztekjdxc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHPは毎回実行されるインタプリタ言語であり、これが問題です-悪魔ではありません。</font><font style="vertical-align: inherit;">しかし、彼には、毎回ファイルを解析しないようにバイトコードをキャッシュできるようにするopcache拡張があります。</font><font style="vertical-align: inherit;">これにより、パフォーマンスが向上します。</font><font style="vertical-align: inherit;">さらに、バイトコードを一度最適化してキャッシュし、二度と最適化することはできません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジャワ</font></font></h3><br>
<img src="https://habrastorage.org/webt/jj/fl/6m/jjfl6mqh76awo4gam34b6ut1rmo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者はJavaでプログラムを作成し、javacを提供します。</font><font style="vertical-align: inherit;">javacはこれらすべてを解析し、条件付きでバイトコードを収集して、それをjarアーカイブにパックします。</font><font style="vertical-align: inherit;">次に、結果のjarファイルをエンドユーザーに提供します。</font><font style="vertical-align: inherit;">彼は何もコンパイルする必要はありません。アンパック後のバイトコードを含む最終的なアーカイブは、JVM仮想マシンに直接飛んでいきます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Facebookエルメス</font></font></h3><br>
<img src="https://habrastorage.org/webt/r1/dn/9a/r1dn9a5ndmbe7-bticrw-gxpzms.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Facebook HermesはFacebookチームの仮想JavaScriptエンジンです。</font><font style="vertical-align: inherit;">私たちはReact NativeでJSで記述していますが、開発者はhermesc（hermesコンパイラー）、エンドユーザーはHVM（hermes仮想マシン）というJavaアプローチを使用していました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V8</font></font></h3><br>
<img src="https://habrastorage.org/webt/mm/jf/gj/mmjfgjotfi2zt3htzol5a9br5sc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V8には、ホットコードのトラブルシューティングに使用されるインタープリターと最適化JITコンパイラーがあります。 </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node.js</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NodeJSにJavaアプローチを実装することは可能ですか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/b7/xm/wv/b7xmwvey9zxida1mffeo9s6kale.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ByteNodeプロジェクトを使用できます。</font><font style="vertical-align: inherit;">これはNode.js内の標準VMモジュールのCLIラッパーであり、任意のスクリプトを実行し、V8オペレーションコードをバイナリ表現でキャッシュし、V8ストアバイトコードのように配置できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、このバイトコードをDockerイメージのバックエンドにパックして、本番環境に送信できます。</font><font style="vertical-align: inherit;">V8の場合、バイトコードをJavaコードに逆コンパイルできる場合、Javaのように（バイトコードからjavascriptに戻す）トランスレーターがないため、これは良い難読化です。</font></font><a name="mach"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想マシン</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセス仮想マシンのアーキテクチャは、サンドボックス内のソフトウェアをサンドボックス内のハードウェアで実行することを想定していないように構築されています。</font><font style="vertical-align: inherit;">そのような仮想マシンの1つがV8です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセス仮想マシンのタイプ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセス仮想マシンには、レジスタベースとスタックベースの2つのタイプがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レジスタベースの仮想マシンは、プロセッサレジスタで動作します。</font><font style="vertical-align: inherit;">したがって、このタイプのマシンは鉄に近いものです。</font><font style="vertical-align: inherit;">レジスタベースのVMの例はDalvikです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レジスタベースのプログラム例を使用して、数値3と4を追加する前の例を検討してください。</font></font><br>
<br>
<pre><code class="plaintext hljs">0x00001 SET r0, 3<font></font>
0x00002 SET r1, 4<font></font>
0x00003 ADD r1, r0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の命令で3をレジスタr0に入れ、2番目の命令で4をレジスタr1に入れ、次にADD命令を使用してレジスタr0、r1を追加し、結果7をr0にスローします。</font><font style="vertical-align: inherit;">ここでの主なものはタイプ化です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レジスタベースのVMとは異なり、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタックベースの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想マシンは、スタックであるアキュムレータ抽象化を介してレジスタを操作します。</font><font style="vertical-align: inherit;">このようなVMに3と4を追加するプログラムを書いてみましょう。</font></font><br>
<br>
<pre><code class="plaintext hljs">0x00001 LOAD 3<font></font>
0x00002 PUSH r0<font></font>
0x00003 LOAD 4<font></font>
0x00004 ADD r0</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
値をレジスターにロードできないため、最初に3をバッテリーにロードします。次に、PUSH命令を使用して、3をバッテリーからレジスタr0に転送します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スタックベースの仮想マシン内に2つの数値を追加するには、レジスタに1つ、バッテリーに2つ目の数値が必要です。したがって、4がバッテリーに投入され、ADD命令を使用してスタックとレジスタから値をプルし、両方を追加して7を取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、両方のアプローチを比較してみましょう。中間層（バッテリー）がないため、レジスタベースのVMはスタックベースのVMよりも高速ですが、レジスタベースの仮想マシンはハードウェアに近いため、実装が難しくなります。したがって、スタックベースのアーキテクチャでインタプリタを作成します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V8インタープリターByteCode。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一度、V8バイトコードに戻ります。</font><font style="vertical-align: inherit;">これを行うには、このようなプログラムを作成します。このプログラムでは、数字3と4を追加します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> a = <span class="hljs-number">4</span>;
    <span class="hljs-keyword">const</span> b = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">return</span> a + b;<font></font>
}<font></font>
test();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、フラグでノードを実行します</font></font><code>--print-bytecode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_n/tk/v2/_ntkv2jkj2vdknvfqrnsnxafbz0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数字4と3を追加するためのプログラム自体は残ったが、魔法のいくつかの種類が登場-アドレスを。</font><font style="vertical-align: inherit;">バイトコードの解釈に一貫性がないため、ジャンプすると間接的に動作する可能性があります。</font><font style="vertical-align: inherit;">これは、条件、サイクルなどの実装に必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、スタックベースのインタープリターは簡単に作成できます。</font><font style="vertical-align: inherit;">バッテリーに「0」をロードするためのLdaZero命令を検討してください。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// LdaZero</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Load literal '0' into the accumulator.</span><font></font>
IGNITION_HANDLER(LdaZero, InterpreterAssembler) {<font></font>
    TNode&lt;Number&gt; zero_value = NumberConstant(<span class="hljs-number">0.0</span>);<font></font>
    SetAccumulator(zero_value);<font></font>
    Dispatch();<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// LdaSmi &lt;imm&gt;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Load an integer literal into the accumulator as a Smi.</span><font></font>
IGNITION_HANDLER(LdaSmi, InterpreterAssembler) {<font></font>
    TNode&lt;Smi&gt; smi_int = BytecodeOperandImmSmi(<span class="hljs-number">0</span>);<font></font>
    SetAccumulator(smi_int);<font></font>
    Dispatch();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムが解釈され、特定のプログラムコードに到達すると、その処理のために仮想マシンがハンドラーを探します。</font><font style="vertical-align: inherit;">マシンは、IGNITION_HANDLERマクロでラップされたこの関数を見つけます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バッテリーに「0」を入れるには、定数「0」（数値）を予約してバッテリーに入れる必要があります。</font><font style="vertical-align: inherit;">次に、Dispatch関数を使用して、定数を次のコードに転送します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LdaSmi命令は小さな整数に対してのみ同じことを行います。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JS上のV8 ByteCodeインタープリター</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてをよりよく理解するために、JavaScriptで仮想マシンクラスを記述します。</font><font style="vertical-align: inherit;">通常の配列をバッテリーとして使用し、レジスターとして、フィールドがレジスターの名前になるオブジェクトを使用します（例：r1、r2）。</font><font style="vertical-align: inherit;">フィールド値は、これらのレジスターの値になります。</font></font><br>
<br>
<pre><code class="javascript hljs">type Accumulator = any[];<font></font>
type Registers = {[key: string]: any};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VirtualMachine</span> </span>{<font></font>
    protected acc: Accumulator = [];<font></font>
    protected registers: Registers = {};<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">
よれば、</font><font style="vertical-align: inherit;">最も人気のある10個のバイトコード用のそのようなインタープリターの作成方法を見ることができます。たった100行で魔法はありません。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スタックベースの仮想マシンでは、1つの数値をバッテリーに、もう1つの数値をレジスターに保持する必要がありますが、V8はそれを行いません。彼はまずLdaSmi関数を使用して両方の数値をバッテリーにロードし、次にStarを使用してそれらをレジスターにロードし</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tf/dt/8_/tfdt8_248fpf-ritxuwfhe2cw3m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。数値を追加するには、バッテリーに1つ保持する必要があります。したがって、V8の最後に、レジスタから値をバッテリーにロードするLdar機能を実行します。したがって、1つのステップが不要になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バッテリーからレジスターへの4の読み込みは、JavaScriptではどのように見えますか。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// Load an integer literal into the accumulator</span>
<span class="hljs-attr">LdaSmi</span>: <span class="hljs-function">(<span class="hljs-params">op</span>) =&gt;</span> {
    <span class="hljs-keyword">this</span>.acc.push(op.operand[<span class="hljs-number">0</span>]);<font></font>
},<font></font>
<span class="hljs-comment">// Store accumulator to register &lt;dst&gt;.</span>
<span class="hljs-attr">Star</span>: <span class="hljs-function">(<span class="hljs-params">op</span>) =&gt;</span> {
    <span class="hljs-keyword">this</span>.putToRegister(<font></font>
        op.reg,<font></font>
        <span class="hljs-keyword">this</span>.acc.pop()<font></font>
    );<font></font>
},<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4つと3つを両方のレジスタに配置するとき、Ldar演算を実行する命令を記述します。</font><font style="vertical-align: inherit;">彼女はその値をバッテリーに入れ、レジスターから取り出します。</font><font style="vertical-align: inherit;">そして今、数字を追加するために、バッテリーをポップアップし、レジスターから値を取得し、それをすべて追加して、バッテリーに戻します。結果は次のとおりです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// Load accumulator with value from register &lt;src&gt;.</span>
<span class="hljs-attr">Ldar</span>: <span class="hljs-function">(<span class="hljs-params">op</span>) =&gt;</span> {
    <span class="hljs-keyword">this</span>.acc.push(
        <span class="hljs-keyword">this</span>.getFromRegister(op.reg)<font></font>
    )<font></font>
},<font></font>
<span class="hljs-comment">// Add register &lt;src&gt; to accumulator.</span>
<span class="hljs-attr">Add</span>: <span class="hljs-function">(<span class="hljs-params">op</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> right = <span class="hljs-keyword">this</span>.getFromRegister(op.reg);<font></font>
<font></font>
    <span class="hljs-keyword">this</span>.acc.push(
        <span class="hljs-keyword">this</span>.acc.pop() + right<font></font>
    )<font></font>
},<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSで小さなデモを書きました。</font><font style="vertical-align: inherit;">実行したばかりのプログラムのコードを緑色でマークし、ジャンプが発生するタイミングを理解するために実行した前のコードを黄色で示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デモの2番目の部分は、0から100までのサイクルでJumpの動作を示してい</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">カウンター</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初はゼロです。</font><font style="vertical-align: inherit;">次に、サイクルを取り、</font><i><font style="vertical-align: inherit;">aが</font></i><font style="vertical-align: inherit;"> 100未満</font><font style="vertical-align: inherit;">である間に</font><font style="vertical-align: inherit;">カウンター</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インクリメントします。</font><font style="vertical-align: inherit;">カウンターが100になると、プログラムはサイクルからジャンプします。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jitコンパイラマシンコード</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V8には、高速のIgnitionインタープリターと独立したTurboFan JITコンパイラーがあります。</font><font style="vertical-align: inherit;">Ignitionは実行時にいくつかのメトリックを収集します。</font><font style="vertical-align: inherit;">そして、インタープリターがコードの一部が「ホット」であることを理解すると、たとえば1000回の反復の後、それを実行しようとするためにTurboFanにマシンコードの生成を要求します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マシンコードを表示するには、次のコマンドを実行</font></font><br>
<br>
<code>d8 --code-comments --print-opt-code jit.js</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
します。D8はすべてのチェックを備えたコンパイル済みのv8です。</font><font style="vertical-align: inherit;">print-opt-code引数は、マシンコードを印刷するコマンドを提供します。動作の原理を理解するために、人間の言語でコードの説明を表示するには、コードコメントが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JITコードでは、オブジェクトのフィールドを追加する関数を使用することにしました。オブジェクト自体がこの関数の引数です。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">plus</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">return</span> obj.x + obj.y;<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(plus({ <span class="hljs-attr">x</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">5</span> }));
<span class="hljs-built_in">console</span>.log(plus({ <span class="hljs-attr">x</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">5</span> }));
<span class="hljs-built_in">console</span>.log(plus({ <span class="hljs-attr">x</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">5</span> }));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、JIT-anulではありません。</font><font style="vertical-align: inherit;">どうして？</font><font style="vertical-align: inherit;">文字指定を紹介します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして-これはバイトコードからのプログラムの実行時間です。</font><font style="vertical-align: inherit;">迅速な通訳のためそれは小さいです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B-JITコンパイラーを使用した関数のコンパイル時間。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cは、JITコンパイラーによってコンパイルされた関数の実行時間です。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、時間AとB + Cを比較する必要があります。</font><font style="vertical-align: inherit;">しかし、Ignitionが3回しか実行されない場合、この関数をコンパイルしても意味がありません。</font><font style="vertical-align: inherit;">彼がJITを始めるまで、私は大きくプレーすることに決め、0を追加しました。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">plus</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">return</span> obj.x + obj.y;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (total &lt; <span class="hljs-number">100000000</span>) {<font></font>
    total += plus({ <span class="hljs-attr">x</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">5</span> });<font></font>
}<font></font>
<span class="hljs-built_in">console</span>.log(total);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再度トリックを使用します</font><font style="vertical-align: inherit;">。JITコンパイラーには多数の最適化があるため、</font><font style="vertical-align: inherit;">関数の結果を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合計し</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一度始めます。コンパイラがこの機能を見つけ、TurboFanが最適化しました。次に、364個のコード命令がコンソールに表示されます。このJITコードが必要な理由を図で調べてみましょう</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1p/ko/vj/1pkovjro3u2bkq0rpl9m68b0nic.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。インタープリターがバイトコードを駆動します。ある時点で、Ignitionは十分な数のメトリックによってコードが「ホット」であることを理解します。したがって、コンパイラーは、最大4つ（V8内の制限、メモリー消費量を削減するため）のタイプ（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V8内の形状メカニズム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）のみで機能する関数を生成します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生成されたコードは、xおよびyフィールドを持つ形状を持つ引数で機能します。そこにxとyを投げた場合、コードは高速パスに沿って進み、コンパイルされた関数からIgnition内の実行フローのグラフを返し、関数の結果を変数totalに加算します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数の引数がその関数を対象とした型ではない場合（関数が生成された最初の4つの図形ではない場合）、関数が呼び出されると、関数はベイルアウトで終了します。救済は、その制限のために適切でないコンパイルされた関数を終了するためのメカニズムです（引数は適切なタイプではありません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、質問に答えましょう。JSはなぜAoTコンパイラーではなくVM（インタープリター+コンパイラー）を使用するのでしょうか。</font><font style="vertical-align: inherit;">すべては使用領域、または私たちが使用領域と言う理由によるものです。</font><font style="vertical-align: inherit;">JSは主にブラウザーで使用されており、比較的最近になってバックエンドに登場しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、TypeScriptでコンパイラを作成するとどうなるでしょうか。</font><font style="vertical-align: inherit;">JSに対するその利点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちを制限できる型システム。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unit8のようなタイプを追加できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独自のコンパイラを作成しているため、すべてのJS関数をサポートできるわけではありません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結局、私はそれを書いてStaticScriptを呼び出しました。</font></font><a name="comp"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、コンパイラは2つの部分で構成されます。</font><font style="vertical-align: inherit;">最初のものは解析に従事し、ASTを取り、ASTレベルであらゆる種類のチェックまたは最適化を行います。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の部分はコード生成を担当します。</font><font style="vertical-align: inherit;">たとえば、TypeScriptでは、2番目の部分でJSコードが生成されます。</font><font style="vertical-align: inherit;">最初の部分はフロントエンドと呼ばれ、2番目の部分はバックエンドと呼ばれます。</font><font style="vertical-align: inherit;">おなじみですか？</font><font style="vertical-align: inherit;">:)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロントエンド</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文字列 "Hello、HolyJS！"をコンソールに表示する単純なプログラムを、存在しない言語で記述します。</font></font><br>
<br>
<pre><code class="javascript hljs">{<font></font>
    console_log(“Hello HolyJS!”);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、TypeScriptはフロントエンドとして機能します。</font><font style="vertical-align: inherit;">コンパイラではなくライブラリとして使用します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ts <span class="hljs-keyword">from</span> <span class="hljs-string">'typescript'</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> options = {
    <span class="hljs-attr">lib</span>: [],
    <span class="hljs-attr">types</span>: []<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">const</span> files = [<span class="hljs-string">'sandbox/hello.ts'</span>];<font></font>
<font></font>
<span class="hljs-keyword">const</span> host = ts.createCompilerHost(options);
<span class="hljs-keyword">const</span> program = ts.createProgram(files, options, host);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScriptをインポートし、ライブラリとタイプがなく、TSがJSではなくなったことをオプションで確認します。意味的には、TypeScriptはTypeScriptのままでしたが、タイプ情報がないため、別の言語になっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の部分では、ASTコードのみを提供しました。しかし、TypeScriptはタイピングチェックなどすべてを実行できます。フロントエンドとして使用されている場合は、それを使用しないのはなぜですか？ PreEmitと呼ばれるJSコードへの最終的なコンパイルの前の段階があることがわかりました。チェックのすべての結果を収集して印刷します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> diagnostics = ts.getPreEmitDiagnostics(program);
<span class="hljs-keyword">if</span> (diagnostics.length) {<font></font>
    ts.sys.write(<font></font>
        ts.formatDiagnosticsWithColorAndContext(<font></font>
            diagnostics,<font></font>
            DiagnosticHostInstance<font></font>
        )<font></font>
    );<font></font>
    ts.sys.exit(<font></font>
        ts.ExitStatus.DiagnosticsPresent_OutputsSkipped<font></font>
    );<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScriptは、配列、ブール、関数など、インターフェイスとして使用するグローバルタイプを見つけることができないと推定しました。</font><font style="vertical-align: inherit;">実際、TypeScriptパーサーは言語のセマンティクスと語彙だけでなく、タイピングでも機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、</font></font><code>staticscript.d.ts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScriptセマンティクスを使用してプログラミング言語を</font><font style="vertical-align: inherit;">作成するためのファイル</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">作成します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs">interface <span class="hljs-built_in">Boolean</span> {}<font></font>
interface <span class="hljs-built_in">Function</span> {}<font></font>
interface IArguments {}<font></font>
interface <span class="hljs-built_in">Number</span> {}<font></font>
interface <span class="hljs-built_in">Object</span> {}<font></font>
interface <span class="hljs-built_in">RegExp</span> {}<font></font>
interface <span class="hljs-built_in">String</span> {}<font></font>
interface <span class="hljs-built_in">Array</span>&lt;T = any&gt; {}
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックエンド</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はバックエンドとして、LLVM（低レベル仮想マシン）を採用しました。LLVMには、仮想マシン、JITコンパイラー、独自のプログラミング言語、および多数のユーティリティが含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AppleはかつてGlangコンパイラのフロントエンドとしてClangを作成していましたが、その後Clangの独自のバックエンドを作成することを決定しました。</font><font style="vertical-align: inherit;">そして、LLVMプロジェクトが誕生しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLVMには、LLVM IRと呼ばれる独自のプログラミング言語があります。</font><font style="vertical-align: inherit;">これはアセンブラよりも高いレベルであり、最終的な結果は任意のターゲットアーキテクチャに対して生成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cで書かれた追加プログラム3と4をもう一度考えてみましょう。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
     <span class="hljs-keyword">auto</span> a = <span class="hljs-number">3</span>;
     <span class="hljs-keyword">auto</span> b = <span class="hljs-number">4</span>;
     <span class="hljs-keyword">auto</span> c = a + b;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラ開発時間のほとんどは、LLVM-Clangのリファレンスフロントエンドを使用し、すべての最適化をオフにして、次のコマンドを使用してLLVMコードにコンパイルしました。</font></font><br>
<br>
<pre><code class="plaintext hljs">clang -S -emit-llvm main.cpp -O0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックエンドがマシンコードを生成する前でも、Clang内のフロントエンドが数値3と4を合計しないように、最適化をオフにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、2つの数値を加算するプログラムのllvmコードです。</font></font><br>
<br>
<pre><code class="cpp hljs">
; ModuleID = ‘main.cpp<span class="hljs-number">'</span>
source_filename = <span class="hljs-string">"main.cpp"</span>
target datalayout = <span class="hljs-string">"e-m:o-i64:64-f80:128-n8:16:32:64-S128"</span>
target triple = “x86_64-apple-macosx10<span class="hljs-number">.14</span><span class="hljs-number">.0</span><span class="hljs-string">"

define i32 @main() #0 {
    %1 = alloca i32, align 4
    %2 = alloca i32, align 4
    %3 = alloca i32, align 4

    store i32 3, i32* %1, align 4
    store i32 4, i32* %2, align 4

    %4 = load i32, i32* %1, align 4
    %5 = load i32, i32* %2, align 4
    %6 = add nsw i32 %4, %5

    store i32 %6, i32* %3, align 4
    ret i32 0
}
</span></code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では</font></font><code>source_filename</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ソースファイルの名前を参照してください。これは</font></font><code>datalayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVMの種類内の不要なアーキテクチャで組み立てることができるので、使用のタイプに関する情報が含まれています。それ</font></font><code>triple</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はコードがmacOSで生成される</font><font style="vertical-align: inherit;">ことを</font><font style="vertical-align: inherit;">言います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、プログラム自体が来ます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はSSA表記の変数です。もちろん、a、b、cと書くこともできます。変数の名前だけを1回だけ使用できます。原則として、彼らが「人間の」コードを書くとき、彼らはを書き</font></font><code>a0=0, a1=a0+1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、変数のそれぞれの変化は新しいインデックスを構成します。さらに、LLVMには、そのようなレジスターの概念はなく、ヒープ（HEAP）とスタックの概念しかありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、3つのポインターを作成し、数値3と4を2つにドロップします。数値を追加するには、それらをヒープからスタックにロードして追加しますが、バックエンドは、たとえば登録操作を生成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLVMには、クラスなど、思いつくタイプはありません。</font><font style="vertical-align: inherit;">整数型など、単純な型があります。整数型、浮動小数点型、ポインタ型、整数型は任意の容量で作成できます。</font><font style="vertical-align: inherit;">整数フラグと浮動小数点フラグの両方を設定することもできます。</font><font style="vertical-align: inherit;">そして、集合型があります：ベクトル、配列、または構造。</font><font style="vertical-align: inherit;">LLVMを使用する理由を説明する</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非常に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クールなコメント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての自尊心のあるプログラマーは彼自身のコンパイラーを作りたいです。</font><font style="vertical-align: inherit;">夢が叶う！</font><font style="vertical-align: inherit;">LLVMは、循環を回避するための重要なステップです。</font></font><br>
<br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グリデム</font></font></a></b><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> これを処理するために、LLVM内の標準的なものをラップするモジュールを使用します。これにより、IRBuilderと呼ばれる中間表現コードを生成できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> llvm <span class="hljs-keyword">from</span> <span class="hljs-string">'llvm-node'</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> llvmContext = <span class="hljs-keyword">new</span> llvm.LLVMContext();
<span class="hljs-keyword">const</span> llvmModule = <span class="hljs-keyword">new</span> llvm.Module(<span class="hljs-string">"test"</span>, <span class="hljs-keyword">this</span>.llvmContext);<font></font>
<font></font>
<span class="hljs-keyword">const</span> mainFnType = llvm.FunctionType.get(<font></font>
    llvm.Type.getVoidTy(llvmContext),<font></font>
    <span class="hljs-literal">false</span><font></font>
);<font></font>
<span class="hljs-keyword">const</span> mainFn = llvm.Function.create(<font></font>
    mainFnType,<font></font>
    LinkageTypes.ExternalLinkage,<font></font>
    <span class="hljs-string">"main"</span>,<font></font>
    llvmModule<font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">const</span> block = llvm.BasicBlock.create(llvmContext, <span class="hljs-string">"entry"</span>, mainFn);
<span class="hljs-keyword">const</span> builder = <span class="hljs-keyword">new</span> llvm.IRBuilder(block);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムの生成を開始するには、コンテキストとモジュールを作成する必要があります。</font><font style="vertical-align: inherit;">モジュール内で、戻り値の型を持つ別の関数を生成します。</font><font style="vertical-align: inherit;">コードを生成するには、ベースユニットを作成し、IRBuilderをそれに変換します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックエンドは</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gy/1h/vo/gy1hvoy7c3vyjrongngwkbb1huy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の</font><font style="vertical-align: inherit;">ようになります。</font><font style="vertical-align: inherit;">これを生成するには、IRBuilderとContextが必要です。</font><font style="vertical-align: inherit;">Contextオブジェクトは、LLVMとモジュールのコンテキスト、TypeScriptとスコープのASTツリーから型を出力するためのts.TypeCheckerを格納します。マップ</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tb/li/af/tbliafo7ls_id708ub7ma3eedra.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
は、このモジュールに配置されます。このモジュール内で関数を呼び出すモジュールを記述します。</font><font style="vertical-align: inherit;">生成して呼び出すことができます。</font><font style="vertical-align: inherit;">したがって、このノードはすでにコンパイルされていることがわかっているため、ASTノードをLLVMビューに渡し、それを呼び出すことができます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型システム</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSには型付けはなく、TypeScriptにはインターフェース型付けがありません。LLVMにはネイティブ型があります。</font><font style="vertical-align: inherit;">型の非互換性の問題を解決します。このために、TypeCheckerから取得したTypeScript型を指定してネイティブ型を取得するクラスを作成します。</font><font style="vertical-align: inherit;">より詳細な場合、クラスは受信したデータの使用方法を決定し、NativeTypeラッパーを生成して、計算されたLLVMタイプとそのフラグの数をそこでラップします。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NativeTypeResolver</span> </span>{
    <span class="hljs-keyword">static</span> getType(type: ts.Type, <span class="hljs-attr">ctx</span>: Context): NativeType|<span class="hljs-literal">null</span> {
        <span class="hljs-keyword">if</span> (type.isNumberLiteral()) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NativeType(<font></font>
                llvm.Type.getDoubleTy(<font></font>
                    ctx.llvmContext<font></font>
                )<font></font>
            );<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">// </span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、Number内の型（通常は64ビットの非整数の数値）はDoubleでラップされ、LLVM内で捕捉されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プリミティブ型を追加するために、基本的にはオブジェクトであるint8という新しい型を作成しました。</font></font><br>
<br>
<pre><code class="javascript hljs">declare type int8 = {};<font></font>
declare type int16 = {};<font></font>
declare type int32 = {};<font></font>
declare type int64 = {};<font></font>
declare type int128 = {};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここに問題があります：TypeScriptは構造タイピングによって管理されています。</font><font style="vertical-align: inherit;">「動物」インターフェースを作成する場合、猫と犬の両方に適しています。ここでは、オブジェクトではなく単純なプリミティブ型を記述する必要があります（構造型指定における「猫と犬」の問題）。</font><font style="vertical-align: inherit;">TypeScript内でプリミティブ型を作成する方法を説明</font><font style="vertical-align: inherit;">する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がありますが、</font><font style="vertical-align: inherit;">私にはハードコアに思えました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランタイム</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ランタイムライブラリは、リンクされたすべてのプログラムモジュールにAPIを提供し、プログラム内のモジュールを常に使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラは、フロントエンドとバックエンドの2つの部分で構成されています。</font><font style="vertical-align: inherit;">フロントエンドはTypeScriptで、バックエンドはIRコードを生成します。</font><font style="vertical-align: inherit;">C ++でランタイムライブラリを作成するには、ランタイム内にある関数を使用するようにフロントエンドをトレーニングする必要があります。</font><font style="vertical-align: inherit;">したがって、runtime.d.tsファイルを作成します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">/// &lt;reference no-default-lib="true"/&gt;</span><font></font>
<font></font>
declare <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">console_log</span>(<span class="hljs-params">value: number</span>): <span class="hljs-title">void</span>;
<span class="hljs-title">declare</span> <span class="hljs-title">function</span> <span class="hljs-title">console_log</span>(<span class="hljs-params">value: string</span>): <span class="hljs-title">void</span>;
<span class="hljs-title">declare</span> <span class="hljs-title">function</span> <span class="hljs-title">console_log</span>(<span class="hljs-params">value: boolean</span>): <span class="hljs-title">void</span>;
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ランタイムライブラリでconsole_log関数を宣言して、タイプ番号、文字列、ブール値をサポートします。</font><font style="vertical-align: inherit;">TypeScriptにはオーバーロードがあり、プリミティブ型付けを使用するため、これが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数の実装をC ++で記述します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">LIBRARY_EXPORT <span class="hljs-keyword">void</span> <span class="hljs-title">console_log</span><span class="hljs-params">(<span class="hljs-keyword">double</span> number)</span> </span>{
    <span class="hljs-built_in">puts</span>(number2string(number));<font></font>
}<font></font>
<font></font>
<span class="hljs-function">LIBRARY_EXPORT <span class="hljs-keyword">void</span> <span class="hljs-title">console_log</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str)</span> </span>{
    <span class="hljs-built_in">puts</span>(str);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">LIBRARY_EXPORT <span class="hljs-keyword">void</span> <span class="hljs-title">console_log</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> boolean)</span> </span>{
    <span class="hljs-keyword">if</span> (boolean) {
        <span class="hljs-built_in">puts</span>(<span class="hljs-string">"true"</span>);<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">puts</span>(<span class="hljs-string">"false"</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数値を出力するときは、まず関数</font></font><code>number2string() </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用して文字列に変換し、を使用し</font><font style="vertical-align: inherit;">て出力し</font></font><code>puts()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><code>puts()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文字列に</font><font style="vertical-align: inherit;">は標準関数を使用し、</font><font style="vertical-align: inherit;">ブール値では、値がtrueの場合は定数文字列「true」を出力し、値がfalseの場合は「false」を出力します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
名前のマングリング（または名前の装飾）技術のおかげで、C ++内部で同様のオーバーロードが可能です。</font><font style="vertical-align: inherit;">数値、ブール値、および文字列を出力するStaticScriptのプログラムを考えてみます。</font></font><br>
<br>
<pre><code class="cpp hljs">console_log(<span class="hljs-number">1.0</span>);<font></font>
console_log(<span class="hljs-literal">true</span>);<font></font>
console_log(<span class="hljs-string">"str"</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、プログラムの生成されたIRコードを考えます：</font></font><br>
<br>
<pre><code class="cpp hljs">
@<span class="hljs-number">0</span> = <span class="hljs-keyword">private</span> constant [<span class="hljs-number">4</span> x i8] c”str\<span class="hljs-number">00</span><span class="hljs-string">"

define i64 @main() {
entry:
    call void @_Z11console_logd(double 1.000000e+00)
    call void @_Z11console_logb(i1 true)
    call void @_Z11console_logPKc(i8* getelementptr …)
    ret i64 0
}
declare void @_Z11console_logd(double)
declare void @_Z11console_logb(i1)
declare void @_Z11console_logPKc(i8*)
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
doubleを印刷するには、関数を使用します</font></font><code>_Z11console_logd()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムはさまざまなモジュールで構成されているため、関数の宣言も行いました。Cアプローチには、この関数を操作するためのヘッダーファイルがあります。</font><font style="vertical-align: inherit;">ヘッダーファイルがないため、宣言を手動で生成しました。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たち</font></font><code>d.ts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">を受け取り</font><font style="vertical-align: inherit;">、それをC ++コードに変換し、この関数の操作方法を内部で生成します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラオブジェクトとクラス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネイティブコンパイラでオブジェクトとクラスを実装する方法と、V8でどのように機能するかを見てみましょう。</font><font style="vertical-align: inherit;">これを行うには、もう一度d8を実行し、フラグ</font></font><code>--allow-natives-syntax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を指定</font><font style="vertical-align: inherit;">して実行し</font><font style="vertical-align: inherit;">、オブジェクトを出力します。</font></font><br>
<br>
<pre><code class="cpp hljs">%DebugPrint({<span class="hljs-number">0</span>: <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>: <span class="hljs-literal">true</span>, a: “holyjs”});
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSでは、すべてがオブジェクトとして表され、オブジェクトは配列にすることができます。オブジェクトは、種類あり</font></font><code>JS_OBJECT_TYPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">種類</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（私たちは私たちが保存されているかを理解することを可能にする内部最適化）、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gx/57/pz/gx57pz9iyf1ziiohts3zcob_wna.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトは、インデックス付きプロパティと名前付きプロパティで構成されています。たとえば、文字列「holyjs」は、戻りマップを含む配列に分類されます。ここには、「holyjs」に対応するが含まれます。数値は通常の整数配列に分類されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、問題があります。これをローカルマシンで実行して0：false、550：trueを書き込みたい場合、オブジェクトは550要素の配列を割り当てます。したがって、オブジェクトを配列として使用する場合は、カウンターを介して0から無限大まで、たとえばPUSHを介してインクリメントします。この例では、0と1のみを使用し、オブジェクトはサイズ17の配列を割り当てました。ここで、0はfalse、1はtrue、残りの穴です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の問題は、V8内でタイピングを作成することです。 JSにはタイプはなく、すべてを無限に変更できます。オブジェクトを作成し、各反復で新しいプロパティの追加と変更を開始します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/oa/on/xh/oaonxhuwq-jmlturzomkno2sck0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、それらには別々のクラスがあります</font></font><code>hiddenClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記述子で配列を参照します。</font><font style="vertical-align: inherit;">オブジェクトを変更するたびに、新しい形状を組み立てるので、最もワイルドなプロトタイプチェーンが組み立てられます。</font><font style="vertical-align: inherit;">新しいフィールドが追加されるたびに、新しいフィールドが作成され</font></font><code>hiddenClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">オブジェクトは他のオブジェクトから含めることができるため、V8内にタイプを入力できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネイティブコンパイラクラス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてがオブジェクトではない、ネイティブプログラミング言語でネイティブクラスがどのように実装されているかを考えます。</font><font style="vertical-align: inherit;">TypeScriptでUserクラスを書いてみましょう：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{<font></font>
    protected name: string;<font></font>
    protected age: number;<font></font>
    protected weight: number;<font></font>
<font></font>
    <span class="hljs-keyword">constructor</span>(name: string, age: number, weight: number) {
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
        <span class="hljs-keyword">this</span>.weight;<font></font>
    }<font></font>
<font></font>
    public getWeight(): number {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.weight;<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOPで書き込みます。</font><font style="vertical-align: inherit;">しかし、ネイティブプログラミング言語ではこれは違います。</font><font style="vertical-align: inherit;">C ++では、クラスは隠し構造の上にある抽象概念です。</font><font style="vertical-align: inherit;">したがって、C ++は非常に魔法の言語です。抽象化を記述できますが、それらは知識や問題なしに変換されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスを作ることにしました。</font><font style="vertical-align: inherit;">値を格納するRAMの領域を記述する構造が必要です。</font></font><br>
<br>
<pre><code class="javascript hljs">struct User {<font></font>
    char* name;<font></font>
    double age;<font></font>
    double weight;<font></font>
};<font></font>
<font></font>
User* construct_User(char *name, double age, double weight)<font></font>
{<font></font>
    <span class="hljs-comment">// code</span><font></font>
}<font></font>
<font></font>
double getWeight(User *ptr) {<font></font>
    <span class="hljs-keyword">return</span> ptr-&gt;weight;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これでプログラムはタイピングで機能します。</font><font style="vertical-align: inherit;">しかし、RAMは型付きのソースではないので、コンピュータでは型付けはどのように機能しますか？</font><font style="vertical-align: inherit;">プログラムの命令セットがあります。</font><font style="vertical-align: inherit;">これらの命令は、レジスタ内の特定のタイプで機能します。</font><font style="vertical-align: inherit;">ここから、プログラムの入力は、生成する命令の中に隠されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLVMにもクラスがないため、ある種の構造として実装されます。</font><font style="vertical-align: inherit;">次に、この構造のコンストラクタを作成する必要があります。</font><font style="vertical-align: inherit;">コンストラクターはメソッドではなくなりますが、最終的な値を保存するヒープに構造を割り当て、プロパティに従って変更し、ポインターを返す別の関数になります。</font><font style="vertical-align: inherit;">低レベルプログラミング言語の他のすべてのメソッドは、このオブジェクトへのポインターで動作するか、スタックを介して渡します。</font><font style="vertical-align: inherit;">つまり、抽象化そのものが欠落しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような構造を生成するには、構造であるLLVMタイプを生成し、その内部でそのオブジェクトのTypeScriptから型を反復処理します。</font><font style="vertical-align: inherit;">次に、プロパティを見つけ、NativeTypeリゾルバー（TypeScriptタイプからLLVMタイプにビューをキャストできるようにするレイヤー）を使用してタイプをLLVMタイプに変換します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> struct = llvm.StructType.create(ctx.llvmContext, structName);<font></font>
<font></font>
struct.setBody(properties.map(<font></font>
    <span class="hljs-function">(<span class="hljs-params">property: ts.<span class="hljs-built_in">Symbol</span></span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> nativeType = NativeTypeResolver.getType(<font></font>
            ctx.typeChecker.getTypeOfSymbolAtLocation(property, node),<font></font>
            ctx<font></font>
        );<font></font>
<font></font>
        <span class="hljs-keyword">return</span> nativeType.getType();<font></font>
    }<font></font>
));<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラーでの動的型付け</font></font></h3><br>
<pre><code class="javascript hljs">{
    <span class="hljs-keyword">let</span> result;<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0</span>) {<font></font>
        result = {};<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        result = <span class="hljs-string">"string"</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-built_in">console</span>.log(result);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
条件の正のブランチの内部にはオブジェクトがあり、負のブランチの内部には文字列があります。</font><font style="vertical-align: inherit;">これをどのように処理するのですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHPが使用するソリューションを使用します。すべてのフィールドの型と共用体を格納します。</font><font style="vertical-align: inherit;">型として、8ビットの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用します。この</font><i><font style="vertical-align: inherit;">列挙には</font></i><font style="vertical-align: inherit;">、格納するすべての低レベルの型の列挙が格納されます。</font><font style="vertical-align: inherit;">そして値を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">union</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内に保存します</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">enum</span> DynamicType: <span class="hljs-keyword">int8_t</span> {<font></font>
    BOOLEAN = <span class="hljs-number">1</span>,<font></font>
    NUMBER = <span class="hljs-number">2</span>,<font></font>
    INT64 = <span class="hljs-number">3</span>,<font></font>
    UNDEFINED = <span class="hljs-number">3</span>,<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dynamic</span> {</span>
<span class="hljs-keyword">private</span>:<font></font>
    DynamicType type;<font></font>
    <span class="hljs-keyword">union</span> {
        <span class="hljs-keyword">double</span> number;
        <span class="hljs-keyword">bool</span> boolean;
        <span class="hljs-keyword">int64_t</span> int64;<font></font>
    };<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのプロパティを個別に書き込んだ場合、構造はRAMの線形セクションであるため、次々に順番に書き込まれます。次に、タイプが1バイトにヒットし、ユニオン内のすべてが順番に並べられます。しかしunionのおかげで、これはすべての型を8バイトにパックします。これは、これがint64のサイズだからです。何にでも使用できる残りの7バイトがあり、私の構造のサイズは16バイトです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V8は、64ビットアドレス内に整数を保存できる場合、Smi最適化を除いて、どこでもオブジェクトを使用します。そして最後のビットで、V8は「0」または「1」を保存できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「1」は、これがオブジェクトのアドレスであることを意味します。</font><font style="vertical-align: inherit;">次に、参照解除、ジャンプ、および目的のメモリ位置へのロードを実行します。</font><font style="vertical-align: inherit;">smi番号には「0」が使用されます。</font><font style="vertical-align: inherit;">このアプローチにより、L1、L2キャッシュを使わずに逆参照できます。</font><font style="vertical-align: inherit;">RAMを浪費するため、オブジェクトタイプ内に小さな数を保存しても意味がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、32ビットプラットフォームあたり理論上31ビットになります。</font><font style="vertical-align: inherit;">しかし、実際には、どこかで約29ビットが利用可能です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラーの配列</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列も線形メモリであり、すべての要素のサイズを揃える必要があります。</font><font style="vertical-align: inherit;">配列内の要素に移動するには、ポインタの算術を使用できます。配列の先頭のアドレスを取得し、要素のサイズにインデックスを掛けたものを追加します。</font><font style="vertical-align: inherit;">このトリックのおかげで、一定の時間内に任意の数を安全に取得できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
動的配列を作成するには、配列が配置されている線形メモリの部分への要素ポインタ、およびサイズ要素のサイズと</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">容量</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素の数を格納する構造を使用します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vector</span> {</span>
    <span class="hljs-keyword">void</span>* elements;
    <span class="hljs-keyword">int32_t</span> size;
    <span class="hljs-keyword">int32_t</span> capacity;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてを機能させるため</font></font><code>Uint8Array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、最終構造にマップマップする</font><font style="vertical-align: inherit;">スコープ内にクラスを保存</font><font style="vertical-align: inherit;">します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">this</span>.scope.classes.set(
    <span class="hljs-string">'Uint8Array'</span>,<font></font>
    ArrayLiteralExpressionCodeGenerator.buildTypedArrayStructLLVMType(<font></font>
        llvm.Type.getInt8Ty(<span class="hljs-keyword">this</span>.llvmContext),
        <span class="hljs-keyword">this</span>,
        <span class="hljs-string">'array&lt;uint8&gt;'</span><font></font>
    )<font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">static</span> buildTypedArrayStructLLVMType(elementType, ctx, name): llvm.StructType<font></font>
{<font></font>
    <span class="hljs-keyword">const</span> structType = llvm.StructType.create(ctx.llvmContext, name);
    <span class="hljs-keyword">return</span> structType.setBody([<font></font>
         elementType,<font></font>
         <span class="hljs-comment">// size</span><font></font>
         llvm.Type.getInt32Ty(ctx.llvmContext),<font></font>
         <span class="hljs-comment">// capacity</span><font></font>
         llvm.Type.getInt32Ty(ctx.llvmContext),<font></font>
    ]);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V8の配列はオブジェクトであるため、V8でもこれは同様に機能し、V8の配列だけが非表示クラスも格納します。この配列に任意のメソッドを追加することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列のすべての要素が同じサイズである必要があります。 2倍のみをスローする1万要素の配列を作成したい場合、2倍にパックするため、配列要素内は8バイトを占有します。しかし、ループの反復後にラインをスローするとどうなるでしょうか。</font></font><br>
<br>
<pre><code class="javascript hljs">{
    <span class="hljs-keyword">let</span> result = [];<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {<font></font>
        result.push(<span class="hljs-built_in">Math</span>.random())<font></font>
    }<font></font>
<font></font>
    result.push(<span class="hljs-string">"Hehehehe Another Type"</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文字列のサイズ、つまりオブジェクトまたはそのパッケージのアドレスは、doubleのサイズとは異なります。</font><font style="vertical-align: inherit;">オブジェクトの文字列と隠しクラスは別々に格納されるため、24バイトになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V8内のこのタイプのストレージは、ボクシングと呼ばれます。</font><font style="vertical-align: inherit;">TypeScriptを使用しているため、フロントエンドレベルには制限があります。</font><font style="vertical-align: inherit;">そして、それが任意のタイプの配列オブジェクトである場合、16バイトの要素を持つ動的配列を使用します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/za/xl/8x/zaxl8x3vz92tlf4idras0rog0tg.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">種類</font></font></h3><br>
<img src="https://habrastorage.org/webt/9b/bp/qe/9bbpqexiele6sfdp330zw2nsnac.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトは配列にすることができますが、完全に異なる値の配列にすることもできます。</font><font style="vertical-align: inherit;">このため、V8にはKindがあり、そのような配列を操作できます。</font><font style="vertical-align: inherit;">これはオブジェクトの特定のサブタイプであり、これを使用すると、このオブジェクトからオフセットを正しく操作して取得するためにアクセスできます。</font></font><a name="arc"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最終的なアーキテクチャ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが、プロジェクトのアーキテクチャが最終的な形でどのように見えるかです</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xs/8l/nu/xs8lnu3wxbuglkfveylvpzcrvpm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。TypeScriptコードをSSCにドロップします。次に、TypeScriptフレームワークが呼び出され、すべてのコードが解析され、事前に出力され、診断が実行されます。その出口で、ASTとすべてのチェックを取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ASTから、IRコードのバックエンドを介してバックエンドを使用して生成します。さらに、IRコードは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llvm-opt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムで最適化されてい</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。次に、これらのモジュール</font><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llvm-llc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">してオブジェクトファイルにコンパイルされます。次に、C ++（オペレーティングシステムのコンパイラエイリアス）とランタイムライブラリを使用して、すべてのプログラムモジュールを相互にリンクし、実行可能ファイルを取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図のフロントエンドは緑色の長方形で強調表示され、それ以外はすべてバックエンドです。オレンジ色の図は、サードパーティプログラムの呼び出しを示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、TypeScriptのコンパイラーを実装できるようにしました。</font><font style="vertical-align: inherit;">ただし、1つの問題があります。TypeScriptはJSのスーパーセットです。</font><font style="vertical-align: inherit;">言語をTypeScriptセマンティクスに制限し、動的オブジェクトやその他のJavaScriptマジックを放棄すると、Dartの最初のバージョンにたどり着くだけです。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今年は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HolyJS 2020 Piter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がオンラインで開催されます。</font><font style="vertical-align: inherit;">今回のカンファレンスに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、いくつかのオープンソースライブラリ（vue-multiselect、vuelidate、vue-global-events）の作者であるDamian Dulishの作者であるコアチームVue.jsのメンバー</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">が</font></a><font style="vertical-align: inherit;">参加します。</font><font style="vertical-align: inherit;">8つの夏季会議すべての</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブスクリプションチケット</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、</font></a><font style="vertical-align: inherit;">さらにクールなスピーカーを聞くことができ</font><font style="vertical-align: inherit;">ます。</font></font></blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja503132/index.html">Apache Arrowを使用したPythonの高速Apache Parquet</a></li>
<li><a href="../ja503134/index.html">管理=チーム+製品。今年の公式を明らかにします：DUMP 2020で人々と人々にとって最も役立つ</a></li>
<li><a href="../ja503136/index.html">大規模なアプリケーションでのMobXの使用経験</a></li>
<li><a href="../ja503140/index.html">C2x：将来の標準C</a></li>
<li><a href="../ja503144/index.html">オンラインまたはオフライン：パンデミックの後で大学のプログラミングを教える方法</a></li>
<li><a href="../ja503148/index.html">Lynisユーティリティを使用したLinuxセキュリティの確認</a></li>
<li><a href="../ja503154/index.html">スタックオーバーフローの将来のシナリオ</a></li>
<li><a href="../ja503156/index.html">ロシアの鉄道駅にはロシアのサーマルイメージャーを装備できますが、外観は中国と非常に似ています。</a></li>
<li><a href="../ja503158/index.html">人工知能は、他の絵画の例から学ぶことなく、実際に単独で絵を描く</a></li>
<li><a href="../ja503160/index.html">マイクロソフトの最新の8つの無料コース</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>