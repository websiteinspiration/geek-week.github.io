<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏾 👨‍🎨 😗 带有高级语言编译器或鼠标之歌的本地FPGA软处理器 🗽 🏴󠁧󠁢󠁥󠁮󠁧󠁿 ✍️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="具有高级语言编译器或鼠标之歌的自己的FPGA软处理器-具有使高级语言编译器适应堆栈处理器内核的经验。
 
 软件处理器的一个普遍问题是缺乏针对它们的开发工具，尤其是在其指令系统不是其流行的处理器内核之一的指令的子集的情况下。在这种情况下，开发人员必须解决此问题。它的直接解决方案是创建汇编语言编译器。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>带有高级语言编译器或鼠标之歌的本地FPGA软处理器</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491604/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有高级语言编译器或鼠标之歌的自己的FPGA软处理器-具有使高级语言编译器适应堆栈处理器内核的经验。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
软件处理器的一个普遍问题是缺乏针对它们的开发工具，尤其是在其指令系统不是其流行的处理器内核之一的指令的子集的情况下。在这种情况下，开发人员必须解决此问题。它的直接解决方案是创建汇编语言编译器。但是，在现代现实中，在Assembler中工作并不总是很方便，因为在项目开发过程中，命令系统可能会由于例如变化的需求而发生变化。因此，与为软件处理器轻松实现高级语言编译器（JAV）的任务相关。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python编译器-Uzh似乎是用于为软件处理器开发软件的便捷工具箱。用于将基元和宏定义为目标语言功能的工具包允许在处理器的汇编语言中实现关键位置。本文讨论了堆栈体系结构处理器的编译器适应性要点。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而不是题词：</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您将一只成年老鼠</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并小心地握住，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将针塞入其中，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您将得到一只刺猬。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果这只刺猬的</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
鼻子被塞住了，以免呼吸，那么</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在更深的地方，扔进河里，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
你会得到一个怒气。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果这个r缩，</font><font style="vertical-align: inherit;">
将</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
头放在虎钳中，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用力拉尾巴，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您将得到一条蛇。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果已经这样，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
准备好两把刀... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，他可能会死，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是这个主意很好！</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">介绍</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 在许多情况下，实施测量仪器，研究设备时，最好使用可重构的FPGA / FPGA解决方案作为系统的主要核心。由于能够轻松，快速地更改工作逻辑，以及由于数据处理和控制信号的硬件加速，这种方法具有许多优势。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于广泛的任务，例如数字信号处理，嵌入式控制系统，数据采集和分析系统，该方法已经证明了自己的方法，包括将一个由FPGA逻辑实现的解决方案模块组合到一个基于一个或多个关键流程和程序控制元素的解决方案中。几个软件处理器，用于常规管理和协调，以及实现与用户或外部设备/节点的交互。</font><font style="vertical-align: inherit;">在这种情况下，使用软件处理器可使我们略微减少调试和验证系统控制算法或单个节点的交互算法所花费的时间。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">典型的愿望清单</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 在这种情况下，软处理器通常不需要超高性能（因为更容易实现，因此我使用FPGA逻辑和硬件资源）。</font><font style="vertical-align: inherit;">它们可以非常简单（从现代微控制器的角度来看-几乎是原始的），因为 </font><font style="vertical-align: inherit;">他们无需复杂的中断系统即可完成工作，仅与某些节点或接口一起工作，而无需支持特定的命令系统。</font><font style="vertical-align: inherit;">它们可以有很多，而它们每个只能执行一组特定的算法或子程序。</font><font style="vertical-align: inherit;">根据当前任务的要求，软处理器的容量也可以是任何容量，包括一个字节的整数倍。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
软处理器的典型目标是：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令系统的足够功能，可能针对任务进行了优化；</font></font></li>
<li>   , ..      ;</li>
<li> –   ,        .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 当然，软件处理器的问题是缺少针对它们的开发工具，尤其是如果其指令系统不是其流行的处理器内核之一的指令的子集时。</font><font style="vertical-align: inherit;">在这种情况下，开发人员必须解决此问题。</font><font style="vertical-align: inherit;">它的直接解决方案是为软件处理器创建汇编语言编译器。</font><font style="vertical-align: inherit;">但是，在现代现实中，在Assembler中工作并不总是很方便，尤其是在项目开发过程中团队系统由于需求变化而发生变化时。</font><font style="vertical-align: inherit;">因此，将上述要求添加到易于实现用于软处理器的高级语言编译器（HLV）的要求是合乎逻辑的。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">源组件</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 堆栈处理器以很高的合规性满足这些要求，因为 </font><font style="vertical-align: inherit;">无需寻址寄存器，命令的位深度可能很小。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它们的数据的位深度可以变化，并且与命令系统的位深度无关。</font><font style="vertical-align: inherit;">作为编译过程中程序代码中间表示的事实上的硬件实现（尽管有一些警告），您可以以较低的人工成本将任何语言的语法转换为可执行代码，并将其翻译成可执行代码（尽管这是虚拟堆叠机或无上下文语法-存储自动机）。</font><font style="vertical-align: inherit;">此外，对于堆栈处理器，Fort语言实际上是“本机”语言。</font><font style="vertical-align: inherit;">为堆栈处理器实现Fort编译器的人工成本可与Assembler相比，在未来的程序实现中具有更大的灵活性和效率。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了构建一种以接近实时的方式从智能传感器收集数据的系统，Fort处理器被选作软处理器的参考解决方案（所谓的参考设计），在[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]中进行了</font><font style="vertical-align: inherit;">描述</font><font style="vertical-align: inherit;">（以下简称</font><font style="vertical-align: inherit;">为“参考设计”）。</font><font style="vertical-align: inherit;">有时被其作者的昵称称为whiteTiger处理器）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其主要特点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分离数据并返回堆栈</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈佛内存组织架构（独立的程序和数据内存，包括地址空间）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用简单的并行总线扩展外围设备。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理器不使用管道，命令的执行是推挽式的：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获取命令和操作数；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 执行命令并保存结果。</font></font></li>
</ol></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 该处理器由程序代码的UART加载器补充，它使您可以更改可执行程序，而无需重新编译FPGA项目。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关于FPGA中块存储的配置，指令的容量设置为9位。数据的位深度设置为32位，但基本上可以是任意值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
处理器代码使用VHDL编写，无需使用任何特定的库，这使您可以在任何制造商的FPGA上使用此项目。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于相对广泛的用途，降低“输入阈值”以及重用代码和应用代码开发，更方便的是切换到Fort以外的Java引擎（部分原因是矿山流程序员对这种语言的复杂性及其代码的可读性存在迷信和误解。 （顺便说一下，这项工作的一位作者对类C语言有类似的看法）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基于多种因素，实验选择了Python语言（Python）以“绑定”软件处理器和Java语言引擎。这是一种高级通用编程语言，致力于提高开发人员的生产率和代码可读性，支持多种编程范例，包括结构，面向对象，功能，命令式和面向方面[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新手开发者，其延伸MyHDL [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]是</font><font style="vertical-align: inherit;">有趣</font><font style="vertical-align: inherit;">，它允许硬件描述元件和结构在Python和将其转化为VHDL或Verilog代码。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不久前，Uzh编译器[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font><font style="vertical-align: inherit;">宣布</font><font style="vertical-align: inherit;">-用于Zmey FPGA软件处理器的小型编译器（具有多线程支持的32位堆栈体系结构-如果您遵循版本/修改/验证链-Zmey是whiteTiger处理器的遥远后代）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uzh也是Python中的静态编译子集的基础上，看好raddsl工具箱[（用于快速创建DSL的编译器原型的工具集）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，影响工作方向选择的因素可以大致表述为：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对降低FPGA上的设备和系统新手开发人员的“入门门槛”的工具的兴趣（语法上，Python对于初学者而言并不像VHDL那样“吓人”）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在项目中争取和谐和单一风格（理论上可以用Python描述软件处理器所需的硬件模块和软件）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 随机巧合。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">微小，“几乎”毫无意义的细微差别</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Zmey处理器的源代码未公开，但是提供了其操作原理和某些体系结构功能的描述。</font><font style="vertical-align: inherit;">尽管它也是可堆叠的，但与whiteTiger处理器有许多关键区别：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆栈是软件-即 </font><font style="vertical-align: inherit;">用指针表示并放置在数据存储器的不同地址处；</font></font></li>
<li>     ,      - ;</li>
<li>          ;</li>
<li>  ,         .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 因此，Uzh编译器将这些功能考虑在内。编译器接受Python代码并在输出处生成启动流，以启动程序存储器和处理器数据存储器，关键是在编译阶段所有语言功能都可用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要安装Uzh编译器，只需下载其归档文件并将其解压缩到任何方便的文件夹中（最好遵循针对专用软件的一般建议-避免路径包含西里尔字母和空格）。您还需要下载raddsl工具包并将其解压缩到编译器的主文件夹中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
编译器测试文件夹包含用于软处理器的程序的示例； src文件夹包含编译器元素的源文本。</font><font style="vertical-align: inherit;">为方便起见，最好使用以下内容创建一个小的批处理文件（扩展名为.cmd）：，</font></font><b><code>c.py C:\D\My_Docs\Documents\uzh-master\tests\abc.py</code> </b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其中abc.py是带有用于软处理器的程序的文件名。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蛇咬尾巴或搭铁和软件</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 为了使Uzh适应whiteTiger处理器，将需要进行一些更改，并且必须对处理器本身进行一些更正。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸运的是，编译器中没有太多要调整的地方。</font><font style="vertical-align: inherit;">主要的“与硬件相关的”文件：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asm.py-汇编程序和数字的形成（文字）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gen.py-低级代码生成规则（函数，变量，转换和条件）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream.py-形成引导流；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">macro.py-宏定义，实际上-具有特定于硬件的功能的基本语言的扩展。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 在原始的白色老虎处理器设计中，UART加载器仅初始化程序存储器。</font><font style="vertical-align: inherit;">引导加载程序算法很简单，但是已经建立并且可靠：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 当接收到某个控制字节时，加载器在处理器复位的内部线路上设置活动级别；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二个字节命令复位存储器地址计数器；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后从最年轻的字母开始，跟随一个传输单词的笔记本序列，再加上一个笔记本编号；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在带有打包笔记本的每个字节之后，紧接着是一对控制字节，第一个控制字节在存储器写允许行上设置活动级别，第二个将其重置；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成打包笔记本的顺序后，复位行上的活动电平将被控制字节删除。 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 由于编译器还使用数据存储器，因此有必要修改加载程序，使其也可以初始化数据存储器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于数据存储器包含在处理器内核的逻辑中，因此有必要多路复用其数据线和控制线。</font><font style="vertical-align: inherit;">为此，引入了其他信号DataDinBtemp，LoaderAddrB，DataWeBtemp-内存中端口的数据，地址和写入权限。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 现在，引导程序代码如下所示：</font></font><br>
<br>
<pre><code class="vhdl hljs">uart_unit: <span class="hljs-keyword">entity</span> work.uart
<span class="hljs-comment">--uart_unit: entity uart</span>
  <span class="hljs-keyword">Generic</span> <span class="hljs-keyword">map</span>(<font></font>
    ClkFreq =&gt; <span class="hljs-number">50_000_000</span>,<font></font>
    Baudrate =&gt; <span class="hljs-number">115200</span>)
  <span class="hljs-keyword">port</span> <span class="hljs-keyword">map</span>(<font></font>
    clk =&gt; clk,<font></font>
    rxd =&gt; rx,<font></font>
    txd =&gt; tx,<font></font>
    dout =&gt; receivedByte,<font></font>
    received =&gt; received,<font></font>
    din =&gt; transmitByte,<font></font>
    transmit =&gt; transmit);<font></font>
    <font></font>
<span class="hljs-keyword">process</span>(clk)
<span class="hljs-keyword">begin</span>
  <span class="hljs-keyword">if</span> rising_edge(clk) <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">if</span> received = <span class="hljs-string">'1'</span> <span class="hljs-keyword">then</span>
      <span class="hljs-keyword">case</span> conv_integer(receivedByte) <span class="hljs-keyword">is</span>
      <span class="hljs-comment">-- 0-F   - 0-3 bits</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">0</span> <span class="hljs-keyword">to</span> <span class="hljs-number">15</span> =&gt; CodeDinA(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<font></font>
		                  DataDinBtemp(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);
      <span class="hljs-comment">-- 10-1F -4-7bits</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">16</span> <span class="hljs-keyword">to</span> <span class="hljs-number">31</span> =&gt; CodeDinA(<span class="hljs-number">7</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">4</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<font></font>
		                   DataDinBtemp(<span class="hljs-number">7</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">4</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>); 
      <span class="hljs-comment">-- 20-2F -8bit </span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">32</span> <span class="hljs-keyword">to</span> <span class="hljs-number">47</span> =&gt; CodeDinA(<span class="hljs-number">8</span>) &lt;= receivedByte(<span class="hljs-number">0</span>);<font></font>
	                   DataDinBtemp(<span class="hljs-number">11</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">8</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);
	  <span class="hljs-keyword">when</span> <span class="hljs-number">48</span> <span class="hljs-keyword">to</span> <span class="hljs-number">63</span> =&gt; DataDinBtemp(<span class="hljs-number">15</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">12</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);
	  <span class="hljs-keyword">when</span> <span class="hljs-number">64</span> <span class="hljs-keyword">to</span> <span class="hljs-number">79</span> =&gt; DataDinBtemp(<span class="hljs-number">19</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">16</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);
	  <span class="hljs-keyword">when</span> <span class="hljs-number">80</span> <span class="hljs-keyword">to</span> <span class="hljs-number">95</span> =&gt; DataDinBtemp(<span class="hljs-number">23</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">20</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);
	  <span class="hljs-keyword">when</span> <span class="hljs-number">96</span> <span class="hljs-keyword">to</span> <span class="hljs-number">111</span> =&gt; DataDinBtemp(<span class="hljs-number">27</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">24</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);
        <span class="hljs-keyword">when</span> <span class="hljs-number">112</span> <span class="hljs-keyword">to</span> <span class="hljs-number">127</span> =&gt; DataDinBtemp(<span class="hljs-number">31</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">28</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<font></font>
<font></font>
      <span class="hljs-comment">-- F0 addr=0</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">240</span> =&gt; CodeAddrA &lt;= (<span class="hljs-keyword">others</span> =&gt; <span class="hljs-string">'0'</span>);
      <span class="hljs-comment">-- F1 - WE=1</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">241</span> =&gt; CodeWeA &lt;= <span class="hljs-string">'1'</span>;
      <span class="hljs-comment">-- F2 WE=0 addr++</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">242</span> =&gt; CodeWeA &lt;= <span class="hljs-string">'0'</span>; CodeAddrA &lt;= CodeAddrA + <span class="hljs-number">1</span>;
      <span class="hljs-comment">-- F3 RESET=1</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">243</span> =&gt; int_reset &lt;= <span class="hljs-string">'1'</span>;
      <span class="hljs-comment">-- F4 RESET=0</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">244</span> =&gt; int_reset &lt;= <span class="hljs-string">'0'</span>;<font></font>
<font></font>
      <span class="hljs-comment">-- F5 addr=0</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">245</span> =&gt; LoaderAddrB &lt;= (<span class="hljs-keyword">others</span> =&gt; <span class="hljs-string">'0'</span>);
      <span class="hljs-comment">-- F6 - WE=1</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">246</span> =&gt; DataWeBtemp &lt;= <span class="hljs-string">'1'</span>;
      <span class="hljs-comment">-- F7 WE=0 addr++</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">247</span> =&gt; DataWeBtemp &lt;= <span class="hljs-string">'0'</span>; LoaderAddrB &lt;= LoaderAddrB + <span class="hljs-number">1</span>;<font></font>
		  <font></font>
		  <font></font>
        <span class="hljs-keyword">when</span> <span class="hljs-keyword">others</span> =&gt; <span class="hljs-keyword">null</span>;
      <span class="hljs-keyword">end</span> <span class="hljs-keyword">case</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;
  <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;
<span class="hljs-keyword">end</span> <span class="hljs-keyword">process</span>;<font></font>
<font></font>
<span class="hljs-comment">---- end of loader</span><font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在活动复位级别下，DataDinBtemp，LoaderAddrB，DataWeBtemp信号连接到相应的数据存储端口。</font></font><br>
<br>
<pre><code class="vhdl hljs">…
    <span class="hljs-keyword">if</span> reset = <span class="hljs-string">'1'</span> <span class="hljs-keyword">or</span> int_reset = <span class="hljs-string">'1'</span> <span class="hljs-keyword">then</span>
      DSAddrA &lt;= (<span class="hljs-keyword">others</span> =&gt; <span class="hljs-string">'0'</span>);      <font></font>
      <font></font>
      RSAddrA &lt;= (<span class="hljs-keyword">others</span> =&gt; <span class="hljs-string">'0'</span>);<font></font>
      RSAddrB &lt;= (<span class="hljs-keyword">others</span> =&gt; <span class="hljs-string">'0'</span>);<font></font>
      RSWeA &lt;= <span class="hljs-string">'0'</span>;<font></font>
      <font></font>
      DataAddrB &lt;= LoaderAddrB;<font></font>
		DataDinB&lt;=DataDinBtemp;<font></font>
		DataWeB&lt;=DataWeBtemp;<font></font>
      DataWeA &lt;= <span class="hljs-string">'0'</span>;<font></font>
…<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据引导加载程序算法，有必要修改stream.py模块。现在，它具有两个功能。第一个函数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-get_val（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -将输入字分割为所需数量的四分位数。因此，对于whiteTiger处理器的9位指令，它们将被转换为三个四元组的组，并被转换为八个四元组的序列中的32位数据。第二个函数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接形成引导程序。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
流模块的最终形式：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_val</span>(<span class="hljs-params">x, by_4</span>):</span><font></font>
  r = []<font></font>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(by_4):<font></font>
    r.append((x &amp; <span class="hljs-number">0xf</span>) | (i &lt;&lt; <span class="hljs-number">4</span>))<font></font>
    x &gt;&gt;= <span class="hljs-number">4</span>
  <span class="hljs-keyword">return</span> r<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make</span>(<span class="hljs-params">code, data, core=<span class="hljs-number">0</span></span>):</span>
  <span class="hljs-comment">#        0  </span>
  stream = [<span class="hljs-number">243</span>,<span class="hljs-number">245</span>] 
  <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data:
    <span class="hljs-comment">#    32- </span>
    <span class="hljs-comment">#         </span>
    stream += get_val(x, <span class="hljs-number">8</span>) + [<span class="hljs-number">246</span>, <span class="hljs-number">247</span>]
  <span class="hljs-comment">#       0</span>
  stream += [<span class="hljs-number">240</span>]
  <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> code:
    <span class="hljs-comment">#    9-  </span>
    <span class="hljs-comment">#         </span>
    stream += get_val(x, <span class="hljs-number">3</span>) + [<span class="hljs-number">241</span>, <span class="hljs-number">242</span>]
  <span class="hljs-comment">#  </span>
  stream.append(<span class="hljs-number">244</span>)<font></font>
<font></font>
  <span class="hljs-keyword">return</span> bytearray(stream)<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 编译器中的以下更改将影响asm.py模块，该模块描述了处理器的命令系统（已编写命令助记符和命令操作码）以及表示/编译数值-文字的方式。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
命令打包成字典，而lite（）函数负责文字。如果命令系统的一切都很简单-助记符列表和相应的操作码只是在变化，那么文字的情况会有些不同。 Zmey处理器具有8位指令，并且有许多用于处理文字的专用指令。在whiteTiger中，第9位指示操作码是命令还是数字的一部分。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果单词的最高（第9位）为1，则操作码将被解释为数字-例如，四个连续的带有数字符号的操作码将形成一个32位数字。</font><font style="vertical-align: inherit;">数字结尾的标志是命令操作码的存在-为了确定性和确保一致性，数字确定的结尾是NOP命令的操作码（“无操作”）。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，修改后的lit（）函数如下所示：</font></font><br>
<br>
<pre><code class="python hljs">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lit</span>(<span class="hljs-params">x</span>):</span>
  x &amp;= <span class="hljs-number">0xffffffff</span><font></font>
  r = [] <font></font>
  <span class="hljs-keyword">if</span> (x&gt;&gt;<span class="hljs-number">24</span>) &amp; <span class="hljs-number">255</span> :<font></font>
    r.append(int((x&gt;&gt;<span class="hljs-number">24</span>) &amp; <span class="hljs-number">255</span>) | <span class="hljs-number">256</span>)
  <span class="hljs-keyword">if</span> (x&gt;&gt;<span class="hljs-number">16</span>) &amp; <span class="hljs-number">255</span>:<font></font>
    r.append(int((x&gt;&gt;<span class="hljs-number">16</span>) &amp; <span class="hljs-number">255</span>) | <span class="hljs-number">256</span>)
  <span class="hljs-keyword">if</span> (x&gt;&gt;<span class="hljs-number">8</span>) &amp; <span class="hljs-number">255</span>:<font></font>
    r.append(int((x&gt;&gt;<span class="hljs-number">8</span>) &amp; <span class="hljs-number">255</span>) | <span class="hljs-number">256</span>)<font></font>
  r.append(int(x &amp; <span class="hljs-number">255</span>) | <span class="hljs-number">256</span>)<font></font>
  r += asm(<span class="hljs-string">"NOP"</span>)
  <span class="hljs-keyword">return</span> list(r)<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主要和最重要的更改/定义在gen.py模块中。</font><font style="vertical-align: inherit;">此模块定义了在汇编器级别上工作/执行高级代码的基本逻辑：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有条件的和无条件的跳跃；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用函数并将参数传递给它们；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从函数返回并返回结果；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调整程序存储器，数据存储器和堆栈的大小；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理器启动时的动作顺序。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 为了支持Java，处理器必须能够任意处理内存和指针，并具有用于存储局部变量函数的内存区域。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Zmey处理器中，返回栈用于处理局部变量和函数自变量-函数自变量被传递给它，并且在进一步的工作中，它们通过返回栈的指针寄存器进行访问（读取，向上/向下修改，在指针地址处读取）。由于堆栈物理上位于数据存储器中，因此此类操作实质上可以简单地归结为存储器操作，并且全局变量位于同一存储器内。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在whiteTiger中，返回堆栈和数据堆栈是专用的硬件堆栈，具有其地址空间，并且没有堆栈指针指令。因此，需要通过数据存储器来组织将参数传递给函数并与局部变量一起使用的操作。增加数据堆栈的容量并返回以在其中存储相对较大的数据阵列没有太大意义；拥有稍大的数据存储器则更合逻辑。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 为了使用局部变量，添加了一个专用的LocalReg寄存器，其任务是存储指向分配给局部变量（一种堆）的内存区域的指针。还添加了使用它的操作（cpu.vhd文件-命令定义区域）：</font></font><br>
<br>
<pre><code class="vhdl hljs">
          <span class="hljs-comment">-- group 1; pop 0; push 1;</span>
          <span class="hljs-keyword">when</span> cmdLOCAL =&gt; DSDinA &lt;= LocalReg;
			 <span class="hljs-keyword">when</span> cmdLOCALadd =&gt; DSDinA &lt;= LocalReg; LocalReg &lt;= LocalReg+<span class="hljs-number">1</span>;
			 <span class="hljs-keyword">when</span> cmdLOCALsubb =&gt; DSDinA &lt;= LocalReg; LocalReg &lt;= LocalReg-<span class="hljs-number">1</span>;<font></font>
…<font></font>
          <span class="hljs-comment">-- group 2; pop 1; push 0;</span>
          <span class="hljs-keyword">when</span> cmdSETLOCAL =&gt; LocalReg &lt;= DSDinA;<font></font>
…<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LOCAL-将LocalReg指针的当前值返回到数据堆栈；</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SETLOCAL-设置从数据堆栈接收的新指针值；</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LOCALadd-将指针的当前值保留在数据堆栈上，并将其递增1；否则，该值为0。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LOCALsubb-将指针的当前值保留在数据堆栈上，并将其当前值减</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1。LOCALadd和LOCALsubb被添加以减少传递函数参数的操作期间的滴答声数量，反之亦然。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与原始的whiteTiger不同，数据存储器的连接稍有变化-现在，通过数据堆栈的第一个单元的输出不断寻址In内存端口，将数据堆栈的第二个单元的输出馈送到其输入：</font></font><br>
<br>
<pre><code class="vhdl hljs"><span class="hljs-comment">-- ++</span>
DataAddrB &lt;= DSDoutA(DataAddrB<span class="hljs-symbol">'range</span>);<font></font>
DataDinB &lt;= DSDoutB;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 执行STORE和FETCH命令的逻辑也已稍作纠正-FETCH在数据堆栈顶部的内存中接收端口的输出值，而STORE仅控制端口B的写使能信号：</font></font><br>
<br>
<pre><code class="vhdl hljs">…
          <span class="hljs-comment">-- group 3; pop 1; push 1;</span>
          <span class="hljs-keyword">when</span> cmdFETCH =&gt; DSDinA &lt;= DataDoutB;<font></font>
…<font></font>
          <span class="hljs-keyword">when</span> cmdSTORE =&gt;            <font></font>
            DataWeB &lt;= <span class="hljs-string">'1'</span>;<font></font>
…<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为培训的一部分，以及对底层（以及Fort语言的编译器级别）的某些硬件对循环的支持，在whiteTiger核心中添加了一个循环计数器堆栈（操作类似于声明数据和返回堆栈时的操作）：</font></font><br>
<br>
<pre><code class="vhdl hljs">…
<span class="hljs-comment">--  </span>
<span class="hljs-keyword">type</span> TCycleStack <span class="hljs-keyword">is</span> <span class="hljs-keyword">array</span>(<span class="hljs-number">0</span> <span class="hljs-keyword">to</span> LocalSize-<span class="hljs-number">1</span>) <span class="hljs-keyword">of</span> DataSignal;
<span class="hljs-keyword">signal</span> CycleStack: TCycleStack;
<span class="hljs-keyword">signal</span> CSAddrA, CSAddrB: StackAddrSignal;
<span class="hljs-keyword">signal</span> CSDoutA, CSDoutB: DataSignal;
<span class="hljs-keyword">signal</span> CSDinA, CSDinB: DataSignal;
<span class="hljs-keyword">signal</span> CSWeA, CSWeB: <span class="hljs-built_in">std_logic</span>;<font></font>
…<font></font>
<span class="hljs-comment">--  </span>
<span class="hljs-keyword">process</span>(clk)
<span class="hljs-keyword">begin</span>
  <span class="hljs-keyword">if</span> rising_edge(clk) <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">if</span> CSWeA = <span class="hljs-string">'1'</span> <span class="hljs-keyword">then</span><font></font>
      CycleStack(conv_integer(CSAddrA)) &lt;= CSDinA;<font></font>
      CSDoutA &lt;= CSDinA;<font></font>
    <span class="hljs-keyword">else</span><font></font>
      CSDoutA &lt;= CycleStack(conv_integer(CSAddrA));<font></font>
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;
  <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;
<span class="hljs-keyword">end</span> <span class="hljs-keyword">process</span>;<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
循环计数器命令已添加。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DO-将循环的迭代次数从数据堆栈移至计数器堆栈，并将指令计数器的递增值放在返回堆栈上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LOOP-检查计数器归零，如果未达到，则将计数器堆栈的顶部元素递减，执行到返回堆栈顶部地址的转换。如果计数器堆栈的顶部为零，则顶部元素被复位，从复位堆栈顶部到循环开始的返回地址也将被复位。</font></font><br>
<br>
<pre><code class="vhdl hljs">
	<span class="hljs-keyword">when</span> cmdDO =&gt; <span class="hljs-comment">-- DO - </span>
               RSAddrA &lt;= RSAddrA + <span class="hljs-number">1</span>; <span class="hljs-comment">-- </span>
               RSDinA &lt;= ip + <span class="hljs-number">1</span>;<font></font>
               RSWeA &lt;= <span class="hljs-string">'1'</span>;<font></font>
				<font></font>
               CSAddrA &lt;= CSAddrA + <span class="hljs-number">1</span>; <span class="hljs-comment">--</span><font></font>
         		CSDinA &lt;= DSDoutA;<font></font>
 		         CSWeA &lt;= <span class="hljs-string">'1'</span>;<font></font>
		         DSAddrA &lt;= DSAddrA - <span class="hljs-number">1</span>; <span class="hljs-comment">--</span>
		         ip &lt;= ip + <span class="hljs-number">1</span>;	<span class="hljs-comment">-- </span><font></font>
<font></font>
      <span class="hljs-keyword">when</span> cmdLOOP =&gt; <span class="hljs-comment">--            </span>
           <span class="hljs-keyword">if</span> conv_integer(CSDoutA) = <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
	          ip &lt;= ip + <span class="hljs-number">1</span>;	<span class="hljs-comment">-- </span>
		         RSAddrA &lt;= RSAddrA - <span class="hljs-number">1</span>; <span class="hljs-comment">-- </span>
		         CSAddrA &lt;= CSAddrA - <span class="hljs-number">1</span>; <span class="hljs-comment">-- </span>
            <span class="hljs-keyword">else</span>
		         CSDinA &lt;= CSDoutA - <span class="hljs-number">1</span>;<font></font>
		         CSWeA &lt;= <span class="hljs-string">'1'</span>;<font></font>
		         ip &lt;= RSDoutA(ip<span class="hljs-symbol">'range</span>);
            <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;<font></font>
			 <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，您可以开始修改gen.py模块的代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
* _SIZE变量不需要注释，仅需要替换处理器核心项目中指定的值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
STUB列表是一个临时存根，用于为转换地址创建一个位置，然后用编译器填充它们（当前值对应于代码存储器的24位地址空间）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
STARTUP列表-设置内核在复位后执行的操作顺序-在这种情况下，局部变量的内存的起始地址设置为900，并过渡到起点（如果不进行任何更改，则应用程序中的起点/入口点将在数据存储器地址中写入编译器2）：</font></font><br>
<br>
<pre><code class="python hljs">STARTUP = asm(<span class="hljs-string">"""
900  SETLOCAL
2 NOP FETCH JMP
"""</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
func（）的定义规定了调用函数时执行的操作，即，将函数参数传递到局部变量区域，为函数自身的局部变量分配内存。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">@act</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">t, X</span>):</span><font></font>
  t.c.entry = t.c.globs[X]<font></font>
  t.c.entry[<span class="hljs-string">"offs"</span>] = len(t.c.code) <span class="hljs-comment"># - 1</span>
  args = t.c.entry[<span class="hljs-string">"args"</span>]<font></font>
  temps_size = len(t.c.entry[<span class="hljs-string">"locs"</span>]) - args
<span class="hljs-comment">#      </span>
  t.out = asm(<span class="hljs-string">"LOCALadd STORE "</span> * args)
  <span class="hljs-keyword">if</span> temps_size:
<span class="hljs-comment">#      </span>
    t.out += asm(<span class="hljs-string">"LOCAL %d PLUS SETLOCAL"</span> % temps_size)
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Epilog（）定义了从函数返回时的操作-释放临时变量的内存，返回到调用点。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">epilog</span>(<span class="hljs-params">t, X</span>):</span>
  locs_size = len(t.c.entry[<span class="hljs-string">"locs"</span>])
<span class="hljs-comment">#    </span>
  t.out = asm(<span class="hljs-string">"RET"</span>)
  <span class="hljs-keyword">if</span> locs_size:
<span class="hljs-comment">#    ()  </span>
    t.out = asm(<span class="hljs-string">"LOCAL %d MINUS SETLOCAL"</span> % locs_size) + t.out
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用变量的操作是通过它们的地址来完成的，其关键定义是push_local（），它将“高级”变量的地址保留在数据堆栈上。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push_local</span>(<span class="hljs-params">t, X</span>):</span>
<span class="hljs-comment">#          </span>
<span class="hljs-comment">#  </span>
  t.out = asm(<span class="hljs-string">"LOCAL %d MINUS"</span> % get_loc_offset(t, X))
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下要点是条件转换和无条件转换。</font><font style="vertical-align: inherit;">whiteTiger处理器中的条件跳转将检查数据堆栈的第二个元素是否为0，如果满足条件，则跳转到堆栈顶部的地址。</font><font style="vertical-align: inherit;">无条件跳转只是将指令计数器的值设置为堆栈顶部的值。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">@act</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">goto_if_0</span>(<span class="hljs-params">t, X</span>):</span><font></font>
  push_label(t, X)<font></font>
  t.out += asm(<span class="hljs-string">"IF"</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><font></font>
<font></font>
<span class="hljs-meta">@act</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">goto</span>(<span class="hljs-params">t, X</span>):</span><font></font>
  push_label(t, X)<font></font>
  t.out += asm(<span class="hljs-string">"JMP"</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下两个定义指定了移位操作-仅在较低级别上应用了循环（这将使代码的大小有所增加-在最初，编译器只是将所需数量的基本移位操作放在一行中。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">@act</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shl_const</span>(<span class="hljs-params">t, X</span>):</span>
  t.out = asm(<span class="hljs-string">"%d DO SHL LOOP"</span> %(X<span class="hljs-number">-1</span>))
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><font></font>
<font></font>
<span class="hljs-meta">@act</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shr_const</span>(<span class="hljs-params">t, X</span>):</span>
  t.out = asm(<span class="hljs-string">"%d DO SHR LOOP"</span> %(X<span class="hljs-number">-1</span>))
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
底层的编译器主要定义是一组语言操作和内存使用规则：</font></font><br>
<br>
<pre><code class="python hljs">stmt = rule(alt(<font></font>
  seq(Push(Int(X)), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"%d"</span> % v.X))),<font></font>
  seq(Push(Local(X)), push_local),<font></font>
  seq(Push(Global(X)), push_global),<font></font>
  seq(Load(), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"NOP FETCH"</span>))),<font></font>
  seq(Store(), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"STORE"</span>))),<font></font>
  seq(Call(), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"CALL"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"+"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"PLUS"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"-"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"MINUS"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"&amp;"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"AND"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"|"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"OR"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"^"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"XOR"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"*"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"MUL"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"&lt;"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"LESS"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"&gt;"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"GREATER"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"=="</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"EQUAL"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"~"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"NOT"</span>))),<font></font>
  seq(ShlConst(X), shl_const),<font></font>
  seq(ShrConst(X), shr_const),<font></font>
  seq(Func(X), func),<font></font>
  seq(Label(X), label),<font></font>
  seq(Return(X), epilog),<font></font>
  seq(GotoIf0(X), goto_if_0),<font></font>
  seq(Goto(X), goto),<font></font>
  seq(Nop(), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"NOP"</span>))),<font></font>
  seq(Asm(X), to(<span class="hljs-keyword">lambda</span> v: asm(v.X)))<font></font>
))<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
macro.py模块允许您使用目标处理器的汇编程序中的宏定义来“扩展”目标语言的词典。</font><font style="vertical-align: inherit;">对于Java编译器，macro.py中的定义与该语言的“本机”运算符和函数没有区别。</font><font style="vertical-align: inherit;">因此，例如，在原始编译器中，定义了外部端口中值的I / O函数。</font><font style="vertical-align: inherit;">添加了具有存储器和局部变量的操作的测试序列以及一个延时操作。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">@macro(1,0)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">testasm</span>(<span class="hljs-params">c,x</span>):</span>
  <span class="hljs-keyword">return</span> Asm(<span class="hljs-string">"1 1 OUTPORT 0 1 OUTPORT 11 10 STORE 10 FETCH 1 OUTPORT  15 100 STORE 100  FETCH 1 OUTPORT"</span>)<font></font>
<font></font>
<span class="hljs-meta">@macro(1,0)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">testlocal</span>(<span class="hljs-params">c,x</span>):</span>
   <span class="hljs-keyword">return</span> Asm(<span class="hljs-string">"1 100 STORE 2 101 STORE 100 SETLOCAL LOCAL NOP FETCH 1 OUTPORT LOCAL 1 PLUS NOP FETCH 1 OUTPORT"</span>)<font></font>
<font></font>
<span class="hljs-meta">@prim(1, 0)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delay</span>(<span class="hljs-params">c, val</span>):</span>
  <span class="hljs-keyword">return</span> [val, Asm(<span class="hljs-string">"DO LOOP"</span>)]<font></font>
<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试中 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 我们处理器的一个小型测试高级程序包含用于计算阶乘的函数的定义，以及实现无限循环中从1到7到端口的阶乘值串行输出的主要函数。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fact</span>(<span class="hljs-params">n</span>):</span>
  r = <span class="hljs-number">1</span>
  <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">1</span>:<font></font>
    r *= n<font></font>
    n -= <span class="hljs-number">1</span>
  <span class="hljs-keyword">return</span> r<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
  n=<span class="hljs-number">1</span>
  <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
     digital_write(<span class="hljs-number">1</span>, fact(n))<font></font>
     delay(<span class="hljs-number">10</span>)<font></font>
     n=(n+<span class="hljs-number">1</span>)&amp;<span class="hljs-number">0x7</span><font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，可以通过一个简单的脚本或从命令行按以下顺序</font><font style="vertical-align: inherit;">
启动</font><font style="vertical-align: inherit;">它进行编译：</font><font style="vertical-align: inherit;">结果，将生成一个启动文件stream.bin，该文件可以通过串行端口（在现代情况下，通过转换器提供的任何虚拟串行端口）传输到FPGA的处理器内核中。 USB-UART接口）。</font><font style="vertical-align: inherit;">结果，程序占用了146个字（9位）的程序存储器，而数据存储器中的3个字。</font></font><br>
<code>c.py C:\D\My_Docs\Documents\uzh-master\tests\fact2.py<br>
</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 通常，Uzh编译器似乎是用于为软件处理器开发软件的简便工具包。</font><font style="vertical-align: inherit;">至少就程序员的可用性而言，它是汇编程序的绝佳替代品。</font><font style="vertical-align: inherit;">用于将基元和宏定义为目标语言功能的工具包允许在处理器的汇编语言中实现关键位置。</font><font style="vertical-align: inherit;">对于堆栈体系结构处理器，编译器适配过程不会太复杂和冗长。</font><font style="vertical-align: inherit;">我们可以说，只有在编译器的源代码可用性有所帮助的情况下-编译器的关键部分正在发生变化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FPGA Altera Cyclone V系列的处理器综合结果（32位容量，4K字的程序存储器和1K RAM）得出以下结果：</font></font><br>
<br>
<pre><code class="plaintext hljs">Family	Cyclone V<font></font>
Device	5CEBA4F23C7<font></font>
Logic utilization (in ALMs)	694 / 18,480 ( 4 % )<font></font>
Total registers	447<font></font>
Total pins	83 / 224 ( 37 % )<font></font>
Total virtual pins	0<font></font>
Total block memory bits	72,192 / 3,153,920 ( 2 % )<font></font>
Total DSP Blocks	2 / 66 ( 3 % )<font></font>
</code></pre><br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文献</font></font></b></i><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VHDL上的Forth处理器// </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m.habr.com/zh/post/149686</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python-Wikipedia // </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Python</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们开始在Python上进行FPGA _ Habr // </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m.habr.com/en/post/439638</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MyHDL // </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.myhdl.org</font></font></a> </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github-true-grue_uzh_ Uzh编译器// </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/true-grue/uzh</font></font></a> </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github-true-grue_raddsl_用于DSL编译器快速原型制作的工具// </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/true-grue/raddsl</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sovietov.com/txt/dsl_python_conf.pdf</font></font></a> </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作者感谢Zmey软件处理器和Uzh编译器的开发人员的咨询和耐心。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN491590/index.html">我们会分析有关保护个人数据和信息安全的建议-您应注意的事项</a></li>
<li><a href="../zh-CN491592/index.html">从星系模型到原子-AI实现中的简单技巧可加快数十亿次仿真速度</a></li>
<li><a href="../zh-CN491594/index.html">一种新的密码学方法，有望引起人们的高度保密，受到怀疑</a></li>
<li><a href="../zh-CN491600/index.html">城市与数据：使用数据科学分析布拉格物体的步行距离</a></li>
<li><a href="../zh-CN491602/index.html">播客：为什么新手IT编辑的工作是一种“军事戏剧”，我们将如何处理</a></li>
<li><a href="../zh-CN491606/index.html">如何制作开始菜单和小地图</a></li>
<li><a href="../zh-CN491608/index.html">来自《茶杯头》和《战神》的动画提示</a></li>
<li><a href="../zh-CN491610/index.html">声明式数据过滤在最前面。吨/吨</a></li>
<li><a href="../zh-CN491612/index.html">以Sberbank的优先股和普通股为例比较python中两只股票的报价动态</a></li>
<li><a href="../zh-CN491614/index.html">为什么Masterhost注定要失败：内幕</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>