<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚úàÔ∏è üò¨ üå≠ Sedikit tentang relokasi di kernel Linux ü§¥üèæ ü§Ωüèº üõÄüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami akan memecahkan masalah sederhana - pilih blok memori di ruang kernel Linux, masukkan beberapa kode biner ke dalamnya dan jalankan. Untuk melakuk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Sedikit tentang relokasi di kernel Linux</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504442/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan memecahkan masalah sederhana - pilih blok memori di ruang kernel Linux, masukkan beberapa kode biner ke dalamnya dan jalankan. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kita menulis modul kernel, di dalamnya kita mendefinisikan fungsi foo, yang akan memainkan peran kode biner yang kita butuhkan, kemudian, menggunakan fungsi module_alloc, pilih blok memori, salin seluruh fungsi ini ke dalamnya melalui memcpy dan berikan kontrol. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Begini tampilannya:</font></font><br>
<a name="habracut"></a><br>
<pre><code class="plaintext hljs">static noinline int foo(int ret)<font></font>
{<font></font>
	return (ret + 2);<font></font>
}<font></font>
<font></font>
static int exe_init(void)<font></font>
{<font></font>
	int ret = 0;<font></font>
	int (*new_foo)(int);<font></font>
<font></font>
	ret = foo(0);<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
<font></font>
	new_foo = module_alloc(PAGE_SIZE);<font></font>
	set_memory_x((unsigned long)new_foo, 1);<font></font>
<font></font>
	printk(KERN_INFO "foo=%lx new_foo=%lx\n",<font></font>
		(unsigned long)foo, (unsigned long)new_foo);<font></font>
<font></font>
	memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
<font></font>
	ret = new_foo(1);<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
<font></font>
	vfree(new_foo);<font></font>
	return 0;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi exe_init dipanggil saat modul dimuat. </font><font style="vertical-align: inherit;">Kami melihat hasil kerja di log kernel:</font></font><br>
<br>
<pre><code class="plaintext hljs">[ 6972.522422] ret=2<font></font>
[ 6972.522443] foo=ffffffffc0000000 new_foo=ffffffffc0007000<font></font>
[ 6972.522457] ret=3<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya bekerja dengan benar. </font><font style="vertical-align: inherit;">Dan sekarang kita menambahkan fungsi printk ke foo untuk menampilkan argumen:</font></font><br>
<br>
<pre><code class="plaintext hljs">static noinline int foo(int ret)<font></font>
{<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
	return (ret + 2);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dan membuang 25 byte konten fungsi new_foo () sebelum memberikan kontrol padanya:</font></font><br>
<br>
<pre><code class="plaintext hljs">	memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
	dump((unsigned long)new_foo);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dump didefinisikan sebagai</font></font><br>
<br>
<pre><code class="plaintext hljs">static inline void dump(unsigned long x)<font></font>
{<font></font>
	int i;<font></font>
	for (i = 0; i &lt; 25; i++) \<font></font>
		pr_cont("%.2x ", *((unsigned char *)(x) + i) &amp; 0xFF); \<font></font>
	pr_cont("\n");<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memuat modul dan mengalami kerusakan dengan pesan berikut di log:</font></font><br>
<br>
<pre><code class="plaintext hljs">[ 8482.806092] ret=0<font></font>
[ 8482.806092] ret=2<font></font>
[ 8482.806111] foo=ffffffffc0000000 new_foo=ffffffffc0007000<font></font>
[ 8482.806113] 53 89 fe 89 fb 48 c7 c7 24 10 00 c0 e8 e8 3d 0b c1 8d 43 02 5b c3 66 2e 0f <font></font>
[ 8482.806135] invalid opcode: 0000 [#1] SMP NOPTI<font></font>
[ 8482.806639] CPU: 0 PID: 5081 Comm: insmod Tainted: G           O      5.4.27 #12<font></font>
[ 8482.807669] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006<font></font>
[ 8482.808560] RIP: 0010:irq_create_direct_mapping+0x79/0x90<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entah bagaimana, kami berakhir di fungsi irq_create_direct_mapping, meskipun kami harus memanggil printk. </font><font style="vertical-align: inherit;">Mari kita cari tahu apa yang terjadi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, lihat daftar fungsi foo yang dibongkar. </font><font style="vertical-align: inherit;">Dapatkan dengan perintah objdump -d:</font></font><br>
<br>
<pre><code class="plaintext hljs">Disassembly of section .text:<font></font>
<font></font>
0000000000000000 &lt;foo&gt;:<font></font>
   0:	53                   	push   %rbx<font></font>
   1:	89 fe                	mov    %edi,%esi<font></font>
   3:	89 fb                	mov    %edi,%ebx<font></font>
   5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi<font></font>
   c:	e8 00 00 00 00       	callq  11 &lt;foo+0x11&gt;<font></font>
  11:	8d 43 02             	lea    0x2(%rbx),%eax<font></font>
  14:	5b                   	pop    %rbx<font></font>
  15:	c3                   	retq   <font></font>
  16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)<font></font>
  1d:	00 00 00 <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi foo terletak di awal bagian teks. Pada offset 0xC, opcode dari perintah panggilan dekat e8 terletak - dekat, karena dijalankan di segmen kode saat ini, nilai pemilih tidak berubah. 4 byte berikutnya adalah offset relatif terhadap nilai dalam register RIP yang kontrolnya akan ditransfer, mis. RIP = offset RIP +, sesuai dengan dokumentasi Intel (Manual Pengembang Perangkat Lunak Arsitektur Intel 64 dan IA-32, Referensi Set Instruksi AZ):</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offset relatif (rel16 atau rel32) umumnya ditentukan sebagai label dalam kode rakitan. </font><font style="vertical-align: inherit;">Tetapi pada level kode mesin, kode tersebut dikodekan sebagai nilai langsung yang ditandatangani, 16 atau 32 bit. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nilai ini ditambahkan ke nilai dalam register EIP (RIP). </font><font style="vertical-align: inherit;">Dalam mode 64-bit, offset relatif selalu merupakan nilai langsung 32-bit yang tandanya diperluas menjadi 64-bit sebelum ditambahkan ke nilai dalam register RIP untuk perhitungan target.</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita tahu alamat fungsi foo, yaitu 0xffffffffc0000000, jadi dalam RIP = 0xffffffffc0000000 + 0xc + 0x5 = 0xffffffffc00000011 (0xc adalah offset untuk instruksi e8, 1 byte instruksi dan 4 byte offset). </font><font style="vertical-align: inherit;">Kami tahu offsetnya, karena </font><font style="vertical-align: inherit;">fungsi tubuh dibuang. </font><font style="vertical-align: inherit;">Mari kita hitung ke mana panggilan untuk mengirim kita ke fungsi yang akan dikirim:</font></font><br>
<br>
<pre><code class="plaintext hljs">0xffffffffc00000011 + 0xffffffffc10b3de8 = 0xffffffff810b3df9
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah alamat fungsi printk:</font></font><br>
<pre><code class="plaintext hljs"># cat /proc/kallsyms | grep ffffffff810b3df9  <font></font>
ffffffff810b3df9 T printk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan sekarang hal yang sama berlaku untuk new_foo, yang alamatnya 0xffffffffc0007000</font></font><br>
<br>
<pre><code class="plaintext hljs">0xffffffffc0007011 + 0xffffffffc10b3de8 = 0xffffffff810badf9
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak ada alamat seperti itu di kallsyms, tetapi ada 0xffffffff810badf9 - 0x79 = 0xffffffff88badbad80</font></font><br>
<pre><code class="plaintext hljs"># cat /proc/kallsyms | grep ffffffff810bad80<font></font>
ffffffff810bad80 T irq_create_direct_mapping<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah fungsi dimana crash terjadi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mencegah kerusakan, hitung ulang offsetnya, dengan mengetahui alamat fungsi new_foo:</font></font><br>
<br>
<pre><code class="plaintext hljs">memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
unsigned int delta = (unsigned long)printk - (unsigned long)new_foo - 0x11;<font></font>
*(unsigned int *)((void *)new_foo + 0xD) = delta;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah koreksi ini, tidak akan ada kerusakan, fungsi new_foo akan berhasil menjalankan dan mengembalikan kontrol. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah terpecahkan. </font><font style="vertical-align: inherit;">Tetap hanya untuk memahami mengapa dalam daftar disassembler offset setelah opcode e8 adalah nol, tetapi tidak ada fungsi dalam dump. </font><font style="vertical-align: inherit;">Untuk melakukan ini, pertimbangkan relokasi apa dan bagaimana kernel bekerja dengannya. </font><font style="vertical-align: inherit;">Tapi pertama-tama, sedikit tentang format ELF.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ELF adalah singkatan dari Executable and Linkable Format - format file yang dapat dieksekusi dan komposit. File ELF adalah kumpulan bagian. Bagian menyimpan satu set objek yang diperlukan untuk linker untuk membentuk gambar yang dapat dieksekusi - instruksi, data, tabel simbol, catatan relokasi, dll. Setiap bagian dijelaskan oleh tajuk. Semua header dikumpulkan dalam tabel header dan pada dasarnya adalah array di mana setiap elemen memiliki indeks. Header bagian berisi offset ke awal bagian dan informasi overhead lainnya, seperti tautan ke bagian lain dengan menentukan indeks dalam tabel header.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika merakit test case kami, kompiler tidak tahu alamat fungsi printk, oleh karena itu mengisi lokasi panggilan dengan nilai nol dan, menggunakan catatan relokasi, memberi tahu kernel bahwa posisi ini harus diisi dengan nilai yang valid. Catatan relokasi berisi offset ke posisi di mana Anda ingin melakukan perubahan (posisi relokasi), jenis relokasi dan indeks simbol dalam tabel simbol, alamat yang harus diganti pada offset yang ditentukan. Untuk apa jenis relokasi? Kami pertimbangkan di bawah ini. Judul bagian catatan relokasi merujuk melalui indeks ke pos bagian dengan tabel karakter dan bagian, relatif terhadap permulaan yang ditentukan offset ke posisi relokasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat melihat isi catatan relokasi menggunakan utilitas objdump dengan saklar -r.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dari daftar dibongkar, kita tahu bahwa pada offset 0xD perlu untuk menulis alamat fungsi printk, jadi kami mencari output objdump dengan posisi berikut:</font></font><br>
<br>
<pre><code class="plaintext hljs">000000000000000d R_X86_64_PC32     printk-0x0000000000000004
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, kami memiliki catatan relokasi yang diperlukan yang menunjukkan posisi pada offset 0xD, dan nama simbol yang alamatnya harus ditulis untuk posisi ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nilai (-4). </font><font style="vertical-align: inherit;">yang ditambahkan ke alamat fungsi printk disebut addendum, dan diperhitungkan saat menghitung hasil akhir relokasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang lihat simbol printk:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ objdump -t exe.ko | grep printk<font></font>
0000000000000000         *UND*	0000000000000000 printk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada simbol, itu tidak terdefinisi di dalam modul (tidak terdefinisi), jadi kami akan mencarinya di kernel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akan lebih informatif untuk melihat catatan relokasi dan simbol dalam bentuk biner. </font><font style="vertical-align: inherit;">Ini dapat dilakukan dengan menggunakan wireshark, dapat mem-parsing format ELF. </font><font style="vertical-align: inherit;">Inilah entri relokasi kami (salin tempel dari writeshark, LSB di sebelah kiri):</font></font><br>
<br>
<pre><code class="plaintext hljs">  0d 00 00 00 00 00 00 00  02 00 00 00 22 00 00 00  fc ff ff ff ff ff ff ff<font></font>
  |                     |  |          ||         |  |                     |<font></font>
  +----  -------+  +--  ---++---+  +---- addendum  ------+<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bandingkan entri ini dengan definisi struktur yang sesuai dari &lt;linux / elf.h&gt;:</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct elf64_rela {<font></font>
  Elf64_Addr r_offset;	/* Location at which to apply the action */<font></font>
  Elf64_Xword r_info;	/* index and type of relocation */<font></font>
  Elf64_Sxword r_addend;	/* Constant addend used to compute value */<font></font>
} Elf64_Rela;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kita memiliki 8 byte offset 0x00000000d, 4 byte tipe 0x00000002, 4 byte indeks dalam tabel karakter 0x00000022 (atau 34 dalam desimal) dan 8 byte addendum -4. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan di sini ada entri dari tabel simbol di nomor 34:</font></font><br>
<br>
<pre><code class="plaintext hljs">  01 01 00 00 10 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dan struktur terkait</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct elf64_sym {<font></font>
  Elf64_Word st_name;		/* Symbol name, index in string tbl */<font></font>
  unsigned char	st_info;	/* Type and binding attributes */<font></font>
  unsigned char	st_other;	/* No defined meaning, 0 */<font></font>
  Elf64_Half st_shndx;		/* Associated section index */<font></font>
  Elf64_Addr st_value;		/* Value of the symbol */<font></font>
  Elf64_Xword st_size;		/* Associated symbol size */<font></font>
} Elf64_Sym;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4 byte pertama 0x00000101 adalah indeks dalam tabel string .strtab dengan nama karakter ini, mis. printk. Kolom st_info mendefinisikan jenis simbol, bisa berupa fungsi, objek data, dll., Lihat spesifikasi ELF untuk detail lebih lanjut. Kami akan melewati bidang st_other, sekarang tidak menarik bagi kami, dan melihat tiga bidang terakhir st_shndx, st_value dan st_size. st_shndx - indeks header bagian di mana karakter didefinisikan. Kami melihat di sini nilai nol, karena simbol tidak didefinisikan di dalam modul, itu tidak ada di bagian yang tersedia. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, nilai st_value dan ukuran st_size juga nol. Bidang-bidang ini akan diisi oleh kernel saat memuat modul. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai perbandingan, lihat simbol foo, yang jelas ada:</font></font><br>
<br>
<pre><code class="plaintext hljs">  08 00 00 00 02 00 02 00  00 00 00 00 00 00 00 00  16 00 00 00 00 00 00 00
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Simbol mendefinisikan fungsi yang terletak di bagian .text di alamat relatif ke awal bagian 0x00000000, yaitu </font><font style="vertical-align: inherit;">di bagian paling awal, seperti yang kita lihat di daftar dibongkar, ukuran fungsi adalah 22 byte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Objdump akan menunjukkan kepada kita informasi yang sama tentang ini:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ objdump -t exe.ko | grep foo<font></font>
0000000000000000 l     F .text	0000000000000016 foo<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika kernel memuat modul, ia menemukan semua karakter yang tidak terdefinisi dan mengisi bidang st_value dan st_size dengan nilai yang valid. </font><font style="vertical-align: inherit;">Ini dilakukan dalam fungsi simplify_symbols, file kernel / module.c:</font></font><br>
<br>
<pre><code class="plaintext hljs">/* Change all symbols so that st_value encodes the pointer directly. */<font></font>
static int simplify_symbols(struct module *mod, const struct load_info *info)<font></font>
{<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam parameter fungsi, struktur load_info dari formulir berikut dilewatkan</font></font><br>
<br>
<pre><code class="plaintext hljs">struct load_info {<font></font>
	const char *name;<font></font>
	/* pointer to module in temporary copy, freed at end of load_module() */<font></font>
	struct module *mod;<font></font>
	Elf_Ehdr *hdr;<font></font>
	unsigned long len;<font></font>
	Elf_Shdr *sechdrs;<font></font>
	char *secstrings, *strtab;<font></font>
	unsigned long symoffs, stroffs, init_typeoffs, core_typeoffs;<font></font>
	struct _ddebug *debug;<font></font>
	unsigned int num_debug;<font></font>
	bool sig_ok;<font></font>
#ifdef CONFIG_KALLSYMS<font></font>
	unsigned long mod_kallsyms_init_off;<font></font>
#endif<font></font>
	struct {<font></font>
		unsigned int sym, str, mod, vers, info, pcpu;<font></font>
	} index;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bidang-bidang berikut ini menarik bagi kami: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - hdr - Header file ELF </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - sechdrs - pointer ke tabel header bagian </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - strtab - tabel nama simbol - satu set string dipisahkan oleh nol </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - index.sym - indeks header bagian yang berisi tabel simbol </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama-tama, fungsi akan mendapatkan akses ke bagian dengan tabel simbol. </font><font style="vertical-align: inherit;">Tabel simbol adalah array elemen bertipe Elf64_Sym:</font></font><br>
<br>
<pre><code class="plaintext hljs">Elf64_Shdr *symsec = &amp;info-&gt;sechdrs[info-&gt;index.sym];<font></font>
Elf64_Sym *sym = (void *)symsec-&gt;sh_addr;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, dalam loop, kita melihat semua karakter dalam tabel, menentukan masing-masing namanya:</font></font><br>
<pre><code class="plaintext hljs">for (i = 1; i &lt; symsec-&gt;sh_size / sizeof(Elf_Sym); i++) {<font></font>
	const char *name = info-&gt;strtab + sym[i].st_name;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bidang st_shndx berisi indeks tajuk bagian di mana karakter ini didefinisikan. </font><font style="vertical-align: inherit;">Jika ada nilai nol (case kami), maka simbol ini tidak ada di dalam modul, Anda perlu mencarinya di kernel:</font></font><br>
<br>
<pre><code class="plaintext hljs">	switch (sym[i].st_shndx) {<font></font>
	.....<font></font>
	 case SHN_UNDEF: //  0<font></font>
	ksym = resolve_symbol_wait(mod, info, name);<font></font>
 	/* Ok if resolved.  */<font></font>
	if (ksym &amp;&amp; !IS_ERR(ksym)) {<font></font>
		sym[i].st_value = kernel_symbol_value(ksym);<font></font>
		break;<font></font>
	}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian muncul antrian relokasi dalam fungsi apply_relocations:</font></font><br>
<br>
<pre><code class="plaintext hljs">static int apply_relocations(struct module *mod, const struct load_info *info)<font></font>
{<font></font>
	unsigned int i;<font></font>
	int err = 0;<font></font>
<font></font>
	/* Now do relocations. */<font></font>
	for (i = 1; i &lt; info-&gt;hdr-&gt;e_shnum; i++) {<font></font>
	.....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam loop, kami mencari bagian relokasi dan memproses catatan setiap bagian yang ditemukan di fungsi apply_relocate_add:</font></font><br>
<br>
<pre><code class="plaintext hljs">if (info-&gt;sechdrs[i].sh_type == SHT_RELA) //   <font></font>
	err = apply_relocate_add(info-&gt;sechdrs, info-&gt;strtab,<font></font>
				info-&gt;index.sym, i, mod);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pointer ke tabel header bagian, pointer ke tabel nama simbol, indeks header bagian dengan tabel simbol dan indeks header bagian relokasi diteruskan ke apply_relocate_add:</font></font><br>
<br>
<pre><code class="plaintext hljs">int apply_relocate_add(Elf64_Shdr *sechdrs,<font></font>
	   const char *strtab,<font></font>
	   unsigned int symindex,<font></font>
	   unsigned int relsec,<font></font>
	   struct module *me)<font></font>
{<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama kami membahas bagian relokasi:</font></font><br>
<br>
<pre><code class="plaintext hljs">Elf64_Rela *rel = (void *)sechdrs[relsec].sh_addr;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian, dalam satu lingkaran, kami memilah-milah array entri:</font></font><br>
<br>
<pre><code class="plaintext hljs">for (i = 0; i &lt; sechdrs[relsec].sh_size / sizeof(*rel); i++) {
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menemukan bagian untuk relokasi dan posisi di dalamnya, yaitu </font><font style="vertical-align: inherit;">di mana kita perlu melakukan perubahan. </font><font style="vertical-align: inherit;">Bidang sh_info dari header bagian relokasi adalah indeks header bagian untuk relokasi, bidang r_offset dari catatan relokasi adalah offset ke posisi di dalam bagian untuk relokasi:</font></font><br>
<br>
<pre><code class="plaintext hljs">/* This is where to make the change */<font></font>
loc = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr + rel[i].r_offset;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alamat karakter yang akan diganti pada posisi ini, dengan mempertimbangkan addendum. </font><font style="vertical-align: inherit;">Bidang r_info dari entri relokasi berisi indeks simbol ini dalam tabel simbol:</font></font><br>
<br>
<pre><code class="plaintext hljs">	/* This is the symbol it is referring to.  Note that all<font></font>
	   undefined symbols have been resolved.  */<font></font>
	sym = (Elf64_Sym *)sechdrs[symindex].sh_addr<font></font>
		+ ELF64_R_SYM(rel[i].r_info);<font></font>
<font></font>
	val = sym-&gt;st_value + rel[i].r_addend;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jenis relokasi menentukan hasil akhir dari perhitungan, dalam contoh kami adalah R_X86_64_PLT32:</font></font><br>
<br>
<pre><code class="plaintext hljs">	switch (ELF64_R_TYPE(rel[i].r_info)) {<font></font>
	......<font></font>
	case R_X86_64_PLT32:	<font></font>
		if (*(u32 *)loc != 0)<font></font>
			goto invalid_relocation;<font></font>
		val -= (u64)loc;	//   <font></font>
		*(u32 *)loc = val;  //    <font></font>
		break;<font></font>
	.....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita dapat menghitung sendiri nilai akhir, mengetahui bahwa sym-&gt; st_value adalah alamat fungsi printk 0xffffffff810b3df9, r_addend adalah (-4), offset ke posisi relokasi adalah 0xd dari awal bagian teks modul, atau dari awal fungsi foo, yaitu dari foo. </font><font style="vertical-align: inherit;">akan menjadi ffffffffc000000d. </font><font style="vertical-align: inherit;">Ganti semua nilai ini dan dapatkan:</font></font><br>
<br>
<pre><code class="plaintext hljs">val = (u32)(0xffffffff810b3df9 - 0x4 - 0xffffffffc000000d) = 0xc10b3de8
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat dump fungsi foo, yang kita dapatkan di awal:</font></font><br>
<br>
<pre><code class="plaintext hljs">53 89 fe 89 fb 48 c7 c7 24 10 00 c0 e8 e8 3d 0b c1 8d 43 02 5b c3 66 2e 0f
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada offset 0xD, nilai 0xc10b3de8 ditemukan, yang identik dengan yang kami hitung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah bagaimana kernel memproses relokasi dan mendapatkan offset yang diperlukan untuk perintah close call. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam mempersiapkan artikel, kernel Linux versi 5.4.27 digunakan.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id504414/index.html">Bagaimana Microsoft Membunuh AppGet</a></li>
<li><a href="../id504420/index.html">Menulis arena PvP berbasis giliran dengan gerakan simultan</a></li>
<li><a href="../id504430/index.html">Pusat Operasi Keamanan Tinkoff Kehidupan Sehari-hari: Analisis Bootloader Tunggal</a></li>
<li><a href="../id504434/index.html">Program pendidikan untuk orang tua: cara melindungi anak-anak dari bahaya di Internet</a></li>
<li><a href="../id504438/index.html">30 mitaps per minggu. Kami membuka musim panas 2020</a></li>
<li><a href="../id504444/index.html">Menggunakan docker multi-stage untuk membangun gambar windows</a></li>
<li><a href="../id504448/index.html">Gamer Generasi II</a></li>
<li><a href="../id504450/index.html">JavaScript Modern: tampilan samping</a></li>
<li><a href="../id504452/index.html">Ontology Meluncurkan Layer 2, Berkontribusi pada Platform Rantai Publik yang Lebih Terintegrasi</a></li>
<li><a href="../id504454/index.html">Repositori GitHub terbaik untuk pengembang web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>