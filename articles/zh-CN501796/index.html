<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>↖️ 🌟 🧑🏽‍🤝‍🧑🏻 在C＃/ .NET中容易犯的7个危险错误 🤽🏼 🐺 🐧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在课程“ C＃ASP.NET Core Developer”开始之前，准备了本文的翻译。
 
 
 
 C＃是一种很棒的语言，.NET Framework也非常好。与其他语言相比，C＃中的强类型键入有助于减少可引发的错误数量。另外，与诸如JavaScript（其中true为false）之类的东西相比...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>在C＃/ .NET中容易犯的7个危险错误</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/501796/"><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在课程</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ C＃ASP.NET Core Developer”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始之前，准备了本文的翻译</font><font style="vertical-align: inherit;">。</font></font></b></i><br>
<br>
<img src="https://habrastorage.org/webt/k8/vz/cz/k8vzcz5umofkpvfxz9zuj1pqibu.png"><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C＃是一种</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很棒的语言</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，.NET Framework也非常好。</font><font style="vertical-align: inherit;">与其他语言相比，C＃中的强类型键入有助于减少可引发的错误数量。</font><font style="vertical-align: inherit;">另外，与诸如JavaScript（其中</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true为false</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）之</font><font style="vertical-align: inherit;">类的东西相比，其一般直观的设计也有很大帮助</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，每种语言都有其自己的优势，很容易被踩踏，还有关于该语言和基础结构预期行为的错误观念。</font><font style="vertical-align: inherit;">我将尝试详细描述其中一些错误。</font></font><a name="habracut"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.不理解延迟（懒惰）执行</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我相信，经验丰富的开发人员会意识到这种.NET机制，但是这可能会使知识渊博的同事感到惊讶。简而言之，返回</font></font><code><code>IEnumerable&lt;</code>T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并用于</font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回每个结果</font><font style="vertical-align: inherit;">的方法/运算符</font><font style="vertical-align: inherit;">不会在实际调用它们的代码行中执行-当以某种方式访问​​结果集合时将执行它们。注意，大多数LINQ表达式最终都将返回带有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yield</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的结果</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，请考虑以下令人震惊的单元测试。</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">TestMethod</span>]<font></font>
[<span class="hljs-meta">ExpectedException(typeof(ArgumentNullException))</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Ensure_Null_Exception_Is_Thrown</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
   <span class="hljs-keyword">var</span> result = RepeatString5Times(<span class="hljs-literal">null</span>);<font></font>
}<font></font>
[<span class="hljs-meta">TestMethod</span>]<font></font>
[<span class="hljs-meta">ExpectedException(typeof(InvalidOperationException))</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Ensure_Invalid_Operation_Exception_Is_Thrown</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
   <span class="hljs-keyword">var</span> result = RepeatString5Times(<span class="hljs-string">"test"</span>);
   <span class="hljs-keyword">var</span> firstItem = result.First();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> IEnumerable&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">RepeatString5Times</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> toRepeat</span>)</span><font></font>
{<font></font>
   <span class="hljs-keyword">if</span> (toRepeat == <span class="hljs-literal">null</span>)
       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(toRepeat));
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<font></font>
   {   <font></font>
       <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(<span class="hljs-string">"3 is a horrible number"</span>);
       <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">$"<span class="hljs-subst">{toRepeat}</span> - <span class="hljs-subst">{i}</span>"</span>;<font></font>
   }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些测试都将失败。第一次测试将失败，因为结果未在任何地方使用，因此该方法的主体将永远不会执行。第二个测试将由于另一个更为平凡的原因而失败。现在，我们得到调用方法的第一个结果，以确保该方法实际运行。但是，延迟执行机制将尽快退出该方法-在这种情况下，我们仅使用第一个元素，因此，一旦我们经过第一次迭代，该方法就会停止执行（因此i == 3永远不会成立）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
延迟执行实际上是一种有趣的机制，特别是因为它使链接LINQ查询变得很容易，仅当您准备好使用查询时才检索数据。</font></font><br>
<br>
<h3>2. ,   Dictionary      ,     </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这特别令人不快，而且我敢肯定，我的某个地方的代码都依赖于此假设。当您将项目添加到列表中时</font></font><code><code>List&lt;T&gt;</code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它们的存储顺序与添加顺序相同-逻辑上。有时，您需要使另一个对象与列表中的项目相关联，显而易见的解决方案是使用字典</font></font><code><code>Dictionary&lt;</code>TKey,TValue&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">该字典</font><font style="vertical-align: inherit;">允许您为键指定相关值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，您可以使用foreach遍历字典，并且在大多数情况下，字典将按预期方式工作-您将以将元素添加到字典中的顺序访问元素。但是，此行为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是不确定的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -即这是一个快乐的巧合，不是您可以依靠并始终期望的事情。这在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft文档</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但我认为很少有人认真研究过此页面。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了说明这一点，在下面的示例中，输出将如下所示：</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
秒</font></font></i><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> dict = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-keyword">string</span>, <span class="hljs-keyword">object</span>&gt;();       <font></font>
dict.Add(<span class="hljs-string">"first"</span>, <span class="hljs-keyword">new</span> <span class="hljs-keyword">object</span>());<font></font>
dict.Add(<span class="hljs-string">"second"</span>, <span class="hljs-keyword">new</span> <span class="hljs-keyword">object</span>());<font></font>
dict.Remove(<span class="hljs-string">"first"</span>);<font></font>
dict.Add(<span class="hljs-string">"third"</span>, <span class="hljs-keyword">new</span> <span class="hljs-keyword">object</span>());
<span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> entry <span class="hljs-keyword">in</span> dict)<font></font>
{<font></font>
    Console.WriteLine(entry.Key);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不相信我？</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自己在线检查这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.不考虑流量安全</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多线程很棒，如果正确实现，则可以显着提高应用程序的性能。但是，一旦您进入多线程，就应该非常小心地对待要修改的任何对象，因为如果您不够谨慎的话，您可能会遇到看似随机的错误。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
简而言之，.NET库中的许多基类都不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线程安全的。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这意味着Microsoft不保证可以使用多个线程并行使用此类。</font><font style="vertical-align: inherit;">如果您可以立即发现与此相关的任何问题，那么这将不是一个大问题，但是多线程的本质意味着出现的任何问题都是非常不稳定且不可预测的-最有可能的是，两个执行都不会产生相同的结果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，考虑使用简单但不是线程安全的代码块</font></font><code><code>List&lt;T&gt;</code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> items = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt;();
<span class="hljs-keyword">var</span> tasks = <span class="hljs-keyword">new</span> List&lt;Task&gt;();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<font></font>
{<font></font>
   tasks.Add(Task.Run(() =&gt; {<font></font>
       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">10000</span>; k++)<font></font>
       {<font></font>
           items.Add(i);<font></font>
       }<font></font>
   }));<font></font>
}<font></font>
Task.WaitAll(tasks.ToArray());<font></font>
Console.WriteLine(items.Count);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们将0到4的数字分别添加到列表10,000次，这意味着列表最终应包含</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">50,000个</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元素。</font><font style="vertical-align: inherit;">我是不是该？</font><font style="vertical-align: inherit;">好吧，最终会有一个小机会-但以下是我5次不同发射的结果：</font></font><br>
<br>
<pre><code class="plaintext hljs">28191<font></font>
23536<font></font>
44346<font></font>
40007<font></font>
40476</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此处在线检查</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，这是因为Add方法不是原子的，这意味着线程可以中断该方法，从而最终可以在另一个线程正在添加或添加具有相同索引的元素时调整数组的大小。作为另一个线程。 IndexOutOfRange异常出现了两次，可能是因为数组的大小在添加数组时发生了变化。那么我们在这里做什么？我们可以使用lock关键字来确保只有一个线程可以一次将（添加）项添加到列表中，但这会显着影响性能。微软是个好人，提供了一些很棒的收藏</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它们是线程安全的，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且在性能方面进行了高度优化。</font><font style="vertical-align: inherit;">我已经发表</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了一篇文章，描述了如何使用它们</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.滥用LINQ中的延迟（延迟）加载</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
延迟加载是LINQ to SQL和LINQ to Entities（实体框架）的一项重要功能，可让您根据需要加载相关的表行。在我的另一个项目中，我有一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“模块”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表和一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“结果”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表</font><font style="vertical-align: inherit;">，它们之间具有一对多关系（一个模块可以有许多结果）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qh/ds/ww/qhdsww2vr9-_oslbtzgqx8rle50.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我想获取特定的模块时，我当然不希望实体框架返回Modules表具有的每个结果！因此，他足够聪明，可以仅在需要时执行查询以获取结果。因此，下面的代码将执行2个查询-一个用于获取模块，另一个用于获取结果（针对每个模块），</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> db = <span class="hljs-keyword">new</span> DBEntities())<font></font>
{<font></font>
   <span class="hljs-keyword">var</span> modules = db.Modules;
   <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> module <span class="hljs-keyword">in</span> modules)<font></font>
   {<font></font>
       <span class="hljs-keyword">var</span> moduleType = module.Results;
      <span class="hljs-comment">//   </span><font></font>
   }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，如果我有数百个模块怎么办？</font><font style="vertical-align: inherit;">这意味着</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将为每个模块</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行一个单独的用于接收结果记录的SQL查询</font><b><font style="vertical-align: inherit;">！</font></b><font style="vertical-align: inherit;">显然，这会对服务器造成压力，并显着降低应用程序速度。</font><font style="vertical-align: inherit;">在Entity Framework中，答案非常简单-您可以指定其在查询中包括一组特定的结果。</font><font style="vertical-align: inherit;">请参阅下面的修改后的代码，其中将仅执行一个SQL查询，该查询将包括每个模块和该模块的每个结果（合并为一个查询，实体框架将智能地显示在模型中），</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> db = <span class="hljs-keyword">new</span> DBEntities())<font></font>
{<font></font>
   <span class="hljs-keyword">var</span> modules = db.Modules.Include(b =&gt; b.Results);
   <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> module <span class="hljs-keyword">in</span> modules)<font></font>
   {<font></font>
       <span class="hljs-keyword">var</span> moduleType = module.Results;
      <span class="hljs-comment">//   </span><font></font>
   }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.不了解LINQ to SQL / Entity Frameworks如何转换查询</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于我们涉及到LINQ主题，因此我认为值得一提的是，如果代码在LINQ查询中，则代码执行的方式会有所不同。从高层次上讲，LINQ查询中的所有代码都使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达式</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换为SQL- </font><font style="vertical-align: inherit;">这似乎很明显，但是非常非常容易忘记您所处的上下文，并最终在代码库中引入问题。下面，我整理了一个列表来描述您可能遇到的一些典型障碍。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大多数方法调用将不起作用。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
因此，假设您在下面的查询中使用冒号分隔所有模块的名称并捕获第二部分。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> modules = <span class="hljs-keyword">from</span> m <span class="hljs-keyword">in</span> db.Modules
              <span class="hljs-keyword">select</span> m.Name.Split(<span class="hljs-string">':'</span>)[<span class="hljs-number">1</span>];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在大多数LINQ提供程序中，您会遇到一个例外-Split方法没有SQL转换，某些方法</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能受</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支持，例如，在日期中增加几天，但这全取决于您的提供程序。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">那些可行的方法可能会产生出乎意料的结果...</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
采用下面的LINQ表达式（我不知道您为什么会在实践中这样做，但是请想象这是一个合理的要求）。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">int</span> modules = db.Modules.Sum(a =&gt; a.ID);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果模块表中有任何行，它将为您提供标识符的总和。</font><font style="vertical-align: inherit;">听起来不错！</font><font style="vertical-align: inherit;">但是，如果您改为使用LINQ to Objects执行该操作，该怎么办？</font><font style="vertical-align: inherit;">为此，我们可以在执行Sum方法之前将模块集合转换为列表。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">int</span> modules = db.Modules.ToList().Sum(a =&gt; a.ID);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
震惊，恐怖-会完全一样！但是，如果模块表中没有行怎么办？ LINQ to Objects返回0，并且Entity Framework / LINQ to SQL版本抛出</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InvalidOperationException</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这表明它不能转换“ int？”。在“诠释” ...这样。这是因为当您在SQL中为空集执行SUM时，将返回NULL而不是0-因此，它会尝试返回可为null的int。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果遇到此类问题，请参考</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">提示以解决此问题</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">知道何时只需要使用良好的旧SQL。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您正在执行一个非常复杂的请求，那么您的翻译请求可能最终看起来像吐出来的东西，一次又一次地被吞掉。</font><font style="vertical-align: inherit;">不幸的是，我没有任何示例可以说明，但是从流行的观点来看，我真的很喜欢使用嵌套视图，这使代码维护成为一场噩梦。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，如果遇到任何性能瓶颈，则由于无法直接控制所生成的SQL，将很难修复它们。</font><font style="vertical-align: inherit;">如果您或您的公司拥有SQL，则可以用SQL进行，也可以将其委派给数据库管理员！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.四舍五入错误</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在的事情比前几段要简单一些，但我总是忘了它，最终遇到了令人不愉快的错误（如果与财务相关，那就是愤怒的鳍/基因主管）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NET Framework在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Math</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类中</font><font style="vertical-align: inherit;">称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Round的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静态方法非常出色</font><font style="vertical-align: inherit;">，该方法采用数字值并将其四舍五入到指定的小数位。它在大多数情况下都能正常运行，但是当您尝试将2.25舍入到小数点后第一位时该怎么办？我假设您可能希望它会四舍五入到2.3-这就是我们都习惯的，对吧？嗯，实际上，事实证明.NET使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">银行取整</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将给定的示例四舍五入为2.2！</font><font style="vertical-align: inherit;">这是由于以下事实：如果银行家的数字位于“中点”，则四舍五入到最接近的偶数。</font><font style="vertical-align: inherit;">幸运的是，这可以在Math.Round方法中轻松覆盖。</font></font><br>
 <br>
<pre><code class="cs hljs">Math.Round(<span class="hljs-number">2.25</span>,<span class="hljs-number">1</span>, MidpointRounding.AwayFromZero)</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.可怕的“ DBNull”类 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这可能会给某些人带来不愉快的记忆-ORM向我们隐藏了这种污秽，但是如果您深入研究裸ADO.NET（SqlDataReader之类）的世界，则会遇到DBNull.Value。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我不是100％知道</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据库中的NULL值按以下方式处理（如果您知道，请在下面注释！），但是Microsoft决定为它们提供特殊类型的DBNull（带有静态字段Value）。</font><font style="vertical-align: inherit;">我可以提供其中一个优点-访问数据库字段NULL时，您不会遇到任何不愉快的NullReferenceException。</font><font style="vertical-align: inherit;">但是，您不仅应该支持检查NULL值的第二种方法（这种方法很容易忘记，可能导致严重的错误），而且还会丢失C＃的任何出色功能，这些功能可以帮助您处理null。</font><font style="vertical-align: inherit;">可能如此简单</font></font><br>
 <br>
<pre><code class="cs hljs">reader.GetString(<span class="hljs-number">0</span>) ?? <span class="hljs-string">"NULL"</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最终变成...</font></font><br>
 <br>
<pre><code class="cs hljs">reader.GetString(<span class="hljs-number">0</span>) != DBNull.Value ? reader.GetString(<span class="hljs-number">0</span>) : <span class="hljs-string">"NULL"</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
啊。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些只是我在.NET中遇到的一些不平凡的“耙子”-如果您了解更多，我想在下面与您联系。</font></font><br>
<br>
<hr><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ASP.NET Core:  </a><br>
<br>
<hr></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN501784/index.html">如果我的车挡住了路</a></li>
<li><a href="../zh-CN501786/index.html">新应用程序“水母”。为什么扑扑？</a></li>
<li><a href="../zh-CN501788/index.html">在nanoCAD Design BIM中创建参数对象</a></li>
<li><a href="../zh-CN501790/index.html">SwiftUI中的非平凡动画</a></li>
<li><a href="../zh-CN501792/index.html">FinFET的父亲如何帮助拯救摩尔定律</a></li>
<li><a href="../zh-CN501798/index.html">C++/Qt: пора валить?.</a></li>
<li><a href="../zh-CN501800/index.html">关于俄罗斯联邦武装部队现代化和生产无线电通信系统的小型osinta会议</a></li>
<li><a href="../zh-CN501804/index.html">镖。您需要了解的有关常数的所有信息</a></li>
<li><a href="../zh-CN501806/index.html">ACS：问题，解决方案和安全风险管理</a></li>
<li><a href="../zh-CN501808/index.html">D 2.092中的更改列表。借借借借</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>