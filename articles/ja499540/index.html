<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐁 🚣🏻 🤹🏾 3Dゲームレンダリングのしくみ：テクスチャリングとテクスチャフィルタリング 👨🏻‍🍳 🌓 🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="3Dゲームでのレンダリングに関する3番目の記事では、頂点処理を処理してシーンをラスタライズした後、3Dワールドに何が起こるかを説明します。テクスチャリングは、マルチカラーブロックの2次元グリッドの色を計算および変更するだけであるにもかかわらず、レンダリングの最も重要な段階の1つです。
 
 現代のゲ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>3Dゲームレンダリングのしくみ：テクスチャリングとテクスチャフィルタリング</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499540/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a4/fee/0c7/2a4fee0c701c2b2200faf2b8c6929832.jpg" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3Dゲームでのレンダリングに関する3番目の記事では、頂点処理を処理してシーンをラスタライズした後、3Dワールドに何が起こるかを説明します。</font><font style="vertical-align: inherit;">テクスチャリングは、マルチカラーブロックの2次元グリッドの色を計算および変更するだけであるにもかかわらず、レンダリングの最も重要な段階の1つです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現代のゲームの視覚効果のほとんどは、意図的にテクスチャを使用するように煮詰められます。テクスチャがないと、ゲームは退屈で活気がないように見えます。</font><font style="vertical-align: inherit;">それでは、すべてがどのように機能するか見てみましょう！</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート1：頂点処理</font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート2：ラスタライズとレイトレーシング</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単なことから始めましょう</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
過去1年間にリリースされた3次元のベストセラーゲームを取り上げて、すべてに共通点があると確信を持って言うことができます。つまり、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テクスチャマップ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（または単に</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テクスチャ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を使用します。これは非常に一般的な用語であり、テクスチャについて考えるとき、ほとんどの人が同じ絵を提示します：表面（草、石、金属、布地、顔など）のイメージを含む単純な平らな正方形または長方形。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、複雑な計算を使用して組み合わせた場合、3Dシーンのこのような単純な画像は驚くほどリアルな画像を作成できます。これがどのように可能であるかを理解するために、それらを完全にオフにして、テクスチャのない3Dワールドのオブジェクトがどのように見えるかを見てみましょう。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前の記事で見たように、3Dの世界は頂点で構成されています。頂点は単純な形状であり、移動してから色付けされます。次に、これらを使用してプリミティブを作成し、プリミティブを2次元のピクセルグリッドに圧縮します。テクスチャを使用しないので、これらのピクセルをカラー化する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
適用できる方法の1つは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラットシェーディング</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれます。</font><font style="vertical-align: inherit;">プリミティブの最初の頂点の色が取得され、この色はラスター内の図形でカバーされるすべてのピクセルに適用されます。次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/f5c/61b/a0bf5c61be539c776d00fa1b11177ced.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、やかんは非現実的に見えますが、特に表面の色が不規則であるためです。色はあるレベルから別のレベルにジャンプし、スムーズな移行はありません。この問題の1つの解決策は、</font></font><em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グーローシェーディング</font></font></a></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用すること</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロセスでは、頂点の色が取得され、その後、三角形の表面に沿った色の変化が計算されます。これには、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形補間が使用され</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。複雑に聞こえるかもしれませんが、実際には、たとえば、プリミティブの片側の色が0.2赤で、もう片側の色が0.8赤の場合、図の中央の色は中央の0.2から0.8の間（つまり0.5）になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロセスは非常に単純であり、単純さがスピードを意味するため、これが主な利点です。コンピュータ機器の機能が制限されていたため、多くの古い3Dゲームはこの手法を使用していました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/128/447/3c8/1284473c8e1e2ce7d32dbf2202065afe.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グーローシェーディングの壮大なバレットとクラウド（ファイナルファンタジーVII、1997）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
しかし、このようなソリューションでさえ問題があります-ライトが三角形の真ん中に落ちると、そのコーナー（および頂点）はこの特性を伝えません。</font><font style="vertical-align: inherit;">これは、光によって生成されるグレアが完全に失われる可能性があることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gouroのフラットシェーディングとシェーディングはレンダリングツールで適切な位置を占めていますが、上記の例は、テクスチャー拡張の明確な候補です。</font><font style="vertical-align: inherit;">そして、テクスチャーが表面に重ねられたときに何が起こるかをよく理解するために、我々は時間をさかのぼります...すでに1996年に。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームとGPUの歴史の概要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
約23年前、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">id Software</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はQuakeをリリースし、主要なマイルストーンになりました。</font><font style="vertical-align: inherit;">これは、3Dポリゴンとテクスチャを使用して環境をレンダリングする最初のゲームではありませんでしたが、これらを効果的に使用した最初のゲームの1つでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、彼女は別のことも行いました-彼女はOpenGLを使用して何ができるかを示し（このグラフィックAPIは最初のバージョンの状態でした）、また、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendition Verite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3Dfx Voodoo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの第一世代のグラフィックカードにも大きく貢献しました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a86/9a9/667/a869a966718cfc8ddf4b6d7618b2fdbf.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">照明のピークとシンプルなテクスチャ。</font><font style="vertical-align: inherit;">1996年をきれいに、Quakeをきれいに。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現代の標準では、Voodooは非常にシンプルでした。2Dグラフィックのサポート、頂点処理はなく、最も単純なピクセル処理のみです。</font><font style="vertical-align: inherit;">しかし、彼女は美しかった：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66c/509/911/66c5099113c9b08098b73ce31436ecb8.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VGA博物館</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
彼女は、テクスチャからピクセルを取得するためのチップ全体（TMU）と、後でそれをラスターピクセルと混合するための別のチップ（FBI）を持っていました。マップは、フォグや透明効果の実装など、いくつかの追加プロセスを実行できますが、これは本質的に、その機能を終了しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グラフィックカードの構造と操作の基礎となるアーキテクチャを見ると、これらのプロセスがどのように機能するかがわかります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/c83/ee4/064c83ee4f63da2be0d5a968c33df0d5.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3Dfx仕様。出典：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falconfly Central</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
FBIチップは2つのカラー値を受け取り、それらを混合しました。それらの1つは、テクスチャの値である可能性があります。混合プロセスは数学的に非常に単純ですが、混合されるものと、命令を実行するために使用されるAPIによって多少異なります。</font><font style="vertical-align: inherit;">関数とミキシング操作に関して</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Direct3Dが提供</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
するもの</font><font style="vertical-align: inherit;">を見ると、最初に各ピクセルに0.0から1.0の数値が乗算されていることがわかります。これにより、ピクセルの色が最終結果にどの程度影響するかが決まります。次に、2つの変更されたピクセルカラーが加算、減算、または乗算されます。一部の関数では、たとえば、最も明るいピクセルが常に選択されるような論理演算が実行されます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/c8b/c8a/aa1c8bc8a2e35a1867c5f6028d958fa8.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イニシアチブを取る技術ブログ</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
上記の画像は、これが実際にどのように機能するかを示しています。ピクセルの</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルファ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値が左の</font><font style="vertical-align: inherit;">ピクセルの</font><font style="vertical-align: inherit;">係数として使用されていることに注意してください</font><font style="vertical-align: inherit;">。この数値は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピクセル</font><font style="vertical-align: inherit;">の</font><em><font style="vertical-align: inherit;">透明度を</font></em><font style="vertical-align: inherit;">示します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他の段階では、フォグ値が適用されます（プログラマーによって作成されたテーブルから取得され、同じ混合計算が実行されます）。可視性と透明性のチェックと変更;最後に、ピクセルカラーがグラフィックスカードのメモリに書き込まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこの歴史への小旅行が必要なのですか？</font><font style="vertical-align: inherit;">まあ、デザインは比較的単純ですが（特に現代のモンスターと比較して）、このプロセスはテクスチャリングの基本原則を説明します。特定の状況でモデルと環境が適切に見えるように、色の値を取得して混合します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現代のゲームも同じことを行います。唯一の違いは、使用されるテクスチャの数とミキシング計算の複雑さです。</font><font style="vertical-align: inherit;">一緒に、それらはフィルムで見られる視覚効果、または照明とさまざまな素材や表面との相互作用をシミュレートします。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テクスチャリングの基本</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちにとって、テクスチャは、フレームの3D構造を構成するポリゴンに重ね合わされたフラットな2D画像です。ただし、コンピュータの場合、これは2D配列の形式のメモリの小さなブロックにすぎません。配列の各要素は、テクスチャイメージのピクセルの1つ（一般に</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テクセル</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -テクスチャピクセル</font><font style="vertical-align: inherit;">と呼ばれます）のカラー値を示し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポリゴンの各頂点には2つの座標のセットがあり（通常は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u、vで</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表され</font><font style="vertical-align: inherit;">ます）、テクスチャのどのピクセルが関連付けられているかをコンピューターに伝えます。頂点自体には3つの座標（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x、y、z</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">セットが</font><font style="vertical-align: inherit;">あり、テクセルを頂点にリンクするプロセスは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テクスチャマッピング</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがどのように行われるかを確認するために、このシリーズの記事ですでに何度か使用したツールである、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リアルタイムレンダリングWebGL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を見てみましょう</font><font style="vertical-align: inherit;">。とりあえず、</font><font style="vertical-align: inherit;">頂点の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">座標も破棄</font><font style="vertical-align: inherit;">し、平面上のすべてのものを考慮します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/d20/fbb/8e1d20fbb308d78a19a2e54d5da96900.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左から右へ：</font><font style="vertical-align: inherit;">コーナー頂点の</font><em><font style="vertical-align: inherit;">x、y</font></em><font style="vertical-align: inherit;">座標に直接結び付けられた</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">テクスチャ</font><font style="vertical-align: inherit;">の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u、v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">座標</font><font style="vertical-align: inherit;">。 2番目の画像では、上部の頂点で</font><em><font style="vertical-align: inherit;">y</font></em><font style="vertical-align: inherit;">座標が増加して</font><font style="vertical-align: inherit;">いますが、テクスチャはまだそれらにアタッチされているため、垂直方向に伸びています。テクスチャは右の画像で既に変更されています</font><i><font style="vertical-align: inherit;">。u</font></i><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">は増加してい</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">が、その結果、テクスチャは圧縮されてから繰り返されています。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値が増加したために実際にはテクスチャが高くなっているにもかかわらず、</font><font style="vertical-align: inherit;">プリミティブに収まるはずであるためです。実際、テクスチャは部分的に繰り返されています。これは、3Dゲームでよく見られる効果を実装する1つの方法です。</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">繰り返しテクスチャ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この効果の例は、石や芝生の風景やレンガ壁のシーンで見ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、プリミティブが増えるようにシーンを変更して、シーンの深度を返します。クラシックランドスケープビューを以下に示しますが、すべてのプリミティブに対してボックステクスチャがコピーされて繰り返されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9e/9e1/0cb/a9e9e10cb533b78330f90fd7eaea3891.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
元のgif形式のボックステクスチャのサイズは66 KBで、解像度は256 x 256ピクセルです。フレームのボックステクスチャで覆われた部分の初期解像度は1900 x 680です。つまり、ピクセルの「領域」の観点からは、そのような領域には20のボックステクスチャしか表示されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、20個を超えるボックスが表示されていることは明らかです。これは、遠くにあるボックスのテクスチャが</font><font style="vertical-align: inherit;">256 x 256ピクセルより</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はるかに</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小さい</font><font style="vertical-align: inherit;">ことを意味します</font><font style="vertical-align: inherit;">。</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、彼らは</font><em><font style="vertical-align: inherit;">「テクスチャの縮小」</font></em><font style="vertical-align: inherit;">と呼ばれるプロセスを受けました</font><font style="vertical-align: inherit;">（そう、そのような単語は英語で存在します！）。繰り返しますが、今度はカメラを引き出しの1つに近づけます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/404/c02/f70/404c02f70291916245ec931642c79860.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テクスチャのサイズは256 x 256ピクセルしかないことを忘れないでください。ただし、ここでは、幅が1900ピクセルの画像の半分よりも大きいテクスチャが表示されています。</font><font style="vertical-align: inherit;">このテクスチャは、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「テクスチャ拡大」</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作にかけられました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3Dゲームでは、これら2つのテクスチャプロセスが常に発生します。これは、カメラがシーン内を移動すると、モデルが近づいたり離れたりし、プリミティブに適用されるすべてのテクスチャがポリゴンとともにスケーリングする必要があるためです。</font><font style="vertical-align: inherit;">数学の観点からは、これは小さな問題です。実際、最も単純な統合グラフィックスチップでさえ、そのような仕事を簡単に行うことができます。</font><font style="vertical-align: inherit;">ただし、テクスチャの縮小と拡大は、何らかの方法で対処する必要がある新しい課題です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テクスチャのミニコピーがシーンに表示されます</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テクスチャを解決する最初の問題は距離です。ボックスの横長の最初の画像に戻ると、水平線の近くにあるボックスのサイズは実際には数ピクセルしかありません。したがって、このような小さなスペースで256 x 256ピクセルの画像を圧縮しようとしても、2つの理由から意味がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、テクスチャが小さいほどグラフィックカードのメモリ使用量が少なくて済みます。これは、小さいキャッシュに収めることができるため便利です。これは、キャッシュから削除される可能性が低いことを意味します。つまり、このテクスチャを繰り返し使用すると、データがメモリ内にあるため、パフォーマンスが向上します。 2番目の理由は、カメラに近いテクスチャで発生する同じ問題に関連しているため、すぐに戻ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大きなテクスチャを小さなプリミティブに圧縮する必要があるという問題の標準的な解決策は、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ミップテクスチャ（ミップマップ）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用すること</font><font style="vertical-align: inherit;">です。これらは元のテクスチャのダウンサイズバージョンです。これらは、エンジン自体によって（適切なAPIコマンドを使用して）生成することも、ゲームデザイナーが事前に作成することもできます。ミップテクスチャの後続の各レベルは、前のレベルと比較してサイズが半分になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、ボックステクスチャの場合、寸法は256 x 256→128 x 128→64 x 64→32 x 32→16 x 16→8 x 8→4 x 4→2 x 2→1 x 1になります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/074/973/1ea/0749731eae53d112d545c0297ac14584.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのミップテクスチャは一緒にパッケージ化されているため、テクスチャのファイル名は同じですが、サイズが大きくなります。テクスチャは、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u、v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">座標が</font><font style="vertical-align: inherit;">どのテクセルがフレーム内のピクセルにスーパーインポーズされるかを決定するだけでなく、どのミップテクスチャでも決定</font><font style="vertical-align: inherit;">されるようにパックされ</font><font style="vertical-align: inherit;">ます。次に、プログラマーは、フレームのピクセル深度の値に基づいてレンダラーを記述し、使用するミップテクスチャを決定します。たとえば、値が非常に高い場合、ピクセルは遠くにあるため、小さなミップテクスチャを使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意深い読者は、ミップテクスチャの欠如に気づくでしょう-彼らはテクスチャのサイズを大きくすることによってそれらのために支払う必要があります。ボックスの元のテクスチャは256 x 256ピクセルでしたが、上の画像を見るとわかるように、ミップテクスチャを含むテクスチャのサイズは384 x 256になっています。片側のテクスチャのサイズは少なくとも50％増加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これは以前に作成されたミップテクスチャにのみ当てはまります。ゲームエンジンがそれらを正しく生成するようにプログラムされている場合、増加は元のテクスチャサイズの33％以下です。したがって、ミップテクスチャを格納するためのメモリ量が少し増えるため、パフォーマンスと視覚的品質が向上します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、ミップテクスチャを無効/有効にした画像の比較です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e96/b67/e71/e96b67e71c3f41aed3ce09ed728f98ea.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像の左側では、ボックスのテクスチャが「そのまま」使用さ</font><font style="vertical-align: inherit;">れており、遠く</font><font style="vertical-align: inherit;">に粒状感といわゆる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モアレ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">現れ</font><font style="vertical-align: inherit;">ました。</font><font style="vertical-align: inherit;">右側では、ミップテクスチャの使用によりスムーズな移行が可能になり、地平線上ではボックスのテクスチャが均一な色にぼかされています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、ぼやけたテクスチャがお気に入りのゲームの背景を台無しにしたいのは誰ですか？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイリニア、トリリニア、異方性-これはすべて私にとって漢字です</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テクスチャからピクセルを選択してフレーム内のピクセルにオーバーレイするプロセスは、テクスチャの</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプリング</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><em><font style="vertical-align: inherit;">ます</font></em><font style="vertical-align: inherit;">。理想的な世界では、サイズ、位置、方向などに関係なく、設計されたプリミティブと理想的に一致するテクスチャが存在します。</font><font style="vertical-align: inherit;">つまり、テクスチャのサンプリングは、単純な1対1のテクセルピクセルマッピングです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これはそうではないので、テクスチャをサンプリングするときに考慮すべきいくつかの要因があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テクスチャーは縮小または拡大されていますか？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テクスチャはソースまたはミップテクスチャですか？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テクスチャはどの角度で表示されますか？</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
順番に分析していきましょう。最初の要素は非常に明白です。テクスチャが増加している場合、プリミティブには、プリミティブのピクセルをカバーするテクセルが必要以上に多くなります。削減する場合、反対が真になります。各テクセルは複数のピクセルをカバーするはずです。そして、それは問題です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ミップテクスチャは遠く離れたプリミティブのテクスチャをサンプリングする問題を回避するために使用されるため、2番目の要素は問題を引き起こしません。したがって、唯一のタスクは、テクスチャを斜めに表示することです。そして、はい、これも問題です。どうして？すべてのテクスチャは「真正面」で表示するために生成された画像だからです。数学言語で言えば、通常の表面テクスチャは、テクスチャが現在表示されている表面の名目と一致します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、テクセルが少なすぎたり多すぎたり、角度をつけて配置されている場合は、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「テクスチャフィルタリング」</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれる追加のプロセスが必要です</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このプロセスを使用しない場合、次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/792/a12/552/792a125529b7f3baa79c072fdf42acba.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、ボックスのテクスチャをRのテクスチャに置き換えて、テクスチャをフィルタリングせずに画像がどのように乱雑になるかをより明確に示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Direct3D、OpenGL、VulkanなどのグラフィックAPIは同じフィルタリングタイプのセットを提供しますが、それらには異なる名前を使用します。</font><font style="vertical-align: inherit;">実際、それらはすべて次のように要約されます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">近点サンプリング</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形テクスチャフィルタリング</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異方性テクスチャフィルタリング</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最も近いポイントのサンプリングは</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィルターで</font><em><font style="vertical-align: inherit;">はあり</font></em><font style="vertical-align: inherit;">ません。必要なテクスチャピクセルの最も近いテクセルのみがサンプリングされ（たとえば、メモリからコピーされ）、ピクセルの元の色と混合されるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで線形フィルタリングが役立ちます。必要な</font><font style="vertical-align: inherit;">テクセル</font><font style="vertical-align: inherit;">座標</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u、v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はサンプリング装置に転送されますが、サンプラーはこれらの座標に最も近いテクセルを取得する代わりに、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4つの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テクセル</font><font style="vertical-align: inherit;">を取得し</font><font style="vertical-align: inherit;">ます。これらは、最も近いポイントをサンプリングすることによって選択されるテクセルの上下左右にあるテクセルです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、これらの4つのテクセルは、重み付きの式を使用して混合されます。たとえば、Vulkanでは、式は次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/9bb/63c/57b9bb63cc81fa5721b007717f6b200a.png"></div><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はテクセルの色を示します</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。f</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はフィルタリングの結果、1〜4は4つのサンプリングされたテクセルの色です。</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルファ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">と</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベータ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">は、座標</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u、vの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポイント</font><font style="vertical-align: inherit;">がテクスチャの中央から</font><font style="vertical-align: inherit;">どれだけ離れているかに応じて取得されます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸い、3Dグラフィックスに関わる人にとって、これはグラフィックスチップで自動的に行われます。実際、これは3dfx VoodooカードのTMUチップが行ったこととまったく同じです。4つのテクセルをサンプリングし、それらを混合しました。 Direct3Dでは、このプロセスは</font><em><font style="vertical-align: inherit;">バイリニアフィルタリングの</font></em><font style="vertical-align: inherit;">奇妙な名前</font><em><font style="vertical-align: inherit;">を</font></em><font style="vertical-align: inherit;">持ってい</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、QuakeとTMUチップの時代以来、グラフィックスカードは既に1クロックサイクルでバイリニアフィルタリングを実行する方法をすでに学んでいます（もちろん、テクスチャが既に最も近いメモリにある場合）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
線形フィルタリングは、ミップテクスチャと一緒に使用できます。フィルタリングを複雑にしたい場合は、テクスチャから4つのテクセルを取り出し、次のレベルのミップテクスチャからさらに4つテクセルを取り出し、それらをすべて混合することができます。そしてそれはDirect3Dで何と呼ばれていますか？</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トリリニア</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィルタリング。このプロセスで</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「3」は</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どこから来たの</font><font style="vertical-align: inherit;">ですか？だから私たちは知りません... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言及する価値がある最後のフィルタリング方法は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異方性</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。実際、これはバイリニアまたはトリリニアフィルタリングによって実行されるプロセスの改善です。最初は計算します</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プリミティブサーフェス</font><em><font style="vertical-align: inherit;">の異方性の度合い</font></em><font style="vertical-align: inherit;">（これは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">驚くほど複雑なプロセスです</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）-この値は、プリミティブの向きによるアスペクト比の変化を増加させます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/247/dfe/e60/247dfee60846988a5e94a1020d9ecef6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上の図は、同じ長さの同じ正方形のプリミティブを示しています。しかし徐々に回転すると、長方形に変わり、その幅は高さよりも大きく変化します。したがって、右側のプリミティブの異方性度は左側よりも大きくなります（正方形の場合、次数はゼロです）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近の3Dゲームの多くでは、異方性フィルタリングをオンにして、そのレベルを（1xから16xに）変更できますが、実際には何が変更されますか？このパラメーターは、各初期線形サンプルで取得される追加のテクセルサンプルの最大数を制御します。ゲームで8xの異方性バイリニアフィルタリングがオンになっているとします。これは、4つのテクセル値の代わりに、32の値を取得することを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
異方性フィルタリングを使用する場合の違いは明らかに顕著です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/302/372/df7302372c6dc0d34730ba572f695063.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上の画像に移動して、最も近いポイントのサンプリングを最大16倍の異方性3線形フィルタリングと比較してください。驚くほどスムーズ！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、テクスチャのこの滑らかな美しさのために、パフォーマンスで支払う必要があります。最大設定では、異方性トリリニアフィルタリングは、レンダリングの各ピクセルのテクスチャから128サンプルを受け取ります。最高の最新GPUを使用しても、これは1クロックサイクルでは達成できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、AMD </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Radeon RX 5700 XT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、プロセッサ内の各テクスチャリングブロックは、1クロックサイクルで最大32テクセルアドレスを使用でき、次のクロックサイクルでメモリから32テクセル値（それぞれ32ビットのサイズ）をロードし、4つをもう1つに混合します。タクト。つまり、128個のテクセルサンプルを1つに混合するには、少なくとも16クロックサイクルが必要です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/abf/cf4/fa4abfcf4411b6cc2622c8e77986ab3c.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU AMD RDNA Radeon RX 5700と7ナノメートルプロセステクノロジー</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
5700 XTのクロック速度が1605 MHzの場合、16サイクルで10 </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ナノ秒</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかかかりません</font><font style="vertical-align: inherit;">。</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テクスチャユニットのみ</font><font style="vertical-align: inherit;">を使用して4Kフレームの各ピクセルに対してこれらのサイクルを実行</font><font style="vertical-align: inherit;">すると、70ミリ秒しかかかりません。すばらしい、パフォーマンスはそれほど重要ではないようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1996年でさえ、3Dfx Voodooや同様のカードはテクスチャにすばやく対応しました。最大で、サイクルあたりバイリニアフィルタリングを使用して1テクセルを提供でき、TMUチップ周波数が50 MHzの場合、これは1秒あたり5,000万テクセルを処理できることを意味します。 800 x 600および30 fpsで実行するゲームは、1秒あたりのバイリニアフィルタリングを備えた1,400万テクセルしか必要としません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、これはすべてのテクスチャが最も近いメモリにあり、各ピクセルに対応するテクセルが1つだけであるという仮定の下でのみ当てはまります。</font><font style="vertical-align: inherit;">20年前、プリミティブにいくつかのテクスチャをオーバーレイする必要性という考えは完全に異質でしたが、今日では標準となっています。</font><font style="vertical-align: inherit;">これがすべて変化する理由を見てみましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">照明を追加する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テクスチャリングがそれほど重要になった理由を理解するには、Quakeの次のシーンをご覧ください。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/dcf/ee4/bdadcfee4354ea561b9239e1ca5a143b.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
暗闇がゲームの雰囲気だったので、これは暗い画像ですが、暗闇はどこでも同じではないことがわかります。壁や床の一部の断片は他よりも明るく、これらの領域に軽快感を生み出しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
壁と床を構成するプリミティブには同じテクスチャが重ねられ</font><font style="vertical-align: inherit;">ていますが、フレームピクセルに適用される前に、テクセルの値と混合さ</font><font style="vertical-align: inherit;">れた</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ライトマップ」</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれる別のテクスチャがあり</font><font style="vertical-align: inherit;">ます。 Quake時代には、ライティングマップは事前に計算され、ゲームエンジンによって作成されていました。静的および動的な照明レベルを生成するために使用されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらの使用の利点は、頂点ではなくテクスチャを使用して複雑な照明計算が実行されたことで、低速コストを犠牲にしてシーンの外観が大幅に改善されたことです。明らかに、画像は不完全です。床では、照明領域と影の間の境界が非常にシャープであることがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの点で、ライトマップは単なる別のテクスチャです（すべて通常の2Dデータセットであることを忘れないでください）。このシーンは、</font><em><font style="vertical-align: inherit;">マルチテクスチャリング</font></em><font style="vertical-align: inherit;">を使用する最初の例の1つです。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。名前が示すように、これは2つ以上のテクスチャがプリミティブに重ねられるプロセスです。 Quakeでのライティングマップの使用は、グーローシェーディングの制限を克服する方法になりましたが、グラフィックカードの機能の範囲を拡大する過程で、マルチテクスチャリングを適用する方法も拡張されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3Dfx Voodooは、その時代の他の多くのカードと同様に、単一の</font><font style="vertical-align: inherit;">レンダリング</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パスで</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行できる操作の量が制限されていました</font><font style="vertical-align: inherit;">。実際、パスは完全なレンダリングサイクルです。頂点の処理からフレームのラスター化、そしてピクセルの変更と完成したフレームバッファーへの書き込みまでです。 20年前のゲームでは、ほとんどの場合、ワンパスレンダリングが使用されていました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a55/0b6/bc9/a550b6bc98c07f1c90276e1aa3721819.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nvidia GeForce 2 Ultra、2000年末頃。画像：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィキメディア</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これは、追加のテクスチャを適用するためだけの2番目の頂点処理がパフォーマンスの面でコストがかかりすぎたために起こりました。 Voodooの後、1回のパスでマルチテクスチャリングが可能なATI RadeonおよびNvidia GeForce 2グラフィックスカードが登場するまで数年待たなければなりませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのGPUは、ピクセル処理領域（つまり、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パイプライン</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）に</font><font style="vertical-align: inherit;">いくつかのテクスチャユニットを備えていた</font><font style="vertical-align: inherit;">ため、2つの別々のテクスチャから双一次フィルタリングを使用したテクセルを取得することが最も簡単な作業になりました。これにより、ライティングマップの人気がさらに高まり、ゲームが完全に動的になり、ゲーム環境の条件に応じてライティング値が変化するようになりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、少数のテクスチャーでもっと多くのことができるので、それらの機能を調べてみましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高さを変えるのは普通です</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3Dレンダリングに関するこのシリーズの記事では、GPUの役割がプロセス全体にどのように影響するかについては触れませんでした（これについては話しますが、今は触れません！）。しかし、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に戻って</font><font style="vertical-align: inherit;">、頂点を処理する複雑なプロセス全体について読むと、これがGPUが実行する必要があるすべての作業の中で最も難しい部分だと思うかもしれません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長い間そうでしたが、ゲームプログラマーはこの負荷を軽減するためにあらゆることを行いました。複数の頂点を使用する場合と同じ画質を保証するために、あらゆる種類のトリックに取り掛かる必要がありましたが、それらを処理しませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのトリックのほとんどは、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高さマップ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><em><font style="vertical-align: inherit;">法線マップ</font></em><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">呼ばれるテクスチャを使用して</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いました。</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらの2つの概念は、前者から後者を作成できるという事実によって関連付けられていますが、ここでは、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「バンプマッピング」</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれる手法のみを見てみましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/db2/5b6/1e3db25b6ecefc0dd3f75c84f767800c.jpg"></div><br>
<i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Emil Perssonによるデモレンダリングで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作成された画像</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">エンボステクスチャリングは無効/有効になっています。エンボステクスチャリング</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
は、元のテクスチャの奇妙なバージョンのように見える「高さマップ」と呼ばれる2D配列を使用します。</font><font style="vertical-align: inherit;">たとえば、上の画像は、2つの平面にオーバーレイされた現実的なレンガのテクスチャを示しています。</font><font style="vertical-align: inherit;">テクスチャとその高さマップは次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a1/87f/221/7a187f2215bcf0723bd4d4f820350858.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高さマップの色は、レンガの表面の法線を示しています（</font><font style="vertical-align: inherit;">一連の記事の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート1で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">法線について説明しました</font><font style="vertical-align: inherit;">）。レンダリングプロセスがレンガテクスチャを表面に適用する段階に達すると、一連の計算が実行され、その法線に基づいてレンガテクスチャの色が変更されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、レンガは完全に平らなままであるにもかかわらず、レンガ自体はより立体的に見えます。特にレンガの端をよく見ると、この手法の制限がわかります。テクスチャが少し歪んで見えます。しかし、これは表面のディテールを追加できる簡単なトリックであるため、エンボステクスチャリングは非常に人気があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
法線マップは高さマップに似ていますが、テクスチャカラーのみが法線そのものです。つまり、高さマップを法線に変換するための計算は必要ありません。あなたは質問することができます：色はどのように空間のベクトルを説明できますか？答えは簡単です。各テクセルには</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r、g、bの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値のセット</font><font style="vertical-align: inherit;">（赤、緑、青）があり、これらの値</font><font style="vertical-align: inherit;">は法線ベクトル</font><font style="vertical-align: inherit;">の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x、y、z</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">直接対応しています</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1f/105/c3b/c1f105c3b93c455ba7661489770172c9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左の図は、凹凸のある表面での法線の方向の変化を示しています。同じ法線をフラットテクスチャ（中央の輪郭）で表すために、それらに色を割り当てます。この場合、</font><font style="vertical-align: inherit;">上向きのベクトル</font><font style="vertical-align: inherit;">に</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r、g、b</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（0.255.0）</font><font style="vertical-align: inherit;">の値を使用</font><font style="vertical-align: inherit;">し、左に傾ける場合は赤、右に傾く場合は青の値を増やしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この色は元のピクセルと混ざらないことに注意してください。これは、法線が示す方向をプロセッサに伝えるだけで、カメラ、光源、テクスチャサーフェス間の角度を正しく計算できるようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンボス加工のテクスチャリングと法線マップの利点は、シーンでダイナミックライティングが使用されている場合、およびレンダリングプロセスがライティングの変化をピクセルごとに計算し、頂点ごとに計算しない場合に明らかになります。今日、現代のゲームは一連のテクスチャを使用して、このトリックの品質を向上させています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ef/d59/660/3efd596604528593b16923297f10f044.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライアン・ベノ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitterは</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
驚くべきことに、このリアルな壁は、ポリゴン数百万を使用して、レンガや石材セメントの詳細がなされていないだけでフラットな面です。代わりに、テクスチャを5つと計算を慎重に使用するだけで十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高さマップはレンガを使用した影付けを生成するために使用され、法線マップはすべての小さな表面の変化をシミュレートするために使用されました。粗さのテクスチャは、壁のさまざまな要素からの光の反射方法を変更するために使用されました（たとえば、滑らかなレンガは、粗いセメントよりも均一に光を反射します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AO画像で名前が付けられた最後のカードは、アンビエントオクルージョンと呼ばれるプロセスの一部を作成します。このテクニックについては、以下の記事で詳しく説明しますが、ここでは、シャドウのリアルさを高めるのに役立つとしましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テクスチャマッピングは重要なプロセスです。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームを開発する場合、テクスチャリングは絶対に不可欠です。たとえば、</font><font style="vertical-align: inherit;">15世紀にボヘミアを舞台にした1人称RPG </font><font style="vertical-align: inherit;">である2019年のゲーム</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kingdom Come：Deliverance</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を例に</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">考えてみましょう</font></a><font style="vertical-align: inherit;">。デザイナーはその時代の最も現実的な世界を作り出そうとしました。数百年前の人生にプレーヤーを没頭させるには、歴史的に正確な風景、建物、服、ヘアスタイル、日常品などを実装するのが最善です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームのこの画像の各テクスチャは、アーティストによって手動で作成されました。また、プログラマーによって制御されるレンダリングエンジンのおかげでもあります。それらのいくつかは小さく、細部が単純であるため、わずかにフィルター処理されるか、他のテクスチャー（手羽先など）で処理されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2e/7d0/24a/e2e7d024ad0c700d26390940caf339ed.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のものは高解像度と多くの小さな詳細を持っています。</font><font style="vertical-align: inherit;">異方性フィルタリングを行い、法線マップやその他のテクスチャと混合します。前景で人物の顔を見てください。</font><font style="vertical-align: inherit;">各シーンオブジェクトのテクスチャリング要件の違いは、プログラマーによって考慮されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレーヤーはこれまで以上に高いレベルのディテールとリアリズムを期待しているため、これは今日多くのゲームで発生しています。</font><font style="vertical-align: inherit;">テクスチャは大きくなり、表面に重ねられるテクスチャが増えていますが、テクセルをサンプリングしてピクセルに重ね合わせるプロセスは、基本的にQuakeの時代と同じです。</font><font style="vertical-align: inherit;">最高のテクノロジーは、古くても死ぬことはありません。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja499524/index.html">Quarkus：JBoss EAPクイックスタートのhelloworldサンプルを使用したアプリケーションのアップグレード</a></li>
<li><a href="../ja499528/index.html">フェルマーの大定理を超えた「見事な」数学的橋</a></li>
<li><a href="../ja499532/index.html">数の言葉：Yandex.Metricaによる無料のブログ分析habravebinary</a></li>
<li><a href="../ja499534/index.html">Pythonバックエンドサービス開発ガイド</a></li>
<li><a href="../ja499536/index.html">自分を知る方法としてのGrowbox</a></li>
<li><a href="../ja499542/index.html">トップファカポフシアン</a></li>
<li><a href="../ja499544/index.html">Googleスプレッドシートでニューラルネットワークを学ぶ</a></li>
<li><a href="../ja499546/index.html">アナログビデオカメラEVR-Y2022Fのファームウェア開発</a></li>
<li><a href="../ja499548/index.html">マスク-他人の世話やセキュリティの幻想？</a></li>
<li><a href="../ja499550/index.html">エコシステム低コードソリューション</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>