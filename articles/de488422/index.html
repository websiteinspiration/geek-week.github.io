<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌🏾 🙌🏻 👍🏻 10 Codezeilen, um die Schmerzen Ihres Vue-Projekts zu verringern 🍮 👂 ✋🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="... oder Vertrautheit mit Vue JS-Plugins als Beispiel für einen integrierten Ereignisbus
 Ein paar Worte über ...
 Hallo alle zusammen! Ich werde sofo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>10 Codezeilen, um die Schmerzen Ihres Vue-Projekts zu verringern</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odin_ingram_micro/blog/488422/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... oder Vertrautheit mit Vue JS-Plugins als Beispiel für einen integrierten Ereignisbus</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein paar Worte über ...</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hallo alle zusammen! </font><font style="vertical-align: inherit;">Ich werde sofort eine Reservierung vornehmen. </font><font style="vertical-align: inherit;">Ich liebe VueJS wirklich, ich schreibe seit mehr als 2 Jahren aktiv darüber und ich glaube nicht, dass die Entwicklung zumindest in erheblichem Maße schaden kann :)</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Andererseits versuchen wir immer, universelle Lösungen zu finden, die dazu beitragen, weniger Zeit für mechanische Arbeiten und mehr für das zu verwenden, was wirklich interessant ist. Manchmal ist die Lösung besonders erfolgreich. Eines davon möchte ich mit Ihnen teilen. Die 10 Zeilen, die besprochen werden (Spoiler: am Ende wird es etwas mehr geben), wurden bei der Arbeit am Cloud Blue - Connect-Projekt geboren, einer ziemlich großen Anwendung mit mehr als 400 Komponenten. Die gefundene Lösung ist bereits in verschiedene Punkte des Systems integriert und erfordert seit mehr als einem halben Jahr keine Korrekturen, sodass sie sicher als erfolgreich auf Stabilität getestet werden kann.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und der Letzte. </font><font style="vertical-align: inherit;">Bevor ich direkt zur Lösung übergehe, möchte ich noch etwas näher auf die Beschreibung der drei Arten der Interaktion zwischen Vue-Komponenten untereinander eingehen: die Prinzipien des unidirektionalen Flusses, das Muster des Speichers und des Ereignisbusses. </font><font style="vertical-align: inherit;">Wenn diese Erklärung für Sie unnötig (oder langweilig) ist, gehen Sie direkt zum Abschnitt mit der Lösung - alles ist so kurz und technisch wie möglich.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein bisschen darüber, wie Vue-Komponenten miteinander kommunizieren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielleicht ist die erste Frage, die eine Person, die ihre erste Komponente geschrieben hat, aufwirft, wie sie Daten für die Arbeit erhält und wie sie wiederum die Daten überträgt, die sie "out" erhalten hat. </font><font style="vertical-align: inherit;">Das im Vue JS-Framework verwendete Interaktionsprinzip heißt ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unidirektionaler Datenstrom</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz gesagt, dieses Prinzip klingt wie "Eigenschaften - unten, Ereignisse - oben". Das heißt, um Daten von außen ("von oben") zu empfangen, registrieren wir eine spezielle Eigenschaft innerhalb der Komponente, in die das Framework bei Bedarf unsere "von außen" empfangenen Daten schreibt. Um Daten "up" innerhalb der Komponente an der richtigen Stelle zu übertragen, rufen wir die spezielle $ emit-Framework-Methode auf, die unsere Daten an den Handler der übergeordneten Komponente weitergibt. Gleichzeitig können wir in Vue JS das Ereignis nicht einfach bis zu einer unbegrenzten Tiefe „übertragen“ (wie zum Beispiel in Angular 1.x). Es "erscheint" nur eine Ebene für den unmittelbaren Elternteil. Gleiches gilt für Veranstaltungen. Um sie auf die nächste Ebene zu übertragen, müssen Sie für jede von ihnen auch eine spezielle Schnittstelle registrieren - Eigenschaften und Ereignisse, die unsere „Nachricht“ weiterleiten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies kann als ein Bürogebäude beschrieben werden, in dem Arbeiter nur von ihren Stockwerken in die benachbarten ziehen können - eins nach oben und eins nach unten. Um das „Dokument zur Unterschrift“ vom fünften in den zweiten Stock zu übertragen, ist eine Kette von drei Arbeitern erforderlich, die es vom fünften in den zweiten Stock liefern, und drei weitere, die es in den fünften zurückliefern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Aber das ist unpraktisch!" Natürlich ist dies aus entwicklungspolitischer Sicht nicht immer praktisch, aber wenn wir uns den Code jeder Komponente ansehen, können wir sehen, was und an wen sie weitergegeben wird. Wir müssen nicht die gesamte Struktur der Anwendung berücksichtigen, um zu verstehen, ob unsere Komponente auf dem Weg zur Veranstaltung ist oder nicht. Wir können dies an der übergeordneten Komponente sehen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl die Vorteile dieses Ansatzes verständlich sind, weist er auch offensichtliche Nachteile auf, nämlich die hohe Kohäsion der Komponenten. </font><font style="vertical-align: inherit;">Einfach ausgedrückt, damit wir eine Komponente in die Struktur einfügen können, müssen wir sie mit den erforderlichen Schnittstellen überlagern, um ihren Status zu verwalten. </font><font style="vertical-align: inherit;">Um diese Konnektivität zu verringern, verwenden sie häufig „State Management Tools“. </font><font style="vertical-align: inherit;">Das vielleicht beliebteste Tool für Vue ist ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vuex (Seite)</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vuex Stor setzt unsere Analogie zu einem Bürogebäude fort und ist ein interner Postdienst. Stellen Sie sich vor, auf jeder Etage des Büros befindet sich ein Fenster zum Ausstellen und Empfangen von Paketen. Im fünften Stock übertragen sie das Dokument Nr. 11 zur Unterschrift und im zweiten fragen sie regelmäßig: „Gibt es Dokumente zur Unterschrift?“, Unterschreiben Sie die vorhandenen und geben Sie sie zurück. Beim fünften fragen sie auch: "Gibt es Unterzeichner?" Gleichzeitig können Mitarbeiter in andere Stockwerke oder in andere Räume umziehen - das Arbeitsprinzip ändert sich nicht, während die Post arbeitet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ungefähr nach diesem Prinzip funktioniert auch das Muster Store. Über die Vuex-Schnittstelle wird ein globales Data Warehouse registriert und konfiguriert, und Komponenten abonnieren es. Und es spielt keine Rolle, auf welcher Ebene in welcher Struktur der Einspruch stattgefunden hat, das Geschäft gibt immer die richtigen Informationen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint, dass damit alle Probleme bereits gelöst sind. Aber irgendwann in unserem metaphorischen Gebäude möchte ein Mitarbeiter einen anderen zum Mittagessen anrufen ... oder einen Fehler melden. Und hier beginnt das Seltsame. Die Nachricht selbst erfordert keine Übertragung als solche. Aber um die Mail nutzen zu können, müssen Sie etwas übertragen. Dann kommen unsere Mitarbeiter mit einem Code. Ein grüner Ball - zum Mittagessen gehen, zwei rote Würfel - ein Anwendungsfehler E-981273 ist aufgetreten, drei gelbe Münzen - überprüfen Sie Ihre Post und so weiter.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist leicht zu erraten, dass ich mit Hilfe dieser umständlichen Metapher Situationen beschreibe, in denen wir sicherstellen müssen, dass unsere Komponente auf ein Ereignis reagiert, das in einer anderen Komponente aufgetreten ist, die an sich in keiner Weise mit dem Datenstrom verbunden ist. </font><font style="vertical-align: inherit;">Das Speichern eines neuen Elements ist abgeschlossen - Sie müssen die Sammlung erneut durchführen. </font><font style="vertical-align: inherit;">Es ist ein nicht autorisierter 403-Fehler aufgetreten. Sie müssen eine Benutzerabmeldung starten und so weiter. </font><font style="vertical-align: inherit;">Die übliche (und bei weitem nicht die beste) Vorgehensweise besteht in diesem Fall darin, Flags im Geschäft zu erstellen oder die gespeicherten Daten und ihre Änderungen indirekt zu interpretieren. </font><font style="vertical-align: inherit;">Dies führt schnell zu einer Verschmutzung sowohl des Geschäfts selbst als auch der Logik der umgebenden Komponenten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dieser Phase beginnen wir darüber nachzudenken, wie Ereignisse direkt unter Umgehung der gesamten Komponentenkette übergeben werden können. </font><font style="vertical-align: inherit;">Und ein wenig googeln oder in der Dokumentation stöbern, stoßen wir auf ein Muster ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ereignisbus</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus technischer Sicht ist der Ereignisbus ein Objekt, mit dem mit einer speziellen Methode ein „Ereignis“ gestartet und mit einer anderen abonniert werden kann. Mit anderen Worten, wenn Sie sich für das eventA-Ereignis anmelden, speichert dieses Objekt die übergebene Handlerfunktion in seiner Struktur, die es aufruft, wenn die Startmethode mit dem eventA-Schlüssel irgendwo in der Anwendung aufgerufen wird. Das Signieren oder Ausführen reicht aus, um durch Import oder Referenz darauf zuzugreifen, und fertig. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metaphorisch gesehen ist in unserem „Gebäude“ ein Bus ein häufiger Chat im Messenger. Komponenten abonnieren einen "allgemeinen Chat", an den andere Komponenten Nachrichten senden. Sobald im "Chat", den die Komponente abonniert hat, eine "Nachricht" angezeigt wird, startet der Handler.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt viele verschiedene Möglichkeiten, einen Ereignisbus zu erstellen. </font><font style="vertical-align: inherit;">Sie können es selbst schreiben oder vorgefertigte Lösungen verwenden - denselben RxJS, der eine enorme Funktionalität für die Arbeit mit ganzen Ereignisströmen bietet. </font><font style="vertical-align: inherit;">Aber meistens verwenden sie bei der Arbeit mit VueJS seltsamerweise VueJS selbst. </font><font style="vertical-align: inherit;">Die über den Konstruktor (new Vue ()) erstellte Vue-Instanz bietet eine schöne und übersichtliche Ereignisoberfläche, die in der offiziellen Dokumentation beschrieben wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier kommen wir der nächsten Frage nahe ...</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was wollen wir?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wir möchten in unserer Anwendung einen Ereignisbus erstellen. </font><font style="vertical-align: inherit;">Wir haben jedoch zwei zusätzliche Anforderungen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sollte in jeder Komponente leicht zugänglich sein. </font><font style="vertical-align: inherit;">Separate Importe in jede der Dutzenden von Komponenten erscheinen uns überflüssig.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es muss modular sein. </font><font style="vertical-align: inherit;">Wir möchten nicht alle Ereignisnamen berücksichtigen, um die Situation zu vermeiden, in der das Ereignis "Element erstellt" Handler aus der gesamten Anwendung auslöst. </font><font style="vertical-align: inherit;">Daher möchten wir in der Lage sein, ein kleines Fragment des Komponentenbaums einfach in ein separates Modul zu trennen und seine Ereignisse innerhalb und nicht außerhalb zu übertragen.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diese beeindruckende Funktionalität zu implementieren, verwenden wir die leistungsstarke Plug-In-Schnittstelle, die uns VueJS zur Verfügung stellt. </font><font style="vertical-align: inherit;">Sie können sich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf der Seite mit der offiziellen Dokumentation </font><font style="vertical-align: inherit;">ausführlicher damit vertraut machen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Registrieren wir zuerst unser Plugin. </font><font style="vertical-align: inherit;">Dazu platzieren wir unmittelbar vor dem Initialisierungspunkt unserer Vue-Anwendung (vor dem Aufruf von Vue. $ Mount ()) den folgenden Block:</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({   <font></font>
  install(vue) { }, <font></font>
});<font></font>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich sind Vue-Plugins eine Möglichkeit, die Funktionalität des Frameworks auf der gesamten Anwendungsebene zu erweitern. Die Plugin-Schnittstelle bietet verschiedene Möglichkeiten zur Integration in die Komponente. Heute werden wir jedoch die Mixin-Schnittstelle vorstellen. Diese Methode akzeptiert ein Objekt, das den Deskriptor jeder Komponente erweitert, bevor der Lebenszyklus in der Anwendung gestartet wird.</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Der Komponentencode, den wir schreiben, ist eher nicht die Komponente selbst, sondern eine Beschreibung ihres Verhaltens und der Kapselung eines bestimmten Teils der Logik, die das Framework in verschiedenen Phasen seines Lebenszyklus verwendet. Die Plug-In-Initialisierung liegt außerhalb des Komponentenlebenszyklus und liegt daher vor uns Wir sagen "Deskriptor", keine Komponente, um zu betonen, dass genau der Code, der in unserer Datei geschrieben ist, und nicht irgendeine Entität, die ein Produkt der Arbeit des Frameworks ist, in den Mixin-Abschnitt des Plugins übertragen wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({<font></font>
  install(vue) {     <font></font>
    vue.mixin({}); <span class="hljs-comment">// &lt;--</span><font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses leere Objekt enthält die Erweiterungen für unsere Komponenten. Aber für den Anfang noch eine Station. In unserem Fall möchten wir eine Schnittstelle für den Zugriff auf den Bus auf der Ebene jeder Komponente erstellen. Fügen wir unserem Deskriptor das Feld '$ Broadcast' hinzu, in dem ein Link zu unserem Bus gespeichert wird. Verwenden Sie dazu Vue.prototype:</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>; <span class="hljs-comment">// &lt;--</span><font></font>
    vue.mixin({}); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt müssen wir den Bus selbst erstellen, aber zuerst wollen wir uns an die Modularitätsanforderung erinnern und davon ausgehen, dass wir im Komponentendeskriptor das neue Modul mit dem Feld "$ module" mit einem Textwert deklarieren (wir werden es etwas später benötigen). </font><font style="vertical-align: inherit;">Wenn das Feld $ module in der Komponente selbst angegeben ist, erstellen wir einen neuen Bus dafür. Wenn nicht, übergeben wir den Link über das Feld $ parent an das übergeordnete Element. </font><font style="vertical-align: inherit;">Beachten Sie, dass uns die Deskriptorfelder über das Feld $ options zur Verfügung stehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden die Erstellung unseres Busses zum frühestmöglichen Zeitpunkt platzieren - im beforeCreate-Hook.</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({<font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>; <font></font>
    vue.mixin({<font></font>
      beforeCreate() {  <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {  <span class="hljs-comment">// &lt;--</span><font></font>
         <font></font>
 	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) {  <span class="hljs-comment">// &lt;--</span><font></font>
         <font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Schluss füllen wir die logischen Zweige aus. </font><font style="vertical-align: inherit;">Wenn der Deskriptor eine neue Moduldeklaration enthält, erstellen Sie eine neue Businstanz. Wenn nicht, nehmen Sie den Link von $ parent.</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>; <font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">new</span> Vue();  <span class="hljs-comment">// &lt;--</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">this</span>.$parent.$broadcast;  <span class="hljs-comment">// &lt;--</span><font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir verwerfen die Ankündigung des Plugins und betrachten ... 1, 2, 3, 4 ... 10 Zeilen, wie ich versprochen habe! </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Können wir es besser machen?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Klar können wir. </font><font style="vertical-align: inherit;">Dieser Code ist leicht erweiterbar. </font><font style="vertical-align: inherit;">In unserem Fall haben wir beispielsweise zusätzlich zu $ ​​Broadcast beschlossen, die $ rootBroadcast-Schnittstelle hinzuzufügen, die den Zugriff auf einen einzelnen Bus für die gesamte Anwendung ermöglicht. </font><font style="vertical-align: inherit;">Ereignisse, die der Benutzer auf dem $ Broadcast-Bus ausführt, werden auf dem $ rootBroadcast-Bus dupliziert, sodass Sie entweder alle Ereignisse eines bestimmten Moduls (in diesem Fall wird der Ereignisname als erstes Argument an den Handler übergeben) oder alle Anwendungsereignisse im Allgemeinen (dann) abonnieren können Der Modulname wird mit dem ersten Argument an den Handler übergeben, der Ereignisname mit dem zweiten, und die mit dem Ereignis übertragenen Daten werden mit den folgenden Argumenten übergeben. </font><font style="vertical-align: inherit;">Dieses Design ermöglicht es uns, die Interaktion zwischen den Modulen herzustellen und einen einzelnen Handler an die Ereignisse verschiedener Module zu hängen.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// This one emits event  </span>
<span class="hljs-keyword">this</span>.$broadcast.$emit(‘my-event’, ‘PARAM_A’); 
<span class="hljs-comment">// This is standard subscription inside module </span>
<span class="hljs-keyword">this</span>.$broadcast.$on(‘my-event’, (paramA) =&gt; {…}); 
<span class="hljs-comment">// This subscription will work for the same event </span>
<span class="hljs-keyword">this</span>.$rootBroadcast.$on(‘my-event’, (<span class="hljs-built_in">module</span>, paramA) =&gt; {…}); 
<span class="hljs-comment">// This subscription will also work for the same event </span>
<span class="hljs-keyword">this</span>.$rootBroadcast.$on(‘*’, (event, <span class="hljs-built_in">module</span>, paramA) =&gt; {…});
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie wir dies erreichen können: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie zunächst einen einzelnen Bus, der über $ rootBroadcast organisiert wird, und das Feld selbst mit einem Link:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue(); <span class="hljs-comment">// &lt;--</span><font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus; <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">new</span> Vue(); <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">this</span>.$parent.$broadcast; <font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt benötigen wir eine Modulmitgliedschaft in jeder Komponente. Erweitern wir also die Definition der Modularität wie folgt:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;  <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">new</span> Vue(); <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;  <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">this</span>.$parent.$broadcast; <font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als nächstes müssen wir das Ereignis auf dem modularen lokalen Bus so reflektieren, wie wir es zur Wurzel benötigen. </font><font style="vertical-align: inherit;">Dazu müssen wir zunächst eine einfache Proxy-Schnittstelle erstellen und den Bus selbst in das bedingt private Eigentum von $ bus stellen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">new</span> Vue() };  <span class="hljs-comment">// &lt;--</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">this</span>.$parent.$broadcast.$bus };  <span class="hljs-comment">// &lt;--</span><font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fügen Sie dem Objekt schließlich Proxy-Methoden hinzu, da das Feld $ Broadcast jetzt keinen direkten Zugriff auf den Bus bietet:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">new</span> Vue() };  <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">this</span>.$parent.$broadcast.$bus };<font></font>
        } <font></font>
        <span class="hljs-comment">// &gt;&gt;&gt;</span>
        <span class="hljs-keyword">this</span>.$broadcast.$emit = <span class="hljs-function">(<span class="hljs-params">…attrs</span>) =&gt;</span> {
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$emit(…attrs);           
          <span class="hljs-keyword">const</span> [event, …attributes] = attrs; 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, …attributes)); 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(‘*’, event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, …attributes)<font></font>
        };<font></font>
        <font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$on = <span class="hljs-function">(<span class="hljs-params">…attrs</span>) =&gt;</span> {           
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$on(…attrs);<font></font>
        };<font></font>
        <span class="hljs-comment">// &lt;&lt;&lt;</span><font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns abschließend daran denken, dass wir durch Schließen Zugriff auf den Bus erhalten. Dies bedeutet, dass die einmal hinzugefügten Handler nicht mit der Komponente gelöscht werden, sondern während der gesamten Zeit der Arbeit mit der Anwendung aktiv sind. Dies kann zu unangenehmen Nebenwirkungen führen. Fügen Sie unserem Bus am Ende des Lebenszyklus der Komponente eine Listener-Bereinigungsfunktion hinzu:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeDestroy() {                               <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">this</span>.$broadcast.$off(<span class="hljs-keyword">this</span>.$broadcastEvents);  <span class="hljs-comment">// &lt;--</span><font></font>
      },<font></font>
<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">this</span>.$broadcastEvents = [];  <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">new</span> Vue() };  <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">this</span>.$parent.$broadcast.$bus };<font></font>
        } <font></font>
<font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$emit = <span class="hljs-function">(<span class="hljs-params">…attrs</span>) =&gt;</span> {
          <span class="hljs-keyword">this</span>.$broadcastEvents.push(attrs[<span class="hljs-number">0</span>]);   <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$emit(…attrs);           
          <span class="hljs-keyword">const</span> [event, …attributes] = attrs; 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, …attributes)); 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(‘*’, event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, …attributes)<font></font>
        };<font></font>
        <font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$on = <span class="hljs-function">(<span class="hljs-params">…attrs</span>) =&gt;</span> {           
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$on(…attrs);<font></font>
        };<font></font>
<font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$off =: <span class="hljs-function">(<span class="hljs-params">...attrs</span>) =&gt;</span> {  <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$off(...attrs);   <span class="hljs-comment">// &lt;--</span><font></font>
        };<font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher bietet diese Option eine interessantere Funktionalität, wenn auch weniger präzise. </font><font style="vertical-align: inherit;">Damit können Sie ein komplettes System alternativer Kommunikation zwischen Komponenten implementieren. </font><font style="vertical-align: inherit;">Darüber hinaus ist er vollständig unter unserer Kontrolle und bringt keine externen Abhängigkeiten in unser Projekt ein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, dass Sie nach dem Lesen Ihr Wissen über Vue-Plugins erworben oder aktualisiert haben und das nächste Mal, wenn Sie Ihrer Anwendung einige allgemeine Funktionen hinzufügen müssen, diese effizienter implementieren können - ohne externe Abhängigkeiten hinzuzufügen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de488408/index.html">STM32 Ethernet-RS485 IoT Gateway</a></li>
<li><a href="../de488410/index.html">7 Lektionen, die ich in zehn Jahren in der Entwicklung gelernt habe</a></li>
<li><a href="../de488412/index.html">Erstellen eines Discord-Bots basierend auf discord.js</a></li>
<li><a href="../de488416/index.html">SLAE - Security Linux Assembly Expert Prüfung</a></li>
<li><a href="../de488418/index.html">REST-API-Authentifizierung mit Spring Security und MongoDB</a></li>
<li><a href="../de488424/index.html">Was wird mit ITSM im Jahr 2020 passieren?</a></li>
<li><a href="../de488426/index.html">Wie führe ich eine Codeüberprüfung durch? Teil 2: Navigation, Geschwindigkeit, Kommentare, Konflikte überprüfen</a></li>
<li><a href="../de488428/index.html">Wie prognostizieren wir die Zukunft bei der Yandex-Suche: von Fehlerkorrekturen bis zu Erkennungsabfragen</a></li>
<li><a href="../de488432/index.html">Snoop Project ist ein unglaubliches Tool für Internet Intelligence, auf das RuNet-Benutzer so lange gewartet haben</a></li>
<li><a href="../de488436/index.html">Erstellen Sie schnell Open-Source-Chiptune-Musik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>