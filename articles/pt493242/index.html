<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç∫ üë©üèΩ‚Äçüé® üñïüèª Algoritmos de processamento r√°pido de cadeias HTTP üëßüèª üïü üï∫üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A compacta√ß√£o de cabe√ßalhos padr√£o apareceu no HTTP / 2, mas o corpo dos valores de URI, Cookie e User-Agent ainda pode ser dezenas de kilobytes e req...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Algoritmos de processamento r√°pido de cadeias HTTP</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/493242/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A compacta√ß√£o de cabe√ßalhos padr√£o apareceu no HTTP / 2, mas o corpo dos valores de URI, Cookie e User-Agent ainda pode ser dezenas de kilobytes e requer tokeniza√ß√£o, pesquisa e compara√ß√£o de substrings. </font><font style="vertical-align: inherit;">A tarefa se torna cr√≠tica se um analisador HTTP precisar lidar com tr√°fego malicioso pesado. </font><font style="vertical-align: inherit;">As bibliotecas padr√£o fornecem extensas ferramentas de processamento de strings, mas as strings HTTP t√™m suas pr√≥prias especificidades. </font><font style="vertical-align: inherit;">√â por essa especificidade que o analisador HTTP Tempesta FW foi desenvolvido. </font><font style="vertical-align: inherit;">Seu desempenho √© v√°rias vezes maior em compara√ß√£o √†s solu√ß√µes modernas de c√≥digo aberto e supera as mais r√°pidas delas.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GcAJF4648JI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander Krizhanovsky</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">krizhanovsky</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) fundador e arquiteto do sistema Tempesta Technologies, especialista em computa√ß√£o de alto desempenho no Linux / x86-64. Alexander falar√° sobre as peculiaridades da estrutura das seq√º√™ncias HTTP, explicar√° por que as bibliotecas padr√£o s√£o pouco adequadas para process√°-las e apresentar√° a solu√ß√£o Tempesta FW. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sob o comando: como o HTTP Flood transforma seu analisador HTTP em um gargalo, problemas x86-64 com erros de previs√£o de ramifica√ß√£o, armazenamento em cache e mem√≥ria insuficiente em tarefas t√≠picas do analisador HTTP, comparando o FSM com saltos diretos, otimiza√ß√£o GCC, vetoriza√ß√£o autom√°tica, strspn () - e algoritmos do tipo strcasecmp () para seq√º√™ncias de HTTP, SSE, AVX2 e ataques de inje√ß√£o de filtragem usando o AVX2.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na Tempesta Technologies, desenvolvemos software personalizado: nos especializamos em √°reas complexas relacionadas ao alto desempenho. </font><font style="vertical-align: inherit;">Estamos especialmente orgulhosos do desenvolvimento do n√∫cleo da primeira vers√£o WAF da Positive Technologies. </font><font style="vertical-align: inherit;">O Web Application Firewall (WAF) √© um proxy HTTP: lida com uma an√°lise muito profunda do tr√°fego HTTP para ataques (Web e DDoS). </font><font style="vertical-align: inherit;">N√≥s escrevemos o primeiro n√∫cleo para isso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m da consultoria, estamos desenvolvendo o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta FW</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - este √© o Application Delivery Controller (ADC). </font><font style="vertical-align: inherit;">N√≥s vamos falar sobre ele.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controlador de Entrega de Aplicativos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Application Delivery Controller √© um proxy HTTP com funcionalidade aprimorada. </font><font style="vertical-align: inherit;">Mas falarei sobre um recurso relacionado √† seguran√ßa - sobre a filtragem de ataques DDoS e Web. </font><font style="vertical-align: inherit;">Mencionarei tamb√©m limita√ß√µes e mostrarei o trabalho e as fun√ß√µes com exemplos de c√≥digo.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mg/gf/tw/mggftw9mux_ycaxzjbfqe6hpdc0.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atua√ß√£o</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Tempesta FW est√° embutido no kernel Linux TCP / IP Stack. </font><font style="vertical-align: inherit;">Gra√ßas a isso e a v√°rias outras otimiza√ß√µes, √© muito r√°pido - ele pode processar 1,8 milh√£o de solicita√ß√µes por segundo em hardware barato. </font><font style="vertical-align: inherit;">Isso √© 3 vezes mais r√°pido que o Nginx na carga m√°xima e tamb√©m √© r√°pido quando comparado com </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a abordagem de desvio de kernel. </font></font></strong><br>
<br>
<img src="https://habrastorage.org/webt/te/md/pe/temdpec1gcgnm98ktgwr4gewn-8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em um pequeno n√∫mero de n√∫cleos, ele mostra desempenho semelhante ao projeto Seastar, usado no ScyllaDB (escrito em DPDK).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problema</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O projeto nasceu quando come√ßamos a trabalhar no PT AF - em 2013. </font><font style="vertical-align: inherit;">Este WAF foi baseado em um popular acelerador HTTP de c√≥digo aberto. </font><font style="vertical-align: inherit;">Nginx, HAProxy, Varnish ou Apache Traffic s√£o bons aceleradores HTTP: eles fornecem conte√∫do fino, armazenam em cache, modificam, mas nenhum deles </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foi projetado para processamento e filtragem de tr√°fego em massa</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, pensamos que, se houver um firewall no n√≠vel da rede, por que n√£o continuar com essa id√©ia e integrar-se √† pilha TCP / IP como um firewall no n√≠vel do aplicativo? </font><font style="vertical-align: inherit;">Na verdade, descobriu-se Tempesta FW - um </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h√≠brido de acelerador HTTP e firewall</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: O Nginx ser√° usado como exemplo no relat√≥rio porque √© um servidor da web simples e popular. </font><font style="vertical-align: inherit;">Em vez disso, poderia haver qualquer outro servidor HTTP de c√≥digo aberto.</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vejamos nossa </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solicita√ß√£o de HTTP</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (HTTP / (1, ~ 2)). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_o/3z/tq/_o3ztqvtwrv-7epdryhdztg8wsq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos ter um URI muito grande. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os separadores</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> importantes no momento da an√°lise do HTTP </font><font style="vertical-align: inherit;">s√£o destacados em vermelho e negrito </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Destacarei os recursos: cadeias grandes de v√°rios kilobytes, bem como delimitadores diferentes, por exemplo, "ponto e v√≠rgula" adicionais que precisamos analisar, ou a sequ√™ncia "\ r \ n". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um pouco sobre o HTTP / 2 tamb√©m precisa ser dito.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recursos HTTP / 2</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2 √© uma mistura de seq√º√™ncias de caracteres e dados bin√°rios</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esse mix tem mais a ver com otimizar a largura de banda de uma conex√£o do que economizar recursos do servidor. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O HTTP / 2 no HPACK usa uma tabela din√¢mica</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . A primeira solicita√ß√£o do cliente n√£o √© otimizada, n√£o est√° na tabela. Voc√™ deve analis√°-lo para que seja adicionado √† tabela. Se o HTTP / 2 DDoS chegar at√© voc√™, ser√° esse o caso. No caso normal, o HTTP / 2 √© um protocolo bin√°rio, mas voc√™ ainda precisa analisar o texto: nomes de cabe√ßalho de texto, dados. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codifica√ß√£o Huffman</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Essa √© uma codifica√ß√£o simples, mas o Huffman √© monstruosamente dif√≠cil de programar rapidamente para a compacta√ß√£o: a codifica√ß√£o do Huffman cruza o limite de bytes, voc√™ n√£o pode usar extens√µes de vetor e precisa usar bytes. </font><font style="vertical-align: inherit;">Voc√™ n√£o poder√° processar dados rapidamente em 32 ou 16 bytes. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cookies, User-Agent, Referer, URIs podem ser muito grandes</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Primeiro, remova o Huffman e envie-o para um analisador HTTP normal, o mesmo que no HTTP / 1. </font><font style="vertical-align: inherit;">Embora seja permitido pelo RFC, n√£o √© recomend√°vel compactar os cookies, porque s√£o dados confidenciais - voc√™ n√£o deve fornecer ao invasor informa√ß√µes sobre seu tamanho. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Processamento HTTP lento</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Todos os servidores HTTP primeiro decodificam o HTTP / 2 e depois enviam essas linhas para o analisador HTTP / 1 que o HTTP / 1 j√° usa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qual √© o problema com a an√°lise HTTP / 1?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ precisa programar rapidamente a m√°quina de estado.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ precisa processar rapidamente linhas consecutivas.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O tr√°fego malicioso tem como alvo a parte mais lenta (mais fraca) do processo. </font><font style="vertical-align: inherit;">Portanto, se queremos fazer um filtro, devemos prestar aten√ß√£o √†s partes lentas, para que elas tamb√©m trabalhem rapidamente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perfil do Nginx</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vejamos o perfil nginx sob o fluxo HTTP. </font><font style="vertical-align: inherit;">Desative o log de acesso para que o sistema de arquivos n√£o fique lento. </font><font style="vertical-align: inherit;">Quando mesmo uma p√°gina de √≠ndice regular √© solicitada, o analisador sobe na parte superior.</font></font><br>
<div class="scrollable-table"><table>
<tbody>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">%</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nome do s√≠mbolo</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1,5719</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_http_parse_header_line</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.0303</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_vslprintf</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,6401</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5807</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recv</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5156</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_linux_sendfile_chain</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,4990</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_http_limit_req_handler</font></font></td>
</tr>
</tbody>
</table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esquerda - "Perfil plano". </font><font style="vertical-align: inherit;">Curiosamente, o ponto mais quente n√£o √© muito mais pesado que o outro, e depois o perfil desce suavemente. </font><font style="vertical-align: inherit;">Isso significa, por exemplo, que otimizar a primeira fun√ß√£o duas vezes n√£o ajudar√° a melhorar significativamente o desempenho. </font><font style="vertical-align: inherit;">Por isso, n√£o otimizamos o mesmo Nginx, mas fizemos um novo projeto que melhorar√° o desempenho de toda a cauda do perfil.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como os analisadores HTTP regulares s√£o codificados</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Normalmente, temos um loop ( </font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) que √© executado ao longo da linha e duas vari√°veis: state ( </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) e data atual ( </font></font><code>str_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entramos no ciclo (1) e olhamos para o estado atual (estado de verifica√ß√£o). Passamos para os dados recebidos (s√≠mbolo </font></font><code><em>'b'</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e implementamos alguma l√≥gica. Passamos para o segundo estado (2). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hi/z7/s2/hiz7s2e3yw5bpqqz-qbir5hbteq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V√° para o final </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3) - esta √© a segunda transi√ß√£o em rela√ß√£o ao in√≠cio do nosso c√≥digo e, possivelmente, a segunda falha no cache de instru√ß√µes. Ent√£o vamos para o come√ßo </font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4), comemos o pr√≥ximo caractere ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gk/zs/17/gkzs17hdxtyfcaife8j1pms7wbi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... e novamente procuramos o estado nas instru√ß√µes internas </font></font><code>case 2:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando uma vari√°vel j√° foi atribu√≠da a um </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor</font></font><code>2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, poder√≠amos simplesmente ir para a pr√≥xima instru√ß√£o. </font><font style="vertical-align: inherit;">Mas, em vez disso, subiram novamente e desceram novamente. </font><font style="vertical-align: inherit;">N√≥s "cortamos c√≠rculos" por c√≥digo, em vez de simplesmente diminuir. </font><font style="vertical-align: inherit;">Analisadores normais n√£o, por exemplo, Ragel gera um analisador com transi√ß√µes diretas.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mc/ba/3w/mcba3wgxqkflqjvq1mxytcy_kwo.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisador HTTP Nginx</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algumas palavras sobre o analisador nginx e seu ambiente. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Nginx funciona com a API de soquete normal</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - os dados que v√£o para o adaptador s√£o copiados para o espa√ßo do usu√°rio. </font><font style="vertical-align: inherit;">Como resultado, temos um grande bloco de dados no qual estamos procurando o que precisamos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Nginx usa um algoritmo que funciona em duas passagens: primeiro ele procura por comprimento e depois verifica. </font><font style="vertical-align: inherit;">Na primeira etapa, ele verifica a sequ√™ncia de tokens, pesquisa o primeiro token ("trial"). </font><font style="vertical-align: inherit;">No segundo, tokens, verifica o final da solicita√ß√£o ( </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) e inicia </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, de acordo com o tamanho do token.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (p = b-&gt;pos; p &lt; b-&gt;last; p++) {<font></font>
    ...<font></font>
    <span class="hljs-keyword">switch</span> (state) {<font></font>
    ...<font></font>
    <span class="hljs-keyword">case</span> sw_method:<font></font>
        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">' '</span>) {<font></font>
            m = r-&gt;request_start;<font></font>
            <span class="hljs-keyword">switch</span> (p - m) {         <span class="hljs-comment">// switch on token length!</span><font></font>
            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                <span class="hljs-keyword">if</span> (ngx_str3_cmp(m, <span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>)) {<font></font>
                ...<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> ((ch &lt; <span class="hljs-string">'A'</span> || ch &gt; <span class="hljs-string">'Z'</span>) &amp;&amp; ch != <span class="hljs-string">'_'</span> &amp;&amp; ch != <span class="hljs-string">'-'</span>)<font></font>
                <span class="hljs-keyword">return</span> NGX_HTTP_PARSE_INVALID_METHOD;<font></font>
            <span class="hljs-keyword">break</span>;<font></font>
    ...</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Obter" est√° sempre no mesmo bloco de dados</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">O Tempesta FW funciona com c√≥pia zero. </font><font style="vertical-align: inherit;">Isso significa que os dados podem vir com um tamanho completamente arbitr√°rio: 1 byte ou 1000 bytes cada. </font><font style="vertical-align: inherit;">Este "mecanismo" n√£o nos conv√©m. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos ver como isso funciona </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no GCC.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gcc</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabela de pesquisa</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . √Ä esquerda, est√° um exemplo t√≠pico de enum: comece com 0, depois r√≥tulos consecutivos, 26 constantes e, em seguida, algum c√≥digo que processe tudo. √Ä direita est√° o c√≥digo que o compilador gera. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ac/1n/hh/ac1nhhz9jqe87hdqb6bxfv541vu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, compare a vari√°vel </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no registro EAX com uma constante. A seguir, apresentamos todos os r√≥tulos na forma de uma matriz seq√ºencial de ponteiros de 8 bytes (tabela de pesquisa). Nesta instru√ß√£o, repassamos o deslocamento nesta matriz - √© uma dupla desreferencia√ß√£o de ponteiros. Em baixo √† direita est√° o c√≥digo para o qual trocamos desta tabela. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acontece uma desreferencia√ß√£o dupla da mem√≥ria: se recebemos dados secretos, ent√£o, por bytes, encontramos o endere√ßo na matriz e vamos para esse ponteiro. √â importante saber que na vida ainda √© pior do que no exemplo - para tabela de consulta, o compilador </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gera</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o c√≥digo √© mais complicado no caso de um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">script</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para um ataque Spectre. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesquisa bin√°ria</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . O pr√≥ximo caso </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o </font><font style="vertical-align: inherit;">√© </font><font style="vertical-align: inherit;">com constantes sequenciais, mas com arbitr√°rias. O c√≥digo √© o mesmo, mas agora o GCC n√£o pode compilar uma matriz t√£o grande e usar constantes como o √≠ndice da matriz. Ele muda para a pesquisa bin√°ria. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/as/mo/7p/asmo7pb4lxsv7pchnafv-qjz7u4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä direita, vemos uma compara√ß√£o seq√ºencial, a transi√ß√£o para o endere√ßo e a continua√ß√£o da compara√ß√£o - a pesquisa bin√°ria √© por c√≥digo. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisador HTTP Nginx.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos ver o que √© a m√°quina de estado nginx. Possui 9 kilobytes de c√≥digo - isso √© tr√™s vezes menor que o cache de primeiro n√≠vel na m√°quina na qual os benchmarks foram lan√ßados (como na maioria dos processadores x86-64).</font></font><br>
<br>
<pre><code class="bash hljs">$ nm -S /opt/nginx-1.11.5/sbin/nginx<font></font>
| grep http_parse | cut -d<span class="hljs-string">' '</span> -f 2<font></font>
| perl -le <span class="hljs-string">'$a += hex($_) while (&lt;&gt;); print $a'</span><font></font>
9220<font></font>
<font></font>
$ getconf LEVEL1_ICACHE_SIZE<font></font>
32768<font></font>
<font></font>
$ grep -c <span class="hljs-string">'case sw_'</span> src/http/ngx_http_parse.c<font></font>
84</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O analisador de cabe√ßalho nginx </font></font><code>ngx_http_parse_header_line ()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© um tokenizador simples. </font><font style="vertical-align: inherit;">Ele n√£o faz nada com os valores dos cabe√ßalhos e seus nomes, mas simplesmente coloca os tokens dos cabe√ßalhos HTTP em um hash. </font><font style="vertical-align: inherit;">Se voc√™ precisar de qualquer valor de cabe√ßalho, verifique a tabela de cabe√ßalho e repita a an√°lise. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Devemos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verificar rigorosamente os nomes e valores dos cabe√ßalhos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> por raz√µes de seguran√ßa </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></strong><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta FW: valida√ß√£o de strings HTTP</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nossa m√°quina de estado √© uma ordem de magnitude mais poderosa: fazemos a valida√ß√£o do cabe√ßalho RFC e imediatamente, no analisador, processamos quase tudo. </font><font style="vertical-align: inherit;">Se nginx tem 80 estados, temos 520, e h√° mais deles. </font><font style="vertical-align: inherit;">Se segu√≠ssemos em frente </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, seria 10 vezes maior. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Temos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E / S de c√≥pia zero</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - peda√ßos de tamanhos diferentes podem cortar dados em lugares diferentes. </font><font style="vertical-align: inherit;">peda√ßos diferentes podem cortar nossos dados. </font><font style="vertical-align: inherit;">Na E / S de c√≥pia zero, por exemplo, "GET" pode (raramente) ocorrer como "GET", "GE" e "T" ou "G", "E" e "T", portanto, √© necess√°rio armazenar o estado entre partes de dados . </font><font style="vertical-align: inherit;">N√≥s praticamente removemos os custos de E / S, mas no perfil ele aumenta - tudo est√° ruim. </font><font style="vertical-align: inherit;">O analisador HTTP grande √© um dos locais mais cr√≠ticos no projeto.</font></font><br>
<br>
<pre><code class="bash hljs">$ grep -c <span class="hljs-string">'__FSM_STATE\|__FSM_TX\|__FSM_METH_MOVE\|__TFW_HTTP_PARSE_'</span> http_parser.c<font></font>
520<font></font>
    7.64% [tempesta_fw]     [k] tfw_http_parse_req<font></font>
    2.79% [e1000]           [k] e1000_xmit_frame<font></font>
    2.32% [tempesta_fw]     [k] __tfw_strspn_simd<font></font>
    2.31% [tempesta_fw]     [k] __tfw_http_msg_add_str_data<font></font>
    1.60% [tempesta_fw]     [k] __new_pgfrag<font></font>
    1.58% [kernel]          [k] skb_release_data<font></font>
    1.55% [tempesta_fw]     [k] __str_grow_tree<font></font>
    1.41% [kernel]          [k] __inet_lookup_established<font></font>
    1.35% [tempesta_fw]     [k] tfw_cache_do_action<font></font>
    1.35% [tempesta_fw]     [k] __tfw_strcmpspn</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que fazer para melhorar esta situa√ß√£o?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refer√™ncias diretas do FSM</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira coisa que fazemos √© </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usar n√£o um loop, mas transi√ß√µes diretas por labels ( </font></font></strong><code>go to</code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Geradores de analisadores normais como Ragel fazem isso. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bq/di/pr/bqdipr9bt6au4ifisfpvjli2p_e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Codificamos cada um de nossos estados com um r√≥tulo </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e um r√≥tulo em C com </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o mesmo nome</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Toda vez que queremos ir, encontramos um r√≥tulo </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou acessamos o mesmo estado diretamente do c√≥digo. A primeira vez que passamos </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e depois dentro dela, vamos diretamente para o r√≥tulo desejado. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desvantagem</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : quando queremos mudar para o pr√≥ximo estado, devemos avaliar imediatamente se ainda temos dados dispon√≠veis (porque E / S de c√≥pia zero). Corpo da condi√ß√£o</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ele √© copiado para cada estado: em vez de uma condi√ß√£o em um FSM regular acionado por comutador, temos 500 deles de acordo com o n√∫mero de estados. Gerar c√≥digo para cada estado n√£o √© bom. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No caso de grandes m√°quinas de estado, pois </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com um </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interior </font><font style="vertical-align: inherit;">grande </font><font style="vertical-align: inherit;">, o GTC tamb√©m repete a condi√ß√£o </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v√°rias vezes dentro do c√≥digo. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Substitua por </font></font></strong><code><strong>switch</strong></code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transi√ß√µes diretas.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A pr√≥xima otimiza√ß√£o √© que n√£o a usamos </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e mudamos para direcionar saltos para os meta endere√ßos salvos. Queremos ir imediatamente para o ponto desejado assim que entrarmos na fun√ß√£o. O GCC permite que voc√™ fa√ßa isso. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/i3/x5/7m/i3x57mb0tahhz99szccnfdbxde0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O GCC tem uma extens√£o padr√£o que pode ajudar. Pegamos o nome do r√≥tulo (aqui est√° </font></font><code>from</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) e atribu√≠mos seu endere√ßo a alguma vari√°vel C via duplo e comercial (&amp;&amp;). Agora podemos fazer uma instru√ß√£o de salto direto</font></font><code>jmp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para o endere√ßo desta etiqueta com </font></font><code>goto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos ver o que vem disso.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desempenho de convers√£o direta</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em um pequeno n√∫mero de estados, o gerador de c√≥digo de transi√ß√£o direta √© ainda um pouco mais lento que o normal </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mas para grandes m√°quinas estaduais, a produtividade dobra. </font><font style="vertical-align: inherit;">Se a m√°quina de estado for pequena, √© melhor usar a m√°quina usual </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="bash hljs">$ grep -m 2 <span class="hljs-string">'model name\|bugs'</span> /proc/cpuinfo<font></font>
model name : Intel(R) Core(TM) i7-6500U CPU @ 2.50GHz<font></font>
bugs       : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf<font></font>
<font></font>
$ gcc --version|head -1<font></font>
gcc (GCC) 8.2.1 20181105 (Red Hat 8.2.1-5)<font></font>
<font></font>
States     Switch-driven automaton     Goto-driven automaton<font></font>
     7     header_line:      139ms     header_line:          156ms<font></font>
    27     request_line:     210ms     request_line:         186ms<font></font>
   406     big_header_line: 1406ms     goto_big_header_line: 727ms</code></pre><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: O c√≥digo Tempesta √© mais complicado que os exemplos. </font><font style="vertical-align: inherit;">O GitHub tem todos os </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://github.com/tempesta-tech/blog/tree/master/"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benchmarks</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que voc√™ possa ver tudo em detalhes. </font><font style="vertical-align: inherit;">O c√≥digo do analisador original est√° dispon√≠vel </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no link</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (analisador HTTP principal). </font><font style="vertical-align: inherit;">Al√©m disso, no Tempesta FW, existem </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analisadores menores</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que usam o FSM mais facilmente.</font></font></em><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que as transi√ß√µes diretas podem ser mais lentas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na m√°quina de estado, passamos por muito c√≥digo, portanto (esperado) haver√° muitas previs√µes erradas de ramifica√ß√£o. </font><font style="vertical-align: inherit;">Vamos executar "cria√ß√£o de perfil" de acordo com a previs√£o de desvio de ramifica√ß√£o:</font></font><br>
<br>
<pre><code class="bash hljs">perf record -e branch-misses -g ./http_benchmark<font></font>
406 states:    switch       - 38% on switch(),<font></font>
               direct jumps - 13% on header value parsing<font></font>
			   <font></font>
7,27 states:   switch       - &lt;18% switch(), up to 40% <span class="hljs-keyword">for</span>()<font></font>
               direct jumps ‚Äì up to 46% on header &amp; URI parsing</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em uma grande m√°quina de estado com 406 estados, gastamos 38% do tempo processando transi√ß√µes </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em uma m√°quina de estado com transi√ß√µes diretas, os pontos ativos s√£o an√°lise de linha. </font><font style="vertical-align: inherit;">A an√°lise de uma sequ√™ncia em cada estado inclui a verifica√ß√£o da condi√ß√£o do final da sequ√™ncia: a condi√ß√£o </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na m√°quina de estados ativada </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="bash hljs">perf <span class="hljs-built_in">stat</span> -e L1-icache-load-misses ./http_benchmark<font></font>
<font></font>
                       Switch-driven automaton  Goto-driven automaton<font></font>
big FSM code size:                       29156                  49202<font></font>
L1-icache-load-misses:                      4M                     2M</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A seguir, vejamos a cria√ß√£o de perfil de ambos os tipos de m√°quina de estado pelos erros de cache de instru√ß√µes L1 de eventos - quase 30 kilobytes por </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e 50 kilobytes por saltos diretos (mais do que o cache das instru√ß√µes de primeiro n√≠vel). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece que, se n√£o cabermos no cache, deve haver muitas falhas de cache para essa m√°quina de estado. </font><font style="vertical-align: inherit;">Mas n√£o, eles s√£o 2 vezes menos. </font><font style="vertical-align: inherit;">Isso ocorre porque o cache funciona melhor: trabalhamos com o c√≥digo sequencialmente e conseguimos extrair dados dos caches mais antigos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O compilador altera a ordem do c√≥digo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando programamos o c√≥digo da m√°quina de estados </font></font><code>go to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, primeiro temos os estados que ser√£o chamados primeiro quando os dados forem recebidos: o m√©todo HTTP, URI e, em seguida, os cabe√ßalhos HTTP. Parece l√≥gico que o c√≥digo seja carregado no cache do processador sequencialmente, de cima para baixo, assim como analisamos os dados. Mas isso est√° completamente errado. Se voc√™ olhar o c√≥digo do assembler, ver√° coisas incr√≠veis. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tg/uf/zr/tgufzrnfusabmvn1gg9ulzjgvgo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä esquerda est√° o que programamos: primeiro analisamos os m√©todos </font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depois em algum lugar muito abaixo do m√©todo improv√°vel </font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Portanto, esperamos ver a an√°lise </font></font><code> GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font><font style="vertical-align: inherit;">no in√≠cio do montador </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e ent√£o </font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mas tudo √© exatamente o oposto: </font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no meio, </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no final e </font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acima.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso ocorre porque o compilador n√£o entende como os dados chegam at√© n√≥s. </font><font style="vertical-align: inherit;">Ele distribui o c√≥digo de acordo com sua imagem do belo c√≥digo. </font><font style="vertical-align: inherit;">Para que ele organize o c√≥digo na ordem correta, devemos usar a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">barreira</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do </font><strong><font style="vertical-align: inherit;">compilador</font></strong><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A barreira do compilador √© um manequim de montagem atrav√©s do qual o compilador n√£o reordenar√°. </font><font style="vertical-align: inherit;">Simplesmente colocando essas barreiras, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melhoramos a produtividade em 4%</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">STATE(sw_method) {<font></font>
    ... <span class="hljs-comment">// the most frequent states</span><font></font>
    MATCH(NGX_HTTP_GET, <span class="hljs-string">"GET "</span>);<font></font>
    MATCH(NGX_HTTP_POST, <span class="hljs-string">"POST"</span>);<font></font>
    <font></font>
    __asm__ __volatile__(<span class="hljs-string">""</span>: : :<span class="hljs-string">"memory"</span>);<font></font>
    ... <span class="hljs-comment">// many other states</span><font></font>
    <font></font>
    <span class="hljs-comment">// Improbable states</span><font></font>
    METH_MOVE(Req_MethU, <span class="hljs-string">'N'</span>, Req_MethUn);<font></font>
    METH_MOVE(Req_MethUn, <span class="hljs-string">'L'</span>, Req_MethUnl);<font></font>
    METH_MOVE(Req_MethUnl, <span class="hljs-string">'O'</span>, Req_MethUnlo);<font></font>
    METH_MOVE(Req_MethUnlo, <span class="hljs-string">'C'</span>, Req_MethUnloc);<font></font>
    METH_MOVE_finish(Req_MethUnloc, <span class="hljs-string">'K'</span>, NGX_HTTP_UNLOCK)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Componha o c√≥digo √† sua maneira</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como o compilador n√£o organiza os dados como desejamos, faremos a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">otimiza√ß√£o guiada pelo criador de perfil</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (otimiza√ß√£o sob o controle do criador de perfil). </font><font style="vertical-align: inherit;">A otimiza√ß√£o guiada por perfilador (PGO) √© o n√∫mero total de amostras, n√£o uma sequ√™ncia de chamadas. </font><font style="vertical-align: inherit;">Por exemplo, um URI recebe mais amostras que uma an√°lise de m√©todo, portanto, posicionar√° o c√≥digo de processamento do URI antes de processar o m√©todo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como funciona? </font><font style="vertical-align: inherit;">Escreveremos o c√≥digo, executaremos benchmarks nele, forneceremos o resultado da cria√ß√£o de perfil para o compilador e ele gerar√° o c√≥digo ideal para nossas cargas. </font><font style="vertical-align: inherit;">Mas o problema √© que ele simplesmente compila as se√ß√µes mais quentes do c√≥digo, mas n√£o controla a depend√™ncia de tempo. </font><font style="vertical-align: inherit;">Se o maior URI da carga, esse ser√° o local mais quente. </font><font style="vertical-align: inherit;">O URI subir√° para o topo da fun√ß√£o e o PGO n√£o mostrar√° que o nome do m√©todo est√° sempre antes do URI. </font><font style="vertical-align: inherit;">Por conseguinte, o PGO n√£o funciona.</font></font><br>
<br>
<pre><code class="cpp hljs">Req_Method: {<font></font>
    <span class="hljs-keyword">if</span> (likely(PI(p) == CHAR4_INT(<span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>))) {<font></font>
        ...<font></font>
        <span class="hljs-keyword">goto</span> Req_Uri;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (likely(PI(p) == CHAR4_INT(<span class="hljs-string">'P'</span>, <span class="hljs-string">'O'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'T'</span>))) {<font></font>
        ...<font></font>
        <span class="hljs-keyword">goto</span> Req_UriSpace;<font></font>
    }<font></font>
    <span class="hljs-keyword">goto</span> Req_Meth_SlowPath;<font></font>
}<font></font>
... <span class="hljs-comment">// other methods: POST, PUT etc.</span><font></font>
Req_Uri:<font></font>
    ... <span class="hljs-comment">// URI processing</span><font></font>
Req_Meth_SlowPath:<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que funciona? </font></font><br>
<br>
<code><strong>likely</strong></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code><strong>unlikely</strong></code> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">macros</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (para c√≥digo do kernel do Linux, os intr√≠nsecos do GCC est√£o dispon√≠veis no espa√ßo do usu√°rio </font></font><code>__builtin_expect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Eles dizem qual c√≥digo colocar mais perto. Por exemplo, os relat√≥rios prov√°veis ‚Äã‚Äãde que o corpo da solicita√ß√£o deve ficar imediatamente para tr√°s </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A pr√©-busca do c√≥digo (pr√©-busca do processador) selecionar√° esse c√≥digo e tudo ser√° r√°pido. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7x/4u/05/7x4u057of2wmtq310wflcuyvlei.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A imagem mostra o in√≠cio do m√©todo de an√°lise, o fim e a barreira. N√£o esper√°vamos ver o c√≥digo por tr√°s da barreira. Parece que n√£o deveria ser - n√≥s colocamos uma barreira. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas o que acontece na realidade? O compilador v√™ a </font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">condi√ß√£o - √© mais prov√°vel que entremos no corpo da condi√ß√£o e l√° mudaremos para um salto incondicional no r√≥tulo</font></font><code>Req_Uri</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Acontece que o c√≥digo que est√° ap√≥s a nossa condi√ß√£o n√£o √© processado no "caminho quente". </font><font style="vertical-align: inherit;">O compilador move o c√≥digo sob o r√≥tulo para tr√°s </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, apesar da barreira, porque a condi√ß√£o de c√≥digo quente √© atendida. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para isso n√£o, o GCC tem uma extens√£o: os atributos </font></font><code>hot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>cold</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para os r√≥tulos. </font><font style="vertical-align: inherit;">Eles dizem que etiqueta est√° quente (provavelmente) e qual est√° fria (menos prov√°vel). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bw/ra/uh/bwrauhxesqvk_ke22cw67cqwuja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui concordamos com o que √© </font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais prov√°vel </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e deixamos para ele </font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sob essa condi√ß√£o, o processamento de URI aumenta e </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fica abaixo. </font><font style="vertical-align: inherit;">Todo o outro c√≥digo para a m√°quina de estado menos prov√°vel fica abaixo porque a etiqueta est√° fria.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-O3 amb√≠guo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos dar uma olhada na otimiza√ß√£o do compilador. </font><font style="vertical-align: inherit;">A primeira coisa que vem √† mente √© usar n√£o o O2, mas o O3 - deve ser mais r√°pido. </font><font style="vertical-align: inherit;">Mas isso n√£o √© verdade - o O3 √†s vezes gera c√≥digo pior. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vc/-p/q8/vc-pq8a078kyofsx7cj1ukorbta.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O3 √© uma cole√ß√£o de algumas otimiza√ß√µes</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Se os adicionarmos ao O2 separadamente, obteremos diferentes op√ß√µes: algumas otimiza√ß√µes ajudam, outras interferem. </font><font style="vertical-align: inherit;">Para o nosso c√≥digo espec√≠fico, selecionamos apenas as otimiza√ß√µes que geram melhor o c√≥digo. </font><font style="vertical-align: inherit;">Deixamos o melhor resultado - aqui est√£o 1.820 segundos em rela√ß√£o a 1.838 e 1.858. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algumas op√ß√µes s√£o destacadas em verde - √© a vetoriza√ß√£o autom√°tica.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autovectoriza√ß√£o</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um exemplo de ciclo do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">guia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">GCC</font></a><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> a[<span class="hljs-number">256</span>], b[<span class="hljs-number">256</span>], c[<span class="hljs-number">256</span>];<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span> <span class="hljs-params">()</span> </span>{<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<font></font>
        a[i] = b[i] + c[i];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se tivermos uma matriz vari√°vel que se repita, podemos otimizar o ciclo - decompor em vetores. </font><font style="vertical-align: inherit;">Por padr√£o, a auto- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vetoriza√ß√£o √©</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ativada no terceiro n√≠vel de otimiza√ß√£o -O3 </font><font style="vertical-align: inherit;">: o GCC gera c√≥digo vetorial onde puder. </font><font style="vertical-align: inherit;">Mas </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nem todo c√≥digo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode ser vetorizado automaticamente (mesmo se for vetorizado em princ√≠pio). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos ativar a op√ß√£o GCC </font></font><code>-fopt-info-vec-all</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que mostra o que foi vetorizado e o que n√£o √©. </font><font style="vertical-align: inherit;">Entendemos que, para nosso benchmark, nada √© vetorizado, mas o c√≥digo ainda √© gerado pior. </font><font style="vertical-align: inherit;">Portanto, a vetoriza√ß√£o nem sempre funciona: √†s vezes atrasa o c√≥digo. </font><font style="vertical-align: inherit;">Mas sempre podemos ver o que foi vetorizado e o que n√£o √© e desativar a vetoriza√ß√£o, se necess√°rio.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alinhamento: como comparar uma string com GET?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fazemos um pequeno hack, como no nginx: n√£o analisamos linhas por bytes, mas calculamos </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e comparamos as linhas com eles.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR4_INT(a, b, c, d)    ((d &lt;&lt; 24) | (c &lt;&lt; 16) | (b &lt;&lt; 8) | a)</span><font></font>
<span class="hljs-keyword">if</span> (p == CHAR4_INT(<span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>)))<font></font>
    <span class="hljs-comment">// we have GET as method</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sabemos que, se n√£o estiver </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alinhado, diminui de 2 a 3 vezes. </font><font style="vertical-align: inherit;">Escrevemos uma pequena </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">refer√™ncia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que comprova isso.</font></font><br>
<br>
<pre><code class="cpp hljs">$ ./int_align<font></font>
Unaligned access = <span class="hljs-number">6.20482</span><font></font>
Aligned access = <span class="hljs-number">2.87012</span><font></font>
Read four bytes = <span class="hljs-number">2.45249</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o tente alinhar </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Vamos procurar, se o endere√ßo estiver </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alinhado, comparar por </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se n√£o, bytes.</font></font><br>
<br>
<pre><code class="cpp hljs"> (((<span class="hljs-keyword">long</span>)(p) &amp; <span class="hljs-number">3</span>)<font></font>
  ? ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">0</span>]) | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span>)<font></font>
  | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">16</span>) | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">3</span>]) &lt;&lt; <span class="hljs-number">24</span>))<font></font>
  : *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)(p));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas acontece que essa abordagem funciona pior:</font></font><br>
<br>
<pre><code class="bash hljs">full request line:     no difference<font></font>
method only:           unaligned      - 214ms<font></font>
                       aligned        - 231ms<font></font>
                       bytes          - 216ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em resumo: existe uma diferen√ßa entre o c√≥digo de refer√™ncia isolado e n√£o otimiz√°vel e o c√≥digo analisador embutido, que perde sua otimiza√ß√£o devido √† grande quantidade de c√≥digo. </font><font style="vertical-align: inherit;">N√£o houve penalidade no perfil. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: uma discuss√£o detalhada de por que isso est√° acontecendo em nossa tarefa pode ser </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lida no GitHub</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que as strings HTTP s√£o importantes para n√≥s?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por exemplo, este √© um URI normal: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pw/_d/tw/pw_dtwjndt-xro47gvj3qehvpm4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
se voc√™ for exigente o suficiente sobre o hotel, v√° para Reservas e defina alguns filtros, obtenha um URI de mais de um kilobyte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Nginx possui uma m√°quina de an√°lise bastante massiva em </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">N√£o funciona muito r√°pido. </font><font style="vertical-align: inherit;">Al√©m disso, no caso do Tempesta FW, precisamos n√£o apenas analisar o URI, mas tamb√©m verific√°-lo quanto a inje√ß√µes.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">case</span> sw_check_uri:<font></font>
    <span class="hljs-keyword">if</span> (usual[ch &gt;&gt; <span class="hljs-number">5</span>] &amp; (<span class="hljs-number">1U</span> &lt;&lt; (ch &amp; <span class="hljs-number">0x1f</span>)))<font></font>
        <span class="hljs-keyword">break</span>;<font></font>
    <span class="hljs-keyword">switch</span> (ch) {<font></font>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:<font></font>
        r-&gt;uri_ext = <span class="hljs-literal">NULL</span>;<font></font>
        state = sw_after_slash_in_uri;<font></font>
        <span class="hljs-keyword">break</span>;<font></font>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'.'</span>:<font></font>
        r-&gt;uri_ext = p + <span class="hljs-number">1</span>;<font></font>
        <span class="hljs-keyword">break</span>;<font></font>
    <span class="hljs-keyword">case</span> <span class="hljs-string">' '</span>:<font></font>
        r-&gt;uri_end = p;<font></font>
        state = sw_check_uri_http_09;<font></font>
        <span class="hljs-keyword">break</span>;<font></font>
    <span class="hljs-keyword">case</span> CR:<font></font>
        r-&gt;uri_end = p;<font></font>
        r-&gt;http_minor = <span class="hljs-number">9</span>;<font></font>
        state = sw_almost_done;<font></font>
        <span class="hljs-keyword">break</span>;<font></font>
    <span class="hljs-keyword">case</span> LF:<font></font>
        r-&gt;uri_end = p;<font></font>
        r-&gt;http_minor = <span class="hljs-number">9</span>;<font></font>
        <span class="hljs-keyword">goto</span> done;<font></font>
    <span class="hljs-keyword">case</span> <span class="hljs-string">'%'</span>:<font></font>
    r-&gt;quoted_uri = <span class="hljs-number">1</span>;<font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro URI: /redir_lang.jsp?lang=foobar%0d%0aContent-Length : </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
% </font><font style="vertical-align: inherit;">200 </font><font style="vertical-align: inherit;">%0d% 0a% 0d% 0aHTTP / 1.1% 20200% 20OK% 0d% 0aContent-Type:% 20text / </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
html% 0d% 0aContent -Length:% 2019% 0d% 0a% 0d% 0aShazam &lt;/ </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
html&gt;. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parece o primeiro, mas tem uma inje√ß√£o. Voc√™ ter√° que cavar fundo o suficiente para entender isso. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos executar um teste</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : fa√ßa o primeiro URI, alimente o wrk, configure-o para nginx e veja se a an√°lise do nginx fica muito quente. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m-/y1/id/m-y1idxtawyq5rjayodyb_r2tgq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se na consulta de √≠ndice regular anterior ficou claro que o analisador j√° est√° no topo, aqui fica ainda mais quente.</font></font><br>
<br>
<pre><code class="bash hljs">8.62%  nginx         [.] ngx_http_parse_request_line<font></font>
2.52%  nginx         [.] ngx_http_parse_header_line<font></font>
1.42%  nginx         [.] ngx_palloc<font></font>
0.90%  [kernel]      [k] copy_user_enhanced_fast_string<font></font>
0.85%  nginx         [.] ngx_strstrn<font></font>
0.78%  libc-2.24.so  [.] _int_malloc<font></font>
0.69%  nginx         [.] ngx_hash_find<font></font>
0.66%  [kernel]      [k] tcp_recvmsg</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que h√° de especial nas seq√º√™ncias HTTP? </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem diferentes separadores </font></font><code>' : '</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>' , '</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e at√© o final das linhas, que podem ser de byte duplo </font></font><code>\r\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou de </font><font style="vertical-align: inherit;">byte </font><font style="vertical-align: inherit;">√∫nico </font></font><code>\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, discutidos no in√≠cio. </font><font style="vertical-align: inherit;">N√£o h√° termina√ß√£o 0 das linhas C - por raz√µes de seguran√ßa, queremos verificar com mais precis√£o o que nos chega. </font><font style="vertical-align: inherit;">Temos duas fun√ß√µes padr√£o que ajudam no analisador.</font></font><br>
<br>
<ul>
<li><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: verifica o alfabeto, os caracteres dispon√≠veis em uma sequ√™ncia de caracteres, compila dinamicamente um alfabeto v√°lido, embora seja conhecido no est√°gio de compila√ß√£o do programa.</font></font></li>
<li><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">N√£o h√° necessidade de caso convertido para comparar </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com </font></font><code>Foo:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Na maioria dos casos </font></font><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, apenas a conformidade / n√£o conformidade √© necess√°ria e voc√™ n√£o precisa conhecer a posi√ß√£o na linha.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eles trabalham devagar. </font><font style="vertical-align: inherit;">Vamos ver os benchmarks e entender o que h√° de errado com eles.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisadores r√°pidos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem v√°rios analisadores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Nginx √© o analisador mais simples, que analisa rigorosamente a conformidade com RFC. Tamb√©m existem analisadores PicoHTTPParser (H2O) e Cloudflare. Eles processam dados mais rapidamente, mas podem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://blog.cloudflare.com/improving-pico"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pular caracteres</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que n√£o s√£o permitidos pelo RFC. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCMESTRI.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Os analisadores usam v√°rias abordagens diferentes. A primeira √© a instru√ß√£o PCMESTRI, que √© usada no analisador Pico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Definimos intervalos nas instru√ß√µes. Infelizmente, podemos carregar 16 caracteres ou 8 intervalos. Se o intervalo consistir em apenas um caractere - basta repetir. Devido a essa limita√ß√£o, o analisador Pico n√£o pode verificar completamente a conformidade com a RFC, porque a RFC possui mais de 8 intervalos nesse local.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ks/x8/m_/ksx8m_ixc0oy3kzucdwzumppaus.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Carregamos o alfabeto no registrador, carregamos a string, executamos a instru√ß√£o. Na sa√≠da, vemos rapidamente se h√° uma coincid√™ncia ou n√£o. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX2 - Abordagem CloudFlare.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O analisador CloudFlare, usando o AVX2, processa 32 bytes de uma string por vez, em vez de 16 bytes com um analisador Pico. A an√°lise √© melhor no CloudFlare porque foi transferida para o AVX2. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/b8/3j/g1/b83jg1epzz6ec6dllxv1j4a-0lo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verificamos todos os caracteres em um espa√ßo na tabela ASCII, todos os caracteres s√£o maiores que 128 e atingimos o intervalo entre eles. C√≥digo simples √© r√°pido. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compare PCMESTRI e AVX2.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para n√≥s, o limite atual √© de 1500. Esse √© o tamanho m√°ximo do pacote que chega at√© n√≥s. Vemos que o c√≥digo AVX2 no big data √© muito mais r√°pido que o analisador Pico. Mas funciona mais lentamente em pequenos dados, porque as instru√ß√µes s√£o mais pesadas no AVX2. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/se/5t/c2/se5tc2npli1yed8ypqkdkk3z-pm.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compar√°vel a</font></font><code><strong>strspn</strong></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se decidirmos usar </font></font><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as coisas pioram, especialmente em big data. </font><font style="vertical-align: inherit;">No analisador "combate" n√£o pode ser usado </font></font><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bf/08/vq/bf08vqlzni3dcjzxgiuj73zgszo.png"><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Tempesta matcher √© mais r√°pido e preciso</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nosso analisador de velocidade √© como esses dois. Em dados pequenos, √© t√£o r√°pido quanto um analisador Pico, em grandes, como o CloudFlare. No entanto, ele n√£o ignora caracteres inv√°lidos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5t/ns/lw/5tnslwsd-ywmrv1d4xaj5_ypwbw.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o analisador √© organizado?</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√≥s, como nginx, definimos uma matriz de bytes e verificamos os dados de entrada por ela - este √© o pr√≥logo da fun√ß√£o. Aqui, trabalhamos apenas com prazos curtos, usamos </font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">porque a predi√ß√£o incorreta de ramifica√ß√£o √© mais dolorosa para linhas curtas do que para linhas longas. N√≥s pegamos esse c√≥digo. Temos um limite de 4 por causa da √∫ltima linha - devemos escrever uma condi√ß√£o bastante poderosa. Se processarmos mais de 4 bytes, a condi√ß√£o ser√° mais dif√≠cil e o c√≥digo mais lento.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> uri_a[] __attribute__((aligned(<span class="hljs-number">64</span>))) = {<font></font>
        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<font></font>
        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<font></font>
        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<font></font>
        ...<font></font>
        <span class="hljs-comment">// Branch misprediction is more crucial for short strings</span><font></font>
        <span class="hljs-keyword">if</span> (likely(len &lt;= <span class="hljs-number">4</span>)) {<font></font>
                <span class="hljs-keyword">switch</span> (len) {<font></font>
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<font></font>
                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<font></font>
                    c3 = uri_a[s[<span class="hljs-number">3</span>]];<font></font>
                    <span class="hljs-comment">// fall through to process other chars</span><font></font>
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    c2 = uri_a[s[<span class="hljs-number">2</span>]];<font></font>
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    c1 = uri_a[s[<span class="hljs-number">1</span>]];<font></font>
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
                }<font></font>
                <span class="hljs-keyword">return</span> (c0 &amp; c1) == <span class="hljs-number">0</span> ? c0 : <span class="hljs-number">2</span> + (c2 ? c2 + c3 : <span class="hljs-number">0</span>);<font></font>
        }</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La√ßo principal e cauda grande. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No ciclo de processamento principal, dividimos os dados: se for longo o suficiente, processamos 128, 64, 32 ou 16 bytes cada. </font><font style="vertical-align: inherit;">Faz sentido processar 128 cada: paralelamente, usamos v√°rios canais de processador (v√°rios pipeline) e um processador superescalar.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> ( ; unlikely(s + <span class="hljs-number">128</span> &lt;= end); s += <span class="hljs-number">128</span>) {<font></font>
        n = match_symbols_mask128_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">128</span>)<font></font>
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">64</span> &lt;= end)) {<font></font>
        n = match_symbols_mask64_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">64</span>)<font></font>
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">64</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">32</span> &lt;= end)) {<font></font>
        n = match_symbols_mask32_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">32</span>)<font></font>
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">32</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">16</span> &lt;= end)) {<font></font>
        n = match_symbols_mask16_c(__C.URI_BM128, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">16</span>)<font></font>
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">16</span>;<font></font>
}</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rabo. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O final da fun√ß√£o √© semelhante ao in√≠cio. </font><font style="vertical-align: inherit;">Se tivermos menos de 16 bytes, processaremos 4 bytes em um loop e n√£o mais que 3 bytes no final.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">while</span> (s + <span class="hljs-number">4</span> &lt;= end) {<font></font>
        c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
        c1 = uri_a[s[<span class="hljs-number">1</span>]];<font></font>
        c2 = uri_a[s[<span class="hljs-number">2</span>]];<font></font>
        c3 = uri_a[s[<span class="hljs-number">3</span>]];<font></font>
        <span class="hljs-keyword">if</span> (!(c0 &amp; c1 &amp; c2 &amp; c3)) {<font></font>
                n = s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str;<font></font>
                <span class="hljs-keyword">return</span> !(c0 &amp; c1) ? n + c0 : n + <span class="hljs-number">2</span> + (c2 ? c2 + c3 : <span class="hljs-number">0</span>);<font></font>
        }<font></font>
        s += <span class="hljs-number">4</span>;<font></font>
}<font></font>
<font></font>
c0 = c1 = c2 = <span class="hljs-number">0</span>;<font></font>
<span class="hljs-keyword">switch</span> (end - s) {<font></font>
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                c2 = uri_a[s[<span class="hljs-number">2</span>]];<font></font>
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                c1 = uri_a[s[<span class="hljs-number">1</span>]];<font></font>
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
}<font></font>
<font></font>
n = s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str;<font></font>
<span class="hljs-keyword">return</span> !(c0 &amp; c1) ? n + c0 : n + <span class="hljs-number">2</span> + c2;</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carregamos m√°scaras e dados de bits -</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> este √© o algoritmo principal do corpo principal da fun√ß√£o. Apresentamos uma tabela ASCII (como na figura) com 16 linhas e 8 colunas. Primeiro, codificamos nossas linhas da tabela no primeiro registro do BM URI: a primeira e a segunda linha. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9l/cv/k2/9lcvk2_wg7qs6svdibpx9m1b09c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os s√≠mbolos reais que permitimos s√£o </font></font><code>0 @ P p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>2 B R q R</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Eles s√£o codificados da seguinte forma: </font></font><code>b8 = inv(1011 1000) = 0 @ P p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>f8 = inv(1111 1000) = 2 B R q R</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Codificamos na ordem inversa: come√ßamos com 0, o primeiro caractere de servi√ßo n√£o √© permitido e, em seguida, as unidades s√£o permitidas. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Defina as m√°scaras de bits ASCII.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por exemplo, aparece uma linha </font></font><code>"pr"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: o primeiro caractere da primeira linha √© ASCII, o segundo da segunda linha. Executamos a instru√ß√£o shuffle, que embaralha nossas linhas de tabela codificadas de acordo com a ordem desses caracteres na entrada.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_i/zr/ol/_izrolii19qo5olblx0zzjgq_iu.jpeg"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ID da coluna para entrada.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em seguida, colocamos as colunas da tabela ASCII em um registro diferente. Depois, cruzamos os registros de colunas e linhas e obtemos uma correspond√™ncia: nosso car√°ter ou n√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como as colunas s√£o os 4 bits mais significativos do byte, mudamos para a esquerda. O AVX possui um deslocamento de apenas 2 bytes; primeiro, mude o byte e depois n com nossa m√°scara para obter apenas bits significativos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d9/xy/xr/d9xyxrmjyplbnhkpwrxbqblians.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Organizando colunas ASCII</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Execute o segundo shuffle, mova a coluna para as posi√ß√µes desejadas. Nos dois casos, o byte de entrada da √∫ltima coluna, portanto, na primeira e na segunda posi√ß√£o, obtemos a mesma coluna. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/g1/2s/hxg12sn4xw-qlt7miq97k0pnwgy.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interse√ß√£o de colunas e linhas de m√°scaras</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Fazemos </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">("cruzamos" as colunas com as colunas) e obtemos que os dados de entrada s√£o v√°lidos - o resultado</font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">da interse√ß√£o de colunas e linhas n√£o √© zero. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cd/oa/kw/cdoakwgjf-oipltg_xeyyglobn8.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conte o n√∫mero de zeros no final. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coletamos tudo do vetor </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e o devolvemos √† sa√≠da - de maneira simples. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/f9/ci/tl/f9citlkgsjvtxifi9qe3pdxu7su.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Personalize os alfabetos. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabalhando com a tabela ASCII, obtemos um recurso barato: usamos tabelas est√°ticas, mas nada impede de perguntar ao usu√°rio qual alfabeto est√° dispon√≠vel para URIs, nomes e valores de cabe√ßalhos diferentes. </font><font style="vertical-align: inherit;">A solicita√ß√£o HTTP URI e o cabe√ßalho usam 8 alfabetos (mais ou menos) para analisar uma solicita√ß√£o HTTP. </font><font style="vertical-align: inherit;">Essas tabelas podem ser carregadas no mesmo c√≥digo e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comparadas em um √∫nico alfabeto especificado pelo usu√°rio, um</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> URI v√°lido. </font><font style="vertical-align: inherit;">Caso contr√°rio, √© diferente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ataques</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alguns casos em que isso pode ser √∫til. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ataque do SSRF com o BlackHat'17</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (‚ÄúUma Nova Era do SSRF‚Äù): </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://foo@evil.com:80@google.com/</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- um s√≠mbolo improv√°vel de e comercial. </font><font style="vertical-align: inherit;">Em algumas aplica√ß√µes, √© usado, em outras n√£o. </font><font style="vertical-align: inherit;">Mas se voc√™ n√£o o estiver usando, poder√° exclu√≠-lo do alfabeto v√°lido e o ataque ser√° bloqueado. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RCE-ataque:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬´eficaz √© a executar ataques de inje√ß√£o de comando como¬ª, BSides'16: </font></font><code>User-Agent: ...;echo NAELBD$((26+58))$echo(echo NAELBD)NAELBD...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O User-Agent √© um cabe√ßalho est√°tico, mas h√° casos de um ataque RCE quando alguns v√™m </font></font><code>shell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com caracteres at√≠picos para o User-Agent. </font><font style="vertical-align: inherit;">N√≥s nos protegemos, exceto pelo cifr√£o. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Substitui√ß√£o de caminho relativo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">O √∫ltimo caso √© o que o Google teve em 2016. </font><font style="vertical-align: inherit;">Aparelhos cacheados, dois pontos, chegaram ao URI </font></font><code>.../gallery?q=%0a{}*{background:red}/..//apis/howto_guide.html</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esses s√£o caracteres improv√°veis ‚Äã‚Äãque podem ser exclu√≠dos do alfabeto.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strcasecmp ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este √© um c√≥digo bastante trivial. </font><font style="vertical-align: inherit;">Tamb√©m comparamos cadeias de caracteres de 32 bytes, duas matrizes cada.</font></font><br>
<br>
<pre><code class="cpp hljs">__m256i CASE = _mm256_set1_epi8(<span class="hljs-number">0x20</span>);<font></font>
<font></font>
<span class="hljs-comment">// Hacker‚Äôs Delight for signed comparison: -0x80 for both operands</span><font></font>
__m256i A = _mm256_set1_epi8(<span class="hljs-string">'A'</span> ‚Äì <span class="hljs-number">0x80</span>);<font></font>
__m256i D = _mm256_set1_epi8(<span class="hljs-string">'Z'</span> - <span class="hljs-string">'A'</span> + <span class="hljs-number">1</span> ‚Äì <span class="hljs-number">0x80</span>);<font></font>
<font></font>
<span class="hljs-comment">// Hacker‚Äôs Delight: 'a' &lt;= v &lt;= 'z' to</span><font></font>
<span class="hljs-comment">// v - ('a' ‚Äì 0x80) &lt; 'z' - 'a' + 1 - 0x80</span><font></font>
__m256i sub = _mm256_sub_epi8(str1, A);<font></font>
__m256i cmp_r = _mm256_cmpgt_epi8(D, sub);<font></font>
__m256i lc = _mm256_and_si256(cmp_r, CASE);<font></font>
__m256i vl = _mm256_or_si256(str1, lc);<font></font>
__m256i eq = _mm256_cmpeq_epi8(vl, str2);<font></font>
<span class="hljs-keyword">return</span> ~_mm256_movemask_epi8(eq);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damos ao registro apenas uma linha, porque no segundo programamos as constantes em nosso analisador em min√∫sculas. </font><font style="vertical-align: inherit;">Como temos compara√ß√µes significativas, subtra√≠mos 128 de cada byte (um truque do Hacker's Delight). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tamb√©m comparamos o intervalo de um caractere v√°lido: se podemos registrar para essa sequ√™ncia ou n√£o, √© uma letra ou n√£o. </font><font style="vertical-align: inherit;">No momento de verificar isso, em vez de duas compara√ß√µes de a a z, podemos usar apenas uma compara√ß√£o (um truque do Hacker's Delight) e passar para uma constante.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desempenho strcasecmp ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tempesta √© muito mais r√°pido que GLIBC, mesmo a nova vers√£o (18 ou 19). </font><font style="vertical-align: inherit;">O c√≥digo </font></font><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamb√©m usa o AVX, mas n√£o a segunda vers√£o. </font><font style="vertical-align: inherit;">O AVX2 √© mais r√°pido, portanto, o Tempesta possui um c√≥digo mais r√°pido.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/zi/pb/wxzipbzdsbvge8u_abhsnok-gfa.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPU do kernel Linux</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usamos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extens√µes de processador de vetores</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - elas est√£o dispon√≠veis no kernel. As instru√ß√µes do vetor s√£o processadas pelo m√≥dulo do processador FPU. Este n√£o √© o m√≥dulo principal do processador, n√£o os principais registradores, mas bastante volumoso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, h√° otimiza√ß√£o no Linux. Se formos do kernel para o espa√ßo do usu√°rio e voltarmos, n√£o salvaremos o contexto dos registros da FPU (XMM, YMM, ZMM): alteramos o contexto apenas dos registros do m√≥dulo do processador principal. Sup√µe-se que o kernel do SO n√£o funcione com a extens√£o vetorial do processador. Mas se voc√™ precisar, por exemplo, a criptografia pode faz√™-lo, mas precisa usar </font></font><code>fpu_begin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>fpu_end</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">salvar e restaurar o contexto do registro da FPU:</font></font><br>
<br>
<pre><code class="cpp hljs">__kernel_fpu_begin_bh();<font></font>
memcpy_avx(dst, src, n);<font></font>
__kernel_fpu_end_bh();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essas s√£o macros nativas que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">salvam e restauram o estado do m√≥dulo do processador</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , respons√°vel pelos registros de vetores. </font><font style="vertical-align: inherit;">Estes s√£o recursos bastante lentos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX e SSE</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes dos par√¢metros de refer√™ncia para salvar e restaurar o contexto da FPU, algumas palavras sobre opera√ß√µes vetoriais. </font><font style="vertical-align: inherit;">Por que √†s vezes faz sentido trabalhar com assembler? </font><font style="vertical-align: inherit;">√Äs vezes, o GCC gera c√≥digo abaixo do ideal. </font><font style="vertical-align: inherit;">O problema √© que, nos modelos mais antigos de processador, h√° uma penalidade significativa na transi√ß√£o do SSE para o AVX. </font><font style="vertical-align: inherit;">O GCC possui uma nova chave </font></font><code>vzeroupper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- use-a para que n√£o gere essa instru√ß√£o </font></font><code>vzeroupper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que limpa os registros e remove essa penalidade. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ precisar√° usar esta instru√ß√£o apenas se estiver trabalhando com c√≥digo antigo que foi compilado para SSE por terceiros. </font><font style="vertical-align: inherit;">Este n√£o √© o nosso caso e podemos jogar essas instru√ß√µes com seguran√ßa.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPU</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Temos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto-vetoriza√ß√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no processador. Isso significa que em qualquer c√≥digo de espa√ßo do usu√°rio haver√° opera√ß√µes de vetor. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/n9/vy/0w/n9vy0wal4alh1eelo1rbdjabavc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quaisquer dois processos no sistema usam extens√µes de processador de vetor. Quando seu processo vai para o kernel e vice-versa, voc√™ n√£o perde tempo economizando e restaurando o estado vetorial do processador. Mas se voc√™ alternar de um espa√ßo do usu√°rio para outro (altern√¢ncia de contexto), al√©m do fato de os caches de primeiro n√≠vel estarem desabilitados l√°, o m√≥dulo de altern√¢ncia de contexto no in√≠cio / fim da FPU tamb√©m funcionar√° mal. A opera√ß√£o √© bastante cara - uma marca de microbench.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nas marcas de micropontos, tudo √© sempre dram√°tico, mas a opera√ß√£o √© muito cara. </font><font style="vertical-align: inherit;">Portanto, no espa√ßo do usu√°rio, alterne o contexto por um longo tempo. </font><font style="vertical-align: inherit;">No kernel, n√£o temos troca de contexto, ent√£o tudo √© r√°pido. </font><font style="vertical-align: inherit;">Salvamos e restauramos o processador vetorial apenas uma vez para um conjunto de pacotes suficientemente grande.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intelpocalypse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No come√ßo, mostrei uma op√ß√£o da tabela de pesquisa para otimizar o c√≥digo do comutador: um processo longo, enum, compila a tabela do comutador em uma matriz e segue a desreferencia√ß√£o dupla do ponteiro que salta sobre essa matriz. Este √© um cen√°rio para um ataque Spectre que explora a execu√ß√£o especulativa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Google tem um bom </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre como a dupla desreferencia√ß√£o de ponteiros em compiladores modernos √© organizada agora (desde o in√≠cio de 2018). N√£o funciona muito bem. Se no in√≠cio do registro algum endere√ßo foi armazenado e fomos para esse endere√ßo, agora temos um c√≥digo diferente.</font></font><br>
<br>
<pre><code class="cpp hljs">jmp *%r11 <font></font>
    call l1<font></font>
l0: pause<font></font>
    lfence<font></font>
    jmp l0<font></font>
l1: mov %r11, (%rsp)<font></font>
    ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como funciona? N√≥s chamamos a fun√ß√£o em l1, o processo vai para esse r√≥tulo e fazemos um hack: como se estivesse retornando da fun√ß√£o (o que n√£o √©), mas reescrevesse o endere√ßo de retorno. Quando fazemos a instru√ß√£o </font></font><code>call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">colocamos </font><font style="vertical-align: inherit;">o endere√ßo de retorno, o endere√ßo atual na pilha, reescrevemos-o com o conte√∫do necess√°rio do registro e vamos para l1. Mas o processador, quando seu pr√©-buscador est√° em execu√ß√£o, v√™ que existe uma fun√ß√£o e depois uma barreira. Consequentemente, tudo ser√° lento - ele libera a pr√©-busca e nos livramos da vulnerabilidade Spectre. O c√≥digo √© lento, o desempenho cai 15%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O pr√≥ximo ataque relativamente novo √© o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meltdown.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">√â espec√≠fico apenas para processos de espa√ßo do usu√°rio. </font><font style="vertical-align: inherit;">Muito doloroso √© ler a mem√≥ria do kernel do espa√ßo do usu√°rio. </font><font style="vertical-align: inherit;">O ataque √© evitado pelo KPTI (Kernel Pate Table Isolation), que √© compilado em novos kernels por padr√£o. </font><font style="vertical-align: inherit;">Mas o KPTI √© muito caro, at√© 30-40% de degrada√ß√£o do desempenho ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conforme medido pelo MariaDB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso se deve ao fato de voc√™ n√£o ter mais a otimiza√ß√£o lenta do TLB: o espa√ßo de endere√ßo do kernel e o processador s√£o completamente separados em diferentes tabelas de p√°ginas (antes, o TLB lento fazia o mapeamento do espa√ßo do kernel para a tabela de p√°ginas de cada processo). </font><font style="vertical-align: inherit;">Isso √© doloroso para o espa√ßo do usu√°rio, mas n√£o para o Tempesta FW, que funciona completamente no kernel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alguns links √∫teis:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=http://natsys-lab.blogspot.com/2014/11/the-fast-finite-state-machine-for-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√°quina de estado finito r√°pido para an√°lise de HTTP</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=http://natsys-lab.blogspot.com/2016/10/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Processamento de strings HTTP usando C, SSE4.2 e AVX2</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Del√≠cia do hacker</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentos de ataques de fus√£o e espectro</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intelpocalypse: goodbye fast system calls</a></li>
</ul><br>
<blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Saint HighLoad++</a>        .       , 6   -- (  ,      Saint HighLoad++)  ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> web </a>. <br>
<br>
     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PHP Russia</a>: 13   ,  .       ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">KnowledgeConf</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">++</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TechLead Conf</a> ‚Äî     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>  , ,    .<br>
</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt493226/index.html">Como ler e corrigir 100.000 linhas de c√≥digo por semana</a></li>
<li><a href="../pt493230/index.html">Novos insights do PageSpeed ‚Äã‚Äãdo Google com tecnologia Lighthouse 6 (beta): verifique o desempenho do seu site</a></li>
<li><a href="../pt493232/index.html">A hist√≥ria do meu trabalho na Open Product LLC</a></li>
<li><a href="../pt493234/index.html">ING lan√ßa Lion: uma biblioteca de componentes Web produtivos, acess√≠veis e flex√≠veis</a></li>
<li><a href="../pt493236/index.html">Asterisco: troncos externos no estado Solicita√ß√£o Enviada</a></li>
<li><a href="../pt493244/index.html">O que pode um computador qu√¢ntico</a></li>
<li><a href="../pt493248/index.html">Webinar "Oportunidades Winnum para an√°lise industrial"</a></li>
<li><a href="../pt493250/index.html">O que est√° acontecendo com as viagens agora - e como se proteger no transporte</a></li>
<li><a href="../pt493252/index.html">Experi√™ncia de ensino em uma escola de desenvolvimento ou por que voc√™ precisa ir para a escola depois da universidade</a></li>
<li><a href="../pt493254/index.html">O sistema de escutas telef√¥nicas em massa da popula√ß√£o era praticamente in√∫til para o FBI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>