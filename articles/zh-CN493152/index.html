<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏽 🚶🏾 🔨 神经网络和过程挖掘：尝试结识朋友 🕵🏽 🙏🏻 🍝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="流程挖掘是一个数据分析字段，可让您基于信息系统的日志来分析流程。由于在Habré上有关该领域的机器学习的使用的出版物很少，我们决定分享我们在开发用于解决面向过程的问题的预测模型方面的经验。作为VTB计划的一部分，面向初级IT专业人员的IT初学者，流程挖掘团队的实习生在研究银行流程的任务范围内测试了机...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>神经网络和过程挖掘：尝试结识朋友</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vtb/blog/493152/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流程挖掘是一个数据分析字段，可让您基于信息系统的日志来分析流程。由于在Habré上有关该领域的机器学习的使用的出版物很少，我们决定分享我们在开发用于解决面向过程的问题的预测模型方面的经验。作为VTB计划的一部分，面向初级IT专业人员的IT初学者，流程挖掘团队的实习生在研究银行流程的任务范围内测试了机器学习方法。在切入点下，我们将讨论何时何地以及如何解决这些问题的想法，我们做了什么以及我们取得了什么结果。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6n/hi/lg/6nhilgitc0hyxrpmzuypu6w0irg.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IT Junior Program是VTB Bank面向初学者IT专业人员的年度实习计划，该计划于2019年9月开始。</font><font style="vertical-align: inherit;">实习期为六个月。</font><font style="vertical-align: inherit;">根据2019年计划的结果，超过一半的实习生加入了员工并成为公司的员工。</font><font style="vertical-align: inherit;">有关该计划的更多信息，选择的开始和对候选人的要求，可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这就是该计划的学员如何处理银行的任务的方式。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在经典坐标系中，为了理解和形式化过程，有必要：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对员工进行面试；</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析可用的报告和文档。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在过程挖掘方法中，不仅基于过程参与者的专家意见，而且还基于来自信息系统的相关数据来形成数字过程模型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，我们获得了过程的客观数字模型，反映了过程IT系统中实际数据的移动。生成的模型可以实时工作，并允许您以必要的详细程度显示流程的当前状态。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在上</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一篇文章中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们讨论了流程挖掘平台和世行的实际任务，并借助其解决了这些问题。</font><font style="vertical-align: inherit;">实施的解决方案使我们能够大大减少准备向政府机构提交强制性报告的时间，还有助于发现和优化流程缺陷，以每日形式展示工作中采购的当前状态。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
随后，我们的客户不仅需要定性确定过程的当前状态，还需要预测其未来条件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，我们将逐步介绍如何利用DGQ高性能的DGX Station知名事件集解决预测采购过程持续时间的问题（以BPI Challenge 2019数据集为例），该过程由NVIDIA提供给我们进行研究。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">机器学习在过程挖掘中的应用</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了解决该问题，我们使用CatBoostRegressor建立了基线，然后开发了具有神经网络并嵌入分类变量的解决方案。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于源数据中存在分类特征和材质特征，因此决定使用boosting，它可以处理分类特征而无需编码，还可以解决离散输入和材质输入的问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
网络被用来建立完整的材料属性并解决整个材料输入上的问题，然后比较这两种方法并决定是否打扰网络。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资料说明</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
决定使用适合我们业务领域并具有类似特征的外部数据。</font><font style="vertical-align: inherit;">使用的BPI Challenge 2019数据集包括25万个案例-这是150万个事件。</font><font style="vertical-align: inherit;">初始数据由一组21个符号表示：18个分类符号（有索引符号），两个布尔值和一个实数。</font><font style="vertical-align: inherit;">选择采购流程的执行时间作为目标变量，它对应于业务的实际需求。</font><font style="vertical-align: inherit;">有关特征的详细描述，可以参考数据</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">描述</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基准线</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在进行模型训练之前，将数据按0.8 / 0.2的比例分为训练（训练）和测试（测试）样本。而且，划分不是根据事件发生的，而是根据情况发生的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了确定使用神经网络形式的复杂专有解决方案的适当程度，使用CatBoost建立了基线，CatBoost是决策树上梯度提升的高级库。为了建立基线，进行了最少的数据预处理（对分类特征进行编码，并在数据中具有相应的频率），开发了目标变量（案例工期）和许多新特征（除了原始数据集中已有的那些特征）：</font></font><br>
<br>
<ul>
<li>   .  ,        :      ,         ,     ,          ,   ,      .<br>
</li>
<li>Exponential Moving Average     . EMA     ,         .<br>
</li>
<li>     (, ,  ).<br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在训练集中训练CatBoostRegressor之后，我们得到以下结果：MAE（平均绝对误差）= 17.5天（即，预测目标变量的值与真实值平均相差17.5天）。该结果用于测试神经网络的有效性。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里重要的细节之一是基准线目标变量的开发。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们来个案例。我们用集合C（数据集中所有案例的集合）中的c_i表示它。每个案例都是事件的有序序列，即c_i =（e_0， ...，e_ni），其中ni是第i个案例的长度。对于每个事件，我们都有一个时间戳记-确切的开始时间。使用这些临时戳记，您可以计算没有最后事件的情况下的持续时间。但是，为每个事件分配这样的目标，即使对应关系ek∈ci，ek→ti（ti是第i种情况的持续时间），并不是很好。首先，在不同持续时间的情况下会发生类似事件（典型）。其次，我们要根据事件的某个子序列（按时间顺序）来预测案件的持续时间（这是由于我们不知道整个事件的顺序，也就是说，我们之前不知道案件的发生）它是如何发生的，但我们想根据此案例中的某些已知（发生）事件来评估整个案例的持续时间。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们需要将每种情况分解为长度从1到时间顺序事件的情况的长度的子序列，并分配一个目标变量，该变量等于从中获得这些子序列的情况的持续时间，即对应关系ci∈C，ci→{sub_cj} ni（ni如前所述，第i种情况的长度），j = 1且len（sub_cj）= j。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们将每个案例分为子序列，并将整个案例的持续时间分配给每个此类子序列。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于子序列的更多信息</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
如前所述，我们将案例分为子序列，并将案例的持续时间分配给每个子序列。我们将使用与输入数据大小一致的增强。现在我们有X = {{sub_c </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sup><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> } </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NI </font></font></sup> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K = 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> } </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吨= 1 N</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，sub_c </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IK</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是第k个第i个箱子子序列，T </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是第i个外壳的长度，N是病例数。也就是说，尺寸[Σ </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ñ </font></font></sup> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t = 1时</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ñ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，SC，17]，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SC</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个变量等于对应的箱子的子序列的长度。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在按频率对分类变量进行编码后，我们得到了实数和布尔变量以及编码的分类变量（在学习过程中将不会使用索引变量）。我们还可以在子序列上求平均值，而在分类特征中我们获得出现的分类值的平均频率，这也可以被视为描述案例中事件子集的特征，即被描述为子序列的特征。离开它，看看会发生什么。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将维度上的sc平均后，我们得到以下维度：[∑ </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N </font></font></sup> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t = 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，17]。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建筑模型</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据这些案例，我们将训练分为另一种训练和一个验证样本，采用具有默认参数的CatBoostRegressor，将其传递给训练样本，对验证样本进行验证，采用最佳迭代，并使用MAE作为验证指标。我们在测试中得到以下内容（在下图中）（我们将为火车所基于的同一管道分别准备测试。所有信号都基于测试中的数据，也就是说，我们没有任何针对目标变量的信号。唯一的警告：如果测试中的分类特征不符合我们在训练中看到的值，那么我们考虑该值在测试中的频率并更新字典以进行编码。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基线结果</font></font></b><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/90b/f18/386/90bf183863f8ad2cdb50098c58d06a37.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
•迭代次数：500。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•学习率：0.1。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
训练参数：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•培训时间：少于2分钟。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•铁：Tesla k80（来自colab）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•测试MAE：17.5天。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
•测试中案件的平均持续时间：66.3天。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">神经网络</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设定</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了训练神经网络，对数据进行了改进：建立了用于分类变量的嵌入，并调整了目标变量的分布。</font><font style="vertical-align: inherit;">接下来，在NVIDIA Tesla K80（Google Colab）和NVIDIA DGX Station上对神经网络进行了训练。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
获得了以下结果：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在NVIDIA K80（Google Colab）上的培训时间：20分钟。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在NVIDIA DGX Station上的培训时间：8分钟。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
神经网络的训练时间归因于所使用的GPU的技术特征的差异：</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVIDIA Tesla K80（Google Colab）</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVIDIA DGX工作站</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个NVIDIA Tesla K80 12GB</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4倍NVIDIA Tesla V100 32GB</font></font><br>
</td>
</tr>
</tbody></table></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预处理</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新迹象</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于事件价值的EMA：我们希望了解每种情况下的活动成本趋势。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缺陷类型：在数据集描述中，您可以找到有关购买（事件）的一些描述性统计信息的四种类型的信息-这些类型被分为原始数据集中的两个变量的值。</font><font style="vertical-align: inherit;">我们只需将其聚合回来（如果您查看数据集的描述，将会很清楚我们在说什么）。</font></font><br>
</li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分类符号我们</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
只需按自然数顺序对分类符号的唯一值进行编码，以便稍后我们可以教授嵌入。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分类变量</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
的嵌入我们确定每个分类变量的嵌入尺寸：</font></font><br>
<br>
<ul>
<li>,   ̆  ̆ ̆.    ̆ ,         ̆  ̆ ,    ̆,  .  : MUi&nbsp; = min(CAT_EMBEDDING_DIM; (len(uniquei) + 1) // 2), CAT_EMBEDDING_DIM — , uniquei —   i-  .<br>
</li>
<li> ,      3,       i-̆ ̆   max(3;MUi)+1,  1,        ,     train,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">unk</a>-.<br>
</li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们调整了目标在火车样本上的分布，</font></font></b>&nbsp;<br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
由于离群（持续了25万天的情况）和大量的短情况，初始分布实际上向左移动了很多，因此我们计算了0.05和0.95个百分位数，并将火车上的数据与目标之间这些急流。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在那之后，我们仍然有案例持续大约1天和大约100天，也就是说，目标变量经历了几个数量级。因此，几乎无法满足以下假设：目标变量在决策算法周围的分布是恒定的，即目标变量的分布接近于正态分布，但由于目标变量可以小于1或大于100，因此方差不是恒定的。以某种方式提高这种效果，我们将数据标准化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果如下图所示（黑线为正态分布）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/k4/qs/vz/k4qsvz1egedfnm9q4y6nljidoam.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后我们按案例将数据分为训练和验证。</font><font style="vertical-align: inherit;">这里还有一个明显的细微差别：我们使用均值和偏差对目标进行归一化，然后根据所有数据进行计算，然后除以火车并进行验证，即结果就像火车上的人脸，但是由于我们在这里解决了一个辅助问题，因此该人脸看起来并不像危急。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建筑标志</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理念</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们仅从火车上获取自然数字编码的分类标志。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不是从案例中提取子字符串，而只是从事件中提取事件，即嵌入数据中的一行用于嵌入-这是一个具有编码分类特征的事件。</font></font><br>
</li>
<li> :     ,   ̆,      ,   ,        ,            ̆  ̆    ̆. - ,         ̆,  ,  ,     ̆ (    ),      (     ,  - ̆  ).<br>
</li>
<li>       ̆        .<br>
</li>
<li>     ,     8-̆̆   elu   ̆,   (  ,   ,     ,  L2-)     .<br>
</li>
<li>,           , —    ,      ,    .<br>
</li>
<li>Summary:    — ̆  ̆ ̆ ̆        —  ̆.<br>
</li>
</ul><br>
<h3>   </h3><br>
<ul>
<li>Batch size = 1000</li>
<li>Learning rate = 3e-04.</li>
<li>  = 15.</li>
<li>: Tesla k80 (colab) + Nvidia DGX Station .</li>
<li> (colab) – 50 .</li>
<li> (Nvidia DGX Station) — 18 .</li>
</ul><br>
<img src="https://habrastorage.org/webt/53/4y/gh/534yghkinehatjl8cm1xwg5j0oi.png"><br>
<br>
<h3> </h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据准备</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
现在我们已经为分类变量进行了嵌入（这里有一个细微差别：我们诚实地在训练中采用了分类变量的唯一值（不是在我们为训练嵌入分配的那个值上，而是在我们刚开始分配的一个值上）训练），因此有可能在测试数据上存在我们在火车上没有看到的分类变量的值，也就是说，我们没有为此值进行嵌入训练。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于这样的值，在嵌入矩阵中会创建一条单独的线，但是在我们的案例中，问题是在训练过程中它没有参与，因此没有进行研究。基于此，如果遇到一个以前从未见过的分类变量的值，则可以采用此向量，但实际上它只是从初始化分布中获取的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在如何训练此向量中，有一个改进模型的方向。这个想法是火车上非常稀有的值可以用这个向量编码，因为如果我们仅在测试中看到一个新值，它有条件地占整个初始样本的20％，那么这个值是稀有的并且可能表现为与火车上的稀有价值相同。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在每种情况下，我们都将类别变量替换为相应的嵌入，并与real和Boolean属性连接，获得大小为[N，F]的矩阵，其中F是类别变量的嵌入尺寸之和，即real和Boolean属性的数量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们按照子序列对事件进行分组（如前所述）。</font><font style="vertical-align: inherit;">子序列的目标变量是从中获得子序列的情况的持续时间。</font><font style="vertical-align: inherit;">将此子序列中的事件数和事件成本之和加到子序列的向量中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们有了一个固定大小的矩阵-您可以输入模型（在对矩阵进行归一化之前）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并行化方法</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们为每个GPU建一个塔。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在每个步骤中，我们在塔之间划分参数。</font></font><br>
</li>
<li>       .<br>
</li>
<li> ̆   ,   .<br>
</li>
<li>       (      ,       ̆ ̆         ).<br>
</li>
<li>        .<br>
</li>
<li>     ,   -  (   ,  word2vec-style,     ).<br>
</li>
</ul><br>
<b></b><br>
<br>
<ul>
<li>          ()   ()  ().<br>
</li>
<li>̆ :   —   ,     gpu     ,    ,   gpu     .<br>
</li>
</ul><br>
<b></b><br>
<br>
<ul>
<li>: 7-̆̆    elu.<br>
</li>
<li>   ̆ ,    .<br>
</li>
<li>Batch size = 1000.<br>
</li>
<li>Learning rate = 3e-04.<br>
</li>
<li>  = 15.<br>
</li>
<li>: Tesla k80 (colab) + Nvidia DGX Station.<br>
</li>
<li> (colab) = 20 .<br>
</li>
<li> (Nvidia DGX Station) = 8 .<br>
</li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一张模型图</font></font></b><br>
<br>
<img src="https://habrastorage.org/webt/u5/4e/3e/u54e3eoth5n5kmcdryndbpqgcua.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，资源消耗和并行化</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
，在CPU上进行神经网络训练所需的时间是在NVIDIA DGX Station上花费的四倍。在这种情况下，差异似乎微不足道-在NVIDIA DGX Station上为8分钟，在CPU上为32分钟。但是，这是一个具有少量数据的小型模型。在实施实际项目时，案例和事件的数量会增加几倍，在CPU上的培训至少需要一周的时间。在这种情况下，使用NVIDIA DGX Station可以将培训时间减少到两天，这将大大提高工作效率。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还显示出学习过程的速度在很大程度上取决于所用GPU的数量，这显示了NVIDIA DGX Station的优势。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
先前在NVIDIA DGX Station CPU和GPU上进行的实验使用原始数据集进行了初步验证，而没有进行任何初步处理：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU上的学习时间：6分18秒。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU训练时间：34秒。</font></font><br>
</li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU </font></font></b><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6f1/015/d82/6f1015d82101dda1e0af40e599ee96a2.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">负载可视化CPU负载可视化</font></font></b><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/efe/3ae/f3b/efe3aef3b801dcbd14655b3851ae9ad3.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">神经网络结果</font></font></h3><br>
<img src="https://habrastorage.org/webt/-g/2g/p1/-g2gp1o1sdktbwtspcurjfdiwqu.png"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试MAE = 10天。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">案件在测试中的平均持续时间= 67天。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推断时间= 20秒。</font></font><br>
</li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发现</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们实施了一项试验，以在过程挖掘任务的背景下评估机器学习方法。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们测试并扩展了我们用于解决对业务重要的问题的工具的列表。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有趣的结果之一是在DGX站配备的4块Tesla v100卡上编写了我们自己的并行计算实现：使用多个gpu可以从gpu的数量中几乎在线地学习（代码是并行的）。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向完全连续输入的过渡以及神经网络的使用，使基准时间缩短了一周。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间从几分钟增加到一个半小时（对最终体系结构和嵌入进行训练，但是可以对嵌入进行预训练，因此时间减少到20分钟）。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所描述的实验表明，在过程挖掘领域，机器和深度学习算法可以成功应用。</font><font style="vertical-align: inherit;">此外，据透露，学习过程的速度很大程度上取决于所用GPU的数量，这显示了NVIDIA DGX Station的优势。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么以及如何可以改善</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Word2vec样式的事件嵌入</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在建立模型（包括分类变量的嵌入）时，我们没有考虑事件彼此之间的顺序，即案例内部事件的特殊语义。</font><font style="vertical-align: inherit;">要从案例内部的事件顺序中学习有用的东西，您需要训练这些事件的嵌入。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理念</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们采用一个分类特征和一个实数，将实数划分为存储桶，然后将通过分类变量的值和真实变量的值所在的存储桶来表征每个事务。</font><font style="vertical-align: inherit;">结合这两个值，就可以得到事件单词的类似物。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将案例视为句子（句子中的单词集对应于案例中的事件集）。</font></font><br>
</li>
<li> ̆      ,          ̆   ̆,    ,             .<br>
</li>
<li>   ̆,     Skipgram  CBOW   .<br>
</li>
<li>  ,      ̆,            .<br>
</li>
</ul><br>
<b> </b><br>
<br>
<ul>
<li>  Skipgram.<br>
</li>
<li>  — 5.<br>
</li>
</ul><br>
<ul>
<li>Batch size = 1000.<br>
</li>
<li>Learning rate = 3e-04.<br>
</li>
<li>  = 10.<br>
</li>
<li>: Tesla k80 (colab) + Nvidia DGX Station.<br>
</li>
<li> (colab) — 20 .<br>
</li>
<li> (Nvidia DGX Station) — 8 .<br>
</li>
<li>Test MAE    : 10 ̆.&nbsp;<br>
</li>
</ul><br>
<b><font style="vertical-align: inherit;"></font></b><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/438/137/cb8/438137cb87ac22637e44a01da4a56dfc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
嵌入中的</font><b><font style="vertical-align: inherit;">Count</font></b><font style="vertical-align: inherit;"> Using功能使一天增加了十分之几。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最终</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，嵌入是未经教育的，因为它们训练了一些。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分类嵌入大约有290个特征，语义嵌入大约有20个特征（由于字典的大小很小，因此不再有意义），因此由于特征比例的不平衡，这些语义特征的影响可以得到平均化。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件之间的语义需要以某种方式添加到训练集中，因为由于事件（案例）的顺序是有序的，所以顺序很重要，并且可以从中提取信息。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以使用更复杂的体系结构进行嵌入。</font></font><br>
</li>
<li>      ,       ,    —     .<br>
</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN493138/index.html">跟我说话：语音机器人今天能做什么</a></li>
<li><a href="../zh-CN493140/index.html">Cipollino历险记：Flant隔离IT任务</a></li>
<li><a href="../zh-CN493142/index.html">“让我们使用Kubernetes！” 您现在有8个问题</a></li>
<li><a href="../zh-CN493146/index.html">您今天可以做的令人兴奋的附带项目</a></li>
<li><a href="../zh-CN493150/index.html">使用思科路由器“远程”</a></li>
<li><a href="../zh-CN493158/index.html">Loghouse 0.3-我们期待已久的Kubernetes日志系统更新</a></li>
<li><a href="../zh-CN493160/index.html">我们如何在2019年改进hh.ru上的智能搜索：信息图表</a></li>
<li><a href="../zh-CN493162/index.html">在线会议的公开清单</a></li>
<li><a href="../zh-CN493164/index.html">事实证明，在线业务在当前环境中尚存。为什么？DNA已删除</a></li>
<li><a href="../zh-CN493166/index.html">Ontol：精选关于“倦怠”的文章[100+]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>