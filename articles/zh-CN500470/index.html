<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧕🏽 😇 🧑🏾 使您现有的业务解决方案适应SwiftUI。第3部分。使用体系结构 👊🏿 🥡 🆚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="祝大家有美好的一天！我和Usetech的领先移动开发人员Anna Zharkova一起，我们将
 
 继续分解SwiftUI的复杂性。可以在链接上找到前面的部分：
 
 第1 
 部分第2部分
 
 今天，我们将讨论架构的功能，以及如何将现有的业务逻辑转移并嵌入到SwiftUI应用程序中。
 
 S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>使您现有的业务解决方案适应SwiftUI。第3部分。使用体系结构</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500470/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">祝大家有美好的一天！</font><font style="vertical-align: inherit;">我和Usetech的领先移动开发人员Anna Zharkova一起，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
继续分解SwiftUI的复杂性。</font><font style="vertical-align: inherit;">可以在链接上找到前面的部分：</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第1 </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分第2部分</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
今天，我们将讨论架构的功能，以及如何将现有的业务逻辑转移并嵌入到SwiftUI应用程序中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftUI中的标准数据流基于View与包含属性和状态变量（即状态变量）的某个模型的交互。</font><font style="vertical-align: inherit;">因此，将MVVM推荐为SwiftUI应用程序的架构伙伴是合乎逻辑的。</font><font style="vertical-align: inherit;">苹果建议将其与Combine框架结合使用，该框架引入了声明性的Api SwiftUI以随着时间的推移处理值。</font><font style="vertical-align: inherit;">ViewModel实现ObservableObject协议，并作为ObservedObject连接到特定的View。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dd/ur/cp/ddurcpkb3o-tgqdmwl1gswmqvck.png"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可修改的模型属性声明为@Published。 </font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewsItemModel</span>: <span class="hljs-title">ObservableObject</span> </span>{<font></font>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> title: <span class="hljs-type">String</span> = <span class="hljs-string">""</span>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> = <span class="hljs-string">""</span>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> image: <span class="hljs-type">String</span> = <span class="hljs-string">""</span>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> dateFormatted: <span class="hljs-type">String</span> = <span class="hljs-string">""</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与传统的MVVM中一样，ViewModel与数据模型（即业务逻辑）进行通信，并以一种或另一种View形式传输数据。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NewsItemContentView</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> moder: <span class="hljs-type">NewsItemModel</span><font></font>
    <font></font>
    <span class="hljs-keyword">init</span>(model: <span class="hljs-type">NewsItemModel</span>) {
        <span class="hljs-keyword">self</span>.model = model <font></font>
    }<font></font>
    <span class="hljs-comment">//... - </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就像几乎其他任何模式一样，MVVM也有拥塞和</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
冗余</font><font style="vertical-align: inherit;">的趋势</font><font style="vertical-align: inherit;">。重载的ViewModel始终取决于业务逻辑的突出显示和抽象程度。视图的负载取决于元素对状态变量的依赖以及转换到其他视图的复杂性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在SwiftUI中，添加的是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View是一个结构，而不是一个class</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不支持继承，从而导致代码重复。</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
如果在小型应用程序中这不是很关键，那么随着功能的增加和逻辑的复杂性，过载变得至关重要，并且大量的复制粘贴会受到抑制。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，让我们尝试使用干净的代码和干净的体系结构的方法。毕竟，我们不能完全放弃MVVM，但DataFlow SwiftUI是基于它构建的，但是要重建的还很多。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">警告！</font></font><br>
</i><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您对有关体系结构的文章过敏，并且“干净代码”从短语中找出来，请向下滚动几段。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这不是Bob叔叔提供的Clean代码！</font></font><br>
</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
是的，我们不会采用鲍伯叔叔的“清洁代码”的最纯粹形式。对于我来说，其中包含过度工程。我们只会采取一个想法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
干净代码的主要思想是创建可读性最强的代码，然后可以轻松地对其进行扩展和修改。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
建议遵循很多软件开发原则。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ep/yb/qx/epybqx2vc9lfjagxz2nlkawvzqc.png" width="50%"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
很多人都知道它们，但不是每个人都喜欢，也不是每个人都使用它们。这是针对holivar的单独主题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了确保代码的纯度，至少有必要将代码分为功能层和模块，使用问题的一般解决方案并实现组件之间交互的抽象。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">至少您需要将UI代码与所谓的业务逻辑分开。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
无论选择哪种架构模式，使用数据库和网络，处理和存储数据的逻辑都与UI和应用程序本身的模块分开。同时，这些模块与服务或存储的实现一起工作，这些实现又访问网络请求的常规服务或常规数据存储。可以初始化某个应用程序模块（模块业务逻辑）最终访问的常规容器中的变量的初始化，您可以通过该变量来访问一项或另一项服务。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xj/5m/wj/xj5mwjxvmfme_cg6li2rowb9eny.png" width="75%"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们选择并抽象了业务逻辑，那么我们可以根据需要安排模块组件之间的交互。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原则上，所有现有的iOS应用程序模式都遵循相同的原理。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s_/b6/zl/s_b6zlrz8qcadakh4tgc75nh5da.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总有业务逻辑，有数据。还有一个呼叫管理器，负责显示和转换要输出的数据以及输出转换后的数据的位置。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">唯一的区别是角色在组件之间的分配方式。</font></font><br>
<br>
</b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
因为我们努力使应用程序可读，以简化当前和将来的更改，将所有这些角色分开是合乎逻辑的。我们的业务逻辑已经被突出显示，数据总是分开的。保留调度员，演示者和视图。结果，我们得到了一个由View-Interactor-Presenter组成的体系结构，其中交互器与业务逻辑服务进行交互，演示者转换数据并将其作为ViewModel的一种提供给我们的View。以一种很好的方式，导航和配置也可以从View中提取到单独的组件中。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-g/wf/bx/-gwfbxs-tyq0noqy2kr87dm3-nw.png" width="75%"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们获得了VIP + R架构，并将有争议的角色划分为不同的组件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们尝试看一个例子。</font><font style="vertical-align: inherit;">我们有一个</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用SwiftUI和MVVM编写</font><font style="vertical-align: inherit;">的小型新闻聚合器应用程序</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h-/ds/od/h-dsodxehcqsfbzn1oo0nruhx-y.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该应用程序具有3个独立的屏幕，具有自己的逻辑，即3个模块： </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新闻列表模块；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新闻屏幕模块；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新闻搜索模块。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个模块都包含一个ViewModel和一个View，该ViewModel与选定的业务逻辑进行交互，该ViewModel显示了ViewModel广播给它的内容。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/50/d1/7f/50d17fsmobld9mjgujdz3pe4f8g.png" width="60%"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们努力确保ViewModel仅与存储准备显示的数据有关。现在，他从事访问服务和处理结果的工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将这些角色转移给为每个</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
模块</font><font style="vertical-align: inherit;">设置的演示者和交互者</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5e/hd/i8/5ehdi8kd3otiltlepisfdr9pzua.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
交互器将从服务接收的数据传递给演示者，该演示者用准备好的数据填充绑定到View的现有ViewModel。原则上，关于模块业务逻辑的分离，一切都很简单。  </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在去查看。</font><font style="vertical-align: inherit;">让我们尝试处理强制代码重复。</font><font style="vertical-align: inherit;">如果我们正在处理某种控件，则可能是他的样式或设置。</font><font style="vertical-align: inherit;">如果我们正在谈论屏幕上的视图，那么：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 屏幕样式</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 常用的UI元素（LoadingView）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 信息警报；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 一些通用方法。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们不能使用继承，但可以完全</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用composition</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正是基于这一原则，在SwiftUI中创建了所有自定义视图。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们创建了一个View容器，在其中传输了所有相同的逻辑，然后将屏幕上的View传递给容器初始化程序，然后将其用作正文中的内容View。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContainerView</span>&lt;<span class="hljs-title">Content</span>&gt;: <span class="hljs-title">IContainer</span>, <span class="hljs-title">View</span> <span class="hljs-title">where</span> <span class="hljs-title">Content</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> containerModel = <span class="hljs-type">ContainerModel</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> content: <span class="hljs-type">Content</span><font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(content: <span class="hljs-type">Content</span>) {
        <span class="hljs-keyword">self</span>.content = content<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">var</span> body : some <span class="hljs-type">View</span> {
        <span class="hljs-type">ZStack</span> {<font></font>
            content<font></font>
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.containerModel.isLoading) {
                <span class="hljs-type">LoaderView</span>()<font></font>
            }<font></font>
        }.alert(isPresented: $containerModel.hasError){<font></font>
            <span class="hljs-type">Alert</span>(title: <span class="hljs-type">Text</span>(<span class="hljs-string">""</span>), message: <span class="hljs-type">Text</span>(containerModel.errorText),<font></font>
                 dismissButton: .<span class="hljs-keyword">default</span>(<span class="hljs-type">Text</span>(<span class="hljs-string">"OK"</span>)){
                <span class="hljs-keyword">self</span>.containerModel.errorShown()<font></font>
                })<font></font>
        }<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
屏幕上的视图嵌入在ContainerView内部的ZStack中，该视图还包含用于显示LoadingView的代码和用于显示信息警报的代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们还需要ContainerView从内部View的ViewModel接收信号并更新其状态。</font><font style="vertical-align: inherit;">我们无法通过@Observed订阅</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与内部View </font><font style="vertical-align: inherit;">相同的模型</font><font style="vertical-align: inherit;">，因为我们将拖动其信号。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hg/y4/gv/hgy4gvxu5fbdn4lbxs6vuzggrca.png" width="60%"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们通过委托模式与其建立通信，对于容器的当前状态，我们使用其自己的ContainerModel。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContainerModel</span>:<span class="hljs-title">ObservableObject</span> </span>{<font></font>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> hasError: <span class="hljs-type">Bool</span> = <span class="hljs-literal">false</span>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> errorText: <span class="hljs-type">String</span> = <span class="hljs-string">""</span>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> isLoading: <span class="hljs-type">Bool</span> = <span class="hljs-literal">false</span><font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupError</span><span class="hljs-params">(error: String)</span></span>{
     <span class="hljs-comment">//....</span><font></font>
       }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">errorShown</span><span class="hljs-params">()</span></span> {
     <span class="hljs-comment">//...</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">showLoading</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">self</span>.isLoading = <span class="hljs-literal">true</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hideLoading</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">self</span>.isLoading = <span class="hljs-literal">false</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ContainerView实现IContainer协议；实例引用分配给嵌入式View模型。 </font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span>  <span class="hljs-title">IContainer</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">showError</span><span class="hljs-params">(error: String)</span></span><font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">showLoading</span><span class="hljs-params">()</span></span><font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hideLoading</span><span class="hljs-params">()</span></span><font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContainerView</span>&lt;<span class="hljs-title">Content</span>&gt;: <span class="hljs-title">IContainer</span>, <span class="hljs-title">View</span> <span class="hljs-title">where</span> <span class="hljs-title">Content</span>: <span class="hljs-title">View</span>&amp;<span class="hljs-title">IModelView</span> </span>{<font></font>
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> containerModel = <span class="hljs-type">ContainerModel</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> content: <span class="hljs-type">Content</span><font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(content: <span class="hljs-type">Content</span>) {
        <span class="hljs-keyword">self</span>.content = content
        <span class="hljs-keyword">self</span>.content.viewModel?.listener = <span class="hljs-keyword">self</span><font></font>
    }<font></font>
    <span class="hljs-comment">//- </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
View实现IModelView协议以封装模型访问并统一一些逻辑。</font><font style="vertical-align: inherit;">出于相同目的的模型实现了IModel协议：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">IModelView</span> </span>{
    <span class="hljs-keyword">var</span> viewModel: <span class="hljs-type">IModel?</span> {<span class="hljs-keyword">get</span>}<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">protocol</span>  <span class="hljs-title">IModel</span>:<span class="hljs-title">class</span> </span>{
   <span class="hljs-comment">//....</span>
    <span class="hljs-keyword">var</span> listener:<span class="hljs-type">IContainer?</span> {<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，已经在该模型中，必要时调用了委托方法，例如，显示带有错误的警报，其中容器模型的状态变量发生了变化。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContainerView</span>&lt;<span class="hljs-title">Content</span>&gt;: <span class="hljs-title">IContainer</span>, <span class="hljs-title">View</span> <span class="hljs-title">where</span> <span class="hljs-title">Content</span>: <span class="hljs-title">View</span>&amp;<span class="hljs-title">IModelView</span> </span>{<font></font>
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> containerModel = <span class="hljs-type">ContainerModel</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> content: <span class="hljs-type">Content</span><font></font>
<font></font>
    <span class="hljs-comment">//- </span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">showError</span><span class="hljs-params">(error: String)</span></span> {
        <span class="hljs-keyword">self</span>.containerModel.setupError(error: error)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">showLoading</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">self</span>.containerModel.showLoading()<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hideLoading</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">self</span>.containerModel.hideLoading()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们可以通过切换到ContainerView来统一View的工作。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在配置以下模块和导航时，这将极大地便利我们的生活。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如何在SwiftUI中配置导航并进行干净的配置，我们将在下</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部分中讨论</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到示例的源代码</font><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN500454/index.html">“什么码头？” 或者我们使用Xamarin（Android）上的移动应用程序通过蓝牙控制控制器</a></li>
<li><a href="../zh-CN500456/index.html">BpfTrace-最后，在Linux上完全替代Dtrace</a></li>
<li><a href="../zh-CN500458/index.html">在线语音技术功能：入门包</a></li>
<li><a href="../zh-CN500462/index.html">检测场景变化并将h264视频剪辑保存到Raspberry Pi中而不进行解码</a></li>
<li><a href="../zh-CN500468/index.html">Java功能指南8-14</a></li>
<li><a href="../zh-CN500472/index.html">Python是时候腾出空间了。关于朱莉娅的前景</a></li>
<li><a href="../zh-CN500476/index.html">不确定</a></li>
<li><a href="../zh-CN500478/index.html">套筒上的俄罗斯方块：可穿戴电子设备的透气材料</a></li>
<li><a href="../zh-CN500484/index.html">Web组件代替React-另一尝试</a></li>
<li><a href="../zh-CN500486/index.html">如何解释二进制符号</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>