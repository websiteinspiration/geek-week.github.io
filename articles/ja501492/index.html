<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💡 🍫 🎅 Pythonを使用してPower BIコホート分析を繰り返す 🔮 💆🏽 🌔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、愛する読者の皆さん！この出版物を書いた理由は、私がYoutubeを見たウェビナーでした。彼は売上高のコホート分析に専念しました。著者は、Power BI Desktopプラットフォームを使用してデータを操作しました。この記事が広告と見なされないように、指定されたビデオへのリンクは提供しま...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Pythonを使用してPower BIコホート分析を繰り返す</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501492/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、愛する読者の皆さん！</font><font style="vertical-align: inherit;">この出版物を書いた理由は、私がYoutubeを見たウェビナーでした。</font><font style="vertical-align: inherit;">彼は売上高のコホート分析に専念しました。</font><font style="vertical-align: inherit;">著者は、Power BI Desktopプラットフォームを使用してデータを操作しました。</font><font style="vertical-align: inherit;">この記事が広告と見なされないように、指定されたビデオへのリンクは提供しませんが、ナレーションの過程で、私自身の決定の論理をよりよく説明するために、元のソースにネタバレを仕掛けるようにします。</font><font style="vertical-align: inherit;">このウェビナーでは、Pandasライブラリの機能を使用してDAX数式の可能性を繰り返すのは興味深いことだと思いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注目したい2つのポイント。まず、この資料は、Pythonプログラミング言語を使用する最初のステップを実行している初心者アナリストを対象としています。読者がPower BI BI分析プラットフォームに精通している場合に最適です。第2に、DAXの計算はインスピレーションの源として機能したため、著者のアルゴリズムを可能な限り「コピー」します。必然的に、主要なプログラミングパラダイムからの逸脱があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はじめに、これですべてです。道に行こう！</font></font><br>
<br>
<a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての計算はJupyterLab環境で実行します。ラップトップソリューションは（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データはPower Queryツールを使用してPower BIに読み込まれます（実際、これはM言語でクエリを生成するビジュアルエディターです）。開発中は次のルールに従う必要があります。すべてのデータ前処理はPower Queryを使用して実行し、メトリックはPower Pivotを使用して計算する必要があります。私たちのメインライブラリはPandasであるため、すぐにその機能を使用します。</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#   </span>
path_to_data = <span class="hljs-string">"C:/Users/Pavel/Documents/Demo/"</span>
<span class="hljs-comment"># </span>
df = pd.read_csv(os.path.join(path_to_data, <span class="hljs-string">"ohortAnalysis_2016_2018.csv"</span>), sep=<span class="hljs-string">";"</span>, parse_dates=[<span class="hljs-string">"date"</span>], dayfirst=<span class="hljs-literal">True</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将来的に最も時間のかかるセクションを確立するために、実行時にコード行をテストします。読み込まれたファイルへのフルパスを設定するには、osライブラリを使用します。ラップトップの開発プロセスを簡略化するために、それなしで行うことができます。データセット自体はランダムに構成されています。 CSVファイルには1,048,575行あります。 read_csv（）関数を使用したデータの読み取りは、通常は簡単です。配列内の列区切り記号と、日付がある場合は日付を含む列を指定するだけで十分です。情報がいくつかの「機能」と共にアップロードされた場合、各列のエンコーディングを指定するなど、追加のパラメーターを構成する必要がある場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの場合、head（）関数は、データ変換の進行状況を視覚的に監視するために使用されます。すべてのエラーを取り除くことはできませんが、明らかな欠陥はその場で修正できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データをモデルに読み込んだ後、ウェビナーの作成者はデータ配列を並べ替えます。これは、インデックス付きの補助列を追加するために行われます。今回の場合、この列は使用されませんが、テーブル内のフィールドの正しい計算をより便利に制御するために、データもソートされます。</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#  ,      </span>
df.sort_values([<span class="hljs-string">"user_id"</span>,<span class="hljs-string">"date"</span>], inplace = <span class="hljs-literal">True</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/t7/ek/x9/t7ekx9mfwh5z7cahruxyrvlvetq.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のステップで、Power BIプラットフォームのソリューションは、メインアレイにデータがプルされる補助テーブルを作成することを提案します。テーブルの作成は、SUMMARIZE（）関数を使用して行われます。選択したグループの合計を集計したピボットテーブルを作成します</font></font><code> df_groupby_user = SUMMARIZE(df;df[user_id];"first_date_transaction";MIN(df[date]);"total_amount_user";SUM(df[amount]);"count_transaction_user";COUNT(df[amount]))</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。Pandasライブラリには、対応するgroupby（）関数があります。 groupby（）を適用するには、必要なデータフレーム（グループ化可能な列）を指定するだけで十分です。最後に、集計関数が使用される列をリストします。得られた結果は、reset_index（）関数によって通常のデータフレームの形式に縮小されます。結論として、フィールドの名前を変更します。</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#       user_id. </span>
df_groupby_user = df.groupby(by = [<span class="hljs-string">"user_id"</span>]).agg({<span class="hljs-string">"date"</span>: <span class="hljs-string">"min"</span>, <span class="hljs-string">"amount"</span>: [<span class="hljs-string">"sum"</span>,<span class="hljs-string">"count"</span>]})<font></font>
df_groupby_user.reset_index(inplace = <span class="hljs-literal">True</span>)
<span class="hljs-comment"># </span>
new_columns = [<span class="hljs-string">"user_id"</span>,<span class="hljs-string">"first_date_transaction"</span>, <span class="hljs-string">"total_amount_user"</span>,<span class="hljs-string">"count_transaction_user"</span>]<font></font>
df_groupby_user.columns = new_columns</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「初回購入日」メトリックに加えて、顧客ごとのトランザクション数および期間全体の顧客購入の合計金額が計算されます。ラップトップでの測定結果は見つかりませんでしたが、削除しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウェビナーに戻ります。新しいメトリック「最初の購入の年月」が計算されます。 DAX式：</font></font><code> first_transaction = FORMAT(df_groupby_user[first_date_transaction];"YYYY-MM")</code><br>
<br>
<img src="https://habrastorage.org/webt/4l/3n/xo/4l3nxosdn2pddiqx3pffvtrniec.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pythonは構文dt.strftime（ '％Y-％m'）を使用します。 Pythonでの日付と時刻の操作に関するオンライン出版物で、それがどのように機能するかについての詳細な説明があります。このステップでは、他の何かが重要です。手術の時間に注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パンダのようなパフォーマンスはまったくありません（24.8秒）。コードの行は、以前のすべてのコードよりも低速です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このリストは、可能なリファクタリングの最初の候補になります。</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#  -</span>
df_groupby_user[<span class="hljs-string">"first_transaction"</span>] = df_groupby_user[<span class="hljs-string">"first_date_transaction"</span>].dt.strftime(<span class="hljs-string">'%Y-%m'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウェビナーに戻る時間です。</font><font style="vertical-align: inherit;">キーフィールドごとにテーブルの結合があります。</font><font style="vertical-align: inherit;">次に、RELATED（）関数を使用して、必要なフィールドをメインテーブルに取り込みます。</font><font style="vertical-align: inherit;">パンダにはこの機能はありません。</font><font style="vertical-align: inherit;">しかし、merge（）、join（）、concat（）があります。</font><font style="vertical-align: inherit;">この場合、最初のオプションを適用することをお勧めします。</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment"># </span>
df_final = pd.merge(df, df_groupby_user, how = <span class="hljs-string">"left"</span>, on = <span class="hljs-string">"user_id"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のトランザクションの日付のデータがメインテーブルに含まれた後、デルタを計算できます。</font><font style="vertical-align: inherit;">applyコンストラクト（lambda x：...）を使用して、このプロセスがどれほどリソースを消費するかを明確に示します（39.7秒）。</font><font style="vertical-align: inherit;">次に、コード書き換えの候補を示します。</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#   "    "</span>
df_final[<span class="hljs-string">"delta_days"</span>] = df_final[<span class="hljs-string">"date"</span>] - df_final[<span class="hljs-string">"first_date_transaction"</span>]<font></font>
df_final[<span class="hljs-string">"delta_days"</span>] = df_final[<span class="hljs-string">"delta_days"</span>].apply(<span class="hljs-keyword">lambda</span> x: x.days)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインテーブルにはすでに日別のデルタがあるため、列データをコホートに分割できます。原則：0（つまり、顧客への最初の販売）-コホート0; 0より大きく、30以下の値は30です。 30を超え、90以下の値は90などです。これらの目的のために、DAXではCEILING（）関数を使用できます。 2番目のパラメーターの値の倍数である最も近い整数に数値を切り上げます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/mu/rh/sdmurhtsdqarznw92jwbklpvjvs.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pythonでは、類似の数学関数は見つかりませんでしたが、mathモジュールで見つけるつもりでした（検索が不十分だった可能性があります）。したがって、私はあちこちに移動して、cut（）関数を適用する必要がありました。データをコホートに広げた後、NaNは0の数値にマッピングされました。カテゴリカルデータを扱っているため、fillna（）関数を使用してこの問題を解決することはできません。まず、カテゴリに新しい値を追加する必要があります。このコードリストの最後で、データ型をintに変更します。これは、将来、データフレームを使用してピボットテーブルを作成するときに、新しいコホートが一連の値の最後に表示されないようにするためです。</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#  . </span>
cut_labels_days = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range (<span class="hljs-number">30</span>, <span class="hljs-number">1230</span>, <span class="hljs-number">30</span>)]<font></font>
cut_bins_days = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range (<span class="hljs-number">0</span>, <span class="hljs-number">1230</span>, <span class="hljs-number">30</span>)]<font></font>
df_final[<span class="hljs-string">"cohort_days"</span>] = pd.cut(df_final[<span class="hljs-string">"delta_days"</span>], bins = cut_bins_days, labels=cut_labels_days, right = <span class="hljs-literal">True</span>)<font></font>
%%time<font></font>
<span class="hljs-comment">#     .   fillna   !</span>
df_final[<span class="hljs-string">"cohort_days"</span>] = df_final[<span class="hljs-string">"cohort_days"</span>].cat.add_categories([<span class="hljs-number">0</span>])<font></font>
df_final[<span class="hljs-string">"cohort_days"</span>].fillna(<span class="hljs-number">0</span>, inplace = <span class="hljs-literal">True</span>)<font></font>
%%time<font></font>
<span class="hljs-comment">#     .   fillna   !</span>
df_final[<span class="hljs-string">"cohort_days"</span>] = df_final[<span class="hljs-string">"cohort_days"</span>].cat.add_categories([<span class="hljs-number">0</span>])<font></font>
df_final[<span class="hljs-string">"cohort_days"</span>].fillna(<span class="hljs-number">0</span>, inplace = <span class="hljs-literal">True</span>)
<span class="hljs-comment">#    .    ,  "0"        ,     </span>
<span class="hljs-comment">#    .</span>
df_final[<span class="hljs-string">"cohort_days"</span>] = df_final[<span class="hljs-string">"cohort_days"</span>].astype(int)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pivot_table（）関数を使用して、目的のピボットテーブルを取得します。コホートは非常に多いため、結果を画面に完全に表示することはできません。これを回避するには、実際のケースを解決するときに、分析のための時間間隔を短くするか、コホート自体の値の範囲を拡大します。</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#  </span>
df_pivot_table = pd.pivot_table(df_final, values=[<span class="hljs-string">"amount"</span>], index=[<span class="hljs-string">"first_transaction"</span>], columns=[<span class="hljs-string">"cohort_days"</span>], aggfunc=np.sum, fill_value = <span class="hljs-number">0</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/e2/dn/u-/e2dnu-fry4n2hd4fl7_coqm_5mo.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Power BIでは、マトリックスツールを使用してそのような視覚化を構築する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sx/qh/gh/sxqhghd3km7lwdo-aycsry8xnn4.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の段階はプロットです。状況のニュアンスは、発生主義で金額が必要であるということです。 Power BIでは、必要な[クイックアクション]メニュー項目を選択するだけで、必要なDAX式が自動的に生成されます。 Pandasライブラリを使用すると、状況は少し複雑になります。既存のデータフレームをダブルシーケンスでグループ化し、cumsum（）関数を適用します。結果は引き続き使用されるため、データフレームのコピーを作成してグラフを作成します。累積売上値は非常に大きかったため、値を1,000,000で割り、結果を小数点以下2桁に丸めます。</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#     amount</span>
df_pivot_table_cumsum = df_final.groupby(by = [<span class="hljs-string">"first_transaction"</span>,<span class="hljs-string">"cohort_days"</span>]).agg({<span class="hljs-string">"amount"</span>: [<span class="hljs-string">"sum"</span>]}).groupby(level=<span class="hljs-number">0</span>).cumsum().reset_index()<font></font>
df_pivot_table_cumsum.columns = [<span class="hljs-string">"first_transaction"</span>,<span class="hljs-string">"cohort_days"</span>,<span class="hljs-string">"cumsum_amount"</span>]<font></font>
%%time<font></font>
<span class="hljs-comment">#     </span><font></font>
df_pivot_table_cumsum_chart = copy.deepcopy(df_pivot_table_cumsum)<font></font>
<span class="hljs-comment">#     ,       Y.</span>
df_pivot_table_cumsum_chart[<span class="hljs-string">"cumsum_amount"</span>]=round(df_pivot_table_cumsum_chart[<span class="hljs-string">"cumsum_amount"</span>]/<span class="hljs-number">1000000</span>, <span class="hljs-number">2</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライブラリの機能を使用してグラフを作成します。図は1行のコードで構築されていますが、その結果は印象的ではありません。このグラフは、BIプラットフォームでの視覚化に明らかに欠けています。 Plotlyライブラリを接続してアドオンで呼び出すことができますが、これはビデオで示されているアプローチと比較すると、完全に異なる人件費です。</font></font><br>
<br>
<pre><code class="python hljs">%%time<font></font>
df_pivot_table_cumsum_chart.pivot(index=<span class="hljs-string">"cohort_days"</span>, columns=<span class="hljs-string">"first_transaction"</span>, values=<span class="hljs-string">"cumsum_amount"</span>).plot(figsize = (<span class="hljs-number">15</span>,<span class="hljs-number">11</span>))</code></pre><br>
<img src="https://habrastorage.org/webt/ya/2f/sj/ya2fsjju2epd-vvcn96gms0i5rm.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単な結論を出しましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
計算に関しては、PandasライブラリがPower Pivot（DAX）に置き換わる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような交換の実現可能性は会話の外に残ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DAXは、Pythonライブラリ関数と同様に、テーブルのフィールド全体に対して操作を実行するのに適しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スピード、シンプルさ、視覚化デザインの容易さの点で、Power BIはPandasよりも優れています。</font><font style="vertical-align: inherit;">私の意見では、組み込みのグラフ（およびmatplotlib、seabornライブラリを使用して作成されたグラフ）は、外れ値、極小/極大、またはプレゼンテーション用のスライドの準備の2つのケースに適用するのに適しています。</font><font style="vertical-align: inherit;">グラフィカルコントロールパネルの開発は、BIソリューションに任せるのが最善です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで全部です。</font><font style="vertical-align: inherit;">すべての健康、幸運、そしてプロとしての成功！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja501480/index.html">Deno v1.0：JavaScriptおよびTypeScript用のセキュアなランタイム。機能の概要</a></li>
<li><a href="../ja501482/index.html">エイリアンケンタウロス</a></li>
<li><a href="../ja501484/index.html">プログラマーが決めなければならない</a></li>
<li><a href="../ja501488/index.html">ミドルからシニアへ</a></li>
<li><a href="../ja501490/index.html">Python 3.9の新機能</a></li>
<li><a href="../ja501494/index.html">魂のグラムではない：失敗した暗号通貨デュロフの物語</a></li>
<li><a href="../ja501496/index.html">コメットレイク、反復の完了</a></li>
<li><a href="../ja501498/index.html">RESTinioのeasy_parserを使用してAuthorization HTTPヘッダーを解析するために必要なC ++コードの量はどれくらいですか？</a></li>
<li><a href="../ja501500/index.html">視覚的ハッキング：脅威となるものとスパイから身を守る方法</a></li>
<li><a href="../ja501502/index.html">新しいラボのデジタル合成がHarris Bookを継続し、FPGAビデオゲームの作成を支援</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>