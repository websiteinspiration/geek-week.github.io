<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌪️ 👀 🧔🏽 長期短期記憶を備えたリカレントニューラルネットワークを使用した時系列の間隔予測... 🔃 🥤 👯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="時系列の予測に関する一連の記事の続き。議題には、「How to Develop Multi-Step LSTM Time Series Forecasting Models for Power Usage」の記事の翻訳があります。
 
 この作品は、提供される情報量の面で強いことに起因する可能性があ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>長期短期記憶を備えたリカレントニューラルネットワークを使用した時系列の間隔予測...</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505338/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時系列の予測に関する一連の記事の続き。</font><font style="vertical-align: inherit;">議題には、「</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to Develop Multi-Step LSTM Time Series Forecasting Models for Power Usage」</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の記事の翻訳があります</font><font style="vertical-align: inherit;">。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この作品は、提供される情報量の面で強いことに起因する可能性があります。さらに、その著者が警告するように、それは時系列と予測全般についてある程度の知識を持つデータ研究者向けに設計されています。ただし、特定の詳細の理解を容易にするために、この記事では関連する出版物へのリンクを提供します。私としては、F。ショールの著書「Deep Learning in Python」を読むことをお勧めします。この断片は、翻訳者のメモの形で翻訳されている記事のいくつかのポイントに同行しました。時間予測の簡単な紹介として、</font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">「リカレントニューラルネットワークを使用した時系列予測」</font></a></i><font style="vertical-align: inherit;">という刊行物をよく理解しておくことをお勧めします</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いわゆる1次元および多次元モデル、およびポイントとインターバルの予測とその実装についてのアイデアを持っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの作品に基づいて、翻訳された記事からいくつかを安全に作り直すか、むしろそれを自分自身に適応させ、時系列に関連する1つまたは別の問題を解決することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
翻訳には私のコメントが付いています。コメントは、いくつかの詳細をすばやく学習するのに役立ちます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c49/d94/0b2/c49d940b2df04a84e5bf6b308a5c41d0.jpg" alt="画像"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長期短期記憶を備えたリカレントニューラルネットワークを使用したインターバル時系列予測：電力消費予測</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2019年5月8日更新</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インテリジェントな電気メーターの使用の増加と、ソーラーパネルなどの生産のためのさまざまな技術の普及により、電力消費に関する多くのデータが表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのデータは、多次元の時系列として表すことができ、モデリングだけでなく、将来の電力消費量の予測にも使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他の機械学習アルゴリズムとは異なり、長期間の短期記憶を備えた再帰型ニューラルネットワーク</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（英語の用語ではLSTM。-約）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時系列から自動的に標識を検出し、多次元データを処理し、可変長の出力系列を出力できるため、間隔予測に使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このガイドでは、長期間の短期記憶を持つリカレントニューラルネットワークを準備する方法を学習します</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（以下、略称-DCTを使用します。-約）。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">住宅の電力消費の時系列の間隔予測を実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このガイドを完了すると、次のことがわかります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1次元と多次元の両方の入力データに基づく時系列の間隔予測のために、「エンコーダー-デコーダー」タイプのDCTを準備して評価する方法。</font></font></li>
<li>      «-»            .</li>
<li>       «-»     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DCTを使用して時系列の時系列予測を実行するための多次元入力データに基づいてモデルを準備する方法と</font><font style="vertical-align: inherit;">、25のステップバイステップのマニュアルと完全なソースコードを備えた</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい本で、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さらに多くのこと</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">を</font></a><font style="vertical-align: inherit;">学び</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
行こう！</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。一般に、このガイドは上級ユーザーを対象としています。Pythonでの時系列の予測に慣れ始めたばかりの場合は、まず</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらをご覧ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。時系列を使用してディープラーニングの方法を知っているだけの場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このページ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から始めて</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ください</font></a><font style="vertical-align: inherit;">。時系列でDCTを使い始めたい場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から始めて</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ください</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新（2019年6月）：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to_supervised（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数のバグを修正し</font><font style="vertical-align: inherit;">、データセットの最後の週のデータを破棄しました（Marcusに感謝）。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガイドレビュー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マニュアルは9つの部分で構成されています。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題の説明。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データセットをダウンロードして準備します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデル評価。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時系列の間隔予測のためのDCT。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1次元の入力データと出力ベクトルに基づくDCT。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1次元の入力データに基づく「エンコーダー-デコーダー」タイプのDCT。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多次元入力データに基づく「エンコーダー-デコーダー」タイプのDCT。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1次元の入力データに基づくエンコーダーとしてたたみ込み層を追加した、「エンコーダー-デコーダー」タイプのDCT。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1次元入力データに基づく「エンコーダー/デコーダー」タイプのたたみ込みDCT。</font></font></li>
</ol><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python環境オプション</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チュートリアルの例を完了するために、次のPythonライブラリがインストールされていることを前提としています：</font><font style="vertical-align: inherit;">低レベルのTensorFlowまたはTheanoライブラリを</font><font style="vertical-align: inherit;">備えたPythonバージョン3の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SciPy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keras</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニューラルネットワークライブラリ</font><font style="vertical-align: inherit;">（バージョン2.2以降）、および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scikit-Learn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pandas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NumPy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matplotlib</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python環境の設定についてサポートが必要な場合は、次の投稿をご覧ください。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機械学習とディープラーニング用のPython環境設定を構成する方法</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプルマニュアルを実行するためにグラフィックカードは必要ありません。</font><font style="vertical-align: inherit;">ただし、低価格でAmazon Web ServicesのGPUにアクセスできます。</font><font style="vertical-align: inherit;">次の出版物は、これを行う方法を説明しています。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Amazon AWS EC2 GPUをセットアップしてKeras深層学習モデルをトレーニングする方法</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで、私たちは没入に目を向けます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題の説明</font></font></h3><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「家計消費電力量」データセットは、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4年に1つの家族のディスプレイのエネルギー消費という多次元時系列です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このデータセットに関するより完全な情報は、次の資料に記載されています。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">家庭のエネルギー使用量データをダウンロードして調査する方法</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このデータは2006年12月から2010年11月まで収集されました。</font><font style="vertical-align: inherit;">電力消費量の測定は毎分行われました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
日付と時刻に加えて、データセットは7つの変数で構成されます。</font></font><br>
<br>
<ul>
<li><b>global_active_power</b>:   ,    (  ).</li>
<li><b>global_reactive_power</b>:   ,    (  ).</li>
<li><b>voltage</b>:   (  ).</li>
<li><b>global_intensity</b>:     (  ).</li>
<li><b>sub_metering_1</b>:      (  -  ).</li>
<li><b>sub_metering_2</b>:     (  -  ).</li>
<li><b>sub_metering_3</b>:     - (  -  ).</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有効電力量と無効電力量は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交流</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の技術的な詳細に関連しています</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（有効電力とは、実際にメーターに対して支払う消費電力です。-約）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><b><font style="vertical-align: inherit;">sub_metering</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
変数</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">、次のように、消費された合計エネルギーから</font><font style="vertical-align: inherit;">3つの定義された</font><b><font style="vertical-align: inherit;">sub_metering</font></b><font style="vertical-align: inherit;">変数の</font><font style="vertical-align: inherit;">合計を減算することによって作成でき</font><font style="vertical-align: inherit;">ます。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="python hljs">sub_metering_remainder = (global_active_power * <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>) - (sub_metering_1 + sub_metering_2 + sub_metering_3)
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データセットの読み込みと準備</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データセットは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UCI Machine Learning</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アーカイブから</font><font style="vertical-align: inherit;">20メガバイトの</font><font style="vertical-align: inherit;">圧縮</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.zip</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイルとして</font><font style="vertical-align: inherit;">ダウンロードできます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Household_power_consumption.zip</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データセットをダウンロードし、現在の作業ディレクトリに解凍します。</font><font style="vertical-align: inherit;">その後、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「household_power_consumption.txt」</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイル</font><font style="vertical-align: inherit;">が元の形式で表示されます。サイズは約127メガバイトです。</font><i><font style="vertical-align: inherit;">read_csv（）</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
関数を使用して</font><font style="vertical-align: inherit;">、データをロードし、最初の2つの列を日付と時刻を組み合わせた1つの列に結合し、それをインデックスとして使用できます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># load all data</span>
dataset = read_csv(<span class="hljs-string">'household_power_consumption.txt'</span>, sep=<span class="hljs-string">';'</span>, header=<span class="hljs-number">0</span>, low_memory=<span class="hljs-literal">False</span>, infer_datetime_format=<span class="hljs-literal">True</span>, parse_dates={<span class="hljs-string">'datetime'</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]}, index_col=[<span class="hljs-string">'datetime'</span>])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、</font><font style="vertical-align: inherit;">記号</font><i><font style="vertical-align: inherit;">「？」で</font></i><font style="vertical-align: inherit;">示された</font><font style="vertical-align: inherit;">すべての</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">欠損値を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">置き換えることができ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">浮動小数点数</font><font style="vertical-align: inherit;">である</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NaN</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の値によって</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、浮動小数点値の1つの連続した配列と同じようにデータを操作でき、さまざまな混合型（それほど効率的ではない）では操作できません。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># mark all missing values</span>
dataset.replace(<span class="hljs-string">'?'</span>, nan, inplace=<span class="hljs-literal">True</span>)
<span class="hljs-comment"># make dataset numeric</span>
dataset = dataset.astype(<span class="hljs-string">'float32'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、欠落している</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NaN</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値を入力します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単な解決策は、同じ時刻から、ただし前日に観測をコピーすることです。</font><font style="vertical-align: inherit;">これは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fill_missing（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">行うことができます。これ</font><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NumPy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ配列を取り</font><font style="vertical-align: inherit;">、コピーされた値を正確に24時間前に返します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># fill missing values with a value at the same time one day ago</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fill_missing</span>(<span class="hljs-params">values</span>):</span>
	one_day = <span class="hljs-number">60</span> * <span class="hljs-number">24</span>
	<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(values.shape[<span class="hljs-number">0</span>]):
		<span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> range(values.shape[<span class="hljs-number">1</span>]):
			<span class="hljs-keyword">if</span> isnan(values[row, col]):<font></font>
				values[row, col] = values[row - one_day, col]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DataFrame</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内のデータに直接適用できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># fill missing</span>
fill_missing(dataset.values)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、前のセクションの計算を使用して、残りの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブメータリング</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を含む新しい列を作成します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># add a column for for the remainder of sub metering</span><font></font>
values = dataset.values<font></font>
dataset[<span class="hljs-string">'sub_metering_4'</span>] = (values[:,<span class="hljs-number">0</span>] * <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>) - (values[:,<span class="hljs-number">4</span>] + values[:,<span class="hljs-number">5</span>] + values[:,<span class="hljs-number">6</span>])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、準備したバージョンのデータセットを別のファイルに保存します。これを行うには、ファイル拡張子を</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.csvに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更し、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「household_power_consumption.csv」</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として保存し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># save updated dataset</span>
dataset.to_csv(<span class="hljs-string">'household_power_consumption.csv'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データセットの読み込み、処理、保存の完全なコードを以下に示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># load and clean-up data</span>
<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> nan
<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> isnan
<span class="hljs-keyword">from</span> pandas <span class="hljs-keyword">import</span> read_csv
<span class="hljs-keyword">from</span> pandas <span class="hljs-keyword">import</span> to_numeric<font></font>
<font></font>
<span class="hljs-comment"># fill missing values with a value at the same time one day ago</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fill_missing</span>(<span class="hljs-params">values</span>):</span>
	one_day = <span class="hljs-number">60</span> * <span class="hljs-number">24</span>
	<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(values.shape[<span class="hljs-number">0</span>]):
		<span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> range(values.shape[<span class="hljs-number">1</span>]):
			<span class="hljs-keyword">if</span> isnan(values[row, col]):<font></font>
				values[row, col] = values[row - one_day, col]<font></font>
<font></font>
<span class="hljs-comment"># load all data</span>
dataset = read_csv(<span class="hljs-string">'household_power_consumption.txt'</span>, sep=<span class="hljs-string">';'</span>, header=<span class="hljs-number">0</span>, low_memory=<span class="hljs-literal">False</span>, infer_datetime_format=<span class="hljs-literal">True</span>, parse_dates={<span class="hljs-string">'datetime'</span>:[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]}, index_col=[<span class="hljs-string">'datetime'</span>])
<span class="hljs-comment"># mark all missing values</span>
dataset.replace(<span class="hljs-string">'?'</span>, nan, inplace=<span class="hljs-literal">True</span>)
<span class="hljs-comment"># make dataset numeric</span>
dataset = dataset.astype(<span class="hljs-string">'float32'</span>)
<span class="hljs-comment"># fill missing</span><font></font>
fill_missing(dataset.values)<font></font>
<span class="hljs-comment"># add a column for for the remainder of sub metering</span><font></font>
values = dataset.values<font></font>
dataset[<span class="hljs-string">'sub_metering_4'</span>] = (values[:,<span class="hljs-number">0</span>] * <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>) - (values[:,<span class="hljs-number">4</span>] + values[:,<span class="hljs-number">5</span>] + values[:,<span class="hljs-number">6</span>])
<span class="hljs-comment"># save updated dataset</span>
dataset.to_csv(<span class="hljs-string">'household_power_consumption.csv'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードが実行されると、新しい</font><font style="vertical-align: inherit;">プロジェクト</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「household_power_consumption.csv」が作成され</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、モデリングプロジェクトの開始点として使用します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデル評価</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションでは、家庭の電力消費量を予測するモデルを作成して評価する方法について説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションは4つの部分で構成されています。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題の定式化</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">評価指標</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データセットをトレーニング部分とテスト部分に分割する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロック検証検証</font></font></li>
</ol><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題の定式化</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マニュアルで説明されているデータセットは、さまざまな目的に使用できます。</font><font style="vertical-align: inherit;">私たちのケースでは、特定の質問に答えるためにそれを使用します。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在の消費レベルを考えると、今後1週間の電力消費はどのくらいになるでしょうか。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この質問に答えるには、次の7日間の毎日の総電力消費量を事前に予測するようにモデルをトレーニングする必要があります。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
総消費電力（インデックス0の特性）は、このマニュアルのすべての例のターゲットデータ（y）を生成するために使用されます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
技術的には、このタスク</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は時系列の間隔予測の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスクに関連してい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。この場合、入力が複数の属性を提供するモデルは、多次元入力データ（または多次元モデル）に基づくモデルと呼ばれます。間隔予測を実行するために使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このタイプのモデルは、家庭の電力消費のコストを計画するのに役立ちます。また、このモデルは、特定の家や家族の電力需要を最適化するという点でも実用的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクが与えられた場合、電力消費量の分単位の測定から毎日の値にサンプルを削減することが有用であると想定されます。これは必須のステップには適用されませんが、毎日の電力消費に関心がある場合、これは理にかなっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは</font><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">DataFrameに</font></i><font style="vertical-align: inherit;">適用された</font><i><font style="vertical-align: inherit;">pandas </font></i></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resample（）</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数で実現でき</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">引数 "D"を指定してこの関数を使用すると、ダウンロードしたデータを日付と時刻でインデックス化して日ごとにグループ化できます。</font><font style="vertical-align: inherit;">次に、8つの変数のそれぞれについて、毎日のすべての観測値の合計を計算し、毎日のエネルギー消費量を含む新しいデータセットを作成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全なデータ処理コードを以下に示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># resample minute data to total for each day</span>
<span class="hljs-keyword">from</span> pandas <span class="hljs-keyword">import</span> read_csv
<span class="hljs-comment"># load the new file</span>
dataset = read_csv(<span class="hljs-string">'household_power_consumption.csv'</span>, header=<span class="hljs-number">0</span>, infer_datetime_format=<span class="hljs-literal">True</span>, parse_dates=[<span class="hljs-string">'datetime'</span>], index_col=[<span class="hljs-string">'datetime'</span>])
<span class="hljs-comment"># resample data to daily</span>
daily_groups = dataset.resample(<span class="hljs-string">'D'</span>)<font></font>
daily_data = daily_groups.sum()<font></font>
<span class="hljs-comment"># summarize</span><font></font>
print(daily_data.shape)<font></font>
print(daily_data.head())<font></font>
<span class="hljs-comment"># save</span>
daily_data.to_csv(<span class="hljs-string">'household_power_consumption_days.csv'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行すると、毎日のエネルギー消費量を含む新しいデータセットが作成され、別のファイル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「household_power_consumption_days.csv」に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存されます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作成したデータセットを使用して、予後モデルの選択と評価を伴うタスクを実行します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">評価指標</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
予測は、7つの値で構成されます-来週の各曜日に1つ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原則として、間隔予測を実行する場合、各予測時間ステップは個別に推定されます。</font><font style="vertical-align: inherit;">これはいくつかの理由で役立ちます：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各タイムステップのレベルをマークするには（たとえば、「+ 1」日と「+3」日）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまなタイムステップを持つモデルの品質を比較するには（たとえば、「+ 1日目」の予測の推定値が高いモデルと「+5日目」の予測の推定値が高いモデル）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
総電力の単位はキロワットなので、同じ単位（同じスケール）でエラーメトリックを設定すると便利です。同時に、二乗平均平方根誤差（RMSE）の平方根と平均絶対誤差（MAE）の両方がこのスケールに対応しますが、このメトリックはより頻繁に使用されるため、手動では二乗平均平方根誤差の平方根が使用されます。さらに、平均絶対誤差とは異なり、予測誤差の場合はモデルの精度が高くなります。したがって、このガイドで検討中の問題のメトリックは、各予測タイムステップ（1日目から7日目）に対して計算されたRMSEになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルの結果を考慮に入れて、予測されるすべての日の結果のスコアとして同じメトリックが使用されます。</font><font style="vertical-align: inherit;">これは、最適なモデルを選択するのに役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に示す</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">evaluate_forecasts（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数は</font><font style="vertical-align: inherit;">、上記のソリューションを実装します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># evaluate one or more weekly forecasts against expected values</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate_forecasts</span>(<span class="hljs-params">actual, predicted</span>):</span><font></font>
	scores = list()<font></font>
	<span class="hljs-comment"># calculate an RMSE score for each day</span>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">1</span>]):
		<span class="hljs-comment"># calculate mse</span><font></font>
		mse = mean_squared_error(actual[:, i], predicted[:, i])<font></font>
		<span class="hljs-comment"># calculate rmse</span><font></font>
		rmse = sqrt(mse)<font></font>
		<span class="hljs-comment"># store</span><font></font>
		scores.append(rmse)<font></font>
	<span class="hljs-comment"># calculate overall RMSE</span>
	s = <span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">0</span>]):
		<span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">1</span>]):<font></font>
			s += (actual[row, col] - predicted[row, col])**<span class="hljs-number">2</span>
	score = sqrt(s / (actual.shape[<span class="hljs-number">0</span>] * actual.shape[<span class="hljs-number">1</span>]))
	<span class="hljs-keyword">return</span> score, scores</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数が実行されると、最初に予測全体の合計RMSE値が返され、次に各日のRMSE値の配列が返されます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データセットをトレーニング部分とテスト部分に分割する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルのトレーニング（昨年）に使用する最初の3年間のデータ-検証（検証）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データは、日曜日に始まり土曜日に終わる標準的な週に分割されます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：米国、イギリス、およびその他の国では、週は日曜日に始まります。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これは、エネルギー消費量を1週間前に予測するという考慮された問題のデータを準備するための現実的で有用な方法です。これは、モデルを使用して特定の日（水曜日など）またはシーケンス全体を予測するという点でも実用的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、データセットの検証部分とは逆の方向に分離が行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その最後の年は2010年で、その最初の日曜日は1月3日でした。</font><font style="vertical-align: inherit;">データは2010年11月中旬に終了し、最も近い最終土曜日は11月20日でした。</font><font style="vertical-align: inherit;">これを念頭に置いて、46週間の検証が許可されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確認のために、データセットの検証部分の日次データの最初と最後の行を以下に示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-number">2010</span><span class="hljs-number">-01</span><span class="hljs-number">-03</span>,<span class="hljs-number">2083.4539999999984</span>,<span class="hljs-number">191.61000000000055</span>,<span class="hljs-number">350992.12000000034</span>,<span class="hljs-number">8703.600000000033</span>,<span class="hljs-number">3842.0</span>,<span class="hljs-number">4920.0</span>,<span class="hljs-number">10074.0</span>,<span class="hljs-number">15888.233355799992</span><font></font>
...<font></font>
<span class="hljs-number">2010</span><span class="hljs-number">-11</span><span class="hljs-number">-20</span>,<span class="hljs-number">2197.006000000004</span>,<span class="hljs-number">153.76800000000028</span>,<span class="hljs-number">346475.9999999998</span>,<span class="hljs-number">9320.20000000002</span>,<span class="hljs-number">4367.0</span>,<span class="hljs-number">2947.0</span>,<span class="hljs-number">11433.0</span>,<span class="hljs-number">17869.76663959999</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データセットのトレーニング部分は、以下に従って形成されます。</font><font style="vertical-align: inherit;">測定は2006年末に開始されます。</font><font style="vertical-align: inherit;">最初の日曜日は12月17日で、これは2行目のデータに対応します。</font><font style="vertical-align: inherit;">これを念頭に置いて、標準的な週のデータ編成では、モデルのトレーニングに完全な159週間を提供します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-number">2006</span><span class="hljs-number">-12</span><span class="hljs-number">-17</span>,<span class="hljs-number">3390.46</span>,<span class="hljs-number">226.0059999999994</span>,<span class="hljs-number">345725.32000000024</span>,<span class="hljs-number">14398.59999999998</span>,<span class="hljs-number">2033.0</span>,<span class="hljs-number">4187.0</span>,<span class="hljs-number">13341.0</span>,<span class="hljs-number">36946.66673200004</span><font></font>
...<font></font>
<span class="hljs-number">2010</span><span class="hljs-number">-01</span><span class="hljs-number">-02</span>,<span class="hljs-number">1309.2679999999998</span>,<span class="hljs-number">199.54600000000016</span>,<span class="hljs-number">352332.8399999997</span>,<span class="hljs-number">5489.7999999999865</span>,<span class="hljs-number">801.0</span>,<span class="hljs-number">298.0</span>,<span class="hljs-number">6425.0</span>,<span class="hljs-number">14297.133406600002</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">split_dataset（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">は、日次データをトレーニング部分と検証部分に</font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">分割</font></a></i><font style="vertical-align: inherit;">し、</font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">split（）</font></a></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NumPy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">を使用して週次データに編成し</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a></i><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># split a univariate dataset into train/test sets</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">split_dataset</span>(<span class="hljs-params">data</span>):</span>
	<span class="hljs-comment"># split into standard weeks</span>
	train, test = data[<span class="hljs-number">1</span>:<span class="hljs-number">-328</span>], data[<span class="hljs-number">-328</span>:<span class="hljs-number">-6</span>]
	<span class="hljs-comment"># restructure into windows of weekly data</span>
	train = array(split(train, len(train)/<span class="hljs-number">7</span>))<font></font>
	test = array(split(test, len(test)/<span class="hljs-number">7</span>))
	<span class="hljs-keyword">return</span> train, test</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
毎日のデータセットをダウンロードし、トレーニングと検証データの最初と最後の行を印刷して上記の関数をテストし、計算が一貫していることを確認します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データを分割するための完全なコードを以下に示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># split into standard weeks</span>
<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> split
<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> array
<span class="hljs-keyword">from</span> pandas <span class="hljs-keyword">import</span> read_csv<font></font>
<font></font>
<span class="hljs-comment"># split a univariate dataset into train/test sets</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">split_dataset</span>(<span class="hljs-params">data</span>):</span>
	<span class="hljs-comment"># split into standard weeks</span>
	train, test = data[<span class="hljs-number">1</span>:<span class="hljs-number">-328</span>], data[<span class="hljs-number">-328</span>:<span class="hljs-number">-6</span>]
	<span class="hljs-comment"># restructure into windows of weekly data</span>
	train = array(split(train, len(train)/<span class="hljs-number">7</span>))<font></font>
	test = array(split(test, len(test)/<span class="hljs-number">7</span>))
	<span class="hljs-keyword">return</span> train, test<font></font>
<font></font>
<span class="hljs-comment"># load the new file</span>
dataset = read_csv(<span class="hljs-string">'household_power_consumption_days.csv'</span>, header=<span class="hljs-number">0</span>, infer_datetime_format=<span class="hljs-literal">True</span>, parse_dates=[<span class="hljs-string">'datetime'</span>], index_col=[<span class="hljs-string">'datetime'</span>])<font></font>
train, test = split_dataset(dataset.values)<font></font>
<span class="hljs-comment"># validate train data</span><font></font>
print(train.shape)<font></font>
print(train[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], train[<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>])
<span class="hljs-comment"># validate test</span><font></font>
print(test.shape)<font></font>
print(test[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], test[<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その実装は、トレーニング部分には15​​9週間のデータが含まれているのに対し、検証部分には46週間あることを示しています。</font><font style="vertical-align: inherit;">同時に、両方の部分の最初と最後の行は、標準の週を考慮して、境界として定義した行に対応しています。</font></font><br>
<br>
<pre><code class="python hljs">(<span class="hljs-number">159</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>)
<span class="hljs-number">3390.46</span> <span class="hljs-number">1309.2679999999998</span>
(<span class="hljs-number">46</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>)
<span class="hljs-number">2083.4539999999984</span> <span class="hljs-number">2197.006000000004</span></code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロック検証検証</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルは、</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウォークフォワード検証</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれるスキームを使用して評価され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シミュレーションの目的は、先週の電力消費を予測することなので、モデルの入力に提供される実際の週次データは、将来の週次値を予測するための基礎として使用できます。このアプローチは、実際に広く使用されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のアプローチの原理を以下に示します。</font></font><br>
<br>
<pre><code class="python hljs"> 				 <font></font>
[<span class="hljs-number">1</span>]                        <span class="hljs-number">2</span>
[<span class="hljs-number">1</span> + <span class="hljs-number">2</span>]              <span class="hljs-number">3</span>
[<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span>]    <span class="hljs-number">4</span>
...</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デモンストレーションアプローチへの小さな追加。データセットは2つの部分に分かれているため、ブロックサイズの増加による検証を考慮に入れると、データの検証部分（160週目）から最初の週を予測するための実際のデータは、最初の159週になります。データのトレーニング部分全体。次に、データの妥当性確認部（161番目の週）の第2週を予測するために、実際のデータ159、訓練週間プラスデータの検証部分（160週）、等：から前の週になり</font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/919/2e5/108/9192e5108ad9351556769ae7059545ea.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
、機能のコード</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">evaluate_model（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、この中に問題のデータセットに基づいてモデルを評価する方法を以下に示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数の引数は、毎週のデータ形式でデータセットのトレーニングと検証の部品だけでなく、追加の引数のある</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n_input</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルが入力として使用することを以前の観察の数を決定する、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のうち- （注ごと。。n_inputパラメータは最高の物語のように表される）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たびに、予測の間隔。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、この関数では2つの新しいサブ関数が呼び出されます。</font><font style="vertical-align: inherit;">トレーニングデータでモデルを作成してトレーニングするために使用される</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">build_model（）と</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">新しい週次データが到着したときに予測を行うために使用される</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予測（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。これらの機能については、次のセクションで説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このガイドでは、人工ニューラルネットワークを使用します。一人で彼らは通常勉強するのに長い時間がかかりますが、彼らはすぐに評価を与えます。この点で、モデルの推奨される使用法は、履歴データに基づいてモデルを構築してトレーニングし、ブロックサイズが増加する各検証ステップを予測することです。モデルは静的です。つまり、モデルは評価中に更新されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、新しいデータが到着したときにブロックサイズを増やして、各検証ステップでモデルを再装備または更新できる場合に、より速く学習する他のモデルとの違いです。</font><font style="vertical-align: inherit;">十分なリソースが利用可能な場合は、人工ニューラルネットワークも同じように使用できますが、このガイドではこれについては扱いません。</font><i><font style="vertical-align: inherit;">evaluate_model（）</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
関数の完全なコードを</font><font style="vertical-align: inherit;">以下に示します。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># evaluate a single model</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate_model</span>(<span class="hljs-params">train, test, n_input</span>):</span>
	<span class="hljs-comment"># fit model</span><font></font>
	model = build_model(train, n_input)<font></font>
	<span class="hljs-comment"># history is a list of weekly data</span>
	history = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> train]
	<span class="hljs-comment"># walk-forward validation over each week</span><font></font>
	predictions = list()<font></font>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(test)):
		<span class="hljs-comment"># predict the week</span><font></font>
		yhat_sequence = forecast(model, history, n_input)<font></font>
		<span class="hljs-comment"># store the predictions</span><font></font>
		predictions.append(yhat_sequence)<font></font>
		<span class="hljs-comment"># get real observation and add to history for predicting the next week</span><font></font>
		history.append(test[i, :])<font></font>
	<span class="hljs-comment"># evaluate predictions days for each week</span><font></font>
	predictions = array(predictions)<font></font>
	score, scores = evaluate_forecasts(test[:, :, <span class="hljs-number">0</span>], predictions)
	<span class="hljs-keyword">return</span> score, scores</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルが評価されたら、その実装の結果を表示できます。</font><i><font style="vertical-align: inherit;">summarize_scores（）</font></i><font style="vertical-align: inherit;">関数は、他のモデルとの単純かつ直観的な比較のための値を持つ文字列としてモデルの有効性を表示します。</font></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># summarize scores</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">summarize_scores</span>(<span class="hljs-params">name, score, scores</span>):</span>
	s_scores = <span class="hljs-string">', '</span>.join([<span class="hljs-string">'%.1f'</span> % s <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> scores])<font></font>
	print(<span class="hljs-string">'%s: [%.3f] %s'</span> % (name, score, s_scores))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、問題のデータセットのモデルの評価を開始するためのすべての要素が揃いました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターバル時系列予測のDCT</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リカレントニューラルネットワーク（RNS）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（英語の用語では、リカレントニューラルネットワーク、RNN-約）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シーケンスの形式でデータを処理するように設計されています。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時系列またはシーケンスは</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
、[サンプル、タイムスタンプ、記号] </font><font style="vertical-align: inherit;">という形式の3次元テンソル</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
です。出典：Pythonのディープラーニング、Francois Scholl。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RNSは、1つのタイムスロットの出力が次のタイムスロットの入力として提供される一種の人工ニューラルネットワークです。</font><font style="vertical-align: inherit;">この状況により、RNSは、現在の時間間隔の入力データと前のステップの出力の両方に基づいて、予測オブジェクトに関する決定を行うことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、最も成功しているためにRNSで大量に使用されるタイプ（アーキテクチャ）は、「長期短期記憶」です。これは、このタイプが従来のRNS *に固有の困難を克服するためです。 DCTには、前の時間間隔の出力と現在の時間間隔の入力との間の接続を確立する機能に加えて、ローカル変数として機能する内部メモリがあり、DCTが入力シーケンスで状態を蓄積できるようにします。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
*これは、勾配の減衰の問題を指します。「多数のレイヤーを持つ非リカレントネットワーク（直接配信ネットワーク）で観察される効果に似ています。レイヤーの数が増えると、ネットワークは最終的にトレーニングされなくなります...これを解決するためにLSTMおよびGRUレイヤーが特別に作成されました問題」。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出典：Pythonのディープラーニング、Francois Scholl。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RNSの詳細については、次の資料を参照してください。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リカレントニューラルネットワークによるディープラーニング：クラッシュコース</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DCTの詳細については、次の資料を参照してください。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長期短期記憶を備えた再帰型ニューラルネットワークの概要：専門家による円卓会議</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時系列の間隔予測では、DCTには他の方法よりも多くの利点があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネイティブシーケンスのサポート。</font><font style="vertical-align: inherit;">DCTは、入力データとしてシーケンスを使用するように設計されたRNSの一種であり、遅延</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他の</font><i><font style="vertical-align: inherit;">時間で取得された-約Per。）</font></i><font style="vertical-align: inherit;">データが入力フィーチャとして提示される</font><font style="vertical-align: inherit;">他のモデルと区別</font><font style="vertical-align: inherit;">されます。</font></font></li>
<li> .            ,      ,          (2) .</li>
<li> .      ,         ,       .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シーケンス間</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予測</font><i><font style="vertical-align: inherit;">（英語では、シーケンス間用語、または略してseq2seqと呼ばれます-注：</font></i><font style="vertical-align: inherit;">と呼ばれ</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">）と呼ばれる、インターバルシーケンス予測用の特別なRNCアーキテクチャが開発されました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアーキテクチャの例は、DCTタイプの「エンコーダー-デコーダー」です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「エンコーダーデコーダー」タイプのDCTは、2つのサブモデルで構成されるモデルです。入力シーケンスを読み取り、固定長の内部表現に圧縮するエンコーダーと、内部表現を解釈して出力シーケンスを予測するデコーダーです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シーケンスを予測するこのアプローチは、直接ベクトル出力よりもはるかに効果的であることを示しており、シーケンスの形式でデータを予測するための好ましいアプローチとなっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、次の時間間隔の予測が前の時間間隔の関数である場合、DCTは自己回帰などの問題にはそれほど効果的ではないことがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題の詳細については、次の資料を参照してください。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時系列を予測するためのDCTの適合性について</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1次元の畳み込みニューラルネットワーク（SNA）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（英語の畳み込みニューラルネットワークの用語では、CNN。-約）。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入力シーケンスからの特徴の自動学習における有効性が証明されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最もよく知られているアプローチは、SNAをDCTと組み合わせて共通のモデルにすることです。このモデルでは、SNAはエンコーダーとして機能し、DCTによって送信される入力シリアルデータの特性を時間間隔として調査します。</font><font style="vertical-align: inherit;">このアーキテクチャは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「SNS-DKP」</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれます</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（英語の用語ではCNN-LSTM。-約）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアーキテクチャの詳細については、次の資料を参照してください。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長期短期記憶を備えた畳み込みニューラルネットワーク</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SNS-DKPアーキテクチャでの電力レベルの変更は、</font><font style="vertical-align: inherit;">DCTセルの入力シーケンスの畳み込み読み取りを使用</font><font style="vertical-align: inherit;">する畳み込みDCT </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（英語の用語Convolutional LSTM、または略してConvLSTM）で表され</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">このアプローチは時系列の分類に非常に効果的であることが証明されており、間隔予測を実行するように適合させることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このガイドでは、時系列の時系列予測を実行するための一連の異なるDCTアーキテクチャについて説明します。</font><font style="vertical-align: inherit;">特に、次のモデルの実行方法を検討します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベクトル出力を伴う1次元入力に基づくDCTモデル</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1次元入力データに基づく「エンコーダー-デコーダー」タイプのDCTモデル</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多次元入力データに基づく「エンコーダー-デコーダー」タイプのDCTモデル</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1次元入力データに基づくエンコーダーとしてたたみ込み層を追加した、「エンコーダー-デコーダー」タイプのDCTモデル</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1次元入力データに基づく「エンコーダーデコーダー」タイプのDCTの畳み込みモデル</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時系列予測にDCTを初めて使用する場合は、次の出版物を強くお勧めします。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時系列予測用のDCTモデルを開発する方法</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルは、家庭のエネルギー消費量を予測する問題を解決する例を使用して開発され、実証されます。定格が単純な（簡略化された）モデルよりも優れている場合、モデルは適合と見なされます。その平均値は、RMSEメトリックを考慮して、465キロワット（週の合計定格）です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらの有効性を改善するために、最適なモデルパラメーターの選択に焦点を合わせません。代わりに、単純な予測よりも予測が優れているモデルを紹介します。例に示されているANS構成とハイパーパラメータの選択は、試行錯誤によって説明されています。したがって、最終的な推定値は、例としてのみ考慮すべきであり、検討中の問題のモデルの最適なパラメーターと構成の研究として考えるべきではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルの確率的性質を考えると、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n回</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">評価して</font></a><font style="vertical-align: inherit;">から</font><font style="vertical-align: inherit;">平均パフォーマンス推定値を導き出す</font><font style="vertical-align: inherit;">ことが最も効果的</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">ただし、代わりに、コードの単純さを維持するために、単一値モデルの結果を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与えられたインターバル予測のタスクに対して、どのアプローチが最も効果的であるかはわかりません。</font><font style="vertical-align: inherit;">データセットに最適な方法を見つけるために、一連のさまざまな方法を検討することをお勧めします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1次元の入力データと出力ベクトルに基づくDCT</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、DCTの単純な（またはバニラ）モデルを実装することから始めます。これは、毎週の総エネルギー消費量を毎日のシーケンスに変換し、次の週のエネルギー消費量を出力ベクトルの形式で予測します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この始まりは、より複雑なモデルの実装の基礎として機能します。これは、以降のセクションで開発および説明されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入力として使用される前の日数は、特徴を調査および識別するためにDCT入力に供給されるデータの1次元シーケンスを決定します。</font><font style="vertical-align: inherit;">以下は、それらの可能なサイズと性質に関するいくつかのアイデアです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数年前のすべての日。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">過去7日間（1週間）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">過去2週間。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前月。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">昨年。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前週と先週。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのサイズを使用するかという質問に対する単一の答えはありません。</font><font style="vertical-align: inherit;">最善の解決策は、それぞれを他のアプローチと一緒にテストし、実装の結果に応じて、最良の結果を示したものを選択することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、選択は次の要因による必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルのトレーニングのために、データのトレーニング部分をどのように準備すべきか。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">評価のためにデータの検証部分を準備する方法。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成したモデルを使用して将来の予測を行う方法。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の7日間を使用することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DCTモデルでは、入力データが次の</font><font style="vertical-align: inherit;">形式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（3次元-約）である</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と想定しています</font><i><font style="vertical-align: inherit;">。</font></i></font><br>
<br>
<pre><code class="python hljs">[,  , ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1日の電力消費が7日間の場合、各サンプルには時間間隔があり、その持続時間は7であり、1つの属性があります。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：この</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間間隔は「履歴」（パラメーターn_input）であり、次の例では過去7日間のものです。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
データのトレーニング部分は159週間含まれているため、その形式は次のようになります。</font></font><br>
<br>
<pre><code class="python hljs">[<span class="hljs-number">159</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このデータ形式では、モデルは前週を使用して次週を予測します。問題は、159個のサンプルがモデルをトレーニングするための非常に少量のデータであることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より多くのデータを作成する1つの方法は、週に関係なく、前のものを考慮に入れて、今後7日間の電力消費量を予測することでアプローチを変更することです</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（この状況では、トレーニングおよび検証データの最初の変換を無意味な週形式に変換します。-約。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この変更はデータのトレーニング部分にのみ適用され、検証部分の目的は変更されていません。前週のデータを考慮して、次週の毎日のエネルギー消費量を予測します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これには、トレーニングデータの準備に若干の調整が必要になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、8つの属性に基づくトレーニングデータが週次データに変換されます。この点に関して、それらの形式は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[159、7、8]の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形式になります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次のステップは、データを平滑化することです。</font><font style="vertical-align: inherit;">これは、8つの時系列を取得するために行われます</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（実際には、データ形式の3Dから2Dへの逆変換が実行されます（上記の注を参照してください）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># flatten data</span>
data = train.reshape((train.shape[<span class="hljs-number">0</span>]*train.shape[<span class="hljs-number">1</span>], train.shape[<span class="hljs-number">2</span>]))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、設定された時間間隔を考慮して、データがいわゆるオーバーラップウィンドウに分割されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例えば：</font></font><br>
<br>
<pre><code class="python hljs">, <font></font>
[d01, d02, d03, d04, d05, d06, d07], [d08, d09, d10, d11, d12, d13, d14]<font></font>
[d02, d03, d04, d05, d06, d07, d08], [d09, d10, d11, d12, d13, d14, d15]<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、設定された時間間隔を考慮して、平滑化されたデータの全長にわたって反復するときに、入力と出力の開始インデックスと終了インデックスを追跡することで実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、入力と出力の数（</font><font style="vertical-align: inherit;">それぞれ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n_input</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n_out</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）が割り当てられ、以下で検討する関数の引数として表示されます。これは、自分のタスクに適用されるさまざまな意味を実験できるようにするために行われます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
n_input引数は、すでに述べたように、履歴、つまり過去の時間間隔でモデルが「リーン」して予測を実現します（n_out）。n_outは、モデルが将来予測を学習する距離を決定する引数です（予測の期間を設定します）時間間隔）。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
以下は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to_supervised（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれる関数で</font><font style="vertical-align: inherit;">、トレーニングデータ、履歴（モデルが入力として使用する以前の観測値の数）、および予測された時間間隔の期間を受け取り、重なり合うスライディングウィンドウの形式で配列を返します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># convert history into inputs and outputs</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_supervised</span>(<span class="hljs-params">train, n_input, n_out=<span class="hljs-number">7</span></span>):</span>
	<span class="hljs-comment"># flatten data</span>
	data = train.reshape((train.shape[<span class="hljs-number">0</span>]*train.shape[<span class="hljs-number">1</span>], train.shape[<span class="hljs-number">2</span>]))<font></font>
	X, y = list(), list()<font></font>
	in_start = <span class="hljs-number">0</span>
	<span class="hljs-comment"># step over the entire history one time step at a time</span>
	<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(len(data)):
		<span class="hljs-comment"># define the end of the input sequence</span><font></font>
		in_end = in_start + n_input<font></font>
		out_end = in_end + n_out<font></font>
		<span class="hljs-comment"># ensure we have enough data for this instance</span>
		<span class="hljs-keyword">if</span> out_end &lt;= len(data):<font></font>
			x_input = data[in_start:in_end, <span class="hljs-number">0</span>]<font></font>
			x_input = x_input.reshape((len(x_input), <span class="hljs-number">1</span>))<font></font>
			X.append(x_input)<font></font>
			y.append(data[in_end:out_end, <span class="hljs-number">0</span>])
		<span class="hljs-comment"># move along one time step</span>
		in_start += <span class="hljs-number">1</span>
	<span class="hljs-keyword">return</span> array(X), array(y)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数を実行すると、159サンプルが1100に変換されます。この点で、変換されたデータの形式は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X = [1100、7、1]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y = [1100、7 </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">]の</font></i><font style="vertical-align: inherit;">形式になります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、モデルの構成が決定され、そのトレーニングが実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、時系列の間隔予測のこの問題は、自動回帰を指します。これは、次の7日間が以前の観測値の関数であるときに、良い結果が得られることを意味します。この状況は、比較的少量のデータとともに、「小規模」で構成が単純なモデルの使用を決定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを念頭に置いて、複数のレイヤーを持つモデルを構築します。最初の隠れ層の役割は、200ニューロンを持つDCT層です（隠れ層のニューロン数は、入力シーケンスの時間間隔の長さに関係ありません）。 DCTの層の後には、200個のニューロンを持つ完全に接続された層が続きます。その目的は、DCT層によって識別された兆候を解釈することです。最後に、出力層は7つの予測要素を含むベクトルを直接出力します-出力シーケンスの各日に1つ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
二乗平均平方根誤差（MSE）は、以前に受け入れられたメトリック（二乗平均平方根誤差のルート、RMSE）のスケールに対応するため、損失関数として受け入れられます。オプティマイザとして採用された</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><i><font style="vertical-align: inherit;">Adam</font></i></a><font style="vertical-align: inherit;">アルゴリズム</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><i><font style="vertical-align: inherit;"></font></i> </a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（確率的勾配降下のバリアント）、モデルのトレーニングは70エポック続き、パッケージサイズは16サンプルで構成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パケットサイズが小さく、アルゴリズムの確率的性質により、同じモデルが繰り返しトレーニング中に入力データと出力データを異なる方法で表示します。これにより、モデルを評価した後、モデルの結果が互いに異なる場合があります。モデルを数回トレーニングして、平均値を最終結果の計算に使用することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">build_model（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">は、データのトレーニング部分を準備し、モデルの構成を決定し、そのトレーニングを実行し、トレーニングされたモデルを返します。これを使用して、予測を行うことができます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># train the model</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_model</span>(<span class="hljs-params">train, n_input</span>):</span>
	<span class="hljs-comment"># prepare data</span><font></font>
	train_x, train_y = to_supervised(train, n_input)<font></font>
	<span class="hljs-comment"># define parameters</span>
	verbose, epochs, batch_size = <span class="hljs-number">0</span>, <span class="hljs-number">70</span>, <span class="hljs-number">16</span>
	n_timesteps, n_features, n_outputs = train_x.shape[<span class="hljs-number">1</span>], train_x.shape[<span class="hljs-number">2</span>], train_y.shape[<span class="hljs-number">1</span>]
	<span class="hljs-comment"># define model</span><font></font>
	model = Sequential()<font></font>
	model.add(LSTM(<span class="hljs-number">200</span>, activation=<span class="hljs-string">'relu'</span>, input_shape=(n_timesteps, n_features)))<font></font>
	model.add(Dense(<span class="hljs-number">100</span>, activation=<span class="hljs-string">'relu'</span>))<font></font>
	model.add(Dense(n_outputs))<font></font>
	model.compile(loss=<span class="hljs-string">'mse'</span>, optimizer=<span class="hljs-string">'adam'</span>)
	<span class="hljs-comment"># fit network</span><font></font>
	model.fit(train_x, train_y, epochs=epochs, batch_size=batch_size, verbose=verbose)<font></font>
	<span class="hljs-keyword">return</span> model</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルがトレーニングされたので、予測の実行方法を確認できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、モデルはデータが同じ3次元形状を持つことを期待します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの場合、毎日の電力消費を考慮に入れた入力サンプルの予想される形式は次のとおりです：「1つのサンプル-7日の時間間隔-1つの符号」：</font></font><br>
<br>
<pre><code class="python hljs">[<span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このフォームには、データセットの検証部分のデータだけでなく、トレーニング済みモデルが将来の予測に使用する「新しい」入力データも含める必要があります。 n入力パラメーターが14日間変更されると、時間間隔の期間も14日間になるため、トレーニングデータの形式と予測の新しいサンプルをそれに応じて変更する必要があります。同時に、時間間隔の期間は最初に処理する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このガイドでは、前のセクションで説明した増分ブロックサイズ検証を使用します。行われた決定に従って、来週のエネルギー消費予測は前週の観察に基づいています。過去の週は</font><i><font style="vertical-align: inherit;">履歴</font></i><font style="vertical-align: inherit;">と呼ばれる配列に収集され</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の週を予測するには、最後の観測日を返す必要があります。</font><font style="vertical-align: inherit;">トレーニングデータと同様に、8つの並列時系列を取得するには、まず週次構造を削除して履歴データを平滑化する必要があります。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># flatten data</span>
data = data.reshape((data.shape[<span class="hljs-number">0</span>]*data.shape[<span class="hljs-number">1</span>], data.shape[<span class="hljs-number">2</span>]))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に</font><font style="vertical-align: inherit;">、過去7日間</font><font style="vertical-align: inherit;">の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">総電力消費量</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（インデックス0の特性）</font><font style="vertical-align: inherit;">の毎日の値を取得する必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トレーニングデータの準備の場合と同様に、前に選択したn_inputパラメーターを使用して、モデルの入力として使用される前の日数を将来変更できるようにします。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># retrieve last observations for input data</span>
input_x = data[-n_input:, <span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、入力データフォームを、モデルが想定する3次元構造に変更します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># reshape into [1, n_input, 1]</span>
input_x = input_x.reshape((<span class="hljs-number">1</span>, len(input_x), <span class="hljs-number">1</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、トレーニングされたモデルと入力データに基づいて、7日間からなる出力ベクトルを抽出して予測が行われます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># forecast the next week</span>
yhat = model.predict(input_x, verbose=<span class="hljs-number">0</span>)
<span class="hljs-comment"># we only want the vector forecast</span>
yhat = yhat[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下に示す</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予測（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数は</font><font style="vertical-align: inherit;">、トレーニング済みモデルを引数として、これまでに観測された前週のデータのリスト（</font><font style="vertical-align: inherit;">ブロックサイズの増加に伴う検証結果から生成された</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">履歴</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメーター</font><font style="vertical-align: inherit;">）と時間間隔</font><font style="vertical-align: inherit;">を使用して、上記のソリューションを実装し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># make a forecast</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forecast</span>(<span class="hljs-params">model, history, n_input</span>):</span>
	<span class="hljs-comment"># flatten data</span><font></font>
	data = array(history)<font></font>
	data = data.reshape((data.shape[<span class="hljs-number">0</span>]*data.shape[<span class="hljs-number">1</span>], data.shape[<span class="hljs-number">2</span>]))
	<span class="hljs-comment"># retrieve last observations for input data</span>
	input_x = data[-n_input:, <span class="hljs-number">0</span>]
	<span class="hljs-comment"># reshape into [1, n_input, 1]</span>
	input_x = input_x.reshape((<span class="hljs-number">1</span>, len(input_x), <span class="hljs-number">1</span>))
	<span class="hljs-comment"># forecast the next week</span>
	yhat = model.predict(input_x, verbose=<span class="hljs-number">0</span>)
	<span class="hljs-comment"># we only want the vector forecast</span>
	yhat = yhat[<span class="hljs-number">0</span>]
	<span class="hljs-keyword">return</span> yhat</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで全部です。</font><font style="vertical-align: inherit;">これで、毎日の総電力消費量の1次元入力データに基づいて、DCTモデルを使用して時系列の間隔予測を実行するために必要なものがすべて揃いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全なコード例を以下に示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># univariate multi-step lstm</span>
<span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt
<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> split
<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> array
<span class="hljs-keyword">from</span> pandas <span class="hljs-keyword">import</span> read_csv
<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error
<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot
<span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Dense
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Flatten
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> LSTM<font></font>
<font></font>
<span class="hljs-comment"># split a univariate dataset into train/test sets</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">split_dataset</span>(<span class="hljs-params">data</span>):</span>
	<span class="hljs-comment"># split into standard weeks</span>
	train, test = data[<span class="hljs-number">1</span>:<span class="hljs-number">-328</span>], data[<span class="hljs-number">-328</span>:<span class="hljs-number">-6</span>]
	<span class="hljs-comment"># restructure into windows of weekly data</span>
	train = array(split(train, len(train)/<span class="hljs-number">7</span>))<font></font>
	test = array(split(test, len(test)/<span class="hljs-number">7</span>))
	<span class="hljs-keyword">return</span> train, test<font></font>
<font></font>
<span class="hljs-comment"># evaluate one or more weekly forecasts against expected values</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate_forecasts</span>(<span class="hljs-params">actual, predicted</span>):</span><font></font>
	scores = list()<font></font>
	<span class="hljs-comment"># calculate an RMSE score for each day</span>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">1</span>]):
		<span class="hljs-comment"># calculate mse</span><font></font>
		mse = mean_squared_error(actual[:, i], predicted[:, i])<font></font>
		<span class="hljs-comment"># calculate rmse</span><font></font>
		rmse = sqrt(mse)<font></font>
		<span class="hljs-comment"># store</span><font></font>
		scores.append(rmse)<font></font>
	<span class="hljs-comment"># calculate overall RMSE</span>
	s = <span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">0</span>]):
		<span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">1</span>]):<font></font>
			s += (actual[row, col] - predicted[row, col])**<span class="hljs-number">2</span>
	score = sqrt(s / (actual.shape[<span class="hljs-number">0</span>] * actual.shape[<span class="hljs-number">1</span>]))
	<span class="hljs-keyword">return</span> score, scores<font></font>
<font></font>
<span class="hljs-comment"># summarize scores</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">summarize_scores</span>(<span class="hljs-params">name, score, scores</span>):</span>
	s_scores = <span class="hljs-string">', '</span>.join([<span class="hljs-string">'%.1f'</span> % s <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> scores])<font></font>
	print(<span class="hljs-string">'%s: [%.3f] %s'</span> % (name, score, s_scores))<font></font>
<font></font>
<span class="hljs-comment"># convert history into inputs and outputs</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_supervised</span>(<span class="hljs-params">train, n_input, n_out=<span class="hljs-number">7</span></span>):</span>
	<span class="hljs-comment"># flatten data</span>
	data = train.reshape((train.shape[<span class="hljs-number">0</span>]*train.shape[<span class="hljs-number">1</span>], train.shape[<span class="hljs-number">2</span>]))<font></font>
	X, y = list(), list()<font></font>
	in_start = <span class="hljs-number">0</span>
	<span class="hljs-comment"># step over the entire history one time step at a time</span>
	<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(len(data)):
		<span class="hljs-comment"># define the end of the input sequence</span><font></font>
		in_end = in_start + n_input<font></font>
		out_end = in_end + n_out<font></font>
		<span class="hljs-comment"># ensure we have enough data for this instance</span>
		<span class="hljs-keyword">if</span> out_end &lt;= len(data):<font></font>
			x_input = data[in_start:in_end, <span class="hljs-number">0</span>]<font></font>
			x_input = x_input.reshape((len(x_input), <span class="hljs-number">1</span>))<font></font>
			X.append(x_input)<font></font>
			y.append(data[in_end:out_end, <span class="hljs-number">0</span>])
		<span class="hljs-comment"># move along one time step</span>
		in_start += <span class="hljs-number">1</span>
	<span class="hljs-keyword">return</span> array(X), array(y)<font></font>
<font></font>
<span class="hljs-comment"># train the model</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_model</span>(<span class="hljs-params">train, n_input</span>):</span>
	<span class="hljs-comment"># prepare data</span><font></font>
	train_x, train_y = to_supervised(train, n_input)<font></font>
	<span class="hljs-comment"># define parameters</span>
	verbose, epochs, batch_size = <span class="hljs-number">0</span>, <span class="hljs-number">70</span>, <span class="hljs-number">16</span>
	n_timesteps, n_features, n_outputs = train_x.shape[<span class="hljs-number">1</span>], train_x.shape[<span class="hljs-number">2</span>], train_y.shape[<span class="hljs-number">1</span>]
	<span class="hljs-comment"># define model</span><font></font>
	model = Sequential()<font></font>
	model.add(LSTM(<span class="hljs-number">200</span>, activation=<span class="hljs-string">'relu'</span>, input_shape=(n_timesteps, n_features)))<font></font>
	model.add(Dense(<span class="hljs-number">100</span>, activation=<span class="hljs-string">'relu'</span>))<font></font>
	model.add(Dense(n_outputs))<font></font>
	model.compile(loss=<span class="hljs-string">'mse'</span>, optimizer=<span class="hljs-string">'adam'</span>)
	<span class="hljs-comment"># fit network</span><font></font>
	model.fit(train_x, train_y, epochs=epochs, batch_size=batch_size, verbose=verbose)<font></font>
	<span class="hljs-keyword">return</span> model<font></font>
<font></font>
<span class="hljs-comment"># make a forecast</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forecast</span>(<span class="hljs-params">model, history, n_input</span>):</span>
	<span class="hljs-comment"># flatten data</span><font></font>
	data = array(history)<font></font>
	data = data.reshape((data.shape[<span class="hljs-number">0</span>]*data.shape[<span class="hljs-number">1</span>], data.shape[<span class="hljs-number">2</span>]))
	<span class="hljs-comment"># retrieve last observations for input data</span>
	input_x = data[-n_input:, <span class="hljs-number">0</span>]
	<span class="hljs-comment"># reshape into [1, n_input, 1]</span>
	input_x = input_x.reshape((<span class="hljs-number">1</span>, len(input_x), <span class="hljs-number">1</span>))
	<span class="hljs-comment"># forecast the next week</span>
	yhat = model.predict(input_x, verbose=<span class="hljs-number">0</span>)
	<span class="hljs-comment"># we only want the vector forecast</span>
	yhat = yhat[<span class="hljs-number">0</span>]
	<span class="hljs-keyword">return</span> yhat<font></font>
<font></font>
<span class="hljs-comment"># evaluate a single model</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate_model</span>(<span class="hljs-params">train, test, n_input</span>):</span>
	<span class="hljs-comment"># fit model</span><font></font>
	model = build_model(train, n_input)<font></font>
	<span class="hljs-comment"># history is a list of weekly data</span>
	history = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> train]
	<span class="hljs-comment"># walk-forward validation over each week</span><font></font>
	predictions = list()<font></font>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(test)):
		<span class="hljs-comment"># predict the week</span><font></font>
		yhat_sequence = forecast(model, history, n_input)<font></font>
		<span class="hljs-comment"># store the predictions</span><font></font>
		predictions.append(yhat_sequence)<font></font>
		<span class="hljs-comment"># get real observation and add to history for predicting the next week</span><font></font>
		history.append(test[i, :])<font></font>
	<span class="hljs-comment"># evaluate predictions days for each week</span><font></font>
	predictions = array(predictions)<font></font>
	score, scores = evaluate_forecasts(test[:, :, <span class="hljs-number">0</span>], predictions)
	<span class="hljs-keyword">return</span> score, scores<font></font>
<font></font>
<span class="hljs-comment"># load the new file</span>
dataset = read_csv(<span class="hljs-string">'household_power_consumption_days.csv'</span>, header=<span class="hljs-number">0</span>, infer_datetime_format=<span class="hljs-literal">True</span>, parse_dates=[<span class="hljs-string">'datetime'</span>], index_col=[<span class="hljs-string">'datetime'</span>])
<span class="hljs-comment"># split into train and test</span><font></font>
train, test = split_dataset(dataset.values)<font></font>
<span class="hljs-comment"># evaluate model and get scores</span>
n_input = <span class="hljs-number">7</span><font></font>
score, scores = evaluate_model(train, test, n_input)<font></font>
<span class="hljs-comment"># summarize scores</span>
summarize_scores(<span class="hljs-string">'lstm'</span>, score, scores)
<span class="hljs-comment"># plot scores</span>
days = [<span class="hljs-string">'sun'</span>, <span class="hljs-string">'mon'</span>, <span class="hljs-string">'tue'</span>, <span class="hljs-string">'wed'</span>, <span class="hljs-string">'thr'</span>, <span class="hljs-string">'fri'</span>, <span class="hljs-string">'sat'</span>]<font></font>
pyplot.plot(days, scores, marker=<span class="hljs-string">'o'</span>, label=<span class="hljs-string">'lstm'</span>)<font></font>
pyplot.show()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード実行は、モデル全体のトレーニングと、（予測全体の）週全体の合計RMSE値と予測週の各日のRMSE値を含む行表示の形式でモデルの評価を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムの確率的性質により、結果は以下に示すものと異なる場合があります。コードを数回実行することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、モデルは単純な予測と比べてパフォーマンスが優れています。合計RMSE値は約399キロワットであり、これは単純なモデルで得られた485キロワット値よりも低くなっています。</font></font><br>
<br>
<pre><code class="python hljs">lstm: [<span class="hljs-number">399.456</span>] <span class="hljs-number">419.4</span>, <span class="hljs-number">422.1</span>, <span class="hljs-number">384.5</span>, <span class="hljs-number">395.1</span>, <span class="hljs-number">403.9</span>, <span class="hljs-number">317.7</span>, <span class="hljs-number">441.5</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
予測週の各日のエラー値を示すグラフを以下に示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グラフは、火曜日と金曜日が他の日よりも予測しやすい日であり、土曜日が予測するのが最も難しい日であることを示しています。</font></font><br>
 <img src="https://habrastorage.org/getpro/habr/post_images/107/854/fcc/107854fcc37b888debb03404a32867b7.png" alt="画像"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このガイドの例に、予測の結果を視覚化するグラフを含めると便利です。</font><font style="vertical-align: inherit;">チャートはさまざまな方法で実行できます。</font><font style="vertical-align: inherit;">エネルギー消費予測の間隔は7日後（パラメーターn_out）であり、これはそれほど多くなく、使用されるリソースとコード実行時間の点で問題を引き起こさないという事実を考慮して、予測週の各日に個別のRMSEスケジュールを導出します。</font><font style="vertical-align: inherit;">これを行うには、新しいshow_plot（）関数を追加します。</font></font></i><br>
<br>
<pre><code class="python hljs">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_plot</span>(<span class="hljs-params">true, pred, title</span>):</span><font></font>
    fig = pyplot.subplots()<font></font>
    pyplot.plot(true, label=<span class="hljs-string">'Y_original'</span>)<font></font>
    pyplot.plot(pred, dashes=[<span class="hljs-number">4</span>, <span class="hljs-number">3</span>], label=<span class="hljs-string">'Y_predicted'</span>)<font></font>
    pyplot.xlabel(<span class="hljs-string">'N_samples'</span>, fontsize=<span class="hljs-number">12</span>)<font></font>
    pyplot.ylabel(<span class="hljs-string">'Instance_value'</span>, fontsize=<span class="hljs-number">12</span>)<font></font>
    pyplot.title(title, fontsize=<span class="hljs-number">12</span>)<font></font>
    pyplot.grid(<span class="hljs-literal">True</span>)<font></font>
    pyplot.legend(loc=<span class="hljs-string">'upper right'</span>)<font></font>
    pyplot.show()<font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">また、evaluate_forecasts（）関数を次の行で補足します。</font></font></i><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(predicted.shape[<span class="hljs-number">1</span>]):<font></font>
    show_plot(actual[:, j], predicted[:, j], j + <span class="hljs-number">1</span>)
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後に、予測週の各日のエラー値を含むグラフの作成は、次の行で補足されます。</font></font></i><br>
<br>
<pre><code class="python hljs">fig = pyplot.subplots()</code></pre><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらの変更の完全なコードはこちらです。</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-comment"># univariate multi-step lstm</span>
<span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt
<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> split
<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> array
<span class="hljs-keyword">from</span> pandas <span class="hljs-keyword">import</span> read_csv
<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error
<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot
<span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Dense
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Flatten
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> LSTM<font></font>
<font></font>
<span class="hljs-comment"># split a univariate dataset into train/test sets</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">split_dataset</span>(<span class="hljs-params">data</span>):</span>
    <span class="hljs-comment"># split into standard weeks</span>
    train, test = data[<span class="hljs-number">1</span>:<span class="hljs-number">-328</span>], data[<span class="hljs-number">-328</span>:<span class="hljs-number">-6</span>]
    <span class="hljs-comment"># restructure into windows of weekly data</span>
    train = array(split(train, len(train)/<span class="hljs-number">7</span>))<font></font>
    test = array(split(test, len(test)/<span class="hljs-number">7</span>))
    <span class="hljs-keyword">return</span> train, test<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_plot</span>(<span class="hljs-params">true, pred, title</span>):</span><font></font>
    fig = pyplot.subplots()<font></font>
    pyplot.plot(true, label=<span class="hljs-string">'Y_original'</span>)<font></font>
    pyplot.plot(pred, dashes=[<span class="hljs-number">4</span>, <span class="hljs-number">3</span>], label=<span class="hljs-string">'Y_predicted'</span>)<font></font>
    pyplot.xlabel(<span class="hljs-string">'N_samples'</span>, fontsize=<span class="hljs-number">12</span>)<font></font>
    pyplot.ylabel(<span class="hljs-string">'Instance_value'</span>, fontsize=<span class="hljs-number">12</span>)<font></font>
    pyplot.title(title, fontsize=<span class="hljs-number">12</span>)<font></font>
    pyplot.grid(<span class="hljs-literal">True</span>)<font></font>
    pyplot.legend(loc=<span class="hljs-string">'upper right'</span>)<font></font>
    pyplot.show()<font></font>
<font></font>
<span class="hljs-comment"># # evaluate one or more weekly forecasts against expected values</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate_forecasts</span>(<span class="hljs-params">actual, predicted</span>):</span><font></font>
    scores = list()<font></font>
    <span class="hljs-comment"># calculate an RMSE score for each day</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">1</span>]):
        <span class="hljs-comment"># calculate mse</span><font></font>
        mse = mean_squared_error(actual[:, i], predicted[:, i])<font></font>
        <span class="hljs-comment"># calculate rmse</span><font></font>
        rmse = sqrt(mse)<font></font>
        <span class="hljs-comment"># store</span><font></font>
        scores.append(rmse)<font></font>
    <span class="hljs-comment"># calculate overall RMSE</span>
    s = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">0</span>]):
        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">1</span>]):<font></font>
            s += (actual[row, col] - predicted[row, col])**<span class="hljs-number">2</span>
    score = sqrt(s / (actual.shape[<span class="hljs-number">0</span>] * actual.shape[<span class="hljs-number">1</span>]))
    <span class="hljs-comment"># plot forecasts vs observations</span>
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(predicted.shape[<span class="hljs-number">1</span>]):<font></font>
        show_plot(actual[:, j], predicted[:, j], j + <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> score, scores<font></font>
<font></font>
<span class="hljs-comment"># summarize scores</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">summarize_scores</span>(<span class="hljs-params">name, score, scores</span>):</span>
    s_scores = <span class="hljs-string">', '</span>.join([<span class="hljs-string">'%.1f'</span> % s <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> scores])<font></font>
    print(<span class="hljs-string">'%s: [%.3f] %s'</span> % (name, score, s_scores))<font></font>
<font></font>
<span class="hljs-comment"># convert history into inputs and outputs</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_supervised</span>(<span class="hljs-params">train, n_input, n_out=<span class="hljs-number">7</span></span>):</span>
    <span class="hljs-comment"># flatten data</span>
    data = train.reshape((train.shape[<span class="hljs-number">0</span>]*train.shape[<span class="hljs-number">1</span>], train.shape[<span class="hljs-number">2</span>]))<font></font>
    X, y = list(), list()<font></font>
    in_start = <span class="hljs-number">0</span>
    <span class="hljs-comment"># step over the entire history one time step at a time</span>
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(len(data)):
        <span class="hljs-comment"># define the end of the input sequence</span><font></font>
        in_end = in_start + n_input<font></font>
        out_end = in_end + n_out<font></font>
        <span class="hljs-comment"># ensure we have enough data for this instance</span>
        <span class="hljs-keyword">if</span> out_end &lt;= len(data):<font></font>
            x_input = data[in_start:in_end, <span class="hljs-number">0</span>]<font></font>
            x_input = x_input.reshape((len(x_input), <span class="hljs-number">1</span>))<font></font>
            X.append(x_input)<font></font>
            y.append(data[in_end:out_end, <span class="hljs-number">0</span>])
        <span class="hljs-comment"># move along one time step</span>
        in_start += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> array(X), array(y)<font></font>
<font></font>
<span class="hljs-comment"># train the model</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_model</span>(<span class="hljs-params">train, n_input</span>):</span>
    <span class="hljs-comment"># prepare data</span><font></font>
    train_x, train_y = to_supervised(train, n_input)<font></font>
    <span class="hljs-comment"># define parameters</span>
    verbose, epochs, batch_size = <span class="hljs-number">0</span>, <span class="hljs-number">70</span>, <span class="hljs-number">16</span>
    n_timesteps, n_features, n_outputs = train_x.shape[<span class="hljs-number">1</span>], train_x.shape[<span class="hljs-number">2</span>], train_y.shape[<span class="hljs-number">1</span>]
    <span class="hljs-comment"># define model</span><font></font>
    model = Sequential()<font></font>
    model.add(LSTM(<span class="hljs-number">200</span>, activation=<span class="hljs-string">'relu'</span>, input_shape=(n_timesteps, n_features)))<font></font>
    model.add(Dense(<span class="hljs-number">100</span>, activation=<span class="hljs-string">'relu'</span>))<font></font>
    model.add(Dense(n_outputs))<font></font>
    model.compile(loss=<span class="hljs-string">'mse'</span>, optimizer=<span class="hljs-string">'adam'</span>)
    <span class="hljs-comment"># fit network</span><font></font>
    model.fit(train_x, train_y, epochs=epochs, batch_size=batch_size, verbose=verbose)<font></font>
    <span class="hljs-keyword">return</span> model<font></font>
<font></font>
<span class="hljs-comment"># make a forecast</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forecast</span>(<span class="hljs-params">model, history, n_input</span>):</span>
    <span class="hljs-comment"># flatten data</span><font></font>
    data = array(history)<font></font>
    data = data.reshape((data.shape[<span class="hljs-number">0</span>]*data.shape[<span class="hljs-number">1</span>], data.shape[<span class="hljs-number">2</span>]))
    <span class="hljs-comment"># retrieve last observations for input data</span>
    input_x = data[-n_input:, <span class="hljs-number">0</span>]
    <span class="hljs-comment"># reshape into [1, n_input, 1]</span>
    input_x = input_x.reshape((<span class="hljs-number">1</span>, len(input_x), <span class="hljs-number">1</span>))
    <span class="hljs-comment"># forecast the next week</span>
    yhat = model.predict(input_x, verbose=<span class="hljs-number">0</span>)
    <span class="hljs-comment"># we only want the vector forecast</span>
    yhat = yhat[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">return</span> yhat<font></font>
<font></font>
<span class="hljs-comment"># evaluate a single model</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate_model</span>(<span class="hljs-params">train, test, n_input</span>):</span>
    <span class="hljs-comment"># fit model</span><font></font>
    model = build_model(train, n_input)<font></font>
    <span class="hljs-comment"># history is a list of weekly data</span>
    history = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> train]
    <span class="hljs-comment"># walk-forward validation over each week</span><font></font>
    predictions = list()<font></font>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(test)):
        <span class="hljs-comment"># predict the week</span><font></font>
        yhat_sequence = forecast(model, history, n_input)<font></font>
        <span class="hljs-comment"># store the predictions</span><font></font>
        predictions.append(yhat_sequence)<font></font>
        <span class="hljs-comment"># get real observation and add to history for predicting the next week</span><font></font>
        history.append(test[i, :])<font></font>
    <span class="hljs-comment"># evaluate predictions days for each week</span><font></font>
    predictions = array(predictions)<font></font>
    score, scores = evaluate_forecasts(test[:, :, <span class="hljs-number">0</span>], predictions)
    <span class="hljs-keyword">return</span> score, scores<font></font>
<font></font>
<span class="hljs-comment"># load the new file</span>
dataset = read_csv(<span class="hljs-string">'household_power_consumption_days.csv'</span>, header=<span class="hljs-number">0</span>,<font></font>
                    infer_datetime_format=<span class="hljs-literal">True</span>, parse_dates=[<span class="hljs-string">'datetime'</span>],<font></font>
                    index_col=[<span class="hljs-string">'datetime'</span>])
<span class="hljs-comment"># split into train and test</span><font></font>
train, test = split_dataset(dataset.values)<font></font>
<span class="hljs-comment"># evaluate model and get scores</span>
n_input = <span class="hljs-number">7</span><font></font>
score, scores = evaluate_model(train, test, n_input)<font></font>
<span class="hljs-comment"># summarize scores</span>
summarize_scores(<span class="hljs-string">'lstm'</span>, score, scores)
<span class="hljs-comment"># plot scores</span>
days = [<span class="hljs-string">'sun'</span>, <span class="hljs-string">'mon'</span>, <span class="hljs-string">'tue'</span>, <span class="hljs-string">'wed'</span>, <span class="hljs-string">'thr'</span>, <span class="hljs-string">'fri'</span>, <span class="hljs-string">'sat'</span>]<font></font>
fig = pyplot.subplots()<font></font>
pyplot.plot(days, scores, marker=<span class="hljs-string">'o'</span>, label=<span class="hljs-string">'lstm'</span>)<font></font>
pyplot.show()<font></font>
</code></pre><br>
</div>
                    </div><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行すると以下の結果が出ました</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs">lstm: [<span class="hljs-number">401.716</span>] <span class="hljs-number">418.6</span>, <span class="hljs-number">413.2</span>, <span class="hljs-number">408.7</span>, <span class="hljs-number">393.8</span>, <span class="hljs-number">395.6</span>, <span class="hljs-number">315.0</span>, <span class="hljs-number">453.8</span></code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/755/826/759/7558267594b9b7dd5e794d31a112e764.png" alt="image"><br>
<img src="https://habrastorage.org/getpro/habr/post_images/61c/0d4/666/61c0d4666f9e7243d7f42fc934312e19.png" alt="image"><br>
<img src="https://habrastorage.org/getpro/habr/post_images/e02/187/287/e02187287b4901d6a2ac87532aa1e56e.png" alt="image"><br>
<img src="https://habrastorage.org/getpro/habr/post_images/9a3/0ce/ee5/9a30ceee58fdbccbbf5bf82b2f90ba26.png" alt="image"><br>
<img src="https://habrastorage.org/getpro/habr/post_images/68f/7b9/80c/68f7b980ccfa9f1b94efc9c94b957e5c.png" alt="image"><br>
<img src="https://habrastorage.org/getpro/habr/post_images/b55/baa/411/b55baa4113aab86095bf999b18ae2f45.png" alt="image"><br>
<img src="https://habrastorage.org/getpro/habr/post_images/ceb/fb4/4f4/cebfb44f46a483a80b9f96d3e73c9e8e.png" alt="image"><br>
<br>
<i>         ,        ,         .</i><br>
</div>
                    </div><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n_input</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
パラメータの値を変更して、入力として使用される前の日数を7から14日に増やしましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># evaluate model and get scores</span>
n_input = <span class="hljs-number">14</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
加えられた変更を考慮してサンプルを再起動すると、モデルの品質に関する概要情報が表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果は、以下に示すものと異なる場合があります。例を数回試してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果は、合計RMSEエラーの値が370キロワットに減少したことを示しています。したがって、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n_inputの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズ</font><font style="vertical-align: inherit;">と、場合によってはモデルノードの数</font><font style="vertical-align: inherit;">をさらに調整すると、</font><font style="vertical-align: inherit;">効率が上がる</font><font style="vertical-align: inherit;">と想定でき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="python hljs">lstm: [<span class="hljs-number">370.028</span>] <span class="hljs-number">387.4</span>, <span class="hljs-number">377.9</span>, <span class="hljs-number">334.0</span>, <span class="hljs-number">371.2</span>, <span class="hljs-number">367.1</span>, <span class="hljs-number">330.4</span>, <span class="hljs-number">415.1</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
毎日のRMSE値を相互に比較すると、7日間の入力データを使用する場合と比較して、ある日は悪い日もありますが、他の日は予測にうまく対応できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、2つのデータアプローチを組み合わせたアンサンブルや、トレーニングデータをさまざまな方法で読み取る単一のモデル（「マルチヘッド」モデル）を使用するなど、サイズの異なる2つの入力を組み合わせて使用​​すると効果的であると想定できます。</font></font><br>
<img src="https://habrastorage.org/getpro/habr/post_images/422/923/4d8/4229234d81dd57fd95c9be1b478446e0.png" alt="画像"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1次元入力データに基づく「エンコーダー-デコーダー」タイプのDCT</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションでは、バニラモデルを「エンコーダー-デコーダー」タイプのDCTモデルにアップグレードする方法について説明します</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（英語の用語では、エンコーダー-デコーダーLSTM。注）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルはベクトルシーケンスを直接出力しません。入力シーケンスを読み取ってエンコードするエンコーダと、エンコードされた入力シーケンスを解釈して出力シーケンスの各要素の点予測を実行するデコーダの2つのサブモデルで構成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデル間の違いはわずかです。実際には、どちらもシーケンスの形式で予測を表示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションで検討するモデルの特徴は、DCTがデコーダーとして使用されることです。DCTレイヤーは、シーケンスの前日の予測に関する情報を収集し、各シーケンスが出力されるときに内部状態も蓄積します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このモデルがどのように決定されるかをさらに詳しく検討してみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前と同様に、200個のニューロンを持つ非表示のDCTレイヤーが決定されます。この層のみが入力シーケンスを読み取り、入力シーケンスから識別された符号に従って200要素のベクトル（ユニットごとに1つの出力）を出力するデコーダーとして機能します。入力データとして、14日間の総エネルギー消費量が使用されます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># define model</span><font></font>
model = Sequential()<font></font>
model.add(LSTM(<span class="hljs-number">200</span>, activation=<span class="hljs-string">'relu'</span>, input_shape=(n_timesteps, n_features)))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、Kerasを使用して簡単に実装できる単純な「エンコーダー-デコーダー」アーキテクチャを使用します。このアーキテクチャは、「自動コーディング」タイプのDCTのアーキテクチャと多くの類似点があります</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（英語の用語では、LSTMオートエンコーダ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「オートエンコーダー」タイプのDCTは、オートエンコーダーの実装の1つです。これはANNの一種であり、その目的は、シーケンスの形式のデータに適用される、入力された小さな隠しスペースとその後のデコードをエンコードすることです。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最初に、入力シーケンスの内部表現が数回繰り返されます—出力シーケンスの各タイムステップに対して1回。この一連のベクトルは、DCTデコーダーに提示されます。</font></font><br>
<br>
<pre><code class="python hljs">model.add(RepeatVector(<span class="hljs-number">7</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、デコーダーは200個のニューロンを持つ非表示のDCTレイヤーとして定義されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンコーダーの場合のように、デコーダーがシーケンスの最後の出力だけでなく、シーケンス全体を出力することに注意することが重要です。これは、200個のニューロンのそれぞれが予測された週の各日に関連付けられ、出力シーケンスの各日に正確に予測する必要があるものを決定することを意味します。</font></font><br>
<br>
<pre><code class="python hljs">model.add(LSTM(<span class="hljs-number">200</span>, activation=<span class="hljs-string">'relu'</span>, return_sequences=<span class="hljs-literal">True</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、最終出力層の前の出力シーケンスの各タイムステップを解釈するための完全に接続された層です。出力レイヤーは、出力シーケンスの1つのステップを予測し、一度に7日すべてを予測するわけではないことに注意することが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、同じシーケンスが出力シーケンスの各要素に適用されます。同じ完全に接続された同じ出力レイヤーが、デコーダーによって提供される各タイムステップを処理するために適用されます。これを行うには、解釈レイヤーと出力レイヤーを</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TimeDistributed</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェルに配置します</font><font style="vertical-align: inherit;">。これにより、タイムステップごとにラップされたレイヤーを使用できます。</font></font><br>
<br>
<pre><code class="python hljs">model.add(TimeDistributed(Dense(<span class="hljs-number">100</span>, activation=<span class="hljs-string">'relu'</span>)))<font></font>
model.add(TimeDistributed(Dense(<span class="hljs-number">1</span>)))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、DCTデコーダーは、出力シーケンスのタイムステップとラップされた完全に接続されたレイヤーとの関係を確立して、同じ重み係数を使用して各タイムステップを個別に解釈できます。別の解決策は、デコーダーと直接ベクトル出力によって作成された構造全体を平滑化することです。これを拡張機能の例として実行して、比較結果を確認できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ネットワーク出力は、入力シーケンスと同じ構造を持つ[次元</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、時間間隔、符号]の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3次元テンソルとして表され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つの症状-合計電力消費量（毎日の形式）-とその7つの遅れた観察があります。</font><font style="vertical-align: inherit;">したがって、1週間の予測は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1、7、1]の形式になります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションでは、1次元モデル、つまり、入力フィーチャセット（X）とターゲットデータセット（y）の両方が単一のフィーチャ（総消費電力）に基づいて形成されるモデルを検討します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、モデルをトレーニングする前に、ターゲットデータ（y）を</font><font style="vertical-align: inherit;">前のセクションで使用した</font><font style="vertical-align: inherit;">2次元形式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[サンプル、特徴]から</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3次元形式</font><font style="vertical-align: inherit;">に変換する必要があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># reshape output into [samples, timesteps, features]</span>
train_y = train_y.reshape((train_y.shape[<span class="hljs-number">0</span>], train_y.shape[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらの変更を考慮して</font><font style="vertical-align: inherit;">
更新された</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">build_model（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を</font><font style="vertical-align: inherit;">以下に示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># train the model</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_model</span>(<span class="hljs-params">train, n_input</span>):</span>
	<span class="hljs-comment"># prepare data</span><font></font>
	train_x, train_y = to_supervised(train, n_input)<font></font>
	<span class="hljs-comment"># define parameters</span>
	verbose, epochs, batch_size = <span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">16</span>
	n_timesteps, n_features, n_outputs = train_x.shape[<span class="hljs-number">1</span>], train_x.shape[<span class="hljs-number">2</span>], train_y.shape[<span class="hljs-number">1</span>]
	<span class="hljs-comment"># reshape output into [samples, timesteps, features]</span>
	train_y = train_y.reshape((train_y.shape[<span class="hljs-number">0</span>], train_y.shape[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>))
	<span class="hljs-comment"># define model</span><font></font>
	model = Sequential()<font></font>
	model.add(LSTM(<span class="hljs-number">200</span>, activation=<span class="hljs-string">'relu'</span>, input_shape=(n_timesteps, n_features)))<font></font>
	model.add(RepeatVector(n_outputs))<font></font>
	model.add(LSTM(<span class="hljs-number">200</span>, activation=<span class="hljs-string">'relu'</span>, return_sequences=<span class="hljs-literal">True</span>))<font></font>
	model.add(TimeDistributed(Dense(<span class="hljs-number">100</span>, activation=<span class="hljs-string">'relu'</span>)))<font></font>
	model.add(TimeDistributed(Dense(<span class="hljs-number">1</span>)))<font></font>
	model.compile(loss=<span class="hljs-string">'mse'</span>, optimizer=<span class="hljs-string">'adam'</span>)
	<span class="hljs-comment"># fit network</span><font></font>
	model.fit(train_x, train_y, epochs=epochs, batch_size=batch_size, verbose=verbose)<font></font>
	<span class="hljs-keyword">return</span> model</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「エンコーダーデコーダー」タイプのDCTの1次元モデルの完全なコード例を以下に示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># univariate multi-step encoder-decoder lstm</span>
<span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt
<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> split
<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> array
<span class="hljs-keyword">from</span> pandas <span class="hljs-keyword">import</span> read_csv
<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error
<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot
<span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Dense
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Flatten
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> LSTM
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> RepeatVector
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> TimeDistributed<font></font>
<font></font>
<span class="hljs-comment"># split a univariate dataset into train/test sets</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">split_dataset</span>(<span class="hljs-params">data</span>):</span>
	<span class="hljs-comment"># split into standard weeks</span>
	train, test = data[<span class="hljs-number">1</span>:<span class="hljs-number">-328</span>], data[<span class="hljs-number">-328</span>:<span class="hljs-number">-6</span>]
	<span class="hljs-comment"># restructure into windows of weekly data</span>
	train = array(split(train, len(train)/<span class="hljs-number">7</span>))<font></font>
	test = array(split(test, len(test)/<span class="hljs-number">7</span>))
	<span class="hljs-keyword">return</span> train, test<font></font>
<font></font>
<span class="hljs-comment"># evaluate one or more weekly forecasts against expected values</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate_forecasts</span>(<span class="hljs-params">actual, predicted</span>):</span><font></font>
	scores = list()<font></font>
	<span class="hljs-comment"># calculate an RMSE score for each day</span>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">1</span>]):
		<span class="hljs-comment"># calculate mse</span><font></font>
		mse = mean_squared_error(actual[:, i], predicted[:, i])<font></font>
		<span class="hljs-comment"># calculate rmse</span><font></font>
		rmse = sqrt(mse)<font></font>
		<span class="hljs-comment"># store</span><font></font>
		scores.append(rmse)<font></font>
	<span class="hljs-comment"># calculate overall RMSE</span>
	s = <span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">0</span>]):
		<span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">1</span>]):<font></font>
			s += (actual[row, col] - predicted[row, col])**<span class="hljs-number">2</span>
	score = sqrt(s / (actual.shape[<span class="hljs-number">0</span>] * actual.shape[<span class="hljs-number">1</span>]))
	<span class="hljs-keyword">return</span> score, scores<font></font>
<font></font>
<span class="hljs-comment"># summarize scores</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">summarize_scores</span>(<span class="hljs-params">name, score, scores</span>):</span>
	s_scores = <span class="hljs-string">', '</span>.join([<span class="hljs-string">'%.1f'</span> % s <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> scores])<font></font>
	print(<span class="hljs-string">'%s: [%.3f] %s'</span> % (name, score, s_scores))<font></font>
<font></font>
<span class="hljs-comment"># convert history into inputs and outputs</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_supervised</span>(<span class="hljs-params">train, n_input, n_out=<span class="hljs-number">7</span></span>):</span>
	<span class="hljs-comment"># flatten data</span>
	data = train.reshape((train.shape[<span class="hljs-number">0</span>]*train.shape[<span class="hljs-number">1</span>], train.shape[<span class="hljs-number">2</span>]))<font></font>
	X, y = list(), list()<font></font>
	in_start = <span class="hljs-number">0</span>
	<span class="hljs-comment"># step over the entire history one time step at a time</span>
	<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(len(data)):
		<span class="hljs-comment"># define the end of the input sequence</span><font></font>
		in_end = in_start + n_input<font></font>
		out_end = in_end + n_out<font></font>
		<span class="hljs-comment"># ensure we have enough data for this instance</span>
		<span class="hljs-keyword">if</span> out_end &lt;= len(data):<font></font>
			x_input = data[in_start:in_end, <span class="hljs-number">0</span>]<font></font>
			x_input = x_input.reshape((len(x_input), <span class="hljs-number">1</span>))<font></font>
			X.append(x_input)<font></font>
			y.append(data[in_end:out_end, <span class="hljs-number">0</span>])
		<span class="hljs-comment"># move along one time step</span>
		in_start += <span class="hljs-number">1</span>
	<span class="hljs-keyword">return</span> array(X), array(y)<font></font>
<font></font>
<span class="hljs-comment"># train the model</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_model</span>(<span class="hljs-params">train, n_input</span>):</span>
	<span class="hljs-comment"># prepare data</span><font></font>
	train_x, train_y = to_supervised(train, n_input)<font></font>
	<span class="hljs-comment"># define parameters</span>
	verbose, epochs, batch_size = <span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">16</span>
	n_timesteps, n_features, n_outputs = train_x.shape[<span class="hljs-number">1</span>], train_x.shape[<span class="hljs-number">2</span>], train_y.shape[<span class="hljs-number">1</span>]
	<span class="hljs-comment"># reshape output into [samples, timesteps, features]</span>
	train_y = train_y.reshape((train_y.shape[<span class="hljs-number">0</span>], train_y.shape[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>))
	<span class="hljs-comment"># define model</span><font></font>
	model = Sequential()<font></font>
	model.add(LSTM(<span class="hljs-number">200</span>, activation=<span class="hljs-string">'relu'</span>, input_shape=(n_timesteps, n_features)))<font></font>
	model.add(RepeatVector(n_outputs))<font></font>
	model.add(LSTM(<span class="hljs-number">200</span>, activation=<span class="hljs-string">'relu'</span>, return_sequences=<span class="hljs-literal">True</span>))<font></font>
	model.add(TimeDistributed(Dense(<span class="hljs-number">100</span>, activation=<span class="hljs-string">'relu'</span>)))<font></font>
	model.add(TimeDistributed(Dense(<span class="hljs-number">1</span>)))<font></font>
	model.compile(loss=<span class="hljs-string">'mse'</span>, optimizer=<span class="hljs-string">'adam'</span>)
	<span class="hljs-comment"># fit network</span><font></font>
	model.fit(train_x, train_y, epochs=epochs, batch_size=batch_size, verbose=verbose)<font></font>
	<span class="hljs-keyword">return</span> model<font></font>
<font></font>
<span class="hljs-comment"># make a forecast</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forecast</span>(<span class="hljs-params">model, history, n_input</span>):</span>
	<span class="hljs-comment"># flatten data</span><font></font>
	data = array(history)<font></font>
	data = data.reshape((data.shape[<span class="hljs-number">0</span>]*data.shape[<span class="hljs-number">1</span>], data.shape[<span class="hljs-number">2</span>]))
	<span class="hljs-comment"># retrieve last observations for input data</span>
	input_x = data[-n_input:, <span class="hljs-number">0</span>]
	<span class="hljs-comment"># reshape into [1, n_input, 1]</span>
	input_x = input_x.reshape((<span class="hljs-number">1</span>, len(input_x), <span class="hljs-number">1</span>))
	<span class="hljs-comment"># forecast the next week</span>
	yhat = model.predict(input_x, verbose=<span class="hljs-number">0</span>)
	<span class="hljs-comment"># we only want the vector forecast</span>
	yhat = yhat[<span class="hljs-number">0</span>]
	<span class="hljs-keyword">return</span> yhat<font></font>
<font></font>
<span class="hljs-comment"># evaluate a single model</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate_model</span>(<span class="hljs-params">train, test, n_input</span>):</span>
	<span class="hljs-comment"># fit model</span><font></font>
	model = build_model(train, n_input)<font></font>
	<span class="hljs-comment"># history is a list of weekly data</span>
	history = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> train]
	<span class="hljs-comment"># walk-forward validation over each week</span><font></font>
	predictions = list()<font></font>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(test)):
		<span class="hljs-comment"># predict the week</span><font></font>
		yhat_sequence = forecast(model, history, n_input)<font></font>
		<span class="hljs-comment"># store the predictions</span><font></font>
		predictions.append(yhat_sequence)<font></font>
		<span class="hljs-comment"># get real observation and add to history for predicting the next week</span><font></font>
		history.append(test[i, :])<font></font>
	<span class="hljs-comment"># evaluate predictions days for each week</span><font></font>
	predictions = array(predictions)<font></font>
	score, scores = evaluate_forecasts(test[:, :, <span class="hljs-number">0</span>], predictions)
	<span class="hljs-keyword">return</span> score, scores<font></font>
<font></font>
<span class="hljs-comment"># load the new file</span>
dataset = read_csv(<span class="hljs-string">'household_power_consumption_days.csv'</span>, header=<span class="hljs-number">0</span>, infer_datetime_format=<span class="hljs-literal">True</span>, parse_dates=[<span class="hljs-string">'datetime'</span>], index_col=[<span class="hljs-string">'datetime'</span>])
<span class="hljs-comment"># split into train and test</span><font></font>
train, test = split_dataset(dataset.values)<font></font>
<span class="hljs-comment"># evaluate model and get scores</span>
n_input = <span class="hljs-number">14</span><font></font>
score, scores = evaluate_model(train, test, n_input)<font></font>
<span class="hljs-comment"># summarize scores</span>
summarize_scores(<span class="hljs-string">'lstm'</span>, score, scores)
<span class="hljs-comment"># plot scores</span>
days = [<span class="hljs-string">'sun'</span>, <span class="hljs-string">'mon'</span>, <span class="hljs-string">'tue'</span>, <span class="hljs-string">'wed'</span>, <span class="hljs-string">'thr'</span>, <span class="hljs-string">'fri'</span>, <span class="hljs-string">'sat'</span>]<font></font>
pyplot.plot(days, scores, marker=<span class="hljs-string">'o'</span>, label=<span class="hljs-string">'lstm'</span>)<font></font>
pyplot.show()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード実行は、モデル全体のトレーニングと、データセットの検証部分での週全体の合計RMSE値と予測週の各日のRMSE値を行表示の形式で提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムの確率的性質により、結果は以下に示すものと異なる場合があります。</font><font style="vertical-align: inherit;">コードを数回実行することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、モデルはまた、単純なモデルよりも優れた予測に対応しました。合計RMSE値は約372キロワットです。</font></font><br>
<br>
<pre><code class="python hljs">lstm: [<span class="hljs-number">372.595</span>] <span class="hljs-number">379.5</span>, <span class="hljs-number">399.8</span>, <span class="hljs-number">339.6</span>, <span class="hljs-number">372.2</span>, <span class="hljs-number">370.9</span>, <span class="hljs-number">309.9</span>, <span class="hljs-number">424.8</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
予測週の各日のRMSEエラー値のグラフは、前のセクションと同様に実行されます。</font></font><br>
<img src="https://habrastorage.org/getpro/habr/post_images/271/12c/48f/27112c48f28cf660158108cb6b45f3c6.png" alt="画像"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></i><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的なビューでは、すべての時間間隔の累積グラフを導出します</font></font></b>
                        <div class="spoiler_text"><pre><code class="python hljs">lstm: [<span class="hljs-number">369.602</span>]</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/3bb/048/1ca/3bb0481ca27b55967be752c5c78657ef.png" alt="image"><br>
<br>
<i>,    - ,       .       ,       .     ,     ,     .</i><br>
</div>
                    </div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多次元入力データに基づく「エンコーダー-デコーダー」タイプのDCT</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションでは、前のセクションで開発した「エンコーダー/デコーダー」タイプのDCTモデルの更新について検討します。これは、8桁の各記号を1次元時系列形式で使用して、次週の電力を予測することで構成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このため、それらのそれぞれは、個別の入力シーケンスの形式でモデルに提示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、DCTは各入力シーケンスの内部表現を作成し、デコーダーによる解釈のために共有されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多次元入力データの使用は、出力シーケンスが予測された符号だけでなく、多くの異なる符号の以前の時間間隔の観測の関数である場合の問題を解決するのに役立ちます。</font><font style="vertical-align: inherit;">このアプローチが電力消費予測の問題を解決するのに適しているかどうかはまだ明確ではないため、この問題を検討する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、1日の合計電力消費だけでなく、8つの機能すべてを含むトレーニングデータの準備を更新し、1行を修正します。</font></font><br>
<br>
<pre><code class="python hljs">X.append(data[in_start:in_end, :])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この変更を考慮して</font><font style="vertical-align: inherit;">
更新された</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to_supervised（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">を以下に示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># convert history into inputs and outputs</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_supervised</span>(<span class="hljs-params">train, n_input, n_out=<span class="hljs-number">7</span></span>):</span>
	<span class="hljs-comment"># flatten data</span>
	data = train.reshape((train.shape[<span class="hljs-number">0</span>]*train.shape[<span class="hljs-number">1</span>], train.shape[<span class="hljs-number">2</span>]))<font></font>
	X, y = list(), list()<font></font>
	in_start = <span class="hljs-number">0</span>
	<span class="hljs-comment"># step over the entire history one time step at a time</span>
	<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(len(data)):
		<span class="hljs-comment"># define the end of the input sequence</span><font></font>
		in_end = in_start + n_input<font></font>
		out_end = in_end + n_out<font></font>
		<span class="hljs-comment"># ensure we have enough data for this instance</span>
		<span class="hljs-keyword">if</span> out_end &lt;= len(data):<font></font>
			X.append(data[in_start:in_end, :])<font></font>
			y.append(data[in_end:out_end, <span class="hljs-number">0</span>])
		<span class="hljs-comment"># move along one time step</span>
		in_start += <span class="hljs-number">1</span>
	<span class="hljs-keyword">return</span> array(X), array(y)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、以前の時間間隔で8つの特徴すべてを使用するには、トレーニング済みモデルに基づいて予測を行うために使用される関数を更新する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、小さな変更を加えます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># retrieve last observations for input data</span><font></font>
input_x = data[-n_input:, :]<font></font>
<span class="hljs-comment"># reshape into [1, n_input, n]</span>
input_x = input_x.reshape((<span class="hljs-number">1</span>, input_x.shape[<span class="hljs-number">0</span>], input_x.shape[<span class="hljs-number">1</span>]))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この変更を考慮した</font><font style="vertical-align: inherit;">
更新された</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予測（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">を以下に示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># make a forecast</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forecast</span>(<span class="hljs-params">model, history, n_input</span>):</span>
	<span class="hljs-comment"># flatten data</span><font></font>
	data = array(history)<font></font>
	data = data.reshape((data.shape[<span class="hljs-number">0</span>]*data.shape[<span class="hljs-number">1</span>], data.shape[<span class="hljs-number">2</span>]))
	<span class="hljs-comment"># retrieve last observations for input data</span><font></font>
	input_x = data[-n_input:, :]<font></font>
	<span class="hljs-comment"># reshape into [1, n_input, n]</span>
	input_x = input_x.reshape((<span class="hljs-number">1</span>, input_x.shape[<span class="hljs-number">0</span>], input_x.shape[<span class="hljs-number">1</span>]))
	<span class="hljs-comment"># forecast the next week</span>
	yhat = model.predict(input_x, verbose=<span class="hljs-number">0</span>)
	<span class="hljs-comment"># we only want the vector forecast</span>
	yhat = yhat[<span class="hljs-number">0</span>]
	<span class="hljs-keyword">return</span> yhat</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前と同じモデルのアーキテクチャと構成が使用されますが、入力データ数が8倍に増加するため、トレーニングエポック数は20から50に増加</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
します。「エンコーダーデコーダー」タイプのDCTの多次元モデルの完全なコード例を以下に示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># multivariate multi-step encoder-decoder lstm</span>
<span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt
<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> split
<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> array
<span class="hljs-keyword">from</span> pandas <span class="hljs-keyword">import</span> read_csv
<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error
<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot
<span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Dense
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Flatten
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> LSTM
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> RepeatVector
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> TimeDistributed<font></font>
<font></font>
<span class="hljs-comment"># split a univariate dataset into train/test sets</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">split_dataset</span>(<span class="hljs-params">data</span>):</span>
	<span class="hljs-comment"># split into standard weeks</span>
	train, test = data[<span class="hljs-number">1</span>:<span class="hljs-number">-328</span>], data[<span class="hljs-number">-328</span>:<span class="hljs-number">-6</span>]
	<span class="hljs-comment"># restructure into windows of weekly data</span>
	train = array(split(train, len(train)/<span class="hljs-number">7</span>))<font></font>
	test = array(split(test, len(test)/<span class="hljs-number">7</span>))
	<span class="hljs-keyword">return</span> train, test<font></font>
<font></font>
<span class="hljs-comment"># evaluate one or more weekly forecasts against expected values</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate_forecasts</span>(<span class="hljs-params">actual, predicted</span>):</span><font></font>
	scores = list()<font></font>
	<span class="hljs-comment"># calculate an RMSE score for each day</span>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">1</span>]):
		<span class="hljs-comment"># calculate mse</span><font></font>
		mse = mean_squared_error(actual[:, i], predicted[:, i])<font></font>
		<span class="hljs-comment"># calculate rmse</span><font></font>
		rmse = sqrt(mse)<font></font>
		<span class="hljs-comment"># store</span><font></font>
		scores.append(rmse)<font></font>
	<span class="hljs-comment"># calculate overall RMSE</span>
	s = <span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">0</span>]):
		<span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">1</span>]):<font></font>
			s += (actual[row, col] - predicted[row, col])**<span class="hljs-number">2</span>
	score = sqrt(s / (actual.shape[<span class="hljs-number">0</span>] * actual.shape[<span class="hljs-number">1</span>]))
	<span class="hljs-keyword">return</span> score, scores<font></font>
<font></font>
<span class="hljs-comment"># summarize scores</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">summarize_scores</span>(<span class="hljs-params">name, score, scores</span>):</span>
	s_scores = <span class="hljs-string">', '</span>.join([<span class="hljs-string">'%.1f'</span> % s <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> scores])<font></font>
	print(<span class="hljs-string">'%s: [%.3f] %s'</span> % (name, score, s_scores))<font></font>
<font></font>
<span class="hljs-comment"># convert history into inputs and outputs</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_supervised</span>(<span class="hljs-params">train, n_input, n_out=<span class="hljs-number">7</span></span>):</span>
	<span class="hljs-comment"># flatten data</span>
	data = train.reshape((train.shape[<span class="hljs-number">0</span>]*train.shape[<span class="hljs-number">1</span>], train.shape[<span class="hljs-number">2</span>]))<font></font>
	X, y = list(), list()<font></font>
	in_start = <span class="hljs-number">0</span>
	<span class="hljs-comment"># step over the entire history one time step at a time</span>
	<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(len(data)):
		<span class="hljs-comment"># define the end of the input sequence</span><font></font>
		in_end = in_start + n_input<font></font>
		out_end = in_end + n_out<font></font>
		<span class="hljs-comment"># ensure we have enough data for this instance</span>
		<span class="hljs-keyword">if</span> out_end &lt;= len(data):<font></font>
			X.append(data[in_start:in_end, :])<font></font>
			y.append(data[in_end:out_end, <span class="hljs-number">0</span>])
		<span class="hljs-comment"># move along one time step</span>
		in_start += <span class="hljs-number">1</span>
	<span class="hljs-keyword">return</span> array(X), array(y)<font></font>
<font></font>
<span class="hljs-comment"># train the model</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_model</span>(<span class="hljs-params">train, n_input</span>):</span>
	<span class="hljs-comment"># prepare data</span><font></font>
	train_x, train_y = to_supervised(train, n_input)<font></font>
	<span class="hljs-comment"># define parameters</span>
	verbose, epochs, batch_size = <span class="hljs-number">0</span>, <span class="hljs-number">50</span>, <span class="hljs-number">16</span>
	n_timesteps, n_features, n_outputs = train_x.shape[<span class="hljs-number">1</span>], train_x.shape[<span class="hljs-number">2</span>], train_y.shape[<span class="hljs-number">1</span>]
	<span class="hljs-comment"># reshape output into [samples, timesteps, features]</span>
	train_y = train_y.reshape((train_y.shape[<span class="hljs-number">0</span>], train_y.shape[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>))
	<span class="hljs-comment"># define model</span><font></font>
	model = Sequential()<font></font>
	model.add(LSTM(<span class="hljs-number">200</span>, activation=<span class="hljs-string">'relu'</span>, input_shape=(n_timesteps, n_features)))<font></font>
	model.add(RepeatVector(n_outputs))<font></font>
	model.add(LSTM(<span class="hljs-number">200</span>, activation=<span class="hljs-string">'relu'</span>, return_sequences=<span class="hljs-literal">True</span>))<font></font>
	model.add(TimeDistributed(Dense(<span class="hljs-number">100</span>, activation=<span class="hljs-string">'relu'</span>)))<font></font>
	model.add(TimeDistributed(Dense(<span class="hljs-number">1</span>)))<font></font>
	model.compile(loss=<span class="hljs-string">'mse'</span>, optimizer=<span class="hljs-string">'adam'</span>)
	<span class="hljs-comment"># fit network</span><font></font>
	model.fit(train_x, train_y, epochs=epochs, batch_size=batch_size, verbose=verbose)<font></font>
	<span class="hljs-keyword">return</span> model<font></font>
<font></font>
<span class="hljs-comment"># make a forecast</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forecast</span>(<span class="hljs-params">model, history, n_input</span>):</span>
	<span class="hljs-comment"># flatten data</span><font></font>
	data = array(history)<font></font>
	data = data.reshape((data.shape[<span class="hljs-number">0</span>]*data.shape[<span class="hljs-number">1</span>], data.shape[<span class="hljs-number">2</span>]))
	<span class="hljs-comment"># retrieve last observations for input data</span><font></font>
	input_x = data[-n_input:, :]<font></font>
	<span class="hljs-comment"># reshape into [1, n_input, n]</span>
	input_x = input_x.reshape((<span class="hljs-number">1</span>, input_x.shape[<span class="hljs-number">0</span>], input_x.shape[<span class="hljs-number">1</span>]))
	<span class="hljs-comment"># forecast the next week</span>
	yhat = model.predict(input_x, verbose=<span class="hljs-number">0</span>)
	<span class="hljs-comment"># we only want the vector forecast</span>
	yhat = yhat[<span class="hljs-number">0</span>]
	<span class="hljs-keyword">return</span> yhat<font></font>
<font></font>
<span class="hljs-comment"># evaluate a single model</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate_model</span>(<span class="hljs-params">train, test, n_input</span>):</span>
	<span class="hljs-comment"># fit model</span><font></font>
	model = build_model(train, n_input)<font></font>
	<span class="hljs-comment"># history is a list of weekly data</span>
	history = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> train]
	<span class="hljs-comment"># walk-forward validation over each week</span><font></font>
	predictions = list()<font></font>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(test)):
		<span class="hljs-comment"># predict the week</span><font></font>
		yhat_sequence = forecast(model, history, n_input)<font></font>
		<span class="hljs-comment"># store the predictions</span><font></font>
		predictions.append(yhat_sequence)<font></font>
		<span class="hljs-comment"># get real observation and add to history for predicting the next week</span><font></font>
		history.append(test[i, :])<font></font>
	<span class="hljs-comment"># evaluate predictions days for each week</span><font></font>
	predictions = array(predictions)<font></font>
	score, scores = evaluate_forecasts(test[:, :, <span class="hljs-number">0</span>], predictions)
	<span class="hljs-keyword">return</span> score, scores<font></font>
<font></font>
<span class="hljs-comment"># load the new file</span>
dataset = read_csv(<span class="hljs-string">'household_power_consumption_days.csv'</span>, header=<span class="hljs-number">0</span>, infer_datetime_format=<span class="hljs-literal">True</span>, parse_dates=[<span class="hljs-string">'datetime'</span>], index_col=[<span class="hljs-string">'datetime'</span>])
<span class="hljs-comment"># split into train and test</span><font></font>
train, test = split_dataset(dataset.values)<font></font>
<span class="hljs-comment"># evaluate model and get scores</span>
n_input = <span class="hljs-number">14</span><font></font>
score, scores = evaluate_model(train, test, n_input)<font></font>
<span class="hljs-comment"># summarize scores</span>
summarize_scores(<span class="hljs-string">'lstm'</span>, score, scores)
<span class="hljs-comment"># plot scores</span>
days = [<span class="hljs-string">'sun'</span>, <span class="hljs-string">'mon'</span>, <span class="hljs-string">'tue'</span>, <span class="hljs-string">'wed'</span>, <span class="hljs-string">'thr'</span>, <span class="hljs-string">'fri'</span>, <span class="hljs-string">'sat'</span>]<font></font>
pyplot.plot(days, scores, marker=<span class="hljs-string">'o'</span>, label=<span class="hljs-string">'lstm'</span>)<font></font>
pyplot.show()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード実行は、モデルとその評価のトレーニングを、データセットの検証部分の1週間の合計RMSE値と予測の各日のRMSE値とともに行表示の形式で提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この実験では、多次元入力データに基づく「エンコーダー-デコーダー」タイプのDCTモデルは、1次元モデルよりも安定性が低いように見えます。</font><font style="vertical-align: inherit;">これは、入力フィーチャデータのスケールが異なることが原因である可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムの確率的性質により、結果は以下に示すものと異なる場合があります。</font><font style="vertical-align: inherit;">コードを数回実行することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、モデルは単純なモデルよりも予測にうまく対応したことがわかります。合計RMSE値は約376キロワットです。</font></font><br>
<br>
<pre><code class="python hljs">lstm: [<span class="hljs-number">376.273</span>] <span class="hljs-number">378.5</span>, <span class="hljs-number">381.5</span>, <span class="hljs-number">328.4</span>, <span class="hljs-number">388.3</span>, <span class="hljs-number">361.2</span>, <span class="hljs-number">308.0</span>, <span class="hljs-number">467.2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、予測週の各日のRMSEチャートです。</font></font><br>
<img src="https://habrastorage.org/getpro/habr/post_images/912/cfc/c36/912cfcc36f0d0928f5b5bd3db8cd8f67.png" alt="画像"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1次元入力データに基づくエンコーダーとして畳み込み層を追加した「エンコーダー-デコーダー」タイプのDCT</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
畳み込みニューラルネットワーク（SNA）は、「エンコーダーデコーダー」タイプのDCTアーキテクチャーのエンコーダーとして使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、SNAはシーケンスの形式でのデータ入力を直接サポートしていません。</font><font style="vertical-align: inherit;">代わりに、1次元SNAは、入力シーケンスの要素を順次読み取り、自動的に特性を調査することができます</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（実際、畳み込みは、イメージのテンソルではなく、入力シーケンスに沿って移動する、重なり合うスライディングウィンドウの方法によって</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能します</font><i><font style="vertical-align: inherit;">。-近似</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次に、通常どおりDCTデコーダーによって解釈されます。</font><font style="vertical-align: inherit;">SNAとDCTの併用は、ハイブリッドモデル（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SNA-DCT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">指し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DCTモデルと同様に、SNAは入力で3次元のテンソルを受け入れます。各サインのみが個別のチャネルとして読み取られ、最終的に同じ効果があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SNA-DCTの1次元モデルに焦点を当てて、例を簡略化します。ただし、モデルは簡単に更新してすべての機能を使用できます（演習として残しました）。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kerasでは、Conv1Dレイヤーを使用して1次元たたみ込みネットワークが作成されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
畳み込みウィンドウは、時間軸上の1次元ウィンドウです。入力テンソルのインデックス1を持つ軸。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出典：Pythonのディープラーニング、Francois Scholl。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
以前と同様に、14日間の総エネルギー消費量が入力として使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シンプルで同時に効果的なSNAアーキテクチャーを、2つの畳み込みレベルと、それに続く最大ユニオンレイヤー</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（MaxPooling1D）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">構成されるエンコーダーとして定義し</font><font style="vertical-align: inherit;">、その結果をさらに平滑化します。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最大プーリングは、隣接する値から最大値を選択する操作です。その目的は、「スペースで折り畳むのと同じように、フィーチャマップの解像度を積極的に下げること」です。 F.ショールによる本の詳細。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の畳み込み層は、入力シーケンスの要素を順番に読み取り、結果を属性カードに投影します。 2番目のたたみ込み層は同じ操作を実行しますが、唯一の違いは、最初の層によって作成されたフィーチャカードで読み取りが既に実行されているため、重要な特性を強化しようとすることです。各畳み込み層は64個のフィルターを使用し、カーネルサイズが3つのタイムステップで入力シーケンスを読み取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最大結合レイヤーは、機能マップの変換を単純化し、最大（最大）信号で値を保存します。レイヤーを最大にマージした後、抽出された特徴マップは1つの長いベクトルに変換され、デコードプロセスの入力として使用されます。</font></font><br>
<br>
<pre><code class="python hljs">model.add(Conv1D(filters=<span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>, input_shape=(n_timesteps,n_features)))<font></font>
model.add(Conv1D(filters=<span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>))<font></font>
model.add(MaxPooling1D(pool_size=<span class="hljs-number">2</span>))<font></font>
model.add(Flatten())</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デコーダーの定義は、前のセクションと同様です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
唯一の追加の変更は、訓練年数を20に設定することです。</font><font style="vertical-align: inherit;">これらの変更を考慮した</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
、更新された</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">build_model（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を</font><font style="vertical-align: inherit;">以下に示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># train the model</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_model</span>(<span class="hljs-params">train, n_input</span>):</span>
	<span class="hljs-comment"># prepare data</span><font></font>
	train_x, train_y = to_supervised(train, n_input)<font></font>
	<span class="hljs-comment"># define parameters</span>
	verbose, epochs, batch_size = <span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">16</span>
	n_timesteps, n_features, n_outputs = train_x.shape[<span class="hljs-number">1</span>], train_x.shape[<span class="hljs-number">2</span>], train_y.shape[<span class="hljs-number">1</span>]
	<span class="hljs-comment"># reshape output into [samples, timesteps, features]</span>
	train_y = train_y.reshape((train_y.shape[<span class="hljs-number">0</span>], train_y.shape[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>))
	<span class="hljs-comment"># define model</span><font></font>
	model = Sequential()<font></font>
	model.add(Conv1D(filters=<span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>, input_shape=(n_timesteps,n_features)))<font></font>
	model.add(Conv1D(filters=<span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>))<font></font>
	model.add(MaxPooling1D(pool_size=<span class="hljs-number">2</span>))<font></font>
	model.add(Flatten())<font></font>
	model.add(RepeatVector(n_outputs))<font></font>
	model.add(LSTM(<span class="hljs-number">200</span>, activation=<span class="hljs-string">'relu'</span>, return_sequences=<span class="hljs-literal">True</span>))<font></font>
	model.add(TimeDistributed(Dense(<span class="hljs-number">100</span>, activation=<span class="hljs-string">'relu'</span>)))<font></font>
	model.add(TimeDistributed(Dense(<span class="hljs-number">1</span>)))<font></font>
	model.compile(loss=<span class="hljs-string">'mse'</span>, optimizer=<span class="hljs-string">'adam'</span>)
	<span class="hljs-comment"># fit network</span><font></font>
	model.fit(train_x, train_y, epochs=epochs, batch_size=batch_size, verbose=verbose)<font></font>
	<span class="hljs-keyword">return</span> model</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、すべてが畳み込み層をエンコーダとして持つ「エンコーダ/デコーダ」アーキテクチャを体験する準備が整いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンコーダーとしてたたみ込み層を追加した「エンコーダー-デコーダー」タイプの1次元DCTモデルの完全なコード例を以下に示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># univariate multi-step encoder-decoder cnn-lstm</span>
<span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt
<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> split
<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> array
<span class="hljs-keyword">from</span> pandas <span class="hljs-keyword">import</span> read_csv
<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error
<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot
<span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Dense
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Flatten
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> LSTM
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> RepeatVector
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> TimeDistributed
<span class="hljs-keyword">from</span> keras.layers.convolutional <span class="hljs-keyword">import</span> Conv1D
<span class="hljs-keyword">from</span> keras.layers.convolutional <span class="hljs-keyword">import</span> MaxPooling1D<font></font>
<font></font>
<span class="hljs-comment"># split a univariate dataset into train/test sets</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">split_dataset</span>(<span class="hljs-params">data</span>):</span>
	<span class="hljs-comment"># split into standard weeks</span>
	train, test = data[<span class="hljs-number">1</span>:<span class="hljs-number">-328</span>], data[<span class="hljs-number">-328</span>:<span class="hljs-number">-6</span>]
	<span class="hljs-comment"># restructure into windows of weekly data</span>
	train = array(split(train, len(train)/<span class="hljs-number">7</span>))<font></font>
	test = array(split(test, len(test)/<span class="hljs-number">7</span>))
	<span class="hljs-keyword">return</span> train, test<font></font>
<font></font>
<span class="hljs-comment"># evaluate one or more weekly forecasts against expected values</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate_forecasts</span>(<span class="hljs-params">actual, predicted</span>):</span><font></font>
	scores = list()<font></font>
	<span class="hljs-comment"># calculate an RMSE score for each day</span>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">1</span>]):
		<span class="hljs-comment"># calculate mse</span><font></font>
		mse = mean_squared_error(actual[:, i], predicted[:, i])<font></font>
		<span class="hljs-comment"># calculate rmse</span><font></font>
		rmse = sqrt(mse)<font></font>
		<span class="hljs-comment"># store</span><font></font>
		scores.append(rmse)<font></font>
	<span class="hljs-comment"># calculate overall RMSE</span>
	s = <span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">0</span>]):
		<span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">1</span>]):<font></font>
			s += (actual[row, col] - predicted[row, col])**<span class="hljs-number">2</span>
	score = sqrt(s / (actual.shape[<span class="hljs-number">0</span>] * actual.shape[<span class="hljs-number">1</span>]))
	<span class="hljs-keyword">return</span> score, scores<font></font>
<font></font>
<span class="hljs-comment"># summarize scores</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">summarize_scores</span>(<span class="hljs-params">name, score, scores</span>):</span>
	s_scores = <span class="hljs-string">', '</span>.join([<span class="hljs-string">'%.1f'</span> % s <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> scores])<font></font>
	print(<span class="hljs-string">'%s: [%.3f] %s'</span> % (name, score, s_scores))<font></font>
<font></font>
<span class="hljs-comment"># convert history into inputs and outputs</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_supervised</span>(<span class="hljs-params">train, n_input, n_out=<span class="hljs-number">7</span></span>):</span>
	<span class="hljs-comment"># flatten data</span>
	data = train.reshape((train.shape[<span class="hljs-number">0</span>]*train.shape[<span class="hljs-number">1</span>], train.shape[<span class="hljs-number">2</span>]))<font></font>
	X, y = list(), list()<font></font>
	in_start = <span class="hljs-number">0</span>
	<span class="hljs-comment"># step over the entire history one time step at a time</span>
	<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(len(data)):
		<span class="hljs-comment"># define the end of the input sequence</span><font></font>
		in_end = in_start + n_input<font></font>
		out_end = in_end + n_out<font></font>
		<span class="hljs-comment"># ensure we have enough data for this instance</span>
		<span class="hljs-keyword">if</span> out_end &lt;= len(data):<font></font>
			x_input = data[in_start:in_end, <span class="hljs-number">0</span>]<font></font>
			x_input = x_input.reshape((len(x_input), <span class="hljs-number">1</span>))<font></font>
			X.append(x_input)<font></font>
			y.append(data[in_end:out_end, <span class="hljs-number">0</span>])
		<span class="hljs-comment"># move along one time step</span>
		in_start += <span class="hljs-number">1</span>
	<span class="hljs-keyword">return</span> array(X), array(y)<font></font>
<font></font>
<span class="hljs-comment"># train the model</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_model</span>(<span class="hljs-params">train, n_input</span>):</span>
	<span class="hljs-comment"># prepare data</span><font></font>
	train_x, train_y = to_supervised(train, n_input)<font></font>
	<span class="hljs-comment"># define parameters</span>
	verbose, epochs, batch_size = <span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">16</span>
	n_timesteps, n_features, n_outputs = train_x.shape[<span class="hljs-number">1</span>], train_x.shape[<span class="hljs-number">2</span>], train_y.shape[<span class="hljs-number">1</span>]
	<span class="hljs-comment"># reshape output into [samples, timesteps, features]</span>
	train_y = train_y.reshape((train_y.shape[<span class="hljs-number">0</span>], train_y.shape[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>))
	<span class="hljs-comment"># define model</span><font></font>
	model = Sequential()<font></font>
	model.add(Conv1D(filters=<span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>, input_shape=(n_timesteps,n_features)))<font></font>
	model.add(Conv1D(filters=<span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">3</span>, activation=<span class="hljs-string">'relu'</span>))<font></font>
	model.add(MaxPooling1D(pool_size=<span class="hljs-number">2</span>))<font></font>
	model.add(Flatten())<font></font>
	model.add(RepeatVector(n_outputs))<font></font>
	model.add(LSTM(<span class="hljs-number">200</span>, activation=<span class="hljs-string">'relu'</span>, return_sequences=<span class="hljs-literal">True</span>))<font></font>
	model.add(TimeDistributed(Dense(<span class="hljs-number">100</span>, activation=<span class="hljs-string">'relu'</span>)))<font></font>
	model.add(TimeDistributed(Dense(<span class="hljs-number">1</span>)))<font></font>
	model.compile(loss=<span class="hljs-string">'mse'</span>, optimizer=<span class="hljs-string">'adam'</span>)
	<span class="hljs-comment"># fit network</span><font></font>
	model.fit(train_x, train_y, epochs=epochs, batch_size=batch_size, verbose=verbose)<font></font>
	<span class="hljs-keyword">return</span> model<font></font>
<font></font>
<span class="hljs-comment"># make a forecast</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forecast</span>(<span class="hljs-params">model, history, n_input</span>):</span>
	<span class="hljs-comment"># flatten data</span><font></font>
	data = array(history)<font></font>
	data = data.reshape((data.shape[<span class="hljs-number">0</span>]*data.shape[<span class="hljs-number">1</span>], data.shape[<span class="hljs-number">2</span>]))
	<span class="hljs-comment"># retrieve last observations for input data</span>
	input_x = data[-n_input:, <span class="hljs-number">0</span>]
	<span class="hljs-comment"># reshape into [1, n_input, 1]</span>
	input_x = input_x.reshape((<span class="hljs-number">1</span>, len(input_x), <span class="hljs-number">1</span>))
	<span class="hljs-comment"># forecast the next week</span>
	yhat = model.predict(input_x, verbose=<span class="hljs-number">0</span>)
	<span class="hljs-comment"># we only want the vector forecast</span>
	yhat = yhat[<span class="hljs-number">0</span>]
	<span class="hljs-keyword">return</span> yhat<font></font>
<font></font>
<span class="hljs-comment"># evaluate a single model</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate_model</span>(<span class="hljs-params">train, test, n_input</span>):</span>
	<span class="hljs-comment"># fit model</span><font></font>
	model = build_model(train, n_input)<font></font>
	<span class="hljs-comment"># history is a list of weekly data</span>
	history = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> train]
	<span class="hljs-comment"># walk-forward validation over each week</span><font></font>
	predictions = list()<font></font>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(test)):
		<span class="hljs-comment"># predict the week</span><font></font>
		yhat_sequence = forecast(model, history, n_input)<font></font>
		<span class="hljs-comment"># store the predictions</span><font></font>
		predictions.append(yhat_sequence)<font></font>
		<span class="hljs-comment"># get real observation and add to history for predicting the next week</span><font></font>
		history.append(test[i, :])<font></font>
	<span class="hljs-comment"># evaluate predictions days for each week</span><font></font>
	predictions = array(predictions)<font></font>
	score, scores = evaluate_forecasts(test[:, :, <span class="hljs-number">0</span>], predictions)
	<span class="hljs-keyword">return</span> score, scores<font></font>
<font></font>
<span class="hljs-comment"># load the new file</span>
dataset = read_csv(<span class="hljs-string">'household_power_consumption_days.csv'</span>, header=<span class="hljs-number">0</span>, infer_datetime_format=<span class="hljs-literal">True</span>, parse_dates=[<span class="hljs-string">'datetime'</span>], index_col=[<span class="hljs-string">'datetime'</span>])
<span class="hljs-comment"># split into train and test</span><font></font>
train, test = split_dataset(dataset.values)<font></font>
<span class="hljs-comment"># evaluate model and get scores</span>
n_input = <span class="hljs-number">14</span><font></font>
score, scores = evaluate_model(train, test, n_input)<font></font>
<span class="hljs-comment"># summarize scores</span>
summarize_scores(<span class="hljs-string">'lstm'</span>, score, scores)
<span class="hljs-comment"># plot scores</span>
days = [<span class="hljs-string">'sun'</span>, <span class="hljs-string">'mon'</span>, <span class="hljs-string">'tue'</span>, <span class="hljs-string">'wed'</span>, <span class="hljs-string">'thr'</span>, <span class="hljs-string">'fri'</span>, <span class="hljs-string">'sat'</span>]<font></font>
pyplot.plot(days, scores, marker=<span class="hljs-string">'o'</span>, label=<span class="hljs-string">'lstm'</span>)<font></font>
pyplot.show()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード実行は、モデルとその評価のトレーニングを、データセットの検証部分の1週間の合計RMSE値と予測の各日のRMSE値とともに行表示の形式で提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
小さな実験では、2つの畳み込み層を使用すると、1つの層だけを使用するよりもモデルが安定することがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムの確率的性質により、結果は以下に示すものと異なる場合があります。</font><font style="vertical-align: inherit;">コードを数回実行することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、モデルは単純なモデルよりも予測にうまく対応したことがわかります。合計RMSE値は約372キロワットです。</font></font><br>
<br>
<pre><code class="python hljs">lstm: [<span class="hljs-number">372.055</span>] <span class="hljs-number">383.8</span>, <span class="hljs-number">381.6</span>, <span class="hljs-number">339.1</span>, <span class="hljs-number">371.8</span>, <span class="hljs-number">371.8</span>, <span class="hljs-number">319.6</span>, <span class="hljs-number">427.2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、予測週の各日のRMSEチャートです。</font></font><br>
<img src="https://habrastorage.org/getpro/habr/post_images/a04/650/8a9/a046508a945502abb120a429e7c186f6.png" alt="画像"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1次元入力データに基づく「エンコーダー/デコーダー」タイプのたたみ込みDCT</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SNA-DCTアプローチの拡張は、各時間間隔のDCTの一部として、SNAのたたみ込み（たとえば、SNAが入力シーケンスデータを読み取る方法）の実装です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この組み合わせは「たたみ込みDCT」と呼ばれます</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（英語の用語では、たたみ込みLSTM、または略してConvLSTM。-およそ。）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 SNA-DCTと同様に、時空間データにも使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データを直接読み取って内部状態と状態遷移を計算するDCTモデルや、SNSモデルの出力を解釈するSNS-DCTモデルとは異なり、畳み込みDCTは、LSTMセルの入力データの読み取りの一部として直接畳み込みを使用します。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（つまり、入力だけでなく、反復変換もたたみ込みされます。つまり、内部行列はたたみ込み演算に置き換えられます。その結果、たたみ込みDCTセルを通過するデータは、1次元ベクトルではなく入力次元を保持します。-注。あたり）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たたみ込みDCTの方程式の導出方法に関するより完全な情報は、次の記事に記載されています。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DCT畳み込みネットワーク：2015年の現在の天気を予測するための新しい機械学習アプローチ。</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keras</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ライブラリは、</font><font style="vertical-align: inherit;">2次元データ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（2次元画像（幅と高さ）を意味し</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font><i><font style="vertical-align: inherit;">）に</font></i><font style="vertical-align: inherit;">基づいて畳み込みDCTを</font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">操作する</font></a></i><font style="vertical-align: inherit;">ための</font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ConvLSTM2D</font></a></i><font style="vertical-align: inherit;">と呼ばれるクラスを提供します</font><font style="vertical-align: inherit;">。 1次元の時系列（1D）を予測するように構成することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デフォルトでは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConvLSTM2D</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">は、入力が次の</font><font style="vertical-align: inherit;">形式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（5次元-約Per。）である</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と想定しています</font><i><font style="vertical-align: inherit;">。</font></i></font><br>
<br>
<pre><code class="python hljs">[,  , , , ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各時間間隔は、ポイント（ピクセル）の形式の画像（行*列）として定義されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
過去2週間の日次データを入力として使用するとします。総エネルギー消費量の1次元シーケンスで作業しているため、14列の単一行として解釈できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、たたみ込みDCTは1回の読み取りを実行します。DCTは14日間の1つの時間間隔を読み取り、それらに対してたたみ込み演算を実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは完璧ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代わりに、14日間のシーケンスをそれぞれ7日間の2つのサブシーケンスに分割できます。</font><font style="vertical-align: inherit;">次に、たたみ込みDCTは、7日間の2つの時間間隔の要素を順次読み取り、それぞれの要素でたたみ込み操作を実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、割り当てられたタスクを考慮すると、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConvLSTM2D</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイヤーの入力は</font><i><font style="vertical-align: inherit;">次の</font></i><font style="vertical-align: inherit;">ようになります。</font></font><br>
<br>
<pre><code class="python hljs">[n, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または：</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプル</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：n、データセットのトレーニング部分にある例の数。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：2、14日間のシーケンスを分割した2つのサブシーケンス。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lines</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：1、各サブシーケンスの1次元形式。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：7、各サブシーケンスで7日。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チャネル</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：1、入力として使用される単一の機能。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他の可能な構成を探索できます。たとえば、入力モデルのデータを21日間、それぞれ7日間の3つのサブシーケンスの形式で送信したり、8つのサイン（チャネル）でデータを提供したりできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConvLSTM2D</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルのデータを準備します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、データセットのトレーニング部分の形式を、モデルが期待する5次元構造</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[サンプル、時間間隔、行、列、チャネル]に変更する必要があり</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># reshape into subsequences [samples, time steps, rows, cols, channels]</span>
train_x = train_x.reshape((train_x.shape[<span class="hljs-number">0</span>], n_steps, <span class="hljs-number">1</span>, n_length, n_features))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、畳み込みDCT（最初の非表示レイヤー）をエンコーダーとして定義し、その後にデータ平滑化レイヤーを定義して、デコードの準備をします。</font></font><br>
<br>
<pre><code class="ruby hljs">model.add(ConvLSTM2D(filters=<span class="hljs-number">64</span>, kernel_size=(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>, input_shape=(n_steps, <span class="hljs-number">1</span>, n_length, n_features)))<font></font>
model.add(Flatten())</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サブシーケンスの数（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n_steps</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）と各サブシーケンスの長さ（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n_length</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）が強調表示され、関数の引数として表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それ以外は、モデルの構成とそのトレーニングは前のセクションと同様です。</font><font style="vertical-align: inherit;">これらの変更を考慮した</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">build_model（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を</font><font style="vertical-align: inherit;">以下に示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># train the model</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_model</span>(<span class="hljs-params">train, n_steps, n_length, n_input</span>):</span>
	<span class="hljs-comment"># prepare data</span><font></font>
	train_x, train_y = to_supervised(train, n_input)<font></font>
	<span class="hljs-comment"># define parameters</span>
	verbose, epochs, batch_size = <span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">16</span>
	n_timesteps, n_features, n_outputs = train_x.shape[<span class="hljs-number">1</span>], train_x.shape[<span class="hljs-number">2</span>], train_y.shape[<span class="hljs-number">1</span>]
	<span class="hljs-comment"># reshape into subsequences [samples, time steps, rows, cols, channels]</span>
	train_x = train_x.reshape((train_x.shape[<span class="hljs-number">0</span>], n_steps, <span class="hljs-number">1</span>, n_length, n_features))
	<span class="hljs-comment"># reshape output into [samples, timesteps, features]</span>
	train_y = train_y.reshape((train_y.shape[<span class="hljs-number">0</span>], train_y.shape[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>))
	<span class="hljs-comment"># define model</span><font></font>
	model = Sequential()<font></font>
	model.add(ConvLSTM2D(filters=<span class="hljs-number">64</span>, kernel_size=(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>, input_shape=(n_steps, <span class="hljs-number">1</span>, n_length, n_features)))<font></font>
	model.add(Flatten())<font></font>
	model.add(RepeatVector(n_outputs))<font></font>
	model.add(LSTM(<span class="hljs-number">200</span>, activation=<span class="hljs-string">'relu'</span>, return_sequences=<span class="hljs-literal">True</span>))<font></font>
	model.add(TimeDistributed(Dense(<span class="hljs-number">100</span>, activation=<span class="hljs-string">'relu'</span>)))<font></font>
	model.add(TimeDistributed(Dense(<span class="hljs-number">1</span>)))<font></font>
	model.compile(loss=<span class="hljs-string">'mse'</span>, optimizer=<span class="hljs-string">'adam'</span>)
	<span class="hljs-comment"># fit network</span><font></font>
	model.fit(train_x, train_y, epochs=epochs, batch_size=batch_size, verbose=verbose)<font></font>
	<span class="hljs-keyword">return</span> model</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このモデルは、入力として5次元データを想定しています。</font><font style="vertical-align: inherit;">したがって、</font><font style="vertical-align: inherit;">その後の予測のため</font><font style="vertical-align: inherit;">に、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forecast（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">サンプル準備を更新することも必要</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># reshape into [samples, time steps, rows, cols, channels]</span>
input_x = input_x.reshape((<span class="hljs-number">1</span>, n_steps, <span class="hljs-number">1</span>, n_length, <span class="hljs-number">1</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この変更を考慮</font><font style="vertical-align: inherit;">し、引数として</font><i><font style="vertical-align: inherit;">n_steps</font></i><font style="vertical-align: inherit;">および</font><i><font style="vertical-align: inherit;">n_length</font></i><font style="vertical-align: inherit;">パラメーター</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">強調表示する</font><font style="vertical-align: inherit;">
更新された</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予測（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を</font><font style="vertical-align: inherit;">以下に示します。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># make a forecast</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forecast</span>(<span class="hljs-params">model, history, n_steps, n_length, n_input</span>):</span>
	<span class="hljs-comment"># flatten data</span><font></font>
	data = array(history)<font></font>
	data = data.reshape((data.shape[<span class="hljs-number">0</span>]*data.shape[<span class="hljs-number">1</span>], data.shape[<span class="hljs-number">2</span>]))
	<span class="hljs-comment"># retrieve last observations for input data</span>
	input_x = data[-n_input:, <span class="hljs-number">0</span>]
	<span class="hljs-comment"># reshape into [samples, time steps, rows, cols, channels]</span>
	input_x = input_x.reshape((<span class="hljs-number">1</span>, n_steps, <span class="hljs-number">1</span>, n_length, <span class="hljs-number">1</span>))
	<span class="hljs-comment"># forecast the next week</span>
	yhat = model.predict(input_x, verbose=<span class="hljs-number">0</span>)
	<span class="hljs-comment"># we only want the vector forecast</span>
	yhat = yhat[<span class="hljs-number">0</span>]
	<span class="hljs-keyword">return</span> yhat</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、畳み込みDCTがエンコーダーとして使用される、インターバル時系列予測の「エンコーダー/デコーダー」アーキテクチャーの評価を開始するためのすべての要素が揃いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「エンコーダーデコーダー」タイプのDCTの1次元たたみ込みモデルの完全なコード例を以下に示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># univariate multi-step encoder-decoder convlstm</span>
<span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt
<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> split
<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> array
<span class="hljs-keyword">from</span> pandas <span class="hljs-keyword">import</span> read_csv
<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error
<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot
<span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Dense
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Flatten
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> LSTM
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> RepeatVector
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> TimeDistributed
<span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> ConvLSTM2D<font></font>
<font></font>
<span class="hljs-comment"># split a univariate dataset into train/test sets</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">split_dataset</span>(<span class="hljs-params">data</span>):</span>
	<span class="hljs-comment"># split into standard weeks</span>
	train, test = data[<span class="hljs-number">1</span>:<span class="hljs-number">-328</span>], data[<span class="hljs-number">-328</span>:<span class="hljs-number">-6</span>]
	<span class="hljs-comment"># restructure into windows of weekly data</span>
	train = array(split(train, len(train)/<span class="hljs-number">7</span>))<font></font>
	test = array(split(test, len(test)/<span class="hljs-number">7</span>))
	<span class="hljs-keyword">return</span> train, test<font></font>
<font></font>
<span class="hljs-comment"># evaluate one or more weekly forecasts against expected values</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate_forecasts</span>(<span class="hljs-params">actual, predicted</span>):</span><font></font>
	scores = list()<font></font>
	<span class="hljs-comment"># calculate an RMSE score for each day</span>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">1</span>]):
		<span class="hljs-comment"># calculate mse</span><font></font>
		mse = mean_squared_error(actual[:, i], predicted[:, i])<font></font>
		<span class="hljs-comment"># calculate rmse</span><font></font>
		rmse = sqrt(mse)<font></font>
		<span class="hljs-comment"># store</span><font></font>
		scores.append(rmse)<font></font>
	<span class="hljs-comment"># calculate overall RMSE</span>
	s = <span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">0</span>]):
		<span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> range(actual.shape[<span class="hljs-number">1</span>]):<font></font>
			s += (actual[row, col] - predicted[row, col])**<span class="hljs-number">2</span>
	score = sqrt(s / (actual.shape[<span class="hljs-number">0</span>] * actual.shape[<span class="hljs-number">1</span>]))
	<span class="hljs-keyword">return</span> score, scores<font></font>
<font></font>
<span class="hljs-comment"># summarize scores</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">summarize_scores</span>(<span class="hljs-params">name, score, scores</span>):</span>
	s_scores = <span class="hljs-string">', '</span>.join([<span class="hljs-string">'%.1f'</span> % s <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> scores])<font></font>
	print(<span class="hljs-string">'%s: [%.3f] %s'</span> % (name, score, s_scores))<font></font>
<font></font>
<span class="hljs-comment"># convert history into inputs and outputs</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_supervised</span>(<span class="hljs-params">train, n_input, n_out=<span class="hljs-number">7</span></span>):</span>
	<span class="hljs-comment"># flatten data</span>
	data = train.reshape((train.shape[<span class="hljs-number">0</span>]*train.shape[<span class="hljs-number">1</span>], train.shape[<span class="hljs-number">2</span>]))<font></font>
	X, y = list(), list()<font></font>
	in_start = <span class="hljs-number">0</span>
	<span class="hljs-comment"># step over the entire history one time step at a time</span>
	<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(len(data)):
		<span class="hljs-comment"># define the end of the input sequence</span><font></font>
		in_end = in_start + n_input<font></font>
		out_end = in_end + n_out<font></font>
		<span class="hljs-comment"># ensure we have enough data for this instance</span>
		<span class="hljs-keyword">if</span> out_end &lt;= len(data):<font></font>
			x_input = data[in_start:in_end, <span class="hljs-number">0</span>]<font></font>
			x_input = x_input.reshape((len(x_input), <span class="hljs-number">1</span>))<font></font>
			X.append(x_input)<font></font>
			y.append(data[in_end:out_end, <span class="hljs-number">0</span>])
		<span class="hljs-comment"># move along one time step</span>
		in_start += <span class="hljs-number">1</span>
	<span class="hljs-keyword">return</span> array(X), array(y)<font></font>
<font></font>
<span class="hljs-comment"># train the model</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_model</span>(<span class="hljs-params">train, n_steps, n_length, n_input</span>):</span>
	<span class="hljs-comment"># prepare data</span><font></font>
	train_x, train_y = to_supervised(train, n_input)<font></font>
	<span class="hljs-comment"># define parameters</span>
	verbose, epochs, batch_size = <span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">16</span>
	n_timesteps, n_features, n_outputs = train_x.shape[<span class="hljs-number">1</span>], train_x.shape[<span class="hljs-number">2</span>], train_y.shape[<span class="hljs-number">1</span>]
	<span class="hljs-comment"># reshape into subsequences [samples, time steps, rows, cols, channels]</span>
	train_x = train_x.reshape((train_x.shape[<span class="hljs-number">0</span>], n_steps, <span class="hljs-number">1</span>, n_length, n_features))
	<span class="hljs-comment"># reshape output into [samples, timesteps, features]</span>
	train_y = train_y.reshape((train_y.shape[<span class="hljs-number">0</span>], train_y.shape[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>))
	<span class="hljs-comment"># define model</span><font></font>
	model = Sequential()<font></font>
	model.add(ConvLSTM2D(filters=<span class="hljs-number">64</span>, kernel_size=(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>), activation=<span class="hljs-string">'relu'</span>, input_shape=(n_steps, <span class="hljs-number">1</span>, n_length, n_features)))<font></font>
	model.add(Flatten())<font></font>
	model.add(RepeatVector(n_outputs))<font></font>
	model.add(LSTM(<span class="hljs-number">200</span>, activation=<span class="hljs-string">'relu'</span>, return_sequences=<span class="hljs-literal">True</span>))<font></font>
	model.add(TimeDistributed(Dense(<span class="hljs-number">100</span>, activation=<span class="hljs-string">'relu'</span>)))<font></font>
	model.add(TimeDistributed(Dense(<span class="hljs-number">1</span>)))<font></font>
	model.compile(loss=<span class="hljs-string">'mse'</span>, optimizer=<span class="hljs-string">'adam'</span>)
	<span class="hljs-comment"># fit network</span><font></font>
	model.fit(train_x, train_y, epochs=epochs, batch_size=batch_size, verbose=verbose)<font></font>
	<span class="hljs-keyword">return</span> model<font></font>
<font></font>
<span class="hljs-comment"># make a forecast</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forecast</span>(<span class="hljs-params">model, history, n_steps, n_length, n_input</span>):</span>
	<span class="hljs-comment"># flatten data</span><font></font>
	data = array(history)<font></font>
	data = data.reshape((data.shape[<span class="hljs-number">0</span>]*data.shape[<span class="hljs-number">1</span>], data.shape[<span class="hljs-number">2</span>]))
	<span class="hljs-comment"># retrieve last observations for input data</span>
	input_x = data[-n_input:, <span class="hljs-number">0</span>]
	<span class="hljs-comment"># reshape into [samples, time steps, rows, cols, channels]</span>
	input_x = input_x.reshape((<span class="hljs-number">1</span>, n_steps, <span class="hljs-number">1</span>, n_length, <span class="hljs-number">1</span>))
	<span class="hljs-comment"># forecast the next week</span>
	yhat = model.predict(input_x, verbose=<span class="hljs-number">0</span>)
	<span class="hljs-comment"># we only want the vector forecast</span>
	yhat = yhat[<span class="hljs-number">0</span>]
	<span class="hljs-keyword">return</span> yhat<font></font>
<font></font>
<span class="hljs-comment"># evaluate a single model</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate_model</span>(<span class="hljs-params">train, test, n_steps, n_length, n_input</span>):</span>
	<span class="hljs-comment"># fit model</span><font></font>
	model = build_model(train, n_steps, n_length, n_input)<font></font>
	<span class="hljs-comment"># history is a list of weekly data</span>
	history = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> train]
	<span class="hljs-comment"># walk-forward validation over each week</span><font></font>
	predictions = list()<font></font>
	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(test)):
		<span class="hljs-comment"># predict the week</span><font></font>
		yhat_sequence = forecast(model, history, n_steps, n_length, n_input)<font></font>
		<span class="hljs-comment"># store the predictions</span><font></font>
		predictions.append(yhat_sequence)<font></font>
		<span class="hljs-comment"># get real observation and add to history for predicting the next week</span><font></font>
		history.append(test[i, :])<font></font>
	<span class="hljs-comment"># evaluate predictions days for each week</span><font></font>
	predictions = array(predictions)<font></font>
	score, scores = evaluate_forecasts(test[:, :, <span class="hljs-number">0</span>], predictions)
	<span class="hljs-keyword">return</span> score, scores<font></font>
<font></font>
<span class="hljs-comment"># load the new file</span>
dataset = read_csv(<span class="hljs-string">'household_power_consumption_days.csv'</span>, header=<span class="hljs-number">0</span>, infer_datetime_format=<span class="hljs-literal">True</span>, parse_dates=[<span class="hljs-string">'datetime'</span>], index_col=[<span class="hljs-string">'datetime'</span>])
<span class="hljs-comment"># split into train and test</span><font></font>
train, test = split_dataset(dataset.values)<font></font>
<span class="hljs-comment"># define the number of subsequences and the length of subsequences</span>
n_steps, n_length = <span class="hljs-number">2</span>, <span class="hljs-number">7</span>
<span class="hljs-comment"># define the total days to use as input</span><font></font>
n_input = n_length * n_steps<font></font>
score, scores = evaluate_model(train, test, n_steps, n_length, n_input)<font></font>
<span class="hljs-comment"># summarize scores</span>
summarize_scores(<span class="hljs-string">'lstm'</span>, score, scores)
<span class="hljs-comment"># plot scores</span>
days = [<span class="hljs-string">'sun'</span>, <span class="hljs-string">'mon'</span>, <span class="hljs-string">'tue'</span>, <span class="hljs-string">'wed'</span>, <span class="hljs-string">'thr'</span>, <span class="hljs-string">'fri'</span>, <span class="hljs-string">'sat'</span>]<font></font>
pyplot.plot(days, scores, marker=<span class="hljs-string">'o'</span>, label=<span class="hljs-string">'lstm'</span>)<font></font>
pyplot.show()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード実行は、モデルとその評価のトレーニングを、データセットの検証部分の1週間の合計RMSE値と予測の各日のRMSE値とともに行表示の形式で提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
小さな実験では、2つの畳み込み層を使用すると、1つの層のみを使用するよりもモデルが安定することがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、モデルが予測にうまく対応したことがわかります。合計RMSE値は約367キロワットです。</font></font><br>
<br>
<pre><code class="python hljs">lstm: [<span class="hljs-number">367.929</span>] <span class="hljs-number">416.3</span>, <span class="hljs-number">379.7</span>, <span class="hljs-number">334.7</span>, <span class="hljs-number">362.3</span>, <span class="hljs-number">374.7</span>, <span class="hljs-number">284.8</span>, <span class="hljs-number">406.7</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、予測週の各日のRMSEチャートです。</font></font><br>
<img src="https://habrastorage.org/getpro/habr/post_images/b42/d63/b34/b42d63b34f57e883c68dbb6b4c48f962.png" alt="画像"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加のタスク</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションでは、このガイドの範囲を超えていて、興味があると思われるいくつかのプロジェクトをリストします。</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入力の大きさ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">モデルへの入力として、より多いまたはより少ない日数で実験します-たとえば、3日、21日、30日以上。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルのデバッグ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">モデルの構造とハイパーパラメーターを調整して、平均してモデル予測の品質を向上させます。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データスケーリング</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">標準化や正規化などのデータのスケーリングが、提示されたDCTモデルの改善された予測品質とどのように相関しているかを確認します。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トレーニングと検証の過程での監視</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">DCTモデルの最適な構造とハイパーパラメーターを調整するために、トレーニングと検証の段階での学習曲線と標準誤差を使用してモデルの品質を制御します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでもこれらのタスクに到達する場合は、私に知らせてください</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（どうやら、作者は珍しい鳥がドニエプル川の真ん中に飛ぶことを知っています:)。</font><font style="vertical-align: inherit;">- 注意 </font><font style="vertical-align: inherit;">あたり）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推奨読書</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このトピックについてもっと学びたい人のために。</font><font style="vertical-align: inherit;">重要な情報源はここにリストされています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">刊行物</font></font></h4><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターバル時系列予測を実行するための4つの戦略</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リカレントニューラルネットワークによるディープラーニング：クラッシュコース</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長期短期記憶を備えた再帰型ニューラルネットワークの概要：専門家による円卓会議</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時系列を予測するためのDCTの適合性について</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長期短期記憶を備えた畳み込みニューラルネットワーク</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kerasを使用して、「シーケンスツーシーケンス」予測を実行するための「エンコーダーデコーダー」モデルを準備する方法</font></font></a></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API</font></font></h4><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pandas.read_csv API</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pandas.DataFrame.resample API</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オフセットエイリアスのリサンプル</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sklearn.metrics.mean_squared_error API</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">numpy.split API</font></font></a></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事</font></font></h4><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">家庭用電力消費データセット、UCI Machine Learning Archive</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AC電源、ウィキペディア</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DCT畳み込みネットワーク：現在の気象を予測するための新しい機械学習アプローチ、2015年</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、住宅の電力消費の時系列の間隔予測を実行するために、長期の短期記憶を持つリカレントニューラルネットワークを準備する方法がわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に：</font></font><br>
<br>
<ul>
<li>      «-»         ,     .</li>
<li>      «-»            .</li>
<li>       «-»     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
質問がありますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下のコメント欄で質問して</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ください。できる限り</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お答えします</font><i><font style="vertical-align: inherit;">（これはメモではありません。-ノートごと）</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは私の著書</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">『Deep Learning：Time Series Forecasting</font></a><font style="vertical-align: inherit;">』の章の一部であることに</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意し</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て</font><b><font style="vertical-align: inherit;">ください。</font></b><font style="vertical-align: inherit;">ここには</font><font style="vertical-align: inherit;">、時系列予測の深層学習方法を学習するためのさらに詳細なガイドがあります。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja505318/index.html">Cognitive Agro Data Factoryの作成方法-世界最大の神経系大学</a></li>
<li><a href="../ja505320/index.html">スペースデブリサーチカメラ...</a></li>
<li><a href="../ja505322/index.html">未来のディスパッチャー：サービス会社における彼の役割はどのように変化しますか？</a></li>
<li><a href="../ja505330/index.html">3年間でゼロから暗号通貨を作成しない方法</a></li>
<li><a href="../ja505336/index.html">方法：マネまたはモネ？ニューラルネットワークが応答する</a></li>
<li><a href="../ja505340/index.html">ウォルマートの従業員は、盗難防止AIが機能しないことを証明しようとします</a></li>
<li><a href="../ja505342/index.html">依存関係の注入と依存関係の逆転の原則は同一ではありません</a></li>
<li><a href="../ja505344/index.html">SOCを起動するか、外部に接続しますか？</a></li>
<li><a href="../ja505346/index.html">Civilization VIからUnityへの戦争の霧の実装</a></li>
<li><a href="../ja505348/index.html">PostgreSQLクエリプランを理解することはさらに便利です</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>