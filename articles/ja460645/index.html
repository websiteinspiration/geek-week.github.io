<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍢 ☠️ 😽 良いこと、悪いこと：Goで邪悪なコードを書く、パート1 👩🏻‍🔧 🗝️ 👅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="囲碁プログラマにとっての悪いヒント
 
 
 数十年にわたるJavaプログラミングの後、ここ数年は主にGoに取り組みました。 Goでの作業は素晴らしいものです。これは主に、コードが非常に簡単に追跡できるためです。 Javaは、多重継承、手動のメモリ管理、および演算子のオーバーロードを削除することによ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>良いこと、悪いこと：Goで邪悪なコードを書く、パート1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460645/"><h4><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">囲碁プログラマにとっての悪いヒント</font></font></i></h4><br>
<img src="https://habrastorage.org/getpro/habr/post_images/1c9/72b/d9b/1c972bd9b185f33a0348abfd7d81e470.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数十年にわたるJavaプログラミングの後、ここ数年は主にGoに取り組みました。 Goでの作業は素晴らしいものです。これは主に、コードが非常に簡単に追跡できるためです。 Javaは、多重継承、手動のメモリ管理、および演算子のオーバーロードを削除することにより、C ++プログラミングモデルを簡素化しました。 Goも同じことを行い、継承と関数のオーバーロードを完全に排除して、シンプルで理解しやすいプログラミングスタイルに向けて動き続けます。単純なコードは読み取り可能なコードであり、読み取り可能なコードはサポートされているコードです。これは会社と従業員にとって素晴らしいことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての文化と同様に、ソフトウェア開発には独自の伝説があり、ストーリーはウォータークーラーによって再販されます。私たちは皆、高品質の製品を作ることに焦点を当てるのではなく、自分の仕事を部外者から保護することに焦点を合わせる開発者のことを聞いています。サポートされているコードは必要ありません。これは、他の人がそれを理解して変更できることを意味するためです。 Goで可能ですか？ Goコードをそれほど複雑にすることは可能ですか？すぐに言いますが、これは簡単な作業ではありません。オプションを見てみましょう。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラミング言語でコードをどれだけ台無しにできるか？」 Goでその作者が会社に不可欠になるようなひどいコードを書くことは可能ですか？</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " 心配しないでください。学生時代に、大学院生が書いた他人のLisp-eコードをサポートするプロジェクトがありました。実際、彼はなんとかLispを使用してFortran-eコードを作成しました。コードは次のようになります。</font></font><br>
<br>
<pre><code class="lisp hljs">(<span class="hljs-name">defun</span> add-mult-pi (<span class="hljs-name">in1</span> in2)<font></font>
    (<span class="hljs-name">setq</span> a in1)<font></font>
    (<span class="hljs-name">setq</span> b in2)<font></font>
    (<span class="hljs-name">setq</span> c (<span class="hljs-name">+</span> a b))<font></font>
    (<span class="hljs-name">setq</span> d (<span class="hljs-name">*</span> <span class="hljs-number">3.1415</span> c)<font></font>
    d<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのようなコードの数十のファイルがありました。</font><font style="vertical-align: inherit;">彼は絶対にひどく、同時に素晴らしかった。</font><font style="vertical-align: inherit;">私はそれを理解しようと何ヶ月も費やしました。</font><font style="vertical-align: inherit;">これと比較して、Goで悪いコードを書くことは単なる唾です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードをサポートしないようにする方法はたくさんありますが、ここではいくつかだけ見ていきます。</font><font style="vertical-align: inherit;">悪を行うには、まず善を行うことを学ぶ必要があります。</font><font style="vertical-align: inherit;">したがって、最初に「良い」Goプログラマーがどのように書くかを検討し、次にその反対の方法を検討します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">悪い包装</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パッケージは、始めるのに便利なトピックです。コード編成はどのように読みやすさを損なうことができますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goでは、パッケージ名はエクスポートされたエンティティを参照するために使用されます（たとえば、 ` </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fmt.Println`</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または` </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http.RegisterFunc`</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。パッケージの名前を確認できるので、「良い」Goプログラマーは、この名前がエクスポートされたエンティティーが何であるかを説明していることを確認します。 ` </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">util.JSONMarshal`の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ような名前は機能しないため、utilパッケージ</font><font style="vertical-align: inherit;">は必要あり</font><font style="vertical-align: inherit;">ません</font><i><font style="vertical-align: inherit;">。`json.Marshal`</font></i><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">必要</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「良い」Go開発者は、DAOまたはモデル用の個別のパッケージも作成しません。この用語に慣れていない人にとって、DAOは「</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データアクセスオブジェクト」です。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（データアクセスオブジェクト）”-データベースとやり取りするコードレイヤー。私は以前、6つのJavaサービスが同じDAOライブラリをインポートして同じデータベースにアクセスし、それらが共有する会社で働いていました。なぜなら、「</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...まあ、マイクロサービスは同じです...</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのDAOを含む別のパッケージがある場合、パッケージ間で循環依存関係が発生する可能性が高くなります。これは、Goでは禁止されています。また、このDAOパッケージをライブラリとして接続する複数のサービスがある場合、1つのサービスの変更ですべてのサービスを更新する必要がある状況に遭遇することもあります。これは分散モノリスと呼ばれ、更新が非常に困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パッケージングがどのように機能し、何がそれを悪化させるかを知っていると、「悪を仕掛け始める」ことが簡単になります。</font><font style="vertical-align: inherit;">コードを適切に整理せず、パッケージに悪い名前を付けてください。</font><font style="vertical-align: inherit;">コードを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">model</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">util</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dao</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などのパッケージに分割します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">本当に混沌を作りたいなら、猫や好きな色に敬意を表してパッケージを作ってみてください。</font><font style="vertical-align: inherit;">コードを使用しようとするために人々が周期的な依存関係や分散したモノリスに直面しているときは、ため息をつき、目を丸めて、彼らが間違っていることを伝える必要があります...</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不適切なインターフェース</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 すべてのパッケージが破損したので、インターフェースに移ることができます。 Goのインターフェースは、他の言語のインターフェースとは異なります。この型がインターフェースを実装することを最初に明示的に宣言しないという事実は重要ではないように見えますが、実際にはインターフェースの概念を完全に逆にしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
抽象型を持つほとんどの言語では、実装の前またはそれと同時にインターフェイスが定義されます。これは、少なくともテストのために行う必要があります。事前にインターフェースを作成しないと、このクラスを使用するすべてのコードを壊さずに後でインターフェースを挿入できません。特定のタイプの代わりにインターフェースへのリンクでそれを書き直さなければならないからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このため、Javaコードには多くのメソッドを持つ巨大なサービスインターフェイスが含まれていることがよくあります。これらのインターフェースを実装するクラスは、必要なメソッドを使用し、残りは無視します。テストを作成することは可能ですが、抽象化の層を追加します。テストを作成するときは、多くの場合、ツールを使用して、不要なメソッドの実装を生成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goでは、暗黙的なインターフェイスによって、使用する必要があるメソッドが決まります。コードはインターフェースを所有し、その逆ではありません。多くのメソッドが定義されているタイプを使用する場合でも、必要なメソッドのみを含むインターフェースを指定できます。同じタイプの別のフィールドを使用する別のコードは、必要な機能のみをカバーする他のインターフェースを定義します。通常、このようなインターフェースにはいくつかのメソッドしかありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、コードを理解しやすくなります。メソッド宣言は、必要なデータを決定するだけでなく、使用する機能を正確に示すからです。これが、優れたGo開発者が「</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェイスを受け入れ、構造を返す</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」というアドバイスに従う理由の1つです</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これが良い習慣であるからといって、それを実行する必要があるという意味ではありません</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。</font><font style="vertical-align: inherit;">呼び出されるコードの一部として、インターフェースを事前に定義します。</font><font style="vertical-align: inherit;">すべてのサービスクライアントで使用される多くのメソッドで巨大なインターフェースを定義します。</font><font style="vertical-align: inherit;">どの方法が本当に必要かは不明確になります。</font><font style="vertical-align: inherit;">これはコードを複雑にし、複雑さはご存じのように、「邪悪な」プログラマーの親友です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒープポインタを渡す</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが何を意味するのかを説明する前に、少し哲学をする必要があります。あなたが気を散らして考えれば、書かれた各プログラムは同じことをします。データを受信して​​処理し、処理したデータを別の場所に送信します。これは、給与計算システムを作成するか、HTTP要求を受け入れてWebページを返すか、またはジョイスティックをチェックしてボタンのクリックを追跡するかどうかに関係なく、プログラムがデータを処理するためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようにプログラムを見る場合、最も重要なことは、データがどのように変換されるかを簡単に理解できるようにすることです。したがって、プログラム中はできるだけデータを変更しないでおくことをお勧めします。変化しないデータは追跡しやすいデータだからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goでは、参照型と値型があります。 2つの違いは、変数がデータのコピーを参照するか、メモリ内のデータの場所を参照するかです。ポインター、スライス、マップ、チャネル、インターフェース、および関数は参照型であり、その他はすべて値型です。値タイプの変数を別の変数に割り当てると、値のコピーが作成されます。ある変数を変更しても、別の変数の値は変更されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
参照型の1つの変数を参照型の別の変数に割り当てると、両方が同じメモリ領域を共有するため、最初のポイントが指すデータを変更すると、2番目のポイントが指すデータが変更されます。これは、ローカル変数と関数パラメーターの両方に当てはまります。</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// </span>
    a := <span class="hljs-number">1</span><font></font>
    b := a<font></font>
    b = <span class="hljs-number">2</span>
    fmt.Println(a, b) <span class="hljs-comment">// prints 1 2</span>
    <span class="hljs-comment">// </span><font></font>
    c := &amp;a<font></font>
    *c = <span class="hljs-number">3</span>
    fmt.Println(a, b, *c) <span class="hljs-comment">// prints 3 2 3</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kind Goの開発者は、データの収集方法をより簡単に理解できるようにしたいと考えています。彼らは値のタイプを関数のパラメーターとしてできるだけ頻繁に使用しようとします。 Goには、構造体または関数パラメーターのフィールドをfinalとしてマークする方法はありません。関数が値パラメーターを使用する場合、パラメーターを変更しても呼び出し元の関数の変数は変更されません。呼び出された関数で実行できることは、呼び出し元の関数に値を返すことだけです。したがって、値パラメーターを使用して関数を呼び出して構造体に入力する場合、構造体の各フィールドがどこから来たかを理解しているため、データを構造体に転送することを恐れることはありません。</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> Foo <span class="hljs-keyword">struct</span> {<font></font>
    A <span class="hljs-keyword">int</span>
    B <span class="hljs-keyword">string</span><font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getA</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">20</span><font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getB</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">string</span></span> {
    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"%d"</span>,i*<span class="hljs-number">2</span>)<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
    f := Foo{}<font></font>
    f.A = getA()<font></font>
    f.B = getB(f.A)<font></font>
    <span class="hljs-comment">//  ,    f</span><font></font>
    fmt.Println(f)<font></font>
}</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、どうすれば「悪」になるのでしょうか。</font><font style="vertical-align: inherit;">非常にシンプル-このモデルをひっくり返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
目的の値を返す関数を呼び出す代わりに、関数内の構造体へのポインターを渡し、それらに構造体を変更させます。</font><font style="vertical-align: inherit;">各関数には独自の構造があるため、どのフィールドが変更されているかを確認する唯一の方法は、コード全体を調べることです。</font><font style="vertical-align: inherit;">また、関数間に暗黙的な依存関係がある場合もあります。最初の関数は、2番目の関数が必要とするデータを転送します。</font><font style="vertical-align: inherit;">ただし、コード自体では、最初に1番目の関数を呼び出す必要があることを示すものはありません。</font><font style="vertical-align: inherit;">この方法でデータ構造を構築すると、コードの実行内容が誰にも理解されないようにすることができます。</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">type</span> Foo <span class="hljs-keyword">struct</span> {<font></font>
    A <span class="hljs-keyword">int</span>
    B <span class="hljs-keyword">string</span><font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setA</span><span class="hljs-params">(f *Foo)</span></span> {<font></font>
    f.A = <span class="hljs-number">20</span><font></font>
}<font></font>
<span class="hljs-comment">//   f.A!</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setB</span><span class="hljs-params">(f *Foo)</span></span> {<font></font>
    f.B = fmt.Sprintf(<span class="hljs-string">"%d"</span>, f.A*<span class="hljs-number">2</span>)<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
    f := Foo{}<font></font>
    setA(&amp;f)<font></font>
    setB(&amp;f)<font></font>
    <span class="hljs-comment">// ,  setA  setB</span>
    <span class="hljs-comment">//    ?</span><font></font>
    fmt.Println(f)<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パニック浮上</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、エラー処理を開始しています。エラーを75％程度処理するプログラムを書くのは悪いことだと思うかもしれませんが、あなたが間違っているとは言えません。 Goコードには、多くの場合、頭からつま先までのエラー処理が実装されています。そしてもちろん、それらをそれほど単純ではなく処理するのが便利でしょう。間違いが発生し、それらを処理することは、初心者からプロを区別するものです。エラー処理が不明瞭になると、プログラムが不安定になり、デバッグや保守が困難になります。時々「良い」プログラマーになるということは「緊張する」ことを意味します。</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dus DBUserService)</span> <span class="hljs-title">Load</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(User, error)</span></span> {<font></font>
    rows, err := dus.DB.Query(<span class="hljs-string">"SELECT name FROM USERS WHERE ID = ?"</span>, id)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> User{}, err<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> !rows.Next() {
        <span class="hljs-keyword">return</span> User{}, fmt.Errorf(<span class="hljs-string">"no user for id %d"</span>, id)<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> name <span class="hljs-keyword">string</span><font></font>
    err = rows.Scan(&amp;name)<font></font>
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> User{}, err<font></font>
    }<font></font>
    err = rows.Close()<font></font>
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> User{}, err<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> User{Id: id, Name: name}, <span class="hljs-literal">nil</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++、Python、Ruby、Javaなどの多くの言語では、例外を使用してエラーを処理します。</font><font style="vertical-align: inherit;">何かがうまくいかない場合、これらの言語の開発者は、いくつかのコードがそれを処理することを期待して、例外をスローまたはスローします。</font><font style="vertical-align: inherit;">もちろん、プログラムは、クライアントが特定の場所でスローされる可能性のあるエラーを認識しているため、例外をスローできることを期待しています。</font><font style="vertical-align: inherit;">Javaでチェックされた例外を除いて（しゃれが意図されていない）、例外が発生する可能性があることを示す言語や関数のメソッドシグネチャには何もありません。</font><font style="vertical-align: inherit;">では、開発者はどの例外を気にする必要があるかをどのようにして知るのでしょうか </font><font style="vertical-align: inherit;">2つのオプションがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まず、コードが呼び出すすべてのライブラリのすべてのソースコードと、呼び出されたライブラリを呼び出すすべてのライブラリなどを読み取ることができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、ドキュメントを信頼できます。</font><font style="vertical-align: inherit;">私は偏見があるかもしれませんが、個人的な経験では、ドキュメントを完全に信頼することはできません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、どうすればこの悪をGoにもたらすことができるのでしょうか。</font><font style="vertical-align: inherit;">もちろん</font><font style="vertical-align: inherit;">パニック（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パニック</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）とリカバリー（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リカバリー</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">乱用</font><font style="vertical-align: inherit;">！</font><font style="vertical-align: inherit;">パニックは、「ディスクが落ちた」または「ネットワークカードが爆発した」などの状況向けに設計されています。</font><font style="vertical-align: inherit;">しかし、そうではありません-「誰かがintの代わりに文字列を渡しました」。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、他の「賢明でない開発者」はコードからエラーを返します。</font><font style="vertical-align: inherit;">したがって、ここにPanicIfErrの小さなヘルパー関数があります。</font><font style="vertical-align: inherit;">他の開発者の間違いをパニックに変えるために使用します。</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PanicIfErr</span><span class="hljs-params">(err error)</span></span> {
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-built_in">panic</span>(err)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PanicIfErrを使用して他の人の間違いをラップし、コードを圧縮できます。</font><font style="vertical-align: inherit;">醜いエラー処理はもうありません！</font><font style="vertical-align: inherit;">間違いはパニックになりました。</font><font style="vertical-align: inherit;">とても生産的です！</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dus DBUserService)</span> <span class="hljs-title">LoadEvil</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">User</span></span> {<font></font>
    rows, err := dus.DB.Query(<font></font>
                 <span class="hljs-string">"SELECT name FROM USERS WHERE ID = ?"</span>, id)<font></font>
    PanicIfErr(err)<font></font>
    <span class="hljs-keyword">if</span> !rows.Next() {
        <span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">"no user for id %d"</span>, id))<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> name <span class="hljs-keyword">string</span><font></font>
    PanicIfErr(rows.Scan(&amp;name))<font></font>
    PanicIfErr(rows.Close())<font></font>
    <span class="hljs-keyword">return</span> User{Id: id, Name: name}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リカバリは、プログラムの先頭に近い場所に配置できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">おそらく独自の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ミドルウェアに配置でき</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">そして、エラーを処理するだけでなく、他の人のコードをよりクリーンにすることもできます。</font><font style="vertical-align: inherit;">善を行うことによって悪を行うことは、最良の種類の悪です。</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PanicMiddleware</span><span class="hljs-params">(h http.Handler)</span> <span class="hljs-title">http</span>.<span class="hljs-title">Handler</span></span> {
    <span class="hljs-keyword">return</span> http.HandlerFunc(
        <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span>{
            <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
                <span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> {<font></font>
                   fmt.Println(<span class="hljs-string">", - ."</span>)<font></font>
                }<font></font>
            }()<font></font>
            h.ServeHTTP(rw, req)<font></font>
        }<font></font>
    )<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">副作用の設定</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、副作用を作成します。</font><font style="vertical-align: inherit;">「良い」Go開発者は、データがプログラムをどのように通過するかを理解したいと考えていることを忘れないでください。</font><font style="vertical-align: inherit;">データが通過するものを知る最良の方法は、アプリケーションに明示的な依存関係を設定することです。</font><font style="vertical-align: inherit;">同じインターフェイスに対応するエンティティでさえ、動作が大きく異なる可能性があります。</font><font style="vertical-align: inherit;">たとえば、データをメモリに格納するコードと、同じ作業のためにデータベースにアクセスするコードです。</font><font style="vertical-align: inherit;">ただし、明示的な呼び出しなしでGoに依存関係をインストールする方法があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他の多くの言語と同様に、Goにはコードを直接呼び出さずに魔法のようにコードを実行する方法があります。パラメーターなしでinitと呼ばれる関数を作成すると、パッケージが読み込まれたときに自動的に開始されます。さらに混乱を招くために、1つのファイルにinitという名前の複数の関数がある場合、または1つのパッケージに複数のファイルがある場合、それらはすべて起動します。</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> account
<span class="hljs-keyword">type</span> Account <span class="hljs-keyword">struct</span>{<font></font>
    Id <span class="hljs-keyword">int</span>
    UserId <span class="hljs-keyword">int</span><font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> {<font></font>
    fmt.Println(<span class="hljs-string">"  !"</span>)<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> {<font></font>
    fmt.Println(<span class="hljs-string">"   ,     init()"</span>)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの場合、init関数は空のインポートに関連付けられています。 Goには、 `import _“ github.com / lib / pq`のような特別なインポート宣言メソッドがあります。インポートされたパッケージに空の名前識別子を設定すると、その中でinitメソッドが実行されますが、パッケージ識別子は表示されません。データベースドライバーやイメージフォーマットなどの一部のGoライブラリでは、パッケージがコードを登録できるようにinit関数を呼び出すだけのために、空のパッケージインポートを有効にしてそれらをロードする必要があります。</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> _ <span class="hljs-string">"github.com/lib/pq"</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
    db, err := sql.Open(<font></font>
        <span class="hljs-string">"postgres"</span>,
        <span class="hljs-string">"postgres://jon@localhost/evil?sslmode=disable"</span>)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これは明らかに「悪」なオプションです。初期化を使用する場合、魔法のように機能するコードは完全に開発者の制御の外にあります。ベストプラクティスでは、初期化関数の使用を推奨していません。これらは自明ではない機能であり、コードを混乱させ、ライブラリで簡単に非表示にすることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言い換えれば、init関数は私たちの邪悪な目的に理想的です。パッケージ内のエンティティを明示的に構成または登録する代わりに、初期化関数と空のインポート関数を使用して、アプリケーションの状態を構成できます。この例では、レジストリを介してアプリケーションの残りの部分でアカウントを使用できるようにし、パッケージ自体がinit関数を使用してレジストリに配置されます。</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> account
<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"github.com/evil-go/example/registry"</span><font></font>
)<font></font>
<span class="hljs-keyword">type</span> StubAccountService <span class="hljs-keyword">struct</span> {}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a StubAccountService)</span> <span class="hljs-title">GetBalance</span><span class="hljs-params">(accountId <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1000000</span><font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> {<font></font>
    registry.Register(<span class="hljs-string">"account"</span>, StubAccountService{})<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アカウントを使用する場合は、プログラムに空のインポートを配置します。</font><font style="vertical-align: inherit;">メインコードや関連コードである必要はありません。「どこかに」ある必要があります。</font><font style="vertical-align: inherit;">それは魔法です！</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> main
<span class="hljs-keyword">import</span> (<font></font>
    _ <span class="hljs-string">"github.com/evil-go/example/account"</span>
   <span class="hljs-string">"github.com/evil-go/example/registry"</span><font></font>
)<font></font>
<span class="hljs-keyword">type</span> Balancer <span class="hljs-keyword">interface</span> {<font></font>
    GetBalance(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">int</span><font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
    a := registry.Get(<span class="hljs-string">"account"</span>).(Balancer)<font></font>
    money := a.GetBalance(<span class="hljs-number">12345</span>)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライブラリでinitsを使用して依存関係を構成すると、他の開発者がこれらの依存関係のインストール方法と変更方法に困惑していることがすぐにわかります。</font><font style="vertical-align: inherit;">そして、誰もあなたより賢くないでしょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複雑な構成</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
設定でできることはまだたくさんあります。 「優れた」Go開発者である場合は、プログラムの残りの部分から構成を分離する必要があります。 main（）関数では、環境から変数を取得し、それらを明示的に相互に関連しているコンポーネントに必要な値に変換します。コンポーネントは、構成ファイル、またはそれらのプロパティの名前について何も知りません。単純なコンポーネントの場合はパブリックプロパティを設定し、より複雑な場合は構成情報を受け取って正しく構成されたコンポーネントを返すファクトリ関数を作成できます。</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
    b, err := ioutil.ReadFile(<span class="hljs-string">"account.json"</span>)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<font></font>
    fmt.Errorf(<span class="hljs-string">"error reading config file: %v"</span>, err)<font></font>
    os.Exit(<span class="hljs-number">1</span>)<font></font>
    }<font></font>
    m := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>{}{}<font></font>
    json.Unmarshal(b, &amp;m)<font></font>
    prefix := m[<span class="hljs-string">"account.prefix"</span>].(<span class="hljs-keyword">string</span>)<font></font>
    maker := account.NewMaker(prefix)<font></font>
}<font></font>
<span class="hljs-keyword">type</span> Maker <span class="hljs-keyword">struct</span> {<font></font>
    prefix <span class="hljs-keyword">string</span><font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m Maker)</span> <span class="hljs-title">NewAccount</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">Account</span></span> {
    <span class="hljs-keyword">return</span> Account{Name: name, Id: m.prefix + <span class="hljs-string">"-12345"</span>}<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMaker</span><span class="hljs-params">(prefix <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">Maker</span></span> {
    <span class="hljs-keyword">return</span> Maker{prefix: prefix}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、「悪」な開発者は、構成に関する情報をプログラム全体に分散させる方がよいことを知っています。パッケージの名前と値のタイプを定義する関数をパッケージ内に1つ持つ代わりに、構成をそのまま使用して独自に変換する関数を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが「悪」であると思われる場合は、init関数を使用してパッケージ内からプロパティファイルを読み込み、値を自分で設定します。あなたは他の開発者の生活を楽にしたように見えるかもしれませんが、あなたと私は知っています...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
init関数を使用すると、コードの後ろで新しいプロパティを定義できます。実行に必要な数十のプロパティファイルのいずれかに何かが入り込まないため、本番環境に移行してすべてが落ちるまで、誰もそれらを見つけることができません。</font><font style="vertical-align: inherit;">さらに「悪の力」が必要な場合は、すべてのライブラリのすべてのプロパティを追跡し、新しいプロパティを定期的に「忘れる」ようにWikiを作成することを提案できます。</font><font style="vertical-align: inherit;">プロパティキーパーとして、ソフトウェアを実行できる唯一の人物になります。</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m maker)</span> <span class="hljs-title">NewAccount</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">Account</span></span> {
    <span class="hljs-keyword">return</span> Account{Name: name, Id: m.prefix + <span class="hljs-string">"-12345"</span>}<font></font>
}<font></font>
<span class="hljs-keyword">var</span> Maker maker
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> {<font></font>
    b, _ := ioutil.ReadFile(<span class="hljs-string">"account.json"</span>)<font></font>
    m := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>{}{}<font></font>
    json.Unmarshal(b, &amp;m)<font></font>
    Maker.prefix = m[<span class="hljs-string">"account.prefix"</span>].(<span class="hljs-keyword">string</span>)<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能フレームワーク</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、フレームワークとライブラリのトピックに行きます。違いは非常に微妙です。サイズだけではありません。大きなライブラリと小さなフレームワークを持つことができます。ライブラリコードを自分で呼び出すときに、フレームワークがコードを呼び出します。フレームワークでは、特定の規則に従ってメソッドに名前を付けるか、特定のインターフェイスに対応するか、フレームワークにコードを登録するように強制するかなど、特定の方法でコードを記述する必要があります。フレームワークには、すべてのコードに対して独自の要件があります。つまり、一般的に、フレームワークはあなたに命じます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goは、ライブラリがリンクされているため、ライブラリの使用を奨励しています。</font><font style="vertical-align: inherit;">もちろん、各ライブラリは特定の形式でデータが送信されることを想定していますが、いくつかの接続コードを記述して、あるライブラリの出力を別のライブラリの入力に変換できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各フレームワークはコードのライフサイクルを完全に制御する必要があるため、フレームワークをシームレスに連携させることは困難です。</font><font style="vertical-align: inherit;">多くの場合、フレームワークを連携させる唯一の方法は、フレームワークの作者が集まり、相互のサポートを明確に編成することです。</font><font style="vertical-align: inherit;">そして、「悪のフレームワーク」を使用して長期的な力を得る最良の方法は、社内でのみ使用される独自のフレームワークを記述することです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在と将来の悪</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのトリックを習得すると、あなたは永遠に悪の道に乗り出すでしょう。</font><font style="vertical-align: inherit;">第2部では、この「悪」をすべて展開する方法と、「良い」コードを「悪」なコードに変える方法を示します。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja460633/index.html">RSTPおよび独自の拡張リング冗長性の実装の詳細</a></li>
<li><a href="../ja460635/index.html">CLRium＃6：並行性と並列性。2日間：プロセッサーから非同期/待機まで</a></li>
<li><a href="../ja460637/index.html">ZigBeeライトコントロール</a></li>
<li><a href="../ja460641/index.html">YouTokenToMe：VKontakteチームからのテキストの迅速なトークン化のためのツール</a></li>
<li><a href="../ja460643/index.html">球上の点の均一な分布</a></li>
<li><a href="../ja460647/index.html">pwnable.kr 05-パスコードでジョブを解決します。フォーマット文字列の脆弱性によるプロシージャリンクテーブルの書き換え</a></li>
<li><a href="../ja460651/index.html">匿名テスター協会の会議：TMS、モニタリングモニタリング、検索品質評価、ネイティブiOSテスト</a></li>
<li><a href="../ja460655/index.html">電報を壊した方法</a></li>
<li><a href="../ja460659/index.html">パイプを使用したピボット</a></li>
<li><a href="../ja460661/index.html">Node.jsについて知っておくべきこと</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>