<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😵 👨🏽‍🔬 🚽 Bagaimana melindungi proses dan ekstensi kernel pada macOS 🏴󠁧󠁢󠁷󠁬󠁳󠁿 ✌🏾 🖕🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Hari ini saya ingin berbicara tentang bagaimana Anda dapat melindungi proses dari penyusup di macOS. Sebagai contoh, ini berguna untuk ant...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Bagaimana melindungi proses dan ekstensi kernel pada macOS</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/497714/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo, Habr! </font><font style="vertical-align: inherit;">Hari ini saya ingin berbicara tentang bagaimana Anda dapat melindungi proses dari penyusup di macOS. </font><font style="vertical-align: inherit;">Sebagai contoh, ini berguna untuk antivirus atau sistem cadangan, terutama mengingat fakta bahwa di bawah MacOS ada beberapa cara untuk "membunuh" proses. </font><font style="vertical-align: inherit;">Baca tentang itu dan tentang metode perlindungan di bawah kucing.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/403/e5f/065/403e5f065b7426d384f3c71e8cb3c8a5.jpg" alt="gambar"></a><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara klasik untuk membunuh suatu proses</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cara terkenal untuk "membunuh" suatu proses adalah mengirim sinyal tentang proses SIGKILL. </font><font style="vertical-align: inherit;">Melalui bash, Anda dapat memanggil standar "kill -SIGKILL PID" atau "pkill -9 NAME" untuk membunuh. </font><font style="vertical-align: inherit;">Perintah kill telah dikenal sejak UNIX dan tersedia tidak hanya pada macOS, tetapi juga pada sistem mirip UNIX lainnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti pada sistem mirip UNIX, macOS memungkinkan Anda untuk mencegat sinyal apa pun ke proses kecuali dua - SIGKILL dan SIGSTOP. </font><font style="vertical-align: inherit;">Dalam artikel ini, sinyal SIGKILL terutama akan dianggap sebagai sinyal yang memunculkan proses pembunuhan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Khusus MacOS</font></font><br>
</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di macOS, kill system call di kernel XNU memanggil fungsi psignal (SIGKILL, ...). Mari kita coba untuk melihat apa tindakan pengguna lain di userspace dapat memanggil fungsi psignal. Kami menghilangkan panggilan ke fungsi psignal dalam mekanisme internal kernel (meskipun mungkin tidak trivial, mari tinggalkan untuk artikel lain :) - verifikasi tanda tangan, kesalahan memori, pemrosesan keluar / terminasi, pelanggaran perlindungan file, dll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memulai ikhtisar dengan fungsi dan panggilan sistem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terminate_with_payload</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dapat dilihat bahwa selain panggilan kill klasik, ada pendekatan alternatif yang khusus untuk sistem operasi macOS dan tidak ditemukan di BSD. </font><font style="vertical-align: inherit;">Prinsip operasi kedua pemanggilan sistem juga dekat. </font><font style="vertical-align: inherit;">Mereka adalah panggilan langsung ke fungsi kernel psignal. </font><font style="vertical-align: inherit;">Juga perhatikan bahwa sebelum mematikan suatu proses, suatu pemeriksaan "cansignal" dilakukan - apakah proses tersebut dapat mengirim sinyal ke proses lain, sistem tidak mengizinkan aplikasi apa pun untuk mematikan proses sistem misalnya.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>
<span class="hljs-title">terminate_with_payload_internal</span><span class="hljs-params">(struct proc *cur_proc, <span class="hljs-keyword">int</span> target_pid, <span class="hljs-keyword">uint32_t</span> reason_namespace,
				<span class="hljs-keyword">uint64_t</span> reason_code, <span class="hljs-keyword">user_addr_t</span> payload, <span class="hljs-keyword">uint32_t</span> payload_size,
				<span class="hljs-keyword">user_addr_t</span> reason_string, <span class="hljs-keyword">uint64_t</span> reason_flags)</span>
</span>{<font></font>
...<font></font>
	target_proc = proc_find(target_pid);<font></font>
...<font></font>
	<span class="hljs-keyword">if</span> (!cansignal(cur_proc, cur_cred, target_proc, SIGKILL)) {<font></font>
		proc_rele(target_proc);<font></font>
		<span class="hljs-keyword">return</span> EPERM;<font></font>
	}<font></font>
...<font></font>
	<span class="hljs-keyword">if</span> (target_pid == cur_proc-&gt;p_pid) {
		<span class="hljs-comment">/*
		 * psignal_thread_with_reason() will pend a SIGKILL on the specified thread or
		 * return if the thread and/or task are already terminating. Either way, the
		 * current thread won't return to userspace.
		 */</span><font></font>
		psignal_thread_with_reason(target_proc, current_thread(), SIGKILL, signal_reason);<font></font>
	} <span class="hljs-keyword">else</span> {<font></font>
		psignal_with_reason(target_proc, SIGKILL, signal_reason);<font></font>
	}<font></font>
...<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">launchd</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cara standar untuk membuat daemon pada startup sistem dan mengontrol masa pakai mereka adalah launchd. </font><font style="vertical-align: inherit;">Saya akan menarik perhatian pada fakta bahwa kode sumber adalah untuk versi lama launchctl sebelum macOS 10.10, contoh kode diberikan sebagai ilustrasi. </font><font style="vertical-align: inherit;">Launchctl modern mengirimkan sinyal launchd melalui XPC, logika launchctl ditransfer ke sana. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita pertimbangkan bagaimana aplikasi dihentikan. </font><font style="vertical-align: inherit;">Sebelum mengirim sinyal SIGTERM, mereka mencoba menghentikan aplikasi menggunakan panggilan sistem proc_terminate.</font></font><br>
<br>
<pre><code class="cpp hljs">&lt;launchctl src/core.c&gt;<font></font>
...<font></font>
	error = proc_terminate(j-&gt;p, &amp;sig);<font></font>
	<span class="hljs-keyword">if</span> (error) {<font></font>
		job_log(j, LOG_ERR | LOG_CONSOLE, <span class="hljs-string">"Could not terminate job: %d: %s"</span>, error, strerror(error));<font></font>
		job_log(j, LOG_NOTICE | LOG_CONSOLE, <span class="hljs-string">"Using fallback option to terminate job..."</span>);<font></font>
		error = kill2(j-&gt;p, SIGTERM);<font></font>
		<span class="hljs-keyword">if</span> (error) {<font></font>
			job_log(j, LOG_ERR, <span class="hljs-string">"Could not signal job: %d: %s"</span>, error, strerror(error));<font></font>
		} <font></font>
...<font></font>
&lt;&gt;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di bawah tenda, proc_terminate, terlepas dari namanya, dapat mengirim tidak hanya psignal dengan SIGTERM, tetapi juga SIGKILL.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembunuhan tidak langsung - batas sumber daya</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kasus yang lebih menarik dapat dilihat pada pemanggilan sistem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">process_policy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lain </font><font style="vertical-align: inherit;">. Penggunaan standar panggilan sistem ini adalah batas sumber daya aplikasi, misalnya, untuk pengindeks, ada batas waktu prosesor dan kuota memori sehingga sistem tidak melambat secara signifikan dari tindakan caching file. Jika aplikasi telah mencapai batas sumber daya, seperti yang dapat dilihat dari fungsi proc_apply_resource_actions, sinyal SIGKILL dikirim ke proses. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meskipun pemanggilan sistem ini berpotensi mematikan proses, sistem tidak cukup memeriksa hak-hak proses yang menyebabkan pemanggilan sistem. Sebenarnya, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cek </font><font style="vertical-align: inherit;">, tetapi cukup menggunakan bendera alternatif PROC_POLICY_ACTION_SET untuk melewati kondisi ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oleh karena itu, jika Anda “membatasi” kuota penggunaan CPU oleh aplikasi (misalnya, izinkan hanya 1 ns yang akan dijalankan), maka Anda dapat mematikan proses apa pun dalam sistem. </font><font style="vertical-align: inherit;">Jadi, malware dapat membunuh proses apa pun pada sistem, termasuk proses antivirus. </font><font style="vertical-align: inherit;">Yang juga menarik adalah efek yang terjadi ketika sebuah proses terbunuh dengan pid 1 (launchctl) - kernel panik ketika mencoba memproses sinyal SIGKILL :)</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/91e/fea/a49/91efeaa490ffd57580d2e5f4a59b4988.png" alt="gambar"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana cara mengatasi masalah tersebut?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cara paling mudah untuk mencegah proses tidak terbunuh adalah dengan mengganti pointer fungsi di tabel panggilan sistem. Sayangnya, metode ini non-sepele karena berbagai alasan </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
, pertama, simbol yang bertanggung jawab atas posisi sysent dalam memori bukan hanya simbol pribadi dari kernel XNU, tetapi juga tidak dapat ditemukan dalam simbol kernel. Anda harus menggunakan metode pencarian heuristik, misalnya, pembongkaran fungsi secara dinamis dan mencari pointer di dalamnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kedua, struktur entri dalam tabel tergantung pada flag yang digunakan kernel. Jika flag CONFIG_REQUIRES_U32_MUNGING dideklarasikan, maka ukuran struktur akan diubah - bidang tambahan </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">sy_arg_munge32</font></a><font style="vertical-align: inherit;"> ditambahkan</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Penting untuk melakukan pemeriksaan tambahan pada flag yang digunakan untuk mengkompilasi kernel, sebagai opsi, membandingkan pointer ke fungsi dengan yang dikenal.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysent</span> {</span>         <span class="hljs-comment">/* system call table */</span>
        <span class="hljs-keyword">sy_call_t</span>       *sy_call;       <span class="hljs-comment">/* implementing function */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> CONFIG_REQUIRES_U32_MUNGING || (__arm__ &amp;&amp; (__BIGGEST_ALIGNMENT__ &gt; 4))</span>
        <span class="hljs-keyword">sy_munge_t</span>      *sy_arg_munge32; <span class="hljs-comment">/* system call arguments munger for 32-bit process */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
        <span class="hljs-keyword">int32_t</span>         sy_return_type; <span class="hljs-comment">/* system call return types */</span>
        <span class="hljs-keyword">int16_t</span>         sy_narg;        <span class="hljs-comment">/* number of args */</span>
        <span class="hljs-keyword">uint16_t</span>        sy_arg_bytes;   <span class="hljs-comment">/* Total size of arguments in bytes for
                                         * 32-bit system calls
                                         */</span><font></font>
};<font></font>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untungnya, dalam versi macOS modern, Apple menyediakan API baru untuk bekerja dengan proses. </font><font style="vertical-align: inherit;">API Keamanan Endpoint memungkinkan klien untuk mengotorisasi banyak permintaan ke proses lain. </font><font style="vertical-align: inherit;">Jadi, Anda dapat memblokir sinyal apa pun untuk proses, termasuk sinyal SIGKILL menggunakan API tersebut.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bsm/libbsm.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;EndpointSecurity/EndpointSecurity.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>{
    <span class="hljs-keyword">es_client_t</span>* cli = <span class="hljs-literal">nullptr</span>;<font></font>
    {<font></font>
        <span class="hljs-keyword">auto</span> res = es_new_client(&amp;cli, ^(<span class="hljs-keyword">es_client_t</span> * client, <span class="hljs-keyword">const</span> <span class="hljs-keyword">es_message_t</span> * message) {
            <span class="hljs-keyword">switch</span> (message-&gt;event_type) {
                <span class="hljs-keyword">case</span> ES_EVENT_TYPE_AUTH_SIGNAL:<font></font>
                {<font></font>
                    <span class="hljs-keyword">auto</span>&amp; msg = message-&gt;event.signal;
                    <span class="hljs-keyword">auto</span> target = msg.target;
                    <span class="hljs-keyword">auto</span>&amp; token = target-&gt;audit_token;
                    <span class="hljs-keyword">auto</span> pid = audit_token_to_pid(token);
                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"signal '%d' sent to pid '%d'\n"</span>, msg.sig, pid);<font></font>
                    es_respond_auth_result(client, message, pid == getpid() ? ES_AUTH_RESULT_DENY : ES_AUTH_RESULT_ALLOW, <span class="hljs-literal">false</span>);<font></font>
                }<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        });<font></font>
    }<font></font>
<font></font>
    {<font></font>
        <span class="hljs-keyword">es_event_type_t</span> evs[] = { ES_EVENT_TYPE_AUTH_SIGNAL };<font></font>
        es_subscribe(cli, evs, <span class="hljs-keyword">sizeof</span>(evs) / <span class="hljs-keyword">sizeof</span>(*evs));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, getpid());<font></font>
    sleep(<span class="hljs-number">60</span>); <span class="hljs-comment">// could be replaced with other waiting primitive</span><font></font>
<font></font>
    es_unsubscribe_all(cli);<font></font>
    es_delete_client(cli);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Demikian pula, Anda dapat mendaftarkan Kebijakan MAC di kernel, yang menyediakan metode perlindungan sinyal (kebijakan proc_check_signal), tetapi API tidak didukung secara resmi.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlindungan Ekstensi Kernel</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain melindungi proses dalam sistem, perlindungan terhadap ekstensi kernel itu sendiri (kext) juga diperlukan. macOS menyediakan kerangka kerja bagi pengembang untuk mengembangkan driver perangkat IOKit dengan mudah. Selain menyediakan alat untuk bekerja dengan perangkat, IOKit menyediakan metode penumpukan driver menggunakan instance dari kelas C ++. Aplikasi di userspace akan dapat "menemukan" instance kelas terdaftar untuk membangun koneksi kernel-userspace. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mendeteksi jumlah instance kelas dalam sistem, utilitas ioclasscount ada.</font></font><br>
<br>
<pre><code class="cpp hljs">my_kext_ioservice = <span class="hljs-number">1</span>
my_kext_iouserclient = <span class="hljs-number">1</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap ekstensi kernel yang ingin didaftarkan pada tumpukan driver harus mendeklarasikan kelas yang diwarisi dari IOService, misalnya, my_kext_ioservice dalam kasus ini. Menghubungkan aplikasi pengguna akan membuat instance baru dari kelas yang diwarisi dari IOUserClient, dalam contoh my_kext_iouserclient. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika mencoba untuk membongkar driver dari sistem (perintah kextunload), fungsi virtual "bool terminate (opsi IOOptionBits)" disebut. </font><font style="vertical-align: inherit;">Sudah cukup untuk mengembalikan false pada panggilan ke fungsi terminate ketika mencoba membongkar untuk menonaktifkan kextunload.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Kext::terminate</span><span class="hljs-params">(IOOptionBits options)</span>
</span>{<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!IsUnloadAllowed)<font></font>
  {<font></font>
    <span class="hljs-comment">// Unload is not allowed, returning false</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> super::<span class="hljs-built_in">terminate</span>(options);<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bendera IsUnloadAllowed dapat diatur oleh IOUserClient saat boot. </font><font style="vertical-align: inherit;">Ketika memuat terbatas, perintah kextunload akan mengembalikan output berikut:</font></font><br>
<br>
<pre><code class="cpp hljs">admin@admins-Mac drivermanager % sudo kextunload ./test.kext<font></font>
Password:<font></font>
(kernel) Can<span class="hljs-number">'</span>t remove kext my.kext.test; services failed to <span class="hljs-built_in">terminate</span> - <span class="hljs-number">0xe00002c7</span>.<font></font>
Failed to unload my.kext.test - (iokit/common) unsupported function.<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlindungan serupa harus dilakukan untuk IOUserClient. </font><font style="vertical-align: inherit;">Instance kelas dapat dibongkar menggunakan fungsi userspace IOKitLib “IOCatalogueTerminate (mach_port_t, flag uint32_t, io_name_t description);”. </font><font style="vertical-align: inherit;">Anda dapat mengembalikan false pada panggilan ke perintah "terminasi" sampai userspace aplikasi mati, yaitu, tidak ada panggilan ke fungsi clientDied.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlindungan file</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk melindungi file, cukup menggunakan API Kauth, yang memungkinkan Anda membatasi akses ke file. Apple memberikan pemberitahuan kepada pengembang tentang berbagai peristiwa dalam ruang lingkup, operasi KAUTH_VNODE_DELETE, KAUTH_VNODE_WRITE_DATA dan KAUTH_VNODE_DELETE_CHILD penting bagi kami. Membatasi akses ke file paling mudah di sepanjang jalan - kami menggunakan API "vn_getpath" untuk mendapatkan path ke file dan membandingkan awalan path. Perhatikan bahwa untuk mengoptimalkan penggantian nama jalur folder dengan file, sistem tidak mengotorisasi akses ke setiap file, tetapi hanya ke folder itu sendiri, yang diganti namanya. Kita perlu membandingkan jalur induk dan membatasi KAUTH_VNODE_DELETE untuk itu.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6e2/ab5/2fb/6e2ab52fb8c17ea8adfe8b63bcf8f611.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kerugian dari pendekatan ini mungkin kinerja rendah dengan meningkatnya jumlah awalan. Agar perbandingannya tidak sama dengan O (awalan * panjang), di mana awalan adalah jumlah awalan, panjang adalah panjang string, Anda dapat menggunakan mesin keadaan terbatas deterministik (DFA) yang ditentukan oleh awalan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan cara untuk membangun DFA untuk serangkaian awalan yang diberikan. Kami menginisialisasi kursor di awal setiap awalan. Jika semua kursor menunjuk ke karakter yang sama, maka kami menambah setiap kursor dengan satu karakter dan ingat bahwa panjang garis yang sama lebih dari satu. Jika ada dua kursor dengan simbol yang berbeda di bawahnya, kami membagi kursor ke dalam kelompok dengan simbol yang mereka arahkan dan ulangi algoritma untuk setiap grup.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus pertama (semua karakter di bawah kursor adalah sama), kita mendapatkan status DFA, yang hanya memiliki satu transisi pada baris yang sama. </font><font style="vertical-align: inherit;">Dalam kasus kedua, kita mendapatkan tabel transisi ukuran 256 (jumlah karakter dan jumlah grup maksimum) di negara-negara berikutnya yang diperoleh dengan memanggil fungsi secara rekursif. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan sebuah contoh. </font><font style="vertical-align: inherit;">Untuk satu set awalan ("/ foo / bar / tmp /", "/ var / db / foo /", "/ foo / bar / aba /", "foo / bar / aac /") Anda bisa mendapatkan DFA berikut. </font><font style="vertical-align: inherit;">Angka tersebut hanya menunjukkan transisi yang mengarah ke negara lain, transisi lain tidak akan bersifat final. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/190/d0f/5ec/190d0f5ec1fdd8c03df23387d83db44a.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat melewati negara bagian DKA, mungkin ada 3 kasus.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status akhir tercapai - jalur dilindungi, kami membatasi operasi KAUTH_VNODE_DELETE, KAUTH_VNODE_WRITE_DATA dan KAUTH_VNODE_DELETE_CHILD</font></font></li>
<li>    ,   “” (  -) —   ,   KAUTH_VNODE_DELETE. ,   vnode  ,     ‘/’,         “/foor/bar/t”,  .</li>
<li>    ,   .       ,   .</li>
</ol><br>
<h3></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tujuan dari solusi keamanan yang dikembangkan adalah untuk meningkatkan tingkat keamanan pengguna dan datanya. Di satu sisi, tujuan ini dipastikan oleh pengembangan produk perangkat lunak Acronis yang mencakup kerentanan di mana sistem operasi itu sendiri “lemah”. Di sisi lain, kita tidak boleh mengabaikan peningkatan aspek-aspek keamanan yang dapat ditingkatkan di sisi OS, terutama karena penutupan kerentanan tersebut meningkatkan stabilitas kita sendiri sebagai sebuah produk. Kerentanan ini dilaporkan oleh Tim Keamanan Produk Apple dan diperbaiki di macOS 10.14.5 (https://support.apple.com/en-gb/HT210119).</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e27/604/c24/e27604c248d5405276235cf613319754.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua ini dapat dilakukan hanya jika utilitas Anda telah diinstal secara resmi di kernel. </font><font style="vertical-align: inherit;">Artinya, tidak ada celah seperti itu untuk perangkat lunak eksternal dan yang tidak diinginkan. </font><font style="vertical-align: inherit;">Namun, seperti yang Anda lihat, bahkan untuk melindungi program yang sah seperti antivirus dan sistem cadangan, Anda harus bekerja keras. </font><font style="vertical-align: inherit;">Tetapi sekarang, produk Acronis baru untuk macOS akan memiliki perlindungan tambahan terhadap pembongkaran dari sistem.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id497688/index.html">Bagaimana Cara Kerja Sekolah Malam Kubernetes</a></li>
<li><a href="../id497696/index.html">Bagaimana Ryuk ransomware yang menyerang perusahaan</a></li>
<li><a href="../id497700/index.html">Mitaps online mingguan untuk dukungan dan DevOps, keamanan, dan robot mulai 17 April</a></li>
<li><a href="../id497702/index.html">Lima tren dalam penyimpanan data yang harus Anda perhatikan di tahun 2020</a></li>
<li><a href="../id497708/index.html">Kami mengundang Anda ke serangkaian webinar Fujitsu pada bulan April dan Mei</a></li>
<li><a href="../id497724/index.html">Mempersiapkan server untuk menerbitkan aplikasi web dengan Python</a></li>
<li><a href="../id497726/index.html">Scaling Pengujian Android di Odnoklassniki</a></li>
<li><a href="../id497728/index.html">Bahaya “membakar” keripik</a></li>
<li><a href="../id497730/index.html">BDD Nyaman: SpecFlow + TFS</a></li>
<li><a href="../id497736/index.html">Ulasan 10 mesin pembakaran internal baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>