<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📀 🥨 👩🏼‍🌾 コンパイラー最適化のプリズムによるC ++例外 👨🏼 🃏 👨‍👧‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="21世紀以外では、setjmp / longjmpに基づくC ++例外処理の非生産的な実装はすでに過去にあります。gccやclangなどの最新のコンパイラは、ゼロコスト例外処理と呼ばれるC ++例外の高度な実装を使用します。しかし、このゼロコストはどれほど真実なのでしょうか？
 
 C ++ Rus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>コンパイラー最適化のプリズムによるC ++例外</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/494986/"><img src="https://habrastorage.org/webt/kn/ko/yp/knkoypvfilv3v6x_8tmlb1hhozu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
21世紀以外では、setjmp / longjmpに基づくC ++例外処理の非生産的な実装はすでに過去にあります。</font><font style="vertical-align: inherit;">gccやclangなどの最新のコンパイラは、ゼロコスト例外処理と呼ばれるC ++例外の高度な実装を使用します。</font><font style="vertical-align: inherit;">しかし、このゼロコストはどれほど真実なのでしょうか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ Russia 2019 Piterカンファレンスで、Roman RusyaevはC ++例外がコンパイラの最適化にどのように影響するかについて説明しました：関数が例外をスローできる場合に適用できない最適化と、適用するのが困難になる最適化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Romanは、Cambridgeで動作するNeural Processing Unitなどの専用プラットフォーム向けのC / C ++コンパイラおよびニューラルネットワークコンパイラの開発者です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カットの下で、テキストのデコードとビデオレポート。</font></font><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/ItemByR4PRg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投稿で、Romanは次のように伝えます。</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外の実装について</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVMでの例外のサポート方法。</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外がコンパイラの最適化にどのように影響するか（例としてLLVMを使用）。</font></font></a></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次は話者に代わるナラティブです。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++例外はアプリケーションのパフォーマンスにどのように影響しますか？</font><font style="vertical-align: inherit;">この問題を、パフォーマンスについて通常考えていたのとは異なる角度から検討してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイナリファイルのサイズまたはプログラムの実行時間の増加を示す数値はありません。</font><font style="vertical-align: inherit;">コンパイラが例外を処理するプロセスでスタックアンワインダーによって使用される特別な情報を配置することは秘密ではありません。これにより、バイナリファイルが展開されます。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">記事</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
が</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで、例外を実装する2つの異なるアプローチを説明し、パフォーマンス測定を示します。</font><font style="vertical-align: inherit;">例外がミドルエンドコンパイラにどのように影響するか、つまり、アプリケーションがより高速に動作するようにアプリケーションを最適化する役割を持つ部分について話しましょう。</font><font style="vertical-align: inherit;">C ++の最も重要な原則の1つが尊重されているかどうかを見てみましょう。使用しないものについては支払いをしません。</font><font style="vertical-align: inherit;">例外をスローしないいくつかの関数がありますが、それらをnoexceptでマークしていないか、またはアセンブリ中に特別なフラグを表示していません。アプリケーションのパフォーマンスに関して追加のコードはありますか？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レポートの目的</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最適化コンパイラーがC ++例外を処理する方法、およびアプリケーションのパフォーマンスにどのように影響するか：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外がスローされなくても、例外はどれほど高価ですか？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外を使用しない方がよい場合。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能な限り例外はありません。</font></font></b></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが支払うことを示したとしましょう。</font><font style="vertical-align: inherit;">しかし、それについて何をすべきか？</font><font style="vertical-align: inherit;">最も明白な結論は、例外を使用しないことです。</font><font style="vertical-align: inherit;">しかし、すべてのアプリケーションがこれを実行できるわけではありません。</font><font style="vertical-align: inherit;">誰かが例外メカニズムを通じてアプリケーションのエラーを処理すると便利です。</font><font style="vertical-align: inherit;">いずれにせよ、ほとんどのコードはまだ例外をスローせず、どういうわけかそれに影響を与えることができます。</font><font style="vertical-align: inherit;">私の主なポイントの1つは、可能な限りnoexceptを使用することです。</font><font style="vertical-align: inherit;">関数が例外をスローしない場合は、 "noexcept"を指定してください。</font><font style="vertical-align: inherit;">何故ですか？</font><font style="vertical-align: inherit;">少し後で検討します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、反対側の陣営、つまり他の方法で考える人々について考えてみましょう。視点があります-どこでもconstを使用してください。値が不変である場合、constをマークすることは論理的です。このキャンプでは、constをどこにでも置く必要があると考えています。ローカル変数、値によって渡される関数パラメーター、戻り値などですが、統計分析などのさまざまな手段を使用して、このルールへの準拠を保証できるとは限りません。コードのレビュープロセスでは、これらの場所のいずれかをスキップできます。コードに一貫性がない：どこかでconstになる、どこかでconstにならない、行が長くなると、これが原因で読みやすさに影響し、移動のセマンティクスによってすべてがさらにおもしろくなる。モーションコンストラクターを呼び出す必要がある場所では、コピーコンストラクターが呼び出されます。そのようなキャンプがあり、彼は彼自身の議論を持っています。noexceptについてはどうですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
矛盾が発生する可能性があると信じている人々の陣営があります-誰かがnoexceptを置くことを忘れるでしょう。</font><font style="vertical-align: inherit;">関数の初期設計では、例外をスローするかどうかを決定する必要があります。</font><font style="vertical-align: inherit;">noexceptをぶら下げて、それを削除する必要がある場合（これは既にインターフェイスの一部です）、ユーザーコードはこれに基づいて構築できます。</font><font style="vertical-align: inherit;">「なぜ私たちが与えるものを除いて、なぜ私たちは通常何もしないのですか？」と言う支持者がいます。</font><font style="vertical-align: inherit;">noexceptでどんな利益が得られるかを実演してみます。</font></font><a name="real"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外実装の紹介</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例外がどのように実装されるか、コンパイラで何が行われるか、ランタイムで何が必要かを一般的に理解しましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例外の実装はかなりプラットフォーム固有のものであるため、現在広く普及しているプラ​​スとプラスのABIを採用しました。IBIは、Itanium CXX ABIです（仕様は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itanium C ++ ABIで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明されてい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゼロコストの例外処理（0eh）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゼロコスト例外処理という用語は、例外を実装するときにHewlett-Packardによって導入されました。彼はどういう意味ですか？例外をスローしない場合、追加のコードは実行されません。 C ++のすべてのゼロコスト抽象化と同様に、例外をスローしない限り、追加の動的命令を実行しないことを宣言します。動的実行に加えて、コンパイラーが使用する静的コードもあります。コンパイラは、このコードが実行されるかどうか、ホットかコールドかを理解できません。特定のヒューリスティック、プロファイリングなどがあります。コンパイラーは何らかの方法で静的コードのみを認識し、動的実行は認識しません。そして、ここでコンパイラのゼロコストは、もはやまったくゼロコストではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが使用する用語について少し。</font><font style="vertical-align: inherit;">noexceptについてのみ説明します。</font><font style="vertical-align: inherit;">noexceptを関数でハングさせて、例外をスローしないことを宣言できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要な条件：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタックの巻き戻し-スローされた例外のオブジェクトに対応する例外ハンドラーでフレームが見つかるまで、各スタックフレームのローカルオブジェクトのデストラクタを呼び出します。</font><font style="vertical-align: inherit;">2つのフェーズで構成されます。</font><font style="vertical-align: inherit;">Itanium ABIでは、これはハンドラー検索フェーズとクリーンアップフェーズです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クリーンアップは、スタックの巻き戻しプロセスでローカルオブジェクトデストラクタを呼び出します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外ハンドラーは、最終的に実行されるコードです。</font><font style="vertical-align: inherit;">常に例外ハンドラがあります。catchを設定していなくても、terminateが呼び出されます。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std ::終了</font></font></h3> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
terminateが呼び出されるケースはたくさんあります。最初に検討するのは、例外の仕様に違反した場合です。 noexceptとマークされた関数から例外がスローされます。クリーンアップから例外がスローされた場合、terminateも呼び出されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2p/ez/uy/2pezuylpw9g6ze9ddotftjtxcqe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例外をスローするとどうなるかを示す例を考えてみます。あなたには機能があります。あなたのコード-ユーザーコードとC ++ランタイムコード-があり、これらはすべての種類の巻き戻しが実装されているC ++サポートライブラリです。例外がスローされます。赤い矢印でC ++ランタイムに移動します。検索フェーズが行われています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハンドラが見つからない場合は、terminateを呼び出します。それ以外の場合は、2番目の段階であるクリーンアップ段階に進みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それから、クリーンアップ自体を実行するコードに渡します。</font><font style="vertical-align: inherit;">アプリケーションのこのコードはコンパイラーをビルドします。</font><font style="vertical-align: inherit;">ローカルオブジェクトのデストラクタへの呼び出しが含まれています。いくつかの追加アクションがある場合があります。</font><font style="vertical-align: inherit;">またはそれはハンドラです。</font><font style="vertical-align: inherit;">たとえば、あなたが書いたキャッチ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの開発パスがあります：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常のフローでキャッチを終了すると、それだけです。コードに残ります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クリーンアップから、コンパイラーは、クリーンアップの第2段階に戻る特別な関数の呼び出しを作成します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3番目のオプションはプラットフォーム固有です。</font><font style="vertical-align: inherit;">LLVMの場合：noexceptを持つ関数がその仕様に違反している場合（この関数から例外がスローされます）、terminateが呼び出されます。</font><font style="vertical-align: inherit;">このターミネートはユーザーコードに組み込まれています。</font><font style="vertical-align: inherit;">標準によれば、これは実装定義です。つまり、スタックを完全にまたは部分的にスピンするか、スタックをまったくスピンせず、すぐに終了を呼び出します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ミドルエンドで何が行われたかを検討してください。</font></font><a name="sup"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM IRの概要</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中間表現-ASTからIRを生成するフロントエンドの結果として取得される、中間表現、コンパイラによって使用される特定のデータ構造または言語。</font><font style="vertical-align: inherit;">IRからミドルエンドまで、コードを高速化するために、すべての最適化、分析、変換が機能します。</font><font style="vertical-align: inherit;">LLVMの少し切り捨てたバージョンを使用しますが、正確さを犠牲にせず、よりわかりやすくします。</font><font style="vertical-align: inherit;">いつでも、このIRを使用して、完全なビューに仕上げることができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM IR疑似コードの手順の例</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％val-ローカル変数またはラベルの宣言。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alloca-タイプtypeのオブジェクトのメモリスタックへの割り当て。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">call-func_nameという名前の関数を呼び出す命令。</font></font></li>
</ul> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要なポイント-通話には特別な機能があります。これは、この呼び出しから例外をスローできるかどうかを示すバイナリサインです。この機能は、最適化で頻繁に使用されます。 returnステートメントは、関数からの戻りでもあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0n/ez/ds/0nezdsf2ahvk3sdzf99zfkrlvmq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ミドルエンドコンパイラのプログラム全体は、制御フローグラフ（制御フローグラフ）として表示されます。ノードが命令のバンドルである特別なグラフ。このノードは基本ブロックと呼ばれます。ベースユニットにある命令のバンドルには特定のプロパティがあります。このベースユニットに行くと、その中のすべての命令を実行するか、まったく到達しないかのどちらかになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nh/nq/a1/nhnqa1vogwsnc0tyd_of5gy9pdy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本ユニットは、ターミネーターと呼ばれる特別な命令で終わります。</font><font style="vertical-align: inherit;">これは、何らかのブランチ（遷移、条件付き、または無条件）にすることも、関数からの戻り命令にすることも、呼び出しと呼ばれる特別な命令にすることもできます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM例外サポート：呼び出し、ランディングパッド、再開</font></font></h2> <br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外がスローされた場合にコードセグメントに暗黙的に遷移する関数を</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
呼び出して、foo（）を呼び出してlabel％1を戻し、label％2を巻き戻します。</font></font></li>
<li><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ランディングパッドの</font><font style="vertical-align: inherit;">例外の処理を担当するコード</font></font></li>
<li><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再開</font><font style="vertical-align: inherit;">スタックを再開する命令</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
呼び出し-端末命令。彼女はベースユニットを完成させ、2つの操作のセマンティクスを持っています。 1つ目は、callステートメントと同様の関数呼び出しのセマンティクスですが、呼び出された関数が正常に実行された場合（例外がスローされなかった場合）、制御は％1というラベルの付いたブロックに移されます。関数の例外がスローされた場合、制御は基本単位％2に移されます。このブロックは、特別なランディングパッド命令で始まり、例外ハンドラーコードやクリーンアップ（ローカルオブジェクトデストラクタの呼び出し）を含んでいます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スタックの昇格を続ける必要がある場合は、特別な再開ステートメントが作成され、その後、コントロールはこの関数に戻りません。</font><font style="vertical-align: inherit;">Resumeは、ABIによって定義された特別な関数の呼び出しに変換され、クリーンアップの第2段階に戻ります。</font><font style="vertical-align: inherit;">Invokeは、オプティマイザが暗黙的な制御フローを表示するために必要な疑似命令です。</font><font style="vertical-align: inherit;">アセンブラでは、通常の関数呼び出し命令で表現されます。</font></font><a name="inf"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラの最適化に対する例外の影響</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの重要なポイント。</font><font style="vertical-align: inherit;">「例外をスローするかしないか」という記号の付いた呼び出し命令があり、呼び出しと同じように機能する呼び出し命令があります-関数を呼び出します-条件付き分岐の追加のセマンティクスがあります。</font><font style="vertical-align: inherit;">条件付きジャンプ-暗黙的、例外がスローされた場合、コンパイラーが生成するコードの特別なセクションに移動します。</font><font style="vertical-align: inherit;">Invokeは終了命令であり、基本ブロックはそれで終わります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべてが最適化によってダイジェストされる方法に移りましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オーバーヘッド（オプティマイザの観点から）</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのようにオーバーヘッドを取得しますか？ランタイム側とバイナリファイルのサイズの増加による追加のオーバーヘッドがあるため、重要な点は正確にミドルエンドの観点から見たオーバーヘッドです。 1つ目のポイントは、関数のサイズの増加です。これは、コンパイラがランディングパッドを構築し、これらのランディングパッドを呼び出して、クリーンアップコードが作成されるためです。つまり、デストラクタが呼び出されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のポイントは、invoke命令による制御フローの複雑さです。</font><font style="vertical-align: inherit;">呼び出しは通常の命令であり、ベースユニットの最初、最後、中央のどこでも可能です。</font><font style="vertical-align: inherit;">呼び出しの場合、ベースブロックはそれらに沿ってカットされ、より多くのベースブロックが表示されます。</font><font style="vertical-align: inherit;">条件付き遷移が表示されるため、制御フローは複雑であり、ベースユニット内で機能する最適化（のぞき穴の最適化）は、適用するコンテキストが少なくなります。</font><font style="vertical-align: inherit;">呼び出しではなく呼び出しを行った場合よりも、命令の数が少なくなっています。</font><font style="vertical-align: inherit;">最新のコンパイラは優れています。</font><font style="vertical-align: inherit;">Clangは活発に開発されています。このオーバーヘッドを排除する特定の最適化があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オーバーヘッド-克服する方法？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の最適化はPruneEHです。呼び出しを呼び出しに変換し、フラグを設定します-例外をスローしない関数のnounwind。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jy/ze/xh/jyzexhppwx1cglh1hzywgvgq944.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードについて考えてみましょう。左側はC ++、他方はLLVMです。 BarはextF関数を呼び出します。なぜ起動しないのですか？ barにはローカルオブジェクトがないため、追加のアクションを実行する必要はありません。 barを呼び出すfooでは、デストラクタを呼び出すローカルオブジェクトが宣言されているため、関数barはinvokeによって呼び出されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/an/f4/tz/anf4tzvno2suvvyslss1m7e4ifo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常の場合、ラベル「4」に到達し、このオブジェクトを破棄して、関数を終了します。例外がスローされた場合、ラベル「5」に到達し、そこでデストラクタを呼び出して、スタックの昇格を続行します。 PruneEHは何をしますか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hp/0j/ay/hp0jaymiz1dzgnucdwpnhxsnfsm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
違いを見てください。それはそうでしたが、それはそうなっています。</font><font style="vertical-align: inherit;">extF関数にはnoexceptというラベルが付いているためです。</font><font style="vertical-align: inherit;">最適化は次のように機能します。コールグラフを分析し、コールグラフを下から上に歩いて行き、途中で発生した場合はnoexcept記号を伝播し、呼び出し命令を呼び出し命令に変換します。</font><font style="vertical-align: inherit;">彼女の仕事の結果を見る。</font><font style="vertical-align: inherit;">その関数が例外をスローしないと判断できました。つまり、この属性を伝達して呼び出しに変換できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その他の最適化</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、たとえば、CFGの簡略化など、いくつかの最適化があります。</font><font style="vertical-align: inherit;">通常、各呼び出しは独自のランディングパッドを構築しますが、ランディングパッドは同じでもかまいません。</font><font style="vertical-align: inherit;">CFGを簡素化してこれらのランディングパッドを組み合わせ、関数コードのサイズを最小化し、他の最適化に有利に影響する不要な命令を削除します。</font><font style="vertical-align: inherit;">GVOはPruneEHと同様のことを行います。</font><font style="vertical-align: inherit;">命令の組み合わせは、ベースユニットで機能するのぞき穴の最適化の一種です。</font><font style="vertical-align: inherit;">noexcept関数を呼び出す呼び出し命令をnoexceptとしてマークします。これは、その後の最適化にも役立ちます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オーバーヘッドを克服できないのはどこですか？</font></font></h2><br>
<img src="https://habrastorage.org/webt/j2/nf/o4/j2nfo4nhn0pwsalsiuoppak1ves.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インラインが最も影響を受けます。</font><font style="vertical-align: inherit;">インライン-呼び出された関数の本体を呼び出し元に置き換える、概念的に単純な最適化。</font><font style="vertical-align: inherit;">すべて。</font><font style="vertical-align: inherit;">しかし、実装の観点から見ると、これは最も難しい最適化の1つです。</font><font style="vertical-align: inherit;">彼女は、この関数をインライン化する必要があるかどうかを理解しているコストモデルやさまざまなヒューリスティックを使用しています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インライン：ヒューリスティック </font></font></h2><br>
<pre><code class="cpp hljs">CallAnalyzer::analyzeBlock(…) { <font></font>
… <font></font>
addCost(…); <span class="hljs-comment">// for each instruction add cost … </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要なヒューリスティックの1つは、インライン化する現在の関数の命令数です。すでに多くの指示がある場合は、別の関数がインライン化される可能性が低くなります。呼び出しが原因で、コンパイラはデストラクタを呼び出す追加のコードを生成し、コードの静的サイズが増加し、インラインの動作が悪化し始めます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m5/2a/bh/m52abhgfgfvibu0qz_fcrstla_4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を考えてみましょう。 fooから呼び出しによって呼び出すbar関数があり、例外がスローされた場合は、ランディングパッドに移動してそこでデストラクタを呼び出します。これは完全に取るに足らない合成例であり、何もしませんが、すでに関数コードのサイズが大きくなっています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d3/6o/ez/d36oezewzqyiwjynj30naqocixw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例は、制御命令を使用してローカルオブジェクトを作成し、呼び出しによってコードが膨らみ、インライン化の可能性が減少することを示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jy/rg/ds/jyrgdswsis88xyngbtdy3gqogxy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒューリスティックの観点からは、ここでは何もできません。コードが大きくなり、インライン確率が低くなります。克服するのがかなり難しい技術的な問題がまだあります。関数f2が呼び出される関数f1があり、関数f1には、例外がスローされた場合に破棄する必要があるローカルオブジェクトがあり、それらに対してデストラクタを呼び出す必要があります。 f1にインライン化する関数f2は、通常の呼び出しで他の関数f3を呼び出します。 f2をf1にインライン化する場合、f3をどうすればよいでしょうか。呼び出しで呼び出す必要があります。インライン化する前に、f2と呼ばれるf1を呼び出し、f3からf3を呼び出すプロセスで例外をスローし、スタックを拡張し、f1にあるランディングパッドを実行する必要があります-クリーンアップを行い、ローカルオブジェクトデストラクタを呼び出します。 f2をインライン化する場合は、f3を呼び出したままにしておくと、ランディングパッドに到達できません。オプティマイザは、例外がスローされた場合に実行する必要があるコードの種類を確認できません。インラインf2の後、callを介して呼び出されたすべての関数は、invokeを介して呼び出す必要があります。インラインf2の後、callを介して呼び出されたすべての関数が、invokeを介して呼び出されるようになりました。つまり、制御フローがさらに複雑になり、余分な条件遷移が発生しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/is/am/rk/isamrk9tyu1pltz7hp9kh8u2nii.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
extFを呼び出すバーがありました。この例では、インラインで呼び出しを介してextFを呼び出していますが、呼び出しを介してバーで呼び出されています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bn/g0/0x/bng00xp5twoeatxwukifovgjigk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resumeは、スタックを巻き戻し続ける命令です。つまり、制御をランタイムC ++コードに移します。例：これを</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fe/rm/hd/fermhdnzp25mvrfa4vxqz-mru0k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変更し、ローカルオブジェクトをbarに追加して、invokeを介してextFが呼び出されるようにします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/op/nu/sr/opnusrplfzjjdblnxllo8hpfe58.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じf1、f2、f3、今ではf3は呼び出しではなく呼び出しによって呼び出されます。履歴書を削除する必要があります。履歴書を残した場合、landingpad1は実行されないため、インラインの後で実行する必要があります。履歴書を削除し、制御フローをlandingpad1にリダイレクトします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pg/xu/gm/pgxugms_hzwt15qd4vsh9srhhjk.png"><br>
<br>
<img src="https://habrastorage.org/webt/wo/dw/c9/wodwc9m3p93zkrd83qsrhk8z5de.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tail Callも古典的な最適化です。スタックフレームを作成することによって生じるオーバーヘッドを最小限に抑えます。</font><font style="vertical-align: inherit;">関数の最後にある呼び出しを単にジャンプステートメントに変換します。つまり、制御を次の関数に移します。</font><font style="vertical-align: inherit;">すべてのアーキテクチャで実行できるわけではないため、最適化はバックエンドで実行されます。</font><font style="vertical-align: inherit;">ジャンプ命令の制御転送アドレスが呼び出しよりも少ないビットでエンコードされるアーキテクチャがあり、ジャンプ内のすべてのアドレスを表すことができるわけではありません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テールコールは呼び出し命令に適用されません</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
呼び出しをジャンプとして提示できる場合、つまり、関数呼び出しの代わりに遷移を行う場合、invokeはできません。呼び出し元の関数に戻ることはなく、実行するはずのランディングパッドでコードを実行しません。 Tail Callは、呼び出しには適用されません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pi/ro/be/pirobedosepqnnb1c4lqpfr0abq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ループフュージョンもクラシックです-隣接するサイクルを組み合わせて-オーバーヘッドをサイクルごとに削減します。つまり、2つではなく1つ実行します。この最適化は、のぞき窓、ベクトル化などの他の最適化の補助にもなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例外をスローする可能性があるという兆候のある呼び出しがループ内にある場合、最適化はこの関数を副作用と見なすため、このループを候補として見なしません。彼女はそのようなサイクルを組み合わせる方法を知りません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wi/nr/lk/winrlkiy0jy-6usytgowvimruhu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LICM（ループインバリアントコードモーション）は、アップサイクルとダウンサイクル（前サイクル/後サイクル）から不変条件を削除し、ロードとストアをプルします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サイクルに関して不変であると判断した場合、呼び出しを行うことができますが、例外をスローする可能性のある呼び出しと呼び出しには適用されません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6y/ru/qi/6yruqiyrrkfahqucp8xfiwp7wxa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ADCEは、最も強力なデッドコード除去機能です。多くの場合、そのためのコンテキストを作成する他のさまざまな最適化の後に適用されます。命令、レジスターが少なくなり、レジスターへの圧力が軽減されるため、レジスターアロケーターなど、多くのさらなる最適化にプラスの効果があります。インラインの場合、同じこと-コードのサイズを最小限に抑えます-インラインの可能性が高くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アグレッシブバージョンは次のように機能します。</font><font style="vertical-align: inherit;">彼女は最初、関数内のすべての命令は無効であると信じ、反対を証明し始めます。</font><font style="vertical-align: inherit;">特定の命令の最適化によってこの命令がライブであると判断された場合、データストリームによって関連付けられているこの命令のすべての先行ノードに「活性」が伝播します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dn/cy/hf/dncyhffvcxhlpdebukyv-ftwqdw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この命令が常に有効であるかどうかをチェックする関数isAlwaysLiveがあります。</font><font style="vertical-align: inherit;">また、着陸パッドについては、追加のチェックをせずに、すべての端末の指示について、「はい、常に」と言います。</font><font style="vertical-align: inherit;">Invokeは終了命令です。</font><font style="vertical-align: inherit;">この結果、「デッド」コールの場合、最適化はそれを削除できますが、呼び出しの場合（これが最終命令であるため）、データストリーム内の先行のように、最適化はそれを削除しません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用語について</font></font></h3><br>
<blockquote>   ,      —   ,   .   —  ,    ,     .   return    - .    —  ,  ,        ,      ,       .</blockquote><br>
<br>
<img src="https://habrastorage.org/webt/qe/kz/aa/qekzaa69opncd9vyxuyxqefnm3q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シンクは、後続の値に近い値を定義するすべての命令を転送するため、動的に実行される命令の数が減ります。例：あるval値のある種のdefがあり、別の基本ユニットで使用されていた場合、最適化はこのdefを使用が配置されている同じ基本ユニットに転送します。 valの使用が含まれていない他のベースユニットが高温だった場合（つまり、制御が頻繁に転送された場合）、追加の指示には従わないため、パフォーマンスにプラスの影響を与えます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kr/-2/3l/kr-23lnqahozzpnpi_b4zvx0k_c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
isSafeToMove関数は、命令を移動できるかどうかを確認します。呼び出しが例外をスローした場合、最適化は適用されません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dz/30/5o/dz305oqdsfdjnej-eag0rse4a-m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マージされたロード/ストアは、ストアを1つに結合し、コード内の静的命令の数を最小限に抑えます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jw/68/r_/jw68r_eaup9wmgboxxdq7h_g6us.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
isStoreSinkBarrierInRange関数は、開始命令と終了命令の間にある命令を引き出すことが可能かどうかを確認します。</font><font style="vertical-align: inherit;">これらの命令の間に例外をスローする呼び出しがある場合、これを行うことはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その他の最適化：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mayHaveSideEffects;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mayThrow;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doesNotThrow。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の関数は、関数が例外をスローするかどうか、および命令に副作用があるかどうかをチェックします。 </font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの古典的な最適化で示したように、ゼロコストは、オプティマイザの観点からゼロからはほど遠いです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このオーバーヘッドを最小限に抑える最適化は多数ありますが、関数が例外をスローしないことを何らかの形で証明できると期待しています。これは、関数が外部の場合（つまり、コンパイラがその定義を認識しない場合）、noexceptでマークする必要があることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライブラリを開発している場合、ユーザーが誰になるかを確認することは理にかなっています。ユーザーが例外なくアプリケーションを作成すれば、ユーザーの数を減らすことができるからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主な結論-すべての場所にnoexceptを置きます。これはたった1語であり、そのスペルは何の費用もかかりませんが、同時に、アプリケーションのパフォーマンスに関して潜在的な利益を得ることができます。</font></font><br>
<br>
<blockquote>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> ++ Russia 2020 Moscow</a>    :    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">    copy elision</a>.        (    ++)      !    — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>.<br>
<br>
 ,     C++,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">8  </a>,       , DevOps   .</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja494966/index.html">スクラム：愛と痛みに関する詩</a></li>
<li><a href="../ja494968/index.html">水中インターネットケーブル：誰がそれらをルーティングするか</a></li>
<li><a href="../ja494970/index.html">内向：エラーの範囲内のランダム性、または種保護の進化メカニズム？</a></li>
<li><a href="../ja494972/index.html">SEMrushとSimilarWeb-どちらがより正確ですか？</a></li>
<li><a href="../ja494978/index.html">Windows PowerShellとは何で、何を食べますか？パート4：オブジェクト、カスタムクラスの操作</a></li>
<li><a href="../ja494990/index.html">時間を正しく使用する：Tinderのプロセス自動化</a></li>
<li><a href="../ja494992/index.html">数学、パンデミック、検疫について、続き</a></li>
<li><a href="../ja494994/index.html">コンピュータサイエンスの定理の重要な証明は数学で物理学を捉えます</a></li>
<li><a href="../ja494998/index.html">SHADでの試験のアルゴリズム</a></li>
<li><a href="../ja495000/index.html">データホーム：スマートモノのエコシステムによって生成されるデータの種類</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>