<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçπ üë©üèæ‚Äçü§ù‚Äçüë©üèª üåá Patrones de almacenamiento de Kubernetes ü§¶üèª üòÆ üßô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! 
 
 Le recordamos que hemos lanzado otro libro extremadamente interesante y √∫til sobre los patrones de Kubernetes. Todo comenz√≥ con los " P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Patrones de almacenamiento de Kubernetes</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/490180/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ku/xh/fw/kuxhfwyrk51o4xpq6d1km-gpfbg.png"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hola Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le recordamos que hemos lanzado otro </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libro</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> extremadamente interesante y √∫til </font><font style="vertical-align: inherit;">sobre los patrones de Kubernetes. </font><font style="vertical-align: inherit;">Todo comenz√≥ con </font><font style="vertical-align: inherit;">los </font><font style="vertical-align: inherit;">" </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patrones</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " de </font><font style="vertical-align: inherit;">Brendan Burns y, por cierto, el trabajo en este segmento est√° en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pleno apogeo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Hoy lo invitamos a leer un art√≠culo del blog de MinIO que resume las tendencias y detalles de los patrones de almacenamiento de datos en Kubernetes.</font></font><br>
<a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes cambi√≥ fundamentalmente los patrones tradicionales de desarrollo e implementaci√≥n de aplicaciones. </font><font style="vertical-align: inherit;">Ahora el equipo puede tardar unos d√≠as en desarrollar, probar e implementar la aplicaci√≥n, en diferentes entornos, y todo esto dentro de los cl√∫steres de Kubernetes. </font><font style="vertical-align: inherit;">Tal trabajo con tecnolog√≠a de generaciones anteriores usualmente tom√≥ semanas, si no meses.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tal aceleraci√≥n fue posible gracias a la abstracci√≥n proporcionada por Kubernetes, es decir, debido al hecho de que Kubernetes interact√∫a con detalles de bajo nivel de m√°quinas f√≠sicas o virtuales, lo que permite a los usuarios declarar, entre otros par√°metros, el procesador deseado, la memoria requerida, el n√∫mero de instancias de contenedor. Como Kubernetes cuenta con el respaldo de una gran comunidad y el alcance de Kubernetes se expande constantemente, lidera por un amplio margen entre todas las plataformas de orquestaci√≥n de contenedores. </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A medida que se expande el uso de Kubernetes, tambi√©n lo hace la confusi√≥n sobre los patrones de almacenamiento utilizados en √©l</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con la competencia general por un pedazo de pastel de Kubernetes (es decir, para el almacenamiento de datos), cuando se trata de hablar sobre el almacenamiento de datos, la se√±al se est√° ahogando en un ruido fuerte. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes incorpora un modelo moderno para desarrollar, implementar y administrar aplicaciones. Un modelo tan moderno separa el almacenamiento de datos de la inform√°tica. Para comprender completamente esta separaci√≥n en el contexto de Kubernetes, tambi√©n debe comprender qu√© son las aplicaciones con estado y sin estado, y c√≥mo se combina el almacenamiento de datos con esto. Aqu√≠ es donde el enfoque REST API utilizado por S3 tiene claras ventajas sobre el enfoque POSIX / CSI que es t√≠pico de otras soluciones.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este art√≠culo hablaremos sobre los patrones de almacenamiento en Kubernetes y discutiremos por separado el debate sobre las aplicaciones aptas y sin estado, para que podamos comprender claramente la diferencia entre ellas y por qu√© es importante. </font><font style="vertical-align: inherit;">M√°s adelante en el texto, consideraremos las aplicaciones y los patrones de almacenamiento de datos utilizados en ellas a la luz de las mejores pr√°cticas para trabajar con contenedores y Kubernetes.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contenedores ap√°tridas</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los contenedores son inherentemente livianos y ef√≠meros. </font><font style="vertical-align: inherit;">Se pueden detener, eliminar o implementar f√°cilmente en otro nodo; todo esto lleva unos segundos. </font><font style="vertical-align: inherit;">En un sistema de orquestaci√≥n de contenedores grandes, tales operaciones ocurren todo el tiempo, y los usuarios ni siquiera notan tales cambios. </font><font style="vertical-align: inherit;">Sin embargo, los movimientos son posibles solo si el contenedor no tiene dependencias en el nodo en el que se encuentra. </font><font style="vertical-align: inherit;">Se dice que estos contenedores funcionan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sin preservaci√≥n del estado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contenedores con estado</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si el contenedor almacena datos en dispositivos conectados localmente (o en un dispositivo de bloque), entonces el almac√©n de datos en el que est√° ubicado deber√° trasladarse a un nuevo nodo junto con el contenedor en s√≠ mismo, en caso de falla. Esto es importante, porque de lo contrario la aplicaci√≥n que se ejecuta en el contenedor no podr√° funcionar correctamente, ya que necesita acceder a los datos almacenados en los medios locales. Se dice que estos contenedores tienen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desde un punto de vista puramente t√©cnico, los contenedores con estado tambi√©n se pueden mover a otros nodos. Por lo general, esto se logra utilizando sistemas de archivos distribuidos o almacenamientos de red en bloque conectados a todos los nodos en los que operan los contenedores. Por lo tanto, los contenedores obtienen acceso a los vol√∫menes para el almacenamiento persistente de datos, y la informaci√≥n se almacena en discos ubicados en toda la red. Llamar√© a este m√©todo un " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enfoque de contenedor para preservar el estado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><font style="vertical-align: inherit;">, y en el resto del art√≠culo lo llamar√© en aras de la uniformidad.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y1/cs/6z/y1cs6zoudpecfzs6ww-aw8ocxyg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En un enfoque t√≠pico de contenedor con estado, todos los pods de aplicaciones se conectan a un sistema de archivos distribuido: se obtiene un tipo de almacenamiento compartido, donde se obtienen todos los datos de la aplicaci√≥n. </font><font style="vertical-align: inherit;">Si bien son posibles algunas variaciones, este es un enfoque de alto nivel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora veamos por qu√© el enfoque de contenedor con estado en el mundo basado en la nube es antipatr√≥n.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dise√±o de aplicaciones basadas en la nube</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tradicionalmente, las aplicaciones usaban bases de datos para el almacenamiento estructurado de informaci√≥n y discos locales o sistemas de archivos distribuidos, donde se volcaban todos los datos no estructurados o incluso semiestructurados. A medida que crec√≠a el volumen de datos no estructurados, los desarrolladores se dieron cuenta de que POSIX era demasiado hablador, asociado con costos significativos y, en √∫ltima instancia, interfiere con la aplicaci√≥n cuando se mueve a una escala realmente grande.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto contribuy√≥ principalmente a la aparici√≥n de un nuevo est√°ndar para el almacenamiento de datos, es decir, almacenamientos basados ‚Äã‚Äãen la nube que funcionan principalmente sobre la base de la API REST y liberan la aplicaci√≥n del mantenimiento oneroso del almac√©n de datos local. En este caso, la aplicaci√≥n ingresa al modo de operaci√≥n sin guardar el estado (ya que el estado est√° en el almacenamiento remoto). Las aplicaciones modernas se est√°n construyendo desde cero ya teniendo en cuenta este factor. Como regla general, cualquier aplicaci√≥n moderna que procese datos de un tipo u otro (registros, metadatos, blobs, etc.) se basa en un paradigma orientado a la nube, donde el estado se transfiere a un sistema de software especialmente asignado para su almacenamiento.</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°El enfoque de contenedor de preservaci√≥n del estado hace que todo este paradigma retroceda exactamente a donde comenz√≥!</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Cuando se utilizan interfaces POSIX para almacenar datos, las aplicaciones funcionan de la misma manera que si mantuvieran el estado, y debido a esto, se apartan de los postulados m√°s importantes del dise√±o basado en la nube, es decir, de la capacidad de variar el tama√±o de los flujos de trabajo de la aplicaci√≥n dependiendo de la entrada cargar, moverse a un nuevo nodo tan pronto como el nodo actual falle, y as√≠ sucesivamente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una mirada m√°s cercana a esta situaci√≥n revela que al elegir un almac√©n de datos, nos enfrentamos una y otra vez con el dilema "POSIX versus REST API", PERO con un agravamiento adicional de los problemas POSIX causados ‚Äã‚Äãpor la naturaleza distribuida de los entornos de Kubernetes. En particular,</font></font><br>
<br>
<ul>
<li><b>POSIX </b>:  POSIX         ,     .     ,     . API   ,  , S3 API,    ,   ,   ¬´¬ª  .     ,       .        .</li>
<li><b> </b>:    ,     ,          . ,  ,            (    ),         ,     . -  POSIX       .   , S3 API       ,      ,  ,     .</li>
<li><b></b>:   POSIX     :          .      - .      ,   API,       ,   ,     ..</li>
<li><b></b>:       ,   .       ,    ,     ,      .  ,     ,      ,   .</li>
</ul><br>
<h4>   </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mientras que la interfaz de almacenamiento de datos de contenedor (CSI) ayud√≥ mucho con la distribuci√≥n del nivel de volumen de Kubernetes, pas√°ndolo parcialmente a proveedores de almacenamiento de datos de terceros, pero tambi√©n contribuy√≥ accidentalmente a la convicci√≥n de que el enfoque de contenedor con estado era el m√©todo recomendado de almacenamiento de datos en Kubernetes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CSI se desarroll√≥ como un est√°ndar para proporcionar sistemas de almacenamiento de archivos y bloques arbitrarios para aplicaciones heredadas cuando se trabaja con Kubernetes. Y, como se mostr√≥ en este art√≠culo, la √∫nica situaci√≥n en la que es apropiado un enfoque de contenedor con estado (y CSI en su forma actual) es cuando la aplicaci√≥n en s√≠ es un sistema heredado en el que es imposible agregar soporte para la API de almacenamiento de datos de objetos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es importante comprender que al usar CSI en su forma actual, es decir, al montar vol√∫menes cuando se trabaja con aplicaciones modernas, encontraremos aproximadamente los mismos problemas que los que se encuentran en los sistemas donde el almacenamiento de datos se organiza en el estilo POSIX.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mejor enfoque</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, es importante comprender que la mayor√≠a de las aplicaciones no est√°n afiladas inherentemente espec√≠ficamente para trabajar con o sin preservaci√≥n del estado. </font><font style="vertical-align: inherit;">Este comportamiento depende de la arquitectura general del sistema y de las opciones espec√≠ficas seleccionadas durante el dise√±o. </font><font style="vertical-align: inherit;">Hablemos un poco sobre las aplicaciones con estado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En principio, todos los datos de la aplicaci√≥n se pueden dividir en varios tipos generales:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dato de registro</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datos de marca de tiempo</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datos de la transacci√≥n</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metadatos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im√°genes de contenedores</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datos de blobs (blobs)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos estos tipos de datos son muy compatibles con las plataformas modernas de almacenamiento de datos, y hay varias plataformas basadas en la nube adaptadas para entregar datos en cada uno de estos formatos espec√≠ficos. Por ejemplo, los datos y metadatos de las transacciones pueden residir en una base de datos moderna basada en la nube, como CockroachDB, YugaByte, etc. Las im√°genes de contenedor o los datos de blob se pueden almacenar en el registro de Docker basado en MinIO. Los datos de la marca de tiempo se pueden almacenar en una base de datos de series de tiempo, como InfluxDB, etc. No entraremos en detalles de cada tipo de datos y aplicaciones relacionadas, pero la idea general es evitar el almacenamiento persistente de datos basado en el montaje del disco local.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/us/gk/li/usgklihtry8ddkgmpkumtziiv3y.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, a menudo es eficaz proporcionar una capa de almacenamiento en cach√© temporal, que sirve como un tipo de almacenamiento de archivos temporal para aplicaciones, pero las aplicaciones no deben depender de este nivel como fuente de verdad.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Almacenamiento de aplicaciones con estado</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si bien en la mayor√≠a de los casos es √∫til mantener las aplicaciones sin estado, aquellas aplicaciones que est√°n dise√±adas para almacenar datos, por ejemplo, bases de datos, almacenes de objetos, almacenes de claves y valores, deben mantener el estado. </font><font style="vertical-align: inherit;">Veamos por qu√© estas aplicaciones se implementan en Kubernetes. </font><font style="vertical-align: inherit;">Tome MinIO como ejemplo, pero se aplican principios similares a cualquier otro gran sistema de almacenamiento basado en la nube.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las aplicaciones centradas en la nube est√°n dise√±adas para maximizar el uso de la flexibilidad inherente a los contenedores. Esto significa que no hacen suposiciones sobre el entorno en el que se implementar√°n. Por ejemplo, MinIO utiliza un mecanismo de codificaci√≥n de borrado interno, que proporciona al sistema una estabilidad suficiente para que permanezca operativo incluso si falla la mitad de las unidades. MinIO tambi√©n gestiona la integridad y seguridad de los datos utilizando su propio cifrado y hashing del lado del servidor.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para tales aplicaciones basadas en la nube, los vol√∫menes locales persistentes (PV) son m√°s convenientes como almacenamiento de respaldo. </font><font style="vertical-align: inherit;">El PV local proporciona la capacidad de almacenar datos sin procesar, mientras que las aplicaciones que se ejecutan sobre estos PV recopilan informaci√≥n de forma independiente para escalar datos y gestionar los crecientes requisitos de datos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este enfoque es mucho m√°s simple y significativamente mejor escalable en comparaci√≥n con la PV basada en CSI, que aporta sus propios niveles de gesti√≥n de datos y redundancia al sistema; </font><font style="vertical-align: inherit;">El hecho es que estos niveles generalmente entran en conflicto con las aplicaciones dise√±adas de acuerdo con el principio de preservaci√≥n del estado.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Movimiento seguro para desanclar datos de la inform√°tica</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este art√≠culo, hablamos sobre c√≥mo las aplicaciones se reorientan para que funcionen sin guardar el estado o, en otras palabras, el almacenamiento de datos se delimita de la computaci√≥n en ellas. En conclusi√≥n, considere algunos ejemplos del mundo real de tal tendencia. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , la reconocida plataforma de an√°lisis de datos, se ha utilizado tradicionalmente con despliegue con estado y despliegue en el sistema de archivos HDFS. Sin embargo, a medida que Spark pasa a un mundo basado en la nube, esta plataforma se usa cada vez m√°s sin la preservaci√≥n del estado usando 's3a'. Spark usa s3a para transferir el estado a otros sistemas, mientras que los contenedores de Spark funcionan completamente sin preservaci√≥n del estado. Otros actores de grandes empresas en el campo del an√°lisis de big data, en particular, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertica</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teradata</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Greenplum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tambi√©n trabaja con la divisi√≥n de almacenamiento de datos y computaci√≥n sobre ellos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambi√©n se pueden ver patrones similares en otras grandes plataformas anal√≠ticas, incluidas Presto, Tensorflow to R, Jupyter. </font><font style="vertical-align: inherit;">La carga de estado a sistemas de almacenamiento en la nube remotos hace que sea mucho m√°s f√°cil administrar y escalar su aplicaci√≥n. </font><font style="vertical-align: inherit;">Adem√°s, ayuda a la portabilidad de la aplicaci√≥n a una variedad de entornos.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es490164/index.html">Entrevista con el ingeniero de software Sony PlayStation Now. Cocina interna, equipos funcionales, divisi√≥n central</a></li>
<li><a href="../es490168/index.html">An√°lisis de la calidad del chatbot en IBM Watson Assistant</a></li>
<li><a href="../es490170/index.html">Project Manager en un vicio. Por qu√© y qu√© hacer al respecto</a></li>
<li><a href="../es490174/index.html">B√∫squeda de DNS en Kubernetes</a></li>
<li><a href="../es490178/index.html">Mientras todos se dirigen al oeste, me mud√© a Armenia</a></li>
<li><a href="../es490184/index.html">Alphabet tiene un segundo grupo secreto de desarrolladores de computadoras cu√°nticas</a></li>
<li><a href="../es490186/index.html">De qu√© hicimos JET BI. Sistema de inteligencia de negocios de arquitectura sin digresiones l√≠ricas</a></li>
<li><a href="../es490190/index.html">Voy a buscar: posicionamiento geogr√°fico de host por direcci√≥n IP en Internet global utilizando el intercambio de cifrado Binance como ejemplo</a></li>
<li><a href="../es490194/index.html">Usando RabbitMQ con MonsterMQ Parte 4</a></li>
<li><a href="../es490196/index.html">[Flipper Zero] rechaza Raspberry Pi, crea nuestra propia placa desde cero. Encontrar el chip WiFi correcto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>