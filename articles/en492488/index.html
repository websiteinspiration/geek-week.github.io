<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∫üèª üí∂ üôåüèæ OpenID Connect: authorization of internal applications from generic to standard üö¥üèΩ üë¥üèΩ üïØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A few months ago, I was implementing an OpenID Connect server to control access to hundreds of our internal applications. From our own developments, c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>OpenID Connect: authorization of internal applications from generic to standard</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/uchi_ru/blog/492488/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A few months ago, I was implementing an OpenID Connect server to control access to hundreds of our internal applications. </font><font style="vertical-align: inherit;">From our own developments, convenient on a smaller scale, we moved on to the generally accepted standard. </font><font style="vertical-align: inherit;">Access through a central service greatly simplifies monotonous operations, reduces the cost of implementing authorizations, allows you to find many ready-made solutions and not break your brain when developing new ones. </font><font style="vertical-align: inherit;">In this article I will talk about this transition and the bumps that we managed to fill.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lf/rf/lc/lfrflcyqjujtcdbfqn71iok4i1o.png" alt="intro"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Once upon a time ... How it all began</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A few years ago, when there were too many internal applications for manual control, we wrote an application for access control inside the company. It was a simple Rails application that connected to a database with information about employees, where access to various functions was configured. Then we raised the first SSO, which was based on verification of tokens from the client and the authorization server, the token was transmitted in encrypted form with several parameters and checked on the authorization server. This was not the most convenient option, since on each internal application it was necessary to describe a considerable layer of logic, and the base of employees was completely synchronized with the authorization server.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After some time, we decided to simplify the task of centralized authorization. SSO transferred to the balancer. Using OpenResty on Lua, they added a template that checked tokens, knew which application the request was in, and could check if there was access there. This approach greatly simplified the task of controlling access of internal applications - in the code of each application, it was no longer necessary to describe additional logic. As a result, we closed the traffic externally, and the application itself did not know anything about authorization.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, one of the problems remained unresolved. </font><font style="vertical-align: inherit;">What about applications that need information about employees? </font><font style="vertical-align: inherit;">You could write an API for the authorization service, but then you would have to add additional logic for each such application. </font><font style="vertical-align: inherit;">In addition, we wanted to get rid of the dependence on one of our self-written applications, further oriented towards translation into OpenSource, on our internal authorization server. </font><font style="vertical-align: inherit;">We will talk about him some other time. </font><font style="vertical-align: inherit;">The solution to both problems was OAuth.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To generally accepted standards</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OAuth is an understandable, generally accepted authorization standard, but since its functionality is not enough, OpenID Connect (OIDC) immediately began to be considered. </font><font style="vertical-align: inherit;">OIDC itself is the third implementation of an open authentication standard that has spilled over into the add-in over the OAuth 2.0 protocol (open authorization protocol). </font><font style="vertical-align: inherit;">This solution closes the problem of the lack of data about the end user, and also makes it possible to change the authorization provider. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, we did not choose a specific provider and decided to add integration with OIDC for our existing authorization server. </font><font style="vertical-align: inherit;">In favor of such a solution, OIDC is very flexible in terms of authorizing the end user. </font><font style="vertical-align: inherit;">Thus, it was possible to implement OIDC support on your current authorization server.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/j3/df/7x/j3df7xjz3ehktpwzwpf8redrmmc.png" alt="image"><br>
 <br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our way to implement our own OIDC server</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) They brought the data to the desired form</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To integrate OIDC, you need to bring the current user data in a way that is understandable to the standard. </font><font style="vertical-align: inherit;">In OIDC, this is called Claims. </font><font style="vertical-align: inherit;">Brands are essentially the final fields in the user database (name, email, phone, etc.). </font><font style="vertical-align: inherit;">There is a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">standard list of brands</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and everything that is not included in this list is considered custom. </font><font style="vertical-align: inherit;">Therefore, the first point that you need to pay attention to if you want to choose an existing OIDC provider is the ability to conveniently customize new brands. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The group of brands is combined into the next subset - Scope. </font><font style="vertical-align: inherit;">During authorization, access is requested not to specific brands, namely to scopes, even if some of the hallmarks from the scope are not needed.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) Implemented the necessary grants</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The next part of OIDC integration is the selection and implementation of authorization types, the so-called grants. The further scenario of the interaction of the selected application with the authorization server will depend on the selected grant. An approximate scheme for choosing the right grant is presented in the figure below.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fm/c1/8b/fmc18b4jfprq3mjz-knzjo_4yso.png" alt="image"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For our first application, we used the most common grant - the Authorization Code. Its difference from others is that it is three-step, i.e. passes additional verification. First, the user makes a request for authorization permission, receives a Token - Authorization Code, then with this token, as if with a ticket for travel, requests an access token. All the main interaction of this authorization scenario is based on redirects between the application and the authorization server. Read more about this grant </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OAuth adheres to the concept that access tokens received after authorization should be temporary and change preferably on average every 10 minutes. The grant of the Authorization Code is a three-step check through redirects; to do this step every 10 minutes is, frankly, not a pleasant experience for the eyes. To solve this problem, there is another grant - Refresh Token, which we also deployed. Everything is simpler here. During the test, from another grant, in addition to the main access token, one more is issued - Refresh Token, which can be used only once and its lifetime, as a rule, is significantly longer. With this Refresh Token, when the TTL (Time to Live) of the main access token ends, a request for a new access token will come to the endpoint of another grant. The used Refresh Token is immediately reset.Such a check is two-step and can be performed in the background, invisibly to the user.</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) Customized user data output formats</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After the selected grants are implemented, authorization works, it is worth mentioning the receipt of data about the end user. </font><font style="vertical-align: inherit;">OIDC has a separate endpoint for this, on which you can request user data with your current access token and when relevant. </font><font style="vertical-align: inherit;">And if the user data does not change so often, and you need to go after the current many times, you can come to a decision like JWT tokens. </font><font style="vertical-align: inherit;">These tokens are also supported by the standard. </font><font style="vertical-align: inherit;">The JWT token itself consists of three parts: header (information about the token), payload (any necessary data) and signature (signature, token is signed by the server and you can check the source of its signature in the future).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In an OIDC implementation, a JWT token is called id_token. </font><font style="vertical-align: inherit;">It can be requested along with a regular access token, and all that remains is to verify the signature. </font><font style="vertical-align: inherit;">The authorization server has a separate endpoint for this with a bunch of public keys in the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JWK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> format </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">And speaking of this, it is worth mentioning that there is another endpoint that, based on the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC5785</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> standard </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">,</font></a><font style="vertical-align: inherit;"> reflects the current configuration of the OIDC server. </font><font style="vertical-align: inherit;">It contains all the addresses of endpoints (including the address of the public keychain used for signing), supported brands and scopes, used encryption algorithms, supported grants, etc.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example on Google:</font></font></b>
                        <div class="spoiler_text"><pre><code class="json hljs">{
 <span class="hljs-attr">"issuer"</span>: <span class="hljs-string">"https://accounts.google.com"</span>,
 <span class="hljs-attr">"authorization_endpoint"</span>: <span class="hljs-string">"https://accounts.google.com/o/oauth2/v2/auth"</span>,
 <span class="hljs-attr">"device_authorization_endpoint"</span>: <span class="hljs-string">"https://oauth2.googleapis.com/device/code"</span>,
 <span class="hljs-attr">"token_endpoint"</span>: <span class="hljs-string">"https://oauth2.googleapis.com/token"</span>,
 <span class="hljs-attr">"userinfo_endpoint"</span>: <span class="hljs-string">"https://openidconnect.googleapis.com/v1/userinfo"</span>,
 <span class="hljs-attr">"revocation_endpoint"</span>: <span class="hljs-string">"https://oauth2.googleapis.com/revoke"</span>,
 <span class="hljs-attr">"jwks_uri"</span>: <span class="hljs-string">"https://www.googleapis.com/oauth2/v3/certs"</span>,
 <span class="hljs-attr">"response_types_supported"</span>: [
  <span class="hljs-string">"code"</span>,
  <span class="hljs-string">"token"</span>,
  <span class="hljs-string">"id_token"</span>,
  <span class="hljs-string">"code token"</span>,
  <span class="hljs-string">"code id_token"</span>,
  <span class="hljs-string">"token id_token"</span>,
  <span class="hljs-string">"code token id_token"</span>,
  <span class="hljs-string">"none"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"subject_types_supported"</span>: [
  <span class="hljs-string">"public"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"id_token_signing_alg_values_supported"</span>: [
  <span class="hljs-string">"RS256"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"scopes_supported"</span>: [
  <span class="hljs-string">"openid"</span>,
  <span class="hljs-string">"email"</span>,
  <span class="hljs-string">"profile"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"token_endpoint_auth_methods_supported"</span>: [
  <span class="hljs-string">"client_secret_post"</span>,
  <span class="hljs-string">"client_secret_basic"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"claims_supported"</span>: [
  <span class="hljs-string">"aud"</span>,
  <span class="hljs-string">"email"</span>,
  <span class="hljs-string">"email_verified"</span>,
  <span class="hljs-string">"exp"</span>,
  <span class="hljs-string">"family_name"</span>,
  <span class="hljs-string">"given_name"</span>,
  <span class="hljs-string">"iat"</span>,
  <span class="hljs-string">"iss"</span>,
  <span class="hljs-string">"locale"</span>,
  <span class="hljs-string">"name"</span>,
  <span class="hljs-string">"picture"</span>,
  <span class="hljs-string">"sub"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"code_challenge_methods_supported"</span>: [
  <span class="hljs-string">"plain"</span>,
  <span class="hljs-string">"S256"</span><font></font>
 ],<font></font>
 <span class="hljs-attr">"grant_types_supported"</span>: [
  <span class="hljs-string">"authorization_code"</span>,
  <span class="hljs-string">"refresh_token"</span>,
  <span class="hljs-string">"urn:ietf:params:oauth:grant-type:device_code"</span>,
  <span class="hljs-string">"urn:ietf:params:oauth:grant-type:jwt-bearer"</span><font></font>
 ]<font></font>
}</code></pre> <br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, using id_token, you can transfer all the necessary hallmarks to the payload of the token and not contact the authorization server each time to request user information. </font><font style="vertical-align: inherit;">The disadvantage of this approach is that changing user data from the server does not come immediately, but with a new access token.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Results of implementation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, after implementing our own OIDC server and setting up connections to it on the application side, we solved the problem of transmitting user information. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since OIDC is an open standard, we have the opportunity to choose an existing provider or server implementation. </font><font style="vertical-align: inherit;">We tried Keycloak, which turned out to be very convenient to configure, after setting up and changing connection configurations on the application side, it is ready to work. </font><font style="vertical-align: inherit;">On the application side, it remains only to change the connection configuration.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speaking of existing solutions</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As part of our organization, as the first OIDC server, we put together our implementation, which was supplemented as needed. After a detailed review of other ready-made solutions, we can say that this is a moot point. Concerns on the part of providers about the lack of necessary functionality served as a solution to the implementation of their server, as well as the presence of an old system in which there were various custom authorizations for some services and quite a lot of data was stored about employees. However, in ready-made implementations, there are convenience for integration. For example, Keycloak has its own user management system and data is stored directly in it, and it will not be difficult to overtake its users there. For this, Keycloak has an API that will allow you to fully implement all the necessary steps for the transfer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another example of a certified, interesting, in my opinion, implementation is Ory Hydra. </font><font style="vertical-align: inherit;">It is interesting in that it consists of different components. </font><font style="vertical-align: inherit;">For integration, you will need to link your user management service with their authorization service and expand as necessary. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keycloak and Ory Hydra are not the only turnkey solutions. </font><font style="vertical-align: inherit;">It's best to select a certified OpenID Foundation implementation. </font><font style="vertical-align: inherit;">Typically, such solutions have an OpenID Certification badge.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/8g/nl/ob/8gnlob5hxgfi2038fymlqsm5tjy.png" alt="Openid certification"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also, don't forget about existing paid providers if you don't want to keep your OIDC server. </font><font style="vertical-align: inherit;">There are many good options to date.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What's next</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the near future, we are going to close the traffic to internal services in another way. </font><font style="vertical-align: inherit;">We plan to transfer our current SSO on the balancer using OpenResty to a proxy based on OAuth. </font><font style="vertical-align: inherit;">There are also many ready-made solutions here, for example: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/bitly/oauth2_proxy </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/ory/oathkeeper </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/keycloak/keycloak-gatekeeper</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additional materials</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jwt.io</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a good service for checking </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">openid.net/developers/certified</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> JWT tokens </font><font style="vertical-align: inherit;">- a list of certified OIDC implementations</font></font><br>
<cut></cut></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en492478/index.html">Without knowledge management it hurts: 5 main consequences of the lack of a system</a></li>
<li><a href="../en492480/index.html">How we struggled with epidemics before and what we do against coronavirus</a></li>
<li><a href="../en492482/index.html">Digital events in Moscow from March 16 to 22</a></li>
<li><a href="../en492484/index.html">Digital events in St. Petersburg from March 16 to March 22</a></li>
<li><a href="../en492486/index.html">Nuxt + Django + GraphQL for example</a></li>
<li><a href="../en492492/index.html">NikiRobot - an evolution in educational robotics</a></li>
<li><a href="../en492496/index.html">Sample Simple Notes SPA at Mithril.js</a></li>
<li><a href="../en492500/index.html">Science Garage in Russian. Experience translating an American show</a></li>
<li><a href="../en492502/index.html">MIP * = RE: epoch-making evidence from the field of computer science that caused the domino effect in physics and mathematics</a></li>
<li><a href="../en492504/index.html">What happens when a JS module is imported twice?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>