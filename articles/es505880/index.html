<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤣 🚋 👨🏻‍🚒 Cómo escribir su índice en Tarantool 👩🏾‍🎤 👉🏽 ⏭️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tarantool es un servidor de aplicaciones y una base de datos. La parte del servidor está escrita en C, y el usuario cuenta con una interfaz Lua para t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Cómo escribir su índice en Tarantool</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/505880/"><img src="https://habrastorage.org/webt/_w/oc/me/_wocmecfrb1lnc7gdoodtf3j3y4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tarantool es un servidor de aplicaciones y una base de datos. </font><font style="vertical-align: inherit;">La parte del servidor está escrita en C, y el usuario cuenta con una interfaz Lua para trabajar con ella. </font><font style="vertical-align: inherit;">Además, Tarantool es un producto de código abierto, lo que significa que el código fuente es de dominio público, y puede desarrollar y distribuir libremente software basado en Tarantool. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero hoy la historia será un poco diferente: sobre el experimento, sobre tratar de escribir su propia estructura de datos para la búsqueda (curva de orden Z) e integrarla en el ecosistema de Tarantool existente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soy desarrollador del equipo de soluciones de Tarantool, no participo directamente en el desarrollo de Tarantool, pero soy un usuario activo. </font><font style="vertical-align: inherit;">Por lo tanto, para mí este experimento es un intento de entender cómo funciona Tarantool a un nivel bajo.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué es Tarantool y dónde almacena los datos?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Qué es tarantool? En el mundo de las bases de datos, se posiciona como una tecnología en memoria. El motor memtx le permite almacenar todos sus datos en RAM, al tiempo que cumple con todos los principios de ACID. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un análogo de las tablas relacionales en Tarantool son el espacio, que están diseñados para almacenar tuplas (tuplas). A diferencia de las tablas relacionales, las tuplas en un espacio generalmente pueden tener una longitud arbitraria. Para almacenarlos, se debe crear una estructura de datos de búsqueda, y la clave de búsqueda es la clave principal, siempre única.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También puede construir estructuras adicionales: índices secundarios que almacenan solo un puntero a una tupla. </font><font style="vertical-align: inherit;">El índice secundario puede no ser único, sin embargo, este es solo el comportamiento externo visible para el usuario. </font><font style="vertical-align: inherit;">Los campos de índice primario se agregan implícitamente a cualquier índice no exclusivo. </font><font style="vertical-align: inherit;">Esto garantiza la estabilidad de las tuplas de clasificación dentro del índice. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tarantool admite diferentes tipos de índices:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En primer lugar, en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B-Tree</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (y si es absolutamente preciso, entonces B + * - Tree). </font><font style="vertical-align: inherit;">Se </font><font style="vertical-align: inherit;">ha </font><font style="vertical-align: inherit;">escrito mucho [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B-Tree</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font><font style="vertical-align: inherit;">sobre la estructura de los B-trees </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Solo noto que los datos se almacenan en forma ordenada, además, puede buscar por el prefijo de la clave indexada.</font></font></li>
<li>   <strong>hash-</strong>. ,      .    .    B-,      ,  .    .</li>
<li><strong>R-Tree</strong>.      .    «» , ,  .       — .     ,       .        .   ,      ,    .</li>
<li><strong>Bitset</strong>. ,     .   ,            ,   .</li>
</ul><br>
<h3> Z-,   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿De dónde surgió la idea de escribir tu índice, y bastante exótica? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una vez me encontré con los artículos de Amazon [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1, 2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ], que hablaban de una estructura como la curva de orden Z o la curva de Morton. Esta es una receta para la ubicación de datos "multidimensionales" dentro de una estructura plana (curva de orden Z), que luego cabe en un árbol B. Tal enfoque debería ayudar a evitar el escaneo continuo de datos. En general, la información sobre cualquier objeto con un cierto conjunto de características puede considerarse datos multidimensionales. Por ejemplo, altura, peso, tamaño del pie, etc. persona. La mayoría de las bases de datos usan R-Tree para este propósito. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un poco sobre cómo se estructura la curva de orden Z.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/363/a10/2c9/363a102c99adb088e19052945e6298fb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una curva de orden Z, también conocida como curva de Morton, se obtiene entrelazando bits de las coordenadas de un punto en el espacio. </font><font style="vertical-align: inherit;">Las direcciones Z así obtenidas tienen la propiedad de localidad. </font><font style="vertical-align: inherit;">Los puntos ubicados cerca del espacio multidimensional seguirán estando cerca cuando se muestren en una línea plana. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La mezcla esquemáticamente similar se ve así:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6eb/04c/f2b/6eb04cf2b6ac3f0b26613a774c8f479d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Cómo funciona? </font><font style="vertical-align: inherit;">Limitamos una determinada región en el espacio, un hipercubo (habrá un rectángulo en el espacio bidimensional), con la ayuda de dos puntos que se encuentran en la diagonal, que se muestran en dos puntos de la línea. </font><font style="vertical-align: inherit;">Y obtenemos un efecto secundario desagradable: algunos de los puntos van más allá del cuadro delimitador:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/991/fd9/889/991fd9889fa6f3b4b30fd7adecfcd436.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es decir, no podemos simplemente iterar a lo largo de esta curva. Pero, armados con un algoritmo especial, podemos dar un salto cuando vamos al extranjero, volviendo al área de búsqueda. Tan pronto como vamos más allá del punto extremo de la curva (llamémosla upper_bound), la búsqueda ha terminado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al trabajar con el B-Tree, tendríamos un conjunto de intervalos, y esta consulta llevaría a una exploración secuencial del B-tree, lo que llevaría mucho tiempo con un gran conjunto de datos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mi interés fue impulsado por otras publicaciones sobre esta curva. Por ejemplo, cómo se integró en TransBase [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ], una base de datos propietaria. Y, desafortunadamente para mí, no encontré ninguna implementación de código abierto de esta estructura.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La curva B-Tree subyacente tiene varias ventajas sobre el R-Tree. </font><font style="vertical-align: inherit;">Por ejemplo, mejor ocupación y compacidad. </font><font style="vertical-align: inherit;">Desventajas: la mayoría de los algoritmos utilizados son de procesador limitado. </font><font style="vertical-align: inherit;">A modo de comparación, decidí usar Tarantool: estaba interesado en las velocidades de lectura / inserción, así como el consumo de memoria. </font><font style="vertical-align: inherit;">Es imposible no mencionar que ya se ha planteado un tema similar en Habré, pero para dimensiones pequeñas (2-3) y en relación con la base de datos de disco PostgreSQL [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZcurvePostgres</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ].</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué se requería para incrustar en Tarantool?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encontré implementaciones simples de esta estructura para las dimensiones 2-3, pero quería comparar el rendimiento con el índice R-Tree existente, por lo que no quería limitarme a pequeñas dimensiones. Elegí la misma dimensión que R-Tree - 20. Para esto, necesitaba un mapa de bits con soporte para algunas operaciones primitivas: extracción / modificación de un bit, desplazamiento, operaciones lógicas OR / AND. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para el prototipo, tomé la implementación de código abierto encontrada, pero rápidamente llegué a la conclusión de que no necesitaba un mapa de bits de propósito general: la longitud de la clave siempre es un múltiplo de 64, por lo que algunas operaciones se simplifican enormemente. Escribí mi propia implementación basada en lo que tenía. Además, en lugar de usar las funciones del sistema para asignar memoria, comencé a usar asignadores especiales implementados en Tarantool [</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quizás el corazón del índice es un conjunto de algoritmos para trabajar con la curva Z. </font><font style="vertical-align: inherit;">A saber, calcular la dirección Z (usando tablas de búsqueda especiales), verificar si la dirección Z pertenece al área de búsqueda y detectar la primera aparición en el área de búsqueda, comenzando desde el punto especificado. </font><font style="vertical-align: inherit;">Si busca bien en la web, puede encontrar publicaciones científicas que describan estos algoritmos, por lo que todo lo que tuve que hacer fue implementarlos, depurarlos y, si es posible, optimizarlos. </font><font style="vertical-align: inherit;">Se suponía que debía almacenar las direcciones Z dentro del árbol B ya implementado utilizado para el índice TREE.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cómo se organiza el manejo de datos?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el caso más general, la tupla nos llega. Esta es una matriz de datos en formato de paquete de mensajes. Y en el caso ideal, solo tendríamos que aislar los campos indexados, mezclar sus bits e insertar la dirección con el puntero a la tupla dentro del árbol B.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, todo sería tan simple si trabajáramos solo con el tipo sin signo, cuando las representaciones de bits ordenadas de los números corresponderían a los números ordenados en una representación natural. Los enteros con signo tienen sus propias reglas de presentación, los números de punto flotante tienen los suyos. Y esto tenía que conducir a un denominador común. Debido al hecho de que almacenamos la dirección Z por separado de los datos en sí, podemos realizar cualquier transformación en nuestras claves, lo principal es mantener el orden de clasificación. Esto se puede hacer usando simples manipulaciones bit a bit. Por ejemplo, para enteros con signo, simplemente puede invertir el byte alto. Para otros tipos, hay transformaciones similares, aunque un poco más complejas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos los tipos numéricos caben en 8 bytes, por lo que la clave resultante tendrá un tamaño de N * 8 bytes, donde N es la dimensión de nuestro espacio. ¿Qué hacer con las cuerdas? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una situación bastante común cuando se trabaja con cadenas es la búsqueda de prefijos. Y es bastante posible apoyar. Los primeros 8 bytes de la cadena bien pueden usarse como una clave. Si la cadena es más corta, se puede rellenar con ceros. El soporte de cadenas impone una limitación fundamental en nuestro índice: perdemos singularidad. Incluso si las líneas difieren en el noveno byte, desde el punto de vista del sistema seguirán siendo las mismas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Miremos el código. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La API de índice consta de un conjunto específico de métodos. No consideraremos cada uno individualmente, solo veremos los más básicos, a saber, las operaciones de búsqueda e inserción.</font></font><br>
<br>
<code>get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- busca un artículo con la clave completa. Solo funciona para índices únicos. Nuestro índice no puede ser único, por lo tanto, la función se reemplaza por una versión genérica especial que devuelve el error "Función de índice no compatible". </font></font><br>
<br>
<code>replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Insertar un artículo. Consideremos con más detalle.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>
<span class="hljs-title">memtx_zcurve_index_replace</span><span class="hljs-params">(struct index *base, struct tuple *old_tuple,
        struct tuple *new_tuple, <span class="hljs-keyword">enum</span> dup_replace_mode mode,
        struct tuple **result)</span>
</span>{<font></font>
    (<span class="hljs-keyword">void</span>)mode;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memtx_zcurve_index</span> *<span class="hljs-title">index</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">memtx_zcurve_index</span> *)<span class="hljs-title">base</span>;</span>
    <span class="hljs-keyword">if</span> (new_tuple) {
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memtx_zcurve_data</span> <span class="hljs-title">new_data</span>;</span><font></font>
        new_data.tuple = new_tuple;<font></font>
        new_data.z_address = extract_zaddress(new_tuple,<font></font>
                &amp;index-&gt;bit_array_pool, index);<font></font>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memtx_zcurve_data</span> <span class="hljs-title">dup_data</span>;</span>
        dup_data.tuple = <span class="hljs-literal">NULL</span>;<font></font>
        dup_data.z_address = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
        <span class="hljs-keyword">int</span> tree_res = memtx_zcurve_insert(&amp;index-&gt;tree, new_data,<font></font>
                &amp;dup_data);<font></font>
        <span class="hljs-keyword">if</span> (tree_res) {<font></font>
            diag_set(OutOfMemory, MEMTX_EXTENT_SIZE,<font></font>
                     <span class="hljs-string">"memtx_zcurve_index"</span>, <span class="hljs-string">"replace"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (dup_data.tuple != <span class="hljs-literal">NULL</span>) {<font></font>
            *result = dup_data.tuple;<font></font>
            z_value_free(&amp;index-&gt;bit_array_pool, dup_data.z_address);<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (old_tuple) {
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memtx_zcurve_data</span> <span class="hljs-title">old_data</span>, <span class="hljs-title">deleted_value</span>;</span><font></font>
        old_data.tuple = old_tuple;<font></font>
        old_data.z_address = extract_zaddress(old_tuple,<font></font>
                &amp;index-&gt;bit_array_pool, index);<font></font>
        memtx_zcurve_delete_value(&amp;index-&gt;tree, old_data, &amp;deleted_value);<font></font>
        z_value_free(&amp;index-&gt;bit_array_pool, old_data.z_address);<font></font>
        z_value_free(&amp;index-&gt;bit_array_pool, deleted_value.z_address);<font></font>
    }<font></font>
    *result = old_tuple;<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿A qué debes prestar atención? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En términos del índice, no hubo transacciones </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>insert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Toda su lógica se ejecuta en este método, que recibe las tuplas antiguas y nuevas, así como </font></font><code>mode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">información sobre si el índice es único o no. </font><font style="vertical-align: inherit;">Nuestro índice no puede ser único, por lo tanto, no se requieren verificaciones adicionales y puede insertar inmediatamente una tupla. </font></font><br>
<br>
<code>memtx_zcurve_insert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>memtx_zcurve_delete_value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- los métodos del árbol B, que ya se han implementado en Tarantool y se utilizan en el índice TREE normal. </font><font style="vertical-align: inherit;">No nos detendremos en ellos por separado. </font><font style="vertical-align: inherit;">A diferencia del TREE ordinario, almacenamos no solo una tupla, sino también una dirección z: los bits mixtos de las partes indexadas. </font><font style="vertical-align: inherit;">La función es responsable de esto </font></font><code>extract_zadress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<code>create_iterator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- de Lua nos referimos a este método en el caso de </font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'a y</font></font><code>pairs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'y.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> struct iterator *
<span class="hljs-title">memtx_zcurve_index_create_iterator</span><span class="hljs-params">(struct index *base, <span class="hljs-keyword">enum</span> iterator_type type,
                                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key, <span class="hljs-keyword">uint32_t</span> part_count)</span>
</span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memtx_zcurve_index</span> *<span class="hljs-title">index</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">memtx_zcurve_index</span> *)<span class="hljs-title">base</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">memtx_engine</span> *<span class="hljs-title">memtx</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">memtx_engine</span> *)<span class="hljs-title">base</span>-&gt;<span class="hljs-title">engine</span>;</span><font></font>
<font></font>
    assert(part_count == <span class="hljs-number">0</span> || key != <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">if</span> (type != ITER_EQ &amp;&amp; type != ITER_ALL &amp;&amp; type != ITER_GE) {<font></font>
        diag_set(UnsupportedIndexFeature, base-&gt;def,<font></font>
                 <span class="hljs-string">"requested iterator type"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">uint8_t</span> index_dim = base-&gt;def-&gt;key_def-&gt;part_count;
    <span class="hljs-keyword">if</span> (part_count == <span class="hljs-number">0</span>) {
        <span class="hljs-comment">/*
         * If no key is specified, downgrade equality
         * iterators to a full range.
         */</span><font></font>
        type = ITER_GE;<font></font>
        key = <span class="hljs-literal">NULL</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index_dim * <span class="hljs-number">2</span> == part_count<font></font>
               &amp;&amp; type != ITER_ALL) {<font></font>
        <span class="hljs-comment">/*
         * If part_count is twice greater than key_def.part_count
         * set iterator to range query
         */</span><font></font>
        type = ITER_GE;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tree_iterator</span> *<span class="hljs-title">it</span> = <span class="hljs-title">mempool_alloc</span>(&amp;<span class="hljs-title">memtx</span>-&gt;<span class="hljs-title">zcurve_iterator_pool</span>);</span>
    <span class="hljs-keyword">if</span> (it == <span class="hljs-literal">NULL</span>) {<font></font>
        diag_set(OutOfMemory, <span class="hljs-keyword">sizeof</span>(struct tree_iterator),
                 <span class="hljs-string">"memtx_zcurve_index"</span>, <span class="hljs-string">"iterator"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
    }<font></font>
<font></font>
    iterator_create(&amp;it-&gt;base, base);<font></font>
    it-&gt;pool = &amp;memtx-&gt;zcurve_iterator_pool;<font></font>
    it-&gt;base.next = tree_iterator_start;<font></font>
    it-&gt;base.<span class="hljs-built_in">free</span> = tree_iterator_free;<font></font>
    it-&gt;type = type;<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (part_count == <span class="hljs-number">0</span> || type == ITER_ALL) {<font></font>
        it-&gt;lower_bound = zeros(&amp;index-&gt;bit_array_pool, index_dim);<font></font>
        it-&gt;upper_bound = ones(&amp;index-&gt;bit_array_pool, index_dim);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == ITER_EQ) {<font></font>
        it-&gt;lower_bound = mp_decode_key(&amp;index-&gt;bit_array_pool,<font></font>
                key, index_dim, index);<font></font>
        it-&gt;upper_bound = <span class="hljs-literal">NULL</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (base-&gt;def-&gt;key_def-&gt;part_count == part_count) {<font></font>
        it-&gt;lower_bound = mp_decode_key(&amp;index-&gt;bit_array_pool,<font></font>
                key, index_dim, index);<font></font>
        it-&gt;upper_bound = ones(&amp;index-&gt;bit_array_pool, index_dim);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (base-&gt;def-&gt;key_def-&gt;part_count * <span class="hljs-number">2</span> == part_count) {<font></font>
        it-&gt;lower_bound  = z_value_create(&amp;index-&gt;bit_array_pool, index_dim);<font></font>
        it-&gt;upper_bound  = z_value_create(&amp;index-&gt;bit_array_pool, index_dim);<font></font>
        mp_decode_part(key, part_count, index, it-&gt;lower_bound, it-&gt;upper_bound);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        unreachable();<font></font>
    }<font></font>
    it-&gt;tree_iterator = memtx_zcurve_invalid_iterator();<font></font>
    it-&gt;current.tuple = <span class="hljs-literal">NULL</span>;<font></font>
    it-&gt;current.z_address = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">return</span> (struct iterator *)it;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dependiendo de la clave transmitida, calculamos los límites inferior y superior de la solicitud. </font><font style="vertical-align: inherit;">Sin embargo, hasta ahora este iterador no apunta a nada. </font><font style="vertical-align: inherit;">Hay varios tipos de iteradores en total. </font><font style="vertical-align: inherit;">En nuestro caso, esto es TODO: obtener todos los elementos; </font><font style="vertical-align: inherit;">EQ: elementos de recepción cuya dirección z coincide con la transmitida; </font><font style="vertical-align: inherit;">y GE es la selección de elementos en el hipercubo. </font></font><br>
<br>
<code>destroy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- eliminación del índice. </font><font style="vertical-align: inherit;">En el caso del índice secundario, simplemente libera la memoria asignada para la estructura de búsqueda. </font><font style="vertical-align: inherit;">Y si el índice es primario, elimina físicamente las tuplas almacenadas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo el código está disponible en: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/olegrok/tarantool/tree/z-order-curve-index</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Veamos qué sucedió y resumamos.</font></font><br>
<br>
<pre><code class="lua hljs">space = box.schema.space.<span class="hljs-built_in">create</span>(<span class="hljs-string">'myspace'</span>, { engine = <span class="hljs-string">'memtx'</span> })<font></font>
pk = space:create_index(<span class="hljs-string">'primary'</span>, { <span class="hljs-built_in">type</span> = <span class="hljs-string">'tree'</span>, parts = {{<span class="hljs-number">1</span>, <span class="hljs-string">'unsigned'</span>}}, unique = <span class="hljs-literal">true</span>})<font></font>
sk = space:create_index(<span class="hljs-string">'secondary'</span>, { <span class="hljs-built_in">type</span> = <span class="hljs-string">'zcurve'</span>, parts = {{<span class="hljs-number">2</span>, <span class="hljs-string">'unsigned'</span>}, {<span class="hljs-number">3</span>, <span class="hljs-string">'unsigned'</span>}}})
<span class="hljs-keyword">for</span> i=<span class="hljs-number">0</span>,<span class="hljs-number">5</span> <span class="hljs-keyword">do</span> <span class="hljs-keyword">for</span> j=<span class="hljs-number">0</span>,<span class="hljs-number">5</span> <span class="hljs-keyword">do</span> space:<span class="hljs-built_in">insert</span>{i * <span class="hljs-number">6</span> + j, i, j} <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>
<span class="hljs-comment">-- returns all tuples</span>
pk:<span class="hljs-built_in">select</span>{}
<span class="hljs-comment">-- (2 &lt;= x &lt;= 3) and (3 &lt;= y &lt;= 5)</span>
sk:<span class="hljs-built_in">select</span>{<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>}
<span class="hljs-comment">---</span>
- — [<span class="hljs-number">15</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">21</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">16</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">17</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]<font></font>
  - [<span class="hljs-number">23</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<font></font>
…<font></font>
<span class="hljs-comment">-- (x == 2) and (y == 3)</span>
sk:<span class="hljs-built_in">select</span>{<span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
<span class="hljs-comment">---</span>
- — [<span class="hljs-number">15</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
<span class="hljs-comment">-- (2 &lt;= x &lt;= 3)</span>
sk:<span class="hljs-built_in">select</span>({<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, box.NULL, box.NULL})
<span class="hljs-comment">---</span>
- — [<span class="hljs-number">12</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>]<font></font>
  - [<span class="hljs-number">18</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>]<font></font>
  - [<span class="hljs-number">13</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<font></font>
  - [<span class="hljs-number">19</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>]<font></font>
  - [<span class="hljs-number">14</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]<font></font>
  - [<span class="hljs-number">20</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]<font></font>
  - [<span class="hljs-number">15</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">21</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">16</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">17</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]<font></font>
  - [<span class="hljs-number">23</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<font></font>
...<font></font>
<span class="hljs-comment">-- (x &gt;= 2) and (y &gt;= 3)</span>
sk:<span class="hljs-built_in">select</span>({<span class="hljs-number">2</span>, box.NULL, <span class="hljs-number">3</span>, box.NULL})
<span class="hljs-comment">---</span>
- — [<span class="hljs-number">15</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">21</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">27</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">33</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>]<font></font>
  - [<span class="hljs-number">16</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">22</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">17</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]<font></font>
  - [<span class="hljs-number">23</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<font></font>
  - [<span class="hljs-number">28</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">34</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>]<font></font>
  - [<span class="hljs-number">29</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<font></font>
  - [<span class="hljs-number">35</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>]<font></font>
...</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué pasa con el rendimiento?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resultó que no todo es tan color de rosa como lo describí. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comenzando en algún punto, la curva de orden Z comienza a ceder significativamente en términos de velocidad de acceso a datos. perf top mostró que la mayor parte del tiempo se dedica a verificar que el punto pertenece al área de búsqueda y calcular el siguiente punto al que debe saltar. Ambas operaciones tienen una complejidad lineal que depende de la longitud de la clave: a medida que aumenta la dimensión, la longitud también aumenta.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70e/338/fd1/70e338fd15af8701c3a5696ebfb3ea2a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De lo agradable: el consumo de memoria es 2-3 veces menor y la inserción es ligeramente más rápida que el R-Tree. </font><font style="vertical-align: inherit;">Lo cual no es particularmente relevante, porque las mediciones se realizaron con WAL desactivado. </font><font style="vertical-align: inherit;">En primer lugar, en un entorno de producción, en caso de falla, un WAL deshabilitado puede conducir a la pérdida de datos. </font><font style="vertical-align: inherit;">En segundo lugar, a pesar de que escribir en el WAL utiliza el enfoque de lote, sigue escribiendo en el disco, que es miles de veces más lento que trabajar con RAM.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ee/e73/e29/9eee73e29d809963c069a9f7414f524a.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c0/8b9/159/2c08b91598dbefe2855ede4d05a593ca.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También es interesante compararlo con el árbol B. </font><font style="vertical-align: inherit;">Aquí, como se esperaba, la curva será más rápida que una exploración completa y comprobará que cada punto pertenece a un área determinada. </font><font style="vertical-align: inherit;">Aunque la verificación es más ligera que en el caso de la curva de orden Z, donde todo se reduce a una comparación bit a bit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los números en el gráfico difieren en orden del R-Tree: la prueba se ha modificado ligeramente.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/140/ae5/44d/140ae544d6ba527bffe6bc4d814f609d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para la prueba, generé un conjunto de puntos y comparé la duración de la consulta usando la curva Z y el escaneo convencional.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para resumir</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el mundo en memoria, esta estructura ha demostrado no ser la mejor manera, sin embargo, todavía tiene ventajas:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ocupa menos espacio.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mecanografiado, a diferencia de R-Tree (relevante solo para Tarantool).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vale la pena verlo más de cerca si solo hay un B-Tree y necesita hacer consultas multidimensionales (no relevante para Tarantool).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fue un experimento interesante. </font><font style="vertical-align: inherit;">Es poco probable que la solución que propuse se convierta en parte de Tarantool. </font><font style="vertical-align: inherit;">Sin embargo, no tengas miedo de experimentar. </font><font style="vertical-align: inherit;">Y si tiene alguna sugerencia y solución, no tenga miedo de compartirla.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuentes</font></font></h2><br>
<a name="B-Tree"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[B-Tree]: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Índices en PostgreSQL - 4 / Blog de Postgres Professional / Habr </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B-tree / Habr </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B-tree data structure / OTUS Blog. </font><font style="vertical-align: inherit;">Educación en línea / revista geek</font></font></a><br>
<br>
<a name="ZcurvePostgres"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ZcurvePostgres]: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acerca de Z-order y R-tree / geek magazine </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z-order vs R-tree, continuación / geek magazine</font></font></a><br>
<br>
<a name="1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indización de orden Z para consultas multifacéticas en Amazon DynamoDB: Parte 1 | </font><font style="vertical-align: inherit;">Blog de la base de datos de AWS</font></font></a><br>
<br>
<a name="1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indización de orden Z para consultas multifacéticas en Amazon DynamoDB: Parte 2 | </font><font style="vertical-align: inherit;">Blog de la base de datos de AWS</font></font></a><br>
<br>
<a name="3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Integrando el árbol UB en un núcleo del sistema de base de datos</font></font></a><br>
<br>
<a name="4"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/tarantool/small</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es505850/index.html">Polimorfismo basado en conceptos C ++ en código de producto: PassManager en LLVM</a></li>
<li><a href="../es505856/index.html">De la fuerza bruta al intento de privacidad: lo que enfrentan los proveedores de SaaS</a></li>
<li><a href="../es505860/index.html">Spring Boot, Hibernate y Kotlin para principiantes paso a paso</a></li>
<li><a href="../es505870/index.html">Cómo promover juegos y aplicaciones móviles en Japón, Corea y China</a></li>
<li><a href="../es505872/index.html">Historia de vehículos no tripulados.</a></li>
<li><a href="../es505884/index.html">Spear phishing: experiencia creando archivos ejecutables condicionalmente maliciosos para correos electrónicos de phishing</a></li>
<li><a href="../es505888/index.html">Analizar YouTube, incluidos los datos cargados, sin la API de YouTube</a></li>
<li><a href="../es505896/index.html">Semana de la seguridad 24: Zoom y privacidad valiente del navegador</a></li>
<li><a href="../es505898/index.html">Claude Shannon: Jack de todos los oficios, bromista y padre de la teoría de la información.</a></li>
<li><a href="../es505900/index.html">Adicciones personales: 40 mm de tamaño completo, sin cable, durante 72 horas por 8000 rublos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>