<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’ªğŸ¼ ğŸ”´ ğŸ†˜ Grafik 3D pada STM32F103 ğŸ“ ğŸ›ŒğŸ¾ ğŸ‘¨ğŸ¼â€âš•ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebuah cerita pendek tentang cara mendorong grafik tiga dimensi yang tidak dapat diedit dan menampilkan waktu nyata menggunakan pengontrol yang tidak ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Grafik 3D pada STM32F103</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496046/"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/cf8/e1c/7e5cf8e1c0fbc2ee47c87c71d72e865f.jpg" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebuah cerita pendek tentang cara mendorong grafik tiga dimensi yang tidak dapat diedit dan menampilkan waktu nyata menggunakan pengontrol yang tidak memiliki kecepatan maupun memori untuk ini.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kembali pada tahun 2017 (berdasarkan tanggal modifikasi file), saya memutuskan untuk beralih dari pengontrol AVR ke STM32 yang lebih kuat. Secara alami, pengontrol pertama adalah F103 yang dipublikasikan secara luas. Tidak kurang wajar bahwa penggunaan papan debug yang tidak ada rak ditolak karena pembuatannya dari awal sesuai dengan persyaratannya. Anehnya, hampir tidak ada tiang tembok (kecuali bahwa UART1 harus dibawa ke konektor normal, dan tidak disambungkan dengan kabel).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dibandingkan dengan AVR, karakteristik batu ini cukup baik: jam 72 MHz (dalam praktiknya, Anda dapat melakukan overclock hingga 100 MHz, atau bahkan lebih, tetapi hanya dengan risiko dan risiko Anda sendiri!), 20 kB RAM dan 64 kB flash. Plus, satu ton periferal, ketika menggunakan yang masalah utamanya adalah tidak perlu takut akan kelimpahan ini dan menyadari bahwa Anda tidak perlu menyekop kesepuluh register untuk memulai, cukup untuk mengatur tiga bit pada yang benar. Setidaknya sampai Anda menginginkan sesuatu yang aneh.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika euforia pertama dari kepemilikan kekuasaan seperti itu berlalu, muncul keinginan untuk menyelidiki batas-batasnya. Sebagai contoh yang efektif, saya memilih perhitungan grafik tiga dimensi dengan semua matriks ini, pencahayaan, model poligon dan Z-buffer dengan tampilan 320x240 pada pengontrol ili9341. Dua masalah paling jelas yang harus dipecahkan adalah kecepatan dan volume. Ukuran layar 320x240 pada 16 bit per warna menghasilkan 150 kB per frame. Tetapi total RAM yang kita miliki hanya 20 kB ... Dan 150 kB ini harus ditransfer ke layar setidaknya 10 kali per detik, yaitu, nilai tukar harus minimal 1,5 MB / s atau 12 MB / s, yang sudah terlihat seperti beban signifikan pada inti. Untungnya, dalam pengontrol ini terdapat modul RAP (akses langsung ke memori, alias Direct Memory Access, DMA), yang memungkinkan Anda untuk tidak memuat kernel dengan operasi transfusi dari kosong ke kosong.Artinya, Anda dapat menyiapkan buffer, beri tahu modul "di sini Anda memiliki buffer data, bekerja!", Dan saat ini siapkan data untuk transfer berikutnya. Dan dengan mempertimbangkan kemampuan tampilan untuk menerima data dalam aliran, algoritma berikut muncul: buffer depan disorot, dari mana DMA mentransfer data ke display, buffer belakang ke mana rendering berlangsung, dan buffer-Z yang digunakan untuk memotong kedalaman. Buffer adalah satu baris (atau kolom, apa pun) dari tampilan. Dan alih-alih 150 kB, kita hanya perlu 1920 byte (320 piksel per baris * 3 buffer * 2 byte per titik), yang sangat pas di memori. Retasan kedua didasarkan pada fakta bahwa perhitungan matriks transformasi dan koordinat titik tidak dapat dilakukan untuk setiap baris, jika tidak gambar akan terdistorsi dengan cara yang paling aneh, dan kecepatannya tidak menguntungkan. Sebagai gantinya, perhitungan "eksternal",yaitu, perkalian matriks transformasi dan penerapannya pada simpul dihitung ulang pada setiap frame, dan kemudian dikonversi ke representasi perantara, yang dioptimalkan untuk rendering dalam gambar 320x1.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk alasan hooligan, perpustakaan akan menyerupai OpenGL dari luar. Seperti pada OpenGL asli, rendering dimulai dengan pembentukan matriks transformasi - kliring glLoadIdentity () membuat unit matriks saat ini, kemudian seperangkat transformasi glRotateXY (...), glTranslate (...), yang masing-masing dikalikan dengan matriks saat ini. Karena perhitungan ini akan dilakukan hanya sekali per frame, tidak ada persyaratan khusus untuk kecepatan, Anda dapat melakukannya dengan float sederhana, tanpa penyimpangan dengan angka titik tetap. Matriks itu sendiri adalah array float [4] [4], dipetakan ke array float satu dimensi [16] - pada kenyataannya, metode ini biasanya digunakan untuk array dinamis, tetapi Anda juga bisa mendapatkan sedikit manfaat dari array statis. Peretasan standar lainnya: alih-alih terus menghitung sinus dan cosinus, yang banyak terdapat dalam matriks rotasi,hitung terlebih dahulu dan tulis di tablet. Untuk melakukan ini, bagi lingkaran penuh menjadi 256 bagian, hitung nilai sinus untuk masing-masing dan buang ke dalam sin_table [] array. Nah, siapa pun dari sekolah bisa mendapatkan cosinus dari sinus. Perlu dicatat bahwa fungsi rotasi mengambil sudut bukan pada radian, tetapi dalam fraksi revolusi penuh, setelah reduksi ke kisaran [0 ... 255]. Namun, fungsi "jujur" telah diterapkan yang melakukan konversi dari sudut ke lobus di bawah kap.melakukan konversi dari sudut ke lobus di bawah kap.melakukan konversi dari sudut ke lobus di bawah kap.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika matriks siap, Anda dapat mulai menggambar primitif. Secara umum, dalam grafik tiga dimensi ada tiga jenis primitif - satu titik, satu garis dan satu segitiga. Tetapi jika kita tertarik pada model poligon, perhatian harus diberikan hanya pada segitiga. "Rendering" -nya terjadi pada fungsi glDrawTriangle () atau glDrawTriangleV (). Kata "rendering" terlampir dalam tanda kutip karena tidak ada rendering yang terjadi pada tahap ini. Kami hanya mengalikan semua titik primitif dengan matriks transformasi, dan kemudian kami mengekstrak dari mereka rumus analitik dari tepi y = ky * x + dengan, yang memungkinkan kami untuk menemukan persimpangan ketiga tepi segitiga dengan garis keluaran saat ini. Kami membuang salah satunya, karena tidak terletak pada interval antara simpul, tetapi pada kelanjutannya.Artinya, untuk menggambar bingkai, Anda hanya perlu melewati semua garis dan untuk setiap cat area antara titik persimpangan. Tetapi jika Anda menerapkan algoritma ini "langsung", masing-masing primitif akan tumpang tindih dengan yang digambar sebelumnya. Kita perlu mempertimbangkan koordinat-Z (kedalaman) sehingga segitiga bersilangan dengan indah. Alih-alih hanya mencetak titik demi titik, kami akan mempertimbangkan koordinat Z-nya dan, dibandingkan dengan koordinat-Z yang tersimpan di buffer kedalaman, baik output (memperbarui buffer-Z) atau mengabaikannya. Dan untuk menghitung koordinat Z dari setiap titik garis minat kepada kami, kami menggunakan rumus garis lurus yang sama z = kz * y + bz dihitung oleh dua titik persimpangan yang sama dengan tepi. Akibatnya, objek segitiga "semi-jadi" struct glTriangle terdiri dari tiga koordinat X dari simpul (tidak ada gunanya menyimpan koordinat Y dan Z, mereka akan dihitung) dan k,b koefisien langsung, yah, warnai ke heap. Di sini, berbeda dengan perhitungan matriks transformasi, kecepatan sangat penting, jadi kami sudah menggunakan angka titik tetap. Selain itu, jika untuk istilah b, akurasi yang sama cukup untuk koordinat (2 byte), maka akurasi faktor k, semakin besar semakin baik, jadi kami mengambil 4 byte. Tapi bukan float, karena bekerja dengan bilangan bulat masih lebih cepat, bahkan dengan ukuran yang sama.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, dengan memanggil sekelompok glDrawTriangle () kami menyiapkan array segitiga setengah jadi. Dalam implementasi saya, segitiga disimpulkan satu per satu oleh panggilan fungsi eksplisit. Sebenarnya, akan logis untuk memiliki array segitiga dengan alamat simpul, tetapi di sini saya memutuskan untuk tidak menyulitkan. Bagaimanapun, fungsi rendering ditulis oleh robot, dan tidak masalah bagi mereka untuk mengisi array konstan atau menulis tiga ratus panggilan yang identik. Saatnya untuk menerjemahkan produk setengah jadi dari segitiga menjadi gambar yang indah di layar. Untuk melakukan ini, fungsi glSwapBuffers () dipanggil. Seperti dijelaskan di atas, ia melewati garis-garis tampilan, mencari setiap titik persimpangan dengan semua segitiga dan menggambar segmen sesuai dengan penyaringan berdasarkan kedalaman. Setelah membuat setiap baris, Anda harus mengirim baris ini ke layar. Untuk melakukan ini, DMA diluncurkan, yang menunjukkan alamat string dan ukurannya.Sementara itu, DMA berfungsi, Anda dapat beralih ke buffer lain dan merender baris berikutnya. Hal utama adalah jangan lupa untuk menunggu akhir transfer jika Anda tiba-tiba selesai render sebelumnya. Untuk memvisualisasikan rasio kecepatan, saya menambahkan dimasukkannya LED merah setelah akhir rendering dan off setelah selesai menunggu DMA. Ternyata sesuatu seperti PWM, yang mengatur kecerahan tergantung pada latensi. Secara teoritis, alih-alih menunggu "bodoh", interupsi DMA dapat digunakan, tetapi kemudian saya tidak dapat menggunakannya, dan algoritme akan menjadi jauh lebih rumit. Untuk program demo, ini berlebihan.Untuk memvisualisasikan rasio kecepatan, saya menambahkan dimasukkannya LED merah setelah akhir rendering dan off setelah selesai menunggu DMA. Ternyata sesuatu seperti PWM, yang mengatur kecerahan tergantung pada latensi. Secara teoritis, alih-alih menunggu "bodoh", interupsi DMA dapat digunakan, tetapi kemudian saya tidak dapat menggunakannya, dan algoritme akan menjadi jauh lebih rumit. Untuk program demo, ini berlebihan.Untuk memvisualisasikan rasio kecepatan, saya menambahkan dimasukkannya LED merah setelah akhir rendering dan off setelah selesai menunggu DMA. Ternyata sesuatu seperti PWM, yang mengatur kecerahan tergantung pada latensi. Secara teoritis, alih-alih menunggu "bodoh", interupsi DMA dapat digunakan, tetapi kemudian saya tidak dapat menggunakannya, dan algoritme akan menjadi jauh lebih rumit. Untuk program demo, ini berlebihan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasil dari prosedur di atas adalah gambar berputar dari tiga bidang berpotongan warna yang berbeda, dan dengan kecepatan yang cukup baik: kecerahan LED merah cukup tinggi, yang menunjukkan margin besar dalam kinerja kernel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nah, jika intinya idle, Anda perlu memuatnya. Dan kami akan memuatnya dengan model yang lebih baik. Namun, jangan lupa bahwa memorinya masih sangat terbatas, sehingga pengontrol tidak akan menarik terlalu banyak poligon secara fisik. Perhitungan paling sederhana menunjukkan bahwa setelah mengurangi memori pada buffer garis dan sejenisnya, ada tempat untuk 378 segitiga. Seperti yang telah ditunjukkan oleh praktik, model-model dari game Gothic yang lama namun menarik sangat cocok untuk ukuran ini. Sebenarnya, model ular dan lalat darah ditarik keluar dari sana (dan sudah pada saat menulis artikel ini dan glocoor, memamerkan KDPV), setelah itu controller kehabisan memori flash. Tetapi model permainan tidak dimaksudkan untuk digunakan oleh mikrokontroler.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Katakanlah mereka mengandung animasi, tekstur dan sejenisnya, yang tidak berguna bagi kita, dan tidak muat dalam memori. Untungnya, blender memungkinkan tidak hanya untuk menyimpannya ke * .obj, yang lebih cocok untuk penguraian, tetapi juga untuk mengurangi jumlah poligon jika perlu. Selanjutnya, dengan bantuan program yang ditulis sendiri sederhana obj2arr * .obj, file-file tersebut diurutkan menjadi koordinat, dari mana file * .h kemudian dibentuk untuk dimasukkan langsung dalam firmware.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi untuk sekarang, modelnya terlihat seperti bercak keriting polos. Pada model uji, ini tidak mengganggu kami, karena semua wajah dicat dengan warna mereka sendiri, tetapi jangan meresepkan warna yang sama untuk setiap poligon model. Tidak, Anda bisa, tentu saja, mengecat lalat dengan warna acak, tetapi itu akan terlihat sangat tiba-tiba, saya memeriksanya. Terutama ketika warna-warna juga berubah pada setiap bingkai ... Sebaliknya, menerapkan setetes sihir vektor dan menambahkan pencahayaan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhitungan pencahayaan dalam versi primitifnya terdiri dalam menghitung produk skalar dari normal dan arah ke sumber cahaya, diikuti dengan mengalikannya dengan warna "asli" pada wajah.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami sekarang memiliki tiga model - dua dari permainan dan satu tes, dari mana kami memulai. Untuk beralih, kita akan menggunakan salah satu dari dua tombol yang disolder di papan tulis. Pada saat yang sama, Anda dapat menambahkan kontrol atas prosesor. Kami sudah memiliki satu kontrol - LED merah yang terkait dengan latensi DMA. Dan yang kedua, hijau, LED, kita akan berkedip dengan setiap pembaruan frame - jadi kita bisa memperkirakan frame rate. Untuk mata telanjang, sekitar 15 fps.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/afyTgpuA6sc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, saya puas dengan hasilnya: senang menerapkan sesuatu yang pada dasarnya tidak mungkin diselesaikan secara langsung. </font><font style="vertical-align: inherit;">Tentu saja, masih banyak untuk mengoptimalkan dan meningkatkan, tetapi ada sedikit gunanya dalam hal ini. </font><font style="vertical-align: inherit;">Secara obyektif, pengontrol untuk grafik tiga dimensi lemah, dan bahkan bukan soal kecepatan, melainkan RAM. </font><font style="vertical-align: inherit;">Namun, seperti sampel demoscene lainnya, proyek ini berharga bukan oleh hasilnya, tetapi oleh prosesnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika seseorang tiba-tiba tertarik, kode sumber tersedia di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id496036/index.html">Sumber terbuka: CI / CD dan infrastruktur pengujian Avito untuk Android</a></li>
<li><a href="../id496038/index.html">Bilirubin - molekul yang bertanggung jawab atas penyakit kuning</a></li>
<li><a href="../id496040/index.html">10 Zen Lifehacks</a></li>
<li><a href="../id496042/index.html">Habr, saya tidak akan memberi tahu Anda tentang kesalahan di situs Anda</a></li>
<li><a href="../id496044/index.html">Peluncuran pesawat ruang angkasa dan ... cuaca di wilayah tersebut</a></li>
<li><a href="../id496050/index.html">Harimau dan Singa mendapatkan coronavirus di New York</a></li>
<li><a href="../id496052/index.html">Bagaimana perusahaan jasa dapat menghindari denda dari pelanggan? Beberapa keunggulan otomatisasi proses yang tidak terlihat</a></li>
<li><a href="../id496056/index.html">Digital: bagaimana angka dan istilah menipu kita</a></li>
<li><a href="../id496080/index.html">Membuat interaksi AI sederhana dengan objek lingkungan</a></li>
<li><a href="../id496082/index.html">Insinyur Data dan Ilmuwan Data: apa bedanya?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>