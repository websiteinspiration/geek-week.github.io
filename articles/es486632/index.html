<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏡 👉🏾 🎥 Modelos de programación reactiva mental para supervisores 👸🏿 👩🏽‍🚒 🕵🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artículo está dirigido a una amplia gama de lectores que desean saber qué es la programación reactiva. El propósito de este artículo es formar su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Modelos de programación reactiva mental para supervisores</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486632/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> <img src="https://habrastorage.org/webt/ez/hr/x0/ezhrx0ymj-ak_tdpfqhioagb3su.jpeg"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este artículo está dirigido a una amplia gama de lectores que desean saber qué es la programación reactiva. </font><font style="vertical-align: inherit;">El propósito de este artículo es formar sus modelos mentales básicos de programación reactiva (MM RP) sin entrar en detalles técnicos.</font></font><br>
<a name="habracut"></a><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descargo de responsabilidad</font></font></b><div class="spoiler_text"> ( ) —    ,   .     ,                     .<br>
   ,      :            ,          . ,      ,     .<br>
          .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero primero, expliquemos qué tienen que ver los modelos mentales y los superiores mencionados en el encabezado del artículo ...</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre modelos mentales</font></font></b><div class="spoiler_text">  ,  ,         ,       .     ,       .<br>
            ,         ,    (. [1], [2])<br>
    ?  ,    ,                   .      (),   ,      ,   .      ,    ,    «», «»     « »    .<br>
    ,   ,       (),     ,      -  ().</div></div> <br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y aquí están los jefes ...</font></font></b><div class="spoiler_text">        .            «»  «»     ,            :   . (  ,  «»    ,      ).<br>
  ,   «»  ,     ,      ,  ,    , . ,          .   «»        «».      ,  ,    ,         .<br>
    ,    ,           ,   ..,       () — ,   ,            .<br>
 ,              .</div></div> <br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Por qué la programación reactiva necesita su proyecto?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muchas personas que no están familiarizadas con RP son inicialmente escépticas de él, sospechando que esta es solo otra moda vacía, cubierta con un par de hermosas palabras. </font><font style="vertical-align: inherit;">Especialmente cuando aprenden que puedes evaluar el RP solo probándolo. </font><font style="vertical-align: inherit;">Y probarlo es caro, debido al alto umbral de entrada. </font><font style="vertical-align: inherit;">Vivimos y vivimos con OOP, ¿qué le falta? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Permítanme presentarles mi punto de vista sobre este tema.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En los albores de la programación, cuando la mayoría de los programas se escribían directamente en lenguaje ensamblador, el concepto de trabajo principal (un elemento del Modelo mental) de los programadores era una instrucción o un comando de lenguaje. Algunos datos (primitivos) se envían a la entrada de un comando o instrucción. La instrucción procesa y emite algunos datos de salida. La aparición de los primeros lenguajes de programación de procedimientos como Fortran no cambió la esencia del asunto. Solo los datos y las operaciones realizadas (como una secuencia de comandos elementales) se han vuelto más complicadas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con el tiempo, se hizo evidente que este concepto no es muy consistente con las realidades del mundo. Puede haber muchos datos, pueden ser difíciles de estructurar. Tanto los datos como la funcionalidad que los rodea sería bueno dividirlos en partes, desarrollarlos y mantenerlos por separado, y usarlos juntos.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOP resolvió estos problemas de muchas maneras. La unidad del modelo mental de un programador típico de OOP es un objeto con datos ocultos (encapsulados) y una interfaz de acceso a estos datos como un conjunto de funciones. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOP ha jugado un papel muy importante en la automatización e informatización de muchos procesos de fabricación y otros. Y junto con esto, sus debilidades fueron expuestas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desafortunadamente, en OOP no existe el concepto de un proceso como tal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Intentaron mejorar la situación de diferentes maneras, concentrándose en varios aspectos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De este modo, nacieron la Programación dirigida por eventos [3], la programación de flujo de datos [4], el procesamiento de flujo [5] y varios otros paradigmas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Me aventuraría a despertar una corriente de críticas a los adherentes y expertos en estos paradigmas, tratando de transmitir en palabras simples su esencia general.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De una forma u otra, estos paradigmas operan con flujos de información. Al mismo tiempo, la programación dirigida por eventos, como su nombre lo indica, se centra en el proceso de aparición de elementos de flujo de información, programación de flujo de datos: control de flujo (división, fusión, transformación de flujos) y procesamiento de flujo en el uso óptimo de los recursos al procesar flujos.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La programación reactiva es casi lo mismo, pero con un enfoque en las operaciones elementales específicas de creación, administración y uso de hilos. Aquellos. RP describe cómo reacciona su sistema (el inglés reacciona) a los elementos del flujo de información. En este sentido, sería más correcto en ruso usar el término "Programación de reactivos" (de la palabra "reaccionar") o "Programación de reacción" (de la palabra "reacción a algo") si no fuera por cortar el oído, y el segundo no causó asociaciones incorrectas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Me aventuraría a expresar otro pensamiento sedicioso. Lo que hoy llamamos en inglés Programación reactiva (Programación reactiva). llamado así por razones históricas e inclinado a favor de este término la opinión mayoritaria.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este paradigma podría haber sido llamado de manera diferente. </font><font style="vertical-align: inherit;">Por lo tanto, no se concentre en su nombre actual, sino intente comprender su esencia. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y aunque hablaré sobre RP en un nivel bastante abstracto, citaré las API de la biblioteca RxJS como ejemplos concretos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El acrónimo RxJS significa Reactive Extension for JavaScript, una extensión de JavaScript para las funciones de programación reactiva. </font><font style="vertical-align: inherit;">Existen extensiones similares para muchos otros lenguajes de programación, como se puede ver en la imagen a continuación, tomada de [6].</font></font><br>
<img src="https://habrastorage.org/webt/ii/gb/ji/iigbjinggcawbioey0iz7ztarzs.png" alt="Extensiones de programación reactiva"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Por qué los modelos mentales de RP necesitan tu proyecto?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los grandes proyectos no se hacen solos. A menudo puede leer o escuchar que los participantes del proyecto deben hablar el mismo idioma. Mi experiencia muestra que esto es apenas necesario y posible. Pero lo que se necesita es que los conceptos más básicos del proyecto sean establecidos y entendidos por los participantes del proyecto de la manera más equitativa posible. En términos de modelos mentales (MM), podemos decir que los MM de nivel superior deberían ser lo más similares posible. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero, ¿cómo pueden ser similares si los analistas piensan en términos de flujo de trabajo y casos de uso, arquitectos en patrones, desarrolladores en funciones y estructuras de datos y probadores en escenarios de prueba?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No insto a todos estos especialistas a comenzar a pensar al mismo tiempo con las categorías de Programación Reactiva, pero puedo prometerles que el conocimiento de estas categorías simplificará y aumentará la efectividad de su comunicación profesional con sus colegas. </font><font style="vertical-align: inherit;">Esto debería suceder porque, por un lado, los MM RP tienen el poder necesario para describir flujos de trabajo complejos y, por otro lado, los MM RP se pueden convertir directamente a código en muchos lenguajes de programación.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sorpresas, peligros o que en RP no es la forma en que todos estamos acostumbrados </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero antes de entrar en la descripción de en qué consisten los modelos mentales de programación reactiva, según nuestra propia experiencia, me gustaría advertir al lector sobre lo que no está en ellos. </font><font style="vertical-align: inherit;">Además, no solo no, sino que la expectativa de un comportamiento OOP simple y comprensible en el mundo lleva a tristes consecuencias. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estoy haciendo esto no para intimidar, sino para intrigar al lector.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferencia 1: en lugar de un modelo de cursor, un gráfico computacional</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Me aventuraré a sugerir que muchos lectores, al pensar en la próxima tarea que se realizará, tienen un modelo mental en su cabeza, que yo llamo el modelo de cursor. </font><font style="vertical-align: inherit;">Se supone que se inventará un algoritmo paso a paso en forma de una lista lineal de instrucciones para resolver el problema. </font><font style="vertical-align: inherit;">La ejecución del algoritmo se reduce a la ejecución paso a paso de las instrucciones una tras otra. </font><font style="vertical-align: inherit;">Puede imaginar algo así como un puntero a la instrucción que se está ejecutando actualmente. </font><font style="vertical-align: inherit;">Después de ejecutar la instrucción, el puntero (cursor) se mueve a la siguiente instrucción en la lista y comienza a ejecutarse. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dentro de este modelo, una secuencia de comandos escritos en un lenguaje de programación orientado a objetos condicional</font></font><br>
<pre><code class="xml hljs">1. 1 = 2<font></font>
2. 2 = 3 <font></font>
3. 3 = 1 + 2<font></font>
4.  1, 2, 3<font></font>
5. 1 = 4<font></font>
6.  1, 2, 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dará el resultado</font></font><br>
<pre><code class="xml hljs">2 3 5<font></font>
4 3 5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestro modelo mental de cursor predice y explica perfectamente tal resultado. </font><font style="vertical-align: inherit;">Después de procesar la tercera línea, se establece el valor X3 y el nuevo valor para X1 especificado en la línea 5 no puede cambiarlo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el mundo de RP, dependiendo de la interpretación de la operación "+", el resultado probablemente será este</font></font><br>
<pre><code class="xml hljs">2 3 5<font></font>
4 3 7</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este mundo, la mayoría de las operaciones conectan los parámetros de entrada entre sí, creando así gráficos computacionales a través de los cuales los cálculos son "empujados" cuando se cambian uno o más parámetros.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferencia 2: operaciones asincrónicas</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el marco del modelo mental de cálculos del cursor, la siguiente operación no puede comenzar antes que la anterior. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere el siguiente ejemplo. </font><font style="vertical-align: inherit;">Suponga que la función f1 calcula el salario base por el valor del identificador de usuario userId, y la función f2 calcula el bono basado en userId y el valor del salario. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces el cálculo del salario completo puede verse así</font></font><br>
<pre><code class="xml hljs">1. X = f1(userId)<font></font>
2. Y = f2(userId, X)<font></font>
 X, Y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que un miembro del personal tiene un salario base de 10,000. </font><font style="vertical-align: inherit;">y una bonificación de 1000 unidades. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestro modelo mental de cursor te dice qué imprimir.</font></font><br>
<pre><code class="xml hljs">10000 1000 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por desgracia, en el mundo de la RP asincrónica, el resultado puede, dependiendo de la duración de las operaciones, ser</font></font><br>
<pre><code class="xml hljs">0 0 <font></font>
10000 0 <font></font>
0 1000 <font></font>
10000 1000 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Todavía no considero excepciones). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La cuestión es que en el mundo asíncrono reactivo, la siguiente operación no espera el final de la anterior, si es la anterior) asíncrona. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para ilustrar esto, veamos algunos detalles importantes utilizando el ejemplo realista que se muestra en la figura a continuación. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La imagen muestra el tiempo de ejecución de cuatro instrucciones L1, L2, L3 y L4 que son independientes entre sí (sus números son importantes para nosotros, no la ortografía) en los modos sincrónico (parte superior de la imagen) y asíncrono (parte inferior de la imagen).</font></font><br>
<img src="https://habrastorage.org/webt/vb/s5/rb/vbs5rbmbwmrmmhqtw7gtx9tivzc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como vemos, en el primer caso, cada instrucción posterior "espera" hasta el final de la anterior. </font><font style="vertical-align: inherit;">En el caso asíncrono, todas las instrucciones comienzan a ejecutarse simultáneamente. </font><font style="vertical-align: inherit;">Debido a la ejecución paralela y al uso de recursos, la mayoría de las instrucciones se ejecutan en modo asíncrono por más tiempo que en modo sincrónico. </font><font style="vertical-align: inherit;">Sin embargo, juntos legarán su trabajo antes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El orden de finalización de las instrucciones en ambos modos también es muy diferente. </font><font style="vertical-align: inherit;">En sincronía:</font></font><pre><code class="javascript hljs">L1, L2, L3, l4</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pero en asíncrono: </font></font><pre><code class="javascript hljs">L3, L2, L1, L4</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferencia 3: las cadenas incompletas (sin consumidor) no funcionan en absoluto</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En muchos lenguajes de programación tradicionales, es común asociar llamadas a funciones o propiedades de objetos con puntos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, la siguiente cadena de llamada de función de JavaScript convierte la palabra "bueno" en "perro":</font></font><br>
<pre><code class="javascript hljs">„good“.split(„“).reverse().join(„“).replace(„oo“, „o“);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las secuencias (cadenas) pueden ser largas. </font><font style="vertical-align: inherit;">Por razones de reutilización o conveniencia, se pueden cortar en pedazos y realizar parcialmente. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dividir una cadena en RP en dos partes y llamar solo una de ellas generalmente conduce a una falta de resultados, ya que solo se realiza la cadena completa (con el consumidor al final).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Por qué todo esto?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probablemente, muchos lectores ya se hacen la pregunta: "¿No se han vuelto locos colectivamente, estos programadores reactivos? ¿Por qué se necesita, tal programación? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No pretendo predecir lo que los creadores y expertos de la República de Polonia responderían a esta pregunta, pero mi respuesta es esta: dicha programación es necesaria, porque muchos objetos del mundo real se comportan así. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gráficos de computación</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : en esto se basa Excel, desde el cual no solo los contadores, sino también los gerentes de proyecto están encantados. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operaciones asincrónicas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cuando haces café o té en tu cocina, ¿te paras en la cocina todo este tiempo y miras tu cafetera o tetera? No. El dispositivo hierve agua y hace su trabajo, mientras que usted está haciendo otra cosa por ahora. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cadena completa de operaciones.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intente desconectar la lámpara de su escritorio de la toma de corriente y presione el interruptor. </font><font style="vertical-align: inherit;">La lámpara no se enciende de esto. </font><font style="vertical-align: inherit;">Este objeto funciona solo si hay una cadena completa, desde la fuente hasta el consumidor de electricidad. </font><font style="vertical-align: inherit;">Y hay muchos, si no la mayoría, de tales objetos en el mundo real. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quiero tranquilizarlo, su conocimiento de la programación tradicional y el cursor MM no deben tirarse a la basura debido a la aparición de RP. </font><font style="vertical-align: inherit;">La programación reactiva los dejó solos y los expandió con nuevas operaciones en nuevos tipos de objetos. </font><font style="vertical-align: inherit;">Cómo, hablaremos de esto más tarde.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El espacio de programación de modelos mentales y el lugar de MM RP en él</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al hablar sobre el lugar de la RP en el panorama general de la programación, los autores a menudo mencionan dos dimensiones: la complejidad de los objetos procesados ​​y el sincronismo / asincronía de las operaciones. </font><font style="vertical-align: inherit;">Un ejemplo de dicha clasificación se puede encontrar en el libro "RxJS en acción" [7], en el capítulo "Cuándo y dónde usar RxJS". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En esta clasificación, la dimensión de los objetos se divide en objetos individuales y multi-objetos: matrices, listas, etc. </font><font style="vertical-align: inherit;">Las operaciones se dividen en síncronas y asíncronas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, esta clasificación divide el mundo de la programación en cuatro áreas. </font><font style="vertical-align: inherit;">RP es una de estas áreas responsables del procesamiento de objetos múltiples con operaciones asincrónicas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta clasificación me parece muy interesante, pero me gustaría verla desde el punto de vista de los modelos mentales. </font><font style="vertical-align: inherit;">La siguiente tabla los presenta.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valores únicos y objetos</font></font></th>
<th>, ,    </th>
</tr>
<tr>
<td> </td>
<td>  </td>
<td>,  (Stream)</td>
</tr>
<tr>
<td> </td>
<td>,  (Promise)</td>
<td> (Workflow)</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponemos que los modelos mentales de instrucciones y el cursor no requieren más explicaciones. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El ciclo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es una extensión de las instrucciones MM y el cursor debido a las instrucciones adicionales del ciclo o regreso a algún punto. Esto permite un conjunto de instrucciones de procesamiento para que un solo objeto se "ajuste" en un bucle y, por lo tanto, procese muchos de estos objetos. En este caso, el cursor se mueve dentro del ciclo como en el modelo anterior, y al llegar al punto de transición, salta al principio o el procesamiento del ciclo se detiene si se procesan todos los objetos. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chorro.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La diferencia entre este modelo mental y el anterior es que el cursor que </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
apunta al objeto procesado permanece en su lugar, y los objetos mismos lo "recorren".</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Miremos esto con dos ejemplos. Si pinta una cerca de madera, usted, por analogía con el modelo de cursor, va de tabla en tabla. Pero el trabajador en el transportador permanece en su lugar y, por analogía con el modelo de chorro, las piezas a procesar se acercan a él. A menudo se hace referencia a estos objetos con el término English Stream, por ejemplo, en el lenguaje Java. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semáforo.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este MM es más fácil de asociar con un semáforo en una intersección. Los objetos asincrónicos sondean periódicamente el estado de una variable pública y realizan ciertas acciones después de cambiar su estado. (como los conductores frente a un semáforo) </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esperando.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una metáfora adecuada para este modelo de expectativa mental es la carta en papel o Emall que esperaba la última vez que obtuvo su trabajo. Puede haber una respuesta positiva o negativa. Su comportamiento después de recibir la carta depende mucho de su contenido. El término en inglés Promise se usa a menudo para describir este tipo de objetos. Eso, desde el punto de vista del usuario, es una expectativa, para el contratista que brinda los servicios, es más bien una promesa. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como vemos en la descripción, el movimiento a lo largo de cada dimensión (de arriba a abajo o de derecha a izquierda en la tabla) significa un cambio cualitativo en el Modelo Mental.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como se puede ver en la tabla, los aviones y las expectativas son vecinos a la izquierda y en la parte superior de la celda del sudeste que nos interesa. </font><font style="vertical-align: inherit;">¿Qué hay de nuevo en los modelos mentales de flujos que habitan en la célula que nos interesa en comparación con ellos?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cuál es la extensión?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La expansión de Streams en comparación con Expectations es que la información esperada puede llegar no una vez, sino en muchas partes. En este caso, el proceso puede finalizar sin finalizar. Aquellos. Después de una serie de porciones exitosas, recibiremos una notificación de error. Además, se agrega otra versión de la información: una notificación del final del proceso. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto significa, por ejemplo, que es posible recibir varias (pero no todas) partes de la información esperada y (sin un mensaje de error) un mensaje sobre el final del procesamiento. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recuerde nuevamente, con Waiting, solo tenemos dos opciones alternativas para la información resultante. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El modelo de chorro mental es muy adecuado para comprender, discutir e implementar el proceso de transformación de una secuencia de objetos del mismo tipo. MM Stream lo expande con los siguientes aspectos:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede haber muchos aviones y podemos fusionarlos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los chorros pueden ser heterogéneos.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos dividir los jets en nuevos según diferentes criterios.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos "cerrar" y / o transformarlos en otros nuevos dentro del marco de una secuencia. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, determinamos el lugar de MM RP (Streams) en el espacio o paisaje de los objetos de Programación. </font><font style="vertical-align: inherit;">Ahora bajemos la vista de pájaro y echemos un vistazo más de cerca a Streams y sus Modelos Mentales.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corrientes y fases de su ciclo de vida.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como primera aproximación, los flujos de RP pueden imaginarse como el agua fluye en las tuberías de agua o la electricidad. </font><font style="vertical-align: inherit;">Debe recordarse que, como cualquier otra analogía, esta analogía tiene sus límites y no siempre es aplicable. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hablando sobre el flujo, se pueden distinguir los siguientes aspectos importantes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada hilo surge de alguna manera</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De alguna manera se está moviendo hacia el consumidor.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algo sucede en el camino con él (se transforma)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se puede dividir en varias transmisiones o fusionar con otras transmisiones.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El consumidor de alguna manera usa el flujo, dejando de existir.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los aspectos enumerados son fases simultáneas del ciclo de vida de elementos individuales del flujo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consideremos con más detalle el ejemplo de las funciones RxJS.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creación de hilos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las secuencias se pueden crear a partir de elementos pasivos como una matriz o una lista de objetos en su programa, bytes, líneas de archivo, etc. Este tipo de fuentes de flujo se llama frío (aunque técnicamente hay una definición más precisa de las fuentes de flujo frío). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las llamadas aguas termales "viven sus propias vidas" y si no se conecta a tiempo, la información se perderá. Esta categoría incluye información sobre las acciones del usuario en una computadora, tableta, teléfono inteligente, por ejemplo, información sobre pulsaciones de teclas, movimientos del mouse o tocar la pantalla. También en esta categoría se encuentran los datos solicitados por varios protocolos como HTTP, datos de varios sensores.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cabe señalar que hay los llamados manantiales "cálidos". </font><font style="vertical-align: inherit;">Además, algunas fuentes "calientes" se pueden "enfriar" y las "frías" se pueden "calentar". </font><font style="vertical-align: inherit;">Pero debería leer sobre esto en literatura especial, por ejemplo, en el libro [7]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es importante para nosotros saber que todas las operaciones de creación de flujos crean objetos del mismo tipo, que pueden ser procesados ​​por las mismas operaciones, independientemente del contenido. </font><font style="vertical-align: inherit;">En este artículo, llamamos a estos objetos flujos. </font><font style="vertical-align: inherit;">El nombre en inglés correspondiente es Observable.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Movimiento del consumidor y transformación del flujo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las operaciones de transformación de flujo pueden llevarse a cabo tanto para el consumidor como para él. </font><font style="vertical-align: inherit;">En ambos casos, las operaciones de procesamiento de los elementos de flujo son estrictamente secuenciales, es decir </font><font style="vertical-align: inherit;">la siguiente operación se inicia estrictamente solo después de que la anterior se haya completado y le haya pasado el resultado. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A diferencia de Stream, que en algunos lenguajes de programación son construcciones de lenguaje con su propia sintaxis y semántica, las extensiones reactivas como RxJS en JavaScript se ven obligadas a usar la sintaxis y la semántica básica de un lenguaje extensible. </font><font style="vertical-align: inherit;">Por lo tanto, RxJs implementa la función pipe (), dentro de la cual puede realizar llamadas a funciones: manejadores tanto de la secuencia en sí como de sus elementos individuales. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es importante tener en cuenta que solo las funciones especiales y canalizables pueden ser controladores de flujo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Flujo trifásico"</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si continuamos la analogía con la electricidad, entonces los flujos que estamos considerando pueden llamarse trifásicos. Junto con el "cable normal" que transmite la información básica, también hay un "cable de error" y un "cable de terminación de flujo". Las operaciones de transformación permiten no solo cambiar el objeto, sino también redirigirlo a otro "cable". Esta técnica se utiliza, por ejemplo, al procesar supuestos errores al trabajar con servidores que utilizan el protocolo HTTP. Por ejemplo, si un servidor no responde, puede intentar solicitar otro sin informar al usuario sobre la falla al solicitar el primer servidor.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es otro elemento muy importante de su modelo de flujo mental. </font><font style="vertical-align: inherit;">Si en los paradigmas de programación tradicionales el error se devuelve desde la función de procesamiento como un código de error o debe ser interceptado como una interrupción (excepción), entonces en los flujos el error "fluye" independientemente del canal principal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Allí puede ser procesado. </font><font style="vertical-align: inherit;">Por ejemplo, si un usuario ha ingresado una contraseña incorrecta, se le puede dar una oportunidad adicional de intentar ingresarla una o más veces.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">División y fusión de flujos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La división de flujos se lleva a cabo en dos etapas. En la primera etapa, se inician los hilos vacíos. Luego, en la segunda etapa (etapa de procesamiento de flujo), en una de las funciones de procesamiento, los elementos serán analizados y redirigidos al flujo deseado. Técnicamente, hay muchas opciones sobre cómo hacer esto. Por ejemplo, eliminarlo del hilo actual o clonarlo antes de comenzarlo en un nuevo hilo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede fusionar múltiples transmisiones en una de una sorprendente cantidad de formas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las formas más simples que vienen a la mente son fusionarlas en el orden de recepción, o primero todo desde la primera secuencia y luego todo desde la segunda.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método que se muestra a continuación en la imagen permite que una de las dos corrientes forme una que contenga pares ordenados de objetos del primer y segundo flujo. </font><font style="vertical-align: inherit;">En este caso, se forma un nuevo par si aparece un nuevo elemento en uno de los flujos. </font><font style="vertical-align: inherit;">A contiene un par de estrictamente los últimos elementos de cada secuencia. </font><font style="vertical-align: inherit;">Esto lleva al hecho de que el mismo elemento puede incluirse en varios pares. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La notación gráfica utilizada en este ejemplo se llama diagramas de mármol y es muy efectiva para explicar la semántica de los flujos de división y fusión. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si este tema le interesa, le aconsejo que estudie las operaciones y sus diagramas de mármol en el recurso [8].</font></font><br>
<img src="https://habrastorage.org/webt/cw/q7/a1/cwq7a1t6omorptqk33hgm93yetw.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usar corrientes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para utilizar los elementos de la secuencia, el usuario o el cliente primero deben suscribirse a ella. Como regla general, al final del procesamiento, debe darse de baja, ya que los recolectores de basura no siempre pueden desactivar automáticamente una suscripción cuando intentan utilizar un suscriptor. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muchos clientes pueden suscribirse a un hilo. En RxJs, la función de suscripción se llama subscribe (). En él, en la mayoría de los casos, es aconsejable realizar llamadas de procesamiento de los elementos "normales" del flujo, un controlador de errores y (relativamente raramente) un controlador de terminación del flujo.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada uno de los suscriptores de la secuencia recibe su copia del elemento o un clon del elemento original. </font><font style="vertical-align: inherit;">Para no causar problemas, la secuencia se implementa de tal manera que los elementos recibidos para el procesamiento se vuelven inmutables. </font><font style="vertical-align: inherit;">En algunas situaciones, esta limitación aún se puede eludir, pero es mejor no hacerlo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peligroso encanto de las corrientes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las corrientes son objetos muy complicados, algo similares a las integrales en matemáticas. Una cosa es saber que existen e incluso imaginar más o menos lo que es, y otra muy distinta poder usarlos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La comprensión de la lógica interna de su funcionamiento, necesaria para aplicarlos bien en la práctica, requiere un esfuerzo intelectual considerable. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las secuencias están intrínsecamente relacionadas con la programación funcional. Para el uso competente de los flujos, es útil comprender cómo es posible construir y aplicar funciones de segundo orden, funciones para las cuales otras funciones sirven como argumentos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces la belleza y la elegancia de los flujos se te revelarán por completo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las corrientes son contagiosas. Después de comprender su belleza, quiero usarlos en todas las tareas, lo que por supuesto no es necesario.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En qué tareas es aconsejable usar flujos, y donde se deben usar los métodos tradicionales, todos deciden por sí mismos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resumir</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este artículo intenté contarte sobre los Modelos Mentales de Programación Reactiva (MM RP) e incluso ponerlos parcialmente en tu Conciencia. </font><font style="vertical-align: inherit;">Repitamos los puntos principales nuevamente.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MM RP son especiales, no similares a los modelos mentales de la programación tradicional. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al embarcarse en la Programación Reactiva, uno debe recordar que algunos bien establecidos en otras áreas de MM como un cursor, cadenas de llamadas o bucles no funcionan, o no funcionan así.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El modelo mental principal de RP es un "flujo de tres canales" con un canal para elementos "normales", errores e información sobre el final del flujo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las corrientes pueden ser finitas e infinitas.</font></font></li>
<li>    «», «»  «» .   «»  «». </li>
<li>      .        (,       ).             .</li>
<li>     ,    .</li>
<li>       ,   .</li>
<li>       .        . </li>
<li>      ,  «».</li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si está interesado en este tema, puede "jugar" con transmisiones utilizando los simuladores disponibles en el sitio [8]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si desea comprender mejor los conceptos de RP, le recomiendo que trabaje en el libro [7] y, por supuesto, que se familiarice con El Manifiesto Reactivo [11]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alcanzará el siguiente nivel en la formación de su propio MM RP trabajando a través de los libros [9] y [10] sobre el diseño y modelado de sistemas reactivos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Literatura y referencias</font></font></h3><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La programación es la materialización de ideas. </font><font style="vertical-align: inherit;">(Artículo en Habr. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr.com/ru/post/425321</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sirotin V. RPSE: Reificación como paradigma de la ingeniería de software. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arxiv.org/abs/1810.01904</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programación dirigida por eventos. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.m.wikipedia.org/wiki/Event-driven_programming</font></font></a></li>
<li>Dataflow-programming. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">en.m.wikipedia.org/wiki/Dataflow_programming</a></li>
<li>Stream-processing. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">en.m.wikipedia.org/wiki/Stream_processing</a></li>
<li>Rx-Extensions: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">reactivex.io/languages.html</a></li>
<li>RxJS in Action. – 4. August 2017. Paul P. Daniels (Autor), Luis Atencio. Manning Publications. ISBN-13: 978-1617293412</li>
<li>RxJS online Documentstion. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">xgrommx.github.io/rx-book/index.html</a></li>
<li>Reactive Design Patterns. 2017. Roland Kuhn Dr., Brian Hanafee, Jamie Allen. Manning Publications. ISBN-13: 978-1617291807</li>
<li>Functional and Reactive Domain Modeling. 2016. Debasish Ghosh.Manning Publications. ISBN-13: 978-1617292248</li>
<li>The Reactive Manifesto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">www.reactivemanifesto.org</a></li>
</ol><br>
<br>
<em> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">geralt</a></em></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es486614/index.html">Por qué se necesita eSIM. Cómo funciona y por qué hablan tanto al respecto</a></li>
<li><a href="../es486622/index.html">Modelo de computación paralela</a></li>
<li><a href="../es486626/index.html">Svelte: conociendo acciones</a></li>
<li><a href="../es486628/index.html">Distancia fija entre ticks en un eje en gnuplot</a></li>
<li><a href="../es486630/index.html">"No parpadee en el ojo": cómo se organiza la tecnología de iluminación de pantalla de los lectores electrónicos</a></li>
<li><a href="../es486634/index.html">Actualizaciones de MSVC Backend en Visual Studio 2019 versión 16.3 y 16.4</a></li>
<li><a href="../es486638/index.html">Blazor WebAssembly 3.2.0 Preview 1 ya está disponible</a></li>
<li><a href="../es486640/index.html">El resumen de materiales interesantes para el desarrollador móvil # 331 (27 de enero - 2 de febrero)</a></li>
<li><a href="../es486644/index.html">Antena de bricolaje en 5 minutos</a></li>
<li><a href="../es486646/index.html">Aléjate de jQuery a Svelte, sin dolor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>