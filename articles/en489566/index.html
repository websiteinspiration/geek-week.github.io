<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüíª üíÜüèæ üì® Build C ++ with bazel üßîüèº üõÉ üëßüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction and Motivation
 Recently, posts have appeared on Habr that cmake and c ++ are friends, examples are given of how to collect header-only l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Build C ++ with bazel</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489566/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introduction and Motivation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recently, posts have appeared on Habr that cmake and c ++ are friends, examples are given of how to collect header-only libraries and not only, but there is no overview of at least some new build systems - bazel, buck, gn and others. </font><font style="vertical-align: inherit;">If you, like me, write in C ++ in 2k20, then I suggest you get acquainted with bazel as a build system for a c ++ project. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will leave the question of what cmake and other existing systems are bad for and concentrate on what bazel itself can do. </font><font style="vertical-align: inherit;">To decide what is best specifically for you, I leave it specifically for you.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start with definition and motivation. </font><font style="vertical-align: inherit;">Bazel is a multilingual Google build system that can build c ++ projects. </font><font style="vertical-align: inherit;">Why should we even look at another build system? </font><font style="vertical-align: inherit;">Firstly, because some large projects are already going to her, for example Tensorflow, Kubernetes and Gtest, and accordingly, to integrate with them, you already need to be able to use bazel. </font><font style="vertical-align: inherit;">Secondly, besides google bazel still uses spaceX, nvidia and other companies judging by their performances on bazelcon. </font><font style="vertical-align: inherit;">Finally, bazel is a pretty popular open source project on github, so it's definitely worth a look and try it out.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Example 1. Trivial</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is main.cc and you need to compile it: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
main.cc</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello, habr"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It all starts with a workspace declaration. In terms of bazel workspace, this is the directory in which all your source files are located. To designate this workspace, you need to create an empty file with the name WORKSPACE in the directory we need, usually this is the src directory. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The minimum unit for organizing code in bazel is a package. The package is defined by the source directory and a special BUILD file that describes how these sources are assembled. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Add the main package to our project: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wq/dq/7l/wqdq7lk5ecrf91hqc2u7og0y3do.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the BUILD file, we must now describe what we want to build from our main. Naturally, we want to compile an executable binary, so we will use the cc_binary rule. Bazel already supports C ++ out of the box, so there is already a certain set of rules for building c ++ goals, we will get to know the rest later.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Add the cc_binary rule to the BUILD file, it has a name that will have an executable file and an array of sources that will be passed to the compiler. </font><font style="vertical-align: inherit;">All of this is described in starlark, which is a truncated python.</font></font><br>
<br>
<pre><code class="python hljs">cc_binary(<font></font>
  name = <span class="hljs-string">"hello_world"</span>,<font></font>
  srcs = <span class="hljs-string">"main.cc"</span><font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bazel, unlike cmake, is not based on commands, but allows declaratively describe dependencies through rules. </font><font style="vertical-align: inherit;">Essentially, rules associate multiple artifacts with a specific operation. </font><font style="vertical-align: inherit;">Using them, bazel builds a command graph, which then caches and executes. </font><font style="vertical-align: inherit;">In our case, the main.cc source file is associated with a compilation operation, the result of which is the artifact hello_world - a binary executable file. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To now get our executable, we must go to the directory with workspace and type:</font></font><br>
<br>
<pre><code class="bash hljs">bazel build //main:hello_world
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The build system accepts the build command and the path to our goal, starting from the root of our project. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The resulting binary will be located at bazel-bin / main / hello_world.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Example 2. Build with your library</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortunately, nobody needs such simple projects, so let's see how to add functionality to our project. </font><font style="vertical-align: inherit;">Add a library that will be built separately and linked to our main. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let it be Square, a library that will provide an unambiguous squaring function. </font><font style="vertical-align: inherit;">Adding a new library means adding a new package, let's also call it square. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/kv/kr/0o/kvkr0o7nryy4fddsibmtge2dabo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
square.h</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SQUQRE_SQUARE_H_</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SQUQRE_SQUARE_H_</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>;<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// SQUQRE_SQUARE_H_</span></span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
square.cc</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"square/square.h"</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-keyword">return</span> x * x;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pay attention to the connection of the header file, I do it through the path from the workspace, even though the file is in the same directory. This approach is adopted in the chromium code style guide, which is inherited from google c ++ style guide. This method allows you to immediately understand where the header file is connected from. Do not worry, there will be a file, bazel will add paths to search for header files, but if you do not follow this rule, then header files may not be found during the bazel build. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the BUILD file of our library, we describe the rule for building the cc_library libraries:</font></font><br>
<br>
<pre><code class="python hljs">cc_library(<font></font>
  name = <span class="hljs-string">"square"</span>,<font></font>
  srcs = [<span class="hljs-string">"square.cc"</span>],<font></font>
  hdrs = [<span class="hljs-string">"square.h"</span>],<font></font>
  visibility = [<span class="hljs-string">"//visibility:public"</span>]<font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we list separately the source and header files, and also specify the visibility in public. </font><font style="vertical-align: inherit;">The latter is necessary so that we can depend on our library anywhere in our project. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In main.cc we use our library:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"square/square.h"</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello, bazel!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; Square(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Again, I draw attention to the fact that we include the header file of the library through the path from workspace. </font><font style="vertical-align: inherit;">This is already absolutely necessary here, because bazel uses Linux containers under the hood to ensure a minimum level of tightness of the assembly and, accordingly, it will mount the square library header files just so that they are located through the path from the workspace. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And we describe the dependency in the assembly rule for main on the square library.</font></font><br>
<br>
<pre><code class="python hljs">cc_binary(<font></font>
  name = <span class="hljs-string">"hello_world"</span>,<font></font>
  srcs = [<span class="hljs-string">"main.cc"</span>],<font></font>
  deps = [<span class="hljs-string">"//square:square"</span>]<font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our entire program is assembled in the same way as without using the library, bazel itself will understand what it depends on, build a graph, cache the results and rebuild only what needs to be rebuilt.</font></font><br>
<br>
<pre><code class="bash hljs">bazel build //main:hello_world
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Example 3. Connecting tests</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How to live without tests? </font><font style="vertical-align: inherit;">No way! </font><font style="vertical-align: inherit;">To connect to bazel GTest, which by the way already supports assembly with bazel, you need to add an external dependency. </font><font style="vertical-align: inherit;">This is done in the WORKSPACE file:</font></font><br>
<br>
<pre><code class="python hljs">load(<span class="hljs-string">"@bazel_tools//tools/build_defs/repo:git.bzl"</span>, <span class="hljs-string">"git_repository"</span>)<font></font>
<font></font>
git_repository(<font></font>
  name = <span class="hljs-string">"googletest"</span>,<font></font>
  remote = <span class="hljs-string">"https://github.com/google/googletest"</span>,<font></font>
  tag = <span class="hljs-string">"release-1.8.1"</span><font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Just like hipsters, they connected the git_repository rule and told bazel which version to download. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, we create a separate package for test tests and add tests to our library into it: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
square_unittest.cc</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"gtest/gtest.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"square/square.h"</span></span><font></font>
<font></font>
TEST(SquareTests, Basics) {<font></font>
    EXPECT_EQ(Square(<span class="hljs-number">-1</span>), <span class="hljs-number">1</span>);<font></font>
    EXPECT_EQ(Square(<span class="hljs-number">1</span>), <span class="hljs-number">1</span>);<font></font>
    EXPECT_EQ(Square(<span class="hljs-number">2</span>), <span class="hljs-number">4</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now it‚Äôs the turn to define a rule for tests.</font></font><br>
<br>
<pre><code class="python hljs">cc_test(<font></font>
  name = <span class="hljs-string">"unittests"</span>,<font></font>
  srcs = [<span class="hljs-string">"square_unittest.cc"</span>],<font></font>
  deps = [<font></font>
   <span class="hljs-string">"//square:square"</span>,
   <span class="hljs-string">"@googletest//:gtest_main"</span><font></font>
  ]<font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We added dependencies on our library and on gtest_main so that the gtest library itself would provide us with a launcher implementation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tests are run with the command:</font></font><br>
<br>
<pre><code class="bash hljs">bazel <span class="hljs-built_in">test</span> //<span class="hljs-built_in">test</span>:unittests
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bazel will download and build GTest itself, link everything that is needed for the tests and run the tests themselves. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I mention that bazel also knows how to do code coverage:</font></font><br>
<br>
<pre><code class="bash hljs">bazel coverage //<span class="hljs-built_in">test</span>:unittests
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And if you need to debug tests, then you can compile everything in debug mode with characters like this:</font></font><br>
<br>
<pre><code class="bash hljs">bazel build //<span class="hljs-built_in">test</span>:unittests --compilation_mode=dbg -s
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Example 4. Connecting other libraries that do not know how to bazel</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, the world is not built on bazel alone, so you need to be able to connect other libraries as well. </font><font style="vertical-align: inherit;">Recently, in my project, I needed a library to parse command line arguments. </font><font style="vertical-align: inherit;">Well, not to write to me in 2k20 your own such library and be distracted from the main work. </font><font style="vertical-align: inherit;">I really do not want to use any half measures, like getops, as well as drag boost into my project. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Not for advertising, we‚Äôll connect the CLI11 library, which uses nothing more than the stl standard C ++ 11 and provides a more or less convenient interface. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A library is header-only, which makes connecting it especially easy. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Connect the external dependency in WORKSPACE:</font></font><br>
<br>
<pre><code class="python hljs">load(<span class="hljs-string">"@bazel_tools//tools/build_defs/repo:http.bzl"</span>, <span class="hljs-string">"http_file"</span>)<font></font>
<font></font>
http_file(<font></font>
  name = <span class="hljs-string">"CLI11"</span>,<font></font>
  downloaded_file_path = <span class="hljs-string">"CLI11.hpp"</span>,<font></font>
  urls = [<span class="hljs-string">"https://github.com/CLIUtils/CLI11/releases/download/v1.9.0/CLI11.hpp"</span>],<font></font>
  sha256 = <span class="hljs-string">"6f0a1d8846ed7fa4c2b66da3eb252aa03d27170258df..."</span>,<font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We add the third-party directory and add the CLI11 package for the convenience of building dependencies on this library:</font></font><br>
<br>
<pre><code class="python hljs">cc_library(<font></font>
  name = <span class="hljs-string">"CLI11"</span>,<font></font>
  hdrs = [<span class="hljs-string">"@CLI11//file"</span>],<font></font>
  strip_include_prefix = <span class="hljs-string">"/external/CLI11/file"</span>,<font></font>
  include_prefix = <span class="hljs-string">"CLI11"</span>,<font></font>
  linkstatic = <span class="hljs-literal">True</span>,<font></font>
  visibility = [<span class="hljs-string">"//visibility:public"</span>],<font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bazel will by default look for the library file by the path / external / CLI11 so that we change the paths a bit to connect it via CLI11 /. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
main.cc</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"CLI11/CLI11.hpp"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"square/square.h"</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello, bazel!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; Square(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depending on main, add "// third_party / CLI11: CLI11" and everything starts to work. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I don‚Äôt know about you, but connecting some unfamiliar library and using it in a c ++ project in this form delights me. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yes, with the header-only library you will say that everything is simple, but with a non-header-only library that is not yet built with bazel everything is just as simple. </font><font style="vertical-align: inherit;">You simply download it via http_archive or git_repository and add an external BUILD file to it in the third-party directory, where you describe how to build your library. </font><font style="vertical-align: inherit;">Bazel supports calling any cmd and even calling cmake, through the cmake_external rule.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Example 5. Scripts and automation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Who needs a project in bare c ++ in 2k20 without scripts for automation? </font><font style="vertical-align: inherit;">Typically, such scripts are needed to run perf tests or to deploy your artifacts somewhere to CI. </font><font style="vertical-align: inherit;">Well, usually they are written in python. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For this, bazel is also suitable, since it can be used in almost all popular languages ‚Äã‚Äãand is designed to collect such solyanka from different programming languages ‚Äã‚Äãthat are so often found in real projects. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's connect the python script that will run our main. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Add the perf-tests package:</font></font><br>
<br>
<pre><code class="python hljs">py_binary(<font></font>
  name = <span class="hljs-string">"perf_tests"</span>,<font></font>
  srcs = [<span class="hljs-string">"perf_tests.py"</span>],<font></font>
  data = [<font></font>
    <span class="hljs-string">"//main:hello_world"</span>,<font></font>
  ],<font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a data dependency, add the hello_world binary dependency. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
perf_tests.py</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> subprocess
<span class="hljs-keyword">import</span> time<font></font>
<font></font>
start_time = time.time()<font></font>
process = subprocess.run([<span class="hljs-string">'main/hello_world, '</span>param1<span class="hljs-string">', ],
                         stdout=subprocess.PIPE,
                         universal_newlines=True)
end_time = time.time()
print("--- %s seconds ---" % (end_time - start_time))
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to run our tests, we simply write:</font></font><br>
<pre><code class="bash hljs">bazel run //perf-tests:perf_tests
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion and what is not touched</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We briefly looked at bazel and its main features for assembling executable files and libraries, both third-party and our own. </font><font style="vertical-align: inherit;">For my taste, it turns out pretty concisely and very quickly. </font><font style="vertical-align: inherit;">No need to suffer and look for some cmake tutorial to do some trivial thing and clean CmakeCache. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you are interested, then there is still a lot left over: connecting protocol buffers, sanitizers, setting up a tool chain to compile for different platforms / architectures. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thanks for reading, and I hope I was useful to you.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en489554/index.html">Little subtleties of java.lang.String</a></li>
<li><a href="../en489556/index.html">Do not give names to threads from ThreadPool when debugging in VS</a></li>
<li><a href="../en489558/index.html">About Samsung updated the flagship TV: Q950 - changes, jambs, as well as forecasts for the new device</a></li>
<li><a href="../en489560/index.html">React Native Feedback Form Using AWS + Telegram</a></li>
<li><a href="../en489562/index.html">Testing in Kotlin with Spock</a></li>
<li><a href="../en489568/index.html">DEFCON 27 Conference. Duplication of mechanical keys with limited access. Part 1</a></li>
<li><a href="../en489576/index.html">The nuances of modern medicine</a></li>
<li><a href="../en489582/index.html">In search of Godzilla. Neural networks and forecasting quotes based on exchange and "external" data</a></li>
<li><a href="../en489584/index.html">How to improve your API service on node.js. Part 1</a></li>
<li><a href="../en489586/index.html">Sound visualization on vintage lamps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>