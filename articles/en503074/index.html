<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∫üèΩ üéÄ üßóüèø Details about the Provider package for Flutter üóØÔ∏è üëº üçá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! 
 
 Our medium-term plans include the release of the Flutter book. Regarding the language of Dart as a topic, we still take a more cautio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Details about the Provider package for Flutter</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/503074/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello, Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our medium-term plans include the release of the Flutter book. </font><font style="vertical-align: inherit;">Regarding the language of Dart as a topic, we still take a more cautious position, so we will try to evaluate its relevance according to the results of this article. </font><font style="vertical-align: inherit;">It will focus on the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Provider</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> package </font><font style="vertical-align: inherit;">and, therefore, on state management in Flutter.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Provider is a state management package written by </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remy Rusle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and adopted by Google and the Flutter community. </font><font style="vertical-align: inherit;">But what is state management? </font><font style="vertical-align: inherit;">For starters, what is a condition? </font><font style="vertical-align: inherit;">Let me remind you that state is just data for representing the UI in your application. </font><font style="vertical-align: inherit;">State management is an approach to creating this data, accessing, handling and disposing of it. </font><font style="vertical-align: inherit;">To better understand the Provider package, we briefly outline the history of state management in Flutter.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. StatefulWidget</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StatelessWidget</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a simple UI component that displays only when it has data. There is </font></font><code>StatelessWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no ‚Äúmemory"; it is created and destroyed as necessary. Flutter also has a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StatefulWidget</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in which there is a memory, thanks to it a long-lived satellite - the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">State</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> object </font><font style="vertical-align: inherit;">. This class has a method </font></font><code>setState()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, when called, a widget is launched that rebuilds the state and displays it in a new form. This is the simplest form of Flutter state management provided out of the box. Here is an example with a button that always displays the time it was last pressed:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyWidgetState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyWidget</span>&gt; </span>{
  <span class="hljs-built_in">DateTime</span> _time = <span class="hljs-built_in">DateTime</span>.now();  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(_time.toString()),<font></font>
      onPressed: () {<font></font>
        setState(() =&gt; _time = <span class="hljs-built_in">DateTime</span>.now());<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So what is the problem with this approach? </font><font style="vertical-align: inherit;">Suppose your application has some global state stored in the root </font></font><code>StatefulWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It contains data that is intended for use in various parts of the UI. </font><font style="vertical-align: inherit;">This data is shared and passed to each child widget in the form of parameters. </font><font style="vertical-align: inherit;">Any events at which it is planned to change this data then pop up in the form of callbacks. </font><font style="vertical-align: inherit;">Thus, through all intermediate widgets, a lot of parameters and callbacks are transmitted, which can soon lead to confusion. </font><font style="vertical-align: inherit;">Worse, any updates to the aforementioned root will lead to a rebuild of the entire widget tree, which is inefficient.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. InheritedWidget</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InheritedWidget</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a special widget whose descendants can access it without a direct link. </font><font style="vertical-align: inherit;">Just by turning to </font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a consuming widget can register for an automatic rebuild, which will occur when rebuilding an ancestor widget. </font><font style="vertical-align: inherit;">This technique allows you to more efficiently organize the UI update. </font><font style="vertical-align: inherit;">Instead of rebuilding huge pieces of the application in response to a small change in state, you can selectively select only those specific widgets that need to be rebuilt. </font><font style="vertical-align: inherit;">You have already worked with </font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">whenever you used </font></font><code>MediaQuery.of(context)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>Theme.of(context)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">True, it is less likely that you have implemented your own InheritedWidget with state preservation. </font><font style="vertical-align: inherit;">The fact is that correctly implementing them is not easy.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. ScopedModel</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScopedModel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a package created in 2017 by Brian Egan, which makes it easy to use </font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to store application state. </font><font style="vertical-align: inherit;">First you need to create a state object that inherits from </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and then call </font></font><code>notifyListeners()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it when its properties change. </font><font style="vertical-align: inherit;">The situation is reminiscent of the implementation of the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PropertyChangeListener</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> interface </font><font style="vertical-align: inherit;">in Java.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Model</span> </span>{<font></font>
  String _foo;  String get foo =&gt; _foo;<font></font>
  <font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> set <span class="hljs-title">foo</span><span class="hljs-params">(String value)</span> </span>{<font></font>
    _foo = value;<font></font>
    notifyListeners();  <font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To provide our state object, we wrap this object in a widget </font></font><code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the root of our application:</font></font><br>
<br>
<pre><code class="java hljs">ScopedModel&lt;MyModel&gt;(<font></font>
  model: MyModel(),<font></font>
  child: MyApp(...)<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now any descendant widgets will be able to access </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">using the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScopedModelDescendant</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> widget </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The model instance is passed to the parameter </font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> ScopedModelDescendant&lt;MyModel&gt;(<font></font>
      builder: (context, child, model) =&gt; Text(model.foo),<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Any descendant widget will also be able to update the model, which will automatically provoke a rebuild of any </font></font><code>ScopedModelDescendants</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(provided that our model correctly calls </font></font><code>notifyListeners()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(<span class="hljs-string">'Update'</span>),<font></font>
      onPressed: () {<font></font>
        <span class="hljs-keyword">final</span> model = ScopedModel.of&lt;MyModel&gt;(context);<font></font>
        model.foo = <span class="hljs-string">'bar'</span>;<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br>
<code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gained popularity in Flutter as a tool for state management, but its use is limited to the provision of objects that inherit the class </font></font><code>Model</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and use this pattern of notification of changes.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. BLoC</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google I / O '18</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conference, the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Business Logic Component</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (BLoC) </font><font style="vertical-align: inherit;">pattern was introduced </font><font style="vertical-align: inherit;">, which serves as yet another tool for pulling state from widgets. BLoC classes are long-lived non-UI components that preserve state and expose it as streams and receivers. Taking state and business logic beyond the UI, you can implement the widget as simple </font></font><code>StatelessWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and use </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamBuilder</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for automatic rebuilding. As a result, the widget "gets dumb", and it becomes easier to test. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Example BLoC class:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBloc</span> </span>{
  <span class="hljs-keyword">final</span> _controller = StreamController&lt;MyType&gt;();  Stream&lt;MyType&gt; <span class="hljs-keyword">get</span> stream =&gt; _controller.stream;<font></font>
  StreamSink&lt;MyType&gt; <span class="hljs-keyword">get</span> sink =&gt; _controller.sink;<font></font>
  <font></font>
  myMethod() {<font></font>
    <span class="hljs-comment">//  </span><font></font>
    sink.add(foo);<font></font>
  }  dispose() {<font></font>
    _controller.close();<font></font>
  }<font></font>
}<font></font>
 ,   BLoC:<font></font>
<span class="hljs-meta">@override</span><font></font>
Widget build(BuildContext context) {<font></font>
 <span class="hljs-keyword">return</span> StreamBuilder&lt;MyType&gt;(<font></font>
  stream: myBloc.stream,<font></font>
  builder: (context, asyncSnapshot) {<font></font>
    <span class="hljs-comment">//  </span><font></font>
 });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The problem with the BLoC pattern is that it is not obvious how to create and destroy BLoC objects. </font><font style="vertical-align: inherit;">How was the instance created </font></font><code>myBloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the above example? </font><font style="vertical-align: inherit;">How do we call </font></font><code>dispose()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to get rid of him? </font><font style="vertical-align: inherit;">Streams require use </font></font><code>StreamController</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which should be </font></font><code>closed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as soon as it becomes unnecessary - this is done to prevent memory leaks. </font><font style="vertical-align: inherit;">(There is no such thing as a class destructor in Dart; only a class </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>StatefulWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">has a method </font></font><code>dispose()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">In addition, it is not clear how to share this BLoC between multiple widgets. </font><font style="vertical-align: inherit;">It is often difficult for developers to master BLoC. </font><font style="vertical-align: inherit;">There are several packages that attempt to simplify this.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Provider</font></font></h4><br>
<code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is a package written in 2018 by Remy Rusle, similar to </font></font><code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but whose functions are not limited to, providing a subclass of Model. This is also a wrapper that concludes </font></font><code>InheritedWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but the provider can provide any state objects, including BLoC, streams, futures and others. Since the provider is so simple and flexible, Google announced at the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google I / O '19 conference</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that in the future it </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be the preferred package for managing state. Of course, other packages are also allowed, but if you have any doubts, Google recommends stopping at </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">built ‚Äúwith widgets, for widgets.‚Äù</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allows you to place any object with a state in the widget tree and open access to it for any other widget (child). </font><font style="vertical-align: inherit;">It also </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">helps to manage the lifetime of state objects by initializing them with data and performing a cleanup after they are removed from the widget tree. </font><font style="vertical-align: inherit;">Therefore, it </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is suitable even for implementing BLoC components or can serve as a basis for other state management solutions! </font><font style="vertical-align: inherit;">Or simply used to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implement dependencies</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a fancy term that means transferring data to widgets in a way that allows you to loosen the connection and improve the testability of the code. </font><font style="vertical-align: inherit;">Finally,</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comes with a set of specialized classes, thanks to which it is even more convenient to use. </font><font style="vertical-align: inherit;">Next, we will take a closer look at each of these classes.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basic Provider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChangeNotifierProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Futureprovider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueListenableProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MultiProvider</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proxyprovider</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installation</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To use it </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, first add a dependency to our file </font></font><code>pubspec.yaml</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<code>provider: ^3.0.0</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then we import the package </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where it is needed: </font></font><br>
<br>
<code>import 'package:provider/provider.dart';</code><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Base provider</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Create the base </font></font><code>Provide</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r in the root of our application; </font><font style="vertical-align: inherit;">this will contain an instance of our model:</font></font><br>
<br>
<pre><code class="dart hljs">Provider&lt;MyModel&gt;(<font></font>
  builder: (context) =&gt; MyModel(),<font></font>
  child: MyApp(...),<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The parameter </font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">creates an instance </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If you want to pass an existing instance to it, use the constructor here </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">Provider.value</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then you can consume this instance of the model anywhere in </font></font><code>MyApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, using the widget </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> Consumer&lt;MyModel&gt;(<font></font>
      builder: (context, value, child) =&gt; Text(value.foo),<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the above example, the class </font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gets an instance </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">using the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consumer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> widget </font><font style="vertical-align: inherit;">. This widget gives us </font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">containing our object in the parameter </font></font><code>value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now, what should we do if we want to update the data in our model? Let's say we have another widget where, when a button is clicked, the property should be updated </font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(<span class="hljs-string">'Update'</span>),<font></font>
      onPressed: () {<font></font>
        <span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context);<font></font>
        model.foo = <span class="hljs-string">'bar'</span>;<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note the specific syntax used to access the instance </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Functionally, this is equivalent to accessing the widget </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The widget </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is useful in cases when the code cannot easily get the link </font></font><code>BuildContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What do you think will happen to the original widget </font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that we created earlier? Will a new meaning be displayed in it </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, no</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It is not possible to listen to changes in old traditional Dart objects (at least without reflection, which is not provided in Flutter). Thus, </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it will not be able to ‚Äúsee‚Äù that we have properly updated the property </font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and ordered the widget to be </font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">updated in response. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChangeNotifierProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But there is hope! </font><font style="vertical-align: inherit;">You can make our class </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implement an impurity </font></font><code>ChangeNotifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It will take a bit to change the implementation of our model and call a special method </font></font><code>notifyListeners()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">whenever one of our properties changes. </font><font style="vertical-align: inherit;">It works in approximately the same way </font></font><code>ScopedModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but in this case it‚Äôs nice that you don‚Äôt need to inherit from a particular model class. </font><font style="vertical-align: inherit;">It is enough to realize the admixture </font></font><code>ChangeNotifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Here's what it looks like:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span> <span class="hljs-title">with</span> <span class="hljs-title">ChangeNotifier</span> </span>{
  <span class="hljs-built_in">String</span> _foo;  <span class="hljs-built_in">String</span> <span class="hljs-keyword">get</span> foo =&gt; _foo;<font></font>
  <font></font>
  <span class="hljs-keyword">void</span> <span class="hljs-keyword">set</span> foo(<span class="hljs-built_in">String</span> value) {<font></font>
    _foo = value;<font></font>
    notifyListeners();  <font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see, we replaced our property </font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with </font></font><code>getter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>setter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, backed by the _foo private variable. </font><font style="vertical-align: inherit;">This way we can ‚Äúintercept‚Äù any changes made to the foo property and let our listeners know that our object has changed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now, from the outside </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we can change our implementation so that it uses a different class called </font></font><code> ChangeNotifierProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs">ChangeNotifierProvider&lt;MyModel&gt;(<font></font>
  builder: (context) =&gt; MyModel(),<font></font>
  child: MyApp(...),<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Like this! </font><font style="vertical-align: inherit;">Now, when our </font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">updates the property </font></font><code>foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the instance </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it </font></font><code>MyWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will automatically update to reflect this change. </font><font style="vertical-align: inherit;">Cool, right? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By the way. </font><font style="vertical-align: inherit;">You probably noticed a button handler </font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with which we used the following syntax:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By default, this syntax will automatically cause instance rebuilding </font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as soon as the model changes </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Perhaps we do not need this. </font><font style="vertical-align: inherit;">In the end, it </font></font><code>OtherWidget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simply contains a button that does not change at all when the value changes </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">To avoid rebuilding, you can use the following syntax to access our model without registering for rebuilding:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context, listen: <span class="hljs-keyword">false</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is another charm provided in the package </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">just like that. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
At first glance, it is not clear why it is needed </font></font><code>StreamProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In the end, you can just use the usual </font></font><code>StreamBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if you need to consume a stream in Flutter. </font><font style="vertical-align: inherit;">For example, here we listen to the stream </font></font><code>onAuthStateChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">provided by </font></font><code>FirebaseAuth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-meta">@override</span><font></font>
Widget build(BuildContext context {<font></font>
  <span class="hljs-keyword">return</span> StreamBuilder(<font></font>
   stream: FirebaseAuth.instance.onAuthStateChanged, <font></font>
   builder: (BuildContext context, AsyncSnapshot snapshot){ <font></font>
     ...<font></font>
   });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To do the same with help </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we could provide our stream through </font></font><code>StreamProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the root of our application:</font></font><br>
<br>
<pre><code class="dart hljs">StreamProvider&lt;FirebaseUser&gt;.value(<font></font>
  stream: FirebaseAuth.instance.onAuthStateChanged,<font></font>
  child: MyApp(...),<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then consume the child widget, as is usually done with </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-meta">@override</span><font></font>
Widget build(BuildContext context) {<font></font>
  <span class="hljs-keyword">return</span> Consumer&lt;FirebaseUser&gt;(<font></font>
    builder: (context, value, child) =&gt; Text(value.displayName),<font></font>
  );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Not only has our widget code become much cleaner, it also abstracts the fact that the data came from the stream. If we ever decide to change the base implementation, for example, to </font></font><code>FutureProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then no changes to the widget code will be required. As you will see, this applies to all other providers shown below. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FutureProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Similar to the above example, it </font></font><code>FutureProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is an alternative to the standard </font></font><code> FutureBuilder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when working with widgets. Here is an example:</font></font><br>
<br>
<pre><code class="plaintext hljs">FutureProvider&lt;FirebaseUser&gt;.value(<font></font>
  value: FirebaseAuth.instance.currentUser(),<font></font>
  child: MyApp(...),<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To consume this value in the child widget, we use the same implementation </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as in the example </font></font><code>StreamProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">above. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueListenableProvider </font></font></i><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueListenable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a Dart interface implemented by the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ValueNotifier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">that takes a value and notifies listeners when it changes to another value. </font><font style="vertical-align: inherit;">It is possible, for example, to wrap an integer counter in a simple model class:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span> </span>{
  <span class="hljs-keyword">final</span> ValueNotifier&lt;<span class="hljs-built_in">int</span>&gt; counter = ValueNotifier(<span class="hljs-number">0</span>);  <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When working with complex types, it </font></font><code>ValueNotifier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uses the operator of the </font></font><code>==</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">object stored in it to determine if the value has changed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's create the simplest one </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which will contain our main model, and it will be followed by a </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nested </font></font><code>ValueListenableProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">listening property </font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="dart hljs">Provider&lt;MyModel&gt;(<font></font>
  builder: (context) =&gt; MyModel(),<font></font>
  child: Consumer&lt;MyModel&gt;(builder: (context, value, child) {<font></font>
    <span class="hljs-keyword">return</span> ValueListenableProvider&lt;<span class="hljs-built_in">int</span>&gt;.value(<font></font>
      value: value.counter,<font></font>
      child: MyApp(...)<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Please note that this nested provider is of type </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">There may be others. </font><font style="vertical-align: inherit;">If you have several providers of the same type registered, the Provider will return the ‚Äúclosest‚Äù (closest ancestor). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here's how to listen to a property </font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from any child widget:</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> Consumer&lt;<span class="hljs-built_in">int</span>&gt;(<font></font>
      builder: (context, value, child) {<font></font>
        <span class="hljs-keyword">return</span> Text(value.toString());<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But here's how to update a property </font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from another widget. </font><font style="vertical-align: inherit;">Please note: we need access to the original copy </font></font><code>MyModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="dart hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span><font></font>
  Widget build(BuildContext context) {<font></font>
    <span class="hljs-keyword">return</span> FlatButton(<font></font>
      child: Text(<span class="hljs-string">'Update'</span>),<font></font>
      onPressed: () {<font></font>
        <span class="hljs-keyword">final</span> model = Provider.of&lt;MyModel&gt;(context);<font></font>
        model.counter.value++;<font></font>
      },<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MultiProvider</font></font></i></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
If you use many widgets</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then in the root of the application you get an ugly structure from many attachments:</font></font><br>
<br>
<pre><code class="dart hljs">Provider&lt;Foo&gt;.value( <font></font>
  value: foo, <font></font>
  child: Provider&lt;Bar&gt;.value( <font></font>
    value: bar, <font></font>
    child: Provider&lt;Baz&gt;.value( <font></font>
      value: baz , <font></font>
      child: MyApp(...)<font></font>
    ) <font></font>
  ) <font></font>
)</code></pre><br>
<code>MultiProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allows you to declare them all on the same level. </font><font style="vertical-align: inherit;">It‚Äôs just syntactic sugar: at the intra-system level, they all remain nested anyway.</font></font><br>
<br>
<pre><code class="dart hljs">MultiProvider( <font></font>
  providers: [ <font></font>
    Provider&lt;Foo&gt;.value(value: foo), <font></font>
    Provider&lt;Bar&gt;.value(value: bar), <font></font>
    Provider&lt;Baz&gt;.value(value: baz), <font></font>
  ], <font></font>
  child: MyApp(...), <font></font>
)<font></font>
</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProxyProvider</font></font></i></a><br>
<br>
<code>ProxyProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is an interesting class added in the third package release</font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It allows you to declare providers that themselves may depend on other providers, up to six on one. </font><font style="vertical-align: inherit;">In this example, the Bar class is instance-specific</font></font><code>Foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is useful when compiling a root set of services that are themselves dependent on each other.</font></font><br>
<br>
<pre><code class="dart hljs">MultiProvider ( <font></font>
  providers: [ <font></font>
    Provider&lt;Foo&gt; ( <font></font>
      builder: (context) =&gt; Foo(),<font></font>
    ), <font></font>
    ProxyProvider&lt;Foo, Bar&gt;(<font></font>
      builder: (context, value, previous) =&gt; Bar(value),<font></font>
    ), <font></font>
  ], <font></font>
  child: MyApp(...),<font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first generic type argument is the type that yours depends on </font></font><code>ProxyProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the second is the type that it returns.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to listen to many providers at the same time</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What if we want a single widget to listen to many providers and rebuild when any of them changes? </font><font style="vertical-align: inherit;">You can listen to up to 6 providers at the same time using widget options </font></font><code>Consumer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We will receive instances as additional method parameters </font></font><code>builder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="dart hljs">Consumer2&lt;MyModel, <span class="hljs-built_in">int</span>&gt;(<font></font>
  builder: (context, value, value2, child) {<font></font>
    <span class="hljs-comment">//value  MyModel</span>
    <span class="hljs-comment">//value2  int</span><font></font>
  },<font></font>
);</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When used, </font></font><code>InheritedWidget</code> <code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it allows </font><font style="vertical-align: inherit;">you </font><font style="vertical-align: inherit;">to manage the state as is customary in Flutter. </font><font style="vertical-align: inherit;">It allows widgets to access state objects and listen to them in such a way that the underlying notification mechanism is abstracted. </font><font style="vertical-align: inherit;">It‚Äôs easier to manage the lifetime of state objects by creating anchor points to create these objects as needed and get rid of them when needed. </font><font style="vertical-align: inherit;">This mechanism can be used to easily implement dependencies and even as a basis for more advanced state management options. </font><font style="vertical-align: inherit;">With the blessing of Google and growing support in the Flutter community, it </font></font><code>Provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">has become a package worth trying without delay!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en503062/index.html">–†–µ–∞–ª—å–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –∂–∏–∑–Ω–∏ –≤ –ö—Ä–µ–º–Ω–∏–µ–≤–æ–π –î–æ–ª–∏–Ω–µ –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞</a></li>
<li><a href="../en503064/index.html">IoT where you did not wait (part 3). Building a simulation model</a></li>
<li><a href="../en503068/index.html">At the crossroads of technology and business: IT leaders open a new university in Switzerland</a></li>
<li><a href="../en503070/index.html">Electric mug. Building a crazy electric scooter / electric bike</a></li>
<li><a href="../en503072/index.html">Just another tool: getting to know the service configuration with Desired State Configuration¬†</a></li>
<li><a href="../en503082/index.html">Telegram as NAS / FTP</a></li>
<li><a href="../en503084/index.html">Lightbend Academy Course Review - Reactive Architecture</a></li>
<li><a href="../en503086/index.html">Are online transcription services secure and confidential?</a></li>
<li><a href="../en503088/index.html">How we selected cargo for carriers</a></li>
<li><a href="../en503096/index.html">Why do managers want workers to recycle?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>