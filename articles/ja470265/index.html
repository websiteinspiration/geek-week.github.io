<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👧‍👧 👨🏾‍🔧 🌊 C ++の省略に関するチートシートなど。パート1：C ++ 🛌🏼 🤬 🤰🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="かつては、C ++開発者の役職について1つのまともな、そしてよく知られたオフィスでさえインタビューを受けました。私はそのときすでにいくつかの経験をしていました、そのとき私は私の雇用主の主要な開発者とさえ呼ばれました。しかし、DRY、KISS、YAGNI、NIHなどを知っているかどうか尋ねられたとき、...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C ++の省略に関するチートシートなど。パート1：C ++</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470265/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">かつては、C ++開発者の役職について1つのまともな、そしてよく知られたオフィスでさえインタビューを受けました。私はそのときすでにいくつかの経験をしていました、そのとき私は私の雇用主の主要な開発者とさえ呼ばれました。しかし、DRY、KISS、YAGNI、NIHなどを知っているかどうか尋ねられたとき、何度も何度も「いいえ」と答える必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、私は惨めに失敗しました。しかし、その後、上記の略語はグーグルで覚えられました。テーマ別の記事や本を読んだり、インタビューの準備をしたり、同僚と話したりするだけで、新しいことを学び、忘れてしまい、もう一度ググって理解しました。数か月前、私の同僚の1人がC ++のコンテキストでIIFEワーキングチャットでさりげなく言及しました。私は、冗談を言っているその祖父のように、ほとんどストーブから落ちて、再びグーグルに入りました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/i7/7u/fc/i77ufc8-ui3-rtrvpu-421lmpfq.png"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのとき、C ++開発者が知っていると役立つ略語のチートシートを（主に私自身が）作成することにしました。これは、それらがC ++にのみ適用されることや、C ++のすべてすべての概念であることを意味するものではありません（言語イディオムに関するボリュームを作成できます）。いいえ、これらは私が仕事やインタビューで実際に遭遇した概念であり、通常は略語の形で表現されています。まあ、LIFO、FIFO、CRUD、OOP、GCC、MSVCのような些細なことは見逃しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでも、略語はきちんと現れたので、チートシートを2つの部分に分けました。C++に強く特徴的で、より一般的です。必要に応じて、コンセプトをグループ化しました。それ以外の場合は、アルファベット順にリストしました。一般的に、それらの順序にはあまり意味がありません。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本的なもの：</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ODR</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POD</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POF</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PIMPL</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAII</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTTI</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STL</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UB </font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">言語の機微：</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADL</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CRTP</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CTAD</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EBO</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IIFE</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVI</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVOおよびNRVO</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SBO、SOO、SSO </font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新：</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CV</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LTO</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCH</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PGO</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEH / VEH</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TMP</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
&nbsp;&nbsp;•&nbsp;&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VLA</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本的なもの</font></font><a name="Basics"></a></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ODR</font></font><a name="ODR"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つの定義ルール。</font><font style="vertical-align: inherit;">1つの定義のルール。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡略化とは、次のことを意味します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単一の翻訳単位内では、各変数、関数、クラスなどは、1つだけの定義を持つことができます。</font><font style="vertical-align: inherit;">広告はいくつも存在します（特定の基本型のない列挙型を除き、単純に定義せずに宣言することはできません）が、複数の定義はありません。</font><font style="vertical-align: inherit;">エンティティが使用されていない場合、可能性は低くなります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラム全体を通して、使用される各非インライン関数と変数には、厳密に1つの定義が必要です。</font><font style="vertical-align: inherit;">使用される各インライン関数と変数は、各変換単位で1つの定義を持つ必要があります。</font></font></li>
<li>  —  , inline   , ,   .&nbsp;. —       (      ).    ,    .cpp       ,    , .      (  ,   ).   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">UB</a>.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラは</font><font style="vertical-align: inherit;">、ブロードキャストユニット内の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ODR</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">違反を簡単にキャッチし</font><font style="vertical-align: inherit;">ます。しかし、コンパイラが一度に1つの翻訳単位を処理するという理由だけで、プログラムレベルでルールに違反すると、彼は何もできなくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リンカーはさらに多くの違反を見つけることができますが、厳密に言えば、これを行う義務はなく（規格によると、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UBが</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここにあるため</font><font style="vertical-align: inherit;">）、何かを見逃す可能性があります。さらに</font><font style="vertical-align: inherit;">、リンク段階で</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ODR</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">違反を検索するプロセス</font><font style="vertical-align: inherit;">は2次の複雑さを持ち、C ++コードのアセンブリはそれほど高速ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、このルール（特にプログラムレベル）を順守する主な責任は開発者自身です。そしてはい</font><i><font style="vertical-align: inherit;">-ODRを</font></i><font style="vertical-align: inherit;">壊す</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラム規模では、外部リンクを持つエンティティのみができます。</font><font style="vertical-align: inherit;">内部からのもの（つまり、匿名の名前空間で定義されているもの）は、このカーニバルには参加しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：1 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回（英語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2回（英語）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポッド</font></font><a name="POD"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレーンな古いデータ。</font><font style="vertical-align: inherit;">シンプルなデータ構造。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最も簡単な定義：これは、Cライブラリとの間でバイナリ形式で送受信できる構造です。</font><font style="vertical-align: inherit;">または、同じことですが、simpleを正しくコピーします</font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準から標準に、完全な定義が詳細に変更されました。</font><font style="vertical-align: inherit;">最新のC ++ 17 </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PODは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在</font><font style="vertical-align: inherit;">、</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スカラー型</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはクラス/構造/共用体、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -自明なクラス</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -標準のデバイスを持つ</font><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">- </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 非</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POD</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非静的フィールドを</font><font style="vertical-align: inherit;">含まない</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはこれらのタイプの配列</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ささいなクラス</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少なくとも1つが削除されていない：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -デフォルト</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 コンストラクター</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - </font><font style="vertical-align: inherit;">コピーコンストラクター</font><font style="vertical-align: inherit;">-移動コンストラクター</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -コピー代入演算子</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -移動代入演算子</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンストラクターと代入演算子をコピーおよび移動するすべてのデフォルトコンストラクターは、簡単（コンパイラーによって生成される）またはリモートです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ささいな非リモートデストラクタがあります</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての基本型とクラス型のすべてのフィールドには自明なデストラクタがあります</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想メソッドなし（デストラクタを含む）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想基本タイプなし</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準デバイスのクラス（標準レイアウトクラス）：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想メソッドなし</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想基本タイプなし</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非静的リンクフィールドはありません</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての非静的フィールドには同じアクセス修飾子があります（パブリック/保護/プライベート）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての非静的フィールドと基本クラスも標準デバイスのタイプです</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラス自体のすべての非静的フィールドとそのすべての祖先が1つの単一クラス（つまり、クラス自体または祖先の1つ）で宣言されている</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じ型を2回継承することはありません。つまり、これを行うことは不可能です。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> {</span>};
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span> :</span> A {};
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">C</span> :</span> A{};
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">D</span> :</span> B, C {};</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の非静的フィールドのタイプ、または配列の場合は、その要素のタイプが基本タイプのいずれとも一致してはなりません（この場合は必須の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EBOの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため</font><font style="vertical-align: inherit;">）</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、C ++ 20では</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POD</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプの</font><font style="vertical-align: inherit;">概念</font><font style="vertical-align: inherit;">はなくなり、単純なタイプと標準デバイスのタイプのみが残ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1（ロシア語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2（英語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3（英語）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POF</font></font><a name="POF"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレーンな古い機能。</font><font style="vertical-align: inherit;">シンプルなCスタイルの関数</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シグナルハンドラのコンテキストでのみ、C ++ 14より前の標準で言及されていました。</font><font style="vertical-align: inherit;">要件は次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CとC ++に共通するものだけを使用します（つまり、例外はなく</font></font><code>try-catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、など）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接的または間接的に非生じない</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POFの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（アトミックブロックフリー操作を除いて、機能を</font></font><code>std::atomic_init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>std::atomic_fetch_add</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等）</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cリンク（</font></font><code>extern "C"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">も持つこのような関数のみが</font><font style="vertical-align: inherit;">、標準でシグナルハンドラーとして使用することが許可されています。</font><font style="vertical-align: inherit;">他の関数のサポートはコンパイラに依存します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 17では、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POF</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の概念が</font><font style="vertical-align: inherit;">なくなり、代わりに</font><font style="vertical-align: inherit;">シグナルセーフ評価</font><font style="vertical-align: inherit;">が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シグナルの意味で</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現れ</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そのような計算では禁止されています：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アトミックでロックのない標準ライブラリのすべての関数の呼び出し</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">挑戦</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>delete</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して </font></font><code>dynamic_cast</code></li>
<li><font style="vertical-align: inherit;"></font><code>thread_local</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本質に</font><font style="vertical-align: inherit;">訴える</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外のある仕事</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ローカル静的変数の初期化</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的変数の初期化が完了するのを待っています</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シグナルハンドラが上記のいずれかを行う場合、標準は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UBを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">約束し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間（英語）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PIMPL</font></font><a name="PIMPL"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装へのポインタ。</font><font style="vertical-align: inherit;">実装へのポインタ。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++の古典的なイディオムは、dポインター、不透明ポインター、コンパイルファイアウォールとも呼ばれます。</font><font style="vertical-align: inherit;">これは、特定のクラスのすべてのプライベートメソッド、フィールド、およびその他の実装の詳細が別のクラスに割り当てられ、パブリックメソッド（つまり、インターフェイス）とこの新しい別のクラスのインスタンスへのポインターのみが元のクラスに残るという事実に基づいています。</font><font style="vertical-align: inherit;">例えば：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo.hpp</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
    Foo();<font></font>
    ~Foo();<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doThis</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">doThat</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Impl</span>;</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Impl&gt; pImpl_;<font></font>
};</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foo.cpp</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"foo.hpp"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>:</span>:Impl<font></font>
{<font></font>
<span class="hljs-comment">// implementation</span><font></font>
};<font></font>
<font></font>
Foo::Foo()<font></font>
    : pImpl_(<span class="hljs-built_in">std</span>::make_unique&lt;Impl&gt;())<font></font>
{}<font></font>
<font></font>
Foo::~Foo() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo::doThis</span><span class="hljs-params">()</span>
</span>{<font></font>
    pImpl_-&gt;doThis();<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Foo::doThat</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> pImpl_-&gt;doThat();<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこれが必要なのか、つまり利点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カプセル化：ヘッダー接続を介したクラスのユーザーは、必要なもの（パブリックインターフェイス）のみを取得します。</font><font style="vertical-align: inherit;">実装の詳細が変更された場合、クライアントコードを再コンパイルする必要はありません（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ABIを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照</font><font style="vertical-align: inherit;">）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイル時：パブリックヘッダーは実装について何も知らないため、必要な多くのヘッダーが含まれていません。</font><font style="vertical-align: inherit;">したがって、クライアントコードの暗黙的に接続されたヘッダーの数が削減されます。</font><font style="vertical-align: inherit;">パブリックヘディングにはプライベートメンバーが含まれていないため、オーバーロードの名前と解決策の検索も単純化されています（プライベートメンバーはプライベートですが、これらのプロセスに参加しています）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
価格、つまり欠点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さらに、少なくとも1つのポインター逆参照と、パブリックメソッドにアクセスするときの1つの関数呼び出し。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要なメモリクラスのサイズは、ポインタのサイズによって増加します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このメモリの一部は（最も可能性の高い使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lshaya）もマイナスのパフォーマンスに影響を与え、ヒープ上で割り当てられました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">論理的不変性は簡単に違反される可能性があります。</font><font style="vertical-align: inherit;">たとえば、そのようなコードは次のようにコンパイルされます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo::doThis</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
</span>{<font></font>
    pImpl_-&gt;doThis();     <span class="hljs-comment">// cosnt method</span>
    pImpl_-&gt;doSmthElse(); <span class="hljs-comment">// non-const method</span>
}</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの欠点のいくつかは除去可能ですが、その代償としてコードがさらに複雑になり、抽象化のレベルが高くなります（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FTSEを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照</font><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1（ロシア語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2（ロシア語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3（英語）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAII</font></font><a name="RAII"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リソースの取得は初期化です。リソースの取得は初期化です。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このイディオムの意味は、特定のリソースの保持が、対応するオブジェクトの存続期間を通じて続くことです。リソースのキャプチャは、オブジェクトの作成/初期化、リリース時-同じオブジェクトの破棄/ファイナライズ時に行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
奇妙なことに（主にC ++プログラマー向け）、このイディオムは、ガベージコレクターを使用する言語であっても、他の言語で使用されます。 Java </font></font><code>try--</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では、Pythonでは演算子</font></font><code>with</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Cでは＃、ディレクティブ</font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ではGo </font></font><code>defer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。しかし、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAII</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が特に有機的に適合する</font><font style="vertical-align: inherit;">オブジェクトの絶対的な予測可能な寿命を備えたC ++ </font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++では、リソースは通常、コンストラクタでキャプチャされ、デストラクタで解放されます。たとえば、スマートポインタはこの方法でメモリを制御し、ファイルストリームはファイルを管理し、ミューテックスロックはミューテックスを使用します。美しさは、ブロックがどのように終了する（スコープ）かに関係なく-出口ポイントのいずれかを通じて正常であるか、または例外がスローされました-このブロックで作成されたリソース制御オブジェクトは破棄され、リソースは解放されます。それら。</font><font style="vertical-align: inherit;">C ++で</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAII</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をカプセル化することに加えて</font><font style="vertical-align: inherit;">、例外の意味でのセキュリティの確保にも役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらがない場合の制限。 C ++のデストラクタは値を返さないため、例外的に例外をスローするべきではありません。したがって、リソースの解放に何かが伴う場合は、コントロールオブジェクトのデストラクタに追加のロジックを実装する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つ（ロシア語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つ（英語）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTTI</font></font><a name="RTTI"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行時タイプ情報。</font><font style="vertical-align: inherit;">実行時のタイプ識別。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、実行時にオブジェクトまたは式のタイプに関する情報を取得するためのメカニズムです。</font><font style="vertical-align: inherit;">他の言語にも存在しますが、C ++では次の目的で使用されます。</font></font><br>
<br>
<ul>
<li><code>dynamic_cast</code></li>
<li><code>typeid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> そして </font></font><code>type_info</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外をキャッチ</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要な制限：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTTI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は仮想関数のテーブルを使用するため、多相型に対してのみ機能します（仮想デストラクタで十分です）。重要な説明：</font></font><code>dynamic_cast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それら</font></font><code>typeid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は常に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTTI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用するわけ</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">はない</font><font style="vertical-align: inherit;">ため、非多相型で機能します。たとえば、子孫への参照を祖先へのリンクに動的にキャストするに</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">RTTIは</font></i><font style="vertical-align: inherit;">必要</font><i><font style="vertical-align: inherit;">あり</font></i><font style="vertical-align: inherit;">ません。すべての情報はコンパイル時に利用できます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTTIは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少しではありますが、無料ではありませんが、消費されるメモリのパフォーマンスとサイズに悪影響を及ぼします（そのため、</font></font><code>dynamic_cast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速度が遅いため</font><font style="vertical-align: inherit;">、頻繁に使用しないことをお勧めします</font><font style="vertical-align: inherit;">）。したがって、コンパイラーは、原則として、</font><i><font style="vertical-align: inherit;">RTTI</font></i><font style="vertical-align: inherit;">を無効にすることができます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">GCCとMSVCは、これが例外をキャッチする正確さに影響しないことを約束します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つ（ロシア語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つ（英語）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STL</font></font><a name="STL"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準テンプレートライブラリ。</font><font style="vertical-align: inherit;">標準テンプレートライブラリ。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">汎用コンテナー、イテレーター、アルゴリズム、およびヘルパー関数を提供するC ++標準ライブラリの一部。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのよく知られている名前にもかかわらず、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は規格でそれほど呼ばれていません。</font><font style="vertical-align: inherit;">標準のセクションのうち、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は明らかにコンテナライブラリ、イテレータライブラリ、アルゴリズムライブラリ、および部分的に一般ユーティリティライブラリに起因します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仕事の説明では、C ++の知識と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STLの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">知識という2つの個別の要件を見つけることがよくあります</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は1998年の最初の標準以降、言語の不可欠な部分である</font><font style="vertical-align: inherit;">ため、私はこれを理解していません</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つ（ロシア語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つ（英語）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UB</font></font><a name="UB"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未定義の動作。</font><font style="vertical-align: inherit;">未定義の動作。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この動作は、標準に要件がないエラーの場合です。</font><font style="vertical-align: inherit;">これらの多くは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UBに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つながるものとして規格に明示的にリストされてい</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">たとえば、次のものが含まれます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列または</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナーの</font><font style="vertical-align: inherit;">境界の違反</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化されていない変数の使用</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nullポインター逆参照</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">符号付き整数オーバーフロー</font></font></li>
</ul><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UB</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の結果は</font><font style="vertical-align: inherit;">、コンパイラーのバージョンと火星の天気の両方に依存します。そして、この結果は何でもかまいません：コンパイルエラー、正しい実行、そしてクラッシュ。不確定な行動は悪であり、それを取り除く必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、未定義の動作は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未指定の動作</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と混同しないでください</font><font style="vertical-align: inherit;">。不特定の動作は正しいプログラムの正しい動作ですが、標準の許可を得て、コンパイラに依存します。そして、コンパイラはそれを文書化する必要はありません。たとえば、これは関数の引数または実装の詳細が評価される順序</font></font><code>std::map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、ここで</font><i><font style="vertical-align: inherit;">実装依存の動作を</font></i><font style="vertical-align: inherit;">思い出すことができ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（実装定義の動作）。</font><font style="vertical-align: inherit;">未指定とはドキュメントの可用性が異なります。</font><font style="vertical-align: inherit;">例：コンパイラーは</font></font><code>std::size_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意のサイズの</font><font style="vertical-align: inherit;">型を自由に作成</font><font style="vertical-align: inherit;">できますが、どれを指定する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1（ロシア語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2（ロシア語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3（英語）</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">言語の微妙さ</font></font><a name="Cobwebs"></a></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADL</font></font><a name="ADL"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引数に依存するルックアップ。</font><font style="vertical-align: inherit;">引数に依存する検索。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アンドリューケーニッヒに敬意を表して、彼はケーニッヒを探し求めています。</font><font style="vertical-align: inherit;">これは</font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、通常の名前解決に加えて、</font><font style="vertical-align: inherit;">修飾されていない関数名（つまり、演算子のない名前）を解決するための一連のルールです</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">簡単に言えば、関数の名前は、その引数に関連する名前空間で検索されます（これは、引数の型、型自体、クラスの場合はそのすべての祖先などを含むスペースです）。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最も単純な例</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><font></font>
<font></font>
<span class="hljs-keyword">namespace</span> N<font></font>
{<font></font>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> {</span>};
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(S)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"f(S)"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; };<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
    N::S s;<font></font>
    f(s);<font></font>
}</code></pre><br>
 <code>f</code>     <code>N</code>  ,      .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
でも、些細な一つが</font></font><code>std::cout &lt;&lt; "Hello World!\n"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADLを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>std::basic_stream::operator&lt;&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それはオーバーロードされていないため</font></font><code>const char*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">しかし、この演算子の最初の引数は</font></font><code>std::basic_stream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であり、コンパイラは名前空間で適切なオーバーロードを検索して見つけます</font></font><code>std</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部の詳細：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、通常の検索でクラスメンバーの宣言、現在のブロックでuseなしの関数宣言</font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、または関数も関数テンプレートも</font><font style="vertical-align: inherit;">宣言されていない場合は適用されません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">または、関数名が括弧内に示されている場合（上記の例はでコンパイルされないため、</font></font><code>(f)(s)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を記述する必要があります</font></font><code>(N::f)(s);</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
場合によっては、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって、完全に修飾された関数名を使用する必要があるように見えることがあります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、このコードはコンパイルされません</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword">namespace</span> N1<font></font>
{<font></font>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> {</span>};
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(S)</span> </span>{};<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">namespace</span> N2<font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(N1::S)</span> </span>{};
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(N1::S s)</span> </span>{ foo(s); }<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1（英語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2（英語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3（英語）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CRTP</font></font><a name="CRTP"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不思議なことに繰り返し発生するテンプレートパターン。</font><font style="vertical-align: inherit;">奇妙な再帰パターン。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テンプレートの本質は次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部のクラスはテンプレートクラスから継承します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子孫クラスは、その基本クラスのテンプレートパラメータとして使用されます</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を挙げたほうが簡単です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">Base</span> {</span>};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Derived</span> :</span> Base&lt;Derived&gt; {};</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CRTP</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は静的多型の代表的な例です。</font><font style="vertical-align: inherit;">基本クラスはインターフェースを提供し、派生クラスは実装を提供します。</font><font style="vertical-align: inherit;">ただし、通常のポリモーフィズムとは異なり、仮想関数のテーブルを作成して使用するためのオーバーヘッドはありません。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span>
{</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(<span class="hljs-keyword">this</span>)-&gt;actionImpl(); }<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Derived</span> :</span> Base&lt;Derived&gt;<font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">actionImpl</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ ... }<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arg</span>&gt;
<span class="hljs-title">void</span> <span class="hljs-title">staticPolymorphicHandler</span>(<span class="hljs-title">const</span> <span class="hljs-title">Arg</span>&amp; <span class="hljs-title">arg</span>)
{</span><font></font>
    arg.action();<font></font>
}</code></pre><br>
   <code>T</code>    <code>Base</code>,     <code>static_cast</code>. ,        .<br>
</div></div><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CRTP</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
のもう1つの一般的な使用分野は</font><font style="vertical-align: inherit;">、継承されたクラス（一部の言語ではmixinと呼ばれるもの）の機能を拡張（または絞り込み）することです。</font><font style="vertical-align: inherit;">おそらく最も有名な例：</font></font><br>
<br>
<ul>
<li><code>struct Derived : singleton&lt;Derived&gt; { … }</code></li>
<li><code>struct Derived : private boost::noncopyable&lt;Derived&gt; { … }</code></li>
<li><code>struct Derived : std::enable_shared_from_this&lt;Derived&gt; { … }</code></li>
<li><code>struct Derived : counter&lt;Derived&gt; { … }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -作成および/または既存のオブジェクトの数を数える</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
欠点、または注意が必要な瞬間：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共通の基本クラスはありません。異なる子孫のコレクションを作成して、基本型へのポインターを介してそれらにアクセスすることはできません。</font><font style="vertical-align: inherit;">ただし、必要に応じて、通常のポリモーフィック型からBaseを継承できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不注意で自分を撃つ追加の機会があります：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Base</span> {</span>};<font></font>
      <font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Derived1</span> :</span> Base&lt;Derived1&gt; {};
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Derived2</span> :</span> Base&lt;Derived1&gt; {};</code></pre><br>
   : <br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">private</span>:<font></font>
    Base() = <span class="hljs-keyword">default</span>;
    <span class="hljs-keyword">friend</span> T;</code></pre></div></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜなら </font><font style="vertical-align: inherit;">すべてのメソッドは非仮想であるため、下位のメソッドは、同じ名前の基本クラスのメソッドを非表示にします。</font><font style="vertical-align: inherit;">したがって、それらを異なる方法で呼び出すことをお勧めします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般に、子孫には、基本クラス以外の場所で使用すべきでないパブリックメソッドがあります。</font><font style="vertical-align: inherit;">これは良いことではありませんが、追加の抽象化レベルによって修正されます（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FTSEを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照</font><font style="vertical-align: inherit;">）。</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つ（ロシア語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つ（英語）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CTAD</font></font><a name="CTAD"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラステンプレート引数の控除。</font><font style="vertical-align: inherit;">クラステンプレートパラメータのタイプを自動的に推論します。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはC ++ 17の新機能です。</font><font style="vertical-align: inherit;">以前は、唯一の変数の型（</font></font><code>auto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）と関数テンプレートのパラメータが</font><font style="vertical-align: inherit;">自動的に表示された</font><font style="vertical-align: inherit;">タイプの補助機能が生じた理由である、</font></font><code>std::make_pair</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>std::make_tuple</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">およびその上で、コンパイラが自動的に出力クラステンプレートのパラメータにできるので今、ほとんどの部分は、それらが、必要とされていません。：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::pair p{<span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>}; <span class="hljs-comment">// -&gt; std::pair&lt;int, double&gt;</span>
<span class="hljs-keyword">auto</span> lck = <span class="hljs-built_in">std</span>::lock_guard{mtx}; <span class="hljs-comment">// -&gt; std::lock_guard&lt;std::mutex&gt;</span></code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CTAD</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は新しい機会であり、それでも進化し進化</font><i><font style="vertical-align: inherit;">する必要</font></i><font style="vertical-align: inherit;">があります（C ++ 20はすでに改善を約束しています）。</font><font style="vertical-align: inherit;">それまでの間、制限は次のとおりです。</font></font><br>
<br>
<ul>
<li><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータタイプの部分的な出力はサポートされていません</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">double</span>&gt; p{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>}; <span class="hljs-comment">// </span>
<span class="hljs-built_in">std</span>::tuple&lt;&gt; t{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};   <span class="hljs-comment">// </span>
</code></pre></div></div></li>
<li><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テンプレートエイリアスはサポートされていません</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">U</span>&gt;
<span class="hljs-title">using</span> <span class="hljs-title">MyPair</span> = <span class="hljs-title">std</span>:</span>:pair&lt;T, U&gt;;<font></font>
MyPair p{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>}; <span class="hljs-comment">// </span></code></pre></div></div></li>
<li><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テンプレート特殊化でのみ使用可能なコンストラクターはサポートされていません。</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">Wrapper</span> {</span>};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Wrapper</span>&lt;int&gt;
{</span>
  Wrapper(<span class="hljs-keyword">int</span>) {};<font></font>
};<font></font>
Wrapper w{<span class="hljs-number">5</span>}; <span class="hljs-comment">// </span></code></pre></div></div></li>
<li><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネストされたテンプレートはサポートされていません</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">Foo</span>
{</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">U</span>&gt;
    <span class="hljs-title">struct</span> <span class="hljs-title">Bar</span>
    {</span><font></font>
        Bar(T, U) {};<font></font>
    };<font></font>
};<font></font>
Foo::Bar x{ <span class="hljs-number">1</span>, <span class="hljs-number">2.0</span> };    <span class="hljs-comment">// </span>
Foo&lt;<span class="hljs-keyword">int</span>&gt;::Bar x{<span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>}; <span class="hljs-comment">// OK</span></code></pre></div></div></li>
<li><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明らかに、テンプレートパラメータのタイプがコンストラクタの引数に関連していない場合、CTADは機能しません。</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">Collection</span>
{</span>
    Collection(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size) {};<font></font>
};<font></font>
Collection c{<span class="hljs-number">5</span>}; <span class="hljs-comment">// </span></code></pre></div></div></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
場合によっては、クラステンプレートと同じブロックで宣言する必要がある明示的な推論規則が役立ちます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">Collection</span>
{</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">It</span>&gt;
    <span class="hljs-title">Collection</span>(<span class="hljs-title">It</span> <span class="hljs-title">from</span>, <span class="hljs-title">It</span> <span class="hljs-title">to</span>) {</span>};<font></font>
};<font></font>
Collection c{v.begin(), v.end()}; <span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">It</span>&gt;
<span class="hljs-title">Collection</span>(<span class="hljs-title">It</span>, <span class="hljs-title">It</span>)-&gt;<span class="hljs-title">Collection</span>&lt;typename std::iterator_traits&lt;It&gt;::value_type&gt;;</span>
Collection c{v.begin(), v.end()}; <span class="hljs-comment">//  OK</span></code></pre></div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つ（ロシア語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つ（英語）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EBO</font></font><a name="EBO"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空の基本最適化。</font><font style="vertical-align: inherit;">空の基本クラスの最適化。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空の基本クラス最適化（EBCO）とも呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご存知のように、C ++では、クラスのオブジェクトのサイズをゼロにすることはできません。</font><font style="vertical-align: inherit;">そうしないと、1つのアドレスでさまざまなオブジェクトに好きなだけマークを付けることができるため、ポインタのすべての計算が失敗します。</font><font style="vertical-align: inherit;">したがって、空のクラスのオブジェクト（つまり、単一の非静的フィールドのないクラス）でもサイズがゼロではないことがあります。これは、コンパイラとOSに依存し、通常は1です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、メモリは空のクラスのすべてのオブジェクトで無駄に浪費されます。</font><font style="vertical-align: inherit;">ただし、この場合、標準は明示的に例外を作成するため、その子孫のオブジェクトは対象外です。</font><font style="vertical-align: inherit;">コンパイラーは空の基本クラスにメモリを割り当てないように許可されているため、空のクラスの1バイトだけでなく、4つすべて（プラットフォームによって異なります）も節約できます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Empty</span> {</span>};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span> :</span> Empty<font></font>
{<font></font>
    <span class="hljs-keyword">int</span> i;<font></font>
};<font></font>
<font></font>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(Empty) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(Foo) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;      <span class="hljs-comment">// 4</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;      <span class="hljs-comment">// 4</span></code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、同じタイプの異なるオブジェクトを同じアドレスに配置することはできないため、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EBO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は次の場合に機能しません。</font></font><br>
<br>
<ul>
<li><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">祖先の間で空のクラスが2回発生する</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Empty</span> {</span>};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Empty2</span> :</span> Empty {};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span> :</span> Empty, Empty2<font></font>
{<font></font>
  <span class="hljs-keyword">int</span> i;<font></font>
};<font></font>
<font></font>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(Empty) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(Empty2) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;   <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(Foo) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;      <span class="hljs-comment">// 8</span></code></pre></div></div></li>
<li><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の非静的フィールドは、同じ空のクラスまたはその子孫のオブジェクトです</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Empty</span> {</span>};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span> :</span> Empty<font></font>
{<font></font>
    Empty e;<font></font>
    <span class="hljs-keyword">int</span> i;<font></font>
};<font></font>
<font></font>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(Empty) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(Foo) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;      <span class="hljs-comment">// 8</span></code></pre></div></div></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
空のクラスのオブジェクトが非静的フィールドである場合、最適化は提供されません（現時点では、属性はC ++ 20に表示されます</font></font><code>[[no_unique_address]]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">ただし、そのようなフィールドごとに4バイト（またはコンパイラが必要とする量）を費やすのは残念です。そのため、空のクラスのオブジェクトを最初の空でない非静的フィールドで自分で「折りたたむ」ことができます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Empty1</span> {</span>};
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Empty2</span> {</span>};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Member</span>, <span class="hljs-title">class</span> ... <span class="hljs-title">Empty</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">EmptyOptimization</span> :</span> Empty ...<font></font>
{<font></font>
    Member member;<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span>
{</span>
    EmptyOptimization&lt;<span class="hljs-keyword">int</span>, Empty1, Empty2&gt; data;<font></font>
};</code></pre><br>
,      Foo     ,  MSVC 2019  8,  GCC 8.3.0  4.           <code>Foo</code>  .</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：1 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回（英語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2回（英語）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IIFE</font></font><a name="IIFE"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">即座に呼び出される関数式。</font><font style="vertical-align: inherit;">すぐに呼び出される関数式。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般に、これはJavaScriptのイディオムであり、Jason Turnerが名前から借用したものです。</font><font style="vertical-align: inherit;">実際、ラムダを作成してすぐに呼び出すだけです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> myVar = [&amp;] {
    <span class="hljs-keyword">if</span> (condition1())<font></font>
    {<font></font>
        <span class="hljs-keyword">return</span> computeSomeComplexStuff();<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> condition2() ? computeSonethingElse() : DEFAULT_VALUE;<font></font>
} ();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこれが必要なのですか？</font><font style="vertical-align: inherit;">たとえば、上記のコードのように、自明ではない計算の結果によって定数を初期化し、不要な変数や関数でスコープを詰まらせないようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：1 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回（英語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2回（英語）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVI</font></font><a name="NVI"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非仮想インターフェイス。</font><font style="vertical-align: inherit;">非仮想インターフェース。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このイディオムによれば、オープンクラスインターフェイスには仮想関数を含めないでください。</font><font style="vertical-align: inherit;">すべての仮想関数はプライベート（最大保護）にされ、非仮想オープンで呼び出されます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~Base() = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// check precondition</span><font></font>
        fooImpl();<font></font>
        <span class="hljs-comment">// check postconditions</span><font></font>
    }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fooImpl</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base<font></font>
{<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fooImpl</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span>
    </span>{<font></font>
    }<font></font>
};</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこれが必要なのですか？</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開いている各仮想関数は2つのことを行います。クラスのパブリックインターフェイスを定義し、子孫クラスのオーバーライド動作に参加します。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVIを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">すると、そのような関数は二重の負荷で排除されます。インターフェイスは一部の関数によって定義され、他の関数によって動作が変更されます。</font><font style="vertical-align: inherit;">両方を独立して変更できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想関数を実装するためのすべてのオプション（事前チェックと事後チェック、ミューテックスキャプチャなど）にいくつかの一般的な要件がある場合は、それらを1か所（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DRYを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照</font><font style="vertical-align: inherit;">）で</font><font style="vertical-align: inherit;">（</font><font style="vertical-align: inherit;">基本クラスで）</font><font style="vertical-align: inherit;">収集して</font><font style="vertical-align: inherit;">、継承がオーバーライドされないようにするの</font><font style="vertical-align: inherit;">が非常に便利です。</font><font style="vertical-align: inherit;">この動作。</font><font style="vertical-align: inherit;">それら。</font><font style="vertical-align: inherit;">パターンテンプレートメソッドの特別なケースがわかります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVIの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
使用料金</font><font style="vertical-align: inherit;">は、コードの膨らみ、1つの追加のメソッド呼び出しによるパフォーマンスの低下の可能性、および壊れやすい基本クラスの問題に対する感受性の増加（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBCを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照</font><font style="vertical-align: inherit;">）です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：1 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回（英語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2回（英語）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVOおよびNRVO</font></font><a name="RVO"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（名前付き）戻り値の最適化。</font><font style="vertical-align: inherit;">（名前付き）戻り値の最適化。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、規格で許可されているコピー省略の特殊なケースです。コンパイラは、コンストラクタとデストラクタに明らかな副作用がある場合でも、一時オブジェクトの不要なコピーを省略できます。</font><font style="vertical-align: inherit;">このような最適化は、関数が値によってオブジェクトを返す場合に許可されます（コピーの省略で許可される他の2つのケースは、例外のスローとキャッチです）。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function">Foo <span class="hljs-title">bar</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> Foo();<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">auto</span> f = bar();<font></font>
}</code></pre></div></div><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVOを使用し</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ない</font><i><font style="vertical-align: inherit;">場合</font></i><font style="vertical-align: inherit;">、</font></font><code>Foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数の</font><font style="vertical-align: inherit;">一時オブジェクト</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">ここ</font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">作成され</font><font style="vertical-align: inherit;">、コピーコンストラクターを介して関数の別の一時オブジェクトがそこから作成され</font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（結果を取得するため</font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、その後、オブジェクトが作成され</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、2番目の一時オブジェクトの値が割り当てられます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はこれらすべてのコピーと割り当てを取り除き、関数</font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は直接作成し</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはほぼ次のように行われます。関数</font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、そのスタックフレーム内のオブジェクトにスペースを割り当てます</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。関数</font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（そのフレームで既に動作している）は、前のフレームで割り当てられたこのメモリにアクセスし、そこに目的のオブジェクトを作成します。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は同じ最適化を行いますが、式</font></font><code>return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">オブジェクトが作成され</font><font style="vertical-align: inherit;">たときではなく、以前に関数で作成されたオブジェクトが返されたときです。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function">Foo <span class="hljs-title">bar</span><span class="hljs-params">()</span>
</span>{<font></font>
    Foo result;<font></font>
    <span class="hljs-keyword">return</span> result;<font></font>
}</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一見小さな違いにもかかわらず、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVOは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装</font><i><font style="vertical-align: inherit;">が</font></i><font style="vertical-align: inherit;">はるかに難しいため、多くの場合機能しません。</font><font style="vertical-align: inherit;">たとえば、関数がグローバルオブジェクトまたはその引数の1つを返す場合、または関数に複数の出口点があり、それらを介して異なるオブジェクトが返される場合、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は適用されません。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVOはここでは機能しません</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function">Foo <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> condition)</span>
</span>{
    <span class="hljs-keyword">if</span> (condition)<font></font>
    {<font></font>
        Foo f1;<font></font>
        <span class="hljs-keyword">return</span> f1;<font></font>
    }<font></font>
    Foo f2;<font></font>
    <span class="hljs-keyword">return</span> f2;<font></font>
}</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどすべてのコンパイラは、長い間</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVOを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サポートしてい</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のサポートの程度は</font><font style="vertical-align: inherit;">、コンパイラーごと、およびバージョンごとに異なります。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は単なる最適化です。また、コンストラクタと代入演算子のコピーは呼び出されませんが、それらはオブジェクトのクラスに含まれている必要があります。規則はC ++ 17で少し変更されました</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。RVOは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コピーの省略</font><i><font style="vertical-align: inherit;">と</font></i><font style="vertical-align: inherit;">は見なされなくなり、必須になり、対応するコンストラクターと代入演算子は必要なくなりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（N）RVOの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定数項は滑りやすいトピックです。 C ++ 14までは、それについては何も言われていませんでした。C++ 17では</font><font style="vertical-align: inherit;">、そのような式に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">必要</font><font style="vertical-align: inherit;">であり、次のC ++ 20-は禁止されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変位の意味論との関係について一言。</font><font style="vertical-align: inherit;">まず、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（N）RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はさらに効果的です。</font><font style="vertical-align: inherit;">moveコンストラクタとデストラクタを呼び出す必要はありません。</font><font style="vertical-align: inherit;">次に、</font></font><code>result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じ関数から戻る</font><font style="vertical-align: inherit;">代わり</font><font style="vertical-align: inherit;">に</font></font><code>std::move(result)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVOが</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能</font><font style="vertical-align: inherit;">しないこと</font><i><font style="vertical-align: inherit;">が</font></i><font style="vertical-align: inherit;">保証されます。</font><font style="vertical-align: inherit;">標準言い換えするには：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVOは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> prvalueに適用され、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVOが適用さ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左辺値に、</font></font><code>std::move(result)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はxValueです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1（英語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2（英語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3（英語）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font><a name="SFINAE"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">置換の失敗はエラーではありません。</font><font style="vertical-align: inherit;">置換の失敗は間違いではありません。</font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、C ++のテンプレート（関数とクラス）のインスタンス化プロセスの機能です。</font><font style="vertical-align: inherit;">つまり、特定のテンプレートをインスタンス化できない場合、他のオプションがある場合、これはエラーとは見なされません。</font><font style="vertical-align: inherit;">たとえば、最も適切な関数オーバーロードを選択するための単純化されたアルゴリズムは、次のように機能します。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数の名前が解決されます。コンパイラは、指定された名前を持つすべての関数を、考慮されるすべての名前空間で検索します（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADLを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照</font><font style="vertical-align: inherit;">）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不適切な関数は破棄されます-引数の数ではなく、引数の型の必要な変換はありません。関数テンプレートの型を導出することができませんでした。</font></font></li>
<li>         (viable functions),          .           —     .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は2番目のステップで発生します。関数テンプレートのインスタンス化によってオーバーロードが取得されたが、コンパイラーが関数のシグニチャーのタイプを推測できなかった場合、このオーバーロードはエラーとは見なされず、警告なしに破棄されます。</font><font style="vertical-align: inherit;">クラスも同様です。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、たとえば、初期化リストの長さを数えたり、数値のビットを数えたりするなど、さまざまな目的で使用できます。</font><font style="vertical-align: inherit;">しかし、ほとんどの場合、その助けを借りて、リフレクションは少なくともエミュレートされます。つまり、クラスに特定のシグネチャを持つメソッドがあるかどうかが判断されます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;type_traits&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span><font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span>, <span class="hljs-title">class</span> = <span class="hljs-title">void</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">HasToString</span> :</span> <span class="hljs-built_in">std</span>::false_type<font></font>
{};<font></font>
<font></font>
<span class="hljs-comment">//    ,      </span>
<span class="hljs-comment">//   -     , </span>
<span class="hljs-comment">//     —  ,    ,  </span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">HasToString</span>&lt;T, std::void_t&lt;decltype(&amp;T::toString)&gt;&gt;
    :</span> <span class="hljs-built_in">std</span>::is_same&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;T&gt;().toString())&gt;<font></font>
{};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span>
{</span>
    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> {}; }<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; HasToString&lt;Foo&gt;::value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 1</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; HasToString&lt;<span class="hljs-keyword">int</span>&gt;::value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 0</span>
}</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 17で登場したものが</font><i><font style="vertical-align: inherit;">SFINAE</font></i><font style="vertical-align: inherit;">に</font></font><code>static if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取って代わる場合が</font><font style="vertical-align: inherit;">あり、C ++ 20で期待されている概念ではほとんど必要ありません。</font><font style="vertical-align: inherit;">様子を見よう。</font><font style="vertical-align: inherit;">
続きを読む：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">1（ロシア語）</font></a><font style="vertical-align: inherit;">、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">2（英語）</font></a><font style="vertical-align: inherit;">、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">3（英語）</font></a></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SBO、SOO、SSO</font></font><a name="SBO"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小さなバッファ/オブジェクト/文字列の最適化。</font><font style="vertical-align: inherit;">小さなバッファ/オブジェクト/ラインの最適化。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小サイズ最適化の意味で</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSOが使用さ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れることもあり</font><font style="vertical-align: inherit;">ますが、非常にまれであるため、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は文字列に関するものである</font><font style="vertical-align: inherit;">と想定し</font><font style="vertical-align: inherit;">ています。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SBO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は同義語であり、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は最も有名な特殊なケースです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
動的メモリを使用するすべてのデータ構造は、スタック上のある場所も占有します。</font><font style="vertical-align: inherit;">少なくとも束へのポインタを格納するために。</font><font style="vertical-align: inherit;">そして、これらの最適化の本質は、比較的小さなオブジェクト（比較的高価）に対してヒープからメモリを要求することではなく、すでに割り当てられているスタックスペースにそれらを配置することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、std ::文字列は次のように実装できます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">string</span>
{</span>
    <span class="hljs-keyword">char</span>* begin_;
    <span class="hljs-keyword">size_t</span> size_;
    <span class="hljs-keyword">size_t</span> capacity_;<font></font>
};</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このクラスのサイズは24バイトです（コンパイラとプラットフォームによって異なります）。</font><font style="vertical-align: inherit;">それら。</font><font style="vertical-align: inherit;">24文字以下の文字列をスタックに配置できます。</font><font style="vertical-align: inherit;">実際には、スタックへの配置とヒープへの配置を何らかの方法で区別する必要があるため、もちろん24時までです。</font><font style="vertical-align: inherit;">しかし、これが最大8文字の短い行（同じサイズ-24バイト）の最も簡単な方法です。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">string</span>
{</span>
    <span class="hljs-keyword">union</span> Buffer<font></font>
    {<font></font>
        <span class="hljs-keyword">char</span>* begin_;
        <span class="hljs-keyword">char</span> local_[<span class="hljs-number">8</span>];<font></font>
    };<font></font>
<font></font>
    Buffer buffer_;<font></font>
    <span class="hljs-keyword">size_t</span> _size;
    <span class="hljs-keyword">size_t</span> _capacity;<font></font>
};</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒープ上の割り当ての欠如に加えて、別の利点があります-高度なデータ局所性。</font><font style="vertical-align: inherit;">このような最適化されたオブジェクトの配列またはベクトルは、実際には連続したメモリのみを占有します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどすべての実装</font></font><code>std::string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と少なくとも一部の実装を使用してい</font></font><code>std::function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">しかし</font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、この方法で最適化される</font><font style="vertical-align: inherit;">ことは</font><font style="vertical-align: inherit;">決して</font><font style="vertical-align: inherit;">あり</font><font style="vertical-align: inherit;">ません。標準では、</font></font><code>std::swap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つのベクトルの場合、要素のコピーや割り当てが発生せず、すべての有効な反復子が有効である</font><font style="vertical-align: inherit;">必要がある</font><font style="vertical-align: inherit;">ためです。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SBO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はこれらの要件を満たすことを許可しません（満たされ</font></font><code>std::string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ていないため）。</font><font style="vertical-align: inherit;">しかし</font></font><code>boost::container::small_vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ご</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">想像のとおり</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、では</font><i><font style="vertical-align: inherit;">SBOを</font></i><font style="vertical-align: inherit;">使用してい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間（英語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDPATE</font></font><a name="Update"></a></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
感謝 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピェルク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> この略語の追加リストについては。</font></font><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">履歴書</font></font><a name="CV"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constやvolatileなどの修飾子。</font></font></i> <code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクト/変数を変更できないことを意味します。これを実行しようとすると、コンパイル時にエラーになるか、</font><font style="vertical-align: inherit;">実行時</font><font style="vertical-align: inherit;">に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UBに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なります。</font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つまり、オブジェクト/変数はプログラムのアクションに関係なく変化する可能性があり（たとえば、一部のマイクロコントローラーがメモリに何かを書き込むなど）、コンパイラーはそのアクセスを最適化してはなりません。</font><font style="vertical-align: inherit;">リンクまたはポインター</font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を介さないオブジェクト</font><font style="vertical-align: inherit;">へのアクセス</font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UBになり</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1（ロシア語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2（英語）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3（ロシア語）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LTO</font></font><a name="LTO"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンク時間の最適化。</font><font style="vertical-align: inherit;">リンクの最適化。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名前が示すように、この最適化はリンク時、つまりコンパイル後に行われます。</font><font style="vertical-align: inherit;">リンカーは、コンパイラーが敢えてしなかったことを実行できます。一部の関数をインライン化し、未使用のコードとデータを破棄します。</font><font style="vertical-align: inherit;">もちろん、リンク時間が増加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間（英語）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCH</font></font><a name="PCH"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プリコンパイル済みヘッダー。</font><font style="vertical-align: inherit;">プリコンパイル済みヘッダー。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">頻繁に使用されますが、めったに変更されないヘッダーファイルは1回コンパイルされ、内部コンパイラー形式で保存されます。</font><font style="vertical-align: inherit;">したがって、プロジェクトの再組み立てにかかる時間が短くなり、場合によってははるかに少なくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間（rus。）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pgo</font></font><a name="PGO"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロファイルに基づく最適化。</font><font style="vertical-align: inherit;">プロファイリング結果に基づく最適化。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはプログラムの最適化方法ですが、静的コード分析ではなく、テストプログラムの起動と実際の統計の収集を通じて行われます。</font><font style="vertical-align: inherit;">たとえば、この方法で仮想関数の分岐と呼び出しを最適化できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間（rus。）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seh / veh</font></font><a name="SEH"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造化/ベクトル化された例外処理。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、例外とエラー処理のためのMSVC拡張です。</font><font style="vertical-align: inherit;">標準とは異なり</font></font><code>try-catch</code> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEH</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：独自のキーワードを使用して</font></font><code>__try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>__except</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>__finally</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、漁獲量とハンドルが明示的になど、純粋仮想関数を呼び出す、原因無限再帰に例外、無効なメモリスタックオーバーフローへのアクセスのようなものを投げていない... </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VEHを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのエラーを明示的にキャッチするのではなく、エラーハンドラーのグローバルチェーンを作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間（英語）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TMP</font></font><a name="TMP"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テンプレートのメタプログラミング。</font><font style="vertical-align: inherit;">テンプレートのメタプログラミング。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メタプログラミングとは、あるプログラムがその作業の結果として別のプログラムを作成することです。</font><font style="vertical-align: inherit;">C ++のテンプレートは、このようなメタプログラミングを実装しています。</font><font style="vertical-align: inherit;">テンプレートコンパイラは、必要な数のクラスまたは関数を生成します。</font><font style="vertical-align: inherit;">C ++の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TMP</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はチューリング完全であること、つまり、任意の関数</font><font style="vertical-align: inherit;">を</font><i><font style="vertical-align: inherit;">TMP</font></i><font style="vertical-align: inherit;">に実装できることがわかっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間（rus。）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VLA</font></font><a name="VLA"></a></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可変長配列。</font><font style="vertical-align: inherit;">可変長の配列。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それら。</font><font style="vertical-align: inherit;">コンパイル段階で長さが不明な配列：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[n];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++標準ではこれは許可されていません。</font><font style="vertical-align: inherit;">C99標準以降、純粋なCに存在するため、これは少し奇妙です。</font><font style="vertical-align: inherit;">また、一部のC ++コンパイラーによって拡張機能としてサポートされています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間（rus。）</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何かを見逃したり、どこかで間違えられたりした場合は、コメントに書き込んでください。</font><font style="vertical-align: inherit;">ここでは、C ++に直接関連する省略形のみがリストされていることを覚えておいてください。</font><font style="vertical-align: inherit;">他の人にとっては、それほど有用ではありませんが、別の投稿があります。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の第二部</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja470247/index.html">RESHI.RU-ロボットは数学の学校のテキスト問題を解決して説明します</a></li>
<li><a href="../ja470251/index.html">Flutterでデスクトップアプリケーションを実行した方法（+ボーナス）</a></li>
<li><a href="../ja470255/index.html">ALGLIBを使用した債券ポートフォリオの最適化</a></li>
<li><a href="../ja470257/index.html">JavaのImmutableListの周りのスタンピード</a></li>
<li><a href="../ja470259/index.html">Aimybox in search：音声アシスタントを作成するためのフレームワークにはiOSウィザードが必要です</a></li>
<li><a href="../ja470267/index.html">認定温度監視</a></li>
<li><a href="../ja470269/index.html">ReactOS 0.4.12：华、你认认这这？</a></li>
<li><a href="../ja470271/index.html">F＃6：タプル</a></li>
<li><a href="../ja470273/index.html">F＃7：レコード</a></li>
<li><a href="../ja470275/index.html">F＃8：差別的な組合</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>