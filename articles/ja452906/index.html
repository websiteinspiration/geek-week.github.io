<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😝 🖐🏽 👨‍👨‍👧‍👧 JavaScriptエンジン：それらはどのように機能しますか？コールスタックからpromiseまで、（ほとんど）知っておくべきすべてのこと 👱🏿 ☂️ 📴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ブラウザがJavaScriptコードをどのように読み取り、実行するのか疑問に思ったことはありませんか？不思議に見えますが、この投稿では、内部で何が起こっているのかを知ることができます。
 
 私たちは、JavaScriptエンジンの素晴らしい世界への小旅行から言語への旅を始めます。
 
 Chrom...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>JavaScriptエンジン：それらはどのように機能しますか？コールスタックからpromiseまで、（ほとんど）知っておくべきすべてのこと</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/452906/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sd/nm/n6/sdnmn6cuvwusvk4fysdkzvnw9rg.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブラウザがJavaScriptコードをどのように読み取り、実行するのか疑問に思ったことはありませんか？不思議に見えますが、この投稿では、内部で何が起こっているのかを知ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは、JavaScriptエンジンの素晴らしい世界への小旅行から言語への旅を始めます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chromeでコンソールを開き、[ソース]タブに移動します。複数のセクションが表示され、最も興味深いものの1つが</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールスタック</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます（Firefoxでは、コードにブレークポイントを配置するとコールスタックが表示されます）：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d34/46f/a81/d3446fa81bf753ff80d32e39bcf5778c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コールスタックとは何ですか？数行のコードを実行するためであっても、ここでは多くのことが起こっているようです。実際、JavaScriptはすべてのブラウザーに同梱されているわけではありません。 JavaScriptコードをコンパイルして解釈する大きなコンポーネントがあります。それはJavaScriptエンジンです。最も人気のあるのはV8で、Google ChromeとNode.js、FirefoxのSpiderMonkey、Safari / WebKitのJavaScriptCoreで使用されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日のJavaScriptエンジンはソフトウェアエンジニアリングの優れた例であり、すべての側面について話すことは事実上不可能です。</font><font style="vertical-align: inherit;">ただし、コード実行に関する主な作業は、エンジンのいくつかのコンポーネント（コールスタック（コールスタック）、グローバルメモリ（グローバルメモリ）、実行コンテキスト（実行コンテキスト））によってのみ行われます。</font><font style="vertical-align: inherit;">それらに会う準備はできましたか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテンツ：</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScriptエンジンとグローバルメモリ</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScriptエンジン：それらはどのように機能しますか？</font><font style="vertical-align: inherit;">グローバル実行コンテキストと呼び出しスタック</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScriptはシングルスレッドであり、他の楽しいストーリーです</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期JavaScript、コールバックキュー、およびイベントループ</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバック地獄とES6の約束</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript Promiseの作成と使用</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ES6 Promiseでのエラー処理</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ES6 Promiseコンビネーター：Promise.all、Promise.allSettled、Promise.anyなど</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ES6 promiseとマイクロタスクキュー</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScriptエンジン：それらはどのように機能しますか？</font><font style="vertical-align: inherit;">非同期の進化：約束から非同期/待機まで</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScriptエンジン：それらはどのように機能しますか？</font><font style="vertical-align: inherit;">概要</font></font></a><br>
</li>
</ol><br>
<a name="1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. JavaScriptエンジンとグローバルメモリ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptはコンパイルされた言語であり、解釈された言語でもあると私は言いました。</font><font style="vertical-align: inherit;">信じられないかもしれませんが、JavaScriptエンジンは実際にコードが実行される前にマイクロ秒単位でコンパイルします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ある種の魔法ですね </font><font style="vertical-align: inherit;">この魔法はJIT（ジャストインタイムコンパイル）と呼ばれます。</font><font style="vertical-align: inherit;">それだけでも大きな議論の的になるトピックであり、本でさえJITの仕事を説明するには不十分です。</font><font style="vertical-align: inherit;">ただし、ここでは、理論をスキップして、実行フェーズに焦点を当てます。これは、それほど興味深いものではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はじめに、次のコードを見てください。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> num = <span class="hljs-number">2</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">num</span>) </span>{
    <span class="hljs-keyword">return</span> num * num;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードがブラウザでどのように処理されるかを尋ねるとしますか？何に答えますか？ 「ブラウザがコードを読み取る」または「ブラウザがコードを実行する」と言うことができます。実際には、すべてがそれほど単純ではありません。まず、コードはブラウザではなくエンジンによって読み取られます。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScriptエンジンはコードを読み取り、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の行を定義するとすぐに、いくつかのリンクを</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グローバルメモリに配置します</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グローバルメモリ（ヒープとも呼ばれます）は、JavaScriptエンジンが変数と関数宣言を格納する領域です。そして、上記のコードを読み取ると、2つのバインダーがグローバルメモリに表示されます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/11b/0a8/a90/11b0a8a904acef9ee7bde8b84cb76873.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例に変数と関数のみが含まれている場合でも、JavaScriptコードがより大きな環境（ブラウザーまたはNode.js）で実行されることを想像してください。</font><font style="vertical-align: inherit;">そのような環境では、グローバルと呼ばれる多くの定義済み関数と変数があります。</font><font style="vertical-align: inherit;">そのため、グローバルメモリはちょうどよりもはるかに多くのデータが含まれます</font></font><code>num</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>pow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、心に留めておきます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、何も実行されていません。</font><font style="vertical-align: inherit;">次に、関数を実行してみましょう。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> num = <span class="hljs-number">2</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">num</span>) </span>{
    <span class="hljs-keyword">return</span> num * num;<font></font>
}<font></font>
<font></font>
pow(num);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何が起こるか？</font><font style="vertical-align: inherit;">そして興味深いことが起こります。</font><font style="vertical-align: inherit;">関数を呼び出すと、JavaScriptエンジンは2つのセクションを強調表示します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グローバル実行コンテキスト</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出しスタック</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らは何ですか？</font></font><br>
<br>
<a name="2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. JavaScriptエンジン：それらはどのように機能しますか？</font><font style="vertical-align: inherit;">グローバル実行コンテキストと呼び出しスタック</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptエンジンが変数と関数宣言を読み取る方法を学びました。それらはグローバルメモリ（ヒープ）に分類されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、今はJavaScript関数を実行しており、エンジンがこれを処理する必要があります。どうやって？各JavaScriptエンジンには</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コールスタックと呼ばれる主要なコンポーネントがあります</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは積み上げデータ構造</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。上から要素を追加できますが、その上に他の要素がある間は構造から除外できません。これがJavaScript関数の動作方法です。実行時に、別の関数が存在する場合、コールスタックを離れることはできません。この概念は、「JavaScriptはシングルスレッドです」というステートメントの理解に役立つため、これに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、例に戻りましょう。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数が呼び出されると、エンジンはそれを呼び出しスタックに送信します</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b79/118/a43/b79118a430d9daa8af3491138c0cfd2b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は呼び出しスタックをPringlesチップのスタックとして提示するのが好きです。スタックの一番上にあるチップを食べるまで、スタックの一番下からチップを食べることはできません。幸いなことに、私たちの関数は同期的です：それはすぐに計算される乗算です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、エンジンは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グローバル実行コンテキスト</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をメモリ</font><font style="vertical-align: inherit;">に配置</font><font style="vertical-align: inherit;">します</font><font style="vertical-align: inherit;">。これは、JavaScriptコードが実行されるグローバル環境です。これは次のよう</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/ea8/a33/9c1/ea8a339c120638632b57eb0fb3161254.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なものです。グローバルJavaScript関数が魚のように浮かぶ海の形のグローバル実行コンテキストを想像してみてください。かわいいね！しかし、これは話の半分にすぎません。関数にネストされた変数または内部関数がある場合はどうなりますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純なケースでも、以下に示すように、JavaScriptエンジンは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ローカル実行コンテキストを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作成し</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> num = <span class="hljs-number">2</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">num</span>) </span>{
    <span class="hljs-keyword">var</span> fixed = <span class="hljs-number">89</span>;
    <span class="hljs-keyword">return</span> num * num;<font></font>
}<font></font>
<font></font>
pow(num);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数に</font></font><code>pow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数</font><font style="vertical-align: inherit;">を追加したことに注意してください</font></font><code>fixed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この場合、ローカル実行コンテキストにはのセクションが含まれ</font></font><code>fixed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">他の小さな長方形の中に小さな長方形を描くのはあまり得意ではないので、想像力を働かせてください。</font><font style="vertical-align: inherit;">ローカル実行コンテキストが表示されます</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
横に</font></font><code>pow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グローバル実行コンテキストの内側に位置する緑色の矩形部の内部に、。</font><font style="vertical-align: inherit;">ネストされた関数内のネストされた関数ごとに、エンジンが他のローカル実行コンテキストを作成する方法も想像してください。</font><font style="vertical-align: inherit;">これらの長方形のセクションはすべて非常に速く表示されます！</font><font style="vertical-align: inherit;">入れ子人形みたい！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シングルスレッドの話に戻りましょう。</font><font style="vertical-align: inherit;">これは何を意味するのでしょうか？</font></font><br>
<br>
<a name="3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. JavaScriptはシングルスレッドで、その他の楽しいストーリー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは、と言う</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">だけで1コールスタックは、当社の機能を処理しているため、JavaScriptがシングルスレッドです</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。他の関数が実行を予期している場合、関数はコールスタックを離れることができないことを思い出させてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同期コードで作業する場合、これは問題ではありません。たとえば、2つの数値の加算は同期的であり、マイクロ秒単位で計算されます。ネットワークコールや外の世界との他の相互作用についてはどうですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さいわい、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScriptエンジンはデフォルトで非同期で動作するように設計されています</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。一度に1つの機能しか実行できない場合でも、遅いエンティティは外部エンティティ（この場合はブラウザ）で実行できます。これについては以下で説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、ブラウザーが何らかのJavaScriptコードをロードすると、エンジンがこのコードを1行ずつ読み取り、次の手順を実行することを知っています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数と関数宣言をグローバルメモリ（ヒープ）に配置します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出しスタックの各関数に呼び出しを送信します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グローバル関数が実行されるグローバル実行コンテキストを作成します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの小さなローカル実行コンテキストを作成します（内部変数または入れ子関数がある場合）。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、すべてのJavaScriptエンジンの基礎となる同期メカニズムの基本を理解できました。</font><font style="vertical-align: inherit;">次の章では、JavaScriptで非同期コードがどのように機能するか、なぜそれがそのように機能するのかについて説明します。</font></font><br>
<br>
<a name="4"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.非同期JavaScript、コールバックキュー、およびイベントループ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グローバルメモリ、実行コンテキスト、およびコールスタックのおかげで、ブラウザーで同期JavaScriptコードが実行されます。しかし、私たちは何かを忘れました。非同期関数を実行する必要がある場合はどうなりますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期関数とは、完了するまでに時間がかかる可能性のある、外界とのすべてのやり取りを意味します。 REST APIまたはタイマーの呼び出しは、実行に数秒かかる可能性があるため、非同期です。エンジンで利用可能な要素のおかげで、コールスタックとブラウザをブロックすることなく、そのような関数を処理できます。忘れないでください。コールスタックは一度に1つの関数しか実行できず、1 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つのブロッキング関数でも文字通りブラウザを停止できます。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。幸いなことに、JavaScriptエンジンは「スマート」であり、ブラウザーからの少しの助けで、物事を整理することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期関数を実行すると、ブラウザーがそれを受け取って実行します。次のようなタイマーを取ります：</font></font><br>
<br>
<pre><code class="javascript hljs">setTimeout(callback, <span class="hljs-number">10000</span>);<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello timer!'</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><code>setTimeout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すでに何百回も</font><font style="vertical-align: inherit;">
見た</font><font style="vertical-align: inherit;">ことがあると思いますが、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この関数がJavaScriptに組み込まれていない</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことはご存じないかもしれません</font><font style="vertical-align: inherit;">。そのため、JavaScriptが登場したとき、その中に関数はありませんでした</font></font><code>setTimeout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。実際、これはいわゆるブラウザAPIの一部であり、ブラウザが提供する便利なツールのコレクションです。素晴らしい！しかし、これは実際にはどういう意味ですか？これ</font></font><code>setTimeout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はブラウザAPIを参照している</font><font style="vertical-align: inherit;">ため</font><font style="vertical-align: inherit;">、この関数はブラウザ自体によって実行されます（しばらくの間、コールスタックに表示されますが、そこからすぐに削除されます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10秒後、ブラウザーは渡されたコールバック関数を受け取り、それを</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバックキューに</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入れ</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。現時点では、さらに2つの長方形セクションがJavaScriptエンジンに表示されています。このコードを見てください：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> num = <span class="hljs-number">2</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">num</span>) </span>{
    <span class="hljs-keyword">return</span> num * num;<font></font>
}<font></font>
<font></font>
pow(num);<font></font>
<font></font>
setTimeout(callback, <span class="hljs-number">10000</span>);<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello timer!'</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スキームは次のようになり</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/00f/8e2/b33/00f8e2b33a47490117a9e8f6abad23f5.png"><br>
<br>
<code>setTimeout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。ブラウザコンテキスト内で実行されます。 10秒後、タイマーが開始され、コールバック関数を実行する準備が整います。ただし、最初に、コールバックキューを通過する必要があります。これはキューの形式のデータ構造であり、その名前が示すように、機能の順序付けされたキューです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各非同期関数は、コールスタックに到達する前にコールバックキューを通過する必要があります。しかし、次に関数を送信するのは誰ですか？これにより</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、イベントループ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれるコンポーネントが作成され</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでのところ、イベントループは1つだけ処理します。コールスタックが空かどうかを確認します。コールバックキューに関数があり、コールスタックが空いている場合は、コールスタックにコールバックを送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、関数は実行されたと見なされます。これは、JavaScriptエンジンで非同期および同期コードを処理するための一般的なスキームです</font><font style="vertical-align: inherit;">。実行の準備ができて</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/eba/ec9/fec/ebaec9fec5dc1931176371fd4a9f3cbd.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いる</font></font><code>callback()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とし</font><font style="vertical-align: inherit;">ましょう</font><font style="vertical-align: inherit;">。実行が完了すると</font></font><code>pow()</code> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コールスタックが解放され、イベントループがそれに送信します</font></font></b> <code>callback()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。以上です！少し簡略化しましたが、上の図を理解すれば、すべてのJavaScriptを理解できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
覚えておいてください：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブラウザベースのAPI、コールバックキュー、およびイベントループは、非同期JavaScriptの柱です</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味があれば、フィリップロバーツの「イベントループは一体何なのか」という興味深いビデオを見ることができます。これは、イベントループの最も良い説明の1つです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、非同期のJavaScriptテーマはまだ完了していません。次の章では、ES6の約束を見ていきます。</font></font><br>
<br>
<a name="5"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.コールバック地獄とES6の約束</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コールバック関数は、同期コードと非同期コードの両方で、JavaScriptのあらゆる場所で使用されます。</font><font style="vertical-align: inherit;">この方法を検討してください：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapper</span>(<span class="hljs-params">element</span>)</span>{
    <span class="hljs-keyword">return</span> element * <span class="hljs-number">2</span>;<font></font>
}<font></font>
<font></font>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].map(mapper);
</code></pre><br>
<code>mapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部で渡されるコールバック関数です</font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">上記のコードは同期です。</font><font style="vertical-align: inherit;">次に、この間隔を考えます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runMeEvery</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Ran!'</span>);<font></font>
}<font></font>
<font></font>
setInterval(runMeEvery, <span class="hljs-number">5000</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部で</font></font><code>setInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はコールバックを渡す</font><font style="vertical-align: inherit;">ため、このコードは非同期</font></font><code>runMeEvery</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。コールバックはJavaScript全体で使用されるため、長年にわたって「コールバック地獄」-「コールバック地獄」と呼ばれる問題がありました。</font><font style="vertical-align: inherit;">JavaScriptの</font><b><font style="vertical-align: inherit;">コールバック地獄</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
という用語</font><font style="vertical-align: inherit;">は、プログラミングの「スタイル」に適用されます</font><font style="vertical-align: inherit;">。この</font><font style="vertical-align: inherit;">スタイルでは、コールバックは、他のコールバックに埋め込まれている他のコールバックに埋め込まれています。</font><font style="vertical-align: inherit;">
正直なところ、コールバックの大きなピラミッドを作成したことはありません。おそらく、私は可読コードを重視し、常にその原則を守ろうとしているためです。コールバック地獄にぶつかった場合、それはあなたの関数がやりすぎていることを意味します。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コールバック地獄については詳しく説明しません。興味がある場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">callbackhell.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">アクセスしてください</font><font style="vertical-align: inherit;">。この問題は詳細に調査されており、さまざまな解決策が提案されています。そして、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ES6の約束</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">についてお話します</font><font style="vertical-align: inherit;">。これは地獄のコールバック問題を解決するために設計されたJavaScriptアドオンです。しかし、約束は何ですか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScriptのpromiseは、将来のイベントを表しています</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。約束は成功するかもしれません、またはプログラマの専門用語では、約束は「解決」されます。しかし、約束がエラーで終わった場合、それは拒否された状態にあると言います。プロミスにはデフォルトの状態もあります。新しいプロミスはそれぞれ保留状態で始まります。自分の約束をすることはできますか？はい。これについては、次の章で説明します。</font></font><br>
<br>
<a name="6"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. JavaScript promiseの作成と操作</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいpromiseを作成するには、コールバック関数を渡してコンストラクターを呼び出す必要があります。</font><font style="vertical-align: inherit;">2つのパラメーターのみを取ることができます：</font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">5秒で解決される新しいプロミスを作成しましょう（ブラウザーコンソールで例をテストできます）。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>)</span>{<font></font>
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<font></font>
        resolve()<font></font>
    }, <span class="hljs-number">5000</span>)<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、</font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはpromiseが正常に終了するために呼び出す関数です。</font><font style="vertical-align: inherit;">そして、それ</font></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は拒否された約束を作成します：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span>{<font></font>
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<font></font>
        reject()<font></font>
    }, <span class="hljs-number">5000</span>)<font></font>
});</code></pre><br><font style="vertical-align: inherit;"></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目のパラメーターであるため、</font><font style="vertical-align: inherit;">
無視し</font><font style="vertical-align: inherit;">て</font><font style="vertical-align: inherit;">かまいません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">しかし、それを使用するつもりなら</font></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を無視することはできません</font></font><code>resolve</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">つまり、次のコードは機能せず、許可されたプロミスで終了します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// Can't omit resolve !</span><font></font>
<font></font>
<span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reject</span>)</span>{<font></font>
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<font></font>
        reject()<font></font>
    }, <span class="hljs-number">5000</span>)<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
約束は今のところあまり役に立たないようですよね？</font><font style="vertical-align: inherit;">これらの例では、ユーザーには何も表示されません。</font><font style="vertical-align: inherit;">何か追加しましょう。</font><font style="vertical-align: inherit;">許可され、拒否されたpromiseはデータを返すことができます。</font><font style="vertical-align: inherit;">例えば：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>{<font></font>
  resolve([{ <span class="hljs-attr">name</span>: <span class="hljs-string">"Chris"</span> }]);<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、まだ何も見えません。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">promiseからデータを抽出するには、promiseをmethodに関連付ける必要があります</font></font><code>then</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">彼はコールバックを受け取り（なんと皮肉なことです！）、現在のデータを受け取ります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{<font></font>
  resolve([{ <span class="hljs-attr">name</span>: <span class="hljs-string">"Chris"</span> }]);<font></font>
});<font></font>
<font></font>
myPromise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{
    <span class="hljs-built_in">console</span>.log(data);<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptの開発者であり、他の誰かのコードの利用者である場合、主に外部のプロミスとやり取りします。</font><font style="vertical-align: inherit;">ライブラリの作成者は、ほとんどの場合、次のようにレガシーコードをPromiseコンストラクターでラップします。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> shinyNewUtil = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
  <span class="hljs-comment">// do stuff and resolve</span>
  <span class="hljs-comment">// or reject</span>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、必要に応じて、次を呼び出してプロミスを作成して解決することもできます</font></font><code>Promise.resolve()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">Promise</span>.resolve({ <span class="hljs-attr">msg</span>: <span class="hljs-string">'Resolve!'</span>})<font></font>
.then(<span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(msg));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptのプロミスは、将来発生するイベントのブックマークです。</font><font style="vertical-align: inherit;">イベントは「決定待ち」状態で始まり、成功（許可、実行）または失敗（拒否）することができます。</font><font style="vertical-align: inherit;">promiseはpromiseにアタッチすることで取得できるデータを返すことができます</font></font><code>then</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次の章では、約束から生じるエラーに対処する方法について説明します。</font></font><br>
<br>
<a name="7"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. ES6 Promiseでのエラー処理</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptでのエラー処理は、少なくとも同期コードでは常に簡単でした。</font><font style="vertical-align: inherit;">例を見てみましょう：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeAnError</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Sorry mate!"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">try</span> {<font></font>
  makeAnError();<font></font>
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Catching the error! "</span> + error);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果は次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs">Catching the error! <span class="hljs-built_in">Error</span>: Sorry mate!</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
予想通り、エラーはブロックに分類されました</font></font><code>catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次に、非同期関数を試してください。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeAnError</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Sorry mate!"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">try</span> {<font></font>
  setTimeout(makeAnError, <span class="hljs-number">5000</span>);<font></font>
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Catching the error! "</span> + error);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
のため、このコードは非同期です</font></font><code>setTimeout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">実行するとどうなりますか？</font></font><br>
<br>
<pre><code class="javascript hljs"> <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Sorry mate!"</span>);<font></font>
  ^<font></font>
<font></font>
<span class="hljs-built_in">Error</span>: Sorry mate!<font></font>
    at Timeout.makeAnError [<span class="hljs-keyword">as</span> _onTimeout] (<span class="hljs-regexp">/home/</span>valentino/Code/piccolo-javascript/<span class="hljs-keyword">async</span>.js:<span class="hljs-number">2</span>:<span class="hljs-number">9</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今、結果は異なります。</font><font style="vertical-align: inherit;">エラーはブロックによってキャッチされませんでしたが</font></font><code>catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、スタックを自由に立ち上げました。</font><font style="vertical-align: inherit;">その理由は、</font></font><code>try/catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期コード</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">のみ機能する</font><font style="vertical-align: inherit;">ためです</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">詳細を知りたい場合は、この問題について</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で詳しく説明し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸い、promiseがあれば、同期エラーのように非同期エラーを処理できます。</font><font style="vertical-align: inherit;">前の章で、挑戦</font></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は約束の拒否につながる</font><font style="vertical-align: inherit;">と私は言った</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{<font></font>
  reject(<span class="hljs-string">'Errored, sorry!'</span>);<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、</font></font><code>catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバックを（再び）プルすることにより</font><font style="vertical-align: inherit;">、ハンドラーを使用してエラーを処理でき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{<font></font>
  reject(<span class="hljs-string">'Errored, sorry!'</span>);<font></font>
});<font></font>
<font></font>
myPromise.catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、適切な場所でプロミスを作成して拒否するには、次を呼び出します</font></font><code>Promise.reject()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">Promise</span>.reject({<span class="hljs-attr">msg</span>: <span class="hljs-string">'Rejected!'</span>}).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
思い出させてください：ハンドラー</font></font><code>then</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はpromiseが実行されたときに実行され、ハンドラー</font></font><code>catch </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は拒否</font><font style="vertical-align: inherit;">されたpromise </font><font style="vertical-align: inherit;">に対して実行されます。</font><font style="vertical-align: inherit;">しかし、これで話は終わりではありません。</font><font style="vertical-align: inherit;">以下では</font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それらが</font><font style="vertical-align: inherit;">どのように機能するかについて説明</font><font style="vertical-align: inherit;">し</font></font><code>try/catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<a name="8"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. ES6の約束の組み合わせ：Promise.all、Promise.allSettled、Promise.anyなど</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロミスは単独で機能するようには設計されていません。 Promise APIは、promiseを</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">組み合わせる</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ためのいくつかのメソッドを提供します</font><font style="vertical-align: inherit;">。最も有用なものの1つ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はPromise.allで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、promiseから配列を取り、1つのpromiseを返します。唯一の問題は、配列内の少なくとも1つのpromiseが拒否された場合にPromise.allが拒否されることです。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.race</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、配列内の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">promiseの</font></a><font style="vertical-align: inherit;"> 1つが対応するステータスを受け取るとすぐに許可または拒否します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V8の最近のバージョンでは、2つの新しいコンビネーターも導入されます：</font></font><code>Promise.allSettled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><code>Promise.any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.any</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は提案された機能の初期段階にまだあり、この記事の執筆時点ではサポートされていません。ただし、理論的には、約束が履行されたかどうかを示すことができます。とは異なり</font></font><code>Promise.race</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">約束の1つが拒​​否されたとしても、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その</font><b><font style="vertical-align: inherit;">Promise.anyは拒否されません</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br>
<code>Promise.allSettled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さらに興味深い。</font><font style="vertical-align: inherit;">彼はまた、さまざまな約束をしますが、約束の1つが拒​​否されても「短縮」しません。</font><font style="vertical-align: inherit;">拒否されたプロミスの存在に関係なく、配列内のすべてのプロミスがいくつかのステージに渡されたかどうかを確認する必要がある場合に役立ちます。</font><font style="vertical-align: inherit;">それは反対であると考えることができます</font></font><code>Promise.all</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="9"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9. ES6の約束とマイクロタスクキュー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前の章を覚えているとしたら、JavaScriptの各非同期コールバック関数は、コールスタックに到達する前にコールバックキューにあります。</font><font style="vertical-align: inherit;">しかし、promiseに渡されるコールバック関数は、運命が異なります。それらは、タスクキューではなくマイクロタスクキューによって処理されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで注意が必要です。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイクロタスクキューは呼び出しキューの前にあります</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">マイクロタスクキューからのコールバックは、新しいコールバックがコールスタックに進む準備ができているかどうかをイベントループがチェックするときに優先されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメカニズムについては、Jake Archibaldが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスク、マイクロタスク、キュー、スケジュール</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について詳しく説明してい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="10"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10. JavaScriptエンジン：それらはどのように機能しますか？</font><font style="vertical-align: inherit;">非同期の進化：約束から非同期/待機まで</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptは急速に進化しており、毎年改善が続けられています。 PROMISは最終版のように見えましたが</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、新しい構文であるECMAScript 2017（ES8）を使用しました</font></font><code>async/await</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-単なる文体の改善で、これを構文糖と呼びます。</font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScriptが変更されることはありません（この言語は古いブラウザとの下位互換性があり、既存のコードを壊さないことを忘れないでください）。これは、promiseに基づいて非同期コードを記述する新しい方法にすぎません。例を考えてみましょう。上記では、対応するものに約束をすでに保存してい</font></font><code>then</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{<font></font>
  resolve([{ <span class="hljs-attr">name</span>: <span class="hljs-string">"Chris"</span> }]);<font></font>
});<font></font>
<font></font>
myPromise.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(data))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、ヘルプ</font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して非同期コードを処理できるため、リストの読者にとってコードが同期的に見えるようになります</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これを適用する代わりに</font></font><code>then</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、promiseを</font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">マークされた関数でラップすることができ</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、結果</font><font style="vertical-align: inherit;">は（</font><font style="vertical-align: inherit;">）になります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{<font></font>
  resolve([{ <span class="hljs-attr">name</span>: <span class="hljs-string">"Chris"</span> }]);<font></font>
});<font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> myPromise;
  <span class="hljs-built_in">console</span>.log(data);<font></font>
}<font></font>
<font></font>
getData();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
健康そうですね </font><font style="vertical-align: inherit;">不思議なことに、非同期関数は常にpromiseを返し、誰もこれをやめることができません。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> myPromise;
  <span class="hljs-keyword">return</span> data;<font></font>
}<font></font>
<font></font>
getData().then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(data));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
間違いはどうですか？</font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この設計の</font><font style="vertical-align: inherit;">利点の1つ</font><font style="vertical-align: inherit;">は、この設計を利用できること</font></font><code><b>try/catch</b></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期関数のエラー処理とそのテストの概要を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読んでください</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハンドラーでエラーを処理するpromiseをもう一度見てみましょう</font></font><code>catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{<font></font>
  reject(<span class="hljs-string">'Errored, sorry!'</span>);<font></font>
});<font></font>
<font></font>
myPromise.catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期関数を使用すると、次のようにリファクタリングできます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> myPromise;
    <span class="hljs-built_in">console</span>.log(data);
    <span class="hljs-comment">// or return the data with return data</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-built_in">console</span>.log(error);<font></font>
  }<font></font>
}<font></font>
<font></font>
getData();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、誰もがこのスタイルに切り替えたわけではありません。</font></font><code>try/catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードが複雑になる場合があります。</font><font style="vertical-align: inherit;">考慮すべきことがもう1つあります。</font><font style="vertical-align: inherit;">このコードのこのブロック内でエラーがどのように発生するかを確認してください</font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Catch me if you can"</span>);<font></font>
    }<font></font>
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-built_in">console</span>.log(err.message);<font></font>
  }<font></font>
}<font></font>
<font></font>
getData()<font></font>
  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"I will run no matter what!"</span>))<font></font>
  .catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Catching err"</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンソールに表示される2行はどうですか？</font><font style="vertical-align: inherit;">これ</font></font><b><code>try/catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は同期構造であり、非同期関数はpromiseを生成する</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことを忘れないでください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">彼らは電車のように2つの異なる道を歩きます。</font><font style="vertical-align: inherit;">しかし、彼らは決して会うことはありません！</font><font style="vertical-align: inherit;">したがって、発生したエラー</font></font><code>throw</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によってのハンドラ</font></font><code>catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">アクティブになる</font><font style="vertical-align: inherit;">ことはあり</font><font style="vertical-align: inherit;">ません</font></font><code>getData()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このコードを実行すると、最初に「できれば捕まえてください」という表記が表示され、次に「何があっても実行します！」という表記が表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、</font></font><code>throw</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行</font><font style="vertical-align: inherit;">するための</font><font style="vertical-align: inherit;">ハンドラ</font><font style="vertical-align: inherit;">は必要ありません</font></font><code>then</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、たとえば</font></font><code>Promise.reject()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数から</font><font style="vertical-align: inherit;">戻ることで解決できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">"Catch me if you can"</span>);<font></font>
    }<font></font>
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-built_in">console</span>.log(err.message);<font></font>
  }<font></font>
}<font></font>
Now the error will be handled <span class="hljs-keyword">as</span> expected:<font></font>
getData()<font></font>
  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"I will NOT run no matter what!"</span>))<font></font>
  .catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Catching err"</span>));<font></font>
<font></font>
<span class="hljs-string">"Catching err"</span> <span class="hljs-comment">// output</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それ以外は、</font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScriptで非同期コードを構造化する最良の方法のように見えます。</font><font style="vertical-align: inherit;">エラー処理をより適切に処理し、コードがよりきれいに見えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いずれにしても、すべてのJSコードをにリファクタリングすることはお勧めしません</font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これについてチームと話し合ってください。</font><font style="vertical-align: inherit;">しかし、あなたが独立して仕事をしているのであれば、純粋な約束の間の選択</font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は好みの問題にすぎません。</font></font><br>
<br>
<a name="11"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11. JavaScriptエンジン：それらはどのように機能しますか？</font><font style="vertical-align: inherit;">概要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptはWeb用のスクリプト言語であり、最初にコンパイルされ、次にエンジンによって解釈されます。最も人気のあるJSエンジン：V8、Google ChromeとNode.jsで使用。 SpiderMonkey、Firefox用に開発。 Safariで使用されるJavaScriptCore。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptエンジンには、コールスタック、グローバルメモリ、イベントループ、コールバックキューなど、多くの「動く」部分があります。これらのパーツはすべて完全に連携して動作し、同期および非同期のコード処理を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptエンジンはシングルスレッドです。つまり、単一のコールスタックを使用して関数を実行します。この制限はJavaScriptの非同期の性質の根底にあります。完了するまでに時間がかかるすべての操作は、外部エンティティ（ブラウザなど）またはコールバック関数によって制御する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期コードの作業を簡略化するために、ECMAScript 2015でpromiseが導入されました。</font><font style="vertical-align: inherit;">promiseは、非同期操作の成功または失敗を表すために使用される非同期オブジェクトです。</font><font style="vertical-align: inherit;">しかし、改善はそこで止まりませんでした。</font><font style="vertical-align: inherit;">2017年に登場しました</font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：promiseのスタイルの改善により、非同期コードを同期のように書くことができます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja452890/index.html">5月23日18時30分-QIWIキッチンの生放送</a></li>
<li><a href="../ja452892/index.html">プログラマーではない人がアメリカに移住する方法：ステップバイステップの説明</a></li>
<li><a href="../ja452894/index.html">顔のなりすましまたは技術的に千人の顔から詐欺師を認識する</a></li>
<li><a href="../ja452902/index.html">プログラマーとしての4年間のトレーニングを終了し、プログラマーとはかけ離れていることを理解しています</a></li>
<li><a href="../ja452904/index.html">マシンの通信方法-MQTTプロトコル</a></li>
<li><a href="../ja452908/index.html">Selenium WebDriver-GrafanaとInfluxDBを使用したリアルタイムテスト指標</a></li>
<li><a href="../ja452910/index.html">こんにちは、ハブル！こんにちはテルコン</a></li>
<li><a href="../ja452914/index.html">実験を恐れない人のための、ScalaでのMLの笑顔</a></li>
<li><a href="../ja452916/index.html">立ち上がって行きます。脊椎手術：いつ行うべきか、何が危険か</a></li>
<li><a href="../ja452922/index.html">柔軟なCSSグリッドテーブル</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>