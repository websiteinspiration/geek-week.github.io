<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎂 🐘 👩🏼‍💻 魔鬼十二中有多少新东西？ 👝 💬 ⏮️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们仅谈论PostgreSQL13。4月8日，发生了“冻结”事件-PostgreSQL 功能冻结，现在只有该日期之前接受的那些功能才包含在该版本中。
 
 很难说出这种革命性的版本。它没有任何主要的，概念上的变化。另外，我也想在PG12中的JSONPath补丁旁边看到诸如JSON / SQL标准的表...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>魔鬼十二中有多少新东西？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/493106/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们仅谈论PostgreSQL13。4月8日，发生了“冻结”事件-PostgreSQL </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">功能冻结</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，现在只有该日期之前接受的那些功能才包含在该版本中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
很难说出这种革命性的版本。</font><font style="vertical-align: inherit;">它没有任何主要的，概念上的变化。</font><font style="vertical-align: inherit;">另外，我也想在PG12中的JSONPath补丁旁边看到诸如JSON / SQL标准的表和函数之类的重要补丁，没有时间输入它。</font><font style="vertical-align: inherit;">现成的嵌入式存储没有出现-只有接口正在最终确定。</font><font style="vertical-align: inherit;">但是改进的清单仍然令人印象深刻。</font><font style="vertical-align: inherit;">我们已经对Devil's Dozen中包含的补丁程序做了一个相当完整的摘要。</font></font></i><br>
<br>
<hr><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对SQL命令的更改</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CREATE DATABASE ... LOCALE</font></font></b></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
实用程序</font></font><code>initdb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>createdb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且团队</font></font><code>CREATE COLLATION</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有一个设置</font></font><code>LOCALE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，可让您指定right</font></font><code>LC_CTYPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和的</font><font style="vertical-align: inherit;">值</font></font><code>LC_COLLATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">现在，团队中出现了相同的机会</font></font><code>CREATE DATABASE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> db_koi8r <span class="hljs-keyword">TEMPLATE</span> template0 
    <span class="hljs-keyword">ENCODING</span> <span class="hljs-string">'KOI8R'</span> LOCALE <span class="hljs-string">'ru_RU.KOI8R'</span>;</code></pre><a name="habracut"></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ALTER VIEW ... RENAME COLUMN</font></font></b></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
现在可以使用命令更改视图中的列名</font></font><code>ALTER VIEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">以前，这需要重新创建视图。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设您忘了给列命名：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> uptime <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">current_timestamp</span>, <span class="hljs-built_in">current_timestamp</span> - pg_postmaster_start_time();
<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> uptime;</code></pre><br>
<pre><code class="plaintext hljs">       current_timestamp       |    ?column?     <font></font>
-------------------------------+-----------------<font></font>
 2020-03-23 15:37:00.088824+03 | 04:18:24.897856</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以解决：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">VIEW</span> uptime <span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">COLUMN</span> "?column?" <span class="hljs-keyword">TO</span> uptime;
<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> uptime;</code></pre><br>
<pre><code class="plaintext hljs">       current_timestamp       |     uptime      <font></font>
-------------------------------+-----------------<font></font>
 2020-03-23 15:37:40.726516+03 | 04:19:05.535548</code></pre><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ALTER TABLE ... ALTER COLUMN ... DROP EXPRESSION</font></font></b></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
现在可以使表的生成</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;">列为</font></b></a><font style="vertical-align: inherit;">普通列，即删除表达式以对其求值：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> payments (<font></font>
    id <span class="hljs-type">integer</span> <span class="hljs-keyword">PRIMARY KEY</span>,<font></font>
    amount <span class="hljs-type">numeric</span>(<span class="hljs-number">18</span>,<span class="hljs-number">2</span>),<font></font>
    income_tax <span class="hljs-type">numeric</span>(<span class="hljs-number">18</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">GENERATED</span> <span class="hljs-keyword">ALWAYS</span> <span class="hljs-keyword">AS</span> (amount*<span class="hljs-number">0.13</span>) STORED<font></font>
);<font></font>
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> payments(id, amount) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-number">42</span>);<font></font>
\d payments</code></pre><br>
<pre><code class="plaintext hljs">                                     Table "public.payments"<font></font>
   Column   |     Type      | Collation | Nullable |                   Default            <font></font>
        <font></font>
------------+---------------+-----------+----------+--------------------------------------<font></font>
 id         | integer       |           | not null |<font></font>
 amount     | numeric(18,2) |           |          |<font></font>
 income_tax | numeric(18,2) |           |          | generated always as ((amount * 0.13))<font></font>
 stored<font></font>
Indexes:<font></font>
    "payments_pkey" PRIMARY KEY, btree (id)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
随后，他们决定应明确设置Income_tax。</font><font style="vertical-align: inherit;">删除表达式：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> payments <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> income_tax <span class="hljs-keyword">DROP</span> EXPRESSION;<font></font>
\d payments</code></pre><br>
<pre><code class="plaintext hljs">                   Table "public.payments"<font></font>
   Column   |     Type      | Collation | Nullable | Default<font></font>
------------+---------------+-----------+----------+---------<font></font>
 id         | integer       |           | not null |<font></font>
 amount     | numeric(18,2) |           |          |<font></font>
 income_tax | numeric(18,2) |           |          |<font></font>
Indexes:<font></font>
    "payments_pkey" PRIMARY KEY, btree (id)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，该列中的现有数据并没有消失：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> payments;</code></pre><br>
<pre><code class="plaintext hljs"> id | amount | income_tax<font></font>
----+--------+------------<font></font>
  1 |  42.00 |       5.46</code></pre><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DROP DATABASE ... FORCE</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
如果要删除数据库而不等待所有用户断开连接，则可以使用new</font></font><code>FORCE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">选项</font></font><code>DROP DATABASE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> db;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
连接到新数据库：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> dblink;
<span class="hljs-keyword">SELECT</span> dblink_connect(<span class="hljs-string">'dbname=db'</span>);</code></pre><br>
<pre><code class="plaintext hljs"> dblink_connect<font></font>
----------------<font></font>
 OK</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们将删除并强制中断</font></font><code>pg_terminate_backend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">打开的连接：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">DATABASE</span> db <span class="hljs-keyword">WITH</span> (FORCE);</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ALTER TYPE ... SET STORAGE</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
该命令</font></font><code>ALTER TYPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许基本数据类型更改各种属性，尤其是存储策略。</font><font style="vertical-align: inherit;">以前，您只能将其设置为一个团队</font></font><code>CREATE TYPE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了演示，我们不会创建新的基本类型，而是使用现有的-</font></font><code>tsquery</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但首先，创建一个单独的数据库并连接到它：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> db;<font></font>
\c db</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tsquery数据类型使用存储策略</font></font><code>plain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此此类型的表的列将获得相同的策略：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> typname,typstorage <span class="hljs-keyword">FROM</span> pg_type <span class="hljs-keyword">WHERE</span> typname = <span class="hljs-string">'tsquery'</span>;</code></pre><br>
<pre><code class="plaintext hljs"> typname | typstorage<font></font>
---------+------------<font></font>
 tsquery | p</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> queries (query <span class="hljs-type">tsquery</span>);
<span class="hljs-keyword">SELECT</span> attname, attstorage <span class="hljs-keyword">FROM</span> pg_attribute <span class="hljs-keyword">WHERE</span> attrelid = <span class="hljs-string">'queries'</span>::<span class="hljs-type">regclass</span> <span class="hljs-keyword">AND</span> attname = <span class="hljs-string">'query'</span>;</code></pre><br>
<pre><code class="plaintext hljs"> attname | attstorage<font></font>
---------+------------<font></font>
 query   | p</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果需要对新表使用其他策略，则可以更改基本类型：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TYPE</span> <span class="hljs-type">tsquery</span> <span class="hljs-keyword">SET</span> (storage=<span class="hljs-keyword">external</span>);
<span class="hljs-keyword">SELECT</span> typname,typstorage <span class="hljs-keyword">FROM</span> pg_type <span class="hljs-keyword">WHERE</span> typname = <span class="hljs-string">'tsquery'</span>;</code></pre><br>
<pre><code class="plaintext hljs"> typname | typstorage<font></font>
---------+------------<font></font>
 tsquery | e</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新表中的存储类型也将更改：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> new_queries (query <span class="hljs-type">tsquery</span>);
<span class="hljs-keyword">SELECT</span> attname, attstorage <span class="hljs-keyword">FROM</span> pg_attribute <span class="hljs-keyword">WHERE</span> attrelid = <span class="hljs-string">'new_queries'</span>::<span class="hljs-type">regclass</span> <span class="hljs-keyword">AND</span> attname = <span class="hljs-string">'query'</span>;</code></pre><br>
<pre><code class="plaintext hljs"> attname | attstorage<font></font>
---------+------------<font></font>
 query   | e</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
应当牢记，更改涉及使用TOAST的策略</font></font><code>plain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不能</font><font style="vertical-align: inherit;">更改为</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TYPE</span> <span class="hljs-type">tsquery</span> <span class="hljs-keyword">SET</span> (storage=plain);</code></pre><br>
<pre><code class="plaintext hljs">ERROR:  cannot change type's storage to PLAIN</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，实验是在一个单独的数据库中进行的，因此不能删除。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ALTER STATISTICS ... SET STATISTICS该</font></font></b></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
命令</font></font><code>CREATE STATISTICS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许您为表列的选定组合收集最常用值的列表。</font><font style="vertical-align: inherit;">收集的最常见值的数量由参数确定</font></font><code>default_statistics_target</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">现在可以使用以下命令更改特定统计信息的值：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">STATISTICS</span>  <span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> _;</code></pre><br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用WITH TIES选项先抓取</font></font></a></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
如您所知</font></font><code>SELECT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>LIMIT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以使用SQL标准中定义的语法来</font><font style="vertical-align: inherit;">代替指定</font><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> *
<span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-string">'1.1'</span>), (<span class="hljs-number">2</span>,<span class="hljs-string">'2.1'</span>), (<span class="hljs-number">2</span>,<span class="hljs-string">'2.2'</span>), (<span class="hljs-number">3</span>,<span class="hljs-string">'3.1'</span>)) t(a,b)
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a
<span class="hljs-keyword">FETCH FIRST</span> <span class="hljs-number">2</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">ONLY</span>;</code></pre><br>
<pre><code class="plaintext hljs"> a |  b  <font></font>
---+-----<font></font>
 1 | 1.1<font></font>
 2 | 2.1<font></font>
(2 rows)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，它</font></font><code>FETCH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支持短语</font></font><code>WITH TIES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它将所有“相关”行添加到输出中（如果仅考虑排序条件，则这些行等于已选择的行）：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> *
<span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-string">'1.1'</span>), (<span class="hljs-number">2</span>,<span class="hljs-string">'2.1'</span>), (<span class="hljs-number">2</span>,<span class="hljs-string">'2.2'</span>), (<span class="hljs-number">3</span>,<span class="hljs-string">'3.1'</span>)) t(a,b)
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a
<span class="hljs-keyword">FETCH FIRST</span> <span class="hljs-number">2</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">WITH</span> TIES;</code></pre><br>
<pre><code class="plaintext hljs"> a |  b  <font></font>
---+-----<font></font>
 1 | 1.1<font></font>
 2 | 2.1<font></font>
 2 | 2.2<font></font>
(3 rows)</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内置函数和数据类型</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_random_uuid</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
新函数</font></font><code>get_random_uuid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回版本4 UUID值（随机值）：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> gen_random_uuid();</code></pre><br>
<pre><code class="plaintext hljs">           gen_random_uuid            <font></font>
--------------------------------------<font></font>
 25e02793-80c0-438c-be07-c94b966c43ab</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该功能对于在分布式系统中生成唯一的UUID值很有用。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前，您必须使用uuid-ossp或pgcrypto库。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min_scale和trim_scale用于数字类型的值</font></font></b></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
该函数</font></font><code>min_scale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定数字的小数部分中的有效位数，并且该函数</font></font><code>trim_scale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">丢弃</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;">非</font></b></a><font style="vertical-align: inherit;">有效</font><font style="vertical-align: inherit;">零：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> n, min_scale(n), trim_scale(n) <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">VALUES</span>(<span class="hljs-number">42.42000</span>)) <span class="hljs-keyword">as</span> t(n);</code></pre><br>
<pre><code class="plaintext hljs">    n     | min_scale | trim_scale<font></font>
----------+-----------+------------<font></font>
 42.42000 |         2 |      42.42</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gcd和lcm</font></font></b></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
数学函数部分中的补货。</font><font style="vertical-align: inherit;">现在，您可以快速找到最大的公因数（</font></font><code>gcm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）和最小的公</font><font style="vertical-align: inherit;">因数</font><font style="vertical-align: inherit;">（</font></font><code>lcm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> gcd(<span class="hljs-number">54</span>,<span class="hljs-number">24</span>), lcm(<span class="hljs-number">54</span>,<span class="hljs-number">24</span>);</code></pre><br>
<pre><code class="plaintext hljs"> gcd | lcm<font></font>
-----+-----<font></font>
   6 | 216</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型pg_lsn聚合函数的最小值和最大值</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集合函数增加了对</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数据类型</font><font style="vertical-align: inherit;">，并</font><font style="vertical-align: inherit;">允许您执行以下形式的查询：</font></font><code>pg_lsn</code><font style="vertical-align: inherit;"></font><code>min</code><font style="vertical-align: inherit;"></font><code>max</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> min(restart_lsn) <span class="hljs-keyword">FROM</span> pg_replication_slots;
<span class="hljs-keyword">SELECT</span> min(sent_lsn) <span class="hljs-keyword">FROM</span> pg_stat_replication;</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查函数返回值的类型修饰符</font></font></b></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在以前的版本中，未检查类型修饰符的函数返回值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设有一个用于存储货币单位的类型和一个返回所得税金额的函数：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TYPE</span> currency <span class="hljs-keyword">AS</span> (<font></font>
    amount <span class="hljs-type">numeric</span>(<span class="hljs-number">18</span>,<span class="hljs-number">2</span>),<font></font>
    code   <span class="hljs-type">text</span><font></font>
);<font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> income_tax(quantity currency) <span class="hljs-keyword">RETURNS</span> currency
    <span class="hljs-keyword">AS</span> <span class="hljs-string">'SELECT quantity.amount * 0.13, quantity.code'</span> <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">SQL</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
调用该函数，我们希望得到两位小数，但是，我们得到四位。</font><font style="vertical-align: inherit;">即使在函数调用后进行显式转换也无济于事（第三列）：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> amount, code, amount::<span class="hljs-type">numeric</span>(<span class="hljs-number">18</span>,<span class="hljs-number">2</span>)
<span class="hljs-keyword">FROM</span> income_tax(<span class="hljs-keyword">ROW</span>(<span class="hljs-number">42.42</span>, <span class="hljs-string">''</span>))\gx</code></pre><br>
<pre><code class="plaintext hljs">-[ RECORD 1 ]--<font></font>
amount | 5.5146<font></font>
code   | <font></font>
amount | 5.5146</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在版本13中，结果是正确的：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> amount, code, amount::<span class="hljs-type">numeric</span>(<span class="hljs-number">18</span>,<span class="hljs-number">2</span>)
<span class="hljs-keyword">FROM</span> income_tax(<span class="hljs-keyword">ROW</span>(<span class="hljs-number">42.42</span>, <span class="hljs-string">''</span>))\gx</code></pre><br>
<pre><code class="plaintext hljs">-[ RECORD 1 ]<font></font>
amount | 5.51<font></font>
code   | <font></font>
amount | 5.51</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to_date（）和to_timestamp（）</font></font></b></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
函数中</font><font style="vertical-align: inherit;">的本地化名称</font></font><code>to_date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还</font></font><code>to_timestamp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">学习了理解月份和星期几的本地化名称。</font><font style="vertical-align: inherit;">以前只能使用英文名称：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> to_date(<span class="hljs-string">', 24  2020'</span>, <span class="hljs-string">'TMDay, DD TMMonth YYYY'</span>);</code></pre><br>
<pre><code class="plaintext hljs">  to_date   <font></font>
------------<font></font>
 2020-03-24</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normalize和IS NORMALIZED</font></font></b></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
为了符合SQL标准，已经添加了normalize（）函数以对Unicode字符串进行标准化，并且IS NORMALIZED谓词可以检查字符串是否被标准化。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> str, normalize(str, NFC) <span class="hljs-keyword">AS</span> nfc,<font></font>
       str <span class="hljs-keyword">IS</span> NFC NORMALIZED <span class="hljs-keyword">AS</span> is_nfc_normalized,<font></font>
       normalize(str, NFKC) <span class="hljs-keyword">AS</span> nfkc,<font></font>
       str <span class="hljs-keyword">IS</span> NFKC NORMALIZED <span class="hljs-keyword">AS</span> is_nfkc_normalized
<span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">VALUES</span>(<span class="hljs-string">U&amp;'\0032\2075'</span>)) <span class="hljs-keyword">AS</span> vals(str)\gx</code></pre><br>
<pre><code class="plaintext hljs">-[ RECORD 1 ]------+---<font></font>
str                | 2⁵<font></font>
nfc                | 2⁵<font></font>
is_nfc_normalized  | t<font></font>
nfkc               | 25<font></font>
is_nfkc_normalized | f</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关UNICODE规范化表格的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">更多</font></a><font style="vertical-align: inherit;">信息。</font></font><br>
<br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于64位事务号的Xid8类型和xid8_current（）函数为64位事务号</font></font></a></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
添加了新的xid8数据类型。但是，不，这并不意味着PostgreSQL转向了64位事务：一切都像以前一样工作。但是，一些函数返回一个新的类型，例如，现在推荐使用，而不是旧的功能pg_current_xact_id txid_current，这回INT8，等等。N. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新多态数据类型anycompatible家庭</font></font></b></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
添加类型</font></font><code>anycompatible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>anycompatiblearray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>anycompatiblenonarray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>anycompatiblerange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。与家庭类型不同</font></font><code>anyelement</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，新类型允许您使用不完全相同但实际上兼容的类型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在下面的示例中，该函数</font></font><code>maximum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为参数定义为</font></font><code>anycompatible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传递</font></font><code>integer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>numeric</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">对于这两种类型，返回值将转换为公共值：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> maximum(a anycompatible, b anycompatible) <span class="hljs-keyword">RETURNS</span> anycompatible
	<span class="hljs-keyword">AS</span> <span class="hljs-string">'SELECT CASE WHEN a &gt; b THEN a ELSE b END'</span> <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">SQL</span>;<font></font>
<font></font>
<span class="hljs-keyword">SELECT</span> f, pg_typeof(f) <span class="hljs-keyword">FROM</span> maximum(<span class="hljs-number">42</span>, <span class="hljs-number">42.42</span>) f;</code></pre><br>
<pre><code class="plaintext hljs">   f   | pg_typeof<font></font>
-------+-----------<font></font>
 42.42 | numeric</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，类型anycompatible-和any-是两个独立的类型集：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> first_elems(a <span class="hljs-type">anyarray</span>, b anycompatiblearray)
    <span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">TABLE</span>(a <span class="hljs-type">anyelement</span>, b anycompatible) <span class="hljs-keyword">AS</span> $$<span class="pgsql">
        <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ROW</span>(a[array_lower(a,<span class="hljs-number">1</span>)], b[array_lower(b,<span class="hljs-number">1</span>)]);
    $$</span> <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">sql</span>;
<span class="hljs-keyword">SELECT</span> first_elems(<span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-keyword">ARRAY</span>[<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>]) <span class="hljs-keyword">AS</span> str, <font></font>
       first_elems(<span class="hljs-keyword">ARRAY</span>[<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>],<span class="hljs-keyword">ARRAY</span>[<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>]) <span class="hljs-type">bool</span>;</code></pre><br>
<pre><code class="plaintext hljs">  str  |  bool   <font></font>
-------+---------<font></font>
 (1,a) | (1.1,t)</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序语言</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / Perl中bool类型的转换</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最近，Ivan Panchenko（Postgres Professional）的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bool_plperl的TRANSFORM已提交</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Postgres像PL或Perl中那样将布尔值传递给PL或Perl</font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font><font style="vertical-align: inherit;">在PL / Perl中传递</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但对于Perl而言，它</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是布尔</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> false</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而是字母f，即 </font><font style="vertical-align: inherit;">在逻辑上，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真理</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">可以通过不同的方式解决此问题（请参阅</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对应关系</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），但是汤姆·莱恩（Tom Lane）认为，为布尔创建TRANSFORM是最实用的。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在PL / pgSQL中快速执行简单表达式</font></font></b></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
简单表达式（至少不包含表调用且不需要锁）会更快。</font><font style="vertical-align: inherit;">以前，在这些情况下，每个周期上与调度程序联系的时间都花了很多时间。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR REPLACE</span> <span class="hljs-keyword">FUNCTION</span> slow_pi() <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">double</span> <span class="hljs-type">precision</span> <span class="hljs-keyword">AS</span> $$<span class="pgsql">
    <span class="hljs-keyword">DECLARE</span>
        a <span class="hljs-type">double</span> <span class="hljs-type">precision</span> := <span class="hljs-number">1</span>;
        s <span class="hljs-type">double</span> <span class="hljs-type">precision</span> := <span class="hljs-number">1</span>;
        r <span class="hljs-type">double</span> <span class="hljs-type">precision</span> := <span class="hljs-number">0</span>;
    <span class="hljs-keyword">BEGIN</span>
        <span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">1</span> .. <span class="hljs-number">10000000</span> <span class="hljs-keyword">LOOP</span>
            r := r + s/a; a := a + <span class="hljs-number">2</span>; s := -s;
        <span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;
        <span class="hljs-keyword">RETURN</span> <span class="hljs-number">4</span>*r;
    <span class="hljs-keyword">END</span>;
    $$</span> <span class="hljs-keyword">LANGUAGE</span> plpgsql;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在PG12中调用slow_pi（）：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> slow_pi();</code></pre><br>
<pre><code class="plaintext hljs">          slow_pi      <font></font>
    --------------------<font></font>
     3.1415925535898497<font></font>
    (1 row)<font></font>
    Time: 13060,650 ms (00:13,061)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在在PG13中：</font></font><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> slow_pi();</code></pre><br>
<pre><code class="plaintext hljs">          slow_pi      <font></font>
    --------------------<font></font>
     3.1415925535897915<font></font>
    (1 row)<font></font>
    Time: 2108,464 ms (00:02,108)</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">受信任的扩展而不是pg_pltemplate</font></font></b></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
系统目录减少了一个表。</font><font style="vertical-align: inherit;">已删除</font></font><code>pg_pltemplate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它存储了执行过程中所需的过程语言的属性</font></font><code>CREATE LANGUAGE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">现在，我们决定从相应语言的扩展脚本中注册属性</font></font><code>pg_pltemplate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并摆脱表本身。</font><font style="vertical-align: inherit;">但是，为了实施该计划，有必要为数据库所有者（无超级用户权限）提供从扩展脚本创建可信语言的可能性。</font><font style="vertical-align: inherit;">确实，例如，现在要创建plpgsql，数据库所有者不必是超级用户。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
收到如下。</font><font style="vertical-align: inherit;">新的逻辑参数已出现在扩展控制文件中</font></font><code>trusted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果两个参数</font></font><code>trusted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>superuser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果包含此扩展名，则扩展名不仅可以由超级用户创建，还可以由拥有</font></font><code>CREATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前数据库（及其所有者）</font><font style="vertical-align: inherit;">权限的用户创建</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">执行此类扩展的脚本时，将使用初始化集群的超级用户权限。</font><font style="vertical-align: inherit;">尽管扩展本身的所有者将是创建用户，但扩展创建的对象将属于该扩展。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些更改的重要后果：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可信扩展为第三方开发人员创建其他可信语言开辟了道路。</font><font style="vertical-align: inherit;">现在我们只限于plpgsql，plperl和pltcl。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这</font></font><code>pg_pltemplate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是很难写了plpython指的是语言的第二个版本。</font><font style="vertical-align: inherit;">否则，</font></font><code>pg_pltemplate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是过渡到python 3的步骤（必要但不充分）。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指标</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B树</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;">压缩</font></b></a><font style="vertical-align: inherit;">由Peter最终传达了一个由Anastasia Lubennikova（Postgres Professional）和Peter Geigan（Peter Geoghegan）编写的，期待已久的重要补丁（工作已于2015年开始）。 Nastya设法</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在PGconf India</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">谈论</font></a><font style="vertical-align: inherit;">了这</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">一点</font></a><font style="vertical-align: inherit;">。 Postgres学会了通过重复数据删除显着减少B树索引的大小，即节省重复索引键。这些索引经过了认真的重新设计，因此可以进行压缩而不会失去与以前版本索引的兼容性。重复数据删除的想法来自更灵活的索引架构，如</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GIN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（反向索引-广义反向索引）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这些索引中比在</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"> B树中</font></a><font style="vertical-align: inherit;">更常见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时，存在键对应于大量记录的情况。例如，在进行文字处理时，通常会在多个文档中找到相同的令牌。并且它仅在索引中存储一次。直到最近，B树索引还不知道如何执行此操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
B树索引与GIN索引的不同之处主要在于叶页。根据与相同键值相关的记录数，可以使用以下选项：该页面仅包含一个发布列表-TID列表（索引记录的标识符），如果该列表很小，并且如果TID很大，那么将存储而不是值列表新的“树枝”-链接到其他页面，如发布列表或其他树枝（它们称为发布树）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样的树结构类似于B树，但是在本质细节上有所不同：例如，用于在GIN中浏览同一树级别的页面的列表是单向的，而不是双向的。因此，不容易实现新的，具有重复数据删除功能的索引与旧版本的良好兼容性。改进确实花费了3年多的时间。还必须弄清清洁机制（微真空）和其他细微差别。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在性能测试中，所有适用重复数据删除的索引缩水了约3倍。压缩重复项还有助于唯一索引，从而消除了表更改率很高时索引膨胀的问题。可以在索引设置级别连接和断开新行为。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在不需要的地方不会按GIN索引进行完全扫描</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在某些情况下，此修补程序可以避免整个GIN索引完全通过。</font><font style="vertical-align: inherit;">尽管GIN索引支持某些操作，但这些操作是通过对索引进行全面扫描来执行的。</font><font style="vertical-align: inherit;">以全文列搜索的索引为例</font></font><code>tsvector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果搜索查询的形式为“给定单词以外的任何内容”，则整个索引将必须全部读取。</font><font style="vertical-align: inherit;">但是，如果请求中存在另一个条件，该条件不需要完全扫描索引，则仍将完全扫描索引。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过新的优化，将首先使用更准确的条件，使您可以从索引中获得收益，然后将再次检查结果以考虑另一个限制。</font><font style="vertical-align: inherit;">比较版本12（缓冲区）中读取的页面数：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">EXPLAIN</span> (<span class="hljs-keyword">ANALYZE</span>, <span class="hljs-keyword">BUFFERS</span>, <span class="hljs-keyword">COSTS</span> <span class="hljs-keyword">OFF</span>, <span class="hljs-keyword">TIMING</span> <span class="hljs-keyword">OFF</span>)
<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> mail_messages <span class="hljs-keyword">WHERE</span> tsv @@ to_tsquery(<span class="hljs-string">'!vacuum'</span>) <span class="hljs-keyword">AND</span> tsv @@ to_tsquery(<span class="hljs-string">'analyze'</span>);</code></pre><br>
<pre><code class="plaintext hljs">                                             QUERY PLAN                                             <font></font>
------------------------------------------------------------------<font></font>
Bitmap Heap Scan on mail_messages (actual rows=5864 loops=1)<font></font>
   Recheck Cond: ((tsv @@ to_tsquery('!vacuum'::text)) AND (tsv @@ to_tsquery('analyze'::text)))<font></font>
   Heap Blocks: exact=5167<font></font>
   Buffers: shared hit=24 read=27405<font></font>
   -&gt;  Bitmap Index Scan on mail_messages_tsv_idx (actual rows=5864 loops=1)<font></font>
         Index Cond: ((tsv @@ to_tsquery('!vacuum'::text)) AND (tsv @@ to_tsquery('analyze'::text)))<font></font>
         Buffers: shared hit=24 read=22238<font></font>
 Planning Time: 0.283 ms<font></font>
 Execution Time: 3258.234 ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新版本中的缓冲区数：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">EXPLAIN</span> (<span class="hljs-keyword">ANALYZE</span>, <span class="hljs-keyword">BUFFERS</span>, <span class="hljs-keyword">COSTS</span> <span class="hljs-keyword">OFF</span>, <span class="hljs-keyword">TIMING</span> <span class="hljs-keyword">OFF</span>)
<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> mail_messages <span class="hljs-keyword">WHERE</span> tsv @@ to_tsquery(<span class="hljs-string">'!vacuum'</span>) <span class="hljs-keyword">AND</span> tsv @@ to_tsquery(<span class="hljs-string">'analyze'</span>);</code></pre><br>
<pre><code class="plaintext hljs">                                             QUERY PLAN                                             <font></font>
---------------------------------------------------------------------------<font></font>
Bitmap Heap Scan on mail_messages (actual rows=5864 loops=1)<font></font>
   Recheck Cond: ((tsv @@ to_tsquery('!vacuum'::text)) AND (tsv @@ to_tsquery('analyze'::text)))<font></font>
   Heap Blocks: exact=5156<font></font>
   Buffers: shared hit=5179<font></font>
   -&gt;  Bitmap Index Scan on mail_messages_tsv_idx (actual rows=5864 loops=1)<font></font>
         Index Cond: ((tsv @@ to_tsquery('!vacuum'::text)) AND (tsv @@ to_tsquery('analyze'::text)))<font></font>
         Buffers: shared hit=23<font></font>
 Planning Time: 0.250 ms<font></font>
 Execution Time: 8.779 ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当使用三字母组和检查数组的出现时，可能会遇到类似的情况。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运算符类的参数</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在PostgreSQL中，许多索引访问方法是一种“框架”，它采用搜索算法的高级实现，使用页面和锁以及WAL日志。使用操作符类绑定到特定的数据类型和操作符。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
到目前为止，操作员类还没有参数。例如，对于全文搜索，可以使用带有一类运算符的GiST索引</font></font><code>tsvector_ops</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（关于</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">此处</font></a><font style="vertical-align: inherit;">的GiST运算符的类别）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）此类运算符使用签名树，并且签名长度是固定的（124个字节）。现在，您可以显式指定长度，这使您可以控制索引大小和效率（哈希冲突数）之间的平衡：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> mail_messages <span class="hljs-keyword">USING</span> gist(tsv tsvector_ops(siglen=<span class="hljs-number">1024</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于其他使用签名树的GiST运算符类，对于启动器也进行了类似的更改，这些签名树适用于hstore，intarray，ltree和pg_trgm扩展。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，构想此更改的主要思想是将JSONPath表达式传递给GIN索引的能力，这样就不会为整个JSON文档建立索引，而仅对它的必要部分进行索引。在许多情况下，这将从根本上减少索引的大小。但是这项工作仍有待完成。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
奥列格·巴图诺夫（Oleg Bartunov）的想法，尼基塔·格鲁霍夫（Nikita Glukhov）和亚历山大·科罗特科夫（Alexander Korotkov）的实现（均为Postgres Professional的三位）。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加了运算符&lt;-&gt;（框，点）</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
，缺少的操作也添加到了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GiST</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SP-GiST的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kNN中</font><font style="vertical-align: inherit;">。在PG12中使用几何类型</font></font><code>point</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以使用距离运算符</font></font><code>&lt;-&gt;(point, box)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它将通过GiST和SP-GiST索引加快搜索速度。</font><font style="vertical-align: inherit;">但是</font></font><code>&lt;-&gt;(box, point)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，尽管他</font></font><code>box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已经理解了与更复杂的类型（多边形和圆形）之间的距离</font><font style="vertical-align: inherit;">，但</font><font style="vertical-align: inherit;">对他对称的操作员</font><font style="vertical-align: inherit;">尚未实现</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> points(<span class="hljs-type">point</span> <span class="hljs-type">point</span>);
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> boxes(<span class="hljs-type">box</span> <span class="hljs-type">box</span>);
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> points <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'1,2'</span>,<span class="hljs-string">'3,4'</span>);
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> boxes <span class="hljs-keyword">VALUES</span>(box(<span class="hljs-type">point</span>(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>),<span class="hljs-type">point</span>(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)), box(<span class="hljs-type">point</span>(<span class="hljs-number">13</span>,<span class="hljs-number">14</span>),<span class="hljs-type">point</span>(<span class="hljs-number">15</span>,<span class="hljs-number">16</span>)));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在PG12中：</font></font><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> p.point, b.box, b.box  &lt;-&gt; p.point distance <span class="hljs-keyword">FROM</span> points <span class="hljs-keyword">AS</span> p, boxes <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> distance;</code></pre><br>
<pre><code class="plaintext hljs">:    : box &lt;-&gt; point</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果反之亦然，那么一切正常：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> p.point, b.box, p.point  &lt;-&gt; b.box distance <span class="hljs-keyword">FROM</span> points <span class="hljs-keyword">AS</span> p, boxes <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> distance;</code></pre><br>
<pre><code class="plaintext hljs"> point |       box       |      distance<font></font>
-------+-----------------+--------------------<font></font>
 (1,2) | (5,6),(3,4)     | 2.8284271247461903<font></font>
 (2,1) | (5,6),(3,4)     | 3.1622776601683795<font></font>
 (1,2) | (15,16),(13,14) | 16.970562748477143<font></font>
 (2,1) | (15,16),(13,14) | 17.029386365926403</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在PG13中：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> p.point, b.box, b.box  &lt;-&gt; p.point distance <span class="hljs-keyword">FROM</span> points <span class="hljs-keyword">AS</span> p, boxes <span class="hljs-keyword">AS</span> b <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> distance;</code></pre><br>
<pre><code class="plaintext hljs"> point |       box       |      distance<font></font>
-------+-----------------+--------------------<font></font>
 (1,2) | (5,6),(3,4)     | 2.8284271247461903<font></font>
 (2,1) | (5,6),(3,4)     | 3.1622776601683795<font></font>
 (1,2) | (15,16),(13,14) | 16.970562748477143<font></font>
 (2,1) | (15,16),(13,14) | 17.029386365926403</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此操作将加快GiST和SP-GiST索引。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，在PG13中，如果您询问：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> count(*) <span class="hljs-keyword">FROM</span> pg_operator <span class="hljs-keyword">WHERE</span> oprname = <span class="hljs-string">'&lt;-&gt;'</span>;</code></pre><pre><code class="plaintext hljs"> count <font></font>
-------<font></font>
    28</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果在PG12中执行相同的操作，则将获得20个条目：在第13版中，该列表最多补充了8个运算符。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">杰森</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支持jsonpath的.datetime（）方法。</font></font></b></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
这是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PG12</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有时间完成</font><font style="vertical-align: inherit;">的大量</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"> JSONPath补丁程序中</font></a><font style="vertical-align: inherit;">不成功的补丁程序之一</font><font style="vertical-align: inherit;">。 JSON / SQL标准的一部分。问题在于，JSONPath修补程序系列中的所有功能都是不可变的，但是日期比较考虑了当前时区，该时区可能在会话期间发生变化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，我们允许现有的不可变函数对非不可变比较抛出错误。同时，此修补程序具有带有后缀_tz的功能，该功能在带时区的操作中稳定运行。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新功能-jsonb_set_lax函数</font></font></b></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，松懈是jsonb函数的非严格（不同于严格）操作模式。在这种情况下，该函数将在其中一个参数为NULL的情况下运行。与严格版本不同-jsonb_set（）-它具有一个附加参数，该参数指示在NULL情况下的操作。选项：use_json_null / raise_exception / return_target / delete_key。感兴趣的用户建议的选项。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优化了一些jsonb函数，做</font></font></b></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">了很多</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
优化</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，主要是通过Nikita Glukhov（Postgres Professional）的努力。</font><font style="vertical-align: inherit;">但是分析这种情况下的每一个观点都是没有意义的：首先，它们的丰富性将使本来已经很短的文章膨胀；</font><font style="vertical-align: inherit;">其次，更改与内部设备有关，并非每个用户都感兴趣。</font><font style="vertical-align: inherit;">因此，我们将仅列出其中的大多数：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优化函数JsonbExtractScalar（）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优化的运算符＃&gt;&gt;，函数jsonb_each_text（），jsonb_array_elements_text（）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优化了对get_jsonb_path_all（）中的JsonbContainer类型的识别；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从轻量级宏JsonbContainerIsXxx（）代替了从JsonbIterator迭代器获取第一个令牌；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更方便的密钥提取-findJsonbKeyInObject（）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优化存储结果findJsonbValueFromContainer（）和getIthJsonbValueFromContainer（）;</font></font></li>
<li>  get_jsonb_path_all(),     ;<br>
  JsonbValueAsText.</li>
</ol><br>
<i> ,        SQL/JSON: JSON_TABLE  SQL/JSON: functions.       . ,   .      .     PG14.   JSONPath   .</i><br>
<br>
<h3>  </h3><br>
<h4>pgbench</h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用于运行性能测试的实用程序进行了一系列改进。</font><font style="vertical-align: inherit;">在初始化阶段</font><font style="vertical-align: inherit;">有</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任务</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">执行的统计信息</font></a><font style="vertical-align: inherit;">，更</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直观的结论</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，能够</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看内置脚本的代码</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在分区的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">帐户</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">表上进行</font></a><font style="vertical-align: inherit;">测试</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，我们添加了</font></font><code>\aset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与相似</font><font style="vertical-align: inherit;">的命令</font></font><code>\gset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但允许为一次发送的多个请求的变量设置值。</font><font style="vertical-align: inherit;">发送到服务器以执行的以下行设置变量</font></font><code>one</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>two</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> one \; <span class="hljs-keyword">SELECT</span> <span class="hljs-number">2</span> <span class="hljs-keyword">AS</span> two \aset</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pg_dump</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pg_dump学会了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从第三方表中卸载数据</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">通过该参数，</font></font><code>--include-foreign-data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以指定第三方服务器的列表，这些服务器的表中的数据将被卸载。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
小心使用此卸载。</font><font style="vertical-align: inherit;">事实并非必须将数据上传到第三方服务器。</font><font style="vertical-align: inherit;">另外，很有可能在恢复期间第三方服务器将不可用。</font><font style="vertical-align: inherit;">或第三方服务器只能允许读取，而不能写入数据。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">psql</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一系列小补丁使psql更舒适：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改进了几个团队的制表符完成度。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除了</font></font><code>\echo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将字符串发送到STDOUT之外，新命令</font><font style="vertical-align: inherit;">还将</font><font style="vertical-align: inherit;">字符串</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>\warn</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发送到标准错误输出（STDERR）。</font></font></li>
<li> <code>\d</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> toast-</a>       .        <code>\d+</code>        .</li>
<li>  <code>\dt+</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  «Persistence»</a>      (unlogged)   (permanent).</li>
<li>  <code>\e</code>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a>,       <code>;</code> (  <code>\g*</code>). ,       psql      .</li>
<li>         .     <code>PROMPT1</code>  <code>PROMPT2</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> <code>%x</code>.</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新命令</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问方法的详细资料：</font></font><code>\dAc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>\dAf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>\dAo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>\dAp</code></li>
<li><font style="vertical-align: inherit;"></font><code>\g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">您</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在方括号中</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">指定</font></a><font style="vertical-align: inherit;">受支持的任何选项</font></font><code>\pset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他们将仅对当前团队采取行动。</font></font></li>
</ul><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libpq</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与PostgreSQL相关的微小变化：</font></font><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这种不准确性</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在主机和hostadr参数的描述，并在输出端的产生的不一致性</font></font><code>\conninfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PSQL实用程序命令已被固定。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果客户端证书密钥以加密形式存储，则只能在交互模式下输入密码。</font><font style="vertical-align: inherit;">新的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sslpassword</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">允许您</font></a><font style="vertical-align: inherit;">非交互地解密密钥。</font></font></li>
<li><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sslminprotocolversion和sslmaxprotocolversion这</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两个新参数</font><font style="vertical-align: inherit;">使您可以指定对允许连接的SSL / TCL协议版本的限制。</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重新索引数据库</font></font></h4><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reindexdb</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实用程序</font><font style="vertical-align: inherit;">
的新</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">--jobs</font></a><font style="vertical-align: inherit;">参数</font><font style="vertical-align: inherit;">设置了将在其中同时重建索引的数据库连接数。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pg_rewind</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实用程序的局限性正在逐渐消除，可能性正在增加。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，pg_rewind </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在可以</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记录要恢复的信息（因为pg_basebackup可以做到），如果没有通过检查点停止实例，则可以开始恢复和随后关闭实例（必须在之前手动完成）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其次，pg_rewind学会了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用WAL归档文件</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在该实用程序找到两台服务器之间的WAL分歧点之后，它应该建立一个需要复制到目标群集的所有页面的列表，以消除差异。</font><font style="vertical-align: inherit;">为此，该实用程序需要从找到的点开始的所有WAL文件。</font><font style="vertical-align: inherit;">如果必需的WAL文件在目标群集上不可用，则该实用程序之前无法执行其工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果指定了新的-c或--restore-target-wal开关，则使用Alexey Kondratov（Postgres Professional）的此修补程序，pg_rewind将能够使用restore_command参数从日志文件的存档中读取丢失的WAL段。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pg_waldump</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pg_waldump将</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解密</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">准备好的交易</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">记录</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">amcheck</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
amcheck扩展已经学会了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更好地识别</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> B树索引中的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">损坏</font></a><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顺便说一句，现在服务器日志中有关损坏页面的消息</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于索引和表</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">有所不同</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">页面检查</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该</font></font><code>heap_tuple_infomask_flags</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pageinspect扩展功能</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解密字段的值</font></font></a> <code>infomask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>infomask2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数返回</font></font><code>heap_page_items</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在调查数据损坏情况时很有用。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">postgres_fdw</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用户名映射级别的超级用户可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许普通用户</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用没有密码的连接：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">MAPPING</span> <span class="hljs-keyword">FOR</span>  <span class="hljs-keyword">SERVER</span> 
    <span class="hljs-keyword">OPTIONS</span> (<span class="hljs-keyword">ADD</span> password_required <span class="hljs-string">'false'</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样做尤其重要，因此</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sslkey和sslcert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可用作连接参数</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">管理包</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
adminpack扩展具有一个新功能- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>pg_file_sync</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用它，您可以对服务器写入磁盘的文件执行fsync，例如通过</font></font><code>pg_file_write</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><code>COPY TO</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">监控方式</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pg_stat_slru</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在服务器的共享内存中，不仅有很大的缓冲区高速缓存，而且还有许多其他更简单的高速缓存（例如，用于事务状态的高速缓存）。</font><font style="vertical-align: inherit;">他们使用一种简单的算法来排挤最不频繁使用的页面（简单的最近最少使用的页面或SLRU）。</font><font style="vertical-align: inherit;">到现在为止，这样的高速缓存“正常工作”，但是有必要对其进行监视，首先是让PostgreSQL内核的开发人员确定是否需要对其进行更改。</font><font style="vertical-align: inherit;">为此目的，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出现</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">pg_stat_slru</font></a><font style="vertical-align: inherit;">的新视图</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pg_stat_activity</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在视图中，</font></font><code>pg_stat_activity</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新列</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><code>leader_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">对于参与并行请求的流程，它会填充前导流程的编号。</font><font style="vertical-align: inherit;">而领导过程</font></font><code>leader_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个过程号</font></font><code>pid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下查询显示哪些查询和哪些进程当前正在并行运行：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> query, leader_pid, <font></font>
    array_agg(pid) <span class="hljs-keyword">filter</span>(<span class="hljs-keyword">WHERE</span> leader_pid != pid) <span class="hljs-keyword">AS</span> members
  <span class="hljs-keyword">FROM</span> pg_stat_activity
 <span class="hljs-keyword">WHERE</span> leader_pid <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>
 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> query, leader_pid;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
等待事件列表发生了变化。</font><font style="vertical-align: inherit;">添加了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两个新事件</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><code>BackupWaitWalArchive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>RecoveryPause</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">另外两个名称更准确：</font></font><code>RecoveryWalStream -&gt; RecoveryRetrieveRetryInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>RecoveryWalAll -&gt; RecoveryWalStream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">副本上</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
又</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发生了两个新的等待事件</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：（</font></font><code>RecoveryConflictSnapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与VACUUM冲突，这删除了行的必需版本）和</font></font><code>RecoveryConflictTablespace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（与删除表空间有关的冲突）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pg_stat_statements</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
到目前为止，该扩展程序已将</font></font><code>pg_stat_statements</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有</font></font><code>FOR UPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或不带有短语的请求视为同一请求。现在，与</font></font><code>FOR UPDATE</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请求</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">将单独记录</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
收集的信息量有所增加。从现在开始，不仅记录了有关用于执行命令的资源的信息，而且还记录了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关生成的日记帐分录的统计信息</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。新的演示文稿列：</font></font><code>wal_bytes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-生成的记录</font></font><code>wal_records</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数量</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">-生成的记录</font></font><code>wal_num_fpw</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数量</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">-整页图像（整页写入）数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这要归功于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">准备好的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">跟踪WAL使用的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">基础结构</font></a><font style="vertical-align: inherit;">。因此，现在</font></font><code>EXPLAIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有了一个新选项，</font></font><code>WAL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它将显示生成的记录的数量：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t (id <span class="hljs-type">int</span>);
<span class="hljs-keyword">EXPLAIN</span> (<span class="hljs-keyword">ANALYZE</span>, WAL, <span class="hljs-keyword">COSTS</span> <span class="hljs-keyword">OFF</span>, <span class="hljs-keyword">TIMING</span> <span class="hljs-keyword">OFF</span>, <span class="hljs-keyword">SUMMARY</span> <span class="hljs-keyword">OFF</span>)
    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>);</code></pre><br>
<pre><code class="plaintext hljs">              QUERY PLAN              <font></font>
--------------------------------------<font></font>
 Insert on t (actual rows=0 loops=1)<font></font>
   WAL:  records=1  bytes=59<font></font>
   -&gt;  Result (actual rows=1 loops=1)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
拓</font></font><code>auto_explain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>VACUUM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font><code>VERBOSE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且</font></font><code>autovacuum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还使用WAL的创建基础设施，将输出量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回到</font></font><code>pg_stat_statements</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启用</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了新参数</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">pg_stat_statements.track_planning</font></a><font style="vertical-align: inherit;">，则将为每个操作员记录与调度程序有关的其他统计信息：计划生成数量；</font><font style="vertical-align: inherit;">总计划时间；</font><font style="vertical-align: inherit;">一个计划的最短和最长时间，以及均值和标准差。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对分配给调度程序的资源的计费反映在与无关的另一个补丁中</font></font><code>pg_stat_statements</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>EXPLAIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该选项</font></font><code>BUFFERS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将报告</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计划阶段使用的缓冲区数量</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">EXPLAIN</span> (<span class="hljs-keyword">ANALYZE</span>, <span class="hljs-keyword">BUFFERS</span>, <span class="hljs-keyword">COSTS</span> <span class="hljs-keyword">OFF</span>, <span class="hljs-keyword">TIMING</span> <span class="hljs-keyword">OFF</span>) 
    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> pg_class;</code></pre><br>
<pre><code class="plaintext hljs">                   QUERY PLAN                   <font></font>
------------------------------------------------<font></font>
 Seq Scan on pg_class (actual rows=386 loops=1)<font></font>
   Buffers: shared hit=9 read=4<font></font>
 Planning Time: 0.782 ms<font></font>
   Buffers: shared hit=103 read=11<font></font>
 Execution Time: 0.219 ms</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">杂志</font></font></h4><br>
<ul>
<li> <code>log_statement_sample_rate</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   SQL,   </a>,      <code>log_min_duration_sample</code>( ).<br>
,    <code>log_min_duration_statement</code>    , ..  <code>log_min_duration_statement</code> ,  <code>log_min_duration_sample</code>,       ,      <code>log_statement_sample_rate</code>.<br>
 ,   <code>log_transaction_sample_rate</code>    ,       ,      .</li>
<li>  ,   (   log_min_error_statement),         .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>log_parameter_max_length_on_error</code></a>.     0,   .<br>
 <code>log_parameter_max_length_on_error</code>          SQL,    ,      .<br>
    (     <code>log_statements</code>  <code>log_duration</code>)   ,  : <code>log_parameter_max_length</code>,     ,   .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，您可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将进程类型</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>pg_stat_activity.backend_type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">写入</font></a><font style="vertical-align: inherit;">服务器日志</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为此</font></font><code>log_line_prefix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">在参数中</font><font style="vertical-align: inherit;">提供了特殊符号</font></font><code>%b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">而且，如果日志以csv（</font></font><code>log_destination=csvlog</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">格式编写</font><font style="vertical-align: inherit;">，则该列</font></font><code>backend_type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已包含在其中。</font></font></li>
</ul><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进展</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新视图</font></font><code>pg_stat_progress_analyze</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还</font></font><code>pg_stat_progress_basebackup</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使您可以跟踪</font><font style="vertical-align: inherit;">团队</font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统计信息收集</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进度，</font></font><code>ANALYZE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并分别</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建该</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实用程序</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">的备份副本</font></a></font><code>pg_basebackup</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优化</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在计划阶段在FROM子句中计算不可变函数</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Aleksandr Kuzmenkov和Aleksandr Parfyonov（均来自Postgres Professional）的补丁在</font></font><code>FROM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用包含实际上是常量的函数调用的</font><font style="vertical-align: inherit;">情况下</font><font style="vertical-align: inherit;">会有所帮助。</font><font style="vertical-align: inherit;">在这种情况下，不是建立连接，而是在请求的必要位置替换常量值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是与全文搜索相关的查询示例的发生方式：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">EXPLAIN</span> (<span class="hljs-keyword">COSTS</span> <span class="hljs-keyword">OFF</span>)
<span class="hljs-keyword">SELECT</span> subject, ts_rank_cd(tsv, q) <span class="hljs-keyword">AS</span> rank
<span class="hljs-keyword">FROM</span> mail_messages, to_tsquery(<span class="hljs-string">'english'</span>, <span class="hljs-string">'tuple'</span>) q
<span class="hljs-keyword">WHERE</span> tsv @@ q
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> rank <span class="hljs-keyword">DESC</span>;</code></pre><br>
<pre><code class="plaintext hljs">                              QUERY PLAN                              <font></font>
------------------------------------------------------------------<font></font>
 Sort<font></font>
   Sort Key: (ts_rank_cd(mail_messages.tsv, '''tuple'''::tsquery)) DESC<font></font>
   -&gt;  Bitmap Heap Scan on mail_messages<font></font>
         Recheck Cond: (tsv @@ '''tuple'''::tsquery)<font></font>
         -&gt;  Bitmap Index Scan on mail_messages_tsv_idx<font></font>
               Index Cond: (tsv @@ '''tuple'''::tsquery)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
没有连接，并且在计划阶段已经在查询中替换了值'tuple':: tsquery。</font><font style="vertical-align: inherit;">第12版的情况完全不同：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">EXPLAIN</span> (<span class="hljs-keyword">COSTS</span> <span class="hljs-keyword">OFF</span>)
<span class="hljs-keyword">SELECT</span> subject, ts_rank_cd(tsv, q) <span class="hljs-keyword">AS</span> rank                            
<span class="hljs-keyword">FROM</span> mail_messages, to_tsquery(<span class="hljs-string">'english'</span>, <span class="hljs-string">'tuple'</span>) q
<span class="hljs-keyword">WHERE</span> tsv @@ q                            
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> rank <span class="hljs-keyword">DESC</span>;</code></pre><br>
<pre><code class="plaintext hljs">                          QUERY PLAN                         <font></font>
-----------------------------------------------------<font></font>
 Sort<font></font>
   Sort Key: (ts_rank_cd(mail_messages.tsv, q.q)) DESC<font></font>
   -&gt;  Nested Loop<font></font>
         -&gt;  Function Scan on q<font></font>
         -&gt;  Bitmap Heap Scan on mail_messages<font></font>
               Recheck Cond: (tsv @@ q.q)<font></font>
               -&gt;  Bitmap Index Scan on mail_messages_tsv_idx<font></font>
                     Index Cond: (tsv @@ q.q)</code></pre><br>
<br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增量排序</font></font></a></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
当需要通过许多键（k1，k2，k3 ...）进行</font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">排序</font></a></b><font style="vertical-align: inherit;">时，调度程序现在可以利用以下知识：已通过多个第一个键（例如，k1和k2）对数据进行了排序。在这种情况下，您无法再次对所有数据重新排序，而是将它们分为具有相同值k1和k2的连续组，并通过键k3进行“排序”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，整个分类分为几个较小的连续类型。这减少了所需的内存量，并且还允许您在所有排序完成之前发出第一个数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，在票证表的demobase中，在ticket_id列上有一个索引。</font><font style="vertical-align: inherit;">从索引接收的数据将按ticket_id排序，因此以下查询将使用增量排序：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">EXPLAIN</span> (<span class="hljs-keyword">analyze</span>, <span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>, <span class="hljs-keyword">timing</span> <span class="hljs-keyword">off</span>)
<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tickets <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> ticket_no, passenger_id;</code></pre><br>
<pre><code class="plaintext hljs">                                  QUERY PLAN                                  <font></font>
------------------------------------------------------------------------------<font></font>
 Incremental Sort (actual rows=2949857 loops=1)<font></font>
   Sort Key: ticket_no, passenger_id<font></font>
   Presorted Key: ticket_no<font></font>
   Full-sort Groups: 92184 Sort Method: quicksort Memory: avg=31kB peak=31kB<font></font>
   -&gt;  Index Scan using tickets_pkey on tickets (actual rows=2949857 loops=1)<font></font>
 Planning Time: 2.137 ms<font></font>
 Execution Time: 2230.019 ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以使用enable_incrementalsort参数禁用增量排序功能。</font><font style="vertical-align: inherit;">在这种情况下，排序将花费更长的时间：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SET</span> enable_incrementalsort = <span class="hljs-keyword">off</span>;
<span class="hljs-keyword">EXPLAIN</span> (<span class="hljs-keyword">analyze</span>, <span class="hljs-keyword">costs</span> <span class="hljs-keyword">off</span>, <span class="hljs-keyword">timing</span> <span class="hljs-keyword">off</span>)
<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> tickets <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> ticket_no, passenger_id;</code></pre><br>
<pre><code class="plaintext hljs">                              QUERY PLAN                               <font></font>
-----------------------------------------------------------------------<font></font>
 Gather Merge (actual rows=2949857 loops=1)<font></font>
   Workers Planned: 2<font></font>
   Workers Launched: 2<font></font>
   -&gt;  Sort (actual rows=983286 loops=3)<font></font>
         Sort Key: ticket_no, passenger_id<font></font>
         Sort Method: external merge  Disk: 107024kB<font></font>
         Worker 0:  Sort Method: external merge  Disk: 116744kB<font></font>
         Worker 1:  Sort Method: external merge  Disk: 107200kB<font></font>
         -&gt;  Parallel Seq Scan on tickets (actual rows=983286 loops=3)<font></font>
 Planning Time: 3.994 ms<font></font>
 Execution Time: 12291.844 ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
增量排序的想法由Alexander Korotkov（Postgres Professional）于2013年提出，现在，七年后，James Coleman将补丁带到了一个社区接受的州。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TRUNCATE加速</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
进行</font></font><code>TRUNCATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扫描</font></font><code>shared_buffers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以从共享内存中删除表缓冲区时。以前，对每个表层执行了三次扫描：MAIN（主数据层），FSM（可用空间图），VM（可见性图）。现在，逻辑已更改，而不是三次操作，缓冲区仅扫描一次。值较大时，</font></font><code>shared_buffers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这将带来明显的收益。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分减压吐司</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当不需要完全阅读TOAST时，只需将其限制在开始或接近开始处的一个切片上，那么完全打开就没有意义。</font><font style="vertical-align: inherit;">压缩的TOAST会以迭代方式读取：读取一段，如果没有必要的数据，则将其扩展并继续读取。</font><font style="vertical-align: inherit;">由Google暑期编程学生Binguo Bao提出，他举了一个例子：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> slicingtest (<font></font>
     id <span class="hljs-type">serial</span> <span class="hljs-keyword">PRIMARY KEY</span>,<font></font>
     a <span class="hljs-type">text</span><font></font>
);<font></font>
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> slicingtest (a) <span class="hljs-keyword">SELECT</span>
    repeat(<span class="hljs-string">'1234567890-=abcdefghijklmnopqrstuvwxyz'</span>, <span class="hljs-number">1000000</span>) <span class="hljs-keyword">AS</span> a <span class="hljs-keyword">FROM</span>
    generate_series(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);<font></font>
\<span class="hljs-keyword">timing</span>
<span class="hljs-keyword">SELECT</span> sum(length(substr(a, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>))) <span class="hljs-keyword">FROM</span> slicingtest;</code></pre><br>
<pre><code class="plaintext hljs">Time: 28.123 ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用补丁程序，速度提高了一个数量级：</font></font><br>
<br>
<pre><code class="plaintext hljs">Time: 2.306 ms</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并行VACUUM</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关此主题的文章中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Yegor Rogov详细解释了并行化中的这一重要步骤。简而言之：“修补泽田正彦，可让您并行执行清洁。该表本身仍由一个（引导）进程清除，但是要清理索引，它现在可以启动后台工作流，每个索引一个。在手动模式下，这可以加快清理具有多个索引的大型表的速度；自动清洁尚未使用此功能。”</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">粘贴到桌子时自动清洁</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于此补丁程序（也称为Berserk自动真空），我们需要感谢Dorofei Proleskovsky，他提出了以下问题的解决方案：自动清理不会出现在仅附加表中，因为它们没有行的“失效”版本。因此，可见性图不会更新，仅索引扫描无效，并且在进行清理以防止事务计数器溢出时，它需要立即执行大量工作。现在，这种情况已得到解决：自动清洁也将在添加生产线时起作用。出现了两个新的服务器参数（</font></font><code>autovacuum_vacuum_insert_threshold</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>autovacuum_vacuum_insert_scale_factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），类似于修改参数（</font></font><code>autovacuum_vacuum_threshold</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>autovacuum_vacuum_scale_factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈希聚合内存管理</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
散列聚合可能需要的RAM比调度程序所考虑的要多，并且要比中指示的要多</font></font><code>work_mem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。以前，这种调度程序错误导致以下事实：</font></font><code>work_mem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">忽略</font><font style="vertical-align: inherit;">了大小，</font><font style="vertical-align: inherit;">并且根据操作或到达OOM Killer的需要分配了足够的内存。现在，该算法可能不会超出范围</font></font><code>work_mem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且如有必要，请使用磁盘上的临时文件。为了控制调度程序的行为，出现了以下参数：</font></font><code>enable_groupingsets_hash_disk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>enable_hashagg_disk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用生成的列优化表的UPDATE</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在版本12中，即使此更改没有任何影响，在任何行更新期间都会重新计算生成的列。现在，仅在确实需要时（如果其基本列已更改），才将重新计算它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，这种优化可以显着加快使用生成的类型列的表的更新</font></font><code>tsvector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为该函数</font></font><code>to_tsvector()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常昂贵。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从触发器访问已更改列的列表</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
一个小补丁，将一个</font></font><code>TriggerData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已更改列</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">位图</font><font style="vertical-align: inherit;">添加到结构中</font><font style="vertical-align: inherit;">。常规触发器功能（例如</font></font><code>tsvector_update_trigger()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或）</font><font style="vertical-align: inherit;">可以使用此信息</font></font><code>lo_manage()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以免做不必要的工作。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">评估时使用几个高级统计信息</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在PG12中，调度程序无法同时对同一张表使用多个高级统计信息。例如，设想一种情况，其中为不同的列集构造了两个高级统计信息，而一组和另一组中的列都参与了查询。现在，计划者可以访问所有可用信息。</font></font><br>
<br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并行化和COPY的基础结构</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（另请参阅</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此补丁。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQL并发仍然适用于只读查询。</font><font style="vertical-align: inherit;">编写者有很多困难，其中之一是阻止同时执行一项任务（包括在一个通用并行组中）的进程。</font><font style="vertical-align: inherit;">可以相信，此类进程的锁不会冲突-例如，多个进程可以在同一表上持有排他锁。</font><font style="vertical-align: inherit;">这需要内核开发人员的特别注意，但是否则他们将不断陷入僵局。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是有两个例外：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关系扩展锁，在将新页面添加到数据文件的末尾时捕获，并且</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">页面锁定，将GIN索引项从等待列表移到主树时使用。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（您可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本文中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读更多</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">内容。</font></a><font style="vertical-align: inherit;">）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
即使在同一并行组的进程之间（实现此补丁程序</font><font style="vertical-align: inherit;">），</font><font style="vertical-align: inherit;">此类锁也应发生冲突。</font><font style="vertical-align: inherit;">但是，这些锁定永远不会导致死锁，因此将它们从扫描中排除。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于用户而言，通常没有什么变化，但是此补丁很重要，因为，首先，它为并行INSERT和COPY铺平了道路；其次，它消除了高负载条件下的PostgreSQL瓶颈之一（可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在报告中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">听到）</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">HL ++</font></a><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SKH PRH</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
素剂已使用现已失效的SKIP协议</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;">代替了替换的</font></b></a><font style="vertical-align: inherit;"> EDH素剂（Diffie-Hellman临时钥匙）。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> initdb：身份验证</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
的默认设置已更改initdb启动时，本地和网络连接的默认访问设置已更改。现在，在</font></font><code>pg_hba.conf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于本地连接的代替认证方法</font></font><code>trust</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将是</font></font><code>peer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（或MD5如果不支持对等体），和</font></font><code>md5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于网络连接。最初，讨论了更宽松的措施：文档中的警告。再难一点：</font></font><code>scram-sha-256</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。结果，我们决定将自己限制为</font></font><code>peer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>md5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用explicit_bzero</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要补丁。 bzero（）和explicit_bzero（）OS函数将包含的字节写入指示的内存区域</font></font><code>'\0'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">参见</font><font style="vertical-align: inherit;">Linux）。这些补丁仅仅是开始：内存中有很多部分可以保留密码和其他敏感信息。我们决定从libpq之类的地方开始，在该地方，带有密码的整个文件在读取.pgpass后可以保留在内存中，从关闭连接后进行清理开始。在be-secure-common.c中，现在覆盖了SSL中输入的秘密短语，该短语出现在错误的行（路径）中。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在libpq中添加了“ password_protocol”参数</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此修补程序允许libpq控制在连接期间使用哪种密码传输协议。收到此参数后，如果协议比指定的协议弱，libpq将拒绝认证。默认情况下，此参数</font></font><code>plaintext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（即所有协议）均适用。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TRUNCATE的强制访问</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
此修补程序使扩展能够嵌入TRUNCATE操作的强制访问控制（MAC）。现在，其</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">权限将由sepgsql</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扩展检查</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SELinux参考策略</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和基于Redhat的Linux发行版不支持对db_table {truncate}进行SELinux检查。在这种情况下，将以'deny_unknown'等于1的情况使用sepgsql，并且TRUNCATE将失败。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GUC ssl_passphrase_command的可用性</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个简单但有用的补丁。</font><font style="vertical-align: inherit;">现在，只有超级用户才能看到ssl_passphrase_command参数的值。</font><font style="vertical-align: inherit;">该参数指定当需要密码来解密SSL文件（例如私钥）时调用的外部命令。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本土化</font></font></h3><br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">版本控制libc归类规则</font></font></a></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
对于ICU归类规则，版本号存储在数据库中。每次使用该规则（排序，字符比较）时，都会使用OS中ICU库中的当前版本检查保存的版本号，如果出现差异，则会发出警告。这使您发现根据修改后的排序规则构建的某些索引可能不正确，应该重新构建。通过使用命令重建索引，</font></font><code>ALTER COLLATION ... REFRESH VERSION</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以更新数据库中排序规则的版本，并且不再发出警告。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但这仅适用于ICU。现在，版本号也存储为libc排序规则：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">SELECT</span> collname, collversion <span class="hljs-keyword">FROM</span> pg_collation <span class="hljs-keyword">WHERE</span> collname = <span class="hljs-string">'ru_RU'</span>;</code></pre><br>
<pre><code class="plaintext hljs"> collname | collversion<font></font>
----------+-------------<font></font>
 ru_RU    | 2.27</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当操作系统中的库发生更改时，可以发出警告。</font><font style="vertical-align: inherit;">鉴于向glibc 2.28的过渡非常相关，在glibc 2.28中，许多排序规则已更改，因此应重建相应的索引。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是直到他们切换到2.28，一切都变得平静了：</font></font><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLLATION</span> "ru_RU" <span class="hljs-keyword">REFRESH</span> <span class="hljs-keyword">VERSION</span>;</code></pre><br>
<pre><code class="plaintext hljs">NOTICE:  version has not changed<font></font>
ALTER COLLATION</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全文搜索</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全文搜索希腊语</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
没有评论。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dict_int学会了处理绝对值</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
。dict_int模板字典（又名扩展名）增加了从数字中删除符号的功能。</font></font><br>
<br>
<pre><code class="pgsql hljs">
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">EXTENSION</span> dict_int;
<span class="hljs-keyword">SELECT</span> ts_lexize(<span class="hljs-string">'intdict'</span>, <span class="hljs-string">'-123'</span>);</code></pre><br>
<pre><code class="plaintext hljs">ts_lexize<font></font>
-----------<font></font>
 {-123}<font></font>
(1 row)</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TEXT SEARCH</span> <span class="hljs-keyword">DICTIONARY</span> intdict (ABSVAL = <span class="hljs-keyword">true</span>);
<span class="hljs-keyword">SELECT</span> ts_lexize(<span class="hljs-string">'intdict'</span>, <span class="hljs-string">'-123'</span>);</code></pre><br>
<pre><code class="plaintext hljs">ts_lexize<font></font>
-----------<font></font>
 {123}<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
即，这次确认了绝对值。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分区</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分区表上的</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
行触发器</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;">之前</font></b></a><font style="vertical-align: inherit;">在版本12中，您不能</font></font><code>BEFORE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在分区表上</font><font style="vertical-align: inherit;">创建行触发器</font><font style="vertical-align: inherit;">。请在单独的部分上-但不要一次在整个表格上。现在，</font></font><code>BEFORE FOR EACH ROW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在分区表上创建</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">触发器将被自动继承并适用于所有部分。但是条件是，如果它是上的触发器</font></font><code>UPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则只能在当前部分中更改其中的分区键。</font></font><br>
<br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在逻辑复制中支持分区表</font></font></a></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
以前，在发布中包括分区表都会导致错误：</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PUBLICATION</span> pub <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">TABLE</span> p;</code></pre><br>
<pre><code class="plaintext hljs">ERROR:  "p" is a partitioned table<font></font>
DETAIL:  Adding partitioned tables to publications is not supported.<font></font>
HINT:  You can add the table partitions individually.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在可以了。</font></font><br>
<br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改进的分段JOIN算法</font></font></a></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
从第11版开始，调度程序可以逐节连接分区表，但前提是各节的边界完全匹配。</font><font style="vertical-align: inherit;">现在，该算法已得到改进：如果一个表的部分完全包含在另一个表的部分中，即使它们的大小不匹配（例如，如果一个表按天划分而另一个表按月划分），该算法也将起作用。</font><font style="vertical-align: inherit;">新算法可用于按范围和列表进行分区。</font></font><br>
<br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分段</font></font></a></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
完全外部联接现在，</font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">分段化</font></a></b><font style="vertical-align: inherit;">联接适用于用短语记录的完全外部联接</font></font><code>USING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">桌布</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这个有吸引力且充满希望但又困难的领域中，关于PostgreSQL 12并没有根本的进步。没有现成的插件存储（如</font></font><code>zheap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆以外的</font><font style="vertical-align: inherit;">插件存储</font><font style="vertical-align: inherit;">），但是API的工作仍在继续。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定表大小的更高层次的抽象方法</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Robert Haas重新编写了代码，更改了其结构以支持抽象层，因此将来不再需要复制代码。这是指</font></font><code>estimate_rel_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-表的层（叉）的大小。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以将表访问方法与relcache一起使用，</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
此修补程序将表访问方法的内存管理功能引入了索引方法的功能。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tableam和TOAST</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
TOAST主要用于存储</font></font><code>heap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，在创建新的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表访问方法时，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以采用两种方式：帮助新方法的开发人员将插入，更新和删除TOAST记录集成到其中，或者委托TOAST使用传统的PostgreSQL存储-堆进行编码。</font><font style="vertical-align: inherit;">一系列5个修补程序使用元组插槽来实现插入/更新/删除操作，并且可以帮助双向执行。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同步</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pg_receivewal和pg_recvologic中</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"> Fsync错误处理</font></b></a><font style="vertical-align: inherit;">继续</font><font style="vertical-align: inherit;">对抗</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fsync（）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 PostgreSQL认为成功的fsync（）调用意味着文件中的所有数据都已刷新到磁盘，但这并不总是会发生（取决于OS），并且可能导致数据丢失。 PG13认为有必要处理这些实用程序</font></font><code>pg_receivewal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>pg_recvlogical</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。当前，默认行为是这样的：这些实用程序会将fsync错误写入日志，恢复连接并继续进行，就好像什么都没发生一样。结果，WAL包含有关已成功复制的文件的信息，而实际上这些文件并未正确刷新到磁盘。因此最好中断该实用程序。还讨论了pg_dump，pg_basebackup，pg_rewind和pg_checksums的命运，但是到目前为止，它们仅限于这两个。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">防止对fsync（）设置不正确的标志的保护措施</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
此修补程序检查在接收到fsync（）的文件描述符时是否正确设置了标志-目录仅开放供读取，文件仅开放用于写入，或两者皆开放。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">备份与复制</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在到达恢复点之前的恢复过程中暂停</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
如果在恢复过程中WAL已经结束</font></font><code>recovery_target_time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且尚未达到</font><font style="vertical-align: inherit;">指定的WAL</font><font style="vertical-align: inherit;">，则服务器将完成恢复并进入正常操作模式。现在事实并非如此。如日志中所报告的，恢复过程将暂停，管理员将有机会插入丢失的WAL段并继续恢复。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ignore_invalid_pages参数</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
当副本上的恢复过程在WAL记录中找到指向无效页面的链接时，</font></font><code>panic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-a</font><font style="vertical-align: inherit;">发生</font><font style="vertical-align: inherit;">。启用它将有助于启用参数</font></font><code>ignore_invalid_pages</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。恢复将继续，可能会丢失完整性，数据和其他最严重的后果。该参数供服务器开发人员使用，在仍然需要尝试完成恢复并启动副本的情况下，应使用该参数。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在不重新启动</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sergey Kornilov的补丁程序的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;">情况下更改primary_conninfo</font></b></a><font style="vertical-align: inherit;">，该补丁程序允许您更改设置</font></font><code>primary_conninfo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>primary_slot_name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而</font></font><code>wal_receiver_create_temp_slot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无需重新启动服务器。实际上，为此，他们</font></font><code>recovery.conf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第12版中</font><font style="vertical-align: inherit;">放弃了该文件</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
Pg_basebackup </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">备份</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清单现在创建了一个“清单”-一个JSON文件，其中包含有关所进行的备份的信息（文件名和大小，必要的WAL文件以及所有内容的校验和）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新的pg_validatebackup实用程序检查备份是否符合清单，并使用pg_waldump实用程序检查恢复所需的WAL文件的可用性和正确性（这仅适用于备份本身内部的WAL文件，不适用于存档中的WAL文件）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这将使您能够检测到备份文件已损坏或消失，或者由于缺少必要的日志文件而使恢复变得不可能的情况。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">限制未读数据复制插槽复制</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
插槽是一种方便但危险的机制：如果客户端未按时从插槽读取数据，则未读WAL记录会占用服务器上的所有空间。现在使用参数</font></font><code>max_slot_wal_keep_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以限制未读数据可以占用的最大磁盘空间量。</font><font style="vertical-align: inherit;">如果在下一个检查点发现大小超出限制，则禁用该插槽，并释放该位置。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视窗</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows 10 </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">对Unix</font></a><font style="vertical-align: inherit;">套接字的支持Windows 10支持</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">Unix</font></a><font style="vertical-align: inherit;">域套接字，尽管默认情况下禁用它们。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文献资料</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文档中有两个新应用程序。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
经过长时间的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">讨论</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出现了附录M术语表</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">词汇表中目前有101个术语。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用变量来突出显示控制台实用程序的诊断消息的颜色的功能</font></font><code>PG_COLOR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">较早。</font><font style="vertical-align: inherit;">这是目前</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记录</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附录N.色彩支持</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Peter Eisentrout在此修补程序中的初衷是使彩色输出默认处于打开状态。</font><font style="vertical-align: inherit;">对于那些不想这样做的人，建议显式设置变量</font></font><code>NO_COLOR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，在讨论补丁的人们中，有更多的反对邮件颜色区分的反对者。</font><font style="vertical-align: inherit;">因此，他们决定只记录可用的机会。</font><font style="vertical-align: inherit;">我们在文档中获得了第一级的新部分。</font></font><br>
<br>
<hr><br>
<i>        PG13,  ,  PG14     . ,   . .</i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN493094/index.html">亚马逊仓库工人对冠状病毒传播发出警报</a></li>
<li><a href="../zh-CN493096/index.html">在iOS中添加深色主题</a></li>
<li><a href="../zh-CN493098/index.html">部署ASA VPN负载平衡群集</a></li>
<li><a href="../zh-CN493100/index.html">寻找简单的方法如何帮助初创企业实现激进的增长</a></li>
<li><a href="../zh-CN493102/index.html">全球自动化趋势：RPA开发</a></li>
<li><a href="../zh-CN493108/index.html">Cloudflare选择第十代边缘服务器的AMD处理器</a></li>
<li><a href="../zh-CN493110/index.html">如何委派远程工作-团队领导指南等</a></li>
<li><a href="../zh-CN493112/index.html">如何在6个月而不是3年内开始新业务</a></li>
<li><a href="../zh-CN493114/index.html">数据工程师如何观看数据</a></li>
<li><a href="../zh-CN493116/index.html">“更多的互动性！” 或TeamLead Conf 2020如何</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>