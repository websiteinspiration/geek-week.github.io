<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏻 🎊 🏠 ブルームフィルターが合わない場合 🎙️ 🧗🏿 🙋🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私は大学から、Burton Bloomにちなんで名付けられた確率論的データ構造であるBloomフィルターについて知っていました。しかし、私にはそれを使う機会がありませんでした。先月、そのような機会が現れました-そしてこの構造は文字通り私を魅了しました。しかし、すぐに彼女に欠陥が見つかりました。この記...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ブルームフィルターが合わない場合</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491132/"><img src="https://habrastorage.org/webt/7x/rh/8w/7xrh8wafuzqnbs-o1jpgzjxtruw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は大学から、</font><font style="vertical-align: inherit;">Burton Bloomにちなんで名付けられた確率論的データ構造である</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloomフィルター</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について知っていました</font><font style="vertical-align: inherit;">。しかし、私にはそれを使う機会がありませんでした。先月、そのような機会が現れました-そしてこの構造は文字通り私を魅了しました。しかし、すぐに彼女に欠陥が見つかりました。この記事は、ブルームフィルターに対する私の短い恋愛についての物語です。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IPスプーフィング</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を調査するプロセスで</font><font style="vertical-align: inherit;">は、受信パケットのIPアドレスをチェックして、データセンターの地理的な場所と比較する必要がありました。たとえば、イタリアからのパッケージはブラジルのデータセンターに移動しないでください。この問題は単純に見えるかもしれませんが、インターネットの絶え間なく変化する状況では、単純なものからはほど遠いものです。結局、次の内容を含む大きなテキストファイルを大量に蓄積したと言えば十分です。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7cf/4b4/f67/7cf4b4f67fdf8b4d8a88c2685051c15f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、解決されたIPアドレス192.0.2.1からのリクエストがCloudflareデータセンター番号107に記録されたことを意味します。このデータは、アクティブサンプルとパッシブサンプル、所有する一部のドメインのログ（たとえば、</font></font><code>cloudflare.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、オープンソース（BGPテーブルなど）など。通常、同じ行が複数のファイルで繰り返されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結局、私はこの種の巨大なデータセットを手に入れました。</font><font style="vertical-align: inherit;">ある時点で、収集されたすべてのソースで、10億行を数えました。</font><font style="vertical-align: inherit;">通常、入力データを前処理するためのbashスクリプトを記述しますが、このスケールではこのアプローチは機能しませんでした。</font><font style="vertical-align: inherit;">例えば、600のMIB 40万行のこの小さなファイルから重複を除去することは取る...永遠：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bfa/dc1/9c0/bfadc19c083b6a31bc34b568cdc81d74.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
十分ではそれはタイプの通常のコマンドを使用して、その重複排除ラインと言って</font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、さまざまな構成（参照では</font></font><code>--parallel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>--buffer-size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">との</font></font><code>--unique</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）このような大規模なデータセットのための最高ではなかったです。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブルームフィルター</font></font></h1><br>
<img src="https://habrastorage.org/getpro/habr/post_images/3a6/110/0e6/3a61100e64277b6a515666b8bf0293f9.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パブリックドメイン</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">の</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デイビッドエプスタインの</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">イラスト</font></a></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
その後、それは私に気づきました：行を並べ替えないでください！重複を削除する必要があるため、ある種の「セット」データ構造がはるかに速く機能します。さらに、入力ファイルのサイズ（一意の行数）を大まかに把握しており、一部のデータの損失は重要ではありません。つまり、確率的データ構造は非常に適しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはブルームフィルターに最適です！</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ブルームフィルターに関するウィキペディアを</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読んでいる間</font><font style="vertical-align: inherit;">、これがこのデータ構造の見方です。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">複数を</font></a><font style="vertical-align: inherit;">
どのように実装</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">し</font></a><font style="vertical-align: inherit;">ますか？理想的なハッシュ関数と無限のメモリが与えられた場合、無限のビットマップを作成し、各要素にビット数を設定するだけです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><code>hash(item)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、「多数」に理想的なデータ構造を提供します。</font><font style="vertical-align: inherit;">正しい？</font><font style="vertical-align: inherit;">ささいなこと。</font><font style="vertical-align: inherit;">残念ながら、ハッシュ関数は衝突し、無限のメモリは存在しないため、現実には妥協する必要があります。</font><font style="vertical-align: inherit;">しかし、衝突の確率を計算して、この値を管理することができます。</font><font style="vertical-align: inherit;">たとえば、優れたハッシュ関数と128 GBのメモリがあります。</font><font style="vertical-align: inherit;">新しい各要素の衝突確率は1099511627776で1であると計算できます。さらに要素を追加すると、ビットマップが塗りつぶされるにつれて確率が増加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、複数のハッシュ関数を適用して、より高密度のビットマップを取得できます。</font><font style="vertical-align: inherit;">これは、ブルームフィルターが適切に機能する場所です。これは、4つの変数を持つ数学データのセットです。</font></font><br>
<br>
<ul>
<li><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -挿入された要素の数（基数）</font></font><br>
</li>
<li><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -ビットマップが使用するメモリ</font></font><br>
</li>
<li><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -各入力に対して計算されたハッシュ関数の数</font></font><br>
</li>
<li><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -偽陽性の一致の確率</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基数</font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と必要な誤検知の確率が</font><font style="vertical-align: inherit;">与えられると、</font></font><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブルームフィルターは必要なメモリ</font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と必要な数のハッシュ関数を</font><font style="vertical-align: inherit;">返します</font></font><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">パラメーターが互いにどのように影響するかについて</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">、</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">優れた</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thomas Hurst </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">視覚化を</font></a><font style="vertical-align: inherit;">チェックしてください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-bloom</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
直感に導かれ、確率ツールmmuniq-bloomを武器に追加しました。これは、入力STDINを取得し、STDOUTに一意の行のみを返します。</font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+の</font><font style="vertical-align: inherit;">組み合わせよりもはるかに高速</font></font><code>uniq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで彼は：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-bloom.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単かつ迅速にするために、最初にいくつかのパラメーターを設定します。まず、特に明記しない限り、mmuniq-bloomは8つのハッシュ関数k = 8を使用します。これはデータサイズに最適な数に近いようで、ハッシュ関数は8つのまともなハッシュをすばやく生成できます。次に</font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ビットマップ</font><font style="vertical-align: inherit;">のメモリ</font><font style="vertical-align: inherit;">を2の累乗に</font><font style="vertical-align: inherit;">アラインメントし</font></font><code>%modulo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て、アセンブラでの処理が遅くなる</font><font style="vertical-align: inherit;">高価な操作を回避</font><font style="vertical-align: inherit;">します</font></font><code>div</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。配列が2の累乗に等しい場合は、ビット単位のANDを使用できます（楽しいために</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コンパイラーが魔法の定数を掛けて除算演算を最適化する方法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をお読みください</font><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、前に使用したのと同じデータファイルで実行できます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3fa/019/d05/3fa019d05b8d6a72ad1ea3bde9c15a19.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ああ、それはずっと良いです！ 2分ではなく12秒。プログラムは、最適化されたデータ構造、比較的限られた量のメモリ、最適化された行の解析、優れた出力バッファリングを使用します...これらすべてを使用すると、ツールと比較して12秒は永遠に思えます</font></font><code>wc -l</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/953/ede/adb/953edeadb5701d03f92c7717f159f20d.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何が起こっているのですか？</font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一意の文字列を計算するよりも</font><font style="vertical-align: inherit;">文字列を数える</font><font style="vertical-align: inherit;">ほう</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">簡単</font><font style="vertical-align: inherit;">だと理解しています</font><font style="vertical-align: inherit;">が、26回の違いは本当に正当化されますか？ CPUは何を取り込み</font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハッシュを計算するためのものでなければなりません。ユーティリティ</font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はプロセッサを使わず、4,000万行ごとにこの奇妙な計算をすべて実行します。私はどちらかと言えば重要なハッシュ関数を使用していますが、</font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それは確かにプロセッサを焼きますよね？のが唯一のハッシュ関数を実行することによって検証してみましょう、しかし、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ではありません</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブルームフィルターで操作を実行しない：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f5e/7a0/e0f/f5e7a0e0f26a3136ca3d0a9b362e0fe3.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは奇妙です。</font><font style="vertical-align: inherit;">ハッシュ関数の計算には約2秒しかかかりませんが、前の実行のプログラム全体が12秒間実行されました。</font><font style="vertical-align: inherit;">1つのBloomフィルターが10秒間機能しますか？</font><font style="vertical-align: inherit;">これはどのようにして可能ですか？</font><font style="vertical-align: inherit;">これはとてもシンプルなデータ構造です...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">秘密兵器-プロファイラー</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このタスクに適切なツールを適用する時が来ました-プロファイラーを実行して、プロセッサーが何に取り組んでいるかを見てみましょう。最初に実行</font></font><code>strace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して、予期しないシステムコールがないことを確認し</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7bc/29b/87c/7bc29b87cdeadac9a11ce78aa61129f6.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。</font></font><code>mmap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それぞれ4ミリ秒（3971μs）</font><font style="vertical-align: inherit;">への10回の呼び出し</font><font style="vertical-align: inherit;">は興味深いものですが、それで十分です。</font></font><code>MAP_POPULATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ページの不足によるエラーを後で防ぐ</font><font style="vertical-align: inherit;">ために、メモリを事前に埋め</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のステップは何ですか？もちろんです</font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/1da/aa8/acc/1daaa8acc9e3a84d1f591ad94cd84387.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、結果を見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/637/38f/3e2/63738f3e2a4bb1207927ecbc45b0cf3b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、メインコードでサイクルの87.2％を実際に書き込みます。正確にどこを見ようか。チームは</font></font><code>perf annotate process_line --source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すぐに予期しない何かを示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/17f/f6f/cc8/17ff6fcc833def72269a07f7fd54d9f0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセッサの26.90％が</font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、しかしそれだけではありません！コンパイラは関数を正しく挿入し、ループを展開します。サイクルのほとんどはこれに行く</font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か、ラインに</font><font style="vertical-align: inherit;">行くことがわかります</font></font><code>uint64_t v = *p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5c0/a3e/59c/5c0a3e59c8f954146bed3b2f1478e0ba.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかにperfは間違っています。このような単純な文字列がどのように多くのリソースを消費するのでしょうか。ただし、他のプロファイラーでテストを繰り返すと、同じ問題が発生します。たとえば、カラフルな図のために、kcachegrindでgoogle-perftoolsを使用したいと思い</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8af/fbd/e9e/8affbde9e2b92d4da89d445314ec4654.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。視覚化の結果は次のとおりです</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/130/ea3/9f9/130ea39f9a8c6a22c252381c3af88045.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。これまでに発見したことを要約してみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準ユーティリティ</font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、600 MiBのファイルを0.45秒のプロセッサ時間で処理します。最適化されたツール</font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は12秒で実行</font><font style="vertical-align: inherit;">されます</font><font style="vertical-align: inherit;">。プロセッサは1つの命令</font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で書き込まれ、メモリを逆参照します...</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6aa/3dd/e6a/6aa3dde6a6562dad5d0b3b2fa94c4565.jpg"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jose Nicdaoの</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">画像</font></a><font style="vertical-align: inherit;">、CC BY / 2.0</font></font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ああ！忘れられる訳がない。メモリへのランダムアクセスは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本当に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遅いです！とても、とても、とても遅い！</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">すべてのプログラマが知っておくべき数字に</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
よると、</font><font style="vertical-align: inherit;">RAMへの1回のアクセスには約100 nsかかります。数えましょう：4000万行、各8ハッシュ。ブルームフィルターのサイズは128 MiBであるため</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">、古いハードウェア</font></a><font style="vertical-align: inherit;">ではL3キャッシュに適合しません。ハッシュは広範囲のメモリに均等に分散されます-ハッシュはそれぞれキャッシュミスを生成します。すべてをまとめると、判明します...</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b54/7e8/2e6/b547e82e6368f26843834121b1765103.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
32秒は、メモリアクセスでのみバーンアウトすることがわかりました。ブルームフィルターはまだキャッシュの恩恵を受けるため、実際のプログラムはわずか12秒で収まります。これは簡単に確認できます</font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2b8/199/785/2b8199785c666437f37b9d96c209670f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、最低3億2000万のキャッシュミス（LLC-load-misses）が発生しているはずですが、発生したのは2億8千万だけです。これでも、プログラムが12秒で動作した理由</font><font style="vertical-align: inherit;">はわかり</font><font style="vertical-align: inherit;">ません。しかし、それは問題ではない。キャッシュミスの数が実際の問題であることは重要であり、メモリアクセスの数を減らすことによってのみ解決できます。 1つのハッシュ関数のみを使用するようにブルームフィルターを構成してみましょう</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/052/bec/d4f/052becd4ffe91553d1d3b01bfa53755b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。本当に痛い！ 10,000ラインあたり1の衝突確率を得るには、ブルームフィルターに64ギガバイトのメモリが必要でした。ひどい！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、速度が大幅に上がったようには見えません。</font><font style="vertical-align: inherit;">オペレーティングシステムがメモリを準備するのに22秒かかりましたが、それでもユーザー空間で11秒を費やしました。</font><font style="vertical-align: inherit;">今では、メモリへのアクセスがまれであるというすべての利点は、メモリサイズが急激に増加したためにキャッシュに入る可能性が低くなることで補われていると思います。</font><font style="vertical-align: inherit;">以前は、ブルームフィルターには128 MiBで十分でした！</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブルームフィルターの拒否</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはとんでもないことになっています。</font><font style="vertical-align: inherit;">誤検知の可能性を減らすには、メモリアクセスが多いブルームフィルターで多くのハッシュ（たとえば、8）を使用するか、1つのハッシュ関数を残して大量のメモリを使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際にはメモリの制限はありません。呼び出しの数を最小限に抑えたいのです。</font><font style="vertical-align: inherit;">要素ごとに最大1つのキャッシュミスが発生し、64ギガバイト未満のRAMを使用するデータ構造が必要です... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カッコウフィルター</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの複雑なデータ構造を実装することもできますが</font><font style="vertical-align: inherit;">、より簡単なオプションがあります。</font><font style="vertical-align: inherit;">古き良き線形プローブハッシュテーブルはどうですか？</font><i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ヴァディムスポダンの</font></a></font></i></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c29/a0d/136/c29a0d136e80e5fc0a6f90f1cab1378e.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イラスト</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-hashの紹介</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ハッシュテーブルを使用したmmuniq-bloomの新しいバージョンを示します。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-hash.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブルームフィルターのビットの代わりに、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「siphash24」関数</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からの64ビットハッシュを格納し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これにより、ハッシュの衝突に対するはるかに優れた保護が提供されます。10,000行あたり1行よりもはるかに優れています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数えてみましょう。</font><font style="vertical-align: inherit;">ハッシュテーブルに新しいアイテムを追加すると、たとえば4,000万のエントリがあると、ハッシュが衝突する可能性があります</font></font><code>40 000 000/2^64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、4,610億分の1であり、確率はかなり低くなります。</font><font style="vertical-align: inherit;">ただし、事前に入力されたセットには1つの要素を追加しません。</font><font style="vertical-align: inherit;">代わりに、最初の空のセットに4000万行を追加します。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">誕生日のパラドックスに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">よると</font><font style="vertical-align: inherit;">、これは衝突の可能性を大幅に高めます。</font><font style="vertical-align: inherit;">妥当な概算は概算です</font></font><code>'~n^2/2m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、私たちの場合は</font></font><code>~(40M^2)/(2*(2^64))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。つまり、23,000の確率のうち1つが判明します。つまり、優れたハッシュ関数を使用すると、4,000万要素の23,000のランダムセットの1つで衝突が発生することが予想されます。これはゼロ以外の確率ですが、ブルームフィルターよりも優れており、このユースケースでは完全に許容できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハッシュテーブルを使用したコードは、ブルームフィルターよりも高速に動作し、メモリアクセスパターンが向上し、誤検知の可能性が低くなります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/0ea/5c5/817/0ea5c5817289f136355f452748da0f86.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「ハッシュの競合」の行に驚かないでください。ハッシュテーブルがどれだけいっぱいであるかを示すだけです。</font><font style="vertical-align: inherit;">リニアセンシングを使用しているので、フルセットに入ると、次の空のセンサーを使用します。</font><font style="vertical-align: inherit;">この例では、テーブル内の空のスポットを見つけるために、平均0.7セットをスキップする必要があります。</font><font style="vertical-align: inherit;">これは正常です。</font><font style="vertical-align: inherit;">セットを線形順序で反復するため、メモリは質的に満杯でなければなりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前の例から、ハッシュ関数には約2秒かかることがわかります。</font><font style="vertical-align: inherit;">4,000万回のメモリアクセスには約4秒かかると結論付けています。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">学んだ教訓</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最新のプロセッサは、サンプリングパターンを予測できる場合、メモリへの順次アクセスに非常に優れています（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュのプリフェッチを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照</font><font style="vertical-align: inherit;">）。一方、メモリへのランダムアクセスは非常にコストがかかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高度なデータ構造は非常に興味深いですが、注意してください。最近のコンピューターでは、キャッシュ最適化アルゴリズムを使用する必要があります。 L3に収まらない大きなデータセットを操作する場合は、使用されるメモリ量を最適化するのではなく、ヒット数を最適化することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブルームフィルターは、L3キャッシュに配置したときに優れたパフォーマンスを発揮すると言っても過言ではありません。しかし、そうでなければ、彼らはひどいです。これはニュースではありません。ブルームフィルターは、呼び出し回数ではなく、メモリの量に対して最適化されています。たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カッコウフィルターに関する科学記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つは、ハッシュ関数に関する無限の議論です。正直なところ、ほとんどの場合、これは問題になりません。複雑なハッシュ関数を数える</font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コストは、メモリへのランダムアクセスのコストと比較して小さい</font><font style="vertical-align: inherit;">よう</font><font style="vertical-align: inherit;">です。私たちの場合、ハッシュ関数を単純化してもわずかなメリットしかありません。 CPU時間が他のどこかで無駄になっている-メモリを待っている！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ある同僚はよく言います：「現代のプロセッサーは無限に高速であると想定できます。彼ら</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は記憶</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">壁に寄りかかる</font></a><font style="vertical-align: inherit;">まで、無限の速度で働き</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、私の間違いを繰り返さないでください。常に最初にプロファイリングを実行する必要があります</font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IPCカウンター（サイクルごとの命令）を確認します。</font><font style="vertical-align: inherit;">1未満の場合、これは通常、プログラムがメモリを待機してスタックしていることを意味します。</font><font style="vertical-align: inherit;">最適値は2を超えています。</font><font style="vertical-align: inherit;">つまり、ワークロードは主にCPUにあります。</font><font style="vertical-align: inherit;">残念ながら、私の仕事では、IPCはまだ低いです...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">優れたmmuniq</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同僚の助けを借りて、ハッシュテーブルに基づいたmmuniqツールの改良版を作成しました。</font><font style="vertical-align: inherit;">これがコードです：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハッシュテーブルのサイズを動的に変更でき、任意の基数での入力をサポートします。</font><font style="vertical-align: inherit;">次に</font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、CPU </font><font style="vertical-align: inherit;">のヒント</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">効果的に使用してデータをパケットで処理</font><font style="vertical-align: inherit;">し、プログラムを35〜40％高速化します。</font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを</font><font style="vertical-align: inherit;">大量に使用</font><font style="vertical-align: inherit;">しても効果はほとんどありません。</font><font style="vertical-align: inherit;">この関数を使用するために、アルゴリズムを特別に並べ替えました。</font><font style="vertical-align: inherit;">すべての改善により、実行時間は2.1秒に短縮されました。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e40/4df/9c4/e404df9c42a97be2f1051a69f98116e6.png"><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">終わり</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「sort / uniq」の組み合わせよりも優れた基本的なツールを作成することで、現代のコンピューティングの隠れた機能が明らかになりました。</font><font style="vertical-align: inherit;">少し汗を流して、プログラムを2分以上から2秒に加速しました。</font><font style="vertical-align: inherit;">開発中に、メモリへのランダムアクセスの遅延と、キャッシュに適したデータ構造の能力について学びました。</font><font style="vertical-align: inherit;">奇妙なデータ構造が注目を集めていますが、実際には、メモリへのランダムアクセスの数を減らす方が効率的であることがよくあります。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja491116/index.html">最新の識別標準：OAuth 2.0、OpenID Connect、WebAuthn</a></li>
<li><a href="../ja491118/index.html">開発者の心：第5世代コンソールの開発キット（パート1）</a></li>
<li><a href="../ja491120/index.html">$ mol：4年後</a></li>
<li><a href="../ja491122/index.html">HiSuiteバックアップのフォレンジック分析</a></li>
<li><a href="../ja491130/index.html">覚えておくべきVueの機能</a></li>
<li><a href="../ja491134/index.html">ISO / IEC 27001認証の採用の必然性の5段階。否定</a></li>
<li><a href="../ja491136/index.html">Angularまたは失われたng-contentドキュメントのコンテンツの投影</a></li>
<li><a href="../ja491138/index.html">衛星とAnsible Towerの統合</a></li>
<li><a href="../ja491146/index.html">開発者向けUML</a></li>
<li><a href="../ja491150/index.html">詐欺師、またはフィッシングパネルの内部だけをハッキングする方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>