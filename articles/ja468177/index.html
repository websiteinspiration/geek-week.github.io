<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏻 ⤵️ 🚏 Gitの内側と外側 🙍🏽 🕴🏽 📴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="バージョン管理システムの内部で機能する能力は、すべてのプログラマーが必要とするスキルです。多くの場合、Gitを掘り下げてその内部を理解することは余分な時間の浪費であり、基本的なタスクは基本的なコマンドのセットを介して解決できると思われるかもしれません。
 
 もちろん、AppsCastチームは詳細を...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Gitの内側と外側</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/468177/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バージョン管理システムの内部で機能する能力は、すべてのプログラマーが必要とするスキルです。多くの場合、Gitを掘り下げてその内部を理解することは余分な時間の浪費であり、基本的なタスクは基本的なコマンドのセットを介して解決できると思われるかもしれません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、AppsCastチームは詳細を知りたいと考え、Gitのすべての機能を実際に適用するためのアドバイスを求めて、彼らは</font><font style="vertical-align: inherit;">Square </font><font style="vertical-align: inherit;">から</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yegor Andreyevich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に&nbsp; </font><b><font style="vertical-align: inherit;">問い合わせました</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/nd/kg/wxndkg7_giwgsbmreljpv-0h5l4.jpeg"><br>
<a name="habracut"></a><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daniil Popov</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：みなさん、こんにちは。今日、SquareのYegor Andreyevichが参加しました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Egor Andreyevich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：みなさん、こんにちは。私はカナダに住んでいて、金融業界のソフトウェアおよびハードウェア会社であるSquareに勤務しています。クレジットカード決済の端末から始め、現在は事業主様向けのサービスを行っております。私はCash App製品に取り組んでいます。これは、友達とお金を交換したり、店舗での支払い用にデビットカードを注文したりできるモバイル銀行です。同社には世界中に多くのオフィスがあり、カナダのオフィスには約60人のプログラマーがいます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daniil Popov</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：Android開発者の間で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Square</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">業界標準となったオープンソースプロジェクトで知られています：OkHttp、Picasso、Retrofit。</font><font style="vertical-align: inherit;">このようなツールを開発することは誰にとってもオープンであり、Gitを使用することは当然です。</font><font style="vertical-align: inherit;">これについてお話したいと思います。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gitとは何ですか？</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Egor Andreevich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：私はGitをツールとして長い間使用してきましたが、ある時点で、それについて詳しく知ることが興味深いものになりました。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gitは単純化されたファイルシステムであり、その上にバージョン管理を操作するための一連の操作があります。 </font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gitでは、特定の形式でファイルを保存できます。ファイルを書き込むたびに、Gitはオブジェクトにキー（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハッシュ）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を返します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daniil Popov</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：多くの人が、リポジトリに魔法の隠しディレクトリ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.git</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があることに気づきました</font><font style="vertical-align: inherit;">。なぜそれが必要なのですか？削除したり、名前を変更したりできますか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Egor Andreevich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：リポジトリの作成は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">git init</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コマンドで可能</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">Gitがファイルの制御に使用する</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.git</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディレクトリ</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">作成し</font><font style="vertical-align: inherit;">ます。で</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.git</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトでやっている店のすべてが、圧縮形式になっています。したがって、このディレクトリからリポジトリを復元できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アレクセイ・クドリャフツェフ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：プロジェクトフォルダーが展開されたGitフォルダーのバージョンの1つであることがわかりましたか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Egor Andreevich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：現在のブランチに応じて、gitは作業可能なプロジェクトを復元します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexei Kudryavtsev</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：フォルダーの中身は何ですか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Egor Andreevich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：Gitは特定のフォルダーとファイルを作成します。最も重要なフォルダは、すべてのオブジェクトが格納される.git / objectsです。最も単純なオブジェクトはblobで、基本的にファイルと同じですが、gitが理解できる形式です。テキストファイルをリポジトリに保存する場合、Gitはそれを圧縮し、アーカイブし、データを追加して、blobを作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディレクトリがあります-これらはサブフォルダーを持つフォルダーです。 Gitには、</font><font style="vertical-align: inherit;">ブロブや他のツリーへの参照を含む</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ツリー</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトタイプ</font><font style="vertical-align: inherit;">があります。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本的に、1つのツリーは、特定の時点でのディレクトリの状態を表すスナップショットです。 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コミットを作成するとき、作業ディレクトリへのリンクが修正されました-ツリー。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コミットはツリーへのリンクであり、誰が作成したかに関する情報が含まれています：電子メール、名前、作成時間、親（親ブランチ）へのリンク、メッセージ。</font><font style="vertical-align: inherit;">また、Gitはコミットを圧縮してオブジェクトディレクトリに書き込みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがどのように機能するかを確認するには、コマンドラインからサブディレクトリのリストを表示する必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gitを使用する利点</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daniil Popov</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：Gitはどのように機能しますか？アクションアルゴリズムがなぜそれほど複雑なのですか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Egor Andreevich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：GitをSubversion（SVN）と比較すると、最初のシステムには理解する必要のある関数がいくつかあります。まず</font><font style="vertical-align: inherit;">、Gitの制限ではなく、機能</font><font style="vertical-align: inherit;">である&nbsp; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステージング領域</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードを操作するときに、すべてがすぐに機能するわけではないことはよく知られています。どこかでレイアウトを変更する必要がある場所、どこかでバグを修正する必要があります。その結果、作業セッションの後、相互接続されていない影響を受けるファイルがいくつか表示されます。 1回のコミットですべての変更を行うと、変更の性質が異なるため、不便になります。次に、一連のコミットが出力されます。これは、ステージング領域のおかげで作成できます。たとえば、レイアウトファイルへのすべての変更が1つのシリーズに送信されます。たとえば、単体テストの修正が別のシリーズに送信されます。私たちはいくつかのファイルを取得し、それらをステージング領域に移動して、参加した場合のみコミットを作成します。作業ディレクトリにある他のファイルはそこには含まれません。したがって、作業ディレクトリで実行されたすべての作業を、それぞれが特定の作業を表すいくつかのコミットに分割します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アレクセイ・クドリャフツェフ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：Gitは他のバージョン管理システムとどう違うのですか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Egor Andreevich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：個人的には、SVNから始めてすぐにGitに切り替えました。重要なことに、Gitは分散型バージョン管理システムです。 Gitリポジトリのすべてのコピーはまったく同じです。各会社にはメインバージョンが配置されているサーバーがありますが、開発者がコンピューター上に持っているサーバーと同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SVNには中央リポジトリとローカルコピーがあります。つまり、すべての開発者が中央リポジトリだけを壊すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gitでは、これは起こりません。中央サーバーがリポジトリデータを失った場合、任意のローカルコピーから復元できます。 Gitは異なる方法で設計されており、速度の利点を提供します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダニイル・ポポフ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：Gitはその分岐で有名で、SVNよりも著しく高速に実行されます。</font><font style="vertical-align: inherit;">彼はそれをどのように行うのですか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Egor Andreevich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：SVNでは、ブランチは前のブランチの完全なコピーです。</font><font style="vertical-align: inherit;">Gitにはブランチの物理表現はありません。</font><font style="vertical-align: inherit;">これは、特定の開発ラインの最後のコミットへのリンクです。</font><font style="vertical-align: inherit;">Gitがオブジェクトを保存すると、コミットの作成時に、コミットに関する特定の情報を含むファイルが作成されます。</font><font style="vertical-align: inherit;">Gitはシンボリックファイルを作成します-別のファイルへのリンクを持つシンボリックリンク。</font><font style="vertical-align: inherit;">多くのブランチがある場合、リポジトリ内のさまざまなコミットを参照します。</font><font style="vertical-align: inherit;">ブランチの履歴を追跡するには、リンクを使用して各コミットから親のコミットに戻る必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merjimブランチ</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daniil Popov</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：2つのブランチを1つにマージするには2つの方法があります。これはマージとリベースです。それらをどのように使用しますか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Egor Andreevich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：それぞれの方法には、独自の長所と短所があります。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マージ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;は最も簡単なオプションです。たとえば、マスターとそこから選択した機能の2つのブランチがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マージには、早送りを使用できます。これは、機能ブランチで作業が開始された瞬間から、マスターで新しいコミットが行われなかった場合に可能です。つまり、機能の最初のコミットはマスターの最後のコミットです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、ポインターはマスターブランチに固定され、機能ブランチの最新のコミットに移動します。このように、機能分岐をメインマスタースレッドに接続し、不要な分岐を削除することで、分岐がなくなります。結果は、すべてのコミットが互いに続く線形履歴です。実際には、このオプションはまれに発生します。なぜなら、常に誰かがコミットをマスターにマージするからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それ以外の場合もあります。 Gitは新しいコミット-マージコミットを作成します。これには、親コミットへの2つの参照があります。1つはマスターで、もう1つは機能です。新しいコミットでは、2つのブランチが接続され、機能を再度削除できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マージコミット後、ストーリーを見て、分岐していることを確認できます。グラフィカルにコミットをレンダリングするツールを使用すると、視覚的にはクリスマスツリーのように見えます。これはGitを壊しませんが、開発者がそのような話を見るのは困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のツールは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rebase</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。概念的には、機能ブランチからすべての変更を取り、それをマスターブランチで裏返します。最初の機能コミットは、最新のマスターコミットに加えて新しいコミットになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
落とし穴があります-Gitはコミットを変更できません。機能にコミットがあり、コミットごとにタイムスタンプがあるため、マスターの上にラップすることはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リベースの場合、Gitは機能内のすべてのコミットを読み取り、一時的に保存してから、同じ順序でマスターに再作成します。リベース後、最初のコミットは消え、同じ内容の新しいコミットがマスターの上に表示されます。問題があります。他の人が作業しているブランチをリベースしようとすると、リポジトリを壊すことができます。たとえば、誰かが機能しているコミットからブランチを開始し、そのコミットを破棄して再作成したとします。リベースは、ローカルブランチにより適しています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daniil Popov</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ある機能ブランチで厳密に1人が作業するという制限を導入する場合、ある機能ブランチを別の機能ブランチからバディできないことに同意すると、この問題は発生しません。しかし、どのようなアプローチを実践していますか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エゴール・アンドレエヴィッチ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：この用語の直接的な意味での機能ブランチは使用しません。変更を加えるたびに、新しいブランチを作成して作業し、すぐにマスターに注ぎます。長期にわたるブランチはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、マージとリベースに関する多くの問題、特に競合が解決されます。ブランチは1時間存在し、マスターに何も追加していないため、早送りを使用する可能性が高くなります。私たちは、プルリクエストでマージを行うと、その後、唯一のマージを作成してマージコミット</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダニール・ポポフを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：時間間隔にタスクを分解することはしばしば非現実的であるため、どのようにして、マスターアイドル機能をマージすることを恐れていませんか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Egor Andreevich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><b><font style="vertical-align: inherit;">機能フラグ</font></b><font style="vertical-align: inherit;">アプローチを使用し</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これらは動的フラグであり、さまざまな状態を持つ特定の機能です。たとえば、相互に支払いを送信する機能は、オンまたはオフになります。この状態を動的にお客様に届けるサービスがあります。あなたはサーバーからあなたがオフ機能の価値を得るかどうか。この値をコードで使用できます-画面に移動するボタンをオフにします。コード自体はアプリケーション内にあり、リリースできますが、機能フラグの背後にあるため、この機能にアクセスできません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daniil Popov</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：多くの場合、Gitの初心者は、リベース後に力を入れてプッシュする必要があると言われています。これ、どこから来たの？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エゴール・アンドレエヴィッチ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：単にプッシュすると、別のリポジトリがエラーをスローする場合があります。ブランチをプッシュしようとしているのに、このブランチで完全に異なるコミットが行われています。 Gitはすべての情報をチェックするので、誤ってリポジトリを壊すことはありません。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">git push force</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と言ったら</font><font style="vertical-align: inherit;">、このチェックをオフにして、あなたが彼よりもよく知っていると信じて、ブランチの書き換えを要求します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リベース後にこれが必要なのはなぜですか？リベースはコミットを再作成します。ブランチも呼び出されていることがわかりましたが、他のハッシュを使用してコミットし、Gitはあなたに誓います。この状況では、ユーザーが状況を制御しているため、強制プッシュを実行することは絶対に正常です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daniil Popov</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インタラクティブなリベース</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の概念はまだあり</font><font style="vertical-align: inherit;">、多くはそれを恐れています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エゴール・アンドレエヴィッチ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ひどいものは何もありません。 Gitはリベース中にストーリーを再作成するため、スローする前に一時的に保存します。一時的なストレージがある場合、コミットで何でもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
対話モードでのリベースは、リベースの前にGitがテキストエディターウィンドウをポップアップし、そこで個々のコミットで何を実行する必要があるかを指定できることを前提としています。数行のテキストのように見えます。各行は、ブランチにあるコミットの1つです。各コミットの前に、実行する価値のある操作の兆候があります。最も単純なデフォルトの操作は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pickです</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。つまり、取り、リベースに含める。最も一般的なのは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">squash</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、Gitはこのコミットからの変更を取得して、以前のコミットからの変更とマージします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの場合、そのようなシナリオがあります。</font><font style="vertical-align: inherit;">ブランチでローカルに作業し、保存用のコミットを作成しました。</font><font style="vertical-align: inherit;">その結果、コミットの長い履歴が作成されます。これは興味深いことですが、同じようにメインの履歴に流すべきではありません。</font><font style="vertical-align: inherit;">次に、スカッシュで一般的なコミットに名前を変更します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チームのリストは長いです。</font><font style="vertical-align: inherit;">あなたはコミットを投げることができます- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドロップする</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と消えます、コミットメッセージを変更できます、など </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexei Kudryavtsev</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：インタラクティブなリベースで競合がある場合、地獄のすべてのサークルを通過します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Egor Andreevich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：私はインタラクティブなリベースのすべての知識を理解するのは非常に遠いですが、それは強力なツールであり、複雑です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実用的なGitアプリケーション</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daniil Popov</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：練習に移りましょう。インタビューで、私はしばしば尋ねます。最初はすべてが順調で、1000回目のテストが失敗しました。ジータの助けを借りて、これにつながった変化をどのように見つけることができますか？」</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Egor Andreevich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：この状況では、</font><font style="vertical-align: inherit;">責任を取る方が簡単ですが、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bisect</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用する必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
面白いものから始めましょう。 Git bisectは、リグレッションがある状況に適用できます-機能しましたが、機能しましたが、突然停止しました。機能が壊れたときを見つけるために、理論的にはアプリケーションの以前のバージョンにランダムにロールバックしてコードを見ることができますが、構造化された問題へのアプローチを可能にするツールがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Git bisectはインタラクティブなツールです。壊れたコミットとgit bisect goodの存在を報告するためのgit bisect badコマンドがあります。アプリケーションがリリースされるたびに、リリース元のコミットのハッシュが記憶されます。このハッシュは、悪いコミットと良いコミットを示すためにも使用できます。 Bisectは、コミットの1つが機能を破壊した間隔に関する情報を受け取り、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイナリ検索</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セッションを開始します。そこで、コミットが</font><font style="vertical-align: inherit;">徐々に</font><font style="vertical-align: inherit;">機能</font><font style="vertical-align: inherit;">するかどうかを確認するためにコミットが発行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セッションを開始すると、Gitはインターバル内のいずれかのコミットに切り替え、これを報告します。千回のコミットの場合、多くの繰り返しはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検証は手動で行う必要があります。ユニットテストを使用するか、アプリケーションを実行して手動でクリックします。 Git bisectは便利にスクリプト可能です。彼がコミットを発行するたびに、コードが機能していることを確認するためのスクリプトを彼に与えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Blameは、その名前に基づいて、機能障害の「危険」を見つけることができる、よりシンプルなツールです。この否定的な定義のために、非難コミュニティの多くはそれを好きではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼は何をしているの？ git blameに特定のファイルを指定すると、このファイルで直線的に表示され、どのコミットがこの行またはその行を変更したかが示されます。コマンドラインからgit blameを使用したことはありません。原則として、これはIDEAまたはAndroid Studioで行われます。クリックして、誰がファイルのどの行をどのコミットで変更したかを確認します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダニイル・ポポフ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ちなみに、Android StudioではAnnotateと呼ばれていました。非難の否定的な意味合いを削除しました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexei Kudryavtsev</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：まさに、xCodeでは、彼らの名前をAuthorsに変更しました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Egor Andreevich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：私はまた、この素晴らしいコードを書いた人を見つけるために、git賞賛のユーティリティがあることも読みました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daniil Popov</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：プルリクエストの作業についての査読者の非難提案については注意が必要です。彼は何よりも特定のファイルに誰が触れたのかを調べ、この人があなたのコードをよくレビューできるようにすることを提案しています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
約1000のコミットの例の場合、99％のケースの非難は何が問題だったかを示します。バイセクトはすでに最後の手段です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エゴール・アンドレエヴィッチ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：はい、二分法を使用することはほとんどありませんが、注釈を定期的に使用しています。</font><font style="vertical-align: inherit;">コードの行からはなぜnullチェックが存在するのか理解できない場合がありますが、作成者が何をしたかったのかはコミット全体を通して明らかです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタックされたPRを使用するには</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daniil Popov</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：Squareがスタックプルリクエスト（PR）を使用していると聞きました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Egor Andreevich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：少なくとも私たちのAndroidチームでは、それらを頻繁に使用しています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは、各プルリクエストを簡単にレビューできるように多くの時間を費やしています。</font><font style="vertical-align: inherit;">ときどき、フィードしたり、すばやくフィードしたり、レビュアーに理解させたりする誘惑がある場合があります。</font><font style="vertical-align: inherit;">小さなプルリクエストと短い説明を作成しようとします-コードはそれ自体で説明する必要があります。</font><font style="vertical-align: inherit;">プルリクエストが小さい場合は、簡単にすばやくボーリングできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで問題が発生します。コードベースで多数の変更を必要とする機能に取り組んでいます。あなたは何ができますか？あなたはそれを1つのプルリクエストに入れることができますが、それから巨大になります。プルリクエストを段階的に作成することで作業できますが、問題は、ブランチを作成し、いくつかの変更を追加してプルリクエストを送信し、マスターに返され、プルリクエストにあったコードがマスターで利用可能になるまでです。マージは行われません。これらのファイルの変更に依存している場合、そのようなコードがないため、作業を続けるのは困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どうすればこれを回避できますか？最初のプルリクエストを作成した後、引き続き作業を行い、プルリクエストの前に使用した既存のブランチから新しいブランチを作成します。各ブランチはマスターからではなく、前のブランチからのものです。この機能の一部の作業が終了したら、別のプルリクエストを送信し、マージではマスターではなく前のブランチにマージすることを再度示します。そのようなプルリクエストのチェーンが判明しました。人が修正すると、この機能によってのみ加えられた変更が表示され、以前の機能では表示されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクは、変更する必要がないように、各プルリクエストをできるだけ小さく明確にすることです。スタックの途中にあるブランチのコードを変更する必要がある場合、リベースを行う必要があるため、上部のすべてが壊れます。プルリクエストが小さい場合は、できるだけ早くフリーズするようにしてから、スタックされたすべてのマージを段階的にマスターにマージします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daniil Popov</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：最終的に、小さなプルリクエストをすべて含む最後のプルリクエストがあることは理解しています。あなたは見ずにこの糸を注ぐ？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エゴール・アンドレエヴィッチ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：マージはスタックされたソースから行われます。最初に、最初のプルリクエストがマスターでマージされ、次に、ベースがブランチからマスターに変更されます。したがって、Gitはマスターに変更が既にあり、スナップショットが少ないと計算します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexei Kudryavtsev</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：最初のブランチがすでにフリーズしていて、その後、2番目のブランチがマスターに変更されていないために最初のブランチが停止したときに、競合状態はありますか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Egor Andreevich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：手で持っているので、そのような状況はありません。プルリクエストを開いて、レビューを取得したい同僚をメモし、準備ができたらbitbucketに移動して、マージを押します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexei Kudryavtsev</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：しかし、何も壊れていないというCIのチェックについてはどうですか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エゴール・アンドレエヴィッチ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：私たちはそれを行いません。 CIはプルリクエストのベースであるブランチ上で実行され、確認後、ベースを変更します。技術的には、変更の数もターゲットにするため、変更されません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daniil Popov</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：マスターに直接プッシュしていますか、それともまだ開発中ですか？そして、リリースするときに、収集するコミットを明示的に示しますか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エゴール・アンドレエヴィッチ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：開発はありません。マスターのみです。</font><font style="vertical-align: inherit;">間違いなく2週間ごとにリリースされます。</font><font style="vertical-align: inherit;">リリースの準備を開始すると、リリースブランチを開き、最後の修正のいくつかはマスターとこのブランチの両方に適用されます。</font><font style="vertical-align: inherit;">タグを使用します-特定のコミットへの永続的なリンク、オプションでいくつかの情報。</font><font style="vertical-align: inherit;">ある種のコミットがリリースコミットである場合、このコミットからリリースしたことを履歴に残しておくと便利です。</font><font style="vertical-align: inherit;">タグが作成され、Gitがバージョン情報を保存します。後でこれに戻ることができます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexei Kudryavtsev</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：Gitをどこで教えるか、何を読むべきか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Egor Andreevich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：Gitには</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公式の本があります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私はそれが書かれた方法が好きです、良い例があります。</font><font style="vertical-align: inherit;">中には章があり、じっくり勉強できます。</font><font style="vertical-align: inherit;">StackOverflowで多くの難解な状況と解決策を見つけることができます。</font><font style="vertical-align: inherit;">それらも使用できます。</font></font><br>
<br>
<blockquote>&nbsp; <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Saint AppsConf</a>  Git  &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;    &nbsp; Introductory, &nbsp;  &nbsp;         .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">&nbsp;   &nbsp;Avito   </a>:  &nbsp; &nbsp;  ,   &nbsp; &nbsp;  &nbsp;2019&nbsp;.<br>
<br>
 AppsCast   &nbsp;  &nbsp;&nbsp;,      , &nbsp; &nbsp; &nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">SoundCloud</a>,   &nbsp;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">&nbsp; </a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja468163/index.html">Oracle VM Server for SPARC for Dummies（ハウツー）</a></li>
<li><a href="../ja468165/index.html">ブラウザが描画する方法。Yandexレポート</a></li>
<li><a href="../ja468167/index.html">生活し、学びます。パート4.仕事をしながら勉強しますか？</a></li>
<li><a href="../ja468169/index.html">jQueryの歴史と遺産</a></li>
<li><a href="../ja468175/index.html">読む価値のあるフロントエンド開発ブログ</a></li>
<li><a href="../ja468179/index.html">分析：ロシアの証券市場のインフラがどのように機能するか</a></li>
<li><a href="../ja468181/index.html">Silent Trinity：悪用後のフレームワークの新しいバージョンを探索する</a></li>
<li><a href="../ja468185/index.html">AWS EC2サービスと連携</a></li>
<li><a href="../ja468189/index.html">コンソールトリックを使用してJavaScriptデバッグスキルを向上させる</a></li>
<li><a href="../ja468191/index.html">RubyRussia 2019：サーバーレスについてのニコライ・スベルチコフ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>