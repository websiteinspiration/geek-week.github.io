<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📴 👋🏼 🔮 Geschichte, wie man eine Zeitmaschine für eine Datenbank erstellt und versehentlich einen Exploit schreibt 🚋 👨🏻‍🔧 🤖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag, Habr. 
 
 Haben Sie sich jemals gefragt, wie Sie die Zeit in der Datenbank ändern können? Einfach? In einigen Fällen ist es einfach - der L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Geschichte, wie man eine Zeitmaschine für eine Datenbank erstellt und versehentlich einen Exploit schreibt</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503804/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guten Tag, Habr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haben Sie sich jemals gefragt, wie Sie die Zeit in der Datenbank ändern können? </font><font style="vertical-align: inherit;">Einfach? </font><font style="vertical-align: inherit;">In einigen Fällen ist es einfach - der Linux-Befehl ist Datum und der Punkt ist im Hut. </font><font style="vertical-align: inherit;">Und wenn Sie die Zeit nur innerhalb einer Instanz der Datenbank ändern müssen, wenn sich mehrere davon auf dem Server befinden? </font><font style="vertical-align: inherit;">Und für einen einzelnen Datenbankprozess? </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UND? </font><font style="vertical-align: inherit;">Äh, das ist es, mein Freund, das ist der springende Punkt.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jemand wird sagen, dass dies ein weiterer Sur ist, der nicht mit der Realität zusammenhängt und regelmäßig auf Habré ausgelegt wird. </font><font style="vertical-align: inherit;">Aber nein, die Aufgabe ist ziemlich real und wird von der Notwendigkeit der Produktion bestimmt - dem Testen von Code. </font><font style="vertical-align: inherit;">Obwohl ich damit einverstanden bin, kann der Testfall ziemlich exotisch sein - überprüfen Sie, wie sich der Code für ein bestimmtes Datum in der Zukunft verhält. </font><font style="vertical-align: inherit;">In diesem Artikel werde ich im Detail untersuchen, wie diese Aufgabe gelöst wurde, und gleichzeitig ein wenig den Prozess der Organisation von Test- und Entwickler-Ständen für die Oracle-Basis erfassen. </font><font style="vertical-align: inherit;">Machen Sie es sich vor einer langen Lektüre bequem und fragen Sie nach einer Katze.</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hintergrund</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit einer kurzen Einführung, um zu zeigen, warum dies notwendig ist. Wie bereits angekündigt, schreiben wir Tests bei der Implementierung von Änderungen in der Datenbank. Das System, unter dem diese Tests durchgeführt werden, wurde zu Beginn (oder kurz vor dem Start) der Nullen entwickelt, sodass sich die gesamte Geschäftslogik in der Datenbank befindet und in Form von gespeicherten Prozeduren in der Sprache pl / sql geschrieben ist. Und ja, es bringt uns Schmerz und Leid. Aber das ist Vermächtnis, und man muss damit leben. Im Code und im Tabellenmodell kann angegeben werden, wie sich die Parameter im System im Laufe der Zeit entwickeln. Mit anderen Worten, legen Sie die Aktivität fest, ab welchem ​​Datum und bis zu welchem ​​Datum sie angewendet werden können. Was ist weit zu gehen? Die jüngste Änderung des Mehrwertsteuersatzes ist ein anschauliches Beispiel dafür. Und damit solche Änderungen im System vorab überprüft werden können,Eine Datenbank mit solchen Änderungen muss zu einem bestimmten Zeitpunkt in der Zukunft übertragen werden. Die Codeparameter in den Tabellen werden zum "aktuellen Zeitpunkt" aktiv. Aufgrund der Besonderheiten des unterstützten Systems können Sie keine Mock-Tests verwenden, bei denen der Rückgabewert des aktuellen Systemdatums in der Sprache zu Beginn der Testsitzung einfach geändert wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also haben wir bestimmt warum, dann müssen wir bestimmen, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie das</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ziel erreicht wird. </font><font style="vertical-align: inherit;">Zu diesem Zweck werde ich einen kleinen Rückblick auf die Optionen zum Erstellen von Testbänken für Entwickler und den Beginn jeder Testsitzung geben.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Steinzeit</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es war einmal, als die Bäume klein und die Mainframes groß waren, gab es nur einen Server für die Entwicklung und es wurden auch Tests durchgeführt. </font><font style="vertical-align: inherit;">Und im Prinzip war dies alles für alle ausreichend ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">640 KB sind für alle ausreichend!</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachteile: </font><i><font style="vertical-align: inherit;">Um</font></i><font style="vertical-align: inherit;"> die Aufgabe der </font><i><font style="vertical-align: inherit;">Zeitänderung</font></i><font style="vertical-align: inherit;"> zu erfüllen, mussten viele verwandte Abteilungen einbezogen werden - Systemadministratoren (hat sich die Zeit auf dem Subserver von root geändert), DBMS-Administratoren (hat die Datenbank neu gestartet), Programmierer ( Es musste mitgeteilt werden, dass eine Zeitänderung eintreten würde, da ein Teil des Codes nicht mehr funktioniert. Beispielsweise waren Web-Token, die zuvor für den Aufruf von API-Methoden ausgegeben wurden, nicht mehr gültig und dies könnte eine Überraschung sein. Tester (testen sich selbst) ... Wenn Sie die Zeit auf die Gegenwart zurückführen alles wurde in umgekehrter Reihenfolge wiederholt.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mittelalter</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der Zeit wuchs die Anzahl der Entwickler in der Abteilung und irgendwann reichte 1 Server nicht mehr aus. Hauptsächlich aufgrund der Tatsache, dass verschiedene Entwickler dasselbe pl / sql-Paket ändern und Tests dafür durchführen möchten (auch ohne die Zeit zu ändern). Immer mehr Empörung war zu hören: „Wie lange! Genug, das zu tolerieren! Fabriken für Arbeiter, Land für Bauern! Jeder Programmierer hat eine Datenbank! “ Wenn Sie jedoch über ein paar Terabyte Produktdatenbank und 50 bis 100 Entwickler verfügen, ist die Anforderung in dieser Form ehrlich gesagt nicht sehr real. Und dennoch möchte jeder, dass die Test- und Entwicklerbasis nicht sehr hinter den Verkäufen zurückbleibt, sowohl in der Struktur als auch in den Daten in den Tabellen. Es gab also einen separaten Server zum Testen, nennen wir es Vorproduktion. Es wurde von 2 identischen Servern gebaut,wo der Verkauf gemacht wurde, um die Datenbank von RMAN Dollar wiederherzustellen, und es dauerte etwa 2-2,5 Tage. Nach der Wiederherstellung wurden in der Datenbank persönliche und andere wichtige Daten anonymisiert, und die Last aus den Testanwendungen wurde auf diesen Server angewendet (und die Programmierer selbst arbeiteten immer mit dem kürzlich wiederhergestellten Server). Die Arbeit mit dem erforderlichen Server wurde mithilfe der von corosync (Schrittmacher) unterstützten Cluster-IP-Ressource sichergestellt. Während alle mit dem aktiven Server arbeiten, beginnt auf dem 2. Knoten die Datenbankwiederherstellung erneut und nach 2-3 Tagen wechseln sie erneut die Plätze.Die Arbeit mit dem erforderlichen Server wurde mithilfe der von corosync (Schrittmacher) unterstützten Cluster-IP-Ressource sichergestellt. Während alle mit dem aktiven Server arbeiten, beginnt auf dem 2. Knoten die Datenbankwiederherstellung erneut und nach 2-3 Tagen wechseln sie erneut die Plätze.Die Arbeit mit dem erforderlichen Server wurde mithilfe der von corosync (Schrittmacher) unterstützten Cluster-IP-Ressource sichergestellt. Während alle mit dem aktiven Server arbeiten, beginnt auf dem 2. Knoten die Datenbankwiederherstellung erneut und nach 2-3 Tagen wechseln sie erneut die Plätze.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von den offensichtlichen Nachteilen: Sie benötigen 2 Server und 2 mal mehr Ressourcen (hauptsächlich Festplatte) als prod. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vorteile: Zeitänderungsbetrieb und -tests - können auf dem 2. Server ausgeführt werden, auf dem Hauptserver zu diesem Zeitpunkt, an dem Entwickler leben und ihren Geschäften nachgehen. </font><font style="vertical-align: inherit;">Serverwechsel treten nur auf, wenn die Datenbank bereit ist und die Ausfallzeit der Testumgebung minimal ist.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ära des wissenschaftlichen und technologischen Fortschritts</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als wir zur 11g Release 2-Datenbank wechselten, lasen wir über eine interessante Technologie, die Oracle unter dem Namen CloneDB bereitstellt. Das Fazit ist, dass die Produktdatenbanksicherungen (es gibt eine direkte Bitkopie der Produktdatendateien) auf einem speziellen Server gespeichert sind, der diesen Datensatz dann über DNFS (direktes NFS) auf einer beliebigen Anzahl von Servern veröffentlicht, und Sie müssen keinen auf dem Server haben Dieselbe Datenträgermenge, da der Copy-On-Write-Ansatz implementiert ist: Die Datenbank verwendet eine Netzwerkfreigabe mit Datendateien vom Sicherungsserver zum Lesen von Daten in Tabellen, und Änderungen werden in lokale Datendateien auf dem Entwicklungsserver selbst geschrieben. In regelmäßigen Abständen wird für den Server das „Nullstellen der Fristen“ durchgeführt, damit die lokalen Datendateien nicht sehr stark wachsen und der Ort nicht endet. Beim Aktualisieren des Servers werden die Daten auch in den Tabellen entpersönlicht.In diesem Fall fallen alle Tabellenaktualisierungen in lokale Datendateien und diese Tabellen werden vom lokalen Server gelesen, alle anderen Tabellen werden über das Netzwerk gelesen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachteile: Es gibt immer noch 2 Server (um reibungslose Updates mit minimalen Ausfallzeiten für Verbraucher zu gewährleisten), aber jetzt wird das Festplattenvolumen erheblich reduziert. Um Geld auf einem NFS-Ball zu speichern, benötigen Sie 1 weiteren Server in Größe + - als Produkt, aber die Ausführungszeit für das Update selbst wird reduziert (insbesondere bei Verwendung von inkrementellen Dollars). Die Vernetzung mit einem NFS-Ball verlangsamt die E / A-Lesevorgänge spürbar. Um die CloneDB-Technologie verwenden zu können, muss die Basis eine Enterprise Edition sein. In unserem Fall mussten wir das Upgrade-Verfahren jedes Mal auf Testbasen durchführen. Glücklicherweise sind Testdatenbanken von den Oracle-Lizenzrichtlinien ausgenommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vorteile: Der Vorgang zum Wiederherstellen einer Basis aus einem Bakup dauert weniger als 1 Tag (ich erinnere mich nicht an die genaue Zeit).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zeitumstellung: keine wesentlichen Änderungen. </font><font style="vertical-align: inherit;">Obwohl zu diesem Zeitpunkt bereits Skripte erstellt wurden, um die Zeit auf dem Server zu ändern und die Datenbank neu zu starten, um dies zu tun, ohne die </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufmerksamkeit der Pfleger der</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Administratoren auf sich zu ziehen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ära der neuen Geschichte</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um noch mehr Speicherplatz zu sparen und Daten offline zu lesen, haben wir uns entschlossen, unsere CloneDB-Version (mit Flashback und Snapshots) mithilfe eines Dateisystems mit Komprimierung zu implementieren. </font><font style="vertical-align: inherit;">Während der Vorversuche fiel die Wahl auf ZFS, obwohl es im Linux-Kernel keine offizielle Unterstützung dafür gibt (Zitat aus dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Zum Vergleich haben wir uns auch BTRFS (b-tree fs) angesehen, das Oracle fördert, aber das Komprimierungsverhältnis war bei gleichem CPU- und RAM-Verbrauch in den Tests geringer. Um die ZFS-Unterstützung für RHEL5 zu aktivieren, wurde ein eigener Kernel basierend auf UEK (unzerbrechlicher Unternehmenskernel) erstellt. Auf neueren Achsen und Kerneln können Sie einfach den vorgefertigten UEK-Kernel verwenden. Die Implementierung einer solchen Testbasis basiert ebenfalls auf dem COW-Mechanismus, jedoch auf der Ebene von Dateisystem-Snapshots. Dem Server werden 2 Festplattengeräte zur Verfügung gestellt, auf einem wird der zfs-Pool erstellt, wobei über RMAN eine zusätzliche Standby-Datenbank aus dem Verkauf erstellt wird. Da wir die Komprimierung verwenden, nimmt die Partition weniger als die Produktion in Anspruch.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das System ist auf dem zweiten Festplattengerät installiert, und der Rest ist erforderlich, damit der Server und die Datenbank selbst funktionieren, z. B. Partitionen zum Rückgängigmachen und Temp. Sie können jederzeit einen Snapshot aus dem zfs-Pool erstellen, der dann als separate Datenbank geöffnet wird. Das Erstellen eines Schnappschusses dauert einige Sekunden. Es ist Magie! Und solche Datenbanken können im Prinzip ziemlich stark gekippt werden, wenn nur der Server über genügend RAM für alle Instanzen und die Größe des zfs-Pools selbst verfügt (zum Speichern von Änderungen in Datendateien während der Depersonalisierung und während des Lebenszyklus des Datenbankklons). Die Hauptzeit für die Aktualisierung der Testbasis ist der Vorgang der Datendepersonalisierung, sie passt jedoch auch in 15 bis 20 Minuten. Es gibt eine signifikante Beschleunigung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachteile: Auf dem Server können Sie die Zeit nicht einfach durch Übersetzen der Systemzeit ändern, da dann alle auf diesem Server ausgeführten Datenbankinstanzen sofort in diese Zeit fallen. Eine Lösung für dieses Problem wurde gefunden und wird im entsprechenden Abschnitt beschrieben. Mit Blick auf die Zukunft möchte ich sagen, dass Sie damit die Zeit in nur einer Instanz der Datenbank ändern können (Ansatz zur Änderung der Zeit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pro Instanz)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) ohne den Rest auf demselben Server zu beeinflussen. </font><font style="vertical-align: inherit;">Und die Zeit auf dem Server selbst ändert sich auch nicht. </font><font style="vertical-align: inherit;">Dadurch ist kein Root-Skript erforderlich, um die Zeit auf dem Server zu ändern. </font><font style="vertical-align: inherit;">Ebenfalls in dieser Phase wird die Zeitänderungsautomatisierung für Instanzen über Jenkins CI implementiert, und Benutzer (relativ gesehen Entwicklungsteams), die ihren Stand besitzen, erhalten Rechte an den Jobs, über die sie selbst die Zeit ändern, den Stand mit Verkäufen auf den aktuellen Status aktualisieren und Schnappschüsse erstellen können und Wiederherstellung (Rollback) der Basis zum zuvor erstellten Snapshot.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ära der jüngeren Geschichte</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dem Aufkommen von Oracle 12c erschien eine neue Technologie - steckbare Datenbanken und damit Container-Datenbanken (cdb). Mit dieser Technologie können innerhalb einer physischen Instanz mehrere "virtuelle" Datenbanken erstellt werden, die sich einen gemeinsamen Speicherbereich der Instanz teilen. Vorteile: Sie können Speicher für den Server speichern (und die Gesamtleistung unserer Datenbank steigern, da der gesamte Speicher, der zuvor belegt war, z. B. 5 verschiedene Instanzen, für alle bereitgestellten PDF-Container in CDB freigegeben werden kann und nur von diesen verwendet wird Wenn sie es wirklich brauchen und nicht wie in der vorherigen Phase, wenn jede Instanz den ihr zugewiesenen Speicher für sich selbst "blockiert" und wenn die Aktivität eines der Klone gering war, wurde der Speicher nicht effektiv genutzt, mit anderen Worten, er war inaktiv.Die Datendateien verschiedener pdb befinden sich immer noch im zfs-Pool, und beim Bereitstellen von Klonen verwenden sie denselben zfs-Snapshot-Mech. Zu diesem Zeitpunkt kamen wir der Fähigkeit nahe, fast jedem Entwickler eine eigene Datenbank zur Verfügung zu stellen. Das Ändern der Zeit in dieser Phase erfordert keinen Neustart der Datenbank und funktioniert nur für Prozesse, die eine Zeitänderung erfordern, sehr genau. Alle anderen Benutzer, die mit dieser Datenbank arbeiten, sind in keiner Weise betroffen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Minuspunkt: Sie können den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitänderungsansatz pro Instanz</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus der vorherigen Phase nicht verwenden, da wir jetzt eine Instanz haben. Es wurde jedoch eine Lösung für diesen Fall gefunden. Und genau dies war der Anstoß für das Schreiben dieses Artikels. Mit Blick auf die Zukunft werde ich sagen, dass es sich um eine zeitliche Änderung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pro Prozessansatz handelt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">d. H. In jedem Datenbankprozess können Sie im Allgemeinen Ihre eigene eindeutige Zeit festlegen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall legt eine typische Testsitzung unmittelbar nach dem Herstellen einer Verbindung zur Datenbank den richtigen Zeitpunkt zu Beginn ihrer Arbeit fest, führt Tests durch und gibt die Zeit am Ende zurück. Die Rückgabe der Zeit ist aus einem einfachen Grund erforderlich: Einige Oracle-Datenbankprozesse werden nicht beendet, wenn der Datenbankclient die Verbindung zum Server trennt. Hierbei handelt es sich um Serverprozesse, die als gemeinsam genutzte Server bezeichnet werden und im Gegensatz zu dedizierten Prozessen ausgeführt werden, wenn der Datenbankserver gestartet wird und nahezu unbegrenzt aktiv ist (im Idealfall) Bild der Welt). Wenn Sie die Zeit in einem solchen Serverprozess geändert lassen, erhält eine andere Verbindung, die in diesem Prozess bedient wird, die falsche Zeit.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem System werden häufig gemeinsam genutzte Server verwendet, weil Bis zu 11 g gab es praktisch keine adäquate Lösung für unser System, um einer hohen Last standzuhalten (in 11 g erschien DRCP - datenbankresidentes Verbindungspooling). Und hier ist der Grund: In Sub gibt es eine Begrenzung für die Gesamtzahl der Serverprozesse, die sowohl im dedizierten als auch im gemeinsam genutzten Modus erstellt werden können. Dedizierte Prozesse werden langsamer erzeugt, als die Datenbank einen vorgefertigten gemeinsam genutzten Prozess aus dem Pool gemeinsam genutzter Prozesse ausgeben kann. Wenn also ständig neue Verbindungen eingehen (insbesondere wenn der Prozess andere langsame Vorgänge ausführt), wächst die Gesamtzahl der Prozesse. Wenn das Limit an Sitzungen / Prozessen erreicht ist, werden in der Datenbank keine neuen Verbindungen mehr hergestellt, und es kommt zu einem Zusammenbruch.Durch den Übergang zur Verwendung eines Pools gemeinsam genutzter Prozesse konnten wir die Anzahl neuer Prozesse auf dem Server beim Herstellen einer Verbindung reduzieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist die Überprüfung der Technologien zum Erstellen von Testdatenbanken abgeschlossen, und wir können endlich mit der Implementierung der Zeitänderungsalgorithmen für die Datenbank selbst beginnen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Fake-per-Instance-Ansatz</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie ändere ich die Zeit in der Datenbank? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste, was mir in den Sinn kam, war, in einem Schema, das den gesamten Geschäftslogikcode enthält, eine eigene Funktion zu erstellen, die die mit der Zeit arbeitenden Sprachfunktionen (sysdate, current_date usw.) überlappt und unter bestimmten Bedingungen andere Werte angibt, z Legen Sie zu Beginn des Testlaufs Werte über den Sitzungskontext fest. Es hat nicht funktioniert, die integrierten Sprachfunktionen haben sich nicht mit den Benutzerfunktionen überschnitten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anschließend wurden leichte Virtualisierungssysteme (Vserver, OpenVZ) und die Containerisierung über Docker getestet. Es funktioniert auch nicht, sie verwenden denselben Kernel wie das Hostsystem, was bedeutet, dass sie dieselben Systemzeitgeberwerte verwenden. Wieder rausfallen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und hier habe ich keine Angst davor, dieses Wort zu retten, eine großartige Erfindung der Linux-Welt - Neudefinition / Abfangen von Funktionen in der Phase des dynamischen Ladens gemeinsam genutzter Objekte. Es ist vielen als Tricks mit LD_PRELOAD bekannt. In der Umgebungsvariablen LD_PRELOAD können Sie die Bibliothek angeben, die vor allen anderen geladen werden soll, die der Prozess benötigt. Wenn diese Bibliothek Zeichen mit demselben Namen wie beispielsweise in der Standardbibliothek enthält, die später geladen wird, sieht die Symbolimporttabelle für die Anwendung wie eine Funktion aus liefert unser Ersatzmodul. Und genau das macht die </font><i><font style="vertical-align: inherit;">libfaketime-</font></i><font style="vertical-align: inherit;"> Projektbibliothek</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die wir zu verwenden begannen, um die Datenbank zu einem anderen Zeitpunkt als dem System zu starten. Die Bibliothek verpasst Anrufe, die die Arbeit mit dem Systemzeitgeber und das Abrufen der Systemzeit und des Systemdatums betreffen. Um zu steuern, wie viel Zeit sich relativ zum aktuellen Serverdatum bewegt oder ab welchem ​​Zeitpunkt die Zeit innerhalb des Prozesses liegen soll, wird alles durch Umgebungsvariablen gesteuert, die zusammen mit LD_PRELOAD festgelegt werden müssen. Um die Zeitänderung zu implementieren, haben wir einen Job auf dem Jenkins-Server implementiert, der in den Datenbankserver eingeht und das DBMS entweder mit oder ohne für libfaketime festgelegte Umgebungsvariablen neu startet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Beispielalgorithmus zum Starten einer Datenbank mit einer Substitutionszeit:</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-built_in">export</span> LD_PRELOAD=/usr/<span class="hljs-built_in">local</span>/lib/faketime/libfaketime.so
<span class="hljs-built_in">export</span> FAKETIME=<span class="hljs-string">"+1d"</span>
<span class="hljs-built_in">export</span> FAKETIME_NO_CACHE=1<font></font>
<font></font>
<span class="hljs-variable">$ORACLE_HOME</span>/bin/sqlplus @/home/oracle/scripts/restart_db.sql
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wenn Sie sich vorstellen, dass alles sofort funktioniert hat, dann irren Sie sich zutiefst. </font><font style="vertical-align: inherit;">Wie sich herausstellte, werden die Bibliotheken überprüft, die beim Start des DBMS in den Prozess geladen werden. </font><font style="vertical-align: inherit;">Und im Alarmprotokoll beginnt er, die bemerkte Fälschung zu ärgern, während die Basis nicht startet. </font><font style="vertical-align: inherit;">Jetzt weiß ich nicht mehr genau, wie ich es loswerden soll. Es gibt einige Parameter, die die Ausführung von Sanity-Checks beim Start deaktivieren können.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Fake-per-Process-Ansatz</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die allgemeine Idee, die Zeit nur innerhalb eines Prozesses zu ändern, blieb dieselbe - verwenden Sie libfaketime. </font><font style="vertical-align: inherit;">Wir starten die Datenbank mit einer vorinstallierten Bibliothek, setzen jedoch beim Start einen Zeitversatz von Null, der dann an alle DBMS-Prozesse weitergegeben wird. </font><font style="vertical-align: inherit;">Legen Sie dann innerhalb der Testsitzung die Umgebungsvariable nur für diesen Prozess fest. </font><font style="vertical-align: inherit;">Pff, etwas geschäftliches.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für diejenigen, die mit der pl / sql-Sprache vertraut sind, ist das ganze Schicksal dieser Idee jedoch sofort klar. Weil die Sprache sehr begrenzt und grundsätzlich für hochrangige Aufgaben geeignet ist. Dort kann keine Systemprogrammierung implementiert werden. Obwohl einige Operationen auf niedriger Ebene (z. B. Arbeiten mit einem Netzwerk, Arbeiten mit Dateien) in Form von vorinstallierten System-dbms / utl-Paketen vorhanden sind. Während der gesamten Zeit, in der ich mit Oracle gearbeitet habe, habe ich vorinstallierte Pakete mehrmals rückentwickelt. Der Code einiger von ihnen ist vor den Augen von Fremden verborgen (sie werden als verpackt bezeichnet). Wenn es Ihnen verboten ist, etwas anzusehen, nimmt die Versuchung zu, herauszufinden, wie es im Inneren angeordnet ist, nur zu. Aber oft gibt es auch nach dem Anvrapper nicht immer etwas zu sehen, da die Funktionen solcher Pakete als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c-Schnittstelle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu so-Bibliotheken auf der Festplatte </font><font style="vertical-align: inherit;">implementiert </font><font style="vertical-align: inherit;">sind.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Insgesamt haben wir uns an einen Kandidaten für die Implementierung gewandt - Technologie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit externen Verfahren</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die speziell gestaltete Bibliothek kann Methoden exportieren, die dann die Oracle-Datenbank über pl / sql aufrufen kann. Scheint vielversprechend. Nur einmal traf ich dies in Advanced plsql Kursen, so dass ich mich sehr aus der Ferne daran erinnerte, wie man es kocht. Und es bedeutet, dass die Dokumentation gelesen werden muss. Ich las es - und wurde sofort depressiv. Da das Laden einer solchen benutzerdefinierten Bibliothek in einem separaten Agentenprozess über einen Datenbank-Listener erfolgt und die Kommunikation mit diesem Agenten über dlink erfolgt. Unsere Idee war es also, eine Umgebungsvariable innerhalb des Datenbankprozesses selbst festzulegen. Und das alles aus Sicherheitsgründen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Bild aus der Dokumentation, das zeigt, wie es funktioniert:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pu/1h/07/pu1h07d6fvy1wwetq4deujbpnga.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Typ der so / dll-Bibliothek ist nicht so wichtig, aber aus irgendeinem Grund ist das Bild nur für Windows. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielleicht hat hier jemand eine weitere mögliche Gelegenheit bemerkt. Ja, ja, das ist Java. Mit Oracle können Sie gespeicherten Prozedurcode nicht nur in plsql, sondern auch in Java schreiben, die jedoch genauso wie plsql-Methoden exportiert werden. In regelmäßigen Abständen habe ich dies getan, daher sollte es kein Problem damit geben. Aber dann wurde eine weitere Falle versteckt. Java arbeitet mit einer Kopie der Umgebung und ermöglicht es Ihnen, nur die Umgebungsvariablen abzurufen, die der JVM-Prozess beim Start hatte. Die integrierte JVM erbt die Umgebungsvariablen des Datenbankprozesses, aber das ist alles. Ich habe im Internet Tipps gesehen, wie man die schreibgeschützte Karte durch Reflexion ändert, aber worum geht es, denn es ist immer noch nur eine Kopie. Das heißt, die Frau hatte wieder nichts mehr.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Java ist jedoch nicht nur wertvolles Fell. Mit ihm können Sie Prozesse aus einem Datenbankprozess heraus erzeugen. Obwohl alle unsicheren Vorgänge separat über den Java-Grant-Mechanismus gelöst werden müssen, der mit dem Paket dbms_java ausgeführt wird. Innerhalb des plsql-Codes können Sie die Prozess-PID des aktuellen Serverprozesses abrufen, in dem der Code ausgeführt wird, indem Sie die Systemansichten v $ session und v $ process verwenden. Außerdem können wir einen untergeordneten Prozess aus unserer Sitzung erzeugen, um etwas mit dieser PID zu tun. Zu Beginn habe ich einfach alle Umgebungsvariablen abgeleitet, die sich im Datenbankprozess befinden (um die Hypothese zu testen).</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/sh
</span>
pid=<span class="hljs-variable">$1</span><font></font>
<font></font>
awk <span class="hljs-string">'BEGIN {RS="\0"; ORS="\n"} $0'</span> <span class="hljs-string">"/proc/<span class="hljs-variable">$pid</span>/environ"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gut abgeleitet, und was dann? Es ist immer noch unmöglich, die Variablen in der Umgebungsdatei zu ändern. Dies sind die Daten, die beim Start an den Prozess übertragen wurden und schreibgeschützt sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe im Stackoverflow im Internet gesucht: "So ändern Sie eine Umgebungsvariable in einem anderen Prozess." Die meisten Antworten waren, dass es unmöglich war, aber es gab eine Antwort, die diese Gelegenheit als minderwertigen und schmutzigen Hack beschrieb. Und diese Antwort war </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Albert Einstein</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gdb. Der Debugger kann sich an jeden Prozess anschließen, der seine PID kennt, und jede Funktion / Prozedur ausführen, die darin als öffentlich exportiertes Symbol vorhanden ist, beispielsweise aus einer Bibliothek. In libc gibt es Funktionen zum Arbeiten mit Umgebungsvariablen, und libc wird in jeden Prozess der Oracle-Datenbank (und praktisch in jedes Programm unter Linux) geladen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So wird die Umgebungsvariable in einem fremden Prozess festgelegt (Sie müssen sie aufgrund des verwendeten ptrace von root aus aufrufen):</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/sh
</span>
pid=<span class="hljs-variable">$1</span>
env_name=<span class="hljs-variable">$2</span>
env_val=<span class="hljs-string">"<span class="hljs-variable">$3</span>"</span><font></font>
<font></font>
out=`gdb -q -batch -ex <span class="hljs-string">"attach <span class="hljs-variable">$pid</span>"</span> -ex <span class="hljs-string">'call (int) setenv("'</span><span class="hljs-variable">$env_name</span><span class="hljs-string">'", "'</span><span class="hljs-string">"<span class="hljs-variable">$env_val</span>"</span><span class="hljs-string">'", 1)'</span> -ex <span class="hljs-string">"detach"</span> 2&gt;&amp;1`
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist auch geeignet, die Umgebungsvariablen innerhalb des GDB-Prozesses anzuzeigen. </font><font style="vertical-align: inherit;">Wie bereits erwähnt, zeigt die Umgebungsdatei aus / proc / pid / nur die Variablen an, die zu Beginn des Prozesses vorhanden waren. </font><font style="vertical-align: inherit;">Und wenn der Prozess im Laufe seiner Arbeit etwas geschaffen hat, kann dies nur durch den Debugger gesehen werden:</font></font><br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/sh
</span>
pid=<span class="hljs-variable">$1</span>
var_name=<span class="hljs-variable">$2</span><font></font>
<font></font>
var_value=`gdb -q -batch -ex <span class="hljs-string">"attach <span class="hljs-variable">$pid</span>"</span> -ex <span class="hljs-string">'call (char*) getenv("'</span><span class="hljs-variable">$var_name</span><span class="hljs-string">'")'</span> -ex <span class="hljs-string">'detach'</span> | egrep <span class="hljs-string">'^\$1 ='</span>`<font></font>
<font></font>
<span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span> == <span class="hljs-string">'$1 = 0x0'</span> ]
<span class="hljs-keyword">then</span>
  <span class="hljs-comment"># variable empty or does not exist</span>
  <span class="hljs-built_in">echo</span> -n
<span class="hljs-keyword">else</span>
  <span class="hljs-comment"># gdb returns $1 = hex_value "string value"</span>
  var_hex=`<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span> | awk <span class="hljs-string">'{print $3}'</span>`<font></font>
  var_value=`<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span> | sed -r -e <span class="hljs-string">'s/^\$1 = '</span><span class="hljs-variable">$var_hex</span><span class="hljs-string">' //;s/^"//;s/"$//'</span>`<font></font>
  <font></font>
  <span class="hljs-built_in">echo</span> -n <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span>
<span class="hljs-keyword">fi</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Lösung ist also bereits in unserer Tasche - über Java erzeugen wir den Debugger-Prozess, der zu dem Prozess geht, der ihn generiert hat, die gewünschte Umgebungsvariable dafür festlegt und dann endet (der Moor hat seine Arbeit erledigt - der Moor kann gehen). </font><font style="vertical-align: inherit;">Aber es gab das Gefühl, dass es eine Art Krücke war. </font><font style="vertical-align: inherit;">Ich wollte etwas eleganteres. </font><font style="vertical-align: inherit;">Es wäre irgendwie egal, den Datenbankprozess selbst zu zwingen, Umgebungsvariablen ohne externen Angriff festzulegen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Ei in einer Ente, eine Ente in einem Hasen ...</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und dann kommt jemand zur Rettung, ja, Sie haben es richtig erraten, wieder Java, nämlich JNI (Java Native Interface). </font><font style="vertical-align: inherit;">Mit JNI können Sie native C-Methoden innerhalb der JVM aufrufen. </font><font style="vertical-align: inherit;">Der Code wird auf besondere Weise in Form eines gemeinsam genutzten Objekts der Bibliothek ausgegeben, das die JVM dann lädt, während die Methoden in der Bibliothek den Java-Methoden in der Klasse zugeordnet sind, die mit dem nativen Modifikator deklariert wurden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, ok, wir schreiben eine Klasse (tatsächlich ist dies nur ein Werkstück):</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Posix</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">setenv</span><span class="hljs-params">(String key, String value, <span class="hljs-keyword">boolean</span> overwrite)</span></span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> String <span class="hljs-title">getenv</span><span class="hljs-params">(String key)</span></span>;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stub</span><span class="hljs-params">()</span> 
    </span>{<font></font>
        <font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompilieren Sie es anschließend und rufen Sie die generierte h-Datei der zukünftigen Bibliothek ab:</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-comment">#  </span><font></font>
javac Posix.java<font></font>
<font></font>
<span class="hljs-comment">#   Posix.h        JNI</span><font></font>
javah Posix<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir die Header-Datei erhalten haben, schreiben wir den Body für jede Methode:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Posix.h"</span></span><font></font>
<font></font>
<span class="hljs-function">JNIEXPORT jint JNICALL <span class="hljs-title">Java_Posix_setenv</span><span class="hljs-params">(JNIEnv *env, jclass cls, jstring key, jstring value, jboolean overwrite)</span>
</span>{
    <span class="hljs-keyword">char</span>* k = (<span class="hljs-keyword">char</span> *) (*env)-&gt;GetStringUTFChars(env, key, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">char</span>* v = (<span class="hljs-keyword">char</span> *) (*env)-&gt;GetStringUTFChars(env, value, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
    <span class="hljs-keyword">int</span> err = setenv(k, v, overwrite);<font></font>
<font></font>
    (*env)-&gt;ReleaseStringUTFChars(env, key, k);<font></font>
    (*env)-&gt;ReleaseStringUTFChars(env, value, v);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> err;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">JNIEXPORT jstring JNICALL <span class="hljs-title">Java_Posix_getenv</span><span class="hljs-params">(JNIEnv *env, jclass cls, jstring key)</span>
</span>{
    <span class="hljs-keyword">char</span>* k = (<span class="hljs-keyword">char</span> *) (*env)-&gt;GetStringUTFChars(env, key, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">char</span>* v = getenv(k);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> (*env)-&gt;NewStringUTF(env, v);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und kompilieren Sie die Bibliothek</font></font><br>
<br>
<pre><code class="bash hljs">gcc -I<span class="hljs-string">"<span class="hljs-variable">$JAVA_HOME</span>/include"</span> -I<span class="hljs-string">"<span class="hljs-variable">$JAVA_HOME</span>/include/linux"</span> -fPIC Posix.c -shared -o libPosix.so -Wl,-soname -Wl,--no-whole-archive<font></font>
<font></font>
strip libPosix.so<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit Java die native Bibliothek laden kann, muss sie vom System ld gemäß allen Linux-Regeln gefunden werden. </font><font style="vertical-align: inherit;">Darüber hinaus verfügt Java über eine Reihe von Eigenschaften, die die Pfade enthalten, in denen die Bibliothekssuche stattfindet. </font><font style="vertical-align: inherit;">Der einfachste Weg, um in Oracle zu arbeiten, besteht darin, unsere Bibliothek in $ ORACLE_HOME / lib abzulegen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir die Bibliothek erstellt haben, müssen wir die Klasse in der Datenbank kompilieren und als plsql-Paket veröffentlichen. </font><font style="vertical-align: inherit;">Es gibt zwei Optionen zum Erstellen von Java-Klassen in der Datenbank:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Laden Sie die binäre Klassendatei über das Dienstprogramm loadjava</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kompilieren Sie Klassencode aus der Quelle mit sqlplus</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden die zweite Methode verwenden, obwohl sie im Grunde gleich sind. </font><font style="vertical-align: inherit;">Für den ersten Fall war es notwendig, sofort den gesamten Klassencode in Stufe 1 zu schreiben, als wir eine Stub-Klasse für die h-Datei erhielten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um eine Klasse in subd zu erstellen, wird eine spezielle Syntax verwendet:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">REPLACE</span> <span class="hljs-keyword">AND</span> RESOLVE <span class="hljs-keyword">JAVA</span> <span class="hljs-keyword">SOURCE</span> NAMED <span class="hljs-string">"Posix"</span> <span class="hljs-keyword">AS</span><font></font>
...<font></font>
...<font></font>
/<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Klasse erstellt wird, muss sie als plsql-Methode veröffentlicht werden, und auch hier die spezielle Syntax:</font></font><br>
<br>
<pre><code class="sql hljs">procedure set_env(var_name varchar2, var_value varchar2)<font></font>
is<font></font>
language java name 'Posix.set_env(java.lang.String, java.lang.String)';<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie versuchen, potenziell unsichere Methoden in Java aufzurufen, wird eine Ausführung ausgelöst, die besagt, dass für den Benutzer keine Java-Berechtigung erteilt wurde. </font><font style="vertical-align: inherit;">Das Laden nativer Methoden ist eine weitere unsichere Operation, da wir fremden Code direkt in den Datenbankprozess einfügen (der gleiche Exploit, der im Header angekündigt wurde). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da es sich bei der Datenbank jedoch um einen Test handelt, gewähren wir einen Zuschuss ohne Bedenken hinsichtlich der Verbindung von sys:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">begin</span>
dbms_java.grant_permission( <span class="hljs-string">'SYSTEM'</span>, <span class="hljs-string">'SYS:java.lang.RuntimePermission'</span>, <span class="hljs-string">'loadLibrary.Posix'</span>, <span class="hljs-string">''</span>);
<span class="hljs-keyword">commit</span>;
<span class="hljs-keyword">end</span>;<font></font>
/<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Systembenutzername ist derjenige, in dem ich den Java-Code und das plsql-Wrapper-Paket kompiliert habe. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist wichtig zu beachten, dass beim Laden einer Bibliothek über einen Aufruf von System.loadLibrary das lib-Präfix und die so-Erweiterung (wie in der Dokumentation beschrieben) weggelassen werden und kein Pfad übergeben wird, in dem gesucht werden soll. Es gibt eine ähnliche System.load-Methode, mit der eine Bibliothek nur über einen absoluten Pfad geladen werden kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und dann erwarten uns 2 unangenehme Überraschungen - ich landete im nächsten Kaninchenbau von Oracle. Bei der Erteilung eines Zuschusses tritt ein Fehler mit einer ziemlich nebligen Meldung auf:</font></font><br>
<br>
<pre><code class="plaintext hljs">ORA-29532: Java call terminated by uncaught Java exception: java.lang.SecurityException: policy table update
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem wird im Internet gegoogelt und führt zu My Oracle Support (auch bekannt als Metalink). </font><font style="vertical-align: inherit;">weil </font><font style="vertical-align: inherit;">Gemäß den Oracle-Regeln ist das Veröffentlichen von Artikeln von einem Metalink in Open Source nicht gestattet. Ich erwähne nur die Dokumentnummer 259471.1 (diejenigen, die Zugriff haben, können selbst lesen). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Wesentliche des Problems ist, dass Oracle nicht zulässt, dass verdächtiger Code von Drittanbietern in unseren Prozess geladen wird. </font><font style="vertical-align: inherit;">Welches ist logisch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da es sich bei der Basis jedoch um einen Test handelt und wir uns auf unseren Code verlassen können, erlauben wir den Download ohne besondere Befürchtungen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fuh, Missgeschicke sind vorbei.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es lebt, lebt</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit angehaltenem Atem beschloss ich, meinem Frankenstein Leben einzuhauchen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir starten die Datenbank mit der vorinstallierten libfaketime und dem 0-Offset. Stellen Sie </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eine Verbindung zur Datenbank her und rufen Sie den Code auf, der einfach die Zeit vor und nach dem Ändern der Umgebungsvariablen anzeigt:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">begin</span>
dbms_output.enable(<span class="hljs-number">100000</span>);<font></font>
dbms_java.set_output(100000);<font></font>
dbms_output.put_line('old time: '||to_char(sysdate, 'dd.mm.yyyy hh24:mi:ss'));<font></font>
system.posix.set_env('FAKETIME','+1d');<font></font>
dbms_output.put_line('new time: '||to_char(sysdate, 'dd.mm.yyyy hh24:mi:ss'));<font></font>
<span class="hljs-keyword">end</span>;<font></font>
/<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es funktioniert, verdammt! </font><font style="vertical-align: inherit;">Ehrlich gesagt hatte ich weitere Überraschungen erwartet, wie zum Beispiel ORA-600-Fehler. </font><font style="vertical-align: inherit;">Die Warnung hatte jedoch die ganze Nummer und der Code funktionierte weiter. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist wichtig zu beachten, dass, wenn die Verbindung zur Datenbank als dediziert hergestellt wird, der Prozess nach Abschluss der Verbindung zerstört wird und keine Ablaufverfolgung erfolgt. </font><font style="vertical-align: inherit;">Wenn wir jedoch gemeinsam genutzte Verbindungen verwenden, wird in diesem Fall ein vorgefertigter Prozess aus dem Serverpool zugewiesen. Wir ändern die Zeit darin durch Umgebungsvariablen. Wenn die Verbindung getrennt wird, bleibt sie innerhalb des Prozesses geändert. </font><font style="vertical-align: inherit;">Und wenn dann eine andere Datenbanksitzung in denselben Serverprozess fällt, wird sie zu ihrer erheblichen Überraschung die falsche Zeit erhalten. </font><font style="vertical-align: inherit;">Daher ist es am Ende der Testsitzung besser, die Zeit immer auf Null zurückzusetzen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, die Geschichte war interessant (und vielleicht sogar für jemanden nützlich). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quellcodes sind alle auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verfügbar </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die libfaketime Dokumentation </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie testest du? </font><font style="vertical-align: inherit;">Und wie erstellen Sie Entwicklungs- und Testdatenbanken in einem Unternehmen?</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonus für diejenigen, die bis zum Ende lesen</font></font></b>
                        <div class="spoiler_text"><img src="https://habrastorage.org/webt/wd/m1/s9/wdm1s9kk6_kckj-xf5amc_o6wjq.jpeg"><br>
</div>
                    </div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de503782/index.html">Wie erstelle ich einen interaktiven Tisch mit einer Arbeitsfläche in Form eines Kreises?</a></li>
<li><a href="../de503786/index.html">Digitale Darstellung von analogem Audio. Kurzes Bildungsprogramm</a></li>
<li><a href="../de503788/index.html">Dynamische E-Mail :: Sicherheit</a></li>
<li><a href="../de503790/index.html">Permutationen. 9.Klasse. Paritätsaufgabe</a></li>
<li><a href="../de503796/index.html">Support billiger machen und versuchen, die Qualität nicht zu verlieren</a></li>
<li><a href="../de503812/index.html">Agiler Pirat und einige Gesetze der Dialektik</a></li>
<li><a href="../de503826/index.html">Symmetrischer und asymmetrischer DDoS-Schutz - was ist der Unterschied?</a></li>
<li><a href="../de503830/index.html">Amazon hat ein großes Obdachlosenheim eröffnet</a></li>
<li><a href="../de503832/index.html">PostgreSQL-Rezepte: Mustach Template Engine</a></li>
<li><a href="../de503836/index.html">Vor- und Nachteile von Technologien zur Kommentarmoderation (+ Umfrage)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>