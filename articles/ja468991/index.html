<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍💼 🍜 👨🏿‍💻 モジュラースプライトキャラクターとそのアニメーション 👆🏾 👨🏻‍⚖️ 👨🏾‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="このブログ投稿は、完全に私のキャラクターアニメーションシステムに特化しており、役立つヒントやコードスニペットが満載されています。
 
 過去2か月間で、最大9つの新しいプレーヤーアクション（シールドでブロックしたり、ジャンプや武器をかわしたりするなど）、17の新しいウェアラブルアイテム、3セットの鎧...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>モジュラースプライトキャラクターとそのアニメーション</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468991/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このブログ投稿は、完全に私のキャラクターアニメーションシステムに特化しており、役立つヒントやコードスニペットが満載されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
過去2か月間で、最大9つの新しいプレーヤーアクション（シールドでブロックしたり、ジャンプや武器をかわしたりするなど）、17の新しいウェアラブルアイテム、3セットの鎧（プレート、シルク、レザー）と6種類のヘアスタイルを作成しました。</font><font style="vertical-align: inherit;">すべての自動化とツールの作成も終了したので、すべてがゲームですでに使用されています。</font><font style="vertical-align: inherit;">記事では、これをどのように達成したかを説明します！</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ef/52a/188/2ef52a1887cdbe639fd35d9df414c38d.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この情報がお役に立てば幸いです。また、このようなツールやオートメーションを独自に作成するために天才である必要はないことを証明しています。</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単な説明</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、互いに重ね合わせたスプライトをシンクロナイズドアニメーターと組み合わせて、交換可能なヘアスタイル、機器、ウェアラブルアイテムを備えたモジュラーキャラクターを作成できるかどうかを確認したいと思いました。手描きのピクセルアニメーションを本当にカスタマイズ可能なキャラクターと組み合わせることができますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、このような機能は、事前にレンダリングされたスプライトを使用した3Dおよび2Dゲームや、骨格アニメーションを使用した2Dゲームで積極的に使用されていますが、私が知る限り、手動で作成したアニメーションとモジュールキャラクターを組み合わせるゲームは多くありません（通常、プロセスが単調すぎる）。</font></font><br>
<a name="habracut"></a><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/412/7a9/d23/4127a9d23d4d84e28671deee781495cb.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unityを使用して最初の1か月でこの古代のGIFを見つけました。実際、このモジュラースプライトは、ゲーム開発における私の最初の実験の1つでした。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Unityアニメーションシステムを使用してプロトタイプを作成し、シャツ1枚、パンツ1枚、髪型1つ、および3つのアイテムを追加してコンセプトをテストしました。これには26の個別のアニメーションが必要でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当時、私はすべてのアニメーションをPhotoshopで作成し、プロセスの自動化を気にしていなかったため、非常に退屈でした。次に、「基本的なアイデアはうまくいったので、後で新しいアニメーションと設備を追加します」と考えました。 「後で」は数年後であることが判明しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今年の3月、私は大量の鎧のデザインを描き（以前の投稿を参照）、このプロセスをより便利にする方法に気づきました。</font><font style="vertical-align: inherit;">自動化を使用しても何も機能しないことに不安を感じていたため、実装を延期し続けました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手動アニメーションのほとんどのゲームのように、キャラクターのカスタマイズを放棄して、唯一のメインキャラクターを作成する必要があると思っていました。</font><font style="vertical-align: inherit;">しかし、私には行動計画があり、このモンスターを倒せるかどうかを確認する時が来ました！</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88b/030/c5a/88b030c5a82c6cd801f7ce4d8b08ff6d.gif"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddd/55f/12c/ddd55f12cb35e4fa22093cdddecd63d4.gif" width="500"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スポイラー：すべてが素晴らしかった。</font><font style="vertical-align: inherit;">以下に私の***の秘密を明かします***</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュラースプライトシステム</font></font></h2><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I.あなたの境界を知る</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前は、アートと時間制御の多くのテストを実施して、そのような作業にかかる時間と、同じレベルの品質を達成できるかどうかを確認しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アニメーションのアイデアをすべて書き留め、スプレッドシートにまとめて、有用性、美しさ、繰り返し使用などのさまざまな基準に従って整理しました。驚いたことに、このリストの一番最初は、アイテム（ポーション、爆弾、ナイフ、斧、ボール）のキャストアニメーションでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は各アニメーションの数値スコアを思いつき、パフォーマンスの悪いすべてのものを放棄しました。当初は6セットの鎧を作るつもりでしたが、多すぎることに気づき、3種類を投げました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間追跡の側面は非常に重要であることが判明しました。「ゲームで作成できる敵はいくつできますか？」などの質問に答えるためにそれを使用することを強くお勧めします。</font><font style="vertical-align: inherit;">ほんの数回のテストの後、私はかなり正確な推定値を推定することができました。</font><font style="vertical-align: inherit;">アニメーションについてさらに作業を重ねるうちに、時間を追跡し、期待を修正し続けました。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">過去2か月間の私のジャーナルのコピーを共有します。</font><font style="vertical-align: inherit;">この時間は、私が週30時間を費やす私の通常の作業に追加されていることに注意してください</font></font></i><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></a><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II。</font><font style="vertical-align: inherit;">明るい未来のためにパレットを変える</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スプライトデザインの色を賢く使用して、1つのスプライトを描画し、パレットを変更してさまざまなバリエーションを作成できます。色だけでなく、さまざまなオン/オフ要素を作成することもできます（たとえば、色を透明度に置き換える）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
鎧の各セットには3つのバリエーションがあり、上部と下部を組み合わせると、多くの組み合わせを得ることができます。私はあなたがキャラクターの外観のための鎧一式と彼の特性のための別の鎧一式を収集できるシステムを実装する予定です（Terrariaのように）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/873/80c/0b9/87380c0b99d150828af05b1a0cf33ef6.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その過程で、発見された奇妙な組み合わせに驚きました。</font><font style="vertical-align: inherit;">プレートの上部をシルクの下部に接続すると、ウォーメイジのスタイルで何かを得ることができます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スプライトの値をエンコードする色を使用してパレットを変更し、後でパレットから実際の色を見つけることができるようにするのが最善です。</font><font style="vertical-align: inherit;">私は少し簡略化していることを知っているので、ここにあなたが始めるためのビデオがあります：</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/u4Iz5AJa31Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてを詳細に説明するのではなく、Unityでこの手法を実装する方法と、その長所と短所について説明します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.各パレットのテクスチャを検索します</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、多くのスプライトが同じパレット/マテリアルを持つ、敵、背景、およびすべてのバリエーションを作成するための最良の戦略です。</font><font style="vertical-align: inherit;">同じスプライト/アトラスを使用していても、異なるマテリアルをバッチにグループ化することはできません。</font><font style="vertical-align: inherit;">テクスチャの操作はかなり面倒ですが、マテリアルのインスタンスごとに異なるパレットが必要な場合は、SpriteRenderer.sharedMaterial.SetTextureまたはMaterialPropertyBlockを使用してマテリアルを置き換えることにより、リアルタイムでパレットを変更できます。</font><font style="vertical-align: inherit;">以下は、フラグメントシェーダー関数の例です。</font></font><br>
<br>
<pre><code class="cpp hljs">sampler2D _MainTex;<font></font>
sampler2D _PaletteTex;<font></font>
float4 _PaletteTex_TexelSize;<font></font>
   <font></font>
<span class="hljs-function">half4 <span class="hljs-title">frag</span><span class="hljs-params">(v2f input)</span> : SV_TARGET </span>{<font></font>
 half4 lookup = tex2D(_MainTex, input.uv);<font></font>
 half4 color = tex2D(_PaletteTex, half2(lookup.r * (_PaletteTex_TexelSize.x / <span class="hljs-number">0.00390625f</span>), <span class="hljs-number">0.5</span>));<font></font>
 color.a *= lookup.a;<font></font>
 <span class="hljs-keyword">return</span> color * input.color;<font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.色の配列</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャラクターの外観が変化するたびに（たとえば、アイテムを置くときなど）パレットを交換し、動的にいくつかのパレットを作成する必要があるため（プレイヤーが選択した髪と肌の色を表示するため）、この決定に落ち着きました。実行時およびエディターでは、これらの目的で配列を操作する方がはるかに簡単だと私には思われました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード：</font></font><br>
<br>
<pre><code class="cpp hljs">sampler2D _MainTex;<font></font>
half4 _Colors[<span class="hljs-number">32</span>];<font></font>
<font></font>
<span class="hljs-function">half4 <span class="hljs-title">frag</span><span class="hljs-params">(v2f input)</span> : SV_TARGET </span>{<font></font>
 half4 lookup = tex2D(_MainTex, input.uv);<font></font>
 half4 color = _Colors[round(lookup.r * <span class="hljs-number">255</span>)];<font></font>
 color.a *= lookup.a;<font></font>
 <span class="hljs-keyword">return</span> color * input.color;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パレットをScriptableObjectタイプとして提示し、MonoBehaviourツールを使用して編集しました。 Asepriteでアニメーションを作成する過程でパレットの編集に長い間取り組んできたので、私は必要なツールを理解し、それに応じてこれらのスクリプトを作成しました。パレットを編集するための独自のツールを作成する場合は、次の機能を実装することをお勧めします</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 。-リアルタイムで変更を表示するために色を編集するときに、さまざまなマテリアルのパレットを更新します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -パレットでの名前の割り当てと色の順序の変更（配列での順序ではなく、フィールドを使用してカラーインデックスを格納します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -一度に複数の色を選択して編集します。</font><font style="vertical-align: inherit;">（ヒント：Unityで色フィールドをコピーして貼り付けることができます：ある色をクリックして、コピーして別の色をクリックして貼り付けてください-今は同じです！）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -オーバーレイ色をパレット全体に適用します</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -パレットをテクスチャに書き込みます</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.すべてのパレットに対する単一の検索テクスチャ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パレットをオンザフライで切り替えたいが、同時にバッチ処理を実行して描画呼び出しの数を減らす必要がある場合は、この手法を使用できます。モバイルプラットフォームでは便利かもしれませんが、使用するのは非常に不便です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、すべてのパレットを1つの大きなテクスチャにパックする必要があります。次に、SpriteRendererコンポーネントで指定された色（別名頂点カラー）を使用して、パレットテクスチャからシェーダーに読み込まれるラインを決定します。つまり、このスプライトのパレットは、SpriteRenderer.colorによって制御されます。頂点カラーは、条件を壊すことなく変更できる唯一のSpriteRendererプロパティです（すべてのマテリアルが同じである場合）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、アルファチャネルを使用してインデックスを制御することをお勧めします。これは、透明度の異なる一連のスプライトはおそらく必要ないためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード：</font></font><br>
<br>
<pre><code class="cpp hljs">sampler2D _MainTex;<font></font>
sampler2D _PaletteTex;<font></font>
float4 _PaletteTex_TexelSize;<font></font>
   <font></font>
<span class="hljs-function">half4 <span class="hljs-title">frag</span><span class="hljs-params">(v2f input)</span> : SV_TARGET </span>{<font></font>
 half4 lookup = tex2D(_MainTex, input.uv);<font></font>
 half2 paletteUV = half2(<font></font>
  lookup.r * _(PaletteTex_TexelSize.x / <span class="hljs-number">0.00390625f</span>),<font></font>
  input.color.a * _(PaletteTex_TexelSize.y / <span class="hljs-number">0.00390625f</span>)<font></font>
 )<font></font>
 half4 color = tex2D(_PaletteTex, paletteUV);<font></font>
 color.a *= lookup.a;<font></font>
 color.rgb *= input.color.rgb;<font></font>
 <span class="hljs-keyword">return</span> color;<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47c/f90/895/47cf908951a0ba9f8f65a57711a5c85c.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パレットとスプライトレイヤーの交換の不思議。</font><font style="vertical-align: inherit;">非常に多くの組み合わせ。</font></font></i><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">III。</font><font style="vertical-align: inherit;">すべてを自動化し、適切なツールを使用します。</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この機能を実装するには、結果として約300のアニメーションと数千のスプライトを得たので、自動化は絶対に必要でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の最初のステップは、便利な</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コマンドラインインターフェース</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して、非常識なスプライトレイヤースキームを管理するAsepriteのエクスポーターを作成することでした</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、私のAsepriteファイル内のすべてのレイヤーとラベルをバイパスし、特定のディレクトリと名前構造に画像をエクスポートして後で読むことができるようにする、単なるPerlスクリプトです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、Unityのインポーターを作成しました。</font><font style="vertical-align: inherit;">Asepriteはフレームデータを含む便利なJSONファイルを表示するため、プログラムでアニメーションアセットを作成できます。</font><font style="vertical-align: inherit;">Aseprite JSONの処理とこのデータ型の記述はかなり退屈であることが判明したので、ここに持ってきます。</font><font style="vertical-align: inherit;">JsonUtility.FromJson &lt;AespriteData&gt;を使用してUnityに簡単にロードできます。オプション--format 'json-array'を使用してAsepriteを実行することを忘れないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード：</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">System.Serializable</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> AespriteData {<font></font>
 [<span class="hljs-meta">System.Serializable</span>]
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Size {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> w;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> h;<font></font>
 }<font></font>
<font></font>
 [<span class="hljs-meta">System.Serializable</span>]
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Position {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> x;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> y;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> w;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> h;<font></font>
 }<font></font>
<font></font>
 [<span class="hljs-meta">System.Serializable</span>]
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Frame {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> filename;
  <span class="hljs-keyword">public</span> Position frame;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> rotated;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> trimmed;
  <span class="hljs-keyword">public</span> Position spriteSourceSize;
  <span class="hljs-keyword">public</span> Size sourceSize;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> duration;<font></font>
 }<font></font>
<font></font>
 [<span class="hljs-meta">System.Serializable</span>]
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Metadata {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> app;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> version;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> format;
  <span class="hljs-keyword">public</span> Size size;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> scale;<font></font>
 }<font></font>
<font></font>
<font></font>
 <span class="hljs-keyword">public</span> Frame[] frames;
 <span class="hljs-keyword">public</span> Metadata meta;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unity側では、スプライトシートの読み込み/スライスとアニメーションクリップの作成という2つの場所で深刻な問題が発生しました。</font><font style="vertical-align: inherit;">明確な例は私を大いに助けるでしょう、それであなたがそれほど苦しむことがないように私のインポーターからのコードのスニペットがあります：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード：</font></font><br>
<br>
<pre><code class="cs hljs">TextureImporter textureImporter = AssetImporter.GetAtPath(spritePath) <span class="hljs-keyword">as</span> TextureImporter;<font></font>
textureImporter.spriteImportMode = SpriteImportMode.Multiple;<font></font>
<font></font>
SpriteMetaData[] spriteMetaData = <span class="hljs-keyword">new</span> SpriteMetaData[aespriteData.frames.Length];<font></font>
<font></font>
<span class="hljs-comment">// Slice the spritesheet according to the aesprite data.</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; aespriteData.frames.Length; i++) {<font></font>
 AespriteData.Position spritePosition = aespriteData.frames[i].frame;<font></font>
<font></font>
 spriteMetaData[i].name = aespriteData.frames[i].filename;<font></font>
 spriteMetaData[i].rect = <span class="hljs-keyword">new</span> Rect(spritePosition.x, spritePosition.y, spritePosition.w, spritePosition.h);<font></font>
 spriteMetaData[i].alignment = (<span class="hljs-keyword">int</span>)SpriteAlignment.Custom; <span class="hljs-comment">// Same as "Pivot" in Sprite Editor.</span>
 spriteMetaData[i].pivot = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">0.5f</span>, <span class="hljs-number">0f</span>); <span class="hljs-comment">// Same as "Custom Pivot" in Sprite Editor. Ignored if alignment isn't "Custom".</span><font></font>
}<font></font>
<font></font>
textureImporter.spritesheet = spriteMetaData;<font></font>
AssetDatabase.ImportAsset(spritePath, ImportAssetOptions.ForceUpdate);<font></font>
<font></font>
Object[] assets = AssetDatabase.LoadAllAssetsAtPath(spritePath); <span class="hljs-comment">// The first element in this array is actually a Texture2D (i.e. the sheet itself).</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; assets.Length; i++) {<font></font>
 sprites[i - <span class="hljs-number">1</span>] = assets[i] <span class="hljs-keyword">as</span> Sprite;<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-comment">// Create the animation.   </span>
AnimationClip clip = <span class="hljs-keyword">new</span> AnimationClip();<font></font>
clip.frameRate = <span class="hljs-number">40f</span>;
<span class="hljs-keyword">float</span> frameLength = <span class="hljs-number">1f</span> / clip.frameRate;<font></font>
<font></font>
ObjectReferenceKeyframe[] keyframes = <span class="hljs-keyword">new</span> ObjectReferenceKeyframe[aespriteData.frames.Length + <span class="hljs-number">1</span>]; <span class="hljs-comment">// One extra keyframe is required at the end to express the last frame's duration.</span><font></font>
<font></font>
<span class="hljs-keyword">float</span> time = <span class="hljs-number">0f</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; keyframes.Length; i++) {
 <span class="hljs-keyword">bool</span> lastFrame = i == keyframes.Length - <span class="hljs-number">1</span>;<font></font>
<font></font>
 ObjectReferenceKeyframe keyframe = <span class="hljs-keyword">new</span> ObjectReferenceKeyframe();<font></font>
 keyframe.<span class="hljs-keyword">value</span> = sprites[lastFrame ? i - <span class="hljs-number">1</span> : i];<font></font>
 keyframe.time = time - (lastFrame ? frameLength : <span class="hljs-number">0f</span>);<font></font>
<font></font>
 keyframes[i] = keyframe;<font></font>
<font></font>
 time += lastFrame ? <span class="hljs-number">0f</span> : aespriteData.frames[i].duration / <span class="hljs-number">1000f</span>;<font></font>
}<font></font>
<font></font>
EditorCurveBinding binding = <span class="hljs-keyword">new</span> EditorCurveBinding();<font></font>
binding.type = <span class="hljs-keyword">typeof</span>(SpriteRenderer);<font></font>
binding.path = <span class="hljs-string">""</span>;<font></font>
binding.propertyName = <span class="hljs-string">"m_Sprite"</span>;<font></font>
AnimationUtility.SetObjectReferenceCurve(clip, binding, keyframes);<font></font>
<font></font>
AssetDatabase.CreateAsset(clip, <span class="hljs-string">"Assets/Animation/"</span> + name + <span class="hljs-string">".anim"</span>);<font></font>
AssetDatabase.SaveAssets();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これをまだ行っていない場合は、私を信じてください。独自のツールの作成を開始するのは非常に簡単です。</font><font style="vertical-align: inherit;">最も単純なトリックは、[ExecuteInEditMode]属性を持つMonoBehaviourがアタッチされたシーンにGameObjectを配置することです。</font><font style="vertical-align: inherit;">ボタンを追加すると、戦いの準備が整います！</font><font style="vertical-align: inherit;">個人用ツールは見栄えがする必要はありません。純粋に実用的である場合もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード：</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">ExecuteInEditMode</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyCoolTool</span> : <span class="hljs-title">MonoBehaviour</span> {<font></font>
   <font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> button;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">if</span> (button) { button = <span class="hljs-literal">false</span>; DoThing(); }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スプライトを使用する場合、標準的なタスク（たとえば、パレットテクスチャの作成や複数のスプライトファイルでの色の一括置換）を自動化するのは非常に簡単です。</font><font style="vertical-align: inherit;">以下は、スプライトの変更方法を学ぶための例です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">string</span> path = <span class="hljs-string">"Assets/Whatever/Sprite.png"</span>;<font></font>
Texture2D texture = AssetDatabase.LoadAssetAtPath&lt;Texture2D&gt;(path);<font></font>
TextureImporter textureImporter = AssetImporter.GetAtPath(path) <span class="hljs-keyword">as</span> TextureImporter;
<span class="hljs-keyword">if</span> (!textureImporter.isReadable) {<font></font>
 textureImporter.isReadable = <span class="hljs-literal">true</span>;<font></font>
 AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);<font></font>
}<font></font>
<font></font>
Color[] pixels = texture.GetPixels(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, texture.width, texture.height);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pixels.Length; i++) {
 <span class="hljs-comment">// Do something with the pixels, e.g. replace one color with another.</span><font></font>
}<font></font>
<font></font>
texture.SetPixels(pixels);<font></font>
texture.Apply();<font></font>
textureImporter.isReadable = <span class="hljs-literal">false</span>; <span class="hljs-comment">// Make sure textures are marked as un-readable when you're done. There's a performance cost to using readable textures in your project that you should avoid unless you plan to change a sprite at runtime.</span><font></font>
<font></font>
<span class="hljs-keyword">byte</span>[] bytes = ImageConversion.EncodeToPNG(texture);<font></font>
File.WriteAllBytes(Application.dataPath + path.Substring(<span class="hljs-number">6</span>), bytes);<font></font>
AssetDatabase.ImportAsset(path, ImportAssetOptions.ForceUpdate);</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メカニムの機会をどのようにして生かすか：苦情</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
APIは常に変化し、ドキュメントが不十分だったため、Mecanimを使用して作成したプロトタイプのモジュラースプライトシステムは、Unityのアップグレード時に最大の問題となりました。単純なステートマシンの場合、各クリップのステータスをクエリしたり、実行時にクリップを変更したりできると便利です。しかし、違います！パフォーマンス上の理由から、Unityはクリップをその状態でベイク処理し、不器用な再定義システムを使用してクリップを変更するように強制します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mecanim自体はそれほど悪いシステムではありませんが、宣言された主な機能であるシンプルさを実現できていないようです。開発者のアイデアは、複雑で痛みを伴うもの（スクリプト）を単純なもの（ビジュアルステートマシン）に置き換えることでした。しかしながら：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -自明ではない有限状態マシンは、すぐにノードと接続の野生のウェブに変わり、そのロジックはさまざまなレイヤーに散在します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -単純な使用例は、一般化されたシステム要件によって妨げられています。 1つまたは2つのアニメーションを再生するには、新しいコントローラーを作成し、状態/遷移を割り当てる必要があります。もちろん、リソースの過剰な浪費があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -面白いのは、結果として、コードを記述する必要があることです。ステートマシンが興味深いことを行うには、Animator.SetBoolおよび同様のメソッドを呼び出すスクリプトが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -他のクリップでステートマシンを複数回使用するには、それを複製し、手動でクリップを置き換える必要があります。将来的には、いくつかの場所で変更を加える必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -実行時に状態を変更したい場合、問題があります。解決策は、すべての可能なアニメーションに対して1つのノードを持つ不良APIまたはクレイジーグラフのいずれかです。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/8VgQ5PpTqjc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Firewatch開発者が</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジュアルスクリプティングの地獄に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入り込んだストーリー</font><font style="vertical-align: inherit;">。おもしろいのは、スピーカーが最も単純な例を示しているとき、彼らはまだ狂って見えるということです。観客は文字通り</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:41に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">うめき</font><font style="vertical-align: inherit;">ます。莫大なメンテナンス費用を追加すれば、私がこのシステムを強く嫌う理由がわかるでしょう。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これらの問題の多くはMecanim開発者のせいでもありませんが、単に互換性のないアイデアの自然な結果です：共通かつ同時に単純なシステムを作成することはできません。 。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2018年のプラクティスニューヨークで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ザックマクレンドン</font></a><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">レポートの</font></a><font style="vertical-align: inherit;">一部を思い出しました。</font><font style="vertical-align: inherit;">時間があれば、ビデオ全体をご覧になることをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私はそれを理解しました。ビジュアルスクリプティングは、アーティストのニーズを理解しない積極的な「独自のエンジンを作成する」オタクによって常に非難されています。また、ほとんどのコードが理解できない専門用語のように見えることも否定できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたがすでに小さなプログラマーであり、スプライトでゲームを作っているなら、あなたは二度考える必要があるかもしれません。私が始めたとき、私はUnity開発者よりも優れたエンジンに関連する何かを書くことができないと確信していました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、あなたは何を知っていますか？</font><font style="vertical-align: inherit;">スプライトアニメーターは、指定された秒数後にスプライトを変更する単なるスクリプトであることがわかりました。</font><font style="vertical-align: inherit;">とにかく、自分で書く必要がありました。</font><font style="vertical-align: inherit;">それ以来、特定のプロジェクトにアニメーションイベントやその他の機能を追加しましたが、半日で書いた基本バージョンは私のニーズの90％をカバーしています。</font><font style="vertical-align: inherit;">これは、120行で構成されており、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">//pastebin.com/m9Lfmd94</font></a><font style="vertical-align: inherit;">から無料でダウンロードでき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私の記事を読んでいただきありがとうございます。</font><font style="vertical-align: inherit;">またね！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja468967/index.html">TAUの動的方程式を得る「技術」。そして、なぜシステム識別は厄介であり、「正直な物理学」が支配するのか</a></li>
<li><a href="../ja468969/index.html">APIを介してPowerShellからGoogleユーザーを作成する</a></li>
<li><a href="../ja468971/index.html">ニンテンドーDS用のJavaで書く</a></li>
<li><a href="../ja468973/index.html">PythonでTensorflowを使用して衛星画像を分類するためのニューラルネットワーク</a></li>
<li><a href="../ja468989/index.html">UEBAマーケットダイ-ロングライブUEBA</a></li>
<li><a href="../ja468993/index.html">Oculus QuestがPCに接続し、手を見る</a></li>
<li><a href="../ja468995/index.html">オープン性ポリシー：ユーザーがプロジェクトに与える影響</a></li>
<li><a href="../ja468997/index.html">メンタリング-必須または素晴らしいボーナス？</a></li>
<li><a href="../ja468999/index.html">「最も遅い」インターネットを利用している国、および到達困難な地域の状況を修正している国</a></li>
<li><a href="../ja469001/index.html">マイクロサービスからお粥を調理する方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>