<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍩 🤵 🍟 Schwache Haufen-Sortierung 💃🏿 👨🏻‍🎨 😝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von den gesamten Zoohaufen ist diese Struktur vielleicht die ungewöhnlichste. Darüber hinaus passt die elegante Einfachheit des Algorithmus durchaus z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Schwache Haufen-Sortierung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/499786/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><div style="text-align:center;"><img width="765" height="430" src="https://habrastorage.org/webt/hh/ve/rt/hhvertyrtwsbd99rbboihxxyjjk.jpeg"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von den gesamten Zoohaufen ist diese Struktur vielleicht die ungewöhnlichste. </font><font style="vertical-align: inherit;">Darüber hinaus passt die elegante Einfachheit des Algorithmus durchaus zu seiner erstaunlichen Exzentrizität. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Sortieren mit einem schwachen Heap gibt es immer weniger Vergleiche und Austausche als mit einem normalen Heap. </font><font style="vertical-align: inherit;">Also ja, ein schwacher Stapel ist stärker als ein gewöhnlicher Stapel.</font></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="EDISON Software - Webentwicklung"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - Webentwicklung"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel wurde mit Unterstützung von EDISON verfasst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir beschäftigen uns mit der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellung eingebetteter Software</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sowie der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entwicklung von Webanwendungen und Websites</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir lieben die Theorie der Algorithmen! </font><font style="vertical-align: inherit;">;-);</font></font></blockquote><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwacher Haufen</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein regulärer Heap ist ein Sortierbaum,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in dem ein Elternteil größer (oder gleich) ist als einer seiner Nachkommen. </font><font style="vertical-align: inherit;">In einem schwachen Haufen wird diese Anforderung geschwächt - jeder Elternteil ist größer (oder gleich) als jeder Nachkomme nur von seinem rechten Teilbaum. </font><font style="vertical-align: inherit;">Im linken Teilbaum können die Nachkommen sowohl kleiner als auch größer als die Eltern sein, da haben Sie so viel Glück.</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="299" src="https://habrastorage.org/webt/by/f6/ef/byf6efzj8swlst2y_2dvb7onduu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Ansatz kann die Kosten für die Aufrechterhaltung des Datensatzes in einem Heap-Zustand erheblich reduzieren. </font><font style="vertical-align: inherit;">Schließlich muss sichergestellt werden, dass das Prinzip „ein Nachkomme ist nicht mehr als ein Elternteil“ nicht für die gesamte Struktur, sondern nur für die Hälfte gilt. </font><font style="vertical-align: inherit;">Gleichzeitig sortiert ein schwacher Haufen, der kein 100% iger Sortierbaum ist, nicht schlechter als ein gewöhnlicher Haufen und in gewisser Weise sogar noch besser. </font><font style="vertical-align: inherit;">Hat die halbe Miete geschafft - mutig gehen! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da die Wurzel des Heaps, auch eine schwache, genau das größte Element benötigt, tut dies die Wurzel des linken Teilbaums nicht.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimierung der Anzahl der Vergleiche</font></font></h2><br>
<img align="left" width="215" height="199" src="https://habrastorage.org/webt/ng/cu/e1/ngcue1zei7olyudhfpge5blkcgu.jpeg"><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ronald D. Dutton, Spezialist für Algorithmen und Graphentheorie, stellte uns 1993 einen schwachen Haufen vor. </font><font style="vertical-align: inherit;">Ein konzeptionell schwacher Stapel ist schwieriger zu verstehen (aber diese Schwierigkeit liegt eher nicht in der Komplexität, sondern in der Extravaganz, Sie müssen Ihre Bewusstseinsmuster durch das Knie brechen) als ein gewöhnlicher Stapel, so dass er nicht viel praktische Verteilung erhalten hat. </font><font style="vertical-align: inherit;">Als Dutton diese Struktur erfand, wollte er nicht nur abstrakte Abstraktionen üben, sondern verfolgte auch ein völlig pragmatisches Ziel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt eine theoretische Untergrenze für die Schätzung der Mindestanzahl von Vergleichen (bei den Sortierungen, bei denen diese Vergleiche weit verbreitet sind): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">= </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / ln 2 + O (log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), wobei 1 / ln 2 = 1,4426 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Sortierung nach einem schwachen Haufen wird die Anzahl der Vergleiche minimiert und liegt nahe genug an der Untergrenze. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies kann von praktischer Bedeutung sein, wenn Sie Objekte anordnen müssen, deren Vergleich teuer ist, z. B. wenn lange Zeichenfolgen sortiert werden sollen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachkommen jonglieren</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Links" und "Rechts" in einem schwachen Haufen ist ein situatives Phänomen. Ein Teilbaum kann entweder ein linker oder ein rechter Nachkomme für seinen übergeordneten Knoten sein - außerdem kann diese "links / rechts" -Relation für den Teilbaum und den übergeordneten Knoten während des Prozesses wiederholt von einem Wert zum anderen wechseln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für den Elternteil anzugeben, wer seinen rechten Sohn hat und wer seine linke Tochter ist, ist nicht einfach, aber sehr einfach. Dazu benötigen Sie eine zusätzliche Bitmap (bestehend aus nur 0/1 Werten) für die Knoten mit Nachkommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erinnern Sie sich daran, wie das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> te übergeordnete Element </font><font style="vertical-align: inherit;">des Index </font><font style="vertical-align: inherit;">die Indizes seines linken und rechten Nachkommen in einem herkömmlichen Stapel definiert (Indizes des Arrays gemessen von Null): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linker Nachkomme 2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rechter Nachkomme 2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einem schwachen Haufen haben wir eine Kirsche auf dem Kuchen - eine Wurzel, die nur den richtigen Teilbaum hat, also werden wir diese Formeln für die Nachkommenindizes anpassen, indem wir eine umgekehrte Verschiebung zu 1 Position hinzufügen: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linker Nachkomme: 2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Rechter Nachkomme: 2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und schließlich , benötigte zusätzliche Bitmap (nenne es </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), wobei für das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i- </font></font></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">te</font></b><font style="vertical-align: inherit;"> Element angegeben wurde, ob der Austausch zwischen seinen linken und rechten Teilbäumen stattfindet. Wenn der Wert für ein Element 0 ist, gab es keinen Austausch. Wenn der Wert 1 ist, gehen die linken und rechten Kinder in die entgegengesetzte Reihenfolge. In diesem Fall lauten die Formeln wie folgt: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linker Nachkomme: 2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rechter Nachkomme: 2 × </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht es aus. </font><font style="vertical-align: inherit;">Elemente, deren Nachkommen sich "umgekehrt" befinden, werden blau hervorgehoben. </font><font style="vertical-align: inherit;">Die Werte im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array </font><font style="vertical-align: inherit;">für sie sind 1.</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="330" src="https://habrastorage.org/webt/h0/by/bm/h0bybmjxpw21mdj1x3uyamtsyk4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können dies überprüfen, indem Sie die übergeordneten Werte </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die entsprechende 0/1 aus dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array </font><font style="vertical-align: inherit;">in den Nachkommenformeln einsetzen. </font><font style="vertical-align: inherit;">Die Indizes der Nachkommen werden nach Bedarf angezeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, muss die Gruppe von Elementen nirgendwo hin verschoben werden, damit ein Elternteil die linken und rechten Teilbäume im Array selbst vertauschen kann. </font><font style="vertical-align: inherit;">Es wird nur der 0/1-Wert für das übergeordnete </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Element</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im </font><b><font style="vertical-align: inherit;">BIT-</font></b><font style="vertical-align: inherit;"> Array </font><b><font style="vertical-align: inherit;">umgeschaltet</font></b><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weiter - eine magische Sitzung mit anschließender Belichtung.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baue einen schwachen Haufen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Vertauschen von Nachkommen nach links und rechts ist das Hauptwerkzeug zum Konvertieren eines Datensatzes aus einem Array in einen schwachen Haufen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Bildung des primären schwachen Heaps müssen wir die Elemente des Arrays in umgekehrter Reihenfolge (beginnend mit dem letzten) sortieren und für jeden von ihnen den Zweig des ersten (rechten) übergeordneten Elements finden, für den es der richtige Teilbaum ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Element der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">richtige Nachkomme einer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Person ist </font><font style="vertical-align: inherit;">, müssen Sie nicht weit gehen. </font><font style="vertical-align: inherit;">Das unmittelbare Elternteil ist das, was Sie brauchen:</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="304" src="https://habrastorage.org/webt/tg/_4/01/tg_401fvyqumg-j_nbwm1-n_bna.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Element der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linke Nachkomme einer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Person ist </font><font style="vertical-align: inherit;">, müssen Sie einige Stufen aufsteigen, bevor Sie den gewünschten Großelternteil treffen, für den sich das Element im rechten Teilbaum befindet:</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="304" src="https://habrastorage.org/webt/lk/ud/-f/lkud-fixce2hbm1d7ejuil3pnh8.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann müssen Sie den Nachkommen und den Vorfahren vergleichen, die irgendwo oben gefunden wurden. </font><font style="vertical-align: inherit;">Und wenn der Nachkomme größer als der Vorfahr ist, muss Folgendes getan werden:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Nachkomme seine Nachkommen hat, tauschen Sie seine linken und rechten Teilbäume aus (d. H. Schalten Sie 0/1 im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array </font><font style="vertical-align: inherit;">für dieses Element).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tauschen Sie die Werte des Nachkommenknotens und des Vorläuferknotens aus.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich ein bestimmtes Beispiel an. </font><font style="vertical-align: inherit;">Nehmen wir an, die folgende Situation ist aufgetreten:</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="339" src="https://habrastorage.org/webt/8f/-8/kr/8f-8krbczd6kxh2o-cbbe4hdkdc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für das Element des Arrays </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] = 87 wurde der notwendige Vorläufer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1] = 76 gefunden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Vorläufer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1] ist kleiner als das Element </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] (76 &lt;87). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Element </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] hat linke und rechte Teilbäume (in Grüntönen markiert). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie müssen diese Teilbäume austauschen </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
( </font><font style="vertical-align: inherit;">dh </font><font style="vertical-align: inherit;">für Element </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array </font><font style="vertical-align: inherit;">den Wert von 0 auf 1 ändern). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist auch notwendig, die Werte der Elemente </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1] </font><font style="vertical-align: inherit;">auszutauschen </font><font style="vertical-align: inherit;">.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nachdem die erforderlichen Aktionen abgeschlossen sind:</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="339" src="https://habrastorage.org/webt/zy/fb/vb/zyfbvbqsvoyyidown3ljp5pe8mk.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für Element </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] wurden die linken und rechten Teilbäume ausgetauscht </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
( </font><font style="vertical-align: inherit;">dh </font><font style="vertical-align: inherit;">im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array </font><font style="vertical-align: inherit;">für Element </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] wurde der Wert von 0 in 1 geändert). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gab auch einen Werteaustausch zwischen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1]. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie das Array vom Ende bis zum Anfang durchlaufen und unterwegs dieses Verfahren für alle Elemente ausführen, erhalten Sie einen schwachen Haufen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum dieser seltsame Mechanismus funktioniert, ist eine Erklärung, die näher am Ende des Artikels liegt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse eines schwachen Stapels</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Heap ist ein Heap, wenn sich das maximale Element im Stammverzeichnis befindet. Mit dieser Tatsache funktionieren alle Heap-Sortierungen auf die gleiche Weise. Die Wurzel (wo sich das Maximum befindet) tauscht Werte mit dem letzten Element des unsortierten Teils des Arrays aus. Infolgedessen nimmt der unsortierte Teil des Arrays ab und der sortierte Teil des Arrays nimmt zu. Nach diesem Austausch ist der Heap kein Heap mehr, da sich das aktuelle maximale Element nicht mehr in seiner Wurzel befindet. Der Heap muss wiederhergestellt werden, dh der resultierende Baum wird wieder zu einem Heap. Suchen Sie ein anderes maximales Element und verschieben Sie es in den Stamm. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wissen, wie man einen normalen binären Heap wiederherstellt - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit Hilfe eines Sichters</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Aber wie kann man einen schwachen Haufen wiederherstellen? Gehen Sie dazu wie folgt vor.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von der Wurzel steigen wir die linken Nachkommen ab (bis zum niedrigsten):</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="339" src="https://habrastorage.org/webt/ka/d1/t8/kad1t8a7egmsgtgrpuqk6txqajc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann gehen wir die linken Nachkommen wieder hoch und auf dem Weg wird jeder linke Nachkomme mit einem Element in der Heap-Wurzel verglichen. </font><font style="vertical-align: inherit;">Und wenn der nächste linke Nachkomme größer als die Wurzel ist, machen wir dasselbe wie in der vorherigen Stufe: Beim linken Nachkommen tauschen wir die Teilbäume (falls er einen hat) und ändern die Werte des linken Nachkommen und der Wurzel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen stellen wir den schwachen Heap wieder her - das maximale Element im verbleibenden Baum wird an seiner Wurzel angezeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wieder haben wir dieses mystische Karussell mit Teilbäumen, die sich gegenseitig ersetzen. </font><font style="vertical-align: inherit;">Was ist das Erfolgsgeheimnis? </font><font style="vertical-align: inherit;">Warum erhalten wir ein sortiertes Array, wenn beim Austausch von Knoten mit Werten die linken und rechten Nachkommen des unteren Knotens vertauscht werden? </font><font style="vertical-align: inherit;">Sie werden es nie erraten, obwohl die Antwort in ihrem Genie einfach ist.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwache Heap-Sortierung :: Schwache Heap-Sortierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also der endgültige Algorithmus:</font></font><br>
<br>
<ul>
<li><b>I.     :</b><ul>
<li><b>I.1.</b>    -.</li>
<li><b>I.2.</b>           «» .</li>
<li><b>I.3.</b>       .</li>
<li><b>I.4.</b>       , :<ul>
<li><b>I.4..</b>   ( ⇔ )     ,     .</li>
<li><b>I.4..</b>    «»      .</li>
</ul></li>
</ul></li>
<li><b>II.            ,     :</b><ul>
<li><b>II.1.</b>           .</li>
<li><b>II.2.</b>             .         .</li>
<li><b>II.3.</b>        ,        .   :<ul>
<li><b>II.3..</b>          .</li>
<li><b>II.3..</b>        ,      .</li>
<li><b>II.3..</b>     ,    , :<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.3.c. 1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir tauschen (links ⇔ rechts) Teilbäume mit Nachkommen gegen den Knoten aus, in dem sich der aktuelle linke Nachkomme befindet.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.3.c.2. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir ändern die Heap-Wurzel und den Knoten mit dem aktuellen linken Kind.</font></font></li>
</ul></li>
</ul></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.4. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An der Wurzel des schwachen Heaps befindet sich wieder das maximale Element für den verbleibenden unsortierten Teil des Arrays. </font><font style="vertical-align: inherit;">Wir kehren zu Absatz II.1 zurück und wiederholen den Vorgang, bis alle Elemente sortiert sind.</font></font></li>
</ul></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Animation (Array-Indizes in meinen Animationen beginnen mit einem):</font></font><br>
<br>
<div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/1l/ay/j-/1layj-xmzm4dl7p5yv7_5iag5pa.gif"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ - Code</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende des Abschnitts „Links“ können sich Interessenten mit der Implementierung dieser Sortierung in C ++ vertraut machen. </font><font style="vertical-align: inherit;">Hier gebe ich nur den Teil an, der den Algorithmus selbst veranschaulicht.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GETFLAG(r, x) ((r[(x) &gt;&gt; 3] &gt;&gt; ((x) &amp; 7)) &amp; 1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TOGGLEFLAG(r, x) (r[(x) &gt;&gt; 3] ^= 1 &lt;&lt; ((x) &amp; 7))</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WeakHeap::WeakHeapMerge</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *r, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>{
  <span class="hljs-keyword">if</span> (wheap[i] &lt; wheap[j]) {<span class="hljs-comment">//""  ?</span>
    <span class="hljs-comment">//  ,   </span>
    <span class="hljs-comment">//( "",   "")</span><font></font>
    TOGGLEFLAG(r, j);<font></font>
    <span class="hljs-comment">//  ""  </span><font></font>
    swap(wheap[i], wheap[j]);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WeakHeap::WeakHeapSort</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span> n = Size();
  <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">1</span>) {<font></font>
		<font></font>
    <span class="hljs-keyword">int</span> i, j, x, y, Gparent;
    <span class="hljs-keyword">int</span> s = (n + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> * r = <span class="hljs-keyword">new</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> [s];<font></font>
		<font></font>
    <span class="hljs-comment">//  ,    </span>
    <span class="hljs-comment">// "",   ""</span>
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">8</span>; ++i) r[i] = <span class="hljs-number">0</span>;<font></font>
		<font></font>
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">for</span>(i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) {<font></font>
      j = i;<font></font>
      <span class="hljs-comment">//    , </span>
      <span class="hljs-comment">//   ""  </span>
      <span class="hljs-keyword">while</span> ((j &amp; <span class="hljs-number">1</span>) == GETFLAG(r, j &gt;&gt; <span class="hljs-number">1</span>)) j &gt;&gt;= <span class="hljs-number">1</span>;
      <span class="hljs-comment">//       ""  </span>
      Gparent = j &gt;&gt; <span class="hljs-number">1</span>;
      <span class="hljs-comment">//  ,   </span>
      <span class="hljs-comment">//   ""</span><font></font>
      WeakHeapMerge(r, Gparent, i);<font></font>
    }<font></font>
		<font></font>
    <span class="hljs-comment">//      --&gt;</span>
    <span class="hljs-comment">//  --&gt;    </span>
    <span class="hljs-keyword">for</span>(i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">2</span>; --i) {
      <span class="hljs-comment">//      </span>
      <span class="hljs-comment">//       </span>
      swap(wheap[<span class="hljs-number">0</span>], wheap[i]);<font></font>
      x = <span class="hljs-number">1</span>;
      <span class="hljs-comment">//    "" </span>
      <span class="hljs-keyword">while</span>((y = <span class="hljs-number">2</span> * x + GETFLAG(r, x)) &lt; i) x = y;
      <span class="hljs-comment">//  ""     </span>
      <span class="hljs-comment">//        </span>
      <span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span>) {<font></font>
        WeakHeapMerge(r, <span class="hljs-number">0</span>, x);<font></font>
        x &gt;&gt;= <span class="hljs-number">1</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">//  -   </span>
    <span class="hljs-comment">//    </span>
    swap(wheap[<span class="hljs-number">0</span>], wheap[<span class="hljs-number">1</span>]);
    <span class="hljs-keyword">delete</span>[] r;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mir gefällt besonders, wie der Binärbaum einfach und natürlich mit bitweisen Operationen durchlaufen wird.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusätzliche Speicherkomplexität</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint wie O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - ein zusätzliches Array ist erforderlich, bei dem für Knoten mit Nachkommen (es gibt ungefähr die Hälfte davon im Array) die Reihenfolge der linken / rechten Teilbäume festgelegt ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt jedoch eine Meinung, dass die Sortierkomplexität hier tatsächlich O (1) ist! </font><font style="vertical-align: inherit;">Für ein Element benötigen wir nur ein zusätzliches Bit (Null / Eins), um die Reihenfolge der Nachkommen anzugeben. </font><font style="vertical-align: inherit;">Wenn wir zum Beispiel Strings sortieren, ist es durchaus möglich, dieses zusätzliche Bit an das Element selbst anzuhängen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine andere Möglichkeit, O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) in O (1) umzuwandeln, besteht darin, Flags in einer ganzen Zahl zu speichern. </font><font style="vertical-align: inherit;">Binäre Erweiterung von Zahlen - eine Reihe von Nullen und Einsen, die für die Reihenfolge der Teilbäume aller Elemente des Arrays verantwortlich sind. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> te Element des Arrays entspricht dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ten Bit der Zahl.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitliche Komplexität</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der Zeit ist O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dasselbe wie ein regulärer Heap. </font><font style="vertical-align: inherit;">Beim Sortieren von Zeilen (insbesondere langen) kann ein schwacher Heap schneller sein als ein normaler Heap. </font><font style="vertical-align: inherit;">Aber das ist, wenn wir die langen Schlangen sortieren. </font><font style="vertical-align: inherit;">Wenn wir die Zahlen sortieren, ist Gerüchten zufolge ein gewöhnlicher Haufen schneller zu verwalten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volles Sieben</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Phase der Bildung des anfänglichen schwachen Haufens schlägt die ganz offensichtliche Idee in Analogie zum üblichen Haufen vor, große Elemente so hoch wie möglich anzuheben. </font><font style="vertical-align: inherit;">Das heißt, wenn wir die Werte des unteren Knotens und seines Vorfahren austauschen, wäre es logisch, die Schritte für den Vorfahren sofort zu wiederholen - um seinen nächsten richtigen Vorfahren für ihn zu finden und zu vergleichen (und wenn es auch notwendig ist, Werte + Austausch von Teilbäumen auszutauschen). </font><font style="vertical-align: inherit;">Und wenn möglich, heben Sie ein großes Element bis zur Wurzel an. </font><font style="vertical-align: inherit;">So sieht es in der ersten Stufe aus (die Aktionen in der zweiten Stufe des Algorithmus bleiben unverändert):</font></font><br>
<br>
<div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/9x/9-/pa/9x9-panzenovigxgpzzal8phtri.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Zeitkomplexitätswert bleibt gleich.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomialstapel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles, was bis zu diesem Punkt war, ist eine Täuschung, eine Illusion. Natürlich führen wir dort formal einige Manipulationen mit dem Binärbaum durch, ändern die Knoten mit Werten, ordnen die Teilbäume neu an und so weiter. Der Algorithmus hat jedoch einen doppelten Boden, den wir nun untersuchen werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diese Art zu verstehen, müssen Sie verstehen, was ein schwacher Haufen wirklich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir ein Array nehmen, in dem die Anzahl der Elemente eine Zweierpotenz ist, dann sind der schwache Heap und der Binomialheap, die auf seiner Basis aufgebaut sind, isomorph.</font></font><br>
<br>
<div style="text-align:center;"><img width="760" height="222" src="https://habrastorage.org/webt/nk/ge/qu/nkgequw_s9eaecxl7h9fiz9v2ua.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie nicht die Tatsache, dass ein schwacher Heap binär ist und Binomial nicht. </font><font style="vertical-align: inherit;">In einem schwachen Haufen unterscheiden sich der linke und der rechte Teilbaum wesentlich. </font><font style="vertical-align: inherit;">Der rechte Teilbaum ist ein Nachkomme im klassischen Sinne, der linke Teilbaum jedoch eher ein „Bruder“. </font><font style="vertical-align: inherit;">Obwohl nicht. </font><font style="vertical-align: inherit;">Der linke Teilbaum ist nicht einmal ein „Bruder“, sondern ein Vektor von „Brüdern“ mit weniger Knoten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der schwache Haufen und der Binomialhaufen sind jedoch nicht zu 100% gleich, obwohl sie die engsten Verwandten sind. </font><font style="vertical-align: inherit;">Der Unterschied ist offensichtlich, wenn Sie ein Array nehmen, dessen Anzahl von Elementen nicht 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n entspricht</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die binomiale Zerlegung eines solchen Arrays ergibt eine zusammenhängende Liste mehrerer idealer Heaps (die Anzahl der Knoten in jedem von ihnen ist eine bestimmte Zweierpotenz):</font></font><br>
<br>
<div style="text-align:center;"><img width="484" height="222" src="https://habrastorage.org/webt/k_/o8/zk/k_o8zk8rbi4n25ojy9ijrwh8jre.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein schwacher Haufen ist in diesem Fall ein unvollständiger Binärbaum:</font></font><br>
<br>
<div style="text-align:center;"><img width="691" height="188" src="https://habrastorage.org/webt/eb/7a/-y/eb7a-yq54lycrpazacxsu6ci0em.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Binomialstapel und der schwache Stapel sind Zwillingsbrüder. </font><font style="vertical-align: inherit;">Die DNA ist dieselbe, obwohl man sie anscheinend nicht erkennen kann.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geheimer Algorithmus</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angesichts der Tatsache, dass ein schwacher Haufen ein kryptobinomischer Haufen ist, findet das Mischen von Teilbäumen plötzlich eine einfache Erklärung.</font></font><br>
<br>
<div style="text-align:center;"><img width="497" height="199" src="https://habrastorage.org/webt/xa/tb/p7/xatbp7kfjag7awytapkrebfwdxk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fegen Sie mit einem schwachen Haufen das pseudobinäre Lametta weg und betrachten Sie die tatsächlichen Beziehungen zwischen den Knoten im Binomialhaufenstil. </font><font style="vertical-align: inherit;">Alles wird klar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt keine "Schwäche", es ist ein vollwertiger Sortierbaum (nicht binär), in dem das Prinzip "Jeder Elternteil ist größer als jeder seiner Nachkommen" erreicht und beibehalten wird.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In allen Phasen vergleichen wir die Nachkommen nicht mit ihren Vorfahren, sondern mit ihren unmittelbaren Eltern.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was wie ein Werteaustausch zwischen einem Nachkommen und einem Vorfahren aussieht + ein Austausch von Teilbäumen in einem Nachkommen - es stellt sich heraus, dass es sich um den Austausch des Verhältnisses selbst (Nachkomme / Elternteil) handelt. </font><font style="vertical-align: inherit;">Wenn der übergeordnete Knoten wertmäßig kleiner als der Nachkomme ist, wird der übergeordnete Knoten selbst zum Nachkommen und der Nachkomme zum übergeordneten Knoten.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist eine ehrliche Visualisierung:</font></font><br>
<br>
<div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/s0/zb/m_/s0zbm_vg9ocfnzzgwhldn70v7he.gif"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der nächsten Serie</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der nächste Stapel, über den ich sprechen möchte, ist mein Favorit - der kartesische Baum. </font><font style="vertical-align: inherit;">Dies ist nicht nur ein Haufen, sondern auch ein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">binärer Suchbaum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Aber dann muss zuerst im nächsten Artikel etwas Interessantes über BST-Bäume geklärt werden. </font><font style="vertical-align: inherit;">Und erst dann durch den Artikel und über kartesische Gespräche.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwacher Heap</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomial-Heap</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomial- </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/fn/cd/py/fncdpynfktllvkdjtmpif0kd1zc.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap C ++ Schwache Heap-Implementierung </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/pt/js/7k/ptjs7kchs12_zg8dfph-ld6yp_4.gif"> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ronald D. Dutton: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Persönliche Seite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UCF-Website-Profil </font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/yv/lm/2t/yvlm2t2kl5affkpm0hzqh7qw5ly.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwache Heaps und Freunde: Neueste Entwicklungen </font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/92/je/ur/92jeurt6uvk1biknydz0eygm9uy.gif"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Datenstruktur für </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">schwache Heaps </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">: Varianten und Anwendungen </font></a></font><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/92/je/ur/92jeurt6uvk1biknydz0eygm9uy.gif"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zur Leistung von WEAK-HEAPSORT </font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/92/je/ur/92jeurt6uvk1biknydz0eygm9uy.gif"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adaptive Heapsort: Quellcode </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/mp/mv/ie/mpmviex2wi0oknklc_zrg5tgfhe.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey Kopeliovich - Hörsaal - Schwacher Haufen (von 48:32 bis 1:16:06)</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serienartikel:</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excel-Anwendung AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sorte austauschen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfügungssortierungen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Auswahl sortieren</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: N-Pyramiden</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Leonardo Numbers</font></font></a></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap-Sortierung: schwacher Heap</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bündelsorten: Kartesischer Baum</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere Heap-Sortierungen: Spiegelhaufen, Mini-Heap, Sieben von unten nach oben</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Jung Heap</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sortierungen zusammenführen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Verteilung sortieren</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hybridsortierung</font></font></a></li>
</ul><br>
<img align="right" width="349" height="264" src="https://habrastorage.org/webt/kf/cj/xj/kfcjxjqyku6wcl2spe8hqzgefz0.png"><br clear="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die heutige Sortierung wird der AlgoLab-Anwendung von einem schwachen Haufen hinzugefügt, der sie verwendet. Aktualisieren Sie die Excel-Datei mit Makros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den Kommentaren zur Zelle mit dem Namen der Sortierung können Sie einige Einstellungen angeben. </font><font style="vertical-align: inherit;">Wenn Sie siftup = 1 setzen, wird bei der Sortierung in der ersten Stufe die vollständige Überprüfung verwendet (standardmäßig siftup = 0). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie binomial = 1 vorschreiben, ist der Baum ein "binomialer Heap" (standardmäßig binomial = 0, dh nur ein schwacher Heap).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de499770/index.html">Lerne während du dich selbst isolierst</a></li>
<li><a href="../de499772/index.html">Es wird sehr, sehr viel sein: Wie die 5G-Technologie den Werbemarkt verändern wird</a></li>
<li><a href="../de499774/index.html">Kein Tag ohne Sport - 2: Neuprogrammierung eines chinesischen Armbands</a></li>
<li><a href="../de499776/index.html">Merkmale der Implementierung der MSH-Sprache</a></li>
<li><a href="../de499784/index.html">Was berühren virtuelle Wände?</a></li>
<li><a href="../de499788/index.html">Kostenloser Online-Kurs "Technische Dokumentation in IT-Projekten"</a></li>
<li><a href="../de499792/index.html">Lasttests Atlassian Jira, Confluence, Bitbucket Teil 1</a></li>
<li><a href="../de499794/index.html">PostgreSQL und JDBC pressen alle Säfte. Vladimir Sitnikov</a></li>
<li><a href="../de499796/index.html">Wie Gerichte in den USA durch Zoom gehalten werden und warum dies als Problem angesehen wird</a></li>
<li><a href="../de499798/index.html">Zwei Tapas zu Geld: Wie wir in Aserbaidschan einen Finanz-Chat-Bot mit sofortiger Kartenausgabe entwickelt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>