<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç© ü§µ üçü Schwache Haufen-Sortierung üíÉüèø üë®üèª‚Äçüé® üòù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von den gesamten Zoohaufen ist diese Struktur vielleicht die ungew√∂hnlichste. Dar√ºber hinaus passt die elegante Einfachheit des Algorithmus durchaus z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Schwache Haufen-Sortierung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/499786/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><div style="text-align:center;"><img width="765" height="430" src="https://habrastorage.org/webt/hh/ve/rt/hhvertyrtwsbd99rbboihxxyjjk.jpeg"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von den gesamten Zoohaufen ist diese Struktur vielleicht die ungew√∂hnlichste. </font><font style="vertical-align: inherit;">Dar√ºber hinaus passt die elegante Einfachheit des Algorithmus durchaus zu seiner erstaunlichen Exzentrizit√§t. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Sortieren mit einem schwachen Heap gibt es immer weniger Vergleiche und Austausche als mit einem normalen Heap. </font><font style="vertical-align: inherit;">Also ja, ein schwacher Stapel ist st√§rker als ein gew√∂hnlicher Stapel.</font></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="EDISON Software - Webentwicklung"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - Webentwicklung"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel wurde mit Unterst√ºtzung von EDISON verfasst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir besch√§ftigen uns mit der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellung eingebetteter Software</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sowie der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entwicklung von Webanwendungen und Websites</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir lieben die Theorie der Algorithmen! </font><font style="vertical-align: inherit;">;-);</font></font></blockquote><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwacher Haufen</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein regul√§rer Heap ist ein Sortierbaum,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in dem ein Elternteil gr√∂√üer (oder gleich) ist als einer seiner Nachkommen. </font><font style="vertical-align: inherit;">In einem schwachen Haufen wird diese Anforderung geschw√§cht - jeder Elternteil ist gr√∂√üer (oder gleich) als jeder Nachkomme nur von seinem rechten Teilbaum. </font><font style="vertical-align: inherit;">Im linken Teilbaum k√∂nnen die Nachkommen sowohl kleiner als auch gr√∂√üer als die Eltern sein, da haben Sie so viel Gl√ºck.</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="299" src="https://habrastorage.org/webt/by/f6/ef/byf6efzj8swlst2y_2dvb7onduu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Ansatz kann die Kosten f√ºr die Aufrechterhaltung des Datensatzes in einem Heap-Zustand erheblich reduzieren. </font><font style="vertical-align: inherit;">Schlie√ülich muss sichergestellt werden, dass das Prinzip ‚Äûein Nachkomme ist nicht mehr als ein Elternteil‚Äú nicht f√ºr die gesamte Struktur, sondern nur f√ºr die H√§lfte gilt. </font><font style="vertical-align: inherit;">Gleichzeitig sortiert ein schwacher Haufen, der kein 100% iger Sortierbaum ist, nicht schlechter als ein gew√∂hnlicher Haufen und in gewisser Weise sogar noch besser. </font><font style="vertical-align: inherit;">Hat die halbe Miete geschafft - mutig gehen! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da die Wurzel des Heaps, auch eine schwache, genau das gr√∂√üte Element ben√∂tigt, tut dies die Wurzel des linken Teilbaums nicht.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimierung der Anzahl der Vergleiche</font></font></h2><br>
<img align="left" width="215" height="199" src="https://habrastorage.org/webt/ng/cu/e1/ngcue1zei7olyudhfpge5blkcgu.jpeg"><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ronald D. Dutton, Spezialist f√ºr Algorithmen und Graphentheorie, stellte uns 1993 einen schwachen Haufen vor. </font><font style="vertical-align: inherit;">Ein konzeptionell schwacher Stapel ist schwieriger zu verstehen (aber diese Schwierigkeit liegt eher nicht in der Komplexit√§t, sondern in der Extravaganz, Sie m√ºssen Ihre Bewusstseinsmuster durch das Knie brechen) als ein gew√∂hnlicher Stapel, so dass er nicht viel praktische Verteilung erhalten hat. </font><font style="vertical-align: inherit;">Als Dutton diese Struktur erfand, wollte er nicht nur abstrakte Abstraktionen √ºben, sondern verfolgte auch ein v√∂llig pragmatisches Ziel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt eine theoretische Untergrenze f√ºr die Sch√§tzung der Mindestanzahl von Vergleichen (bei den Sortierungen, bei denen diese Vergleiche weit verbreitet sind): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">= </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / ln 2 + O (log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), wobei 1 / ln 2 = 1,4426 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Sortierung nach einem schwachen Haufen wird die Anzahl der Vergleiche minimiert und liegt nahe genug an der Untergrenze. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies kann von praktischer Bedeutung sein, wenn Sie Objekte anordnen m√ºssen, deren Vergleich teuer ist, z. B. wenn lange Zeichenfolgen sortiert werden sollen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachkommen jonglieren</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Links" und "Rechts" in einem schwachen Haufen ist ein situatives Ph√§nomen. Ein Teilbaum kann entweder ein linker oder ein rechter Nachkomme f√ºr seinen √ºbergeordneten Knoten sein - au√üerdem kann diese "links / rechts" -Relation f√ºr den Teilbaum und den √ºbergeordneten Knoten w√§hrend des Prozesses wiederholt von einem Wert zum anderen wechseln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr den Elternteil anzugeben, wer seinen rechten Sohn hat und wer seine linke Tochter ist, ist nicht einfach, aber sehr einfach. Dazu ben√∂tigen Sie eine zus√§tzliche Bitmap (bestehend aus nur 0/1 Werten) f√ºr die Knoten mit Nachkommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erinnern Sie sich daran, wie das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> te √ºbergeordnete Element </font><font style="vertical-align: inherit;">des Index </font><font style="vertical-align: inherit;">die Indizes seines linken und rechten Nachkommen in einem herk√∂mmlichen Stapel definiert (Indizes des Arrays gemessen von Null): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linker Nachkomme 2 √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rechter Nachkomme 2 √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einem schwachen Haufen haben wir eine Kirsche auf dem Kuchen - eine Wurzel, die nur den richtigen Teilbaum hat, also werden wir diese Formeln f√ºr die Nachkommenindizes anpassen, indem wir eine umgekehrte Verschiebung zu 1 Position hinzuf√ºgen: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linker Nachkomme: 2 √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Rechter Nachkomme: 2 √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und schlie√ülich , ben√∂tigte zus√§tzliche Bitmap (nenne es </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), wobei f√ºr das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i- </font></font></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">te</font></b><font style="vertical-align: inherit;"> Element angegeben wurde, ob der Austausch zwischen seinen linken und rechten Teilb√§umen stattfindet. Wenn der Wert f√ºr ein Element 0 ist, gab es keinen Austausch. Wenn der Wert 1 ist, gehen die linken und rechten Kinder in die entgegengesetzte Reihenfolge. In diesem Fall lauten die Formeln wie folgt: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linker Nachkomme: 2 √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rechter Nachkomme: 2 √ó </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht es aus. </font><font style="vertical-align: inherit;">Elemente, deren Nachkommen sich "umgekehrt" befinden, werden blau hervorgehoben. </font><font style="vertical-align: inherit;">Die Werte im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array </font><font style="vertical-align: inherit;">f√ºr sie sind 1.</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="330" src="https://habrastorage.org/webt/h0/by/bm/h0bybmjxpw21mdj1x3uyamtsyk4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen dies √ºberpr√ºfen, indem Sie die √ºbergeordneten Werte </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die entsprechende 0/1 aus dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array </font><font style="vertical-align: inherit;">in den Nachkommenformeln einsetzen. </font><font style="vertical-align: inherit;">Die Indizes der Nachkommen werden nach Bedarf angezeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen k√∂nnen, muss die Gruppe von Elementen nirgendwo hin verschoben werden, damit ein Elternteil die linken und rechten Teilb√§ume im Array selbst vertauschen kann. </font><font style="vertical-align: inherit;">Es wird nur der 0/1-Wert f√ºr das √ºbergeordnete </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Element</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im </font><b><font style="vertical-align: inherit;">BIT-</font></b><font style="vertical-align: inherit;"> Array </font><b><font style="vertical-align: inherit;">umgeschaltet</font></b><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weiter - eine magische Sitzung mit anschlie√üender Belichtung.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baue einen schwachen Haufen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Vertauschen von Nachkommen nach links und rechts ist das Hauptwerkzeug zum Konvertieren eines Datensatzes aus einem Array in einen schwachen Haufen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Bildung des prim√§ren schwachen Heaps m√ºssen wir die Elemente des Arrays in umgekehrter Reihenfolge (beginnend mit dem letzten) sortieren und f√ºr jeden von ihnen den Zweig des ersten (rechten) √ºbergeordneten Elements finden, f√ºr den es der richtige Teilbaum ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Element der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">richtige Nachkomme einer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Person ist </font><font style="vertical-align: inherit;">, m√ºssen Sie nicht weit gehen. </font><font style="vertical-align: inherit;">Das unmittelbare Elternteil ist das, was Sie brauchen:</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="304" src="https://habrastorage.org/webt/tg/_4/01/tg_401fvyqumg-j_nbwm1-n_bna.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Element der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linke Nachkomme einer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Person ist </font><font style="vertical-align: inherit;">, m√ºssen Sie einige Stufen aufsteigen, bevor Sie den gew√ºnschten Gro√üelternteil treffen, f√ºr den sich das Element im rechten Teilbaum befindet:</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="304" src="https://habrastorage.org/webt/lk/ud/-f/lkud-fixce2hbm1d7ejuil3pnh8.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann m√ºssen Sie den Nachkommen und den Vorfahren vergleichen, die irgendwo oben gefunden wurden. </font><font style="vertical-align: inherit;">Und wenn der Nachkomme gr√∂√üer als der Vorfahr ist, muss Folgendes getan werden:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Nachkomme seine Nachkommen hat, tauschen Sie seine linken und rechten Teilb√§ume aus (d. H. Schalten Sie 0/1 im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array </font><font style="vertical-align: inherit;">f√ºr dieses Element).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tauschen Sie die Werte des Nachkommenknotens und des Vorl√§uferknotens aus.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen Sie sich ein bestimmtes Beispiel an. </font><font style="vertical-align: inherit;">Nehmen wir an, die folgende Situation ist aufgetreten:</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="339" src="https://habrastorage.org/webt/8f/-8/kr/8f-8krbczd6kxh2o-cbbe4hdkdc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr das Element des Arrays </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] = 87 wurde der notwendige Vorl√§ufer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1] = 76 gefunden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Vorl√§ufer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1] ist kleiner als das Element </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] (76 &lt;87). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Element </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] hat linke und rechte Teilb√§ume (in Gr√ºnt√∂nen markiert). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie m√ºssen diese Teilb√§ume austauschen </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
( </font><font style="vertical-align: inherit;">dh </font><font style="vertical-align: inherit;">f√ºr Element </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array </font><font style="vertical-align: inherit;">den Wert von 0 auf 1 √§ndern). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist auch notwendig, die Werte der Elemente </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1] </font><font style="vertical-align: inherit;">auszutauschen </font><font style="vertical-align: inherit;">.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nachdem die erforderlichen Aktionen abgeschlossen sind:</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="339" src="https://habrastorage.org/webt/zy/fb/vb/zyfbvbqsvoyyidown3ljp5pe8mk.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr Element </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] wurden die linken und rechten Teilb√§ume ausgetauscht </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
( </font><font style="vertical-align: inherit;">dh </font><font style="vertical-align: inherit;">im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array </font><font style="vertical-align: inherit;">f√ºr Element </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] wurde der Wert von 0 in 1 ge√§ndert). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gab auch einen Werteaustausch zwischen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1]. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie das Array vom Ende bis zum Anfang durchlaufen und unterwegs dieses Verfahren f√ºr alle Elemente ausf√ºhren, erhalten Sie einen schwachen Haufen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum dieser seltsame Mechanismus funktioniert, ist eine Erkl√§rung, die n√§her am Ende des Artikels liegt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse eines schwachen Stapels</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Heap ist ein Heap, wenn sich das maximale Element im Stammverzeichnis befindet. Mit dieser Tatsache funktionieren alle Heap-Sortierungen auf die gleiche Weise. Die Wurzel (wo sich das Maximum befindet) tauscht Werte mit dem letzten Element des unsortierten Teils des Arrays aus. Infolgedessen nimmt der unsortierte Teil des Arrays ab und der sortierte Teil des Arrays nimmt zu. Nach diesem Austausch ist der Heap kein Heap mehr, da sich das aktuelle maximale Element nicht mehr in seiner Wurzel befindet. Der Heap muss wiederhergestellt werden, dh der resultierende Baum wird wieder zu einem Heap. Suchen Sie ein anderes maximales Element und verschieben Sie es in den Stamm. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wissen, wie man einen normalen bin√§ren Heap wiederherstellt - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit Hilfe eines Sichters</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Aber wie kann man einen schwachen Haufen wiederherstellen? Gehen Sie dazu wie folgt vor.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von der Wurzel steigen wir die linken Nachkommen ab (bis zum niedrigsten):</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="339" src="https://habrastorage.org/webt/ka/d1/t8/kad1t8a7egmsgtgrpuqk6txqajc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann gehen wir die linken Nachkommen wieder hoch und auf dem Weg wird jeder linke Nachkomme mit einem Element in der Heap-Wurzel verglichen. </font><font style="vertical-align: inherit;">Und wenn der n√§chste linke Nachkomme gr√∂√üer als die Wurzel ist, machen wir dasselbe wie in der vorherigen Stufe: Beim linken Nachkommen tauschen wir die Teilb√§ume (falls er einen hat) und √§ndern die Werte des linken Nachkommen und der Wurzel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen stellen wir den schwachen Heap wieder her - das maximale Element im verbleibenden Baum wird an seiner Wurzel angezeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wieder haben wir dieses mystische Karussell mit Teilb√§umen, die sich gegenseitig ersetzen. </font><font style="vertical-align: inherit;">Was ist das Erfolgsgeheimnis? </font><font style="vertical-align: inherit;">Warum erhalten wir ein sortiertes Array, wenn beim Austausch von Knoten mit Werten die linken und rechten Nachkommen des unteren Knotens vertauscht werden? </font><font style="vertical-align: inherit;">Sie werden es nie erraten, obwohl die Antwort in ihrem Genie einfach ist.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwache Heap-Sortierung :: Schwache Heap-Sortierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also der endg√ºltige Algorithmus:</font></font><br>
<br>
<ul>
<li><b>I.     :</b><ul>
<li><b>I.1.</b>    -.</li>
<li><b>I.2.</b>           ¬´¬ª .</li>
<li><b>I.3.</b>       .</li>
<li><b>I.4.</b>       , :<ul>
<li><b>I.4..</b>   ( ‚áî )     ,     .</li>
<li><b>I.4..</b>    ¬´¬ª      .</li>
</ul></li>
</ul></li>
<li><b>II.            ,     :</b><ul>
<li><b>II.1.</b>           .</li>
<li><b>II.2.</b>             .         .</li>
<li><b>II.3.</b>        ,        .   :<ul>
<li><b>II.3..</b>          .</li>
<li><b>II.3..</b>        ,      .</li>
<li><b>II.3..</b>     ,    , :<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.3.c. 1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir tauschen (links ‚áî rechts) Teilb√§ume mit Nachkommen gegen den Knoten aus, in dem sich der aktuelle linke Nachkomme befindet.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.3.c.2. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir √§ndern die Heap-Wurzel und den Knoten mit dem aktuellen linken Kind.</font></font></li>
</ul></li>
</ul></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.4. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An der Wurzel des schwachen Heaps befindet sich wieder das maximale Element f√ºr den verbleibenden unsortierten Teil des Arrays. </font><font style="vertical-align: inherit;">Wir kehren zu Absatz II.1 zur√ºck und wiederholen den Vorgang, bis alle Elemente sortiert sind.</font></font></li>
</ul></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Animation (Array-Indizes in meinen Animationen beginnen mit einem):</font></font><br>
<br>
<div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/1l/ay/j-/1layj-xmzm4dl7p5yv7_5iag5pa.gif"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ - Code</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende des Abschnitts ‚ÄûLinks‚Äú k√∂nnen sich Interessenten mit der Implementierung dieser Sortierung in C ++ vertraut machen. </font><font style="vertical-align: inherit;">Hier gebe ich nur den Teil an, der den Algorithmus selbst veranschaulicht.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GETFLAG(r, x) ((r[(x) &gt;&gt; 3] &gt;&gt; ((x) &amp; 7)) &amp; 1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TOGGLEFLAG(r, x) (r[(x) &gt;&gt; 3] ^= 1 &lt;&lt; ((x) &amp; 7))</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WeakHeap::WeakHeapMerge</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *r, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>{
  <span class="hljs-keyword">if</span> (wheap[i] &lt; wheap[j]) {<span class="hljs-comment">//""  ?</span>
    <span class="hljs-comment">//  ,   </span>
    <span class="hljs-comment">//( "",   "")</span><font></font>
    TOGGLEFLAG(r, j);<font></font>
    <span class="hljs-comment">//  ""  </span><font></font>
    swap(wheap[i], wheap[j]);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WeakHeap::WeakHeapSort</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span> n = Size();
  <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">1</span>) {<font></font>
		<font></font>
    <span class="hljs-keyword">int</span> i, j, x, y, Gparent;
    <span class="hljs-keyword">int</span> s = (n + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> * r = <span class="hljs-keyword">new</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> [s];<font></font>
		<font></font>
    <span class="hljs-comment">//  ,    </span>
    <span class="hljs-comment">// "",   ""</span>
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">8</span>; ++i) r[i] = <span class="hljs-number">0</span>;<font></font>
		<font></font>
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">for</span>(i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) {<font></font>
      j = i;<font></font>
      <span class="hljs-comment">//    , </span>
      <span class="hljs-comment">//   ""  </span>
      <span class="hljs-keyword">while</span> ((j &amp; <span class="hljs-number">1</span>) == GETFLAG(r, j &gt;&gt; <span class="hljs-number">1</span>)) j &gt;&gt;= <span class="hljs-number">1</span>;
      <span class="hljs-comment">//       ""  </span>
      Gparent = j &gt;&gt; <span class="hljs-number">1</span>;
      <span class="hljs-comment">//  ,   </span>
      <span class="hljs-comment">//   ""</span><font></font>
      WeakHeapMerge(r, Gparent, i);<font></font>
    }<font></font>
		<font></font>
    <span class="hljs-comment">//      --&gt;</span>
    <span class="hljs-comment">//  --&gt;    </span>
    <span class="hljs-keyword">for</span>(i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">2</span>; --i) {
      <span class="hljs-comment">//      </span>
      <span class="hljs-comment">//       </span>
      swap(wheap[<span class="hljs-number">0</span>], wheap[i]);<font></font>
      x = <span class="hljs-number">1</span>;
      <span class="hljs-comment">//    "" </span>
      <span class="hljs-keyword">while</span>((y = <span class="hljs-number">2</span> * x + GETFLAG(r, x)) &lt; i) x = y;
      <span class="hljs-comment">//  ""     </span>
      <span class="hljs-comment">//        </span>
      <span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span>) {<font></font>
        WeakHeapMerge(r, <span class="hljs-number">0</span>, x);<font></font>
        x &gt;&gt;= <span class="hljs-number">1</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">//  -   </span>
    <span class="hljs-comment">//    </span>
    swap(wheap[<span class="hljs-number">0</span>], wheap[<span class="hljs-number">1</span>]);
    <span class="hljs-keyword">delete</span>[] r;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mir gef√§llt besonders, wie der Bin√§rbaum einfach und nat√ºrlich mit bitweisen Operationen durchlaufen wird.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zus√§tzliche Speicherkomplexit√§t</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint wie O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - ein zus√§tzliches Array ist erforderlich, bei dem f√ºr Knoten mit Nachkommen (es gibt ungef√§hr die H√§lfte davon im Array) die Reihenfolge der linken / rechten Teilb√§ume festgelegt ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt jedoch eine Meinung, dass die Sortierkomplexit√§t hier tats√§chlich O (1) ist! </font><font style="vertical-align: inherit;">F√ºr ein Element ben√∂tigen wir nur ein zus√§tzliches Bit (Null / Eins), um die Reihenfolge der Nachkommen anzugeben. </font><font style="vertical-align: inherit;">Wenn wir zum Beispiel Strings sortieren, ist es durchaus m√∂glich, dieses zus√§tzliche Bit an das Element selbst anzuh√§ngen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine andere M√∂glichkeit, O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) in O (1) umzuwandeln, besteht darin, Flags in einer ganzen Zahl zu speichern. </font><font style="vertical-align: inherit;">Bin√§re Erweiterung von Zahlen - eine Reihe von Nullen und Einsen, die f√ºr die Reihenfolge der Teilb√§ume aller Elemente des Arrays verantwortlich sind. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> te Element des Arrays entspricht dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ten Bit der Zahl.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitliche Komplexit√§t</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der Zeit ist O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dasselbe wie ein regul√§rer Heap. </font><font style="vertical-align: inherit;">Beim Sortieren von Zeilen (insbesondere langen) kann ein schwacher Heap schneller sein als ein normaler Heap. </font><font style="vertical-align: inherit;">Aber das ist, wenn wir die langen Schlangen sortieren. </font><font style="vertical-align: inherit;">Wenn wir die Zahlen sortieren, ist Ger√ºchten zufolge ein gew√∂hnlicher Haufen schneller zu verwalten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volles Sieben</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Phase der Bildung des anf√§nglichen schwachen Haufens schl√§gt die ganz offensichtliche Idee in Analogie zum √ºblichen Haufen vor, gro√üe Elemente so hoch wie m√∂glich anzuheben. </font><font style="vertical-align: inherit;">Das hei√üt, wenn wir die Werte des unteren Knotens und seines Vorfahren austauschen, w√§re es logisch, die Schritte f√ºr den Vorfahren sofort zu wiederholen - um seinen n√§chsten richtigen Vorfahren f√ºr ihn zu finden und zu vergleichen (und wenn es auch notwendig ist, Werte + Austausch von Teilb√§umen auszutauschen). </font><font style="vertical-align: inherit;">Und wenn m√∂glich, heben Sie ein gro√ües Element bis zur Wurzel an. </font><font style="vertical-align: inherit;">So sieht es in der ersten Stufe aus (die Aktionen in der zweiten Stufe des Algorithmus bleiben unver√§ndert):</font></font><br>
<br>
<div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/9x/9-/pa/9x9-panzenovigxgpzzal8phtri.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Zeitkomplexit√§tswert bleibt gleich.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomialstapel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles, was bis zu diesem Punkt war, ist eine T√§uschung, eine Illusion. Nat√ºrlich f√ºhren wir dort formal einige Manipulationen mit dem Bin√§rbaum durch, √§ndern die Knoten mit Werten, ordnen die Teilb√§ume neu an und so weiter. Der Algorithmus hat jedoch einen doppelten Boden, den wir nun untersuchen werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diese Art zu verstehen, m√ºssen Sie verstehen, was ein schwacher Haufen wirklich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir ein Array nehmen, in dem die Anzahl der Elemente eine Zweierpotenz ist, dann sind der schwache Heap und der Binomialheap, die auf seiner Basis aufgebaut sind, isomorph.</font></font><br>
<br>
<div style="text-align:center;"><img width="760" height="222" src="https://habrastorage.org/webt/nk/ge/qu/nkgequw_s9eaecxl7h9fiz9v2ua.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie nicht die Tatsache, dass ein schwacher Heap bin√§r ist und Binomial nicht. </font><font style="vertical-align: inherit;">In einem schwachen Haufen unterscheiden sich der linke und der rechte Teilbaum wesentlich. </font><font style="vertical-align: inherit;">Der rechte Teilbaum ist ein Nachkomme im klassischen Sinne, der linke Teilbaum jedoch eher ein ‚ÄûBruder‚Äú. </font><font style="vertical-align: inherit;">Obwohl nicht. </font><font style="vertical-align: inherit;">Der linke Teilbaum ist nicht einmal ein ‚ÄûBruder‚Äú, sondern ein Vektor von ‚ÄûBr√ºdern‚Äú mit weniger Knoten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der schwache Haufen und der Binomialhaufen sind jedoch nicht zu 100% gleich, obwohl sie die engsten Verwandten sind. </font><font style="vertical-align: inherit;">Der Unterschied ist offensichtlich, wenn Sie ein Array nehmen, dessen Anzahl von Elementen nicht 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n entspricht</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die binomiale Zerlegung eines solchen Arrays ergibt eine zusammenh√§ngende Liste mehrerer idealer Heaps (die Anzahl der Knoten in jedem von ihnen ist eine bestimmte Zweierpotenz):</font></font><br>
<br>
<div style="text-align:center;"><img width="484" height="222" src="https://habrastorage.org/webt/k_/o8/zk/k_o8zk8rbi4n25ojy9ijrwh8jre.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein schwacher Haufen ist in diesem Fall ein unvollst√§ndiger Bin√§rbaum:</font></font><br>
<br>
<div style="text-align:center;"><img width="691" height="188" src="https://habrastorage.org/webt/eb/7a/-y/eb7a-yq54lycrpazacxsu6ci0em.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Binomialstapel und der schwache Stapel sind Zwillingsbr√ºder. </font><font style="vertical-align: inherit;">Die DNA ist dieselbe, obwohl man sie anscheinend nicht erkennen kann.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geheimer Algorithmus</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angesichts der Tatsache, dass ein schwacher Haufen ein kryptobinomischer Haufen ist, findet das Mischen von Teilb√§umen pl√∂tzlich eine einfache Erkl√§rung.</font></font><br>
<br>
<div style="text-align:center;"><img width="497" height="199" src="https://habrastorage.org/webt/xa/tb/p7/xatbp7kfjag7awytapkrebfwdxk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fegen Sie mit einem schwachen Haufen das pseudobin√§re Lametta weg und betrachten Sie die tats√§chlichen Beziehungen zwischen den Knoten im Binomialhaufenstil. </font><font style="vertical-align: inherit;">Alles wird klar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tats√§chlich:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt keine "Schw√§che", es ist ein vollwertiger Sortierbaum (nicht bin√§r), in dem das Prinzip "Jeder Elternteil ist gr√∂√üer als jeder seiner Nachkommen" erreicht und beibehalten wird.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In allen Phasen vergleichen wir die Nachkommen nicht mit ihren Vorfahren, sondern mit ihren unmittelbaren Eltern.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was wie ein Werteaustausch zwischen einem Nachkommen und einem Vorfahren aussieht + ein Austausch von Teilb√§umen in einem Nachkommen - es stellt sich heraus, dass es sich um den Austausch des Verh√§ltnisses selbst (Nachkomme / Elternteil) handelt. </font><font style="vertical-align: inherit;">Wenn der √ºbergeordnete Knoten wertm√§√üig kleiner als der Nachkomme ist, wird der √ºbergeordnete Knoten selbst zum Nachkommen und der Nachkomme zum √ºbergeordneten Knoten.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist eine ehrliche Visualisierung:</font></font><br>
<br>
<div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/s0/zb/m_/s0zbm_vg9ocfnzzgwhldn70v7he.gif"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der n√§chsten Serie</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der n√§chste Stapel, √ºber den ich sprechen m√∂chte, ist mein Favorit - der kartesische Baum. </font><font style="vertical-align: inherit;">Dies ist nicht nur ein Haufen, sondern auch ein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bin√§rer Suchbaum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Aber dann muss zuerst im n√§chsten Artikel etwas Interessantes √ºber BST-B√§ume gekl√§rt werden. </font><font style="vertical-align: inherit;">Und erst dann durch den Artikel und √ºber kartesische Gespr√§che.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwacher Heap</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomial-Heap</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomial- </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/fn/cd/py/fncdpynfktllvkdjtmpif0kd1zc.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap C ++ Schwache Heap-Implementierung </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/pt/js/7k/ptjs7kchs12_zg8dfph-ld6yp_4.gif"> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ronald D. Dutton: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pers√∂nliche Seite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UCF-Website-Profil </font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/yv/lm/2t/yvlm2t2kl5affkpm0hzqh7qw5ly.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwache Heaps und Freunde: Neueste Entwicklungen </font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/92/je/ur/92jeurt6uvk1biknydz0eygm9uy.gif"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Datenstruktur f√ºr </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">schwache Heaps </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">: Varianten und Anwendungen </font></a></font><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/92/je/ur/92jeurt6uvk1biknydz0eygm9uy.gif"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zur Leistung von WEAK-HEAPSORT </font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/92/je/ur/92jeurt6uvk1biknydz0eygm9uy.gif"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adaptive Heapsort: Quellcode </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/mp/mv/ie/mpmviex2wi0oknklc_zrg5tgfhe.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey Kopeliovich - H√∂rsaal - Schwacher Haufen (von 48:32 bis 1:16:06)</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serienartikel:</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excel-Anwendung AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sorte austauschen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einf√ºgungssortierungen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Auswahl sortieren</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: N-Pyramiden</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Leonardo Numbers</font></font></a></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap-Sortierung: schwacher Heap</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B√ºndelsorten: Kartesischer Baum</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere Heap-Sortierungen: Spiegelhaufen, Mini-Heap, Sieben von unten nach oben</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Jung Heap</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sortierungen zusammenf√ºhren</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Verteilung sortieren</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hybridsortierung</font></font></a></li>
</ul><br>
<img align="right" width="349" height="264" src="https://habrastorage.org/webt/kf/cj/xj/kfcjxjqyku6wcl2spe8hqzgefz0.png"><br clear="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die heutige Sortierung wird der AlgoLab-Anwendung von einem schwachen Haufen hinzugef√ºgt, der sie verwendet. Aktualisieren Sie die Excel-Datei mit Makros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den Kommentaren zur Zelle mit dem Namen der Sortierung k√∂nnen Sie einige Einstellungen angeben. </font><font style="vertical-align: inherit;">Wenn Sie siftup = 1 setzen, wird bei der Sortierung in der ersten Stufe die vollst√§ndige √úberpr√ºfung verwendet (standardm√§√üig siftup = 0). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie binomial = 1 vorschreiben, ist der Baum ein "binomialer Heap" (standardm√§√üig binomial = 0, dh nur ein schwacher Heap).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de499770/index.html">Lerne w√§hrend du dich selbst isolierst</a></li>
<li><a href="../de499772/index.html">Es wird sehr, sehr viel sein: Wie die 5G-Technologie den Werbemarkt ver√§ndern wird</a></li>
<li><a href="../de499774/index.html">Kein Tag ohne Sport - 2: Neuprogrammierung eines chinesischen Armbands</a></li>
<li><a href="../de499776/index.html">Merkmale der Implementierung der MSH-Sprache</a></li>
<li><a href="../de499784/index.html">Was ber√ºhren virtuelle W√§nde?</a></li>
<li><a href="../de499788/index.html">Kostenloser Online-Kurs "Technische Dokumentation in IT-Projekten"</a></li>
<li><a href="../de499792/index.html">Lasttests Atlassian Jira, Confluence, Bitbucket Teil 1</a></li>
<li><a href="../de499794/index.html">PostgreSQL und JDBC pressen alle S√§fte. Vladimir Sitnikov</a></li>
<li><a href="../de499796/index.html">Wie Gerichte in den USA durch Zoom gehalten werden und warum dies als Problem angesehen wird</a></li>
<li><a href="../de499798/index.html">Zwei Tapas zu Geld: Wie wir in Aserbaidschan einen Finanz-Chat-Bot mit sofortiger Kartenausgabe entwickelt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>