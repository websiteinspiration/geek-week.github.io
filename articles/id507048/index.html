<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÇ üôå ü•¢ Olya, tes dan pabrik - jalan menuju arsitektur yang indah dan kode bersih üèà üåç üëßüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam otomatisasi pengujian, ada banyak pendekatan, solusi, dan metode yang berbeda. Yang paling umum dan sangat diperlukan adalah pola Obyek Halaman ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Olya, tes dan pabrik - jalan menuju arsitektur yang indah dan kode bersih</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/507048/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam otomatisasi pengujian, ada banyak pendekatan, solusi, dan metode yang berbeda. </font><font style="vertical-align: inherit;">Yang paling umum dan sangat diperlukan adalah pola Obyek Halaman (Objek Layar). </font><font style="vertical-align: inherit;">Saya menemukan dua pendekatan ketika bekerja dengan pola ini: dengan pabrik untuk objek halaman saya dan tanpa itu. </font><font style="vertical-align: inherit;">Dalam artikel ini, dengan contoh autotests kami, kami membandingkan kedua pendekatan, pro dan kontra mereka. </font><font style="vertical-align: inherit;">Mari saya tunjukkan seperti apa pabrik objek halaman kami. </font><font style="vertical-align: inherit;">Saya juga akan berbicara tentang masalah yang kami temui dalam tes otomatis dengan pabrik dan bagaimana mereka dipecahkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya akan mengutip semua contoh dalam artikel di Swift, tetapi untuk Android autotests semuanya bekerja dengan cara yang sama.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ci/5e/br/ci5ebr0v9onedivfawpjjy-ux0c.png"></div><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memulai</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hai nama saya Olya. Saya seorang penguji aplikasi seluler di hh.ru. Selama dua tahun dengan ekor, kami mentransfer 90% pengujian manual ke otomatis. Selama waktu ini, kami berhasil menemukan berbagai jebakan berkali-kali, berdebat ratusan perselisihan, dan sekarang saya ingin berbagi pengalaman kami dengan dunia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menulis autotest di android (Kotlin, Kaspresso) dan di iOS (Swift, XCUITest). Kami mencoba membuat tes UI kecil, hanya memeriksa skrip individual. Manfaat besi sudah cukup untuk ini, dan regresi ~ 300-400 UI auto-test pada setiap platform membutuhkan rata-rata 30-40 menit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam autotest kami, kami menggunakan pola </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obyek Halaman</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ribuan artikel telah ditulis tentang dia, jadi kita tidak akan membahasnya lebih detail.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara historis, saat membuat autotest pertama di iOS dan Android, kami memilih berbagai pendekatan untuk bekerja dengan objek halaman. </font><font style="vertical-align: inherit;">Di Android, kami hanya mengikuti polanya, dan di iOS kami juga membuat pabrik objek halaman. </font><font style="vertical-align: inherit;">Pabrik adalah tempat semua objek halaman diinisialisasi. </font><font style="vertical-align: inherit;">Dengan menggunakannya, dalam metode layar kami, kami dapat mentransfer objek halaman lain, sehingga membangun rantai interaksi yang mirip dengan perilaku aplikasi.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah pabrik memerlukan objek halaman?&nbsp;</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah membuat ratusan kasus uji, kami sampai pada kesimpulan bahwa menggunakan pabrik objek halaman adalah masalah selera bagi tester yang akan menulis autotest. Tidak ada perbedaan dalam kinerja dan stabilitas ketika bekerja dengan pendekatan yang berbeda. Tetapi agar tidak menderita kode asli di masa mendatang, Anda harus memutuskan sesegera mungkin apakah akan ada tempat untuk pabrik objek halaman dalam arsitektur autotests atau tidak. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk lebih jelasnya, saya akan memberikan dua contoh tes yang sama: ditulis dengan dan tanpa pabrik.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang dilakukan tes ini: dari layar utama aplikasi, pengguna mencoba masuk ke tab profil. Di profil, ia memilih "Masuk", lalu metode masuk dengan masuk dan memasukkan nama pengguna dan kata sandi, lalu mengklik tombol "Masuk".</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//   </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleLoginTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{
   <span class="hljs-keyword">let</span> mainScreen = <span class="hljs-type">MainScreen</span>()
   <span class="hljs-keyword">let</span> profileScreen = <span class="hljs-type">ProfileScreen</span>()
   <span class="hljs-keyword">let</span> authorizationScreen = <span class="hljs-type">AuthorizationScreen</span>()
   <span class="hljs-keyword">let</span> loginScreen = <span class="hljs-type">LoginScreen</span>()<font></font>
 <font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleLogin</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> user = userFixtureService.createUser()<font></font>
 <font></font>
        mainScreen.openProfileTab()<font></font>
        profileScreen.goToAuthorization()<font></font>
        authorizationScreen.goToLogin()<font></font>
        loginScreen<font></font>
           .enterLogin(user.login)<font></font>
           .enterPassword(user.password)<font></font>
           .logIn()   <font></font>
   }<font></font>
}<font></font>
</code></pre><br>
<pre><code class="swift hljs"><span class="hljs-comment">//   </span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleLoginTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleLogin</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> user = userFixtureService.createUser()<font></font>
 <font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openProfileTab()<font></font>
            .goToAuthorization()<font></font>
            .goToLogin()<font></font>
            .enterLogin(user.login)<font></font>
            .enterPassword(user.password)<font></font>
            .logIn()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika setelah contoh ini Anda memutuskan bahwa tes tanpa pabrik terlihat bagus, ambil saja dan tulis tanpa itu. </font><font style="vertical-align: inherit;">Tip ini sangat relevan jika Anda tidak memiliki aplikasi yang sangat besar, dengan berbagai konten dan elemen yang tidak berulang. </font><font style="vertical-align: inherit;">Atau jika Anda menulis tes di mana tidak lebih dari 10-15 langkah. </font><font style="vertical-align: inherit;">Dalam hal ini, pabrik tidak akan melakukan cuaca.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi jika ini bukan masalahnya, atau jika tes pabrik telah menjawab dalam hati Anda, maka artikel ini adalah untuk Anda.&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qe/g4/zc/qeg4zcjbcn8z9yrhq83bmteoz8k.jpeg"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti apa pabrik kami?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita cari tahu apa tujuan pembuatan objek laman, seperti apa tampilannya dan apa fungsinya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kasing standar adalah serangkaian langkah:</font></font><br>
<blockquote><ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luncurkan aplikasi</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buka layar Profile</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketuk pada "Login"</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilih metode login menggunakan login dan kata sandi</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masukkan data pengguna (nama pengguna dan kata sandi)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketuk tombol "Login"</font></font></li>
</ol><br>
</blockquote><div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tes screencast</font></font></b>
                        <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/nYHsgZiJgo8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap langkah dari test case sesuai dengan langkah dalam autotest. Anda juga dapat mengatakan bahwa setiap langkah adalah metode objek halaman terpisah dari layar yang sesuai.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita ingin mengulangi kasus uji ini dalam autotest tepat dalam langkah-langkah, membangun rantai panggilan metode yang tidak terputus yang sama, perlu setiap metode mengembalikan objek halaman dari layar berikutnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat membuat objek halaman, itu perlu diinisialisasi. Ternyata jika kita ingin membuat objek halaman di dalam yang lain, akan ada banyak inisialisasi identik di setiap objek halaman. Agar tidak melakukan ini, inisialisasi semua objek halaman dipindahkan ke pabrik - pageObjectFactory (atau screenFactory, dll.). Di akhir setiap metode, kami meminta pabrik untuk membuat layar yang kami butuhkan.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfilePageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goToAuthScreen</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AuthPageObject</span> {<font></font>
        openAuthButton.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeAuthPageObject()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua objek halaman diwarisi dari BasePageObject, yang berisi parameter utama. </font><font style="vertical-align: inherit;">Di dalamnya, kita harus meresepkan konstruktor yang diperlukan agar pabrik dapat membuat ahli warisnya. </font><font style="vertical-align: inherit;">Dalam kasus kami, kelas dasar terlihat seperti ini:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePageObject</span> </span>{
    <span class="hljs-keyword">let</span> pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>
    <span class="hljs-keyword">let</span> application: <span class="hljs-type">XCUIApplication</span><font></font>
 <font></font>
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>,<font></font>
                       application: <span class="hljs-type">XCUIApplication</span>) {
        <span class="hljs-keyword">self</span>.pageObjectsFactory = pageObjectsFactory
        <span class="hljs-keyword">self</span>.application = application<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan inisialisasi layar di pabrik sebagai hasilnya terlihat seperti ini:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageObjectsFactory</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initializePageObject</span>&lt;PageObject: BasePageObject&gt;<span class="hljs-params">(ofType type: PageObject.<span class="hljs-keyword">Type</span>)</span></span> -&gt; <span class="hljs-type">PageObject</span> {
        <span class="hljs-keyword">return</span> type.<span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-keyword">self</span>, application: application)<font></font>
    }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeAuthPageObject</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AuthPageObject</span> {
        <span class="hljs-keyword">return</span> initializePageObject(ofType: <span class="hljs-type">AuthPageObject</span>.<span class="hljs-keyword">self</span>)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akibatnya, dalam metode objek halaman apa pun, kita dapat memanggil metode pabrik untuk membuat layar yang menginisialisasi itu.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus kehidupan seorang tester tanpa pabrik</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Dari tes selalu jelas pada layar mana tindakan dilakukan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tanpa pabrik, di setiap baris </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya titik</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uji </font><s><font style="vertical-align: inherit;">,</font></s><font style="vertical-align: inherit;"> layar dan tindakan yang terjadi di atasnya jelas terdaftar. </font><font style="vertical-align: inherit;">Ini memungkinkan Anda untuk tidak membaca seluruh kode pengujian dari awal, misalnya, selama debugging dan perbaikan. </font><font style="vertical-align: inherit;">Kurangnya pabrik menambah keterbacaan terutama ketika tindakan atau pemeriksaan dilakukan pada satu layar.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleLoginTestSuit</span> : <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
<font></font>
    <span class="hljs-comment">//   ,   </span>
    <span class="hljs-keyword">let</span> mainScreen = <span class="hljs-type">MainScreen</span>()
    <span class="hljs-keyword">let</span> profileScreen = <span class="hljs-type">ProfileScreen</span>()
    <span class="hljs-keyword">let</span> authorizationScreen = <span class="hljs-type">AuthorizationScreen</span>()
    <span class="hljs-keyword">let</span> loginScreen = <span class="hljs-type">LoginScreen</span>()<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleLogin</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> user = userFixtureService.createUser() <span class="hljs-comment">//   </span><font></font>
 <font></font>
        mainScreen.openProfileTab() <span class="hljs-comment">//      </span>
        profileScreen.goToAuthorization() <span class="hljs-comment">//     ""</span>
        authorizationScreen.goToLogin() <span class="hljs-comment">//          </span>
        loginScreen <span class="hljs-comment">//           </span><font></font>
            .enterLogin(user.login)<font></font>
            .enterPassword(user.password)<font></font>
            .login()   <font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan jika Anda tidak terlalu tenggelam dalam semua seluk-beluk aplikasi, itu akan segera menjadi jelas dari contoh di atas bahwa tindakan enterLogin / enterPassword dilakukan pada layar yang sama. </font><font style="vertical-align: inherit;">Tes dengan pabrik tidak akan begitu jelas - Anda mungkin berpikir bahwa tindakan enterLogin memindahkan pengguna ke layar berikutnya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Lebih mudah menulis tes dengan tindakan yang dapat menyebabkan layar berbeda</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat menulis tes tanpa pabrik, Anda tidak perlu memikirkan fakta bahwa tindakan pengguna apa pun, tergantung pada kondisi aplikasi, dapat berperilaku berbeda, Anda cukup menjabarkan logika apa yang terjadi:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//        </span><font></font>
    vacancyScreen.tapResponseButton()<font></font>
    authScreen.authUser(user)<font></font>
    responseScreen.checkScreenIsOpened()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
atau</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//       	</span><font></font>
    vacancyScreen.tapResponseButton()<font></font>
    responseScreen.checkScreenIsOpened()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus objek halaman pabrik, Anda harus memikirkan bagaimana, tergantung pada otorisasi pengguna, untuk mengembalikan layar yang diinginkan dalam metode tapResponseButton () (atau menduplikasi metode seperti tapResponseButtonAndLogin ())</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
    ‚Ä¶<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tapResponseButton</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">ResponseSendPageObject</span> {<font></font>
        responseButton.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeResponseSendPageObject()<font></font>
    }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tapResponseButtonAndLogin</span><span class="hljs-params">(login: String)</span></span> -&gt; <span class="hljs-type">ResponseSendPageObject</span> {<font></font>
        responseButton.tap()<font></font>
        pageObjectsFactory<font></font>
            .makeAuthorizationPageObject()<font></font>
            .goToLogin()<font></font>
            .logIn(login)<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeResponseSendPageObject()<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memiliki 6 metode serupa di layar ini, meskipun faktanya mereka semua mengetuk tombol yang sama.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Tidak perlu membungkus setiap tindakan dan masing-masing memeriksa dalam metode terpisah</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode objek halaman tanpa pabrik tidak perlu mengembalikan layar berikutnya untuk melanjutkan rantai, masing-masing, untuk tindakan individu, Anda tidak dapat membuat metode terpisah.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, ketukan pada tombol dalam pengujian tanpa pabrik mungkin terlihat seperti ini:</font></font><br>
<br>
<pre><code class="swift hljs">    vacancyScreen.responseButton.tap()</code></pre><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Tidak harus memikirkan solusi yang kompleks, selain memikirkan arsitektur objek halaman</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam pengalaman saya, ketika menulis autotest tanpa pabrik, praktis tidak ada masalah dengan objek halaman. </font><font style="vertical-align: inherit;">Menggambarkan objek halaman baru adalah proses yang mudah dan cepat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pabrik, beserta kemampuannya, menambah beberapa kesulitan, yang akan saya bahas nanti.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keuntungan yang tak diragukan dari pabrik</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Saat menulis tes, tidak ada cara untuk melewati langkah</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua metode objek halaman adalah tautan dari satu rantai. Setiap tautan (metode) baru harus saling terkait dengan yang berikut ini. Hal ini disebabkan oleh kenyataan bahwa semua metode mengembalikan objek-halaman (sendiri atau yang lain), itulah sebabnya ketika menulis tes kami tidak memiliki cara untuk memilih metode layar apa pun, hanya berikut ini.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, secara signifikan mempercepat penulisan autotest pertama Anda dengan tester baru. IDE sendiri memberi tahu Anda tindakan apa dan di layar mana Anda dapat melakukan lebih lanjut. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kedua, arsitektur autotest ini memungkinkan Anda untuk mengenali aplikasi melalui tulisannya, dan bukan sebaliknya. (lagi - motivasi yang baik untuk penguji muda).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketiga, tidak ada cara untuk melewati langkah, karena metode yang diinginkan tidak akan muncul sampai Anda melewati skrip dengan benar. </font><font style="vertical-align: inherit;">Kelalaian semacam itu sangat umum saat menulis tes tanpa pabrik, dan Anda hanya akan mengetahuinya saat menjalankan tes.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Jika Anda mengubah tanda tangan metode objek halaman, IDE akan memaksa Anda untuk mengubah semua tes yang terkait dengan objek</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Item ini mengikuti dari yang sebelumnya. </font><font style="vertical-align: inherit;">Semua metode objek halaman mengulangi logika dan perilaku aplikasi. </font><font style="vertical-align: inherit;">Jika aplikasi mengubah logika transisi antar layar atau menambahkan yang baru, kami akan memperbaiki metode yang kami butuhkan dan mengubah pengembaliannya. </font><font style="vertical-align: inherit;">Di tes mandiri pabrik, untuk menemukan semua tes yang dipengaruhi oleh perubahan ini, Anda tidak harus menjalankan semua tes. </font><font style="vertical-align: inherit;">IDE itu sendiri akan menunjuk ke semua tempat di mana "rantai" putus. </font><font style="vertical-align: inherit;">Tes tanpa pabrik tidak mengikuti ini.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Arsitektur dan kebersihan kode tidak menderita karena penciptaan objek layar yang berlebihan&nbsp;</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda tidak menggunakan pabrik, dan tes melewati skrip melalui puluhan layar, maka di awal kelas dengan tes Anda harus menulis seluruh blok untuk membuat objek dari setiap layar. </font><font style="vertical-align: inherit;">Dan Anda perlu melakukan ini setiap waktu untuk setiap kelas tes. </font><font style="vertical-align: inherit;">Lebih buruk lagi jika Anda menulis beberapa tes di kelas yang sama. </font><font style="vertical-align: inherit;">Kemudian ukuran "blok" ini dengan penciptaan semua objek halaman meningkat secara signifikan.&nbsp;&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh dari tes nyata, di mana pengguna merespons lowongan, keluar dan masuk ke pengguna lain. </font><font style="vertical-align: inherit;">Blok ini bergerak dari kelas ke kelas dengan perubahan kecil untuk semua tes serupa.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterUpdateAfterOtherUserLoginTest</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> mainScreen = <span class="hljs-type">MainScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> vacanciesScreen = <span class="hljs-type">VacanciesScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> responseToVacancyScreen = <span class="hljs-type">ResponseToVacancyBottomSheet</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> successResponseBottomSheet = <span class="hljs-type">SuccessResponseBottomSheet</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> settingsScreen = <span class="hljs-type">UserSettingsScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> chooseAuthScreen = <span class="hljs-type">ChooseAuthScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> authScreen = <span class="hljs-type">NativeAuthScreenPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> navigation = <span class="hljs-type">NavigationPageObject</span>()
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> moreScreen = <span class="hljs-type">MoreScreenPageObject</span>()<font></font>
<font></font>
    ...<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada opsi untuk membuat inisialisasi semua objek halaman dalam kelas dasar tes menggunakan inisialisasi malas. </font><font style="vertical-align: inherit;">Kemudian di setiap pengujian semua layar akan tersedia dan objek yang tidak perlu tidak akan dibuat. </font><font style="vertical-align: inherit;">Tetapi masalah dengan daftar banyak layar akan kembali ketika kita ingin membuat objek halaman di halaman objek sendiri jika kita perlu menulis metode yang akan melalui layar lain. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pabrik melakukan tugas inisialisasi objek halaman yang diperlukan saat dibutuhkan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Kesempatan besar untuk menyelam lebih dalam ke kode aplikasi, mempelajari arsitekturnya, modul, interaksinya, dll.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memiliki pabrik objek halaman memerlukan membungkus semua tindakan dengan layar dalam metode yang akan mengembalikan layar berikutnya. </font><font style="vertical-align: inherit;">Karena itu, objek halaman berkembang sangat pesat, yang membuat Anda bertanya-tanya bagaimana membuat semuanya lebih indah dan akurat. </font><font style="vertical-align: inherit;">Untuk itu, Anda mencoba menggunakan teknik arsitektur, menonton implementasi berbagai layar dalam kode aplikasi, melacak interaksi modul untuk membangun sistem serupa di autotests Anda, yang akan menyenangkan dan nyaman untuk digunakan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai bonus, kami memperoleh pengetahuan tentang cara kerja aplikasi dari dalam. </font><font style="vertical-align: inherit;">Paling tidak, ini berguna untuk pengembangan keseluruhan, dan sering sangat membantu saat pengujian.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Kode tes terlihat sangat rapi dan bersih.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak ada komentar, ini benar-benar bumbu. </font><font style="vertical-align: inherit;">Tentang bagaimana Anda "lebih akurat dan bersih" dapat diputuskan dengan contoh pertama.</font></font><br>
<br>
<p></p><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perangkap // bagaimana mereka tersandung dan berkeliling</font></font></h1><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gd/4a/jz/gd4ajzpobkjvg6t4tq1vy-3a-ws.jpeg" width="60%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita dapat menyimpulkan bahwa lebih baik menggunakan pabrik objek halaman saat menulis autotest. </font><font style="vertical-align: inherit;">Jangan tanya siapa pun mengapa mereka menggunakan pabrik, selalu ada satu jawaban: "Dan Anda mencoba menulis tes tanpa itu dan membandingkan." </font><font style="vertical-align: inherit;">Pabrik benar-benar mengambil bagian penting dari tugas, tanggung jawab atas tidak adanya kesalahan dalam urutan autotest, dan sebagainya. </font><font style="vertical-align: inherit;">Ini juga membuka beberapa peluang menarik yang saya tulis di atas.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi saya ingin mencatat bahwa semuanya tidak selalu cerah dengan kemampuan ini. </font><font style="vertical-align: inherit;">Selama otomatisasi dengan pabrik, kami menemui masalah yang sangat tidak menyenangkan, tetapi pada akhirnya kami menyelesaikannya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protokol dan elemen yang umum untuk seluruh aplikasi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada elemen dalam aplikasi seluler apa pun yang dapat diakses dari layar apa pun. Misalnya, Anda dapat mengambil tabbar (menu). Timbul pertanyaan: bagaimana, tanpa mengganggu rantai panggilan ke metode objek halaman, mendapatkan akses ke metode tabbar kapan saja dalam pengujian?&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang paling jelas dan keputusan awal kami adalah membuat ekstensi kelas dasar objek halaman dengan metode ini.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">import</span> XCTest<font></font>
 <font></font>
<span class="hljs-comment">/*
      .
 */</span>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> tabBar = application.tabBars[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.identifier].firstMatch
    <span class="hljs-keyword">var</span> searchTab =  tabBar.buttons[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.searchTab].firstMatch<font></font>
    ‚Ä¶<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openSearchTab</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">MainScreenPageObject</span> {<font></font>
        searchTab.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory.makeMainScreenPageObject()<font></font>
    }<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selama diskusi, kami menyadari bahwa tabbar bukan satu-satunya elemen yang diperlukan pada semua layar, dan sampai pada kesimpulan bahwa dengan menambahkan lebih banyak ekstensi, kami akan dengan cepat mengacaukan kelas dasar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kerugian lain dari solusi ini adalah bahwa metode menjadi tersedia untuk semua objek halaman, yang salah. Ini melanggar kontrak untuk kelas-kelas penerus, yang, dalam teori, hanya boleh berisi metode khusus untuk mereka. Misalnya, untuk objek lansiran laman, metode tabbar tidak diperlukan.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusi akhir kami - kami membuat protokol TabBarUsable dari objek halaman Tabbar (antarmuka untuk Kotlin serupa). Dan mereka menulis ekstensi (ekstensi, implementasi), yang memungkinkan Anda untuk tidak menduplikasi kode, dan pada saat yang sama mengganti warisan dengan komposisi.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">import</span> XCTest<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TabBarUsable</span> </span>{
    <span class="hljs-keyword">var</span> searchTab: <span class="hljs-type">XCUIElement</span> { <span class="hljs-keyword">get</span> }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openSearchTab</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">MainScreenPageObject</span><font></font>
    ‚Ä¶<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">TabBarUsable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> tabBar: <span class="hljs-type">XCUIElement</span> { application.tabBars[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.identifier].firstMatch }
    <span class="hljs-keyword">var</span> searchTab: <span class="hljs-type">XCUIElement</span> { tabBar.buttons[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">TabBar</span>.searchTab].firstMatch }<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openSearchTab</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">MainScreenPageObject</span> {<font></font>
        searchTab.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory.makeMainScreenPageObject()<font></font>
    }<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk semua layar yang memiliki tabbar, kami menambahkan kepatuhan dengan protokol ini (sesuaikan).</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">TabBarUsable</span> </span>{<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, semua metode bekerja dengan tabbar menjadi tersedia di semua layar ini.&nbsp;</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleTabbarTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleOpenSearchTab</span><span class="hljs-params">()</span></span> {<font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openVacanciesList()<font></font>
            .openVacancy() <span class="hljs-comment">//   .makeVacancyPageObject()</span>
            .openSearchTab() <span class="hljs-comment">//   TabBarUsable </span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada saat yang sama, arsitektur tidak pecah, metode tabbar hanya tersedia untuk layar yang kita butuhkan, dan kode metode yang sama tidak diduplikasi.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protokol dan Revisi Kode</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti disebutkan sebelumnya, ketika menggunakan pabrik objek halaman, semua tindakan dan semua pemeriksaan dibungkus dengan metode. </font><font style="vertical-align: inherit;">Setelah beberapa saat, membuat autotest berikutnya, Anda mulai memperhatikan bahwa Anda menulis metode yang sama untuk setiap objek halaman, yang bahkan tidak berbeda dalam elemen. </font><font style="vertical-align: inherit;">Contoh metode tersebut dapat berupa pemeriksaan layar nol, bekerja dengan item daftar identik pada layar yang berbeda, dan sebagainya.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/a2/xg/ic/a2xgiczqetidmsoqa2rl2aandjo.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada pemikiran logis: "Saya akan membuatnya lebih mudah untuk saya?!". Bagaimana cara menghentikan duplikasi kode? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode pertama yang sudah saya tulis adalah untuk memasukkan semua metode tersebut ke dalam kelas dasar. Itu mungkin, tetapi sangat hati-hati. Pertama, proses ini sangat menarik. Tampaknya satu metode di kelas dasar tidak akan merusak apa pun, tetapi cepat atau lambat kelas dasar berubah menjadi monster yang tak tertahankan, tidak terstruktur, berantakan, singkatnya, itu menjadi benar-benar tidak mungkin. Kami mencoba, kami tahu. Menyingkirkan monster ini bahkan lebih sulit daripada segera melakukannya dengan benar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seiring waktu, kami menyadari bahwa prinsip KERING (Jangan Ulangi Diri Sendiri) diciptakan karena suatu alasan. Kami mulai mencari metode yang sama yang digunakan di banyak objek halaman. Setelah menemukan mereka, mereka berdiskusi untuk waktu yang lama apakah metode ini benar-benar digunakan di mana-mana, memiliki logika yang sama. Dan akhirnya, mereka memutuskan bahwa jika metode yang digunakan dalam 80% kasus dengan cara yang sama, maka mereka harus diambil dalam protokol terpisah.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satu metode pertama yang diberikan adalah metode waitView (). Kami menggambarkan protokol ViewWaitable khusus dan implementasinya dalam ekstensi protokol, dan sekarang, agar metode ini tersedia di objek halaman, Anda hanya perlu menambahkan kesesuaian dengan protokol (konform). Karena pengidentifikasi tampilan berbeda untuk semua layar, semua objek halaman menggunakan protokol harus menyatakan tampilan dalam dirinya sendiri.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ViewWaitable</span> </span>{
    <span class="hljs-keyword">var</span> view: <span class="hljs-type">XCUIElement</span> { <span class="hljs-keyword">get</span> }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">ViewWaitable</span> <span class="hljs-title">where</span> <span class="hljs-title">Self</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-meta">@discardableResult</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">waitView</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> {<font></font>
        testWaiter.waitForElementToAppear(view)<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">TabBarUsable</span>, <span class="hljs-title">ViewWaitable</span> </span>{<font></font>
 <font></font>
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> view = application.otherElements[<span class="hljs-type">Accessibility</span>.view].firstMatch<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh lain dari aplikasi hh.ru kami: kami memiliki daftar lowongan yang dapat ditemukan di banyak layar berbeda, dengan satu-satunya pengidentifikasi yang menjadi pengidentifikasi tampilan tempat daftar ini ditampilkan. Banyak tindakan dan banyak pemeriksaan terkait dengan daftar ini. Lipat gandakan dengan sekitar 10 (dengan jumlah layar daftar ini muncul) untuk memperkirakan skala duplikasi kode.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusinya lagi protokol. Untuk membuat protokol lebih dimengerti dan menyenangkan untuk digunakan, kami membagi elemen daftar (VacancyListContainig), elemen sel (VacancyCellContainig), metode dengan cek (menegaskan, memeriksa), dan metode interaksi (tindakan). Pemisahan ini dengan sempurna memecahkan masalah keterbacaan isi objek halaman besar. Arsitektur terakhir terlihat seperti ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/sx/zw/_j/sxzw_jfnqwufs2snkgohmzxawb4.png" width="50%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Objek halaman yang berisi daftar lowongan dapat menambahkan kepatuhan pada protokol VacancyListPageObject. </font><font style="vertical-align: inherit;">Dengan demikian, semua metode dari implementasi protokol ini tersedia untuk layar tanpa duplikasi kode.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchResultPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">ViewWaitable</span>, <span class="hljs-title">VacancyListPageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> view = application<font></font>
        .otherElements[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">SearchResults</span>.view].firstMatch
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> listView = application<font></font>
        .tables[<span class="hljs-type">Accessibility</span>.<span class="hljs-type">SearchResults</span>.tableView].firstMatch<font></font>
    ‚Ä¶<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akibatnya, karena mengikuti prinsip KERING, kami memiliki objek halaman yang sangat bersih, rapi, nama metode yang sama, dan kurangnya kode tambahan.&nbsp;</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lansiran yang sama di layar berbeda // Sumber</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kesalahan sistem, peringatan, lembaran bawah adalah bagian integral dari regresi, yang tentu saja ingin saya bahas dengan tes otomatis. Kesalahan dan peringatan terjadi pada layar yang berbeda, dalam kasus yang berbeda, berbeda di negara aplikasi yang berbeda, tetapi elemen itu sendiri, pada dasarnya, memiliki pengidentifikasi dan perilaku yang sama. Jelas, jenis peringatan yang sama dengan dua tombol (misalnya, Ok / Batal) = satu objek halaman terpisah.&nbsp;&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami kembali ke keinginan untuk tidak mengganggu rantai panggilan metode. Kami memiliki - puluhan layar yang darinya kami dapat membuka peringatan yang sama. Saat menutup lansiran seperti itu, kita harus kembali ke objek halaman tempat dibuka. Pada saat yang sama, kami tidak ingin menulis lusinan metode duplikat ini di objek halaman peringatan tersebut, yang akan berbeda satu sama lain hanya di objek halaman yang dikembalikan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusi paling sederhana adalah dengan skor dan istirahat tes sekali. </font><font style="vertical-align: inherit;">Tidak ada yang salah dengan itu juga. </font><font style="vertical-align: inherit;">Dan hidup jadi lebih sederhana.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExample</span><span class="hljs-params">()</span></span> {<font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openVacanciesList()<font></font>
            .openVacancy()<font></font>
            .openAlert()<font></font>
            .closeAlert() <span class="hljs-comment">//      ,     </span><font></font>
        pageObjectFactory<font></font>
            .makeVacancyPageObject() <span class="hljs-comment">//   </span><font></font>
        ‚Ä¶<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusi kami lebih rumit, tetapi betapa indahnya itu! </font><font style="vertical-align: inherit;">Kami menambahkan objek halaman dari parameter tipe peringatan ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generik</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), itu akan menjadi tipe objek halaman tempat kami membuka lansiran. </font><font style="vertical-align: inherit;">Dalam hal ini, objek halaman layar ini ditransfer ke peringatan objek halaman setelah inisialisasi dan disimpan sebagai variabel sumber generik.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lebih lanjut tentang cara kerjanya: ketika Anda membuka (dan menginisialisasi) peringatan, kami melewati layar yang diinginkan dalam variabel generik sumber. </font><font style="vertical-align: inherit;">Ini dilakukan dalam metode objek halaman, yang membuka peringatan:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyPageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
    ‚Ä¶<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openAlert</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AlertPageObject</span>&lt;<span class="hljs-type">VacancyPageObject</span>&gt; {<font></font>
        button.tap()<font></font>
        <span class="hljs-keyword">return</span> pageObjectsFactory<font></font>
            .makeAlertPageObject(from: <span class="hljs-keyword">self</span>) <span class="hljs-comment">//  source VacancyPageObject</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, sumber ini (dalam contoh ini, VacancyPageObject) melewati semua metode yang diperlukan dalam tes dan berakhir di pembubaran akhirAlert (). </font><font style="vertical-align: inherit;">Akibatnya, metode penutupan tanda mengembalikan layar yang kita butuhkan, yang dengannya kita dapat segera melanjutkan tes.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlertPageObject</span>&lt;<span class="hljs-title">Source</span>: <span class="hljs-title">BasePageObject</span>&gt;: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dismissAlert</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Source</span> {<font></font>
        cancelButton.tap()<font></font>
        <span class="hljs-keyword">return</span> source <span class="hljs-comment">//  ,     ‚Äî VacancyPageObject</span><font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang telah saya katakan, agar objek halaman dapat menerima dan mengembalikan layar yang diperlukan (sumber), perlu menetapkan jenis generik terbatas pada tipe dasar objek halaman dan menginisialisasi dengan menggunakan objek halaman, yang perlu dikembalikan pada bagian paling akhir. :</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlertPageObject</span>&lt;<span class="hljs-title">Source</span>: <span class="hljs-title">BasePageObject</span>&gt;: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
 <font></font>
    <span class="hljs-comment">// generic-          </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> source: <span class="hljs-type">Source</span><font></font>
 <font></font>
    <span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>,<font></font>
         application: <span class="hljs-type">XCUIApplication</span>,<font></font>
         source: <span class="hljs-type">Source</span>) {
        <span class="hljs-keyword">self</span>.source = source
        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(pageObjectsFactory: pageObjectsFactory, application: application)<font></font>
    }<font></font>
 <font></font>
    <span class="hljs-comment">//  BasePageObject   ,      </span>
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(pageObjectsFactory: <span class="hljs-type">PageObjectsFactory</span>, application: <span class="hljs-type">XCUIApplication</span>) {
        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"init(pageObjectsFactory:application:) has not been implemented. Use another init"</span>)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inisialisasi objek halaman generik di pabrik akan terlihat seperti ini:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageObjectsFactory</span> </span>{<font></font>
    ‚Ä¶<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeAlertPageObject</span>&lt;Source: BasePageObject&gt;<span class="hljs-params">(
        from source: Source
    )</span></span> -&gt; <span class="hljs-type">AlertPageObject</span>&lt;<span class="hljs-type">Source</span>&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-type">AlertPageObject</span>(pageObjectsFactory: <span class="hljs-keyword">self</span>,<font></font>
                                          application: application,<font></font>
                                          source: source)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ta-daa! </font><font style="vertical-align: inherit;">Semuanya sudah siap, dan sekarang kita dapat melanjutkan tes tanpa memutus rantai panggilan.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleSourcesTestSuit</span>: <span class="hljs-title">BaseTestCase</span> </span>{<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testExampleSource</span><span class="hljs-params">()</span></span> {<font></font>
        pageObjectsFactory<font></font>
            .makeMainScreenPageObject()<font></font>
            .openVacanciesList()<font></font>
            .openVacancy()<font></font>
            .openAlert()<font></font>
            .dismissAlert()<font></font>
            .checkVacancyScreenIsOpened() <span class="hljs-comment">//       ,         </span><font></font>
        ‚Ä¶<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gn/rt/hs/gnrthsrb0jerc7jtimpsmfqeryw.jpeg" width="70%"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek halaman besar, bagaimana memahaminya</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada layar (meskipun ada) di mana banyak konten berbeda, berbagai elemen antarmuka, blok logis individu ditempatkan. Pada saat yang sama, mereka semua berada di layar yang sama, dan saya ingin berinteraksi dengan mereka melalui objek halaman, yang menggambarkan layar ini.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, ambil layar utama aplikasi seluler kami.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/2a/bc/v8/2abcv8sw0r9idx5m53mrj7hcf8u.jpeg" width="40%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Layar ini dapat dibagi menjadi tiga bagian yang sepenuhnya independen: bilah pencarian, blok riwayat pencarian dan tab dengan daftar pekerjaan. Mungkin saja untuk menggambarkan semuanya dalam satu objek halaman-e (setelah semua, ini adalah layar penuh penuh), tetapi tidak akan mudah untuk menggunakannya, karena setiap bagian memiliki logika sendiri, pemeriksaan sendiri, dll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juga, dalam memperluas objek halaman, cepat atau lambat, masalah nama metode muncul. Ada banyak sel, judul, subtitle, dll yang berbeda, sebagai akibatnya, alih-alih nama sederhana, Anda harus memberikan yang panjang, dengan klarifikasi tentang apa yang sebenarnya berkaitan. Tes menulis menjadi sangat tidak nyaman dan sulit. Setiap kali Anda memilih metode dalam pengujian, Anda harus membuka kode objek halaman dan hati-hati menyelidikinya agar tidak membuat kesalahan.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VacancyListPageObject</span>: <span class="hljs-title">BasePageObject</span> </span>{<font></font>
    ‚Ä¶<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertHistoryListFirstCellTitleExists</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertHistoryListCellByTitleExists</span><span class="hljs-params">(title: String)</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertRecommendationsListFirstCellTitleExists</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertVacancyNearbyListFirstCellTitleExists</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Self</span> { ...  }<font></font>
    ‚Ä¶  <font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/ia/_g/zwia_gz_wjygrw7tpmis1_gnx8q.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusi paling sederhana adalah tidak melihat masalah. Tidak peduli seberapa besar objek halamannya, Anda tetap dapat menggunakannya (terutama jika Anda terbiasa). Tapi saya tidak ingin terbiasa dengannya, tetapi saya ingin itu menjadi indah dan nyaman. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus, "bagian-bagian" ini dapat berupa berbagai modul dalam kode, yang berarti dapat digunakan kembali pada berbagai layar aplikasi. Jika kita membangun arsitektur yang mirip dengan objek halaman, kita juga dapat menggunakannya kembali. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami membuat keputusan dengan kemauan keras - sekarang untuk bagian seperti itu kami menulis berbagai kelas objek halaman. Untuk masing-masing dari mereka, kami menambahkan korespondensi ke protokol MainScreenSection kosong pemersatu: BasePageObject {}. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, ambil bagian riwayat pencarian di layar utama. Objek halamannya akan terlihat seperti ini:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchHistoryPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">MainScreenSection</span> </span>{
    <span class="hljs-comment">// </span>
    <span class="hljs-comment">// </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada dasarnya, objek halaman dari MainScreenPageObject, yang menggambarkan layar utama, kami membuat metode yang kami katakan dari pengujian di bagian mana kami akan melakukan sesuatu sekarang. </font><font style="vertical-align: inherit;">Ini terlihat seperti ini.&nbsp;</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainScreenPageObject</span>: <span class="hljs-title">BasePageObject</span>, <span class="hljs-title">TabBarUsable</span> </span>{<font></font>
    ‚Ä¶<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">section</span>&lt;Section: MainScreenSection&gt;<span class="hljs-params">(<span class="hljs-number">_</span> section: Section.<span class="hljs-keyword">Type</span>)</span></span> -&gt; <span class="hljs-type">Section</span> {
        <span class="hljs-keyword">return</span> section.<span class="hljs-keyword">init</span>(pageObjectsFactory: pageObjectsFactory, application: application)<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam metode ini, kami melewati jenis bagian, di dalam kami menginisialisasi objek halaman menggunakan metode pabrik generik.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai hasilnya, kami mendapat pengujian tanpa gangguan, kurangnya inisialisasi objek halaman besar yang tidak perlu, dan keterbacaan kode.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">//        ‚Äú ‚Äù</span>
    .openSearchTab() <span class="hljs-comment">//   MainScreenPageObject</span>
    .section(<span class="hljs-type">SearchHistoryPageObject</span>.<span class="hljs-keyword">self</span>) <span class="hljs-comment">//     </span>
    .waitHistoryIsLoad() <span class="hljs-comment">//   page object-  </span>
    .section(<span class="hljs-type">MainScreenPageObject</span>.<span class="hljs-keyword">self</span>) <span class="hljs-comment">//       </span>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meringkaskan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat menulis autotest tanpa pabrik objek halaman. Objek halaman dengan pendekatan ini ditulis dengan sangat cepat dan sederhana, terutama jika mereka tidak memerlukan inisialisasi yang kompleks. Tetapi, di sisi lain, saat menulis ujian, Anda harus sangat berhati-hati. Tanggung jawab untuk urutan langkah-langkah dalam pengujian, inisialisasi objek halaman, kurangnya pembungkus atas beberapa tindakan, dll. Terletak pada tester. Jika aplikasi Anda tidak terlalu rumit, maka itu mungkin tidak layak rumit, dan semua masalah yang tercantum pada umumnya tidak akan terlihat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika, pada awalnya, Anda duduk sedikit di atas penciptaan pabrik, maka di masa depan itu akan, pertama, mengambil sendiri semua tanggung jawab di atas, dan kedua, itu akan membuat proses penulisan autotest sangat sederhana dan hampir tanpa kemungkinan kesalahan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/uc/i6/ta/uci6takmotdv_r0ujdl5kbv3_3a.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena tidak ada keputusan tunggal yang tepat, terserah Anda untuk memutuskan. </font><font style="vertical-align: inherit;">Kami terus menggunakan kedua pendekatan, dan semua orang merasa nyaman dan baik. </font><font style="vertical-align: inherit;">Semoga beruntung dan autotest yang indah!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tautan yang bermanfaat:</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel tentang pola Objek Halaman</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel keren tentang peran arsitektur dalam otomatisasi</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kotlin DSL, Jadwal dan tes UI yang elegan di Android</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antarmuka, Protokol, dan Ekstensi / Swift vs. </font><font style="vertical-align: inherit;">Kotlin</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kekuatan generik di Swift</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id507032/index.html">Pesan ‚ÄúJual portofolio Anda. Apa yang tidak diajarkan di sekolah desain "</a></li>
<li><a href="../id507034/index.html">Webstorm NodeJs interpreter dari wadah Docker</a></li>
<li><a href="../id507040/index.html">Bagaimana mengurangi pendaftaran kerusakan di bawah asuransi kewajiban motor wajib dari beberapa hari menjadi 60 menit</a></li>
<li><a href="../id507042/index.html">Saya ingin gamedev: 27 balasan dari 8 pro</a></li>
<li><a href="../id507044/index.html">Papan paling terjangkau untuk bereksperimen dengan SoC'om MCU & FPGA</a></li>
<li><a href="../id507050/index.html">Analisis desain game Hollow Knight. Bagian 1. Persimpangan yang Terlupakan</a></li>
<li><a href="../id507052/index.html">Data Scientist paling keren tidak membuang waktu untuk statistik</a></li>
<li><a href="../id507058/index.html">Joel Spolsky: Peran Gamifikasi dalam Keberhasilan Stack Overflow</a></li>
<li><a href="../id507066/index.html">10 Cara untuk Mengotomatiskan Iklan di Google Ads</a></li>
<li><a href="../id507068/index.html">Panduan Instrumentasi Manajemen Windows (WMI): Memahami Serangan WMI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>