<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚙️ 😅 💌 Zeichnen mit Ameisen: prozedurale Bilder unter Verwendung von Algorithmen zur Optimierung von Ameisenkolonien 😂 🤽 🤸🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Warum wollte ich mit Ameisen zeichnen?
 Ich wollte ein Kunstwerk schaffen, das die Komplexität des Software-Designs untersucht. Wenn ich eine riesige ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Zeichnen mit Ameisen: prozedurale Bilder unter Verwendung von Algorithmen zur Optimierung von Ameisenkolonien</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487098/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59e/d31/366/59ed31366bcf08b906a07e476152a66c.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum wollte ich mit Ameisen zeichnen?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich wollte ein Kunstwerk schaffen, das die Komplexität des Software-Designs untersucht. Wenn ich eine riesige Codebasis präsentiere, denke ich an die unabhängig auftretende Komplexität und die miteinander verflochtenen, miteinander verbundenen Teile. Seine allgemeine Form ergibt sich sozusagen aus den Handlungen vieler einzelner Persönlichkeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich dachte darüber nach, wie ich das grafisch darstellen könnte, und eines der Bilder, die in mir eine Antwort fanden, war das Bild einer Ameisenkolonie. Ameisen sind ein gutes Beispiel für aufkommende (aufkommende) Komplexität. Keine einzelne Ameise ist Architekt, aber zusammen bauen sie prächtige komplexe Strukturen.</font></font><br>
<a name="habracut"></a><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b1/4f3/a72/5b14f3a72a15eefbeef534448a51647b.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schema der Formicaria. Quelle: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikimedia Commons</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ich suchte zunächst nach Informationen über Simulationen von Ameisenkolonien. Offensichtlich gibt es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Literatur darüber, und es ist wunderschön</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Der Trick war jedoch, dass die Ameisenhaufen teilweise abhängig von der Physik des Sandes und der Erde entstehen, in der sie gebaut sind - denn ihre Entstehung hängt davon ab, wie sich das Teilchen befindet, wenn die Ameise es einsetzt. Ich wollte etwas in 2D erstellen, also habe ich versucht, direkt zur Simulation zu gelangen, ohne Sandphysikcode zu schreiben, dh ich musste die physikalische Simulation des Ameisenhügels aufgeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus diesem Grund begann ich erneut zu suchen und sie führten mich zu einer völlig </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anderen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse von Ameisensimulationen:</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithmen zur Optimierung von Ameisenkolonien (Algorithmen für Ameisenkolonien)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ameisenkolonieoptimierung ist ein Agentenalgorithmus, mit dem das Problem gelöst wird, den kürzesten Weg zwischen zwei Punkten eines Graphen zu finden. "Agent" bedeutet, dass der Algorithmus aus separaten Prozeduren besteht (in diesem Fall "Ameisen"), deren auftretendes Verhalten das Problem löst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es funktioniert sehr einfach. Jede Ameise hinterlässt auf ihrem Weg eine Spur von „Pheromonen“. Ameisen verlassen eine Art von Pheromon, nachdem sie den Ameisenhaufen verlassen haben, und die andere, wenn sie Nahrung finden. Ameisen, die nach Nahrung suchen, suchen nach einer Spur eines "Nahrungs" -Pheromons, während diejenigen, die nach Ameisenhaufen suchen, nach einer Spur eines "Heim" -Pheromons suchen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ameisen, die sich auf einem kürzeren Weg befinden, können schneller von zu Hause zum Futter und umgekehrt gelangen. </font><font style="vertical-align: inherit;">Dies bedeutet, dass sie eine gesättigtere Schicht von Pheromonen bilden. </font><font style="vertical-align: inherit;">Ameisen, die sich länger bewegen, bevorzugen eine reichhaltigere Spur und bewegen sich auf einem kürzeren Weg. </font><font style="vertical-align: inherit;">Jede einzelne Ameise arbeitet nach sehr einfachen Regeln, aber im Laufe der Zeit finden die Ameisen einen optimaleren Weg zwischen zwei Punkten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simulation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe meinen Ameisensimulator für Processing 3 geschrieben. Ich habe meine eigene Implementierung gestartet, indem ich den Code </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus diesem erstaunlichen Beitrag von Gregory Brown</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simuliert habe </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem sich die Ameisen zu bewegen begannen, begann ich, den Code zu erweitern und zu modifizieren, damit er in größeren Pixelgittern besser funktioniert. Ich wollte interessant aussehende Simulationen (nicht unbedingt </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">effektiv</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und das bestimmte meine Arbeit am Code. Ich habe eine sehr rudimentäre Vision für Ameisen erstellt, damit jede Ameise mehrere Pixel vor sich sehen kann. Ich habe den Tod und die Wiedergeburt von Ameisen hinzugefügt, damit sie sich nicht zufällig im Raum verteilen. Schließlich habe ich die Ameisen etwas dümmer gemacht: Sie verlassen das Pheromon ständig, auch wenn die Suche nicht erfolgreich war, was dem tatsächlichen Verhalten der Ameisen ähnelt.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier können</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie den Simulationsport auf p5.js direkt in Ihrem Browser abspielen! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können sich auch den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">portierten Quellcode auf Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ansehen </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">. </font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor allem in der Simulation war ich fasziniert von den schönen, seltsamen und komplexen Formen, die Ameisen erzeugen. </font><font style="vertical-align: inherit;">Sie marschieren nicht in geraden Linien, sondern bilden Schleifen, Kurven und Zweige. </font><font style="vertical-align: inherit;">Noch interessanter ist, dass Sie das Erscheinungsbild von Figuren, die von Ameisen erstellt wurden, steuern können, indem Sie verschiedene Variablen ihrer Welt ändern. </font><font style="vertical-align: inherit;">Sie können beispielsweise die Pheromonverdampfungsrate und den Sichtbereich von Ameisen in Pixel ändern.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ameisen in Kunst verwandeln</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem die Simulation zu funktionieren begann, bestand der nächste Schritt darin, die ausgegebenen Daten zu untersuchen. Mein Ziel war es, eine Art zweidimensionales Bild zu erstellen, dh ich musste die von den Ameisen erstellten Figuren erfassen und zeichnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende habe ich verschiedene Arten von Ausgaben geschrieben: verschiedene Arten von Rasterausgaben und einen Vektor. Um die Rasterausgabe zu erfassen, habe ich die von den Ameisen besuchten Zellen und die Häufigkeit ihrer Besuche verfolgt. Nachdem Sie mit den Filtern dieser Schlussfolgerung gespielt haben, können Sie eine gespenstische Spur der Orte erhalten, an denen die Ameisen besucht haben.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b02/930/8ca/b029308ca64dee625eccbe87749bfc87.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Beispiel für eine Rasterausgabe. </font><font style="vertical-align: inherit;">Die Wege sind viel breiter entlang der beliebten Ameisenpfade und wo die Ameisen zufällig um den Ameisenhaufen herumstreiften. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Rasterausgabe war interessant, aber ich wollte die einzelnen Pfade klarer sehen, deshalb habe ich die Möglichkeit des Exports nach svg untersucht. </font><font style="vertical-align: inherit;">Für die Vektorausgabe habe ich die Geschichte jeder Ameise gespeichert, und als sie Nahrung oder Ameisenhaufen erreichten, habe ich diese Geschichte auf die Liste geschrieben. </font><font style="vertical-align: inherit;">Zum Rendern habe ich jeden gespeicherten Pfad abgetastet und als eine Reihe von Kurven gerendert.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/069/397/a81/069397a81dcb254778ab2ce864bab992.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Beispiel für die Vektorausgabe. </font><font style="vertical-align: inherit;">Hier sehen Sie die einzelnen Wege der Ameisen. </font><font style="vertical-align: inherit;">Wo es viele Ameisen gab, bilden leicht überlappende Linien breitere Wege.</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbinde die Punkte</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich wusste, dass ich Ameisen zeichnen wollte, die zwischen vielen Punkten reisen, daher war der Code zum Verknüpfen mehrerer Simulationen zu einem Bild einer der ersten. Aber was soll ich dann zeichnen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst habe ich beschlossen, sehr wörtliche Diagramme zu erstellen: angefangen bei einfachen Binärbäumen bis hin zu komplexeren Visualisierungen. Dies schien ein natürlicher Schritt zu sein, da die Optimierung der Ameisenkolonie das Problem löst, Pfade in Graphen zu finden. Ich dachte auch, dass dies eine interessante Möglichkeit wäre, die Komplexität des Codes zu visualisieren: Warum nicht ein UML-Diagramm oder ein Abhängigkeitsdiagramm nehmen und sie mit Ameisen rendern? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich war bereits mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphviz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vertraut </font><font style="vertical-align: inherit;">und habe mich daher für dieses Toolkit und die </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">DOT- </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Grafikbeschreibungssprache</font></a><font style="vertical-align: inherit;"> entschieden</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um die Knoten und Kanten meiner Simulation anzugeben. </font><font style="vertical-align: inherit;">Graphviz verfügt über einen Modus, der eine DOT-Datei mit Anmerkungen zu Pixelkoordinaten ausgibt. </font><font style="vertical-align: inherit;">Ich habe einen sehr hässlichen DOT-Datei-Parser geschrieben und ihn mit einer kommentierten DOT-Datei verwendet, um Ameisenhaufen- und Essensstandorte zu simulieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Experimente mit binären Bäumen schienen vielversprechend und ergaben ein sehr natürliches, organisches Aussehen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/971/59e/e53/97159ee533223d92707a989ba83c10c3.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein einfacher Binärbaum. </font><font style="vertical-align: inherit;">Mir wurde gesagt, dass es wie ein Angiogramm ist.</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/278/845/f30/278845f30db3fab5dc9085c6261130b7.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein etwas komplexerer Baum, schon ziemlich tief. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann fing ich an, mehr Diagramme mit verschiedenen Codebasen als Eingabe zu erstellen. </font><font style="vertical-align: inherit;">Ich habe einige einfache Python-Skripte geschrieben: Das eine verwandelte den Git-Baum in eine DOT-Datei, das andere verwandelte C-Importabhängigkeiten in eine DOT-Datei.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d41/699/426/d41699426c3cf2e31c97b2ee429dc34b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diagramm der Objekte im Git-Objektbaum, gezeichnet von Ameisen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/813/525/30d/81352530da26c9e3cdf334d6909c479e.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abhängigkeiten zwischen Dateien im Linux-Kernel. Knoten und Kanten wurden im quadratischen Stil von Graphviz-Diagrammen erstellt. In der Tat nicht viel interessanter als zufällige Grafiken.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Obwohl all diese Grafiken interessant und definitiv komplex sind, war ich enttäuscht, dass sie tatsächlich nichts über die allgemeine Form der Codebasen sagten, auf denen sie aufgebaut waren. Je mehr ich mit Code-Visualisierung experimentierte, desto mehr wurde mir klar, dass das Erstellen eines interessanten Diagramms aus einer Codebasis an sich eine separate, schwierigere Aufgabe ist. Ich mochte jedoch die Komplexität sehr großer Grafiken und kam später wieder darauf zurück. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mein nächstes Experiment waren Spiele mit einfachen Formen. Ich habe Diagramme aus Linien, Kreisen, Sinuskurven und anderen Formen erstellt, die mit Knoten und Kanten leicht zu beschreiben sind.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fab/5f3/287/fab5f32876434586bafc780db2d897d9.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Punkte auf dem Segment auf der rechten Seite des Segments liegen näher beieinander.</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d5/8e5/ef1/2d58e5ef1de0f74706ee2e47321b94d0.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterschiedliche Sinuswellenfrequenzen. </font><font style="vertical-align: inherit;">Ich nehme an, ein ziemlich gutes Oszilloskop wird aus den Ameisen kommen. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einfachsten triangulierten Räume schienen mir die interessantesten zu sein. </font><font style="vertical-align: inherit;">Ich habe viele gleichmäßig verteilte Punkte generiert - entweder zufällig oder durch Zeichnen von Formen - und dann die Verarbeitungsbibliothek verwendet, um diese Punkte in eine Delaunay-Triangulation oder ein Voronoi-Diagramm umzuwandeln. </font><font style="vertical-align: inherit;">Dann wurden die resultierenden Rippen verwendet, um Ameisen zu simulieren, wobei jede Rippe einen "Ameisenhaufen" oder "Futter" bezeichnete.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59e/d31/366/59ed31366bcf08b906a07e476152a66c.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gezeichnet von Ameisen Voronoi Diagramm.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dies führte zum Erscheinen eines wunderschönen, vollen Raums komplexer Ameisen-Komplikationen, der die Komplexität, die mich interessiert, viel besser beschreibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließlich näherte ich mich der Aufgabe aus einem anderen Blickwinkel. Ein Freund schaute sich die Simulation an und fragte, was passieren würde, wenn die Ameisen mit der Wand kollidieren - können sie einfache Hindernisse vermeiden? Mein Code wusste bereits, wie man Wände als Grenzfälle behandelt, also fügte ich nur Innenwände hinzu und verbrachte dann viel Zeit damit, Ameisen beizubringen, wie man Labyrinthe löst.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e74/803/088/e74803088c3d09ddb1b2b77902004c72.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Wege der Ameisen, die versuchen, ein einfaches Labyrinth zu lösen. </font><font style="vertical-align: inherit;">Sie können die Form des Labyrinths sehen, indem Sie feststellen, wohin die Ameisen nicht gehen können. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hatte die Idee, dass Ameisen, wenn sie einfache Labyrinthe lösen können, diese miteinander kombinieren können, um eine größere Arbeit zu schaffen. </font><font style="vertical-align: inherit;">Ich habe viel Zeit damit verbracht, die Simulationsvariablen so einzurichten, dass die Ameisen sie lösen konnten, aber ich konnte sie immer noch nicht dazu bringen, die Labyrinthe stabil zu lösen. </font><font style="vertical-align: inherit;">Am Ende verwandelte sich all dies in nur Locken von Ameisenpfaden, die durch die Form des Labyrinths selbst begrenzt waren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertiges Kunstwerk</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu diesem Zeitpunkt beschloss ich, einen Schritt zurückzutreten und die Ergebnisse aller meiner Experimente zu berücksichtigen. Ich erkannte, dass die interessantesten Bilder aus großen Feldern halbzufälliger Punkte und Kanten stammen, und entschied mich, dies zu meiner endgültigen Entscheidung zu machen, indem ich die Simulation zum Zeichnen von Linien zwischen der Delaunay-Triangulation zufälliger Punkte einrichtete.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b3/09f/a33/3b309fa331b59c059e4b722d4e4c7c10.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simulationslauf abgeschlossen. Es enthält viele überlagerte Pfade, aus denen unscharfe Punkte erhalten werden.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Die letzte Frage war, wie SVG-Kurven in fertige Arbeiten umgewandelt werden können. Aus den Experimenten wusste ich, dass ich die Pfade irgendwie sortieren wollte, um Pfade mit einer schönen Form hervorzuheben. Der Durchlauf der fertigen Simulation dauerte jedoch ein bis zwei Stunden, weshalb es unpraktisch war, die Variablen bei jedem Durchlauf des Experiments zu ändern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe beschlossen, ein </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zweites</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verarbeitungsdiagramm </font><font style="vertical-align: inherit;">zu schreiben </font><font style="vertical-align: inherit;">, das die Simulationsausgabe in SVG lädt und dann die benötigten visuellen Effekte anwendet. Außerdem wollte ich das Nachbearbeitungsskript interaktiv gestalten, damit ich mit verschiedenen Gewichten und Farben von Linien sowie Sortierschwellen experimentieren kann.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe verschiedene Methoden ausprobiert, um die Pfade zu bewerten, die im Vordergrund und im Hintergrund stehen sollten. Es wurden verschiedene Faktoren berechnet: die Anzahl der Selbstschnittpunkte der Linie, die Anzahl der Schnittpunkte durch die Linie ihrer Steigungslinie und die Wahrscheinlichkeit, dass die Linie der durch die beiden vorherigen Punkte vorhergesagten Steigung folgt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe das Nachbearbeitungsskript für Experimente mit unterschiedlichen Gewichten und Werten dieser Schätzungen verwendet, bis ich das gewünschte Aussehen erhalten habe.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ac/8a0/5e7/6ac8a05e7e250a030461dab605e0770f.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwellenwerteinstellung für Vorder- und Hintergrundlinien.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Zu diesem Zeitpunkt hat das Speichern des Bildes beim Ändern jeder Variablen sehr geholfen. Als ich mich dem Bild näherte, das ich brauchte, war es viel einfacher, einige kleinere Variationen zu vergleichen, als mehrere Faktoren gleichzeitig zu ändern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach einer langen Einrichtung und kleinen Änderungen habe ich aus meiner Simulation das folgende Bild erstellt:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/781/a92/940/781a92940d65d658abfd788b7e0a27db.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich zoomte auf den Bereich, der mir am interessantesten erschien, und beschnitt ihn, um ein gutes Gleichgewicht zwischen leerem und gefülltem Raum herzustellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der letzte Schritt war die Wahl, wie dieses Bild in ein physisches Objekt verwandelt werden soll. Ich habe sie digital als 40 × 50 cm großes Poster gedruckt und versucht (erfolglos), den Bildschirm auf Farbpapier zu drucken. Ein digital gedrucktes Poster sieht gut aus, aber in Zukunft möchte ich das Bild als Teil des Bildes kopieren. Ich finde komplexe Zeichnungen meditativ und denke, dass ich interessante Effekte erzielen kann, indem ich sie manuell zeichne.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für dieses Projekt wurde viel mehr Zeit aufgewendet als erwartet, und es stellte sich als komplizierter heraus, als es am Anfang schien. </font><font style="vertical-align: inherit;">Dies ist jedoch eine großartige Möglichkeit, mit allen Arten von Rechengeometrie und algorithmischen Problemen zu experimentieren. </font><font style="vertical-align: inherit;">Ich finde es ziemlich ironisch, dass ich mehrere tausend Codezeilen für die Arbeit an Komplexität geschrieben habe, aber ich freue mich, dass es cool aussieht und für sich selbst spricht.</font></font></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de487088/index.html">Debugging von GSM-Skalen auf Arduino</a></li>
<li><a href="../de487090/index.html">Eine neue Stufe der Windows-Optimierung</a></li>
<li><a href="../de487092/index.html">Modellierung von Geschäftsprozessen als Teil eines Projekts zur Implementierung eines ERP-Systems</a></li>
<li><a href="../de487094/index.html">Wiederaufbereitungsereignisse von Kafka erhalten</a></li>
<li><a href="../de487096/index.html">Schnipsel. So vereinfachen Sie die Arbeit mit der Dokumentation</a></li>
<li><a href="../de487100/index.html">Unveränderliche Datenstrukturen auf dem neuesten Stand der Technik</a></li>
<li><a href="../de487106/index.html">RunUO-Prüfung des PVS-Studio-Analysators</a></li>
<li><a href="../de487108/index.html">Mobiles Spielerprofil: MyTracker Research</a></li>
<li><a href="../de487110/index.html">Slurm SRE. Ein komplettes Experiment mit Experten von Booking.com und Google.com</a></li>
<li><a href="../de487112/index.html">Rand des Wahnsinns: Der Grundkreis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>