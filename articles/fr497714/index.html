<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📲 🤛 🐏 Comment protéger les processus et les extensions du noyau sur macOS 👆🏽 🍽️ 🤙🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Aujourd'hui, je voudrais parler de la façon dont vous pouvez protéger les processus contre les intrus dans macOS. Par exemple, il est u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Comment protéger les processus et les extensions du noyau sur macOS</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/497714/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour, Habr! </font><font style="vertical-align: inherit;">Aujourd'hui, je voudrais parler de la façon dont vous pouvez protéger les processus contre les intrus dans macOS. </font><font style="vertical-align: inherit;">Par exemple, il est utile pour un antivirus ou un système de sauvegarde, surtout à la lumière du fait que sous macOS, il existe plusieurs façons de «tuer» le processus. </font><font style="vertical-align: inherit;">Lisez à ce sujet et sur les méthodes de protection sous un chat.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/403/e5f/065/403e5f065b7426d384f3c71e8cb3c8a5.jpg" alt="image"></a><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La manière classique de tuer un processus</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La manière bien connue de «tuer» un processus consiste à envoyer un signal concernant un processus SIGKILL. </font><font style="vertical-align: inherit;">Grâce à bash, vous pouvez appeler le standard «kill -SIGKILL PID» ou «pkill -9 NAME» pour tuer. </font><font style="vertical-align: inherit;">La commande kill est connue depuis UNIX et est disponible non seulement sur macOS, mais également sur d'autres systèmes de type UNIX. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme dans les systèmes de type UNIX, macOS vous permet d'intercepter tous les signaux du processus, sauf deux - SIGKILL et SIGSTOP. </font><font style="vertical-align: inherit;">Dans cet article, le signal SIGKILL sera principalement considéré comme un signal provoquant la mort d'un processus.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spécificités MacOS</font></font><br>
</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur macOS, l'appel système kill dans le noyau XNU appelle la fonction psignal (SIGKILL, ...). Essayons de voir quelles autres actions utilisateur dans l'espace utilisateur peuvent appeler la fonction psignal. Nous éliminons les appels à la fonction psignal dans les mécanismes internes du noyau (bien qu'ils puissent être non triviaux, nous les laisserons pour un autre article :) - vérification de signature, erreurs de mémoire, traitement de sortie / arrêt, violation de la protection des fichiers, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous commençons la vue d'ensemble avec la fonction et l'appel système correspondant </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terminate_with_payload</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">On peut voir qu'en plus de l'appel de mise à mort classique, il existe une approche alternative spécifique au système d'exploitation macOS et qui ne se trouve pas dans BSD. </font><font style="vertical-align: inherit;">Les principes de fonctionnement des deux appels système sont également proches. </font><font style="vertical-align: inherit;">Ce sont des appels directs à la fonction de noyau psignal. </font><font style="vertical-align: inherit;">Notez également qu'avant de tuer un processus, une vérification de «cansignal» est effectuée - si le processus peut envoyer un signal à un autre processus, le système ne permet à aucune application de tuer des processus système par exemple.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>
<span class="hljs-title">terminate_with_payload_internal</span><span class="hljs-params">(struct proc *cur_proc, <span class="hljs-keyword">int</span> target_pid, <span class="hljs-keyword">uint32_t</span> reason_namespace,
				<span class="hljs-keyword">uint64_t</span> reason_code, <span class="hljs-keyword">user_addr_t</span> payload, <span class="hljs-keyword">uint32_t</span> payload_size,
				<span class="hljs-keyword">user_addr_t</span> reason_string, <span class="hljs-keyword">uint64_t</span> reason_flags)</span>
</span>{<font></font>
...<font></font>
	target_proc = proc_find(target_pid);<font></font>
...<font></font>
	<span class="hljs-keyword">if</span> (!cansignal(cur_proc, cur_cred, target_proc, SIGKILL)) {<font></font>
		proc_rele(target_proc);<font></font>
		<span class="hljs-keyword">return</span> EPERM;<font></font>
	}<font></font>
...<font></font>
	<span class="hljs-keyword">if</span> (target_pid == cur_proc-&gt;p_pid) {
		<span class="hljs-comment">/*
		 * psignal_thread_with_reason() will pend a SIGKILL on the specified thread or
		 * return if the thread and/or task are already terminating. Either way, the
		 * current thread won't return to userspace.
		 */</span><font></font>
		psignal_thread_with_reason(target_proc, current_thread(), SIGKILL, signal_reason);<font></font>
	} <span class="hljs-keyword">else</span> {<font></font>
		psignal_with_reason(target_proc, SIGKILL, signal_reason);<font></font>
	}<font></font>
...<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">launchd</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La méthode standard pour créer des démons au démarrage du système et contrôler leur durée de vie est launchd. </font><font style="vertical-align: inherit;">J'attirerai l'attention sur le fait que le code source est pour l'ancienne version de launchctl avant macOS 10.10, des exemples de code sont donnés à titre d'illustration. </font><font style="vertical-align: inherit;">Le launchctl moderne envoie des signaux launchd via XPC, la logique de launchctl lui est transférée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons comment la demande est arrêtée. </font><font style="vertical-align: inherit;">Avant d'envoyer un signal SIGTERM, ils essaient d'arrêter l'application à l'aide de l'appel système proc_terminate.</font></font><br>
<br>
<pre><code class="cpp hljs">&lt;launchctl src/core.c&gt;<font></font>
...<font></font>
	error = proc_terminate(j-&gt;p, &amp;sig);<font></font>
	<span class="hljs-keyword">if</span> (error) {<font></font>
		job_log(j, LOG_ERR | LOG_CONSOLE, <span class="hljs-string">"Could not terminate job: %d: %s"</span>, error, strerror(error));<font></font>
		job_log(j, LOG_NOTICE | LOG_CONSOLE, <span class="hljs-string">"Using fallback option to terminate job..."</span>);<font></font>
		error = kill2(j-&gt;p, SIGTERM);<font></font>
		<span class="hljs-keyword">if</span> (error) {<font></font>
			job_log(j, LOG_ERR, <span class="hljs-string">"Could not signal job: %d: %s"</span>, error, strerror(error));<font></font>
		} <font></font>
...<font></font>
&lt;&gt;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sous le capot, proc_terminate, malgré son nom, peut envoyer non seulement du psignal avec SIGTERM, mais aussi SIGKILL.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Élimination indirecte - limite de ressources</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un cas plus intéressant peut être vu dans un autre appel système </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">process_policy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . L'utilisation standard de cet appel système est des limites de ressources d'application, par exemple, pour l'indexeur, il y a une limite de temps processeur et de quota de mémoire afin que le système ne ralentisse pas de manière significative en raison des actions de mise en cache de fichiers. Si l'application a atteint la limite de ressources, comme le montre la fonction proc_apply_resource_actions, le signal SIGKILL est envoyé au processus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien que cet appel système puisse potentiellement tuer un processus, le système n'a pas vérifié correctement les droits du processus à l'origine de l'appel système. En fait, une vérification </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existait</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais il suffit d'utiliser l'indicateur alternatif PROC_POLICY_ACTION_SET pour contourner cette condition.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, si vous «limitez» le quota d'utilisation du processeur par l'application (par exemple, n'autorisez que 1 ns à être exécuté), vous pouvez alors tuer n'importe quel processus du système. </font><font style="vertical-align: inherit;">Ainsi, le malware peut tuer n'importe quel processus sur le système, y compris le processus antivirus. </font><font style="vertical-align: inherit;">L'effet qui se produit quand un processus est tué avec pid 1 (launchctl) - panique du noyau en essayant de traiter un signal SIGKILL est également intéressant :)</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/91e/fea/a49/91efeaa490ffd57580d2e5f4a59b4988.png" alt="image"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment résoudre le problème?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La façon la plus simple d'empêcher un processus d'être tué est de remplacer le pointeur de fonction dans la table d'appels système. Malheureusement, cette méthode n'est pas triviale pour de nombreuses raisons </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
. Premièrement, le symbole qui est responsable de la position du sysent dans la mémoire n'est pas seulement un symbole privé du noyau XNU, mais ne peut pas non plus être trouvé dans les symboles du noyau. Vous devrez utiliser des méthodes de recherche heuristiques, par exemple, le démontage dynamique d'une fonction et rechercher un pointeur dans celle-ci. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deuxièmement, la structure des entrées du tableau dépend des drapeaux avec lesquels le noyau a été construit. Si le drapeau CONFIG_REQUIRES_U32_MUNGING est déclaré, alors la taille de la structure sera modifiée - un champ supplémentaire </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">sy_arg_munge32</font></a><font style="vertical-align: inherit;"> est ajouté</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il est nécessaire d'effectuer une vérification supplémentaire sur l'indicateur avec lequel le noyau a été compilé, en option, comparer les pointeurs aux fonctions avec des fonctions connues.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysent</span> {</span>         <span class="hljs-comment">/* system call table */</span>
        <span class="hljs-keyword">sy_call_t</span>       *sy_call;       <span class="hljs-comment">/* implementing function */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> CONFIG_REQUIRES_U32_MUNGING || (__arm__ &amp;&amp; (__BIGGEST_ALIGNMENT__ &gt; 4))</span>
        <span class="hljs-keyword">sy_munge_t</span>      *sy_arg_munge32; <span class="hljs-comment">/* system call arguments munger for 32-bit process */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
        <span class="hljs-keyword">int32_t</span>         sy_return_type; <span class="hljs-comment">/* system call return types */</span>
        <span class="hljs-keyword">int16_t</span>         sy_narg;        <span class="hljs-comment">/* number of args */</span>
        <span class="hljs-keyword">uint16_t</span>        sy_arg_bytes;   <span class="hljs-comment">/* Total size of arguments in bytes for
                                         * 32-bit system calls
                                         */</span><font></font>
};<font></font>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heureusement, dans les versions modernes de macOS, Apple fournit une nouvelle API pour travailler avec les processus. </font><font style="vertical-align: inherit;">L'API Endpoint Security permet aux clients d'autoriser de nombreuses demandes à d'autres processus. </font><font style="vertical-align: inherit;">Ainsi, vous pouvez bloquer tous les signaux aux processus, y compris le signal SIGKILL en utilisant l'API susmentionnée.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bsm/libbsm.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;EndpointSecurity/EndpointSecurity.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>{
    <span class="hljs-keyword">es_client_t</span>* cli = <span class="hljs-literal">nullptr</span>;<font></font>
    {<font></font>
        <span class="hljs-keyword">auto</span> res = es_new_client(&amp;cli, ^(<span class="hljs-keyword">es_client_t</span> * client, <span class="hljs-keyword">const</span> <span class="hljs-keyword">es_message_t</span> * message) {
            <span class="hljs-keyword">switch</span> (message-&gt;event_type) {
                <span class="hljs-keyword">case</span> ES_EVENT_TYPE_AUTH_SIGNAL:<font></font>
                {<font></font>
                    <span class="hljs-keyword">auto</span>&amp; msg = message-&gt;event.signal;
                    <span class="hljs-keyword">auto</span> target = msg.target;
                    <span class="hljs-keyword">auto</span>&amp; token = target-&gt;audit_token;
                    <span class="hljs-keyword">auto</span> pid = audit_token_to_pid(token);
                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"signal '%d' sent to pid '%d'\n"</span>, msg.sig, pid);<font></font>
                    es_respond_auth_result(client, message, pid == getpid() ? ES_AUTH_RESULT_DENY : ES_AUTH_RESULT_ALLOW, <span class="hljs-literal">false</span>);<font></font>
                }<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        });<font></font>
    }<font></font>
<font></font>
    {<font></font>
        <span class="hljs-keyword">es_event_type_t</span> evs[] = { ES_EVENT_TYPE_AUTH_SIGNAL };<font></font>
        es_subscribe(cli, evs, <span class="hljs-keyword">sizeof</span>(evs) / <span class="hljs-keyword">sizeof</span>(*evs));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, getpid());<font></font>
    sleep(<span class="hljs-number">60</span>); <span class="hljs-comment">// could be replaced with other waiting primitive</span><font></font>
<font></font>
    es_unsubscribe_all(cli);<font></font>
    es_delete_client(cli);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De même, vous pouvez enregistrer la politique MAC dans le noyau, qui fournit une méthode de protection du signal (politique proc_check_signal), mais l'API n'est pas officiellement prise en charge.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protection des extensions du noyau</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus de protéger les processus dans le système, la protection de l'extension du noyau elle-même (kext) est également nécessaire. macOS fournit un cadre permettant aux développeurs de développer facilement des pilotes de périphérique IOKit. En plus de fournir des outils pour travailler avec des périphériques, IOKit fournit des méthodes d'empilement de pilotes utilisant des instances de classes C ++. Une application dans l'espace utilisateur pourra «trouver» une instance enregistrée de la classe pour établir une connexion noyau-espace utilisateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour détecter le nombre d'instances de classe dans le système, l'utilitaire ioclasscount existe.</font></font><br>
<br>
<pre><code class="cpp hljs">my_kext_ioservice = <span class="hljs-number">1</span>
my_kext_iouserclient = <span class="hljs-number">1</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toute extension de noyau qui souhaite s'inscrire sur la pile du pilote doit déclarer une classe héritée d'IOService, par exemple, my_kext_ioservice dans ce cas. La connexion des applications utilisateur créera une nouvelle instance de la classe qui hérite de IOUserClient, dans l'exemple my_kext_iouserclient. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque vous essayez de décharger le pilote du système (commande kextunload), la fonction virtuelle «bool terminate (options IOOptionBits)» est appelée. </font><font style="vertical-align: inherit;">Il suffit de retourner false lors de l'appel à la fonction terminate lorsque vous essayez de décharger pour désactiver kextunload.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Kext::terminate</span><span class="hljs-params">(IOOptionBits options)</span>
</span>{<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!IsUnloadAllowed)<font></font>
  {<font></font>
    <span class="hljs-comment">// Unload is not allowed, returning false</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> super::<span class="hljs-built_in">terminate</span>(options);<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'indicateur IsUnloadAllowed peut être défini par IOUserClient au démarrage. </font><font style="vertical-align: inherit;">Lorsque le chargement est limité, la commande kextunload renvoie la sortie suivante:</font></font><br>
<br>
<pre><code class="cpp hljs">admin@admins-Mac drivermanager % sudo kextunload ./test.kext<font></font>
Password:<font></font>
(kernel) Can<span class="hljs-number">'</span>t remove kext my.kext.test; services failed to <span class="hljs-built_in">terminate</span> - <span class="hljs-number">0xe00002c7</span>.<font></font>
Failed to unload my.kext.test - (iokit/common) unsupported function.<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une protection similaire doit être effectuée pour IOUserClient. </font><font style="vertical-align: inherit;">Les instances de classe peuvent être déchargées à l'aide de la fonction d'espace utilisateur IOKitLib «IOCatalogueTerminate (mach_port_t, indicateur uint32_t, io_name_t description);». </font><font style="vertical-align: inherit;">Vous pouvez retourner false lors d'un appel à la commande «terminate» jusqu'à ce que l'espace utilisateur de l'application meure, c'est-à-dire qu'il n'y ait aucun appel à la fonction clientDied.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protection des fichiers</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour protéger les fichiers, il suffit d'utiliser l'API Kauth, qui vous permet de restreindre l'accès aux fichiers. Apple fournit aux développeurs des notifications sur divers événements dans la portée, les opérations KAUTH_VNODE_DELETE, KAUTH_VNODE_WRITE_DATA et KAUTH_VNODE_DELETE_CHILD sont importantes pour nous. Restreindre l'accès aux fichiers est plus facile en cours de route - nous utilisons l'API «vn_getpath» pour obtenir le chemin d'accès au fichier et comparer le préfixe du chemin d'accès. Notez que pour optimiser le renommage des chemins des dossiers contenant des fichiers, le système n'autorise pas l'accès à chaque fichier, mais uniquement au dossier lui-même, qui a été renommé. Il est nécessaire de comparer le chemin parent et de restreindre KAUTH_VNODE_DELETE pour cela.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6e2/ab5/2fb/6e2ab52fb8c17ea8adfe8b63bcf8f611.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'inconvénient de cette approche peut être de faibles performances avec un nombre croissant de préfixes. Pour que la comparaison ne soit pas égale à O (préfixe * longueur), où préfixe est le nombre de préfixes, longueur est la longueur de la chaîne, vous pouvez utiliser une machine à états finis déterministe (DFA) construite par des préfixes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérez un moyen de créer un DFA pour un ensemble de préfixes donné. Nous initialisons les curseurs au début de chaque préfixe. Si tous les curseurs pointent vers le même caractère, alors nous augmentons chaque curseur d'un caractère et nous rappelons que la longueur de la même ligne est plus d'un. S'il y a deux curseurs avec des symboles différents sous eux, nous divisons les curseurs en groupes par le symbole vers lequel ils pointent et répétons l'algorithme pour chaque groupe.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le premier cas (tous les caractères sous les curseurs sont les mêmes), nous obtenons l'état DFA, qui n'a qu'une seule transition sur la même ligne. </font><font style="vertical-align: inherit;">Dans le second cas, nous obtenons une table de transition de taille 256 (nombre de caractères et nombre maximum de groupes) dans les états suivants obtenus en appelant récursivement la fonction. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenons un exemple. </font><font style="vertical-align: inherit;">Pour un ensemble de préfixes ("/ foo / bar / tmp /", "/ var / db / foo /", "/ foo / bar / aba /", "foo / bar / aac /"), vous pouvez obtenir le DFA suivant. </font><font style="vertical-align: inherit;">La figure montre uniquement les transitions menant à d'autres états, les autres transitions ne seront pas définitives. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/190/d0f/5ec/190d0f5ec1fdd8c03df23387d83db44a.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors du passage dans les États de la DKA, il peut y avoir 3 cas.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'état final a été atteint - le chemin est protégé, nous restreignons les opérations KAUTH_VNODE_DELETE, KAUTH_VNODE_WRITE_DATA et KAUTH_VNODE_DELETE_CHILD</font></font></li>
<li>    ,   “” (  -) —   ,   KAUTH_VNODE_DELETE. ,   vnode  ,     ‘/’,         “/foor/bar/t”,  .</li>
<li>    ,   .       ,   .</li>
</ol><br>
<h3></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le but des solutions de sécurité développées est d'augmenter le niveau de sécurité de l'utilisateur et de ses données. D'une part, cet objectif est assuré par le développement du produit logiciel Acronis qui couvre les vulnérabilités où le système d'exploitation lui-même est «faible». D'un autre côté, nous ne devons pas négliger l'amélioration de ces aspects de sécurité qui peuvent être améliorés du côté du système d'exploitation, d'autant plus que la fermeture de ces vulnérabilités augmente notre propre stabilité en tant que produit. La vulnérabilité a été signalée par l'équipe de sécurité des produits Apple et a été corrigée dans macOS 10.14.5 (https://support.apple.com/en-gb/HT210119).</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e27/604/c24/e27604c248d5405276235cf613319754.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout cela ne peut être fait que si votre utilitaire a été officiellement installé dans le noyau. </font><font style="vertical-align: inherit;">Autrement dit, il n'y a pas de telles lacunes pour les logiciels externes et indésirables. </font><font style="vertical-align: inherit;">Cependant, comme vous pouvez le voir, même pour protéger des programmes légitimes tels que des antivirus et des systèmes de sauvegarde, vous devez travailler dur. </font><font style="vertical-align: inherit;">Mais maintenant, les nouveaux produits Acronis pour macOS bénéficieront d'une protection supplémentaire contre le déchargement du système.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr497688/index.html">Comment fonctionne l'école du soir de Kubernetes</a></li>
<li><a href="../fr497696/index.html">Comment le rançongiciel Ryuk qui attaque les entreprises</a></li>
<li><a href="../fr497700/index.html">Mitaps en ligne hebdomadaires sur le support et DevOps, la sécurité et les robots à partir du 17 avril</a></li>
<li><a href="../fr497702/index.html">Cinq tendances du stockage de données auxquelles vous devriez faire attention en 2020</a></li>
<li><a href="../fr497708/index.html">Nous vous invitons à une série de webinaires Fujitsu en avril et mai</a></li>
<li><a href="../fr497724/index.html">Préparation d'un serveur pour la publication d'une application Web en Python</a></li>
<li><a href="../fr497726/index.html">Mise à l'échelle des tests Android à Odnoklassniki</a></li>
<li><a href="../fr497728/index.html">Les dangers de «brûler» les puces</a></li>
<li><a href="../fr497730/index.html">BDD pratique: SpecFlow + TFS</a></li>
<li><a href="../fr497736/index.html">Examen de 10 nouveaux moteurs à combustion interne</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>