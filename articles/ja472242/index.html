<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💔 👨‍🔬 🙌🏻 Tokioスケジューラーを10倍高速化しました ⏪ 🙎 🎩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rustの非同期ランタイム環境であるTokioの次のメジャーバージョンを準備中です。 10月13日、ブランチにマージするために、完全に書き換えられたタスクスケジューラを含むプールリクエストが発行されました。その結果、パフォーマンスが大幅に向上し、待ち時間が短縮されます。一部のテストでは10倍の加速が...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Tokioスケジューラーを10倍高速化しました</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472242/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rustの非同期ランタイム環境であるTokioの次のメジャーバージョンを準備中です。 10月13日、ブランチにマージするために</font><font style="vertical-align: inherit;">、完全に書き換えられたタスクスケジューラを</font><font style="vertical-align: inherit;">含む</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プールリクエスト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">発行されました</font><font style="vertical-align: inherit;">。その結果、パフォーマンスが大幅に向上し、待ち時間が短縮されます。一部のテストでは10倍の加速が記録されました。いつものように、模擬テストは実際の実際の利点を反映していません。そのため、スケジューラーの変更が</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハイパー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トニック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの実際のタスクにどのように影響するかも確認しました</font><font style="vertical-align: inherit;">（ネタバレ：結果はすばらしい）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいプランナーの準備をするために、テーマ別のリソースを探すことに時間を費やしました。</font><font style="vertical-align: inherit;">実際の実装を除いて、特別なものは何も見つかりませんでした。</font><font style="vertical-align: inherit;">また、既存の実装のソースコードをナビゲートするのが難しいこともわかりました。</font><font style="vertical-align: inherit;">これを修正するために、Tokio shedulerをできるだけきれいに書くようにしました。</font><font style="vertical-align: inherit;">スケジューラーの実装に関するこの詳細な記事が、同じ立場にあり、このトピックに関する情報の検索に失敗した人に役立つことを願っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は、ジョブキャプチャポリシーを含む、デザインの高レベルのレビューから始まります。</font><font style="vertical-align: inherit;">次に、新しいTokioスケジューラーの特定の最適化の詳細について説明します。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考慮された最適化：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいstd ::将来のタスクシステム</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適なキューアルゴリズムの選択</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージテンプレートの合理化</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スロットルキャプチャ</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッド間の同期を減らす</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリ割り当てを減らす</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アトミックリンクのカウントを減らす</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、主なテーマは「削減」です。</font><font style="vertical-align: inherit;">結局、最速のコードはその欠如です！</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">新しいスケジューラのテスト</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
についても説明し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">ロックなしで正しい並列コードを書くことは非常に困難です。</font><font style="vertical-align: inherit;">特にバグがメモリのセキュリティに関連している場合は、グリッチを使ってゆっくりとではなく正しく実行することをお勧めします。</font><font style="vertical-align: inherit;">ただし、最良のオプションはエラーなしで迅速に機能するはずなので</font><font style="vertical-align: inherit;">、同時実行テストツールである</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">loomを</font></a><font style="vertical-align: inherit;">作成しました。</font><font style="vertical-align: inherit;">
トピックに入る前に、私は感謝したいと思います：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<ul>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@withoutboats</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><code>async / await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Rustの</font><font style="vertical-align: inherit;">機能</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">取り組んだ人たち</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">あなたは素晴らしい仕事をしました。</font><font style="vertical-align: inherit;">これはキラー機能です。</font></font><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@cramertj</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および他の開発者</font></font><code>std::task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、以前よりも大幅に改善されています。</font><font style="vertical-align: inherit;">そして素晴らしいコード。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">企業</font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浮力</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、作成者</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンカード</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そしてさらに重要なことに、私の雇用者。</font><font style="vertical-align: inherit;">この仕事に多くの時間を割かせてくれてありがとう。</font><font style="vertical-align: inherit;">誰かがサービスメッシュに興味がある場合は、Linkerdをご覧ください。</font><font style="vertical-align: inherit;">間もなく、この記事で説明するすべてのメリットが含まれるようになります。</font></font><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そのような優れたプランナーの実装に</font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">行き</font></a></b><font style="vertical-align: inherit;">ます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一杯のコーヒーを取り、座ってください。</font><font style="vertical-align: inherit;">これは長い記事になります。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プランナーはどのように機能しますか？</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Shedulerの仕事は仕事を計画することです。アプリケーションは作業単位に分割されており、これを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスク</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼びます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">外部リソースにロックされている場合、</font><font style="vertical-align: inherit;">タスクは</font><font style="vertical-align: inherit;">実行中に移動できて満たされなくなったとき、または</font><i><font style="vertical-align: inherit;">待機</font></i><font style="vertical-align: inherit;">モード</font><font style="vertical-align: inherit;">（アイドル）で</font><font style="vertical-align: inherit;">実行</font><font style="vertical-align: inherit;">さ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れた</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（実行可能）</font><font style="vertical-align: inherit;">と見なされます</font><font style="vertical-align: inherit;">。タスクは、任意の数のタスクを同時に実行できるという意味で独立しています。スケジューラは、タスクがスタンバイモードに戻るまで、実行状態でタスクを実行する責任があります。タスクの実行とは、タスクにプロセッサ時間を割り当てること、つまりグローバルリソースを意味します。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、ユーザースペーススケジューラについて説明します。つまり、オペレーティングシステムスレッド（カーネルレベルのShedulerによって制御されます）の上で作業します。 Tokioスケジューラは、Rustフューチャーを実行します。これは、「非同期のグリーンスレッド」と考えることができます。これは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M：N混合ストリーミング</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターン</font><font style="vertical-align: inherit;">であり、多くのユーザーインターフェイスタスクがオペレーティングシステムの複数のスレッドに多重化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
shedulerをシミュレートする方法は数多くあり、それぞれに長所と短所があります。最も基本的なレベルでは、スケジューラは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行キュー</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">それを引き離す</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセッサ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">としてモデル化できます</font><font style="vertical-align: inherit;">。プロセッサは、スレッドで実行されるコードの一部です。疑似コードでは、次のことを行います。</font></font><br>
<br>
<pre><code class="plaintext hljs">while let Some(task) = self.queue.pop() {<font></font>
    task.run();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクが実行可能になると、タスクは実行キューに挿入されます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/ff6/1f4/18f/ff61f418f73f08c62b5e9eaeacaeb8ed.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リソース、タスク、およびプロセッサーが同じスレッド上に存在するシステムを設計することはできますが、Tokioは複数のスレッドを使用することを好みます。</font><font style="vertical-align: inherit;">私たちは、コンピュータに多くのプロセッサが搭載されている世界に住んでいます。</font><font style="vertical-align: inherit;">シングルスレッドのスケジューラを開発すると、鉄のロードが不十分になります。</font><font style="vertical-align: inherit;">すべてのCPUを使用します。</font><font style="vertical-align: inherit;">これにはいくつかの方法があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのグローバル実行キュー、多数のプロセッサー。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くのプロセッサがあり、それぞれに独自の実行キューがあります。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1ターン、多くのプロセッサ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このモデルには、1つのグローバル実行キューがあります。タスクが完了すると、キューの最後に配置されます。複数のプロセッサがあり、それぞれが別のスレッドにあります。各プロセッサは、キューの先頭からタスクを取得するか、使用可能なタスクがない場合はスレッドをブロックします。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/85c/8d0/23d/85c8d023dfeba249bba01234e0e8783a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行キューは、多くの製造元と消費者によってサポートされている必要があります。通常、</font><font style="vertical-align: inherit;">煩雑</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">な</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リストが使用されます。各タスクの構造には、キュー内の次のタスクへのポインターが含まれます（リンクされたリストでタスクをラップするのではなく）。したがって、プッシュ操作とポップ操作のメモリ割り当てを回避できます。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ロックせずにプッシュ操作</font></a><font style="vertical-align: inherit;">ができます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ただし、コンシューマを調整するために、ポップ操作にはミューテックスが必要です（ブロッキングなしでマルチユーザーキューを実装することは技術的に可能です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、実際には、ロックに対する適切な保護のためのオーバーヘッドは、単にmutexを使用する以上のものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは、いくつかの利点があるため、汎用スレッドプールによく使用されます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスクはかなり計画されています。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比較的シンプルな実装。</font><font style="vertical-align: inherit;">多かれ少なかれ標準的なキューは、上記のプロセッササイクルとインターフェイスします。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
公正な（衡平な）計画についての簡単な説明。これは、タスクが正直に実行されることを意味します。先に来た人は誰でも、先に去った人です。汎用プランナは公平を期しますが、fork-joinによる並列化などの例外があり、個々のサブタスクの正義ではなく結果を計算する速度が重要な要素になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このモデルには欠点があります。</font><font style="vertical-align: inherit;">すべてのプロセッサは、キューの先頭からタスクを申請します。</font><font style="vertical-align: inherit;">汎用スレッドの場合、これは通常問題ではありません。</font><font style="vertical-align: inherit;">タスクを完了する時間は、キューからタスクを取得する時間をはるかに超えています。</font><font style="vertical-align: inherit;">タスクが長期間実行されると、キューでの競争が減少します。</font><font style="vertical-align: inherit;">ただし、非同期のRustタスクは非常に迅速に完了することが期待されています。</font><font style="vertical-align: inherit;">この場合、キューでの戦闘のオーバーヘッドが大幅に増加します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並行性と機械的同情</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最大のパフォーマンスを実現するには、ハードウェア機能を最大限に活用する必要があります。ソフトウェアの機械的同情という用語は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Martin Thompson</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって最初に使用されました</font><font style="vertical-align: inherit;">（そのブログはもはや更新されていませんが、それでも非常に有益です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最新の機器における並列処理の実装に関する詳細な説明は、この記事の範囲を超えています。一般的に言って、鉄は加速によるのではなく、より多くのCPUコアの導入により（私のラップトップでさえ6つある！）、パフォーマンスを向上させます。各コアは、小さな時間間隔で大量の計算を実行できます。キャッシュやメモリアクセスなどのアクティビティには、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">さらに長い時間が</font></a><font style="vertical-align: inherit;">かかり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPUでの実行時間に関連します。したがって、アプリケーションを高速化するには、各メモリアクセスのCPU命令の数を最大化する必要があります。コンパイラーは多くのことを助けますが、アラインメントやメモリーアクセスのパターンなどについてはまだ考えなければなりません。</font><font style="vertical-align: inherit;">複数のスレッドが同じキャッシュラインを同時に変更する（同時ミューテーション）か、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">一貫した一貫性</font></a><font style="vertical-align: inherit;">が必要になる</font><b><font style="vertical-align: inherit;">まで</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
、個別のスレッドは個別に単一の独立したスレッドと非常によく似</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">てい</font></a><font style="vertical-align: inherit;">ます。この場合、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">CPUキャッシュコヒーレンスプロトコルが</font></a><font style="vertical-align: inherit;">アクティブになり</font><font style="vertical-align: inherit;">ます。各CPUのキャッシュの関連性を保証します。</font><font style="vertical-align: inherit;">
結論は明らかです。遅いため、スレッド間の同期はできるだけ避けてください。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それぞれが独自の実行キューを持つ多くのプロセッサ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のモデルは、いくつかのシングルスレッドスケジューラです。</font><font style="vertical-align: inherit;">各プロセッサは独自の実行キューを受け取り、タスクは特定のプロセッサに固定されています。</font><font style="vertical-align: inherit;">これにより、同期の問題が完全に回避されます。</font><font style="vertical-align: inherit;">Rustタスクモデルは、任意のスレッドからタスクをキューに入れる機能を必要とするため、タスクをスケジューラに入力するためのスレッドセーフな方法がまだあるはずです。</font><font style="vertical-align: inherit;">各プロセッサの実行キューは、スレッドセーフプッシュ操作（MPSC）をサポートするか、各プロセッサには、</font><font style="vertical-align: inherit;">非同期とスレッドセーフの</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行キューがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c6d/a3c/35e/c6da3c35e7f6fb28b63fdb3ff6417882.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この戦略は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Seastar</font></a><font style="vertical-align: inherit;">によって使用されます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ほぼ完全に同期を回避するため、この戦略は非常に高速です。</font><font style="vertical-align: inherit;">しかし、彼女はすべての問題を解決するわけではありません。</font><font style="vertical-align: inherit;">ワークロードが完全に均一でない場合、一部のプロセッサに負荷がかかっている一方で、他のプロセッサはアイドルになっているため、リソースが最適に使用されません。</font><font style="vertical-align: inherit;">これは、タスクが特定のプロセッサに固定されているために発生します。</font><font style="vertical-align: inherit;">タスクのグループが1つのプロセッサのパッケージで計画されている場合、他のタスクがアイドル状態であっても、ピーク負荷を単独で実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの「実際の」ワークロードは均一ではありません。</font><font style="vertical-align: inherit;">したがって、汎用の計画担当者は通常、このモデルを避けます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジョブキャプチャスケジューラ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ワークスチールスケジューラを備えたスケジューラは、分割されたスケジューラモデルに基づいており、ハードウェアリソースの不完全なロードの問題を解決します。各プロセッサは、独自の実行キューをサポートしています。実行されるようになるタスクは、現在のプロセッサの実行キューに置かれ、処理されます。しかし、プロセッサがアイドル状態の場合、姉妹プロセッサのキューをチェックして、そこから何かを取得しようとします。プロセッサは、ピアツーピアの実行キューから作業を見つけられない場合にのみ、スリープモードになります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/561/9a9/02c/5619a902c1d95252d20ac7db1273e57f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルレベルでは、これは「両方の長所」のアプローチです。負荷がかかると、プロセッサは独立して動作し、オーバーヘッドの同期を回避します。プロセッサー間の負荷が不均一に分散されている場合、スケジューラーはそれを再分散できます。これが、このようなスケジューラーが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erlang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">およびその他の言語で</font><font style="vertical-align: inherit;">使用される理由</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
欠点は、このアプローチがはるかに複雑になることです。キューアルゴリズムは、ジョブのキャプチャをサポートしている必要があり、かつ円滑な遂行のために</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセッサ間の同期が</font><font style="vertical-align: inherit;">必要です</font><font style="vertical-align: inherit;">。正しく実装されていない場合、キャプチャのオーバーヘッドがゲインより大きくなる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況を考えてみましょう：プロセッサーAは現在タスクを実行中で、実行キューは空です。</font><font style="vertical-align: inherit;">プロセッサBはアイドルです。</font><font style="vertical-align: inherit;">彼はいくつかのタスクをキャプチャしようとしましたが、失敗したため、スリープモードに入ります。</font><font style="vertical-align: inherit;">次に、プロセッサAのタスクから20のタスクが生成されます。</font><font style="vertical-align: inherit;">理想的には、プロセッサBがウェイクアップして、それらのいくつかを取得する必要があります。</font><font style="vertical-align: inherit;">これを行うには、スケジューラに特定のヒューリスティックを実装する必要があります。この場合、プロセッサは、キューに新しいタスクが出現したことをスリープ状態のピアプロセッサに通知します。</font><font style="vertical-align: inherit;">もちろん、これには追加の同期が必要であるため、このような操作は最小限に抑えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最終的に：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期が少ないほど良いです。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジョブキャプチャは、汎用の計画担当者にとって最適なアルゴリズムです。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各プロセッサは他のプロセッサとは独立して動作しますが、作業をキャプチャするにはある程度の同期が必要です。</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tokio 0.1スケジューラ</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2018年3月に、Tokioの最初の作業スケジューラがリリースされました。</font><font style="vertical-align: inherit;">これは間違っていることが判明したいくつかの仮定に基づく最初の試みでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、Tokio 0.1スケジューラは、プロセッサスレッドが一定の時間アイドル状態にある場合は閉じる必要があると提案しました。スケジューラは元々、Rustスレッドプールの「汎用」システムとして作成されました。当時、Tokioランタイムはまだ開発の初期段階でした。次に、モデルはI / OタスクがI / Oセレクターと同じスレッド（epoll、kqueue、iocp ...）で実行されることを想定していました。さらに多くの計算タスクをスレッドプールに送ることができます。このコンテキストでは、アクティブなスレッド数の柔軟な設定が想定されているため、アイドルスレッドを無効にする方が理にかなっています。ただし、ジョブキャプチャを備えたスケジューラでは、モデルは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期タスクの</font><font style="vertical-align: inherit;">実行に切り替わり</font><font style="vertical-align: inherit;">ました。この場合、常に少数のスレッドをアクティブ状態に維持することは理にかなっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、双方向の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クロスビーム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が実装され</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ました</font></a><font style="vertical-align: inherit;">。この実装は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">双方向のChase-Levライン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">基づいており、</font><font style="vertical-align: inherit;">以下に説明する理由により、独立した非同期タスクの計画には適していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第三に、実装が複雑すぎることがわかりました。これは、これが私の最初のタスクスケジューラだったことが原因の1つです。また、ブランチでアトミックを使用するとき、私はあまりにも焦りました。ミューテックスがうまく機能するためです。重要な教訓は、非常に多くの場合、最もよく機能するのはミューテックスであるということです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、初期の実装には多くの小さな欠陥がありました。</font><font style="vertical-align: inherit;">初期の頃、非同期Rustモデルの実装の詳細は大幅に進化しましたが、ライブラリはAPIを常に安定させていました。</font><font style="vertical-align: inherit;">これはいくつかの技術的負債の蓄積につながりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、Tokioは最初のメジャーリリースに近づいています。この借金をすべて支払うだけでなく、長年の開発で得られた経験から学ぶことができます。</font><font style="vertical-align: inherit;">これはエキサイティングな時間です！</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次世代Tokioスケジューラ</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、新しいスケジューラの変更点を詳しく見ていきましょう。</font></font><br>
<br>
<a name="1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいタスクシステム</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、それが何であるかを強調することが重要です</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ではない</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">東京の一部ではなく、効率の向上の観点から非常に重要である：これは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいタスクシステム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では</font></font><code>std</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、もともとによって開発された、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テイラークレイマー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このシステムは、非同期Rustタスクを実行するためにスケジューラーが実装する必要があるフックを提供し、システムは本当に見事に設計および実装されています。前のバージョンよりもはるかに軽量で柔軟性があります。</font><font style="vertical-align: inherit;">リソース</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
の構造</font></font><code>Waker</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行可能であることを示します</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スケジューラキューに配置されるタスク。</font><font style="vertical-align: inherit;">新しいタスクシステムでは、これは2ポインタ構造ですが、以前ははるかに大きくなりました。</font><font style="vertical-align: inherit;">サイズを小さくすること</font></font><code>Waker</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、さまざまな場所で</font><font style="vertical-align: inherit;">値をコピーするオーバーヘッドを最小限に抑えるために重要</font><font style="vertical-align: inherit;">であり、構造内のスペースが少なくて済むため、より重要なデータをキャッシュラインに圧縮できます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vtableの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">設計</font><font style="vertical-align: inherit;">はいくつかの最適化を行いましたが、これについては後で説明します。</font></font><br>
<br>
<a name="2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適なキューアルゴリズムの選択</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行キューはスケジューラの中央にあります。したがって、これは修正する最も重要なコンポーネントです。元のTokioスケジューラは、双方向の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クロスビームキューを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用していまし</font><font style="vertical-align: inherit;">た。単一ソースの実装（プロデューサー）と多くのコンシューマーです。タスクは一方の端に配置され、値は他方から取得されます。ほとんどの場合、スレッドはキューの最後から値を「プッシュ」しますが、他のスレッドが作業をインターセプトして同じ操作を実行することもあります。双方向キューは、配列と、先頭と末尾を追跡する一連のインデックスによってサポートされます。キューがいっぱいになると、キューが導入されてストレージスペースが増加します。新しい、より大きな配列が割り当てられ、値が新しいストレージに移動されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
成長する能力は、複雑さとオーバーヘッドによって達成されます。プッシュ/ポップ操作では、この増加を考慮する必要があります。さらに、元のアレイを解放することは、さらに困難を伴います。ガベージコレクション（GC）言語では、古い配列はスコープ外になり、最終的にはGCがそれをクリアします。ただし、RustはGCなしで出荷されます。これは、私たち自身が配列を解放する責任があることを意味しますが、スレッドは同時にメモリへのアクセスを試みることができます。この問題を解決するために、クロスビームは古くからの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リサイクル戦略を採用しています。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（エポックベースの再生戦略）。多くのリソースは必要ありませんが、メインパス（ホットパス）に重要なオーバーヘッドを追加します。各オペレーションは、クリティカルセクションの入口と出口でアトミックRMW（読み取り-変更-書き込み）オペレーションを実行して、メモリが使用中であり、クリアできないことを他のスレッドに通知する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行キューの増加に対するオーバーヘッドのため、考えることは理にかなっています。この増加のサポートは本当に必要ですか？この質問は最終的に私にプランナーを書き直すように促しました。新しい戦略では、各プロセスのキューサイズを固定します。キューがいっぱいになると、ローカルキューを増やす代わりに、タスクは複数のコンシューマとプロデューサを持つグローバルキューに移動します。プロセッサは定期的にこのグローバルキューをチェックしますが、ローカルキューよりもはるかに低い頻度です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の実験の1つとして、クロスビームを</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">mpmcに</font></a><font style="vertical-align: inherit;">置き換え</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、プッシュとポップの同期の量が原因で大幅な改善につながらなかった。各プロセッサは自分のキューにしかアクセスしないため、作業をキャプチャするための鍵は、負荷がかかっているキューでの競合がほとんどないことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階で、Goのソースを注意深く調査することにしました。1つのメーカーと複数のコンシューマーで固定キューサイズを使用しており、最小限の同期で非常に印象的です。アルゴリズムをTokioスケジューラーに適合させるために、いくつかの変更を加えました。 Goの実装が（私が理解しているように）順次アトミック操作を使用していることは注目に値します。 Tokioバージョンでは、まれなコードブランチでの一部のコピー操作の数も削減されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キューの実装は、配列に値を格納する循環バッファーです。</font><font style="vertical-align: inherit;">キューの先頭と末尾は、整数値を持つアトミック操作によって追跡されます。</font></font><br>
<br>
<pre><code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span></span> {
    <span class="hljs-comment">/// Concurrently updated by many threads.</span><font></font>
    head: AtomicU32,<font></font>
<font></font>
    <span class="hljs-comment">/// Only updated by producer thread but read by many threads.</span><font></font>
    tail: AtomicU32,<font></font>
<font></font>
    <span class="hljs-comment">/// Masks the head / tail position value to obtain the index in the buffer.</span>
    mask: <span class="hljs-built_in">usize</span>,<font></font>
<font></font>
    <span class="hljs-comment">/// Stores the tasks.</span>
    buffer: <span class="hljs-built_in">Box</span>&lt;[MaybeUninit&lt;Task&gt;]&gt;,<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キューイングは単一のスレッドによって実行されます。</font></font><br>
<br>
<pre><code class="rust hljs"><span class="hljs-keyword">loop</span> {
    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">self</span>.head.load(Acquire);<font></font>
<font></font>
    <span class="hljs-comment">// safety: this is the **only** thread that updates this cell.</span>
    <span class="hljs-keyword">let</span> tail = <span class="hljs-keyword">self</span>.tail.unsync_load();<font></font>
<font></font>
    <span class="hljs-keyword">if</span> tail.wrapping_sub(head) &lt; <span class="hljs-keyword">self</span>.buffer.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span> {
        <span class="hljs-comment">// Map the position to a slot index.</span>
        <span class="hljs-keyword">let</span> idx = tail <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span> &amp; <span class="hljs-keyword">self</span>.mask;<font></font>
<font></font>
        <span class="hljs-comment">// Don't drop the previous value in `buffer[idx]` because</span>
        <span class="hljs-comment">// it is uninitialized memory.</span>
        <span class="hljs-keyword">self</span>.buffer[idx].as_mut_ptr().write(task);<font></font>
<font></font>
        <span class="hljs-comment">// Make the task available</span>
        <span class="hljs-keyword">self</span>.tail.store(tail.wrapping_add(<span class="hljs-number">1</span>), Release);<font></font>
<font></font>
        <span class="hljs-keyword">return</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// The local buffer is full. Push a batch of work to the global</span>
    <span class="hljs-comment">// queue.</span>
    <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.push_overflow(task, head, tail, global) {
        <span class="hljs-literal">Ok</span>(_) =&gt; <span class="hljs-keyword">return</span>,
        <span class="hljs-comment">// Lost the race, try again</span>
        <span class="hljs-literal">Err</span>(v) =&gt; task = v,<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数では</font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、アトミック操作は、順序付けによるロードと順序付けによる</font></font><code>Acquire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存</font><font style="vertical-align: inherit;">のみ</font></font><code>Release</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。以前のように、RMW（</font></font><code>compare_and_swap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>fetch_and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...）</font><font style="vertical-align: inherit;">操作</font><font style="vertical-align: inherit;">や順次オーダー</font><font style="vertical-align: inherit;">はありません</font><font style="vertical-align: inherit;">。 x86チップではすべてのダウンロード/保存がすでに「アトミック」であるため、これは重要です。したがって、CPUレベルでは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この機能は同期されません</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。アトミック操作はコンパイラーの特定の最適化を妨げますが、それだけです。ほとんどの場合、最初の操作</font></font><code>load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はorderingを使用して安全に実行できます</font></font><code>Relaxed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、置換しても顕著なオーバーヘッドはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キューがいっぱいになると呼び出されます</font></font><code>push_overflow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この関数は、タスクの半分をローカルキューからグローバルキューに移動します。グローバルキューは、ミューテックスによって保護された侵入リストです。グローバルキューに移動するとき、タスクは最初に相互にリンクされ、次にミューテックスが作成され、グローバルキューの末尾へのポインターを更新することによってすべてのタスクが挿入されます。これにより、クリティカルセクションのサイズを小さくすることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アトミックメモリの順序付けの詳細に精通している場合は、上記の関数の潜在的な「問題」に気付くかもしれません</font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。アトミックな</font></font><code>load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">順序付け</font><font style="vertical-align: inherit;">操作は</font></font><code>Acquire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">かなり弱いです。廃止された値を返す可能性があります。つまり、並列キャプチャ操作によってすでに値</font></font><code>self.head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">増加している可能性があります</font><font style="vertical-align: inherit;">が、ストリームキャッシュでは</font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">古い値が残るため、キャプチャ操作に気づきません。これはアルゴリズムの正確さの問題ではありません。主な（速い）方法で</font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ローカルキューがいっぱいであるかどうかのみを考慮します。現在のスレッドのみがキューをプッシュできるため、古い操作で</font></font><code>load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、キューが実際よりもいっぱいに見えるだけです。キューがいっぱいであると誤って判断し、原因となる</font></font><code>push_overflow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合が</font><font style="vertical-align: inherit;">あります</font><font style="vertical-align: inherit;">が、この関数にはより強力なアトミック操作が含まれています。</font></font><code>push_overflow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キューが実際にはいっぱいでない</font><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">判断した</font><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">は、w /を返し</font></font><code>Err</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、操作</font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が再開されます。これは、別の理由です</font></font><code>push_overflow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行キューの半分をグローバルキューに移動します。</font><font style="vertical-align: inherit;">この動きの後、そのような誤検出はそれほど頻繁に発生しなくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ローカル</font></font><code>pop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（キューが属するプロセッサから）も簡単に実装されます。</font></font><br>
<br>
<pre><code class="rust hljs"><span class="hljs-keyword">loop</span> {
    <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">self</span>.head.load(Acquire);<font></font>
<font></font>
    <span class="hljs-comment">// safety: this is the **only** thread that updates this cell.</span>
    <span class="hljs-keyword">let</span> tail = <span class="hljs-keyword">self</span>.tail.unsync_load();<font></font>
<font></font>
    <span class="hljs-keyword">if</span> head == tail {
        <span class="hljs-comment">// queue is empty</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// Map the head position to a slot index.</span>
    <span class="hljs-keyword">let</span> idx = head <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span> &amp; <span class="hljs-keyword">self</span>.mask;<font></font>
<font></font>
    <span class="hljs-keyword">let</span> task = <span class="hljs-keyword">self</span>.buffer[idx].as_ptr().read();<font></font>
<font></font>
    <span class="hljs-comment">// Attempt to claim the task read above.</span>
    <span class="hljs-keyword">let</span> actual = <span class="hljs-keyword">self</span><font></font>
        .head<font></font>
        .compare_and_swap(head, head.wrapping_add(<span class="hljs-number">1</span>), Release);<font></font>
<font></font>
    <span class="hljs-keyword">if</span> actual == head {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">Some</span>(task.assume_init());<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数では、1つのアトミック</font></font><code>load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と1つ</font></font><code>compare_and_swap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のs </font></font><code>Release</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">主なオーバーヘッドはから来</font></font><code>compare_and_swap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数</font></font><code>steal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はに似て</font></font><code>pop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いますが、</font></font><code>self.tail</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アトミックロードは</font><font style="vertical-align: inherit;">から</font><font style="vertical-align: inherit;">転送</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">必要があります。</font><font style="vertical-align: inherit;">さらに、同様</font></font><code>push_overflow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、操作は</font></font><code>steal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単一のタスクではなくキューの半分であるふりをしようとしています。</font><font style="vertical-align: inherit;">これはパフォーマンスに良い影響を与えます。これについては後で説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に欠けている部分は、ローカルキューをオーバーフローするタスクを受信するグローバルキューの分析と、非プロセッサスレッドからスケジューラにタスクを転送するための分析です。</font><font style="vertical-align: inherit;">プロセッサに負荷がかかっている場合、つまり、ローカルキューにタスクがある場合、プロセッサは、ローカルキューに約60タスクごとにタスクをグローバルキューからプルしようとします。</font><font style="vertical-align: inherit;">また、以下で説明する「検索」状態のときにグローバルキューをチェックします。</font></font><br>
<br>
<a name="3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージテンプレートの合理化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tokioアプリケーションは通常、多くの小さな独立したタスクで構成されています。それらはメッセージを介して相互に対話します。このようなテンプレートは、GoやErlangなどの他の言語に似ています。テンプレートがどれほど一般的であるかを考えると、プランナがそれを最適化することは理にかなっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクAとBが与えられたとすると、タスクAが実行されており、伝送チャネルを介してタスクBにメッセージを送信します。チャネルは、タスクBが現在ブロックされているリソースであるため、メッセージを送信するアクションにより、タスクBが実行可能な状態に移行し、現在のプロセッサの実行キューに配置されます。次に、プロセッサは実行キューから次のタスクを推定して実行し、タスクBに到達するまでこのサイクルを繰り返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、メッセージの送信からタスクBの完了までに大幅な遅延が発生する可能性があることです。</font><font style="vertical-align: inherit;">さらに、メッセージなどの「ホット」データはCPUキャッシュに格納されますが、タスクが完了するまでに、対応するキャッシュがクリアされる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するために、新しいTokioスケジューラーは最適化を実装しています（GoおよびKotlinスケジューラーと同様）。</font><font style="vertical-align: inherit;">タスクが実行可能な状態になると、タスクはキューの最後に置かれず、特別な「次のタスク」スロットに格納されます。</font><font style="vertical-align: inherit;">プロセッサは、キューをチェックする前に常にこのスロットをチェックします。</font><font style="vertical-align: inherit;">スロットに挿入するときにすでに古いタスクがある場合、そのタスクはスロットから削除され、キューの最後に移動します。</font><font style="vertical-align: inherit;">したがって、メッセージを送信するタスクは、実質的に遅延なく実行されます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/12f/e12/a32/12fe12a324d1855a6c62cacd56cb4f70.png"><br>
<br>
<a name="4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スロットルキャプチャ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジョブキャプチャスケジューラでは、プロセッサ実行キューが空の場合、プロセッサはピアCPUからタスクをキャプチャしようとします。最初に、ランダムなピアツーピアCPUが選択され、そのタスクが見つからない場合は、次のCPUが検索され、タスクが見つかるまで繰り返されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、いくつかのプロセッサが実行キューの処理をほぼ同時に終了することがよくあります。これは、ジョブパッケージが到着したときに発生します（たとえば、</font></font><code>epoll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソケットの準備状況をポーリングしました）。プロセッサはウェイクアップし、タスクを受け取り、タスクを開始して完了します。これは、すべてのプロセッサが同時に他の人のタスクをキャプチャしようとしている、つまり、多くのスレッドが同じキューにアクセスしようとしているという事実につながります。矛盾があります。開始点をランダムに選択すると、競争が減りますが、状況はまだあまり良くありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を回避するために、新しいスケジューラーはキャプチャー操作を実行する並列プロセッサーの数を制限します。他の人のタスクをキャプチャしようとしているプロセッサの状態を、「ジョブ検索」または「検索」と略します（詳細は後で説明します）。このような最適化は、アトミック値を使用して実行されます</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、プロセッサが検索を開始する前に増加し、検索状態を終了するときに減少します。</font><font style="vertical-align: inherit;">検索状態では、可能な限りプロセッサの総数の半分にすることができます。</font><font style="vertical-align: inherit;">つまり、おおよその制限が設定されていますが、これは正常です。</font><font style="vertical-align: inherit;">検索のCPU数にハード制限は必要ありません。調整するだけです。</font><font style="vertical-align: inherit;">アルゴリズムの効率化のために精度を犠牲にしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検索状態に入った後、プロセッサはピアCPUからの作業のキャプチャを試み、グローバルキューをチェックします。</font></font><br>
<br>
<a name="5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッド間の同期を減らす</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スケジューラのもう1つの重要な部分は、ピアCPUに新しいタスクを通知することです。 「兄弟」が眠っている場合、彼は目を覚まし、タスクをキャプチャします。通知は別の重要な役割を果たします。キューアルゴリズムは弱いアトミックな順序（</font></font><code>Acquire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;/ </font></font><code>Release</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">使用することを思い出してください</font><font style="vertical-align: inherit;">。メモリのアトミックな割り当てにより、ピアプロセッサが追加の同期なしにキュー内のタスクを確認できるという保証はありません。したがって、通知もそれに責任があります。このため、通知は高額になります。目標は、CPUリソースを使用しないようにそれらの数を最小化することです。つまり、プロセッサーにはタスクがあり、「兄弟」はそれらを盗むことができません。通知の数が多すぎると</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、群れの問題が発生し</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オリジナルの東京プランナーは通知に対して素朴なアプローチをとりました。新しいタスクが実行キューに配置されるたびに、プロセッサは通知を受け取りました。 CPUが通知を受け、ウェイクアップ後にタスクを確認するたびに、別のCPUに通知しました。このロジックにより、すべてのプロセッサがウェイクアップして作業を探すようになりました（競合の原因）。多くの場合、ほとんどのプロセッサーは作業を見つけられず、再び眠りに落ちました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいスケジューラーは、Goスケジューラーと同様に、このパターンを大幅に改善しました。通知は以前と同じように送信されますが、検索状態にCPUがない場合のみです（前のセクションを参照）。プロセッサが通知を受信すると、すぐに検索状態になります。検索状態のプロセッサが新しいタスクを見つけると、最初に検索状態を終了してから、他のプロセッサに通知します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このロジックは、プロセッサが起動する速度を制限します。タスクパッケージ全体がすぐに計画される場合（たとえば、</font></font><code>epoll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソケットの準備状況をポーリングした場合）、最初のタスクはプロセッサの通知につながります。</font><font style="vertical-align: inherit;">彼は現在捜索中です。</font><font style="vertical-align: inherit;">少なくとも1つのCPUが検索状態にあるため、パッケージ内の残りのスケジュールされたタスクはプロセッサに通知しません。</font><font style="vertical-align: inherit;">この通知されたプロセッサは、パッケージ内のタスクの半分をキャプチャし、次に、他のプロセッサに通知します。</font><font style="vertical-align: inherit;">3番目のプロセッサが起動し、最初の2つのプロセッサの1つのタスクを見つけて、それらの半分をキャプチャします。</font><font style="vertical-align: inherit;">これにより、稼働中のCPUの数がスムーズに増加し、ロードバランシングが高速になります。</font></font><br>
<br>
<a name="6"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリ割り当てを減らす</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいTokioスケジューラーは、生成されたタスクごとに1つのメモリー割り当てのみを必要としますが、古いものは2つ必要でした。</font><font style="vertical-align: inherit;">以前は、タスク構造は次のようなものでした。</font></font><br>
<br>
<pre><code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Task</span></span> {
    <span class="hljs-comment">/// All state needed to manage the task</span><font></font>
    state: TaskState,<font></font>
<font></font>
    <span class="hljs-comment">/// The logic to run is represented as a future trait object.</span>
    future: <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">dyn</span> Future&lt;Output = ()&gt;&gt;,<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造</font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もで強調表示され</font></font><code>Box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。非常に長い間、私はこのジョイントを修正したいと思っていました（2014年に初めて試しました）。古い東京プランナー以降、2つの点が変更されました。まず、安定化</font></font><code>std::alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。次に、将来のタスクシステムは明示的な</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vtable戦略に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">切り替わりました</font><font style="vertical-align: inherit;">。最後に、各タスクの非効率的な二重メモリ割り当てを取り除くために欠けていたのは、これらの2つでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、構造</font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は次の形式で表示されます。</font></font><br>
<br>
<pre><code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Task</span></span>&lt;T&gt; {<font></font>
    header: Header,<font></font>
    future: T,<font></font>
    trailer: Trailer,<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
and </font></font><code>Header</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>Trailer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">必要なタスクの場合</font><font style="vertical-align: inherit;">、「ホット」データ（ヘッド）と「コールド」（テール）に分けられます。m。E.頻繁にアクセスされるデータとほとんど使用されないデータの間。</font><font style="vertical-align: inherit;">「ホット」データは構造の先頭に配置され、可能な限り保存されません。</font><font style="vertical-align: inherit;">プロセッサがタスクポインターを逆参照すると、すぐにキャッシュライン（64〜128バイト）が読み込まれます。</font><font style="vertical-align: inherit;">このデータをできる限り関連性のあるものにしたいと考えています。</font></font><br>
<br>
<a name="7"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アトミックリンクのカウントを減らす</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事で説明する最後の最適化は、アトミックリンクの数を減らすことです。スケジューラや各ウェイカーからなど、タスクの構造への多くの参照があります。このメモリを管理するための一般的な戦略は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アトミックリンクカウント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。この戦略では、リンクが複製されるたび、およびリンクが削除されるたびに、アトミック操作が必要です。最後のリンクがスコープから外れると、メモリが解放されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
古いTokioスケジューラーでは、スケジューラーとすべてのウェイカーの両方に、タスク記述子へのリンクが含まれていました。</font></font><br>
<br>
<pre><code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Waker</span></span> {<font></font>
    task: Arc&lt;Task&gt;,<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">impl</span> Waker {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">wake</span></span>(&amp;<span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">let</span> task = <span class="hljs-keyword">self</span>.task.clone();<font></font>
        task.scheduler.schedule(task);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクが起動すると、リンクが複製されます（アトミック増分が発生します）。</font><font style="vertical-align: inherit;">次に、リンクが実行キューに配置されます。</font><font style="vertical-align: inherit;">プロセッサがタスクを受け取り、その実行を完了すると、リンクが破棄され、アトミックな削減につながります。</font><font style="vertical-align: inherit;">これらのアトミック操作（増加と減少）が加算されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題は、以前はタスクシステムの開発者によって特定されていました</font></font><code>std::future</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">彼らは、電話をかけるとき、</font></font><code>Waker::wake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンクへの元のリンク</font></font><code>waker</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が不要になること</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">多いことに</font><font style="vertical-align: inherit;">気づきました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これにより、タスクを実行キューに移動するときにアトミックリンクカウンターを再利用できます。</font><font style="vertical-align: inherit;">タスクシステムに</font></font><code>std::future</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、「ウェイクアップ」するための2つのAPI呼び出しが含まれています。</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><code>wake</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">受け入れる </font></font><code>self</code><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><code>wake_by_ref</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">受け入れる </font></font><code>&amp;self</code></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなAPI構造により</font></font><code>wake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、を</font><font style="vertical-align: inherit;">呼び出すときに使用して、</font><font style="vertical-align: inherit;">アトミックな増分を回避します。</font><font style="vertical-align: inherit;">実装は次のようになります。</font></font><br>
<br>
<pre><code class="rust hljs"><span class="hljs-keyword">impl</span> Waker {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">wake</span></span>(<span class="hljs-keyword">self</span>) {<font></font>
        task.scheduler.schedule(<span class="hljs-keyword">self</span>.task);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">wake_by_ref</span></span>(&amp;<span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">let</span> task = <span class="hljs-keyword">self</span>.task.clone();<font></font>
        task.scheduler.schedule(task);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより</font><font style="vertical-align: inherit;">、覚醒の責任を負うことができる場合に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のみ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、追加の参照カウントのオーバーヘッドが回避され</font><font style="vertical-align: inherit;">ます。私の経験では、代わりにで目を覚ますことをお勧めし</font></font><code>&amp;self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。目覚め</font></font><code>self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ウェイカーの再利用を防ぎます（リソースが多くの値、つまりチャネル、ソケットなどを送信する場合に役立ちます）。また、</font></font><code>self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドセーフなウェイクアップを実装</font><font style="vertical-align: inherit;">することが</font><font style="vertical-align: inherit;">より難しい</font><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">（詳細は別の記事に残します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいプランナーは、「ウェイクスルー」の問題を解決し、</font></font><code>self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のアトミックな増分を回避します</font></font><code>wake_by_ref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これにより、</font></font><code>wake(self)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これを行うために、スケジューラーは現在アクティブな（まだ完了していない）すべてのタスクのリストを維持します。</font><font style="vertical-align: inherit;">リストは、タスクを実行キューに送信するために必要な参照カウンターを表します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この最適化の複雑さは、スケジューラがタスクが再度実行キューに配置されるという保証を受け取るまで、スケジューラがそのリストからタスクを削除しないという事実にあります。</font><font style="vertical-align: inherit;">このスキームの実装の詳細はこの記事の範囲を超えていますが、ソースを確認することを強くお勧めします。</font></font><br>
<br>
<a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loomによる大胆な（安全でない）同時実行性</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロックなしで正しい並列コードを書くことは非常に困難です。特にバグがメモリのセキュリティに関連している場合は、グリッチを使ってゆっくりとではなく正しく実行することをお勧めします。ただし、最良のオプションはエラーなしで迅速に機能するはずです。新しいスケジューラはかなり積極的な最適化を行い</font></font><code>std</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、特殊化のために</font><font style="vertical-align: inherit;">ほとんどのタイプ</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">回避し</font><font style="vertical-align: inherit;">ます。一般に、安全でないコードがかなり多く含まれてい</font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並列コードをテストする方法はいくつかあります。それらの1つは、ユーザーの代わりにユーザーがテストとデバッグを実行するためのものです（魅力的なオプション、それは確かです）。もう1つは、ループで実行され、エラーをキャッチできる単体テストを作成することです。たぶん</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">TSANを</font></a><font style="vertical-align: inherit;">使う</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。もちろん、彼がエラーを見つけた場合、テストサイクルを再開しないと簡単に再現できません。また、このサイクルにはどのくらい時間がかかりますか？ 10秒？ 10分？十日？以前は、Rustで並列コードをテストする必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況は容認できません。コードをリリースするとき、特にロックのない並列コードの場合は、（可能な限り）自信を持ちたいと思います。 Tokioユーザーには信頼性が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、</font><font style="vertical-align: inherit;">並列コードの置換テストのためのツールである</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を開発し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ました</font></a><font style="vertical-align: inherit;">。テストはいつものように書かれていますが、</font></font><code>loom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリーミング環境でテストが遭遇する可能性のある実行および動作のすべてのバリアントを再配置して、それらを何度も実行します。また、正しいメモリアクセスやメモリの解放などもチェックします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例として、新しいスケジューラのルームテストを次に示します。</font></font><br>
<br>
<pre><code class="rust hljs"><span class="hljs-meta">#[test]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">multi_spawn</span></span>() {<font></font>
    loom::model(|| {<font></font>
        <span class="hljs-keyword">let</span> pool = ThreadPool::new();<font></font>
<font></font>
        <span class="hljs-keyword">let</span> c1 = Arc::new(AtomicUsize::new(<span class="hljs-number">0</span>));<font></font>
<font></font>
        <span class="hljs-keyword">let</span> (tx, rx) = oneshot::channel();
        <span class="hljs-keyword">let</span> tx1 = Arc::new(Mutex::new(<span class="hljs-literal">Some</span>(tx)));<font></font>
<font></font>
        <span class="hljs-comment">// Spawn a task</span>
        <span class="hljs-keyword">let</span> c2 = c1.clone();
        <span class="hljs-keyword">let</span> tx2 = tx1.clone();<font></font>
        pool.spawn(<span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> {<font></font>
            spawn(<span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> {
                <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> == c1.fetch_add(<span class="hljs-number">1</span>, Relaxed) {<font></font>
                    tx1.lock().unwrap().take().unwrap().send(());<font></font>
                }<font></font>
            });<font></font>
        });<font></font>
<font></font>
        <span class="hljs-comment">// Spawn a second task</span>
        pool.spawn(<span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> {<font></font>
            spawn(<span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> {
                <span class="hljs-keyword">if</span> <span class="hljs-number">1</span> == c2.fetch_add(<span class="hljs-number">1</span>, Relaxed) {<font></font>
                    tx2.lock().unwrap().take().unwrap().send(());<font></font>
                }<font></font>
            });<font></font>
        });<font></font>
<font></font>
        rx.recv();<font></font>
    });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
かなり正常に見えますが、ブロック内のコードの一部は</font></font><code>loom::model</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、動作にわずかな変更を加えて、何千回（おそらく数百万回）実行されます。実行ごとに、スレッドの正確な順序が変更されます。さらに、各アトミック操作に対して、ルームはC ++ 11メモリモデルで許可されているすべての異なる動作を試みます。のアトミックロード</font></font><code>Acquire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はかなり弱く、廃止された値を返す可能性があること</font><font style="vertical-align: inherit;">を思い出してください</font><font style="vertical-align: inherit;">。テスト</font></font><code>loom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ロードできるすべての可能な値を試します。</font></font><br>
<br>
<code>loom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいプランナーを開発する上で非常に貴重なツールになりました。彼はすべての単体テスト、手動テスト、および負荷テストに合格した10以上のバグをキャッチしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
賢明な読者は、織機が「考えられるすべての順列」をチェックすることを疑うかもしれず、彼は正しいでしょう。素朴な順列は、組み合わせ爆発につながります。重要なテストは決して終了しません。この問題は長年にわたって研究されており、組み合わせの爆発を防ぐために多くのアルゴリズムが開発されてきました。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分的な順序付けを伴う動的な縮小</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（動的な半順序の縮小）に</font><font style="vertical-align: inherit;">基づくルーム基本アルゴリズム</font><font style="vertical-align: inherit;">。このアルゴリズムは、同じ結果につながる順列を排除します。しかし、状態スペースは、妥当な時間（数分）で処理されないほどのサイズに成長する可能性があります。 Loomでは、部分的な順序付けを使用した動的削減を使用して、さらに制限することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、Loomでの広範なテストのおかげ</font><font style="vertical-align: inherit;">で、スケジューラーの正確さに</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">かなり</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自信を持つようになりました。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、スケジューラーとは何か、そして新しいTokioスケジューラーがどのようにして大幅なパフォーマンス向上を達成したかを調べましたが、どのような成長ですか？</font><font style="vertical-align: inherit;">新しいスケジューラーは開発されただけなので、現実の世界ではまだ完全にテストされていません。</font><font style="vertical-align: inherit;">これが私たちが知っていることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、新しいベンチマークはマイクロベンチマークではるかに高速です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オールドプランナー</font></font></h4><br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストchained_spawn ...ベンチ：2,019,796 ns / iter（+/- 302,168）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストping_pong ...ベンチ：1,279,948 ns / iter（+/- 154,365）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
test spawn_many ...ベンチ：10,283,608 ns / iter（+/- 1,284,275）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストyield_many ...ベンチ：21,450,748 ns / iter（+/- 1,201,337）</font></font></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいプランナー</font></font></h4><br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストchained_spawn ...ベンチ：168,854 ns / iter（+/- 8,339）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストping_pong ...ベンチ：562,659 ns / iter（+/- 34,410）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
test spawn_many ...ベンチ：7,320,737 ns / iter（+/- 264,620）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストyield_many ...ベンチ：14,638,563 ns / iter（+/- 1,573,678）</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このベンチマークには次のものが含まれます。</font></font><br>
<br>
<ul>
<li><code>chained_spawn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 新しいタスクを再帰的に生成します。つまり、別のタスクを生成するタスクを生成します。これにより、タスクも生成されます。</font></font><br>
</li>
<li><code>ping_pong</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チャネル</font></font><code>oneshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">選択し、</font><font style="vertical-align: inherit;">そのチャネルでメッセージを送信するタスクを生成します。</font><font style="vertical-align: inherit;">元のタスクはメッセージを待っています。</font><font style="vertical-align: inherit;">これは「実世界」に最も近いテストです。</font></font><br>
</li>
<li><code>spawn_many</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> スケジューラでのタスクの実装を確認します。つまり、コンテキストの外部からタスクを生成します。</font></font><br>
</li>
<li><code>yield_many</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 自己覚醒タスクをチェックします。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ベンチマークの違いは非常に印象的です。</font><font style="vertical-align: inherit;">しかし、これはどのように「現実の世界」に反映されるのでしょうか。</font><font style="vertical-align: inherit;">確かに言うのは難しいですが、私は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハイパー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベンチマークを実行しようとしました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが最も単純なHyperサーバーで、そのパフォーマンスは以下を使用して測定されます</font></font><code>wrk -t1 -c50 -d10</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オールドプランナー</font></font></h4><br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10秒間のテスト@ http://127.0.0.1 {000</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1スレッド、50接続</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  スレッド統計平均標準偏差最大+/-標準偏差</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    レイテンシ371.53us 99.05us 1.97ms 60.53％</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    要求/秒114.61k 8.45k 133.85k 67.00％</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1139307リクエスト、10.00秒、95.61MB読み取り</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リクエスト数/秒：113923.19</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
転送/秒：9.56MB</font></font></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいプランナー</font></font></h4><br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10秒間のテスト@ http://127.0.0.1 {000</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1スレッド、50接続</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  スレッド統計平均標準偏差最大+/-標準偏差</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    レイテンシ275.05us 69.81us 1.09ms 73.57％</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    要求/秒153.17k 10.68k 171.51k 71.00％</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1522671リクエスト、10.00秒、127.79MB読み取り</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リクエスト/秒：152258.70</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
転送/秒：12.78MB</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スケジューラを変更した直後は、1秒あたりのリクエスト数が34％増加しています。</font><font style="vertical-align: inherit;">これを初めて見たときは、最大で5〜10％の増加が予想されていたので、とても嬉しかったです。</font><font style="vertical-align: inherit;">しかし、この結果は古い東京スケジューラーがあまり良くないことを示していたので、私は悲しくなりました。</font><font style="vertical-align: inherit;">次に、Hyperは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すでにTechEmpowerの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">評価のリーダーで</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ある</font></a><font style="vertical-align: inherit;">ことを思い出しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">新しいプランナーが評価にどのように影響するかを見るのは興味深いことです。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トニック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいスケジューラと、gRPCクライアントとサーバは、トニックはまだ完全に最適化されていないことを考えるとかなり印象的である約10％、によって加速しました。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数ヶ月の仕事を経てようやくこのプロジェクトを完成できて本当にうれしいです。</font><font style="vertical-align: inherit;">これは、Rustの非同期I / Oの大きな改善点です。</font><font style="vertical-align: inherit;">私は、行われた改善に非常に満足しています。</font><font style="vertical-align: inherit;">Tokioコードにはまだ最適化の余地があるため、パフォーマンスの改善はまだ完了していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事の内容が、タスクスケジューラを作成しようとしている同僚にとって役立つことを願っています。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja472228/index.html">Visual Studio Codeを操作するための9つのトリック</a></li>
<li><a href="../ja472230/index.html">ML用チップ-新製品について話す</a></li>
<li><a href="../ja472232/index.html">「ZX-Spectrum用カラーエクステンダー」からZX-Polyへ</a></li>
<li><a href="../ja472234/index.html">暗号通貨：それはまだフリーローダーですか、それともパートナーですか？</a></li>
<li><a href="../ja472240/index.html">ゲーミフィケーションについて。それは何ですか、なぜそしてどのようにそれを行うのですか？開発者の外観</a></li>
<li><a href="../ja472246/index.html">React + IndexDb +自動更新=ほとんどAsyncRedux</a></li>
<li><a href="../ja472248/index.html">IT Planetプログラミングファイナルをどのように統合したか</a></li>
<li><a href="../ja472252/index.html">10月21日から28日までのモスクワでのデジタルイベント</a></li>
<li><a href="../ja472254/index.html">10月21日から28日までのサンクトペテルブルクでのデジタルイベント</a></li>
<li><a href="../ja472258/index.html">「学ぶことを学ぶ」方法-マインドフルネスを改善する</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>