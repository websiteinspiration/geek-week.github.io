<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçß üë©üèø‚Äçüç≥ üë®üèø‚Äçüîß Welche Belastung der Server f√ºhrt zu Netzwerkmechanismen? üë¥ üë®‚Äçüî¨ ü§¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei der Analyse des Betriebs des Netzwerksubsystems von Servern werden normalerweise Indikatoren wie Latenz, Durchsatz des Systems und die Anzahl der ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Welche Belastung der Server f√ºhrt zu Netzwerkmechanismen?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/503636/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Analyse des Betriebs des Netzwerksubsystems von Servern werden normalerweise Indikatoren wie Latenz, Durchsatz des Systems und die Anzahl der Pakete, die pro Sekunde verarbeitet werden k√∂nnen (PPS, Pakete pro Sekunde), ber√ºcksichtigt. Diese Indikatoren werden verwendet, um zu verstehen, unter welcher maximalen Last der untersuchte Computer arbeiten kann. Und obwohl diese Metriken wichtig sind und oft viel √ºber das System aussagen k√∂nnen, liefern sie keine Informationen dar√ºber, welche Auswirkungen die Verarbeitung von Netzwerkpaketen auf Programme hat, die auf dem Server ausgef√ºhrt werden. </font><font style="vertical-align: inherit;">
Dieses Material zielt darauf ab, die Last zu untersuchen, die durch Netzwerkmechanismen auf Servern erzeugt wird. Insbesondere werden wir dar√ºber sprechen, wie viel Prozessorzeit die L√∂sung f√ºr Netzwerkprobleme von verschiedenen Prozessen ‚Äûstehlen‚Äú kann, die auf Linux-Systemen ausgef√ºhrt werden.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/q_/0y/ya/q_0yyareydlakrio4dbunpbt8fu.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Netzwerkpaketverarbeitung unter Linux</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linux verarbeitet eine erhebliche Anzahl von Paketen im Kontext eines Prozesses, der vom Prozessor zum Zeitpunkt der Verarbeitung des entsprechenden IRQ ausgef√ºhrt wird. </font><font style="vertical-align: inherit;">Die System Accounting Engine weist die daf√ºr verwendeten Prozessorzyklen jedem Prozess zu, der gerade ausgef√ºhrt wird. </font><font style="vertical-align: inherit;">Dies wird auch dann durchgef√ºhrt, wenn dieser Prozess nichts mit der Netzwerkpaketverarbeitung zu tun hat. </font><font style="vertical-align: inherit;">Beispielsweise kann ein Team </font></font><code>top</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angeben, dass ein Prozess anscheinend mehr als 99% der Ressourcen des Prozessors verbraucht. Tats√§chlich werden jedoch 60% der Prozessorzeit f√ºr die Verarbeitung der Pakete aufgewendet. </font><font style="vertical-align: inherit;">Dies bedeutet, dass der Prozess selbst, der seine eigenen Probleme l√∂st, nur 40% der CPU-Ressourcen verbraucht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eingehender Handler</font></font><code>net_rx_action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Regel sehr, sehr schnell durchgef√ºhrt. Zum Beispiel in weniger als 25 Œºs. (Diese Daten stammen aus Messungen mit eBPF. Wenn Sie an den Details interessiert sind, lesen Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a> <code>net_rx_action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .) Der Prozessor kann bis zu 64 Pakete pro NAPI-Instanz (NIC oder RPS) verarbeiten, bevor die Aufgabe auf einen anderen SoftIRQ-Zyklus verschoben wird. Nacheinander k√∂nnen ohne Unterbrechung bis zu 10 SoftIRQ-Zyklen folgen, was ungef√§hr 2 ms dauert (mehr dazu erfahren Sie, indem Sie dar√ºber lesen </font></font><code>__do_softirq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Wenn der SoftIRQ-Vektor nach Ablauf der maximalen Anzahl von Zyklen oder nach Ablauf der Zeit immer noch ungel√∂ste Probleme aufweist, wird die L√∂sung dieser Probleme f√ºr die Ausf√ºhrung im Thread verz√∂gert</font></font><code>ksoftirqd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spezifische CPU. </font><font style="vertical-align: inherit;">In diesem Fall erweist sich das System als etwas transparenter im Sinne des Abrufs von Informationen √ºber die durch Netzwerkoperationen erzeugte Prozessorlast (obwohl eine solche Analyse unter der Annahme durchgef√ºhrt wird, dass SoftIRQ untersucht wird, das sich auf die Paketverarbeitung bezieht und nicht auf etwas anderes). . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine M√∂glichkeit, die oben genannten Indikatoren zu erhalten, besteht darin, Folgendes zu verwenden </font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">sudo perf record -a \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e irq:irq_handler_entry,irq:irq_handler_exit<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e irq:softirq_entry --filter="vec == 3" \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e irq:softirq_exit --filter="vec == 3"&nbsp; \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e napi:napi_poll \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- sleep 1<font></font>
<font></font>
sudo perf script<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist das Ergebnis:</font></font><br>
<br>
<pre><code class="plaintext hljs">swapper &nbsp; &nbsp; 0 [005] 176146.491879: irq:irq_handler_entry: irq=152 name=mlx5_comp2@pci:0000:d8:00.0<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491880:&nbsp; irq:irq_handler_exit: irq=152 ret=handled<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491880: &nbsp; &nbsp; irq:softirq_entry: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491942:&nbsp; &nbsp; &nbsp; &nbsp; napi:napi_poll: napi poll on napi struct 0xffff9d3d53863e88 for device eth0 work 64 budget 64<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491943:&nbsp; &nbsp; &nbsp; irq:softirq_exit: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491943: &nbsp; &nbsp; irq:softirq_entry: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491971:&nbsp; &nbsp; &nbsp; &nbsp; napi:napi_poll: napi poll on napi struct 0xffff9d3d53863e88 for device eth0 work 27 budget 64<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491971:&nbsp; &nbsp; &nbsp; irq:softirq_exit: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.492200: irq:irq_handler_entry: irq=152 name=mlx5_comp2@pci:0000:d8:00.0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall ist der Prozessor inaktiv (daher das Auftreten von Eintr√§gen </font></font><code>swapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr den Prozess), IRQ wird f√ºr die Rx-Warteschlange auf CPU 5 aufgerufen, die SoftIRQ-Verarbeitung wird zweimal aufgerufen, 64 Pakete werden zuerst verarbeitet, dann 27. Der n√§chste IRQ wird nach 229 Œºs aufgerufen und startet den Zyklus erneut.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Daten wurden auf einem Leerlaufsystem erhalten. Auf dem Prozessor kann jedoch jede Aufgabe ausgef√ºhrt werden. In diesem Fall tritt die obige Abfolge von Ereignissen auf, die diese Aufgabe unterbrechen und IRQ / SoftIRQ-Aufgaben ausf√ºhren. Gleichzeitig schreibt das System Accounting dem unterbrochenen Prozess die vom Prozessor erzeugte Last zu. Infolgedessen sind Netzwerkpaketverarbeitungsaufgaben normalerweise vor herk√∂mmlichen Tools zur √úberwachung der Prozessorlast verborgen. Sie werden im Kontext eines zuf√§llig ausgew√§hlten Prozesses im Kontext des ‚ÄûOpferprozesses‚Äú ausgef√ºhrt. Dies f√ºhrt uns zu einigen Fragen. Wie kann die Zeit gesch√§tzt werden, f√ºr die der Prozess f√ºr die Verarbeitung von Paketen unterbrochen wird? Wie kann man zwei verschiedene Netzwerkl√∂sungen vergleichen, um zu verstehen, welche davon weniger Einfluss auf verschiedene Aufgaben haben, die auf einem Computer gel√∂st werden?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Verwendung von RSS-, RPS- und RFS-Mechanismen wird die Paketverarbeitung normalerweise auf die Prozessorkerne verteilt. </font><font style="vertical-align: inherit;">Daher bezieht sich die obige Paketverarbeitungssequenz auf jede spezifische CPU. </font><font style="vertical-align: inherit;">Mit zunehmender Paketankunftsrate (ich denke, wir k√∂nnen von Geschwindigkeiten von 100.000 Paketen pro Sekunde und h√∂her sprechen) muss jede CPU Tausende oder Zehntausende von Paketen pro Sekunde verarbeiten. </font><font style="vertical-align: inherit;">Die Verarbeitung so vieler Pakete wirkt sich unweigerlich auf andere auf dem Server ausgef√ºhrte Aufgaben aus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie eine M√∂glichkeit, diesen Effekt zu bewerten.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deaktivieren der verteilten Paketverarbeitung</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stoppen wir zun√§chst die verteilte Verarbeitung von Paketen, indem wir RPS deaktivieren und Flusssteuerungsregeln einrichten, die darauf abzielen, die Verarbeitung aller Pakete zu organisieren, die sich auf eine bestimmte MAC-Adresse auf der einzigen uns bekannten CPU beziehen. </font><font style="vertical-align: inherit;">Mein System verf√ºgt √ºber 2 Netzwerkkarten, die in einer 802.3ad-Konfiguration zusammengefasst sind. </font><font style="vertical-align: inherit;">Netzwerkaufgaben werden einer einzelnen virtuellen Maschine zugewiesen, die auf einem Computer ausgef√ºhrt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RPS auf Netzwerkadaptern ist wie folgt deaktiviert:</font></font><br>
<br>
<pre><code class="plaintext hljs">for d in eth0 eth1; do<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;find /sys/class/net/${d}/queues -name rps_cpus |<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;while read f; do<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo 0 | sudo tee ${f}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;done<font></font>
done<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als N√§chstes richten wir die Flusssteuerungsregeln ein, um sicherzustellen, dass Pakete mit einer einzigen CPU in die virtuelle Testmaschine gelangen:</font></font><br>
<br>
<pre><code class="plaintext hljs">DMAC=12:34:de:ad:ca:fe<font></font>
sudo ethtool -N eth0 flow-type ether dst ${DMAC} action 2<font></font>
sudo ethtool -N eth1 flow-type ether dst ${DMAC} action 2<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch Deaktivieren von RPS und Verwenden von Flusssteuerungsregeln k√∂nnen wir sicherstellen, dass alle f√ºr unsere virtuelle Maschine bestimmten Pakete auf derselben CPU verarbeitet werden. </font><font style="vertical-align: inherit;">Um sicherzustellen, dass Pakete an die Warteschlange gesendet werden, an die sie gesendet werden sollen, k√∂nnen Sie einen Befehl wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ethq verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dann k√∂nnen Sie herausfinden, zu welcher CPU diese Warteschlange geh√∂rt </font></font><code>/proc/interrupts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In meinem Fall wird Runde 2 mittels CPU 5 bearbeitet.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ñffnet den Geschwindigkeitsbefehl</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich k√∂nnte Dienstprogramme verwenden </font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font><font style="vertical-align: inherit;">SoftIRQ-Laufzeiten analysieren, die f√ºr die Verarbeitung des eingehenden Datenverkehrs verantwortlich sind </font></font><code>bpf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber dieser Ansatz ist ziemlich kompliziert. Dar√ºber hinaus beeinflusst der Beobachtungsprozess selbst definitiv die Ergebnisse. Eine viel einfachere und verst√§ndlichere L√∂sung besteht darin, die durch die Netzwerkoperationen auf dem System erzeugte Last mithilfe einer Aufgabe zu identifizieren, die eine bekannte Last auf dem System erzeugt. Dies ist beispielsweise ein Befehl </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Testen der OpenSSL-Leistung. Auf diese Weise k√∂nnen Sie herausfinden, wie viel Prozessorressourcen das Programm in der Realit√§t erh√§lt, und es mit der Menge der Ressourcen vergleichen, die es empfangen soll (dies hilft herauszufinden, wie viel Ressourcen f√ºr Netzwerkaufgaben ausgegeben werden).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Team ist </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast zu 100% ein User-Space-Team. Wenn Sie es an eine bestimmte CPU binden, verwendet es w√§hrend der Ausf√ºhrung von Tests alle verf√ºgbaren Ressourcen. Das Team stellt den Timer auf das angegebene Intervall ein (hier dauert es beispielsweise 10 Sekunden, um die Berechnungen zu vereinfachen), f√ºhrt den Test aus und ermittelt dann beim Ausl√∂sen des Timers </font></font><code>times</code><code>()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wie viel Prozessorzeit das Programm tats√§chlich hat. Aus der Sicht </font></font><code>syscall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sieht es so aus:</font></font><br>
<br>
<pre><code class="plaintext hljs">alarm(10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 0<font></font>
times({tms_utime=0, tms_stime=0, tms_cutime=0, tms_cstime=0}) = 1726601344<font></font>
--- SIGALRM {si_signo=SIGALRM, si_code=SI_KERNEL} ---<font></font>
rt_sigaction(SIGALRM, ...) = 0<font></font>
rt_sigreturn({mask=[]}) = 2782545353<font></font>
times({tms_utime=1000, tms_stime=0, tms_cutime=0, tms_cstime=0}) = 1726602344<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das hei√üt, es stellt sich heraus, dass zwischen dem Aufrufen </font></font><code>alarm()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und dem √úberpr√ºfen der Ergebnisse nur sehr wenige Systemaufrufe get√§tigt wurden. Wenn das Programm nicht oder nur sehr selten unterbrochen wurde, </font></font><code>tms_utime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stimmt </font><font style="vertical-align: inherit;">die Zeit </font><font style="vertical-align: inherit;">mit der Testzeit √ºberein (in diesem Fall 10 Sekunden). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da dies ein Test ist, der ausschlie√ülich im Benutzerbereich durchgef√ºhrt wird, bedeutet jede Systemzeit, die in angezeigt </font></font><code>times()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird, eine zus√§tzliche Belastung des Systems. Es stellt sich heraus, dass </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dies zwar ein Prozess ist, der auf der CPU ausgef√ºhrt wird, die CPU selbst jedoch m√∂glicherweise mit etwas anderem besch√§ftigt ist. Beispiel: Verarbeiten von Netzwerkpaketen:</font></font><br>
<br>
<pre><code class="plaintext hljs">alarm(10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 0<font></font>
times({tms_utime=0, tms_stime=0, tms_cutime=0, tms_cstime=0}) = 1726617896<font></font>
--- SIGALRM {si_signo=SIGALRM, si_code=SI_KERNEL} ---<font></font>
rt_sigaction(SIGALRM, ...) = 0<font></font>
rt_sigreturn({mask=[]}) = 4079301579<font></font>
times({tms_utime=178, tms_stime=571, tms_cutime=0, tms_cstime=0}) = 1726618896<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sehen Sie, dass es </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√∂glich war, 7,49 Sekunden am Prozessor zu arbeiten (178 + 571 in Ma√üeinheiten entsprechend 0,01 s). </font><font style="vertical-align: inherit;">Gleichzeitig aber 5,71 s. </font><font style="vertical-align: inherit;">Dieses Intervall wird durch die Systemzeit dargestellt. </font><font style="vertical-align: inherit;">Da er </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit keinem Gesch√§ft im Kernelbereich besch√§ftigt ist, bedeutet dies, dass 5,71 s. </font><font style="vertical-align: inherit;">- Dies ist das Ergebnis einer zus√§tzlichen Belastung des Systems. </font><font style="vertical-align: inherit;">Das hei√üt, dies ist die Zeit, in der der Prozess "gestohlen" wurde, um die Anforderungen des Systems zu erf√ºllen.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden des Befehls openssl speed zum Erkennen der Systemlast, die durch Netzwerkmechanismen verursacht wird</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir herausgefunden haben, wie das Team arbeitet </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, werden wir uns die Ergebnisse ansehen, die es auf einem praktisch inaktiven Server erzielt:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ taskset -c 5 openssl speed -seconds 10 aes-256-cbc &gt;/dev/null<font></font>
Doing aes-256 cbc for 10s on 16 size blocks: 66675623 aes-256 cbc's in 9.99s<font></font>
Doing aes-256 cbc for 10s on 64 size blocks: 18096647 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 256 size blocks: 4607752 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 1024 size blocks: 1162429 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 8192 size blocks: 145251 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 16384 size blocks: 72831 aes-256 cbc's in 10.00s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen k√∂nnen, wird uns mitgeteilt, dass das Programm 9,99 bis 10 Sekunden ben√∂tigt, um Bl√∂cke unterschiedlicher Gr√∂√üe zu verarbeiten. Dies best√§tigt, dass Systemmechanismen dem Programm keine Prozessorzeit entziehen. Mit </font></font><code>netperf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird nun der Server geladen, indem Pakete aus zwei Quellen verarbeitet werden. F√ºhren Sie den Test erneut aus:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ taskset -c 5 openssl speed -seconds 10 aes-256-cbc &gt;/dev/null<font></font>
Doing aes-256 cbc for 10s on 16 size blocks: 12061658 aes-256 cbc's in 1.96s<font></font>
Doing aes-256 cbc for 10s on 64 size blocks: 3457491 aes-256 cbc's in 2.10s<font></font>
Doing aes-256 cbc for 10s on 256 size blocks: 893939 aes-256 cbc's in 2.01s<font></font>
Doing aes-256 cbc for 10s on 1024 size blocks: 201756 aes-256 cbc's in 1.86s<font></font>
Doing aes-256 cbc for 10s on 8192 size blocks: 25117 aes-256 cbc's in 1.78s<font></font>
Doing aes-256 cbc for 10s on 16384 size blocks: 13859 aes-256 cbc's in 1.89s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ergebnisse unterscheiden sich stark von denen auf einem inaktiven Server. Es wird erwartet, dass jeder der Tests innerhalb von 10 Sekunden ausgef√ºhrt wird, es wird jedoch </font></font><code>times()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berichtet, dass die tats√§chliche Ausf√ºhrungszeit zwischen 1,78 und 2,1 Sekunden liegt. Dies bedeutet, dass die verbleibende Zeit zwischen 7,9 und 8,22 Sekunden f√ºr die Verarbeitung der Pakete aufgewendet wurde, entweder im Kontext des Prozesses </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder in </font></font><code>ksoftirqd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Werfen wir einen Blick darauf, was das Team </font></font><code>top</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bei der Analyse des gerade abgeschlossenen Starts herausgeben wird </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="plaintext hljs">PID USER&nbsp; &nbsp; &nbsp; PR&nbsp; NI&nbsp; &nbsp; VIRT&nbsp; &nbsp; RES&nbsp; &nbsp; SHR S&nbsp; %CPU %MEM &nbsp; &nbsp; TIME+ COMMAND&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P&nbsp;<font></font>
&nbsp;8180 libvirt+&nbsp; 20 &nbsp; 0 33.269g 1.649g 1.565g S 279.9&nbsp; 0.9&nbsp; 18:57.81 qemu-system-x86 &nbsp; &nbsp; 75<font></font>
&nbsp;8374 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 R&nbsp; 99.4&nbsp; 0.0 &nbsp; 2:57.97 vhost-8180&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 89<font></font>
&nbsp;1684 dahern&nbsp; &nbsp; 20 &nbsp; 0 &nbsp; 17112 &nbsp; 4400 &nbsp; 3892 R&nbsp; 73.6&nbsp; 0.0 &nbsp; 0:09.91 openssl&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;38 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 R&nbsp; 26.2&nbsp; 0.0 &nbsp; 0:31.86 ksoftirqd/5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier k√∂nnte man denken, dass es </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ungef√§hr 73% der Ressourcen von CPU 5 verbraucht und die </font></font><code>ksoftirqd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verbleibenden Ressourcen erhalten werden. </font><font style="vertical-align: inherit;">In der Realit√§t wird jedoch im Kontext die </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verarbeitung einer so gro√üen Anzahl von Paketen durchgef√ºhrt, dass das Programm selbst nur 18 bis 21% der Prozessorzeit ben√∂tigt, um seine Probleme zu l√∂sen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie die Netzwerklast auf 1 Stream reduzieren, haben Sie </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das </font><font style="vertical-align: inherit;">Gef√ºhl, dass </font><font style="vertical-align: inherit;">99% der Systemressourcen verbraucht werden.</font></font><br>
<br>
<pre><code class="plaintext hljs">&nbsp;&nbsp;PID USER&nbsp; &nbsp; &nbsp; PR&nbsp; NI&nbsp; &nbsp; VIRT&nbsp; &nbsp; RES&nbsp; &nbsp; SHR S&nbsp; %CPU %MEM &nbsp; &nbsp; TIME+ COMMAND&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P<font></font>
&nbsp;8180 libvirt+&nbsp; 20 &nbsp; 0 33.269g 1.722g 1.637g S 325.1&nbsp; 0.9 166:38.12 qemu-system-x86 &nbsp; &nbsp; 29<font></font>
44218 dahern&nbsp; &nbsp; 20 &nbsp; 0 &nbsp; 17112 &nbsp; 4488 &nbsp; 3996 R&nbsp; 99.2&nbsp; 0.0 &nbsp; 0:28.55 openssl&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5<font></font>
&nbsp;8374 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 R&nbsp; 64.7&nbsp; 0.0&nbsp; 60:40.50 vhost-8180&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 55<font></font>
&nbsp;&nbsp;&nbsp;38 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 S &nbsp; 1.0&nbsp; 0.0 &nbsp; 4:51.98 ksoftirqd/5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Wirklichkeit stellt sich jedoch heraus, dass das im Benutzerbereich ausgef√ºhrte Programm von den erwarteten 10 Sekunden nur etwa 4 Sekunden erh√§lt:</font></font><br>
<br>
<pre><code class="plaintext hljs">Doing aes-256 cbc for 10s on 16 size blocks: 26596388 aes-256 cbc's in 4.01s<font></font>
Doing aes-256 cbc for 10s on 64 size blocks: 7137481 aes-256 cbc's in 4.14s<font></font>
Doing aes-256 cbc for 10s on 256 size blocks: 1844565 aes-256 cbc's in 4.31s<font></font>
Doing aes-256 cbc for 10s on 1024 size blocks: 472687 aes-256 cbc's in 4.28s<font></font>
Doing aes-256 cbc for 10s on 8192 size blocks: 59001 aes-256 cbc's in 4.46s<font></font>
Doing aes-256 cbc for 10s on 16384 size blocks: 28569 aes-256 cbc's in 4.16s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Herk√∂mmliche Prozess√ºberwachungstools weisen darauf hin, dass das Programm fast alle Prozessorressourcen verwendet. In Wirklichkeit werden jedoch 55-80% der CPU-Ressourcen f√ºr die Verarbeitung von Netzwerkpaketen ausgegeben. </font><font style="vertical-align: inherit;">Der Durchsatz des Systems sieht gleichzeitig gut aus (mehr als 22 Gbit / s pro 25 Gbit / s Leitung), dies hat jedoch enorme Auswirkungen auf die in diesem System ausgef√ºhrten Prozesse.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassung</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier haben wir ein Beispiel untersucht, wie Paketverarbeitungsmechanismen Prozessortakte von einem einfachen und nicht sehr wichtigen Benchmark ‚Äûstehlen‚Äú. </font><font style="vertical-align: inherit;">Auf einem realen Server k√∂nnen Prozesse, die in √§hnlicher Weise betroffen sind, alles sein. </font><font style="vertical-align: inherit;">Dies k√∂nnen virtuelle Prozessoren, Emulator-Threads und vhost-Threads von virtuellen Maschinen sein. </font><font style="vertical-align: inherit;">Dies k√∂nnen unterschiedliche Systemprozesse sein, deren Auswirkungen sich unterschiedlich auf die Leistung dieser Prozesse und des gesamten Systems auswirken k√∂nnen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ber√ºcksichtigen Sie bei der Analyse Ihrer Server die Auswirkungen der mit dem Netzwerkbetrieb verbundenen Last auf deren tats√§chliche Leistung?</font></font></b><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/a_/bs/aa/a_bsaactpbr8fltzymtkhqbw1d4.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de503624/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 416 (18.-24. Mai 2020)</a></li>
<li><a href="../de503626/index.html">Testen. ISTQB-Zertifizierungsfehler oder l√∂sen eine Million Beispiele</a></li>
<li><a href="../de503630/index.html">Augmented Reality Brille: Wo stehen wir jetzt?</a></li>
<li><a href="../de503632/index.html">1000 und 1 Beitrag: Alles Gute zum Geburtstag, Habr ‚ù§</a></li>
<li><a href="../de503634/index.html">5 interessante JavaScript-Funde im Vue-Quellcode</a></li>
<li><a href="../de503638/index.html">6 n√ºtzliche Gewohnheiten, die √ºberraschenderweise nur wenige Programmierer haben</a></li>
<li><a href="../de503642/index.html">Wie komme ich auf LinkedIn, Facebook, Google im Silicon Valley?</a></li>
<li><a href="../de503650/index.html">VKCup 2020 Stufe I. Ein langer Weg</a></li>
<li><a href="../de503652/index.html">Digitale Veranstaltungen in Moskau vom 25. bis 31. Mai</a></li>
<li><a href="../de503654/index.html">Webdienst, mit dem Benutzer unabh√§ngig eine Online-Kommunikationskultur pflegen k√∂nnen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>